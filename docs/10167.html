<html>
<head>
<title>Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/recursion-ea2e3b35cb49?source=collection_archive---------17-----------------------#2022-01-16">https://medium.com/geekculture/recursion-ea2e3b35cb49?source=collection_archive---------17-----------------------#2022-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5513" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如果一个函数可以调用其他函数，那么它就可以调用自己。这叫做递归。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/4b6621c24605f427d71af3a76e572dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByLiFQ24LnTUaErZgzVoKQ.jpeg"/></div></div></figure><p id="2d01" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">根据维基百科的定义:</p><p id="70b6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="kg">递归是一种方法，其中问题的解决方案依赖于同一问题的较小实例的解决方案。</em></p><p id="a41d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我已经可以想象你的眼睛呆滞。让我们用一个电影院的类比来解释递归。</p><p id="904c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设你在一个电影院，那里的排是没有编号的。有人问你在哪一排。你不想数，所以你问你前面的人。他也不想数，所以他们问他们前面的人。这延续到前排的人。那个人看不到他们前面的人，所以他们告诉后面的人他在第一排。第二排的人在他的回答上加1，并告诉他后面的人他在第三排。这一直延续到最初提出问题的人。</p><p id="8d14" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">问题“我是第几排？”可以(递归地)重新表述为“我前面有多少人+ 1？”基本情况是零。</p><p id="7707" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="kg">如果一个函数可以调用其他函数，那么它就可以调用自己。这叫做递归。</em></p><p id="8d63" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">递归可能是解决大量问题的有用策略。当一个问题可以被定义为子问题的解决方案时，它工作得很好。</p><p id="0be1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">示例1 —阶乘</strong></p><p id="60e1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">什么是n！(n阶乘)？n！是n * (n-1) * (n-2) * … * 1。我们也可以说n！是n * (n-1)！。这导致计算n的代码非常短！。</p><p id="5d0a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">1.int factorial(int n) {</p><p id="7f8d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">2.if (n == 0或n == 1) { /*基本情况*/</p><p id="cc9f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">3.返回1；</p><p id="3bb0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">4.}否则{</p><p id="82f2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">5.返回n *阶乘(n-1)；</p><p id="4551" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">6. }</p><p id="a73f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">7. }</p><p id="069b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">基本情况(或终止条件)极其重要。没有它，函数将永远运行。</p><p id="3b99" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">内存使用量</strong></p><p id="e60e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">任何可以递归解决的问题也可以迭代解决(非递归地使用循环)，尽管有时这样做要复杂得多。然而，递归有一个缺点，那就是内存使用。</p><p id="b24f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">阶乘示例的内存使用量也是O(N)。factorial(n)方法调用factorial(n-1)，后者调用factorial(n-2)，依此类推。请注意，factorial(n)在factorial(n-1)完成之前不会完成，而factorial(n-1)在factorial(n-2)之前不会完成。</p><p id="2e7b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，在某个时间点，我们在“调用堆栈”上同时运行n个函数</p><p id="aadb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">阶乘(0)</p><p id="bea8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">阶乘(1)</p><p id="2fc2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">…</p><p id="c4ad" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">阶乘(n-1)</p><p id="f40b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">阶乘</p><p id="6ac7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">每一个都会占用一些内存。因此，在某个时间点，正在使用n个内存块。这意味着这个程序在递归实现时，时间和内存都是O(N)。</p><p id="9a8c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就是递归的缺点:递归调用占用内存。</p><p id="7138" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">示例2 —斐波那契数</strong></p><p id="d1ff" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">大家可能还记得，第n个斐波那契数f(n)是f(n-1) + f(n-2)。</p><p id="6ed4" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">1.int fibonacci(int n) {</p><p id="35eb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">2.if (n == 0) {</p><p id="936c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">3.返回0；</p><p id="0d63" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">4.} else if (n == 1) {</p><p id="2d87" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">5.返回1；</p><p id="0f06" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">6.}否则{</p><p id="750b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">7.返回斐波那契(n-1) +斐波那契(n-2)；</p><p id="4d8a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">8. }</p><p id="87c1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">9. }</p><p id="6bbf" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这是一个可以递归实现的自然函数，因为第n个斐波那契数是由它们较小的问题定义的。</p></div></div>    
</body>
</html>
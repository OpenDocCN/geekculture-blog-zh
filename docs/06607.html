<html>
<head>
<title>Introduction to C# Unit Testing in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity中的C#单元测试简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/c-unit-testing-in-unity-80d8bbfc62bb?source=collection_archive---------33-----------------------#2021-08-24">https://medium.com/geekculture/c-unit-testing-in-unity-80d8bbfc62bb?source=collection_archive---------33-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cdc5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">创建可靠的、可重用的测试来帮助快速开发</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b483d347a9e97d6b94137ba2df3e825f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDHST1UkGdsWTSYrsw22Og.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Be assertive!</figcaption></figure><p id="505b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最近我完成了一项挑战，将一个矩阵的元素顺时针或逆时针旋转45度。换句话说，我需要能够制作这个:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/8752ca12b3d2ed4379c8fc7981a83ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*HRi05wopmFjHayPfatHhcg.png"/></div></figure><p id="7b65" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">变成这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kk"><img src="../Images/283d275876fa94bcaec6c2823ad57029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Wrv4LHZgQuMc7FpzeBWAAA.png"/></div></figure><p id="7b95" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">或者这个:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kl"><img src="../Images/8d279ea35f875679115896422c77a7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*sYC2CKw2X1-g7h8I-i2D_Q.png"/></div></figure><p id="6192" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里有一个场景，在我写之前，我确切地知道我需要从方法中得到什么样的输出——这使它成为单元测试的完美候选。</p><p id="3d2b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">单元测试就像它听起来的那样。这是一个验证代码单元操作的测试。你可能熟悉使用Unity的<em class="km"> Debug。Log() </em>方法在开发过程中验证代码的运行。这是相似的，但是有几个额外的优点。</p><ul class=""><li id="870c" class="kn ko hi jp b jq jr jt ju jw kp ka kq ke kr ki ks kt ku kv bi translated">单元测试发生在方法本身之外。如果你改变方法，测试仍然有效，因为它不依赖于方法的内容。它只关心代码的输入/输出(如果有的话)或行为。</li><li id="1542" class="kn ko hi jp b jq kw jt kx jw ky ka kz ke la ki ks kt ku kv bi translated">单元测试可以在播放模式之外进行，不需要用户的任何输入。这使得快速到达您想要测试的点，并且反馈是即时的。</li><li id="2a2b" class="kn ko hi jp b jq kw jt kx jw ky ka kz ke la ki ks kt ku kv bi translated">您可以将您的测试组织成在同一游戏系统上运行的类似测试套件。如果其中一个失败，整个套件都会失败。</li></ul><p id="34ad" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看看如何使用Unity的Test Runner模块来创建和组织我们的单元测试。</p><p id="3dcc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">试跑者</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/7cbe62900c54f279e318865041b4d328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOIc7lgUOnK7ACgD5RpSNQ.png"/></div></div></figure><p id="5366" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当你第一次打开<em class="km">窗口&gt;常规&gt;测试运行器</em>时，你会看到类似上面的屏幕。有两个选项卡—一个用于播放模式测试，一个用于编辑模式。我将关注编辑模式，因为我想在不运行游戏的情况下运行我的测试。</p><p id="0014" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，点击<strong class="jp hj">创建编辑模式测试组件文件夹</strong>。这将创建一个新文件夹<em class="km">和</em>一个装配定义资产(。asmdef)文件。该文件跟踪对存储要测试的脚本的文件夹的引用。在我们开始之前，让我们点击<strong class="jp hj">在当前文件夹</strong>中创建测试脚本。以包含您想要测试的方法的类来命名这个脚本是一个很好的做法。因此，在我的例子中，我称它为RotateMatrixTests脚本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lc"><img src="../Images/b0162bec04ee5a4bbc8893b0a624d7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKavchV3pTH5CRpxUXlWuA.png"/></div></div></figure><p id="5db8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们还需要在RotateMatrix测试所在的文件夹中创建一个组装定义资产。为此，右击脚本文件夹并选择<em class="km">创建&gt;装配定义</em>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/b3d20df4fde2b79b552601e67287ad49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNhqnIn5Jj9rm6RU7SPaMg.png"/></div></div></figure><p id="ca7c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如你在上面看到的，我将我的命名为RotateMatrix.Scripts。</p><blockquote class="le lf lg"><p id="5e34" class="jn jo km jp b jq jr ij js jt ju im jv lh jx jy jz li kb kc kd lj kf kg kh ki hb bi translated">[项目名称]。[树中的第一个文件夹(不包括资产)]。[…根据需要在树中添加其他文件夹]</p></blockquote><p id="21a3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我的例子中，项目标题是Rotate Matrix，我测试的脚本在<em class="km"> Assets/Scripts/ </em>中。因此，我为该文件夹定义的程序集的名称是“RotateMatrix”。脚本"</p><p id="21cd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦创建了组装定义资产，返回到<em class="km"> Scripts/Tests/ </em>文件夹中的Tests.asmdef文件，并在检查器中查看它。在Assembly Definition References下，单击+号，并将刚刚在<em class="km">脚本/ </em>文件夹中创建的asmdef文件拖到插槽中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/6d5b96c1e562ef0ffaeb8d321a5b6ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UD_41AYkYKdxoWjDzEDcw.png"/></div></div></figure><p id="e6a1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，如果您遵循了所有这些步骤，您应该准备好打开RotateMatrixTests脚本并开始测试了！清除默认的测试方法，并创建一个以您想要测试的方法命名的新方法。我正在测试我的<em class="km"> RotateClockwise(int[，] matrix) </em>和<em class="km"> RotateCounterClockwise(int[，] matrix) </em>方法，所以我将调用这些<em class="km"> RotateClockwiseTest() </em>和<em class="km">RotateCounterClockwiseTest()</em>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/2b88a39efc643db85b757a9e49f396d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*514ymV2wdep61nWtiAq2JA.png"/></div></div></figure><p id="2564" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">请注意，每个都有[Test]属性。这告诉Unity在Test Runner窗口中显示这些测试。</p><p id="22aa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，为了运行顺时针旋转方法，我们需要为它提供一个2D数组来摆弄。所以我们首先需要定义这样一个数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/670d68d9c3fc3e286129f8292c180942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGGeIMuAuZ3be3jF9kpK6A.png"/></div></div></figure><p id="ee5f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，<em class="km">矩阵</em>变量定义如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/8752ca12b3d2ed4379c8fc7981a83ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*HRi05wopmFjHayPfatHhcg.png"/></div></figure><p id="1ad3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，我们需要获取场景中RotateMatrix脚本实例的引用，以便我们可以访问要测试的方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/b55ec95f94c3d9786b937db64b95a1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KOzfd21phz-viz6izS02w.png"/></div></div></figure><p id="de05" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后一个要素是调用<em class="km"> Assert() </em>类。这是保存检查输出的逻辑的类。我们期望什么样的产出？嗯，我们可以检查原始矩阵的两个角，并将它们与旋转后的矩阵中相应的目标点进行比较。如果值已经移动到我们期望的位置，那么旋转就成功了。</p><p id="dbfb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，最初包含在<em class="km">矩阵[0，0] </em>中的值应该等于<em class="km">结果[0，1] — </em>的值，也就是说，从它开始的地方向右一列。同样，原始矩阵在两个轴的最大值处的值应该等于结果矩阵在x轴的最大值处的值和y轴的最大值减去y轴的最大值——比开始时高一行。这里有一种编写断言来测试这些条件的方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/6770557d70bc12ef12fd96e80ffa8804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_m_erkCaHzb81muGBskKA.png"/></div></div></figure><p id="6254" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果这些条件中的任何一个失败，我们将在调试日志中得到哪个角不匹配的解释。</p><p id="5dd1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我现在准备尝试用我的RotateClockwise方法解决这个问题。我可以尝试任何数量的方法，并立即测试该方法，看看它是否给出了预期的输出。迭代这个问题变得1000%容易。</p><p id="1de6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你好奇，这是我最后想到的方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/52ee07b9da6d62210f312accabfc8c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bR6CeJrwBXc_ZnuQBAZ_Rg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The 3x2 Rotation Matrix can rotate Vector2 data around a center coordinate — perfect for rotating the indices of 2D arrays around the center of the array.</figcaption></figure><p id="76fa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当您准备好测试您的方法时，您需要做的就是在测试运行器中双击您想要运行的测试或测试套件(或者单击“Run All”来测试所有测试套件中的所有内容)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/78624edfa7442d2faeff1536dc89844e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cLM7IS202HI09jvKRe2cg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Hey, look! It works!</figcaption></figure><p id="46a7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如您所看到的，单元测试是充分利用您的键盘时间的有效方法。我希望这个单元测试的简要介绍对你有用！</p></div></div>    
</body>
</html>
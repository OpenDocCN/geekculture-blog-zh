<html>
<head>
<title>Managing UI With Kotlin Sealed Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin密封类管理UI</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/managing-ui-with-kotlin-sealed-classes-1ee674f1836f?source=collection_archive---------5-----------------------#2021-05-06">https://medium.com/geekculture/managing-ui-with-kotlin-sealed-classes-1ee674f1836f?source=collection_archive---------5-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/91b65a0d583f3e4e2687209e48af5689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlRNvHWdnQSVsmGrkaWgSA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@mreichelt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marc Reichelt</a> on <a class="ae iu" href="https://unsplash.com/s/photos/kotlin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fd5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大家好！我叫格里戈里，来自莫斯科的android开发人员。这是我第一篇关于android应用和kotlin密封类的文章。这是一个简单的例子。我希望有人会觉得有用，并会很高兴收到您的反馈和想法！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="ac1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将创建一个非常简单的android应用程序，向您展示用kotlin密封类管理UI的简单方法。我试图遵循基本清晰的架构和坚实的原则，但有些事情，如缺乏依赖注入，样板代码和其他小的限制，你会在这里看到在简化应用程序的情况。这篇短文的主要目的是展示我们如何使用kotlin密封类并以简单美观的方式管理我们的UI。</p><p id="d21b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先创建项目，打开app <strong class="ix hj"> build.gradle </strong>文件并添加这个。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="4173" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用协程和MVVM，但你可以选择RxJava，MVP等。现在我们需要在主活动xml中创建一些视图。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="ea4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个xml文件是为了展示主要思想而创建的，它远非完美。所以我们有三个主要视图:<strong class="ix hj">成功_布局</strong>、<strong class="ix hj">进度条</strong>和<strong class="ix hj">错误_布局</strong>。默认情况下，他们的可见性是<strong class="ix hj">消失</strong>。</p><p id="1991" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是创建MainScreenState类。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="35ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个密封类的所有子类在编译时都是已知的，所以<strong class="ix hj"> when </strong>表达式帮助我们写出清晰易懂的代码。</p><p id="2a12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要为测试创建数据类。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="2654" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的业务逻辑都在一个视图模型中。这是一个生命周期感知类，帮助我们存储和管理在屏幕旋转等配置更改后仍然存在的数据。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="8edc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在MainViewModel类中，我们有一个存储库。在大型应用程序中，我们通常需要一个中间层，如interactor或用例，来分离逻辑和责任，但是一个存储库对我们来说已经足够了。一个好的解决方案是通过dagger、koin或其他依赖注入框架在视图模型中注入存储库。</p><p id="4ed6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个属性是defaultError字符串。不要在真实的app里做。一个好主意是注入一个定制的资源管理器类，它有一个上下文，可以在视图模型中正确地获取资源。</p><p id="9c8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的数据持有者是一个可变的动态数据。我们可以很容易地从活动或片段中观察到它，并向用户显示实际数据。</p><p id="92ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看主要的<strong class="ix hj"> fetchData </strong>方法。首先，我检查屏幕状态值。如果它已经<strong class="ix hj">成功</strong>在我们的情况下我们不需要继续加载。这真的是一个非常简单的例子。否则，我将通过加载状态来改变屏幕状态，以显示用户挂起并尝试从存储库中获取数据。当我们向服务器或数据库请求数据时，我们几乎总是需要进行阻塞操作。这里我使用协程和viewModelScope扩展。在这段代码中，我可以调用挂起函数——协程的主要思想。<strong class="ix hj">延迟</strong>有助于我们测试UI，但不要在真实的实践中这么做。所有的合成负载和期望都是一个糟糕的决定。作为开发人员，我们必须尽可能快地向用户展示信息和数据。最好的解决方案是存储和显示来自缓存的数据，同时从服务器下载。下一步很明显——如果我们得到了结果，我们显示<strong class="ix hj">成功</strong>，如果没有，我们显示<strong class="ix hj">错误</strong>。</p><p id="12e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看仓库。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="1144" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该使用接口并在实现中隐藏它们的逻辑，以创建维护良好的应用程序。MainApi是一个对象——匿名类，用单一方法实现接口。它可以是改型、数据库或其他来源。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="48c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MainRepositoryImpl的<strong class="ix hj"> getData </strong>方法随机从api返回用户或者抛出异常。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="d8f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常我使用视图绑定特性来与视图交互，但是这里有一个旧的<strong class="ix hj"> findViewById </strong>解决方案。首先，我们向ViewModelProvider请求我们的主视图模型。如果它存在，我们得到一个保存了所有数据的模型，如果不存在，我们得到一个新的模型。在这之后，我开始观察屏幕状态的实时数据。因为屏幕状态实时数据的类型是我们的密封类，所以当没有else分支的表达式时，我们可以使用<strong class="ix hj">。我们绝对肯定只能得到这三个子类中的一个。在这里，我隐藏或显示主要视图，如成功布局，进度条和错误布局。</strong></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="58b2" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">结论</h2><p id="48a1" class="pw-post-body-paragraph iv iw hi ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">Android开发中的密封类帮助我们管理UI，编写清晰易懂的代码。但是当我们谈论一个有许多屏幕的大型项目时，这个应用程序的设计有一个很大的缺陷。这个大纰漏的名字是违反干原则的。每一个新的屏幕都迫使我们编写重复的代码。如果您喜欢这篇文章，我将创建一篇新文章，向您展示如何优雅地避免代码重复。感谢阅读！以下是<a class="ae iu" href="https://github.com/Sosorevgm/android-ui-sealed-classes" rel="noopener ugc nofollow" target="_blank">该项目的完整代码</a>:<a class="ae iu" href="https://github.com/Sosorevgm/android-ui-sealed-classes" rel="noopener ugc nofollow" target="_blank">https://github.com/Sosorevgm/android-ui-sealed-classes</a></p></div></div>    
</body>
</html>
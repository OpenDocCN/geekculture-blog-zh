<html>
<head>
<title>How to Load Test a Machine Learning API in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python对机器学习API进行负载测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/load-testing-a-ml-model-api-e48ec0a0dffc?source=collection_archive---------3-----------------------#2021-02-24">https://medium.com/geekculture/load-testing-a-ml-model-api-e48ec0a0dffc?source=collection_archive---------3-----------------------#2021-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c371" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过使用Flask和Locust对Python中的API进行负载测试，了解如何放心地将ML模型部署到生产环境中</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2e0f3ed9eed135782baecbbaf2640fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZdJl9NOBgocIjH_1K5y7g.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@danist07" rel="noopener ugc nofollow" target="_blank">Danist</a> on <a class="ae jn" href="https://unsplash.com/photos/8Gg2Ne_uTcM" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c48a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">自信地部署</h1><p id="7f73" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">将机器学习(ML)模型部署为由业务关键型系统使用或直接由最终用户使用的实时服务可能是一个可怕的前景。系统的需求越大，你的模型出现问题破坏系统的风险就越高。然而，你也不能把你的模型困在笔记本里。他们需要为你的客户和你的企业创造价值。</p><p id="f7af" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">有很多方法可以减轻这些焦虑。一种方法(理论上)很简单:拥有一个健壮的测试策略。最终，有效的测试策略可以帮助您在ML系统中建立更高程度的信心。事实上，就像任何其他软件系统一样，你应该将深思熟虑的测试策略视为任何ML系统部署的必要先决条件。</p><p id="0788" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然而，您所采用的测试策略和技术将根据您的系统被开发和部署的环境而有所不同。对于部署为某种形式的web服务(例如REST API)的软件系统来说，一个特别重要的技术是<em class="lh">负载测试</em>的思想。而且，如果你没有猜到这一页的标题，这就是这篇文章的主题:负载测试ML模型API。</p><p id="9a68" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这里的目的是让您熟悉负载测试背后的动机和概念，回顾负载测试可以用来探索的一些重要的设计考虑事项，并提供一个简短的示例，说明如何对作为基本web应用程序部署的Scikit-Learn模型(包括模板存储库)进行负载测试。</p><h1 id="e69a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">什么是负载测试？</h1><p id="efcc" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们从一般的软件工程观点开始。大多数现代网站至少有一些对外部web服务的依赖。这些服务从通知管理器到分析工具，再到认证和支付服务等核心基础设施。</p><p id="6851" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当对这些服务进行更改时，确保系统不被中断是很重要的。这对于高流量平台尤其重要，因为服务停机或中断会导致重大财务损失。当您部署新服务(或更新现有服务)时，您希望确信您的服务能够承受“真实世界”的需求。</p><p id="b078" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这就是负载测试派上用场的地方。负载测试是<a class="ae jn" href="https://en.wikipedia.org/wiki/Non-functional_testing" rel="noopener ugc nofollow" target="_blank">非功能测试</a>的一种形式:它的目的是测试系统行为，而不是系统功能的细节。换句话说，负载测试的目的是探索您的服务在负载下如何响应——顾名思义。具体来说，它可用于在不同负载和不同操作条件下(包括不同类型的用户和用户行为)表征您的系统。根据您使用的框架或工具，您通常可以对这些条件和行为进行细粒度的控制，并定制您自己的测试来反映特定于您的服务的交互动态。</p><p id="0fe3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这里的目的是证明在您指定的条件下，您的服务可以<em class="lh">保持</em>期望的性能特征。但是你问有什么性能特点呢？通常，负载测试关注两个关键指标:<em class="lh">延迟</em>和<em class="lh">吞吐量</em>。让我们来定义这些:</p><ul class=""><li id="6899" class="li lj hi ki b kj lc km ld kp lk kt ll kx lm lb ln lo lp lq bi translated"><strong class="ki hj">延迟</strong> —服务响应所需的时间。它通常也被称为响应时间。它通常以毫秒(ms)为单位。延迟非常低的服务可以被描述为<em class="lh">高响应</em>。</li><li id="98a9" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><strong class="ki hj">吞吐量</strong> —在给定的时间范围内，服务可以处理的请求总数。例如，每秒请求数(RPS)是量化吞吐量特性的常用指标。</li></ul><p id="1ec6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">此外，与任何工程问题一样，描述系统的局限性也很重要。除了有助于确定服务可以支持预期的需求和性能约束之外，负载测试还可以(也应该)用于了解服务的上限。这有助于确定在什么条件下您的服务开始降级(并最终完全失败)。有了这类信息，您可以更自信地将您的服务部署到“生产”中，并且还可以了解随着您的服务的扩展，它可能会如何执行——在当前<em class="lh">和</em>随着对您的服务的需求的增长(希望如此)。</p><h1 id="4c46" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">这和ML有什么关系？</h1><p id="991e" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">到目前为止，一切顺利。让我们把它映射回一个具体的ML问题。假设你是一家经营在线市场的公司的数据科学家。您的任务是创建一个定价模型，以帮助市场用户更有竞争力地为他们销售的产品定价。您已经构建了模型，执行了各种评估任务，现在您已经准备好进行部署了。在仔细考虑了您的选择之后，您决定将您的模型作为一个简单的HTTP web服务部署到您的工程团队(和内部服务！)在其他功能中使用。对你来说，这正是这篇文章要解决的情况。</p><p id="48de" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">与任何类似的服务一样，你需要问自己的第一个问题是:“这项服务的响应速度是否足以确保良好的用户体验？”。这可以通过多种方式进行分解，但由此产生的一些自然问题包括:</p><ul class=""><li id="4fab" class="li lj hi ki b kj lc km ld kp lk kt ll kx lm lb ln lo lp lq bi translated">您的服务是否有足够的“物理”资源(CPU、RAM等)。)来支持您的预期(和“激增”)使用？</li><li id="4533" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">你的系统设计有瓶颈吗？仔细考虑您依赖的其他服务，特别是在负载下可能出现的任何速率限制或并发限制。</li><li id="90ce" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">是否存在响应性较差的行为或请求类型？考虑您的模型如何执行推理，以及是否值得添加额外的约束来限制用户为了保证性能而可以发出的请求类型。</li></ul><p id="ac1f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在这一点上，同样值得认识到的是，不仅要考虑你的“<a class="ae jn" href="https://en.wikipedia.org/wiki/Happy_path" rel="noopener ugc nofollow" target="_blank">幸福之路</a>”(即预期的“正常”行为)也很重要。例如，您应该确保在出现错误的情况下提出上述问题:如果您将一堆无效查询添加到混合查询中，您的系统会发生什么情况？当您的服务收到无效查询时，它会突然挂起并阻止进一步的请求吗？还是快速优雅地处理错误？</p><p id="aeec" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">确保您的负载测试策略能够回答诸如此类的问题是很重要的。对立地思考如何测试系统的设计和实现(包括ML方面)是值得的——不仅仅是在负载测试环境中！</p><h1 id="a016" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">实践中的负载测试</h1><p id="1929" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">希望你现在已经接受了负载测试的效用。也许你正在思考这与你自己的工作有什么关系。也许你已经在用这种方式思考你的ML项目了，在这种情况下:干得好！</p><p id="8b1f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如你可能意识到的，有各种各样的工具用于软件测试，负载测试的子领域也不例外。然而，这些工具的用户友好性是……可变的。其中一个对用户更友好的工具是<a class="ae jn" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">蝗虫</a>，尤其是对大多数数据科学家来说。Locust是一个负载测试工具和框架，使用Python编写和控制。</p><p id="4300" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">实际上，这意味着您可以用纯Python定义您的测试(包括定义模拟的客户行为)。您用Python编写您的用户行为，指定您想要模拟的用户数量，然后您就可以开始了！此外，作为一名数据科学家，即使你不是“超级用户”，你也有可能至少熟悉Python。我自己的经验表明，在实践中，Locust是此类工具中门槛最低的工具之一，它可以为数据科学/ML团队带来相关的采用和合规性优势。</p><p id="9865" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">也不仅仅是<em class="lh">简单易用。它也可以扩展到大型应用程序。例如，据报道，DICE (战地视频游戏系列fame)的人们<a class="ae jn" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">用它来负载测试他们的服务器，谷歌</a><a class="ae jn" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">和微软</a>的各个团队也用它。</em></p><p id="58e2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">除了Pythonic式设计提供的易用性，Locust还提供了几个有用的附加特性。首先，它允许您以CSV格式导出测试的统计数据，以供进一步分析或存档。这可能是跟踪负载测试实验的一种简便的低技术方法。</p><p id="1230" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">另一方面，它也有一个简单但信息丰富的用户界面(UI)。开箱即用，UI允许您配置您想要模拟的用户数量，指向您想要测试的主机，并设置您想要将用户添加到模拟中的速率，并立即启动您的测试套件。</p><p id="f074" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">运行时，UI提供了几个选项卡，为您提供一系列信息，从列表统计、延迟、吞吐量和用户数的“实时”图表，到测试发现的故障和错误的详细信息。对于具有单一路由(<code class="du lw lx ly lz b">/</code>)的服务的最小情况，统计数据的顶级列表视图如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/62952a9043027bdf7b4fc82694db4f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XaT4aXpKcRIZ5BrA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">A minimal example of the Locust dashboard for an API with a single endpoint. Image by author.</figcaption></figure><p id="54a0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如您所见，您可以获得服务当前正在处理的每秒请求数(RPS)的信息(即顶级吞吐量统计)。您还可以获得平均、中间、最小和最大延迟的统计数据(都以毫秒为单位)。当考虑测试中的每条路线时，这些信息可以让您对系统在负载下的行为有一个惊人的全面了解——这正是您想要的。也有一些漂亮的“实时”图表显示这些信息:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/0d0a7b10335dde1b478896c099e0059d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wjOHOOY5qjUGe4AS.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">An example of the real-time monitoring dashboard provided by Locust. Image by author.</figcaption></figure><p id="eba6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这是蝗虫在30000英尺高的视角。是时候用一个具体的例子来使用它了！</p><h1 id="51bc" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">正在设置</h1><p id="c31a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">密码时间到了。这篇文章的其余部分将向您展示如何配置一个基本的负载测试设置，该设置演示了上面概述的关于本地机器上的最小ML API的一些想法。我整理的示例项目包括一些用于部署到您最喜欢的云提供商的实用程序，负载测试API的一般过程对于部署的服务也是一样的，尽管部署设置的实际过程超出了本文的范围。也就是说，这个过程与我之前的帖子非常相似，在这里:</p><div class="mb mc ez fb md me"><a href="https://mark.douthwaite.io/getting-production-ready-a-minimal-flask-app/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">生产中的Flask:最小的Web APIs</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">Flask是一个流行的用Python构建web APIs的“微框架”。然而，将一个Flask API“投入生产”…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">马克·道斯韦特</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms jh me"/></div></div></a></div><p id="5e53" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">首先，最基本的。我决定在本教程中使用<a class="ae jn" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>,因为它有一个很棒的社区(至少在我看来),功能丰富且易于使用。另外，它被用于各种各样的项目中，所以掌握好Flask <em class="lh">可能比Python中的其他web框架更有用。</em></p><p id="c36a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">也就是说，如果你正在寻找Flask的替代品，你最好看一看<a class="ae jn" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>，这是一个较新的“微网络框架”，填补了Flask的类似空白，但在设计上侧重于速度。通过扩展，如果API的响应是最重要的，那么<em class="lh">可能是</em>更好的起点。否则，Flask很可能是一个强有力的赌注！</p><div class="mb mc ez fb md me"><a href="https://fastapi.tiangolo.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">FastAPI</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">FastAPI框架，高性能，简单易学，快速编码，准备生产文档…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">fastapi.tiangolo.com</p></div></div><div class="mn l"><div class="mt l mp mq mr mn ms jh me"/></div></div></a></div><p id="8414" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于本演练，您需要熟悉示例项目存储库:</p><div class="mb mc ez fb md me"><a href="https://github.com/markdouthwaite/sklearn-flask-api-demo" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">markdouthwaite/sk learn-flask-API-demo</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">这个模板库为“生产就绪”的Flask API Scikit-Learn项目提供了一个最小的配置。它…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">github.com</p></div></div><div class="mn l"><div class="mu l mp mq mr mn ms jh me"/></div></div></a></div><p id="eb5e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">要使用这个库，您应该<a class="ae jn" href="https://docs.github.com/en/github/getting-started-with-github/fork-a-repo" rel="noopener ugc nofollow" target="_blank">派生库</a>(您也可以<a class="ae jn" href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-from-a-template" rel="noopener ugc nofollow" target="_blank">从模板</a>创建您自己的版本)并将它<a class="ae jn" href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository" rel="noopener ugc nofollow" target="_blank">克隆到您的工作环境中。您还需要确保您正在运行<strong class="ki hj"> Python 3.7或更高版本</strong>来运行代码。如果您确实从模板创建了您的项目，请确保在这样做之前选中<code class="du lw lx ly lz b">Include all branches</code>框！</a></p><p id="6bdd" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">都准备好了吗？太棒了。是时候安装一些依赖项了。为此，导航到新下载的项目并运行以下命令:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="4f10" class="mz jp hi lz b fi na nb l nc nd">make develop</span></pre><p id="6478" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这将安装您的模型API <em class="lh">和</em>开发依赖项的需求，包括测试包和样式工具(例如优秀的<a class="ae jn" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">黑色</a>和<a class="ae jn" href="https://github.com/PyCQA/isort" rel="noopener ugc nofollow" target="_blank"> isort </a>包)。</p><h1 id="cc49" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">盒子里是什么？</h1><p id="92e5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">下一个明显的问题是:你刚刚下载了什么？谢谢关心。如前所述，这个项目的结构在很大程度上与其派生的<a class="ae jn" href="https://github.com/markdouthwaite/minimal-flask-api" rel="noopener ugc nofollow" target="_blank"> vanilla Flask项目</a>中定义的结构相同。如果你还没有看过，我建议你看看贯穿其中的博客文章。</p><p id="75a0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">上面的“香草”烧瓶项目和我们现在看到的这个<code class="du lw lx ly lz b">scikit-learn</code>口味的有几个关键的区别。这些区别主要是添加了以下目录:</p><ul class=""><li id="008e" class="li lj hi ki b kj lc km ld kp lk kt ll kx lm lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">data</code> -对于这个例子，这是任何数据(包括中间产品，如模型和模型度量)将被存储的地方。默认情况下，它存储一个数据集(<code class="du lw lx ly lz b">heart-disease.csv</code>，来自<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>)和一个示例<code class="du lw lx ly lz b">payload.json</code>，为您将要部署的API提供一个说明性的请求负载。在实践中，你应该考虑使用一个专用的云存储服务来存储所有的数据和工件(比如谷歌<a class="ae jn" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">云存储</a>或者<a class="ae jn" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> AWS S3 </a>)。</li><li id="ede7" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">steps</code> -这是<em class="lh">训练</em>、<em class="lh">评估</em>和<em class="lh">监控</em>模型所需的任何(自动)步骤应该位于的位置。实际上，该目录可能包含多个Python脚本，每个脚本都用于训练、评估和验证您的模型和输出。然而，在这个例子中，它只包含一个训练简单的<code class="du lw lx ly lz b">scikit-learn</code>分类器管道的<code class="du lw lx ly lz b">train.py</code>脚本。</li></ul><p id="4705" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">你可能还注意到Flask应用程序代码也略有不同，并且<em class="lh">与我之前整理的相关教程非常相似:</em></p><div class="mb mc ez fb md me"><a href="https://github.com/markdouthwaite/serverless-scikit-learn-demo" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">markdouthwaite/无服务器-scikit-learn-demo</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">为部署轻量级Scikit提供建议的项目结构和简单设计模式的存储库-了解…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">github.com</p></div></div><div class="mn l"><div class="ne l mp mq mr mn ms jh me"/></div></div></a></div><p id="8050" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">接下来，您需要创建一个您的API可以加载和公开的<a class="ae jn" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank">酸洗</a>模型工件。为此，只需运行:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="27ce" class="mz jp hi lz b fi na nb l nc nd">python steps/train.py --path=data/heart-disease.csv</span></pre><p id="c719" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这将在<a class="ae jn" href="https://archive.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank">UCI心脏病数据集</a>上训练一个<a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn管道</a>，对其进行处理并将其导出到<code class="du lw lx ly lz b">data</code>目录(以及一些重要的元数据)。请随意深入<code class="du lw lx ly lz b">steps/train.py</code>文件，以便更好地了解这里发生了什么。</p><h1 id="c2fa" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">启动模型服务器</h1><p id="c20c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在继续之前，有必要检查一下您的模型服务器是否配置正确并且可以运行。要在本地运行模型服务器(公开您的API)，您只需运行:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="258c" class="mz jp hi lz b fi na nb l nc nd">make start</span></pre><p id="8c1d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在项目的顶层目录中。这将创建一个运行Flask应用程序的<code class="du lw lx ly lz b">gunicorn</code>服务器。然后，您应该能够发送查询:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="7a71" class="mz jp hi lz b fi na nb l nc nd">curl <a class="ae jn" href="http://localhost:8080/health" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/health</a></span></pre><p id="642b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">看看人们的反应:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="0eca" class="mz jp hi lz b fi na nb l nc nd">OK</span></pre><p id="19a7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">状态代码为200。要直接查询模型，您可以使用<code class="du lw lx ly lz b">data/payload.json</code>示例中的数据并发送:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="af88" class="mz jp hi lz b fi na nb l nc nd">curl --location --request POST 'http://localhost:8080/predict' --header 'Content-Type: application/json' -d @data/payload.json</span></pre><p id="e944" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">您应该会看到类似以下内容的响应:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="c30d" class="mz jp hi lz b fi na nb l nc nd">{"diagnosis":"heart-disease"}</span></pre><p id="11b0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这意味着你的模型是活的。您可以让模型服务器暂时运行，因为您需要它处于活动状态来运行Locust。</p><p id="a1e6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在要编写一两个负载测试…</p><h1 id="d65c" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">模拟用户行为</h1><p id="ab81" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">正如您之前看到的，负载测试的主要目标不是评估API <em class="lh">本身</em>的正确性(或者在ML上下文中:准确性/您选择的其他度量标准)。这是为了探索您的API在不同负载下的表现，了解API在所述负载下是否、何时、如何以及为什么开始降级，并最终根据这些信息将您的API部署到“生产”环境中。</p><p id="43c0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">实际上，第一步是定义你期望用户如何与你的服务交互。对于具有单个端点的API，这个<em class="lh">可能</em>只是一种交互类型。事实上，它<em class="lh">应该</em>是单一类型的交互(例如查询单一模型)。这个例子就是这种情况。然而，如果你开发一个更完整的API，比如说一个有很多端点的成熟的REST API，可能的用户交互数量可能会大得多。</p><p id="0424" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在Locust的世界中，以编程方式定义用户行为非常简单。这个框架提供了一个<code class="du lw lx ly lz b">User</code>类，你可以用它来构建你的行为。此外，由于这是建立在纯Python之上的，它确保您可以用非常复杂的行为来定义用户，如果您愿意的话。这里有一个最小蝗虫<code class="du lw lx ly lz b">User</code>的例子:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="f2c6" class="mz jp hi lz b fi na nb l nc nd">from locust import HttpUser, task </span><span id="5aa6" class="mz jp hi lz b fi nf nb l nc nd">class SimpleUser(HttpUser): <br/>    @task <br/>    def get_health(self): <br/>        self.client.get("/health")</span></pre><p id="7747" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这是什么？在这个例子中，您有一个来自所提供的<code class="du lw lx ly lz b">HttpUser</code>类的用户，并且定义了一个<code class="du lw lx ly lz b">task</code>行为，在这个例子中是<code class="du lw lx ly lz b">get_health</code>。以下是这些事情的具体含义:</p><ul class=""><li id="5f37" class="li lj hi ki b kj lc km ld kp lk kt ll kx lm lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">HttpUser</code>-<code class="du lw lx ly lz b">HttpUser</code>类是Locust <code class="du lw lx ly lz b">User</code>的一个特殊子类，它提供对<code class="du lw lx ly lz b">client</code>属性的访问。这个<code class="du lw lx ly lz b">client</code>属性反过来提供了一个可以用来查询API的HTTP客户机(当然，前提是它公开了一个HTTP接口！).注意，在这个文件中没有任何地方引用了API的基本URL。这是在运行时通过Locust CLI或从Locust web UI中提供给Locust的。我们稍后再看。</li><li id="7ee1" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">这个方法定义了你想要为你的API模拟的用户行为。在这种情况下，只需向<code class="du lw lx ly lz b">/health</code>路线发送一个<code class="du lw lx ly lz b">GET</code>请求。换句话说，检查<code class="du lw lx ly lz b">GET /health</code>端点是否以非错误状态代码响应。<code class="du lw lx ly lz b">client</code>属性公开了一个全功能的HTTP客户端，因此您能够向您选择的服务发送任意的HTTP请求。您可以在每个方法中使用<code class="du lw lx ly lz b">client</code>进行多次调用，这意味着如果需要，您可以构建任意复杂的用户流。</li><li id="a646" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">task</code> -这个<em class="lh">装饰器</em>将它关联的方法标记为任务。这告诉Locust在测试过程中初始化<code class="du lw lx ly lz b">User</code>时执行该方法。您可以用这个装饰器标记任意多的方法，因此一个<code class="du lw lx ly lz b">User</code>可以定义多个<code class="du lw lx ly lz b">task</code>，实际上，这允许您构建更复杂的用户行为，正如您可能看到的。</li></ul><p id="8552" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果你查看<code class="du lw lx ly lz b">tests/load/locustfiles/api.py</code>文件，你会看到这个例子和那里提供的相似。但是，您可能会注意到这里介绍的最小案例和这个文件中的案例之间的一些区别。首先，在这个类上有一个设置为<code class="du lw lx ly lz b">between(1, 5)</code>的<code class="du lw lx ly lz b">wait_time</code>属性。这确保了Locust在<code class="du lw lx ly lz b">User</code>执行后续动作(或者用Locust术语来说:执行另一个<code class="du lw lx ly lz b">task</code>)之前会等待一秒到五秒的随机时间。此外，鉴于它是一个类变量，这是为蝗虫初始化的所有 <code class="du lw lx ly lz b">DefaultUser</code>类<em class="lh">配置的。</em></p><h1 id="c9dc" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">简短的警告</h1><p id="07e5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在继续一个稍微高级一点的案例之前，我想提出一个重要的概念点，根据我的经验，这个概念点与您应该如何着手为ML APIs设置蝗虫测试特别相关。Locust初始化您为每个被模拟的用户定义的每个<code class="du lw lx ly lz b">User</code>的一个实例。换句话说，如果您定义了一个<code class="du lw lx ly lz b">User</code>，并且您的负载测试模拟了100个并发用户，<em class="lh"> Locust将创建这个类</em>的100个实例。</p><p id="dbfa" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这对您如何创建自定义的<code class="du lw lx ly lz b">User</code>类有影响。例如，当定义测试ML模型API的用户行为时，加载历史数据作为样本负载来测试您的API可能很有诱惑力。这个<em class="lh">可能</em>又涉及为每个用户加载CSV作为<code class="du lw lx ly lz b">pandas</code>数据帧，潜在地导致为这一百个用户中的每一个初始化数据集。很明显，你需要仔细考虑这是否适合你的问题。有一些方法可以有效地测试你的API<em class="lh">而不需要</em>一次将大量数据加载到内存中并且(潜在地)使你的机器崩溃！</p><p id="d4db" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在让我们来看一个选项。</p><h1 id="d458" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">查询您的模型</h1><p id="766a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">好吧。你知道蝗虫的基本组成<code class="du lw lx ly lz b">User</code>。让我们再深入一点。最简单的情况是发送一个固定的有效负载来查询您的模型API。如果您还记得的话，在<code class="du lw lx ly lz b">data/payload.json</code>文件中有一个示例负载。如果我们基于该数据结构创建一个自定义用户，可能会是这样:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="ac8a" class="mz jp hi lz b fi na nb l nc nd">class FixedPayloadUser(HttpUser): <br/>    payload = { <br/>        "sex": 0, <br/>        "cp": 1, <br/>        "restecg": 0, <br/>        ... <br/>    } <br/>    @task <br/>    def get_diagnosis_with_valid_payload(self):<br/>        self.client.post("/predict", json=self.payload)</span></pre><p id="a022" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这个<code class="du lw lx ly lz b">User</code>然后将发送一个固定的有效载荷(由类变量<code class="du lw lx ly lz b">payload</code>定义)到<code class="du lw lx ly lz b">POST /predict</code>端点。很简单，对吧？这当然比什么都没有好，而且在许多情况下可能就足够了。然而，像这样的测试的效用显然会被API前面的任何缓存层所击败，并且所选择的有效负载可能不会像您所希望的那样扩展您的API。</p><p id="9e63" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这就是随机有效载荷有时能派上用场的地方。同样，我们对“绝对模型准确性”的概念并不特别感兴趣，而是对服务的吞吐量和弹性感兴趣，因此，如果随机有效负载不是“物理上合理的”(即，现实价值)，这通常不会有太大影响。此外，如果您的API <em class="lh">要求</em>查询在特定范围内，可以使用相同的方法，只需稍加修改，以确保您的服务器端验证如您所愿地工作。下面是一个如何为API设置随机查询的例子:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="0940" class="mz jp hi lz b fi na nb l nc nd">import random <br/>from dataclasses import dataclass, asdict </span><span id="1834" class="mz jp hi lz b fi nf nb l nc nd">random.seed(42) </span><span id="03ee" class="mz jp hi lz b fi nf nb l nc nd">@dataclass <br/>class Payload: <br/>    sex: int = random.randint(0, 1) <br/>    cp: int = random.randint(0, 3) <br/>    restecg: int = random.randint(0, 1) <br/>    ... # other attributes here. </span><span id="6c3e" class="mz jp hi lz b fi nf nb l nc nd">def iter_random_payloads() -&gt; dict: <br/>    while True: <br/>        yield asdict(Payload())</span></pre><p id="9cc8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然后，我们可以通过以下方式定义我们的用户行为:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="e454" class="mz jp hi lz b fi na nb l nc nd">from locust import HttpUser, between, task </span><span id="0efd" class="mz jp hi lz b fi nf nb l nc nd">class RandomizedPayloadUser(HttpUser): </span><span id="3232" class="mz jp hi lz b fi nf nb l nc nd">    # wait between requests from one user for between 1 and 5 seconds. <br/>    wait_time = between(1, 5) </span><span id="f644" class="mz jp hi lz b fi nf nb l nc nd">    def __init__(self, *args, **kwargs): <br/>        super().__init__(*args, **kwargs) <br/>        self.payloads = iter_random_payloads() </span><span id="4c1f" class="mz jp hi lz b fi nf nb l nc nd">    @task <br/>    def get_diagnosis_with_valid_payload(self): <br/>        payload = next(self.payloads) <br/>        self.client.post("/predict", json=asdict(payload))</span></pre><p id="acbe" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这种方法有几个好处。正如你所见，<code class="du lw lx ly lz b">iter_random_payloads</code>函数是一个Python <em class="lh">生成器</em>，它将产生无限多的随机<code class="du lw lx ly lz b">Payload</code>对象。在这篇文章中，我不打算深究生成器的优点和缺点，只想说生成器可以帮助你创建内存高效的迭代器。具体来说，在这种情况下，<code class="du lw lx ly lz b">RandomizedPayloadUser</code>的每个实例都会在内存中同时拥有一个<code class="du lw lx ly lz b">Payload</code>实例。</p><p id="2ca2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如前面提到的，当你有数百个(甚至数千个)这样的用户被初始化时，这是一个重要的考虑因素，因为它可以消除一次初始化大量潜在的非常大的有效载荷的需要(例如，如果你使用一个普通的Python <code class="du lw lx ly lz b">list</code>而不是一个生成器，你就会这样)。这可能<em class="lh">特别有助于</em>处理图像或类似大型数值数组的应用。</p><p id="1493" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在这一点上，我建议你将上面的片段复制到路径<code class="du lw lx ly lz b">tests/load/locustfiles/randomized.py</code>下的一个新文件中。完成这些后，您可以使用以下命令启动Locust:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="ee19" class="mz jp hi lz b fi na nb l nc nd">locust -f tests/load/locustfiles/randomized.py</span></pre><p id="2735" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">打开一个浏览器到<code class="du lw lx ly lz b">http://localhost:8089</code>(或者跟随终端中的链接)。系统将提示您提供要模拟的用户总数(即您希望运行的最大并发用户数)、生成率(即您希望从启动开始多快增加新用户)，最后是您的API的主机。由于这个例子是在本地运行的，您可以将它设置为<code class="du lw lx ly lz b">http://localhost:8080</code>(假设您使用了前面的<code class="du lw lx ly lz b">make start</code>命令)。点击<code class="du lw lx ly lz b">Start swarming</code>，你将被重定向到蝗虫仪表盘。过一会儿，您应该会看到类似这样的内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/b8f8a8e6a745ccd14bf090d4dea33f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kMj1k9dBxrB-oZjU.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">An example of a Locust dashboard for a live test against a locally-running model API. Image by author.</figcaption></figure><h1 id="8a16" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">变得敌对</h1><p id="d310" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">太好了！您已经针对您的模型API运行了一个简单的测试！对于这篇文章的其余部分，您将希望确保您已经提交了到目前为止所做的任何更改，然后您应该签出存储库的<code class="du lw lx ly lz b">locust-tests</code>分支。完成了吗？我们继续。</p><p id="b7e9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">负载测试的部分目标是描述您的服务在预期负载下的行为。如果你有工程思维，你会意识到这包括当一定比例的流量发送错误的请求，或者以你意想不到的方式运行时会发生什么。实际上，从反面思考用户可能如何与你的服务进行交互并相应地进行测试是非常有帮助的。</p><blockquote class="nh ni nj"><p id="2a25" class="kg kh lh ki b kj lc ij kl km ld im ko nk le kr ks nl lf kv kw nm lg kz la lb hb bi translated"><em class="hi">实际上，从反面思考用户可能如何与你的服务交互并相应地进行测试会非常有帮助。</em></p></blockquote><p id="00f3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">记住这一点，您可以以类似于前面所示的方式定义一个随机有效负载生成器，但是这一次您可以修改生成的有效负载以省略必需的字段，例如。这可能看起来有点像这样:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="8217" class="mz jp hi lz b fi na nb l nc nd">def iter_random_invalid_payloads() -&gt; dict: <br/>    fields = list(asdict(Payload()).keys()) <br/>    while True: <br/>        field = random.choice(fields) <br/>        payload = asdict(Payload()) <br/>        # missing field <br/>        del payload[field] <br/>        yield payload</span></pre><p id="63b4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">显然，您会认为畸形的有效负载会在您的API中产生某种类型的错误。具体来说，在这种情况下，您可能会认为这会返回某种类型的<code class="du lw lx ly lz b">4xx</code>错误(即客户端错误)。对于这个项目中的API(至少在<code class="du lw lx ly lz b">locust-tests</code>分支上)，这种类型的错误被配置为返回状态代码<code class="du lw lx ly lz b">400</code>(错误请求)。Locust允许您检查来自API的响应，以确保它们按照您的预期得到处理。要将这种行为合并到之前定义的<code class="du lw lx ly lz b">RandomizedPayloadUser</code>用户中，您可以:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="d678" class="mz jp hi lz b fi na nb l nc nd">class RandomizedPayloadUser(HttpUser): <br/>    # wait between requests from one user for between 1 and 5 seconds. <br/>    wait_time = between(1, 5) <br/>   <br/>    def __init__(self, *args, **kwargs): <br/>        super().__init__(*args, **kwargs) <br/>        self.valid_payloads = iter_random_valid_payloads()<br/>        self.invalid_payloads = iter_random_invalid_payloads() </span><span id="2afb" class="mz jp hi lz b fi nf nb l nc nd">    @task(4) <br/>    def get_diagnosis_with_valid_payload(self):<br/>        self.client.post("/predict", json=next(self.valid_payloads))</span><span id="9222" class="mz jp hi lz b fi nf nb l nc nd">    @task(1) <br/>    def get_diagnosis_with_invalid_payload(self): <br/>        payload = next(self.invalid_payloads) <br/>        with self.client.post( "/predict", json=payload, catch_response=True) as response: <br/>            if response.status_code != 400: <br/>               response.failure( f"Wrong response. Expected status code 400, " f"got {response.status_code}" ) <br/>            else: response.success()</span></pre><p id="b097" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这里我们将<code class="du lw lx ly lz b">get_diagnosis_with_invalid_payload</code>方法作为<code class="du lw lx ly lz b">task</code>添加到了<code class="du lw lx ly lz b">User</code>中。您可能还注意到两个<code class="du lw lx ly lz b">task</code>装饰器现在都有了一个额外的参数。在这种情况下，这会告诉Locust它应该对每个方法进行调用的比率，所以在这种情况下，它对<code class="du lw lx ly lz b">get_diagnosis_with_valid_payload</code>的调用是对<code class="du lw lx ly lz b">get_diagnosis_with_invalid_payload</code>的四倍。这允许您“调整”您的<code class="du lw lx ly lz b">User</code>行为，以减少对API的错误调用。</p><p id="85f7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">您还将看到新方法检查对调用的响应，并确保无效负载返回正确的响应代码。这有助于确保您的API继续按照您的期望对错误做出<em class="lh">响应。例如，未能始终如一地响应预期的状态代码可能是您的API没有像您期望的那样优雅地处理错误的标志，也可能是您的服务严重退化的标志。这些都是需要监控的重要信息。</em></p><p id="4578" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我已经将上面的代码示例(加上对应用程序端错误处理的一些小调整)添加到了<code class="du lw lx ly lz b">locust-tests</code>分支中。请随意检查该分支并玩一玩！</p><p id="fd8e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">至此，您已经有了一个使用Locust对模型API进行负载测试的基本示例。正如您可能看到的，扩展Locust测试的机会是广泛的，您肯定需要仔细考虑如何在您自己的项目中使用Locust。如果您有兴趣了解如何配置和扩展Locust的更多信息，我建议您查看Locust文档:</p><div class="mb mc ez fb md me"><a href="https://docs.locust.io/en/stable/writing-a-locustfile.html" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">编写locustfile - Locust 1.4.3文档</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">locustfile是一个普通的python文件。唯一的要求是它声明至少一个从…继承的类</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">docs.locust.io</p></div></div></div></a></div><h1 id="341e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">跟踪结果</h1><p id="fea0" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在结束之前，我想提醒您负载测试的一个更重要的方面，那就是如何存储和使用结果。对于负载测试，随着时间的推移跟踪结果会很有用。例如，这可能有助于您检测您的服务限制(比如:在降级之前您的服务可以支持的最大并发用户数)是如何随时间变化的。Locust允许您使用以下代码将CSV格式的测试输出写入您选择的路径:</p><pre class="iy iz ja jb fd mv lz mw mx aw my bi"><span id="60a2" class="mz jp hi lz b fi na nb l nc nd">locust -f tests/load/locustfiles/api.py --csv data/example</span></pre><p id="833b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在这种情况下，负载测试的结果将被写入到<code class="du lw lx ly lz b">data</code>目录中。您将看到至少出现四个文件:</p><ul class=""><li id="1356" class="li lj hi ki b kj lc km ld kp lk kt ll kx lm lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">example_stats.csv</code> -在这个文件中，您将找到您的<code class="du lw lx ly lz b">User</code>调用的每个端点的顶级聚合统计数据。该文件对于获取有关服务整体响应性的信息非常有用</li><li id="0a6d" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">example_stats_history.csv</code> -这是Locust采样的每个时间戳的完整日志。换句话说，它是你的测试统计数据的时间序列，在测试的持续时间内，所有的<code class="du lw lx ly lz b">User</code>都聚集在一起。</li><li id="8cce" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">example_failures.csv</code> -该文件包含与测试期间发生的任何故障相关的数据以及故障发生次数的汇总。失败是返回错误代码<em class="lh">的响应，除非</em>您拦截错误代码并将它们标记为成功(对于类似于上面概述的用例)。</li><li id="ccb7" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lw lx ly lz b">example_exceptions.csv</code> -这个文件包含了您的测试遇到的未捕获异常的概要信息。这对于调试您的测试设置非常有用。</li></ul><p id="db73" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在命名测试输出时，值得考虑使用某种形式的惟一标识符，以确保清楚地知道结果是在什么时候和什么条件下生成的。然而，我将让您来决定什么适合您的用例。</p><p id="a5f0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，虽然简单地记录结果是一个好的开始，但是确保在项目中突出显示最新的结果是有用的，这样团队成员或其他用户/开发人员就知道在部署API或进行更改时会有什么功能。一种选择可能是编写一个小脚本来更新您的<code class="du lw lx ly lz b">README.md</code>(或其他文档)以反映您的测试的最新结果。另一个更高级的选择可能是将结果导出到数据库中进行跟踪，并编写一些诊断笔记本来分析一段时间内的性能。选择权在你，但不管是哪种情况，要知道埋藏在你自己脑袋里或某个黑暗、布满灰尘的仓库里的测试结果对其他人<em class="lh">和</em>的用处非常有限，这是生产软件中的一个重要考虑因素。毕竟，工程是一项团队运动。</p><h1 id="f163" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">下次见！</h1><p id="6c71" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这个帖子到此为止。我希望它能帮助您开始使用Locust，并最终帮助您构建更好、更可靠的软件。一如既往，我喜欢反馈，所以如果我错过了什么，或者你有任何进一步的问题，让我知道！</p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><p id="236a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh">原载于2021年2月24日</em><a class="ae jn" href="https://mark.douthwaite.io/intro-to-software-testing-load-testing-an-api/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://mark . douthwaite . io</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>The Foundational Update to Core Rendering model React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心渲染模型React 18的基础更新</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-foundational-update-to-core-rendering-model-react-18-610d0de81336?source=collection_archive---------1-----------------------#2022-05-19">https://medium.com/geekculture/the-foundational-update-to-core-rendering-model-react-18-610d0de81336?source=collection_archive---------1-----------------------#2022-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/845a9d700cfc3dc5b9d92b31e5ef087c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EV3vxO8ZDGhresNYHlRCQw.jpeg"/></div></div></figure><h1 id="5689" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">简介:</h1><p id="789d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React 18于2022年3月8日发布，有新的更新和改进。最重要的更新是并发渲染模型，它是React核心渲染模型的基础更新，大多数新功能都是为了利用它而构建的。React 18只是React团队在这个新基础上构建的目标的开始。</p><p id="d935" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如我们一直期待React团队的重大改进，以及一个简单的升级指南，而没有我们旧项目的负面影响或昂贵的重写成本。</p><blockquote class="kr ks kt"><p id="6aaa" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">请通过媒体<strong class="jq hj">跟随我</strong>，获取下一篇新文章的通知。我也活跃在推特<a class="ae ky" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> @IbraKirill </strong> </a>。</p></blockquote><p id="96f6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">我们将在本文中解释:</strong></p><p id="0700" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">1-并发机制</p><p id="fbe7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18中的新功能。</p><p id="8459" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18中的新<a class="ae ky" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f"> <strong class="jq hj">挂钩</strong> </a>。</p><p id="a1d5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">4-折旧</p><p id="294b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">5-React 18升级指南</p><h1 id="2ec5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1-并发机制:</h1><p id="8b8a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">什么是并发机制？当我们同时做不止一件事时，它就会发生。不要与并行性混淆，并发性是指多个操作序列在重叠的时间段内运行。它们是互不依赖的操作。</p><blockquote class="kr ks kt"><p id="db4f" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">例1: </em> </strong>我有一个朋友打来的电话，当我正在和他说话的时候，我的父亲打电话给我，我觉得这可能是一个紧急电话，所以我告诉我的朋友，我会让他等一下，然后接听我父亲的电话，之后再切换到我朋友的电话。</p><p id="90c6" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated"><strong class="jq hj">与此同时，我的omlet还在煮。我会把重点放在阅读和烹饪过程中的各个点上什么是更紧急的。</strong></p></blockquote><p id="0a71" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">并发并不一定意味着我同时与两个人交谈或者同时做饭阅读，这不是一种并行技术。这只是意味着，在任何时刻，我可能正在进行多个电话或行动，我选择与谁交谈或我将在哪个行动上取得进展，基于哪个对话或行动更紧急。</p><p id="73c4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在React的早期版本中，有一种方法称为分块渲染，更新在单个不间断的同步渲染中进行渲染，因此一次只能处理一个任务。使用同步呈现，一旦更新开始呈现，没有什么可以中断它，直到用户可以在屏幕上看到结果。</p><p id="ceba" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">在React 18中:</strong>引入了并发特性，使得渲染可中断。应用程序可能会开始呈现更新，中间暂停，然后稍后继续。React保证UI看起来是一致的，即使渲染被中断。要做到这一点，它会等到完成整个树的评估后，再执行DOM突变。有了这个功能，React可以在后台准备新的屏幕，而不会阻塞主线程。这意味着即使在大型渲染任务中，用户界面也可以立即响应用户输入，创造流畅的用户体验。</p><p id="2a41" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React中的并发模式不是一个特性，但它是React核心渲染模型的一个基础更新。它是一种新的幕后机制，使React能够同时准备多个版本的UI。您可以将并发性视为一个实现细节。它的价值在于它所开启的功能。React在其内部实现中使用了复杂的技术，比如优先级队列和多重缓冲。但是你不会在我们的公共API中看到这些概念。因此，虽然知道并发性是如何工作的并不是非常重要，但在高层次上了解它是什么可能是值得的。</p><p id="df8f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，为了在React上应用并发性，我将@sylwiavargas的一些解释放到了Github上:</p><blockquote class="kr ks kt"><p id="0f35" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">现在，为了解释这个类比，在React的情况下,“电话”就是你的<code class="du kz la lb lc b"><em class="hi">setState</em></code>电话。以前，React一次只能处理一个状态更新。所以所有的更新都是“紧急的”:一旦你开始重新渲染，你就不能停下来。但是使用<code class="du kz la lb lc b"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/41" rel="noopener ugc nofollow" target="_blank"><em class="hi">startTransition</em></a></code>，你可以将一个非紧急更新标记为过渡。<br/>你可以把“紧急”<code class="du kz la lb lc b"><em class="hi">setState</em></code>更新理解为类似于紧急电话(例如，你父亲需要你的帮助)，而转换就像轻松的对话，如果不再相关，可以暂停甚至中断。</p></blockquote><p id="ee64" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React团队正计划在React 18即将推出的次要版本中添加一个名为<code class="du kz la lb lc b">&lt;Offscreen&gt;</code>的新组件，你将能够使用屏幕外在后台准备一个新的UI，以便在用户展示它之前准备好，例如:当用户从一个屏幕切换回来时，React应该能够将上一个屏幕恢复到它之前的状态。</p><blockquote class="kr ks kt"><p id="b98e" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">正如安德鲁·克拉克在React 18主题演讲 : <strong class="jq hj">中所说:“有了React，设计师和开发人员就有了共同的语言。”</strong></p></blockquote><h1 id="2c5d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">React 18中的新功能:</h1><h2 id="4402" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">a-自动配料:</h2><p id="de33" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在React 18之前，当我们在promises、setTimeout、本机事件处理程序或任何其他事件中有多个状态更新组时，例如:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="2bd9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它将为三个状态更新执行3次重新渲染，当然，这对性能不利。</p><p id="c22c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18引入了自动批处理，React将promises、setTimeout、native事件处理程序或任何其他事件中的多个状态更新分组到单个重新渲染中以获得更好的性能，因此在升级到React 18后，上述示例将只重新渲染一次。</p><h2 id="7a18" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">B-悬念功能:</h2><p id="e07d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在React 18之前，当我调用API来获取数据时，加载状态会以微调器或任何类型的UI加载组件的形式出现在用户面前，当我使用完API时，我们会消失微调器，另一个包含数据的组件会出现。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="baf4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">悬念使“UI加载状态”成为React编程模型中的一级声明性概念。如果组件树的一部分还没有准备好被显示，悬念可以让你声明性地指定它的加载状态。它减少了代码行数，代码变成了干净的代码:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="08f1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18中的悬念与过渡API结合使用效果最佳。如果您在过渡期间暂停，React将防止已经可见的内容被回退替换。相反，React将延迟渲染，直到加载了足够的数据，以防止出现错误的加载状态。</p><p id="3e98" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">服务器暂停:</strong></p><p id="9bd9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae ky" href="https://kirillibrahim.medium.com/gray-area-on-when-to-use-different-rendering-modes-csr-ssr-ssg-214a636a24a4" rel="noopener"> <strong class="jq hj">客户端渲染:</strong> </a> <strong class="jq hj"> </strong>服务器渲染一个空白页面，脚本标签指向app的捆绑包。空白页面被发送到客户端浏览器，浏览器开始运行应用程序，编译所有内容，然后进行API调用并呈现页面内容。</p><p id="75c4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果JavaScript包很大，或者您的连接速度很慢，这个过程可能需要很长时间，用户将等待页面变得可交互，或者看到有意义的内容。</p><p id="e241" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以使用服务器渲染来改善用户体验，避免用户坐在空白屏幕上。</p><p id="41dc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae ky" href="https://kirillibrahim.medium.com/gray-area-on-when-to-use-different-rendering-modes-csr-ssr-ssg-214a636a24a4" rel="noopener"> <strong class="jq hj">服务器端呈现:</strong> </a> <strong class="jq hj"> </strong>是应用程序通过在服务器上显示网页而不是在浏览器中呈现网页的能力。这意味着，如果您有一个服务器端呈现的应用程序，您的内容将在服务器端获取，并传递到您的浏览器以显示给您的用户。这允许用户在JS包加载时和应用变得可交互之前查看一些UI。</p><p id="653d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们的应用程序中的大多数组件都很快，除了其中的一两个，所以一个慢的组件可以减慢整个页面，这个组件的渲染通常是应用程序中的瓶颈，增加了渲染时间。</p><p id="e841" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在React 18之前，我们不能通知React推迟加载一个慢组件，也不能通知React发送其他组件的HTML，直到慢组件加载完成。</p><p id="a8a6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18在服务器上增加了对悬念的支持。我们可以将应用程序的慢速部分封装在悬念组件中，告诉React延迟慢速组件的加载&amp;指定一个加载状态，当它像加载微调器一样加载时可以显示，重点是向下发送另一个，当慢速组件准备好并获取其数据时，服务器渲染器将在同一流中弹出其HTML。</p><p id="4955" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，用户可以尽快看到页面的框架，并随着HTML的到来，看到它逐渐显示更多的内容。在页面上加载任何JS或React之前，所有这些都已完成，从而改善了用户体验并降低了感知延迟。</p><blockquote class="kr ks kt"><p id="17bf" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">如果你想一头扎进<strong class="jq hj"> </strong> <a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1383496&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fserver-side-rendering-with-react-and-redux%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">服务器端渲染用React </strong> </a>，我劝你用下面的<a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1383496&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fserver-side-rendering-with-react-and-redux%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">课程</strong> </a>。</p></blockquote><h2 id="cb9c" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">c转换:</h2><p id="cb9a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">并发是指多个操作序列在重叠的时间段内运行。Transition是React引入的，它将帮助我们利用并发机制来区分紧急和非紧急更新。</p><p id="169d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">紧急更新</strong>需要即时响应，以匹配用户对物理对象如何操作(如打字、点击、按压等)的直觉和经验。例如，如果当用户点击产品的过滤器按钮时有轻微的延迟，这对用户来说是糟糕的体验，因为用户期望立即的响应，但是如果用户注意到在过滤后显示产品的结果有轻微的延迟，这种小的延迟将是察觉不到的，并且通常是预期的。</p><p id="00ed" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">向用户显示被点击按钮的反射是重要的(即时响应),因此是紧急的。显示产品过滤后的结果不是那么紧急，所以可以标记为非紧急。</p><p id="7d07" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">这些非紧急更新被称为转换。</strong>过渡是不同的，因为用户不期望像紧急更新那样在屏幕上看到每个中间值。<strong class="jq hj"> </strong>通过将非紧急UI更新标记为“过渡”，React将知道哪些更新要优先处理。通过这种方式，摆脱陈旧渲染&amp;优化渲染变得更加容易。</p><p id="8ad4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可以使用<code class="du kz la lb lc b">startTransition API</code>将更新标记为非紧急。<code class="du kz la lb lc b">startTransition</code>通知React哪些更新是紧急的，哪些是“过渡”。这里有一个例子:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="f04f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">包装在<code class="du kz la lb lc b">startTransition</code>中的更新被视为非紧急更新，如果出现更紧急的更新，如点击或按键，更新将被中断。如果过渡被用户打断(例如，在一行中键入多个字符)，<strong class="jq hj"> React将丢弃未完成的陈旧渲染工作，只渲染最新的更新，因此，如果在结果渲染完成之前再次更改过滤器，您只需查看最新的结果。</strong></p><h2 id="34e1" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">d-新的严格模式行为:</h2><p id="c797" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">React 18引入了一个巨大的突破性变化，在严格模式下。所有组件都被装载和卸载，然后再次装载。</p><p id="8c8f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在反应18:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="39fa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18之后，React将在开发模式下模拟卸载和重新安装组件:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="23ac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">react团队正在为<a class="ae ky" href="https://github.com/reactwg/react-18/discussions/19" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">将来会添加到</strong></a>React的新功能铺平道路，比如“屏幕外”API，允许React通过隐藏组件而不是卸载组件来保留这样的状态。例如，当用户从一个屏幕切换回来时，React应该能够立即显示上一个屏幕。为此，React将使用与以前相同的组件状态卸载和重新装载树。</p><p id="7ed3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">在React 18中的严格模式下，useEffect钩子有棘手的行为:</strong></p><div class="lx ly ez fb lz ma"><a href="https://kirillibrahim.medium.com/the-tricky-behavior-of-useeffect-hook-in-react-18-282ef4fb570a" rel="noopener follow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">React 18中useEffect钩子的巧妙行为</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">React 18引入了一个新的开发专用的严格模式检查。这个新检查将自动卸载和重新装载…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">kirillibrahim.medium.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo io ma"/></div></div></a></div><h1 id="52c0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">React 18中的新挂钩:</h1><ul class=""><li id="6d9e" class="mp mq hi jq b jr js jv jw jz mr kd ms kh mt kl mu mv mw mx bi translated"><strong class="jq hj"> useId </strong></li><li id="4158" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><strong class="jq hj">使用过渡</strong></li><li id="ed64" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><strong class="jq hj">使用插入效果</strong></li><li id="3300" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><strong class="jq hj">已用导出值</strong></li><li id="1eee" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><strong class="jq hj"> useSyncExternalStore </strong></li></ul><p id="3cdd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我会写一篇新文章解释这些新的<a class="ae ky" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f"> <strong class="jq hj">钩子</strong> </a>。</p><h1 id="5625" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">4-折旧:</h1><ul class=""><li id="2157" class="mp mq hi jq b jr js jv jw jz mr kd ms kh mt kl mu mv mw mx bi translated"><code class="du kz la lb lc b">react-dom</code> : <code class="du kz la lb lc b">ReactDOM.render</code>已被弃用。如果我们使用它，我们的应用程序会发出警告，并在React 17模式下运行。</li><li id="2352" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><code class="du kz la lb lc b">react-dom</code> : <code class="du kz la lb lc b">ReactDOM.hydrate</code>已被弃用。如果我们使用它，我们的应用程序会发出警告，并在React 17模式下运行。</li><li id="2bff" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><code class="du kz la lb lc b">react-dom</code> : <code class="du kz la lb lc b">ReactDOM.unmountComponentAtNode</code>已弃用。</li><li id="0d28" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><code class="du kz la lb lc b">react-dom</code> : <code class="du kz la lb lc b">ReactDOM.renderSubtreeIntoContainer</code>已弃用。</li><li id="6d78" class="mp mq hi jq b jr my jv mz jz na kd nb kh nc kl mu mv mw mx bi translated"><code class="du kz la lb lc b">react-dom/server</code> : <code class="du kz la lb lc b">ReactDOMServer.renderToNodeStream</code>已被弃用。</li></ul><h1 id="34b3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">5-React 18升级指南:</h1><p id="9fb5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">好消息:</strong>我们不会改变我们的整个代码，或者像Angularjs 1到Angular 2+所发生的那样重新学习一切，我们仍然按照以前的方式编写React代码。</p><h2 id="5b8b" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">a-从npm或yarn安装React 18和React DOM:</h2><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="ff47" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React 18引入了新的根API，为管理根提供了更好的人机工程学。在<code class="du kz la lb lc b">index.js</code>中，我们应该将<code class="du kz la lb lc b">ReactDom.render</code>替换为<code class="du kz la lb lc b">ReactDom.createRoot</code>来创建一个根，并使用根来渲染你的应用。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="b8c5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">React团队也将<code class="du kz la lb lc b">unmountComponentAtNode</code>更改为<code class="du kz la lb lc b">root.unmount</code>:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="942b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果React app使用服务器端渲染和水合，将<code class="du kz la lb lc b">hydrate</code>升级到<code class="du kz la lb lc b">hydrateRoot</code>:</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="53b3" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">b-如果React项目使用TypeScript:</h2><p id="8342" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们需要将<code class="du kz la lb lc b">@types/react</code>和<code class="du kz la lb lc b">@types/react-dom</code>依赖项更新到最新版本。新的类型更加安全，并且捕捉到了过去被类型检查器忽略的问题。最显著的变化是<code class="du kz la lb lc b">children</code>道具现在需要在定义道具时明确列出；</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="7527" class="ld ir hi bd is le lf lg iw lh li lj ja jz lk ll je kd lm ln ji kh lo lp jm lq bi translated">c-采用并发功能:</h2><p id="3041" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们可以在开发过程中使用<code class="du kz la lb lc b"><a class="ae ky" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank">&lt;StrictMode&gt;</a></code>来帮助解决与并发相关的错误。严格模式不会影响生产行为，但是在开发过程中，它会记录额外的警告，并双重调用被认为是幂等的函数。它不会捕捉到所有内容，但它可以有效地防止最常见类型的错误。</p><h1 id="e2e9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论:</h1><p id="2902" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本文涵盖了React 18推出的大部分新东西。React团队正在为在React的下一个版本中添加许多新功能铺平道路。</p><blockquote class="kr ks kt"><p id="9fb0" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated"><strong class="jq hj">我希望我增加了价值，</strong>如果你喜欢读这篇文章，并想支持我成为一名作家，你可以<a class="ae ky" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">请我喝杯咖啡！</strong> </a></p><p id="f704" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">如果你想潜进<strong class="jq hj"> </strong> <a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">反应18 </strong> </a>用实际例子，我奉劝你用下面的<a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">课程</strong> </a>。</p><p id="fe2b" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">如果您想深入React  中的<a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">最佳实践模式。我用下面的<a class="ae ky" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">课程</strong> </a> <strong class="jq hj">劝你。</strong></strong></a></p></blockquote></div></div>    
</body>
</html>
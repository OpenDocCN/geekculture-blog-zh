<html>
<head>
<title>A simple search bar auto-complete implementation (ReactJs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的搜索栏自动完成实现(ReactJs)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-simple-search-bar-auto-complete-implementation-reactjs-f08382742013?source=collection_archive---------8-----------------------#2021-08-02">https://medium.com/geekculture/a-simple-search-bar-auto-complete-implementation-reactjs-f08382742013?source=collection_archive---------8-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b9a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想知道搜索栏中自动完成功能背后的技巧吗？我抓住你了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b104c3c6314ee5d41193b14f026358d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MNZ0nkzKPnyXnezN.jpeg"/></div></figure><p id="93d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，不久前我研究了Trie(一种主要用于自动完成和自动建议实现的数据结构),当我用几个词对它进行测试并返回建议时，它看起来真的很神奇。现在我很兴奋能更上一层楼。使用ReactJs，我创建了一个简单的搜索栏，并用一个包含十个单词的字典对它进行了测试(当然它们不是很多，只是为了确保它能工作)。你可以<a class="ae jl" href="https://wxj36.csb.app/" rel="noopener ugc nofollow" target="_blank">在这里</a>用<em class="jm">‘你好’，‘氦’，‘世界’，‘汽车’，‘地毯’，‘测试’，‘这个’，‘那个’，‘那些’，‘工作’，‘是’(因为那是我全部加到我的字典里的)</em>。让我们来看看我是如何做到这一点的。</p><blockquote class="jn jo jp"><p id="7a8d" class="if ig jm ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">TL；DR直接进入<a class="ae jl" href="https://codesandbox.io/s/search-bar-wxj36" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>并摆弄代码</p></blockquote><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jv jw et er es jx jy bd b be z dx"><a class="ae jl" href="https://codesandbox.io/s/search-bar-wxj36" rel="noopener ugc nofollow" target="_blank">finished search bar as seen in codesandbox.io</a></figcaption></figure><p id="fe2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，了解Trie如何工作的逻辑是很有用的，我已经在这里写了一篇关于我的实现的文章，所以你可以继续。</p><blockquote class="jz"><p id="fdb6" class="ka kb hi bd kc kd ke kf kg kh ki jc dx translated">当你理解了基本原理，就很容易操纵动力学。</p></blockquote><p id="47aa" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">首先，我假设您熟悉启动react项目模板并让它运行，以及如何使用<code class="du ko kp kq kr b">react hooks</code>。我还会跟踪这个库的主分支中的<a class="ae jl" href="https://github.com/EKaxada/search-bar" rel="noopener ugc nofollow" target="_blank">源代码，这样万一您的实现在第一次尝试中不工作，您可以参考。</a></p><p id="d827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们深入了解真实情况。我们在<code class="du ko kp kq kr b">src</code>文件夹中的文件夹结构将如下所示；</p><pre class="je jf jg jh fd ks kr kt ku aw kv bi"><span id="e169" class="kw kx hi kr b fi ky kz l la lb">src<br/> |App.css<br/> |App.js<br/> |trie.js<br/> |index.js</span></pre><p id="19a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们继续在<code class="du ko kp kq kr b">trie.js</code>中创建<code class="du ko kp kq kr b">Trie</code>逻辑，但我不会在这里这样做，因为这会让这篇短小的黑客文章变得冗长而乏味。<a class="ae jl" href="https://github.com/EKaxada/search-bar/blob/main/src/trie.js" rel="noopener ugc nofollow" target="_blank">你可以在这里找到代码</a>和<a class="ae jl" rel="noopener" href="/geekculture/how-to-effortlessly-implement-an-autocomplete-data-structure-in-javascript-using-a-trie-ea87a7d5a804">一篇解释实现的文章</a>。</p><p id="4b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们开始在<code class="du ko kp kq kr b">App.js</code>文件中实现整个项目的核心。我们的<code class="du ko kp kq kr b">App.js</code>文件将是一个具有两个<code class="du ko kp kq kr b">string</code>状态和两个输入字段的<code class="du ko kp kq kr b">state component</code>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/e5f68799f103531bd34c3eb86033c6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0jLB3aU_hDnyP5pTuwXog.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">the two states in App.js</figcaption></figure><p id="71f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这是逻辑。我们将<strong class="ih hj">将两个输入堆叠起来</strong>。这将通过CSS <code class="du ko kp kq kr b">position</code>和<code class="du ko kp kq kr b">z-index</code>属性来完成。(<a class="ae jl" href="https://github.com/EKaxada/search-bar/blob/main/src/App.css" rel="noopener ugc nofollow" target="_blank">全文</a> <code class="du ko kp kq kr b"><a class="ae jl" href="https://github.com/EKaxada/search-bar/blob/main/src/App.css" rel="noopener ugc nofollow" target="_blank">App.css</a></code> <a class="ae jl" href="https://github.com/EKaxada/search-bar/blob/main/src/App.css" rel="noopener ugc nofollow" target="_blank">文件此处</a>)。<em class="jm">顶部的输入将用于输入单词，而后面的输入将用于显示完整的单词(如果找到的话)。这是基本的设计逻辑。</em></p><blockquote class="jn jo jp"><p id="8ddd" class="if ig jm ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj">注意:使用<code class="du ko kp kq kr b">input</code>元素控制输入字段的设计非常困难，这就是为什么大多数设计选择了<code class="du ko kp kq kr b">contenteditable div</code>的原因，本文并不打算解决这些问题，但至少我遇到了一些限制，我希望你能弄清楚什么时候不使用一个或另一个。</strong></p></blockquote><p id="59c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此顶部的<code class="du ko kp kq kr b">input</code>元件将具有两种功能并保持第一种状态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lh"><img src="../Images/1ffbb5940e1e3fec2f9941c4edcd3794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYI3ItVHb0bK2o5jV4_5jA.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">first input element</figcaption></figure><p id="c3f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后面的<code class="du ko kp kq kr b">input</code>元件将没有功能，而是处于第二状态；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es li"><img src="../Images/24d7fb8ec40f7cd9b3e714d38dd351b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IppcQ5TSt9G6evHrQ8Mzvw.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">second input element</figcaption></figure><p id="43ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，根据我们的第一个<code class="du ko kp kq kr b">input</code>元素，我们创建了两个函数来实现这个特性，<code class="du ko kp kq kr b"><strong class="ih hj"><em class="jm">onChange</em></strong></code> <strong class="ih hj"> <em class="jm">和</em> </strong> <code class="du ko kp kq kr b"><strong class="ih hj"><em class="jm">handleKeyDown</em></strong></code> <strong class="ih hj"> <em class="jm">函数</em> </strong>。</p><h1 id="3cec" class="lj kx hi bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="du ko kp kq kr b">'onChange'</code>功能</h1><p id="47ea" class="pw-post-body-paragraph if ig hi ih b ii mg ik il im mh io ip iq mi is it iu mj iw ix iy mk ja jb jc hb bi translated">对于将在顶部输入中键入或删除的每个字符，将调用该函数。我将逐行解释这个函数，因为它是最重要的，但首先，这是整个函数；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml ju l"/></div></figure><p id="e44f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当该函数被调用时，此时输入域中的任何字符都用<code class="du ko kp kq kr b">e.target.value</code>引用，并存储在<code class="du ko kp kq kr b">value</code>变量中。</p><pre class="je jf jg jh fd ks kr kt ku aw kv bi"><span id="41db" class="kw kx hi kr b fi ky kz l la lb">var value = e.target.value</span></pre><p id="da1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用<code class="du ko kp kq kr b">setPrefix(value)</code>将<code class="du ko kp kq kr b">prefix</code>状态更新为输入字段中的当前字符。</p><p id="1624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时用户可能输入了不止一个单词，唯一的方法是使用空格<code class="du ko kp kq kr b">split</code>字符串<code class="du ko kp kq kr b">value</code>；</p><pre class="je jf jg jh fd ks kr kt ku aw kv bi"><span id="45cb" class="kw kx hi kr b fi ky kz l la lb">var words = value.split(" ")</span><span id="7185" class="kw kx hi kr b fi mm kz l la lb">// if value = 'this is a sentence' then value.split(" ") returns an array of ["this","is","a","sentence"].</span></pre><p id="c41c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在调用<code class="du ko kp kq kr b">trie.find('he')</code>时查看了我们的Trie实现，我们正在寻找以<code class="du ko kp kq kr b">'he'</code>开头的所有单词，对于我们的示例词典，这些单词是<code class="du ko kp kq kr b">'hello'</code>和<code class="du ko kp kq kr b">'helium'</code>。因此，为了总是获得<code class="du ko kp kq kr b">trie_prefix</code>，我们将目标锁定在最后一个空格后输入的最后一个单词，并且总是锁定我们可以说的话；</p><pre class="je jf jg jh fd ks kr kt ku aw kv bi"><span id="4a0f" class="kw kx hi kr b fi ky kz l la lb">var trie_prefix = words[words.length - 1].toLowerCase()</span></pre><p id="18ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我包含了<code class="du ko kp kq kr b">.toLowerCase()</code>方法，以便在有大写字母的情况下，它被转换成小写字母，因为我的字典中所有的单词都是小写的。然后，我将查找单词并使用<code class="du ko kp kq kr b">trie_prefix</code>返回一个按照长度排序的<code class="du ko kp kq kr b">found_words</code>数组，最短的放在最前面。</p><pre class="je jf jg jh fd ks kr kt ku aw kv bi"><span id="511c" class="kw kx hi kr b fi ky kz l la lb">var found_words = myTrie.find(trie_prefix).sort((a, b) =&gt; {      return a.length - b.length;});</span></pre><blockquote class="jn jo jp"><p id="ae4e" class="if ig jm ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">大多数时候，单词是根据它们的使用频率和复杂度预测来排序的，实际上我在这里并没有这样做。</p></blockquote><p id="8143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们用<code class="du ko kp kq kr b">var first_word = found_words[0]</code>挑选第一个单词，然后表演一些‘魔术’！</p><p id="d7f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有任何<code class="du ko kp kq kr b">found_words</code>并且如果输入字段不为空并且<code class="du ko kp kq kr b">value</code>中的最后一个字符也不是空格，我们继续检查<code class="du ko kp kq kr b">first_word</code>是否不是<code class="du ko kp kq kr b">undefined</code>或<code class="du ko kp kq kr b">null</code>，如果不是，我们使用<code class="du ko kp kq kr b">slice()</code>方法获取<code class="du ko kp kq kr b">first_word</code>的剩余字母并用完整的单词更新我们的<code class="du ko kp kq kr b">suggestion</code>状态，否则我们用输入字段中的任何内容更新我们的<code class="du ko kp kq kr b">suggestion</code>状态。这是这个程序的代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml ju l"/></div></figure><p id="f7da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么用户如何选择建议的单词呢？按下右箭头键，这就是<code class="du ko kp kq kr b">handleKeyChange</code>功能发挥作用的地方。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml ju l"/></div><figcaption class="jv jw et er es jx jy bd b be z dx">handleKeyDown function</figcaption></figure><p id="140e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样，我们现在可以用我们喜欢的任何单词来创建我们的字典，并测试它们。我将使用JSON和一个数组对象。(我假设您可能想使用您自己的单词，这些单词可能以JSON格式返回，所以我用JSON实现了它，以使事情变得简单)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml ju l"/></div><figcaption class="jv jw et er es jx jy bd b be z dx">sample words</figcaption></figure><p id="c1a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们实例化一个新的Trie对象，并通过自调用异步函数遍历数组中的每个单词来插入这些单词。<em class="jm">(确保将其放在</em> <code class="du ko kp kq kr b"><em class="jm">onChange</em></code> <em class="jm">函数之前的状态声明之后)</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ml ju l"/></div><figcaption class="jv jw et er es jx jy bd b be z dx">inserting words into trie</figcaption></figure><p id="b98a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这些了。<a class="ae jl" href="https://wxj36.csb.app/" rel="noopener ugc nofollow" target="_blank">通过观看这个演示</a>来看看结果如何。使用这个库跟踪<a class="ae jl" href="https://github.com/EKaxada/search-bar" rel="noopener ugc nofollow" target="_blank">的完整实现，我希望你能扩展它以满足你的需求。这只是让你开始。</a></p><p id="b188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很欣赏这些掌声。干杯:)！</p></div></div>    
</body>
</html>
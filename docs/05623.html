<html>
<head>
<title>How to automatically create fixup commits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何自动创建修正提交</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-automatically-create-fixup-commits-8e55a3837b00?source=collection_archive---------37-----------------------#2021-07-26">https://medium.com/geekculture/how-to-automatically-create-fixup-commits-8e55a3837b00?source=collection_archive---------37-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="73af" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用这个简洁的脚本实现PR修复可以节省时间</h2></div><p id="82e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您提交了一个带有良好的<a class="ae jt" href="https://ablingeroscar.medium.com/ensure-atomic-commits-in-the-ci-eaa1ba2033f3" rel="noopener">原子提交</a>的拉请求，您的同事发现了一些改进。它们很容易实现，但是如果您想要一个好的历史，您现在必须弄清楚应该将它们添加到哪个提交中。通常这只是文件被更改的最后一次提交。但是仍然需要一段时间来找到它——或者让这个脚本来完成这项工作。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/9dd41e99da1292c085f8d96545c30a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKh_vfileueNLqKCqNn5rg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Made by the author using <a class="ae jt" href="https://carbon.now.sh" rel="noopener ugc nofollow" target="_blank">carbon.sh</a></figcaption></figure><h1 id="e0a4" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">使用</h1><p id="3ffe" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在向您展示脚本之前，我首先想向您展示您可以用它做些什么。</p><p id="3669" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，该脚本会自动计算出已更改文件最后一次修改的提交，并为它们创建修正提交。对于一个原始提交，只有一个修正提交，即使在同一个提交中修改了多个已更改的文件。</p><p id="e646" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该能够挤压所有生成的提交，而没有合并冲突(使用<code class="du lh li lj lk b">git rebase -i</code>)。</p><p id="d085" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您还可以使用一些选项稍微调整它的行为:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ll"><img src="../Images/aaffacb2630f680b4f6189eeaa0d70ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLSV2XGFjFmG333uFM2HXA.png"/></div></div></figure><ul class=""><li id="2618" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">纯文本参数“root”:该脚本将只查看从根提交开始的提交(但不包括根提交)。这可用于确保不会为不在当前分支上的提交创建任何修正提交。在此提交期间或之前最后更改的文件将只是保持未提交状态。</li><li id="ae35" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated"><code class="du lh li lj lk b">-n | --dry-run</code>:如果指定了空运行，则不会进行持续的更改。取而代之的是，它将输出哪些文件将被分配给哪些提交。</li><li id="323b" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated"><code class="du lh li lj lk b">-d | --default-root</code>指定默认根目录。如果同时指定了默认根和根，则只考虑根。这是一个git别名，您可以将<code class="du lh li lj lk b">main</code>或<code class="du lh li lj lk b">master</code>指定为默认值，并在使用别名时覆盖它。</li><li id="aa39" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated"><code class="du lh li lj lk b">-M&lt;n&gt; | --find-renames[=&lt;n&gt;]</code>:如果指定，将尝试分配重命名。格式与<a class="ae jt" href="https://git-scm.com/docs/git-diff#Documentation/git-diff.txt--Mltngt" rel="noopener ugc nofollow" target="_blank"> git diff </a>相同。</li></ul><p id="7b06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，让我们看看下面的命令:</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="7ce9" class="me kl hi lk b fi mf mg l mh mi">assign -n -d main -M master</span></pre><p id="3308" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将导致脚本列出所有更改文件的提交(而不是由于<code class="du lh li lj lk b">-n</code>创建提交)，包括重命名的文件(由于<code class="du lh li lj lk b">-M</code>)。如果文件的最后一次更改提交是在当前<code class="du lh li lj lk b">master</code>所在的提交之前或之中进行的，它将不会列出文件(如果只有<code class="du lh li lj lk b">-d</code>选项，它将是<code class="du lh li lj lk b">main</code>，但它被最后一个参数覆盖)。</p><p id="2da9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参见下一章的输出示例。</p><h1 id="125e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">例子</h1><p id="9f8f" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">为了测试这一点，我还编写了一个小脚本来创建一个git存储库，并向其中添加一些提交。</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="7327" class="me kl hi lk b fi mf mg l mh mi">#!/bin/sh</span><span id="9911" class="me kl hi lk b fi mj mg l mh mi">rm -rf repo<br/>mkdir repo<br/>cd repo</span><span id="4929" class="me kl hi lk b fi mj mg l mh mi">git init</span><span id="79dc" class="me kl hi lk b fi mj mg l mh mi">echo "* text eol=lf" &gt; .gitattributes<br/>git add .<br/>git commit -m "initial commit"<br/>git checkout -b "feature-branch"</span><span id="0222" class="me kl hi lk b fi mj mg l mh mi">echo a &gt; A<br/>git add .<br/>git commit -m "A"</span><span id="bdaf" class="me kl hi lk b fi mj mg l mh mi">echo b &gt; B<br/>git add .<br/>git commit -m "B"</span><span id="a65b" class="me kl hi lk b fi mj mg l mh mi">echo with spaces &gt; "file with spaces"<br/>git add .<br/>git commit -m "file with spaces"</span><span id="0088" class="me kl hi lk b fi mj mg l mh mi">echo aAndC &gt;&gt; B<br/>echo c &gt; C<br/>git add .<br/>git commit -m "B and C"</span><span id="1db1" class="me kl hi lk b fi mj mg l mh mi">echo change &gt; A<br/>echo change &gt; B<br/>echo change &gt; C<br/>mv "file with spaces" "other file with spaces"</span></pre><p id="2607" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一些提交和一些未提交的更改:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mk"><img src="../Images/9883fc7a5103940936a8086ff435e655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*Y9nIK4HHQGF2i8i3HCrDig.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Screenshot of the <a class="ae jt" href="https://gitforwindows.org/" rel="noopener ugc nofollow" target="_blank">git for windows</a> bash made by the author</figcaption></figure><p id="e88e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我现在在存储库中执行<code class="du lh li lj lk b">assign -M -d main -n</code>,输出将如下所示:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ml"><img src="../Images/8c6f2e52c71c5a63448cb535190c7638.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*nteBXVGkt-97eJ4LQzg9Ng.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">Screenshot of the <a class="ae jt" href="https://gitforwindows.org/" rel="noopener ugc nofollow" target="_blank">git for windows</a> bash made by the author</figcaption></figure><p id="c7fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，在这个截图中，我已经利用了一个git别名，我将在最后向您展示这个别名。</p><h1 id="c283" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">代码</h1><p id="ed3c" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">好了，解释够了，下面是代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="0931" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是很多，但幸运的是你可以把它复制粘贴到你电脑上的一个文件中。不要总是直接调用文件，我建议为它创建一个git别名。</p><p id="05dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我将以下内容添加到我的<code class="du lh li lj lk b">~/.gitconfig</code>文件中:</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="5f60" class="me kl hi lk b fi mf mg l mh mi">[alias]<br/> a = assign<br/> assign = !bash -c '~/.gitscripts/assign -M -d "$(git merge-base HEAD main)" "$@"' -<br/> assign-all = !bash -c '~/.gitscripts/assign -M "$@"' -</span></pre><p id="4ab0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，你可能想稍微改变一下你别名的默认选项(比如把<code class="du lh li lj lk b">main</code>改成<code class="du lh li lj lk b">master</code>，但是我发现这些对我来说是最明智的默认选项。只是不要忘记替换你的脚本的路径(在我的例子中，我把它保存为<code class="du lh li lj lk b">~/.gitscripts/assign</code>)。</p><p id="1362" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哦，不保证你的文件名中是否有换行符或制表符。</p><h1 id="2921" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">说明</h1><p id="92c4" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">如果只是想用，现在可以不看了。但是如果你想知道它是如何工作的，这里有一个渐进的解释:</p><h2 id="6a1b" class="me kl hi bd km mp mq mr kq ms mt mu ku jg mv mw kw jk mx my ky jo mz na la nb bi translated">最简单的脚本</h2><p id="d469" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">起初，我只是希望有一个脚本，它可以根据修改文件的最后一次提交自动创建修正提交。我想到了一个简单的5行脚本:</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="f9b9" class="me kl hi lk b fi mf mg l mh mi">for file in $(git diff --name-only);<br/>do<br/>    git add "${file}"<br/>    git commit --fixup "$(git log -1 --format="format:%H" -- "${file}")"<br/>done</span></pre><p id="1866" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很简单，对吧？检查每个更改的文件，添加它并创建一个修正提交。</p><h2 id="76ea" class="me kl hi bd km mp mq mr kq ms mt mu ku jg mv mw kw jk mx my ky jo mz na la nb bi translated">简单的脚本</h2><p id="f808" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">但是前面的脚本可能会为同一个提交创建多个修复提交。我认为这很难看，所以我们没有直接添加和提交，而是首先创建一个提交到其更改文件的映射。</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="2997" class="me kl hi lk b fi mf mg l mh mi">#!/bin/bash</span><span id="1350" class="me kl hi lk b fi mj mg l mh mi"># For each changed file find the commit in which it was last changed.<br/># lastCommits is an associative array with the commit hash as key and<br/># a newline separated list of the file names as value.<br/>declare -A lastCommits<br/>for file in $(git diff --name-only);<br/>do<br/>    commit=$(git log -1 --format="format:%H" -- "${file}")<br/>    lastCommits[$commit]+="$file"$'\n'<br/>done</span><span id="7dc0" class="me kl hi lk b fi mj mg l mh mi"># For each commit in lastCommits, we now add all of the associated<br/># files and then create a fixup commit for the respective commit<br/>IFS=$'\n'<br/>for commit in "${!lastCommits[@]}";<br/>do<br/>    for file in ${lastCommits[$commit]};<br/>    do<br/>        git add "${file}"<br/>    done</span><span id="788c" class="me kl hi lk b fi mj mg l mh mi">    git commit --fixup "$commit"<br/>done<br/>unset IFS</span></pre><h2 id="dcd0" class="me kl hi bd km mp mq mr kq ms mt mu ku jg mv mw kw jk mx my ky jo mz na la nb bi translated">添加一些选项</h2><p id="ade7" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">接下来，我希望能够对times进行一次测试，我不确定最后一次提交是否正确。所以我在开头添加了更多的命令解析样板文件和一些if语句。</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="fc3c" class="me kl hi lk b fi mf mg l mh mi">#!/bin/bash</span><span id="035a" class="me kl hi lk b fi mj mg l mh mi"># Default options<br/>DRY_RUN=false</span><span id="184e" class="me kl hi lk b fi mj mg l mh mi"># Read potential options<br/>while [ "$1" != "" ];<br/>do<br/>    case $1 in<br/>        -n | --dry-run)<br/>            DRY_RUN=true<br/>            ;;<br/>        *)<br/>            printf "unrecognised option: %s" "$1"<br/>            exit 1<br/>            ;;<br/>    esac<br/>    shift<br/>done</span><span id="38cd" class="me kl hi lk b fi mj mg l mh mi"># For each changed file find the commit in which it was last changed.<br/># lastCommits is an associative array with the commit hash as key and<br/># a newline separated list of the file names as value.<br/>declare -A lastCommits<br/>for file in $(git diff --name-only);<br/>do<br/>    commit=$(git log -1 --format="format:%H" -- "${file}")<br/>    lastCommits[$commit]+="$file"$'\n'<br/>done</span><span id="9688" class="me kl hi lk b fi mj mg l mh mi"># For each commit in lastCommits, we now add all of the associated<br/># files and then create a fixup commit for the respective commit<br/>IFS=$'\n'<br/>for commit in "${!lastCommits[@]}";<br/>do<br/>    if [[ $DRY_RUN == true ]];<br/>    then<br/>        printf "commit %s:\n" "${commit}"<br/>    fi</span><span id="9c44" class="me kl hi lk b fi mj mg l mh mi">for file in ${lastCommits[$commit]};<br/>    do<br/>        if [[ $DRY_RUN == false ]];<br/>        then<br/>            git add "${file}"<br/>        else<br/>            printf "\t%s\n" "${file}"<br/>        fi<br/>    done</span><span id="7aa3" class="me kl hi lk b fi mj mg l mh mi">if [[ $DRY_RUN == false ]];<br/>    then<br/>        git commit --fixup "${commit}"<br/>    fi<br/>done<br/>unset IFS</span></pre><h2 id="6865" class="me kl hi bd km mp mq mr kq ms mt mu ku jg mv mw kw jk mx my ky jo mz na la nb bi translated">添加根选项</h2><p id="c0cd" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">为了添加<code class="du lh li lj lk b">root</code>选项，我在开头扩展了样板代码。读取选项后，<code class="du lh li lj lk b">root</code>被设置为默认根或特定根。</p><p id="f4c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当在第一个循环中确定哪些文件属于哪个提交时，我们还指定了根提交(如果我们有一个的话)。如果在指定的提交之后没有找到相关的提交，这将导致<code class="du lh li lj lk b">git log</code>返回空值。</p><p id="4e44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不需要其他更改。</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="aacf" class="me kl hi lk b fi mf mg l mh mi">#!/bin/bash</span><span id="73ef" class="me kl hi lk b fi mj mg l mh mi"># Default options<br/>DRY_RUN=false<br/>DEFAULT_ROOT=""<br/>ROOT=""</span><span id="5394" class="me kl hi lk b fi mj mg l mh mi"># Read potential options<br/>while [ "$1" != "" ];<br/>do<br/>    case $1 in<br/>        -n | --dry-run)<br/>            DRY_RUN=true<br/>            ;;<br/>        -d | --default-root)<br/>            shift<br/>            DEFAULT_ROOT="$1"<br/>            ;;<br/>        -*)<br/>            printf "unrecognised option: %s" "$1"<br/>            exit 1<br/>            ;;<br/>        *)<br/>            if [[ $ROOT == "" ]];<br/>            then<br/>                ROOT="$1"<br/>            else<br/>                printf "Cannot specify root twice (specified both '%s' and '%s')" "${ROOT}" "$1"<br/>                exit 1<br/>            fi<br/>            ;;<br/>    esac<br/>    shift<br/>done</span><span id="02af" class="me kl hi lk b fi mj mg l mh mi">if [[ $DEFAULT_ROOT != "" &amp;&amp; $ROOT == "" ]];<br/>then<br/>    ROOT="${DEFAULT_ROOT}"<br/>fi</span><span id="713d" class="me kl hi lk b fi mj mg l mh mi"># For each changed file find the commit in which it was last changed.<br/># lastCommits is an associative array with the commit hash as key and<br/># a newline separated list of the file names as value.<br/>declare -A lastCommits<br/>for file in $(git diff --name-only);<br/>do<br/>    if [[ $ROOT != "" ]];<br/>    then<br/>        commit=$(git log -1 --format="format:%H" "${ROOT}.." -- "${file}")</span><span id="9f3e" class="me kl hi lk b fi mj mg l mh mi">        # When a root is specified, a file could have no changes before that.<br/>        # We simply ignore that file then.<br/>        if [[ $commit != "" ]];<br/>        then<br/>            lastCommits[$commit]+="$file"$'\n'<br/>        fi<br/>    else<br/>        commit=$(git log -1 --format="format:%H" -- "${file}")<br/>        lastCommits[$commit]+="$file"$'\n'<br/>    fi<br/>done</span></pre><h2 id="5af4" class="me kl hi bd km mp mq mr kq ms mt mu ku jg mv mw kw jk mx my ky jo mz na la nb bi translated">添加查找-重命名</h2><p id="ab03" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">之前的脚本已经运行得很好了。唯一恼人的是，如果我重命名一个文件，它只会创建一个修正提交来删除原始文件，而不是添加“新”文件。</p><p id="0ff5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我增加了一个新选项:</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="8297" class="me kl hi lk b fi mf mg l mh mi"># Default options<br/>DRY_RUN=false<br/>DEFAULT_ROOT=""<br/>ROOT=""<br/>FIND_RENAMES=()</span><span id="aebe" class="me kl hi lk b fi mj mg l mh mi"># Read potential options<br/>while [ "$1" != "" ];<br/>do<br/>    case $1 in<br/>        -n | --dry-run)<br/>            DRY_RUN=true<br/>            ;;<br/>        -d | --default-root)<br/>            shift<br/>            DEFAULT_ROOT="$1"<br/>            ;;<br/>        -M* | --find-renames*)<br/>            FIND_RENAMES=("$1")<br/>            ;;<br/>        -*)<br/>            printf "unrecognised option: %s" "$1"<br/>            exit 1<br/>            ;;<br/>        *)<br/>            if [[ $ROOT == "" ]];<br/>            then<br/>                ROOT="$1"<br/>            else<br/>                printf "Cannot specify root twice (specified both '%s' and '%s')" "${ROOT}" "$1"<br/>                exit 1<br/>            fi<br/>            ;;<br/>    esac<br/>    shift<br/>done</span></pre><p id="784b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，变量<code class="du lh li lj lk b">FIND_RENAMES</code>要么为空，要么具有完整的、未更改的参数。这意味着我可以将它原样提供给<code class="du lh li lj lk b">git diff</code>，您可以自动使用该命令的所有特性。</p><p id="e8e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我们已经为每个更改的文件分配了commit之后，我们现在还想根据git判断是否有任何重命名。为此，我们首先需要找到所有未转移的文件。然后我们告诉git我们打算添加它们(使用<code class="du lh li lj lk b">git add -N</code>)。之后，git将检查它是否是一个重命名的文件。我们可以通过使用<code class="du lh li lj lk b">git diff --name-status</code>来询问它，并使用<code class="du lh li lj lk b">--diff-filter=R</code>来过滤重命名。</p><p id="1de7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们简单地保存哪个文件被重命名为什么。</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="6b8e" class="me kl hi lk b fi mf mg l mh mi">declare -A renamedFiles=()<br/>if (( ${#FIND_RENAMES[@]} ));<br/>then<br/>    # first add all files indvidually as intent-to-add<br/>    intentToAdd=$(git ls-files -o)<br/>    for file in $intentToAdd;<br/>    do<br/>        git add -N "$file"<br/>    done</span><span id="ebbe" class="me kl hi lk b fi mj mg l mh mi"># get all renames and save them into an associative array<br/>    while IFS=$'\t' read -r origFile newFile;<br/>    do<br/>        renamedFiles["$origFile"]="$newFile"<br/>    done &lt; &lt;(git diff --name-status --diff-filter=R "${FIND_RENAMES[@]}" | cut -f 2,3)<br/>    <br/>    # remove intent-to-add<br/>    for file in $intentToAdd;<br/>    do<br/>        git reset -q -- "$file"<br/>    done<br/>fi</span></pre><p id="5098" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加文件时，我们现在还会添加所有重命名的文件:</p><pre class="jv jw jx jy fd ma lk mb mc aw md bi"><span id="ba20" class="me kl hi lk b fi mf mg l mh mi">if [[ -v "renamedFiles[${file}]" ]];<br/>then<br/>    add_file "${renamedFiles[${file}]}"<br/>fi</span></pre><p id="6707" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nc"><img src="../Images/c50f3edc584b6bc09b237c42402a8ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LwE81p9pgEMGSTZV"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@alx_andru?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Getting Started: Android CameraX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">入门:Android CameraX</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/getting-started-android-camerax-a84e138e2c00?source=collection_archive---------2-----------------------#2021-05-12">https://medium.com/geekculture/getting-started-android-camerax-a84e138e2c00?source=collection_archive---------2-----------------------#2021-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9792" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">快速指南(和示例代码)让您开始使用新的Android Jetpack CameraX API作为MLKit的条形码扫描仪。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1bb62ffc1659a540b1645212fb35bcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Hv0cWYsD1FC0jsR"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@sharegrid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ShareGrid</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7c18" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顾名思义，Jetpack(一组用于Android开发的现代API)真正提高了开发人员的工作效率——Jetpack CameraX API的引入也不例外。</p><p id="5c37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与它的前身(Camera2)相比，使用CameraX开发基于相机的Android视图是一个更加简化的过程，具有一些突出的功能:</p><ul class=""><li id="f691" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">抽象出OEM传感器硬件驱动程序差异的复杂性。</li><li id="3092" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">支持Android API 21及以上版本。</li><li id="7326" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">与其他Jetpack组件一样，它具有生命周期意识，并负责提供和分解所需的资源以响应应用程序生命周期事件。</li><li id="a7c3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">对我来说，最激动人心的特性是引入了所谓的“用例管道”</strong></li></ul><h1 id="ab49" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">一个用例管道？</strong></h1><p id="d60e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">本质上，CameraX API上下文中的<code class="du lv lw lx ly b">UseCase</code>是一个类，它接受来自相机的图像帧，对它做一些事情，并在完成时通知API，此时调用下一个用例——冲洗和重复。</p><p id="972b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">举例来说，这就是如何使用CameraX初始化/设置相机实例:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/1a1065ac2f78ad9de39ee641b42c63e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmB0pNiEEJunQp3Su6FUAw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Screenshot of ProcessCameraProvider.java in android.camerax.lifecycle</figcaption></figure><p id="42b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如您所看到的，传递了<code class="du lv lw lx ly b">bindToLifecycle</code>函数:</p><ul class=""><li id="eae7" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">将承载摄像机实例的活动(LifecycleOwner)。</li><li id="6d3c" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">一个助手(<code class="du lv lw lx ly b">CameraSelector</code>)，用来指定使用哪个硬件传感器(摄像头)。</li><li id="bc1c" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj"> <em class="ma">一个</em> </strong> <code class="du lv lw lx ly b"><strong class="jq hj"><em class="ma">UseCase</em></strong></code> <strong class="jq hj"> <em class="ma">类型的列表(vararg)来运行每一帧。</em> </strong></li></ul><p id="df95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一个参数允许您根据需要将多个用例连接在一起。</p><p id="97a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，如前所述，这绑定到一个生命周期感知相机实例，因此，例如，如果您后台应用程序，CameraX将负责暂停硬件并使相关资源可用于垃圾收集。</p><h1 id="f622" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">基础用例</strong></h1><p id="1f06" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">到目前为止，CameraX API有三个不同的基本用例，即:</p><ul class=""><li id="c87c" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><strong class="jq hj">预览</strong>:接受显示预览的表面— <code class="du lv lw lx ly b">Preview</code></li><li id="0bbc" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">图像分析</strong>:为分析提供CPU可访问的缓冲区，例如用于机器学习推理:)— <code class="du lv lw lx ly b">ImageAnalysis</code></li><li id="5b1b" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">图像捕捉</strong>:捕捉并保存照片— <code class="du lv lw lx ly b">ImageCapture</code></li></ul><p id="a686" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设<code class="du lv lw lx ly b">Preview</code>用例将在<em class="ma">大部分时间</em>被放置在管道中是安全的。这将获取接收到的图像帧，并将其渲染到一个<code class="du lv lw lx ly b">Surface</code> ( <code class="du lv lw lx ly b">androidx.camera.view.PreviewView</code>)供用户查看。</p><p id="4c1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似地，<code class="du lv lw lx ly b">ImageCapture</code>提供将接收到的帧保存为照片的功能。</p><p id="d257" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最令人兴奋的显然是<code class="du lv lw lx ly b">ImageAnalyses</code>——它给你一个原始的帧缓冲区，让你用自己选择的ML模型进行推理。</p><blockquote class="mb mc md"><p id="60f4" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">出于本文的目的，我将使用<code class="du lv lw lx ly b">BarcodeScanning</code> API(作为<a class="ae jn" href="https://developers.google.com/ml-kit" rel="noopener ugc nofollow" target="_blank"> Google的MLKit框架</a>的一部分)对图像帧进行推理，以识别和解码图像中的不同条形码标准</p></blockquote><p id="5fa5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">可以说，使用这种方法扫描条形码在准确性和速度方面击败了所有其他东西，例如ZXing库。</p><p id="3c7a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的测试中，我在理想条件下获得了2秒的识别速度——更不用说CPU利用率的巨大差异了。</p><h1 id="53f8" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">挖入</strong></h1><p id="5db8" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">我现在介绍一个实现了CameraX和MLKit的演示Android项目，演示如何使用CameraX对图像帧进行推理(如前所述——一个条形码扫描仪)</p><p id="b782" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一段视频，展示了包含EAN条形码和二维码的包装<em class="ma">(注意屏幕底部解码后的条形码字符串)</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="10c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">入门</strong></p><p id="ed03" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然你可以在GitHub 上使用<a class="ae jn" href="https://github.com/k1dbl4ck/android-camerax-demo" rel="noopener ugc nofollow" target="_blank">示例代码，但我会指出一些(尽管是显而易见的)需要记住的事情:</a></p><ul class=""><li id="b3ae" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">在您的应用程序模块<code class="du lv lw lx ly b">build.gradle</code>文件中添加CameraX(以及可选的MLKit)依赖项。</li><li id="d80f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">记得声明使用设备摄像头硬件的<code class="du lv lw lx ly b">AndroidManifest.xml</code>权限和特性。</li><li id="a1f7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">该项目使用<code class="du lv lw lx ly b">dataBinding</code>,因此确保您的Android Studio版本兼容自动生成绑定类。</li><li id="c71f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在示例项目中，实际的集成放在<code class="du lv lw lx ly b">CameraHelper.kt</code>中以保持其可移植性。</li></ul><blockquote class="mb mc md"><p id="0ebc" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">需要注意的一个一般范例是，移动设备上的图像处理和推理可能是相对昂贵的操作，并且将多个用例(尤其是低效用例)流水线化在一起可能会对设备电池和资源产生巨大影响。</p><p id="4b30" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">在本文的最后，我将讨论如何让用例跳过超过某个负载阈值的帧——导致吞吐量降低——但更好地利用资源。</p></blockquote><p id="298c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">主要活动</strong></p><p id="a9d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先要做的是创建预览视图(用户可以看到的摄像机画面):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="27c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我使用了一个专门为渲染相机预览而设计的视图。请注意，尽管视图填充了父视图，但渲染帧的实际尺寸是根据设备屏幕大小和方向通过纵横比计算来设置的。</p><p id="1b57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，绑定这个视图的活动:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="6529" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里没什么特别的:</p><ul class=""><li id="d4e3" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">用所有者、上下文、呈现预览的视图和接收解码的条形码识别结果的回调函数初始化<code class="du lv lw lx ly b">CameraHelper</code>类。</li><li id="157e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">权限处理程序重写将权限结果传递回助手。</li></ul><p id="b4f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lv lw lx ly b">CameraHelper</code>本身就是行动的地方。你可以直接在Github上查看这个类:</p><div class="mk ml ez fb mm mn"><a href="https://github.com/k1dbl4ck/android-camerax-demo/blob/master/app/src/main/java/nl/venters/cameraxdemo/CameraHelper.kt" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">k1dbl4ck/android-camerax-demo</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">一篇关于thewerner.medium.com的文章的源代码</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">github.com</p></div></div></div></a></div><p id="5602" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管不是必需的，但为了方便起见，我们创建了一个<code class="du lv lw lx ly b">typealias</code>监听器对象，传递给分析器，以回调条形码推断的结果:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="d10f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们创建一个<code class="du lv lw lx ly b">ExecutorService</code>来在后台/在它自己的线程上运行<code class="du lv lw lx ly b">ImageAnalysis</code>分析器，以及一些全局属性:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="edf7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">start函数检查是否授予了权限，如果没有，则启动摄像机权限请求，这将导致上面的活动获得权限结果，该结果再次传递给该类的<code class="du lv lw lx ly b">onRequestPermissionsResult</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="cba7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所看到的，这个过程将无限循环，直到用户授予相机权限——因为没有相机，应用程序无法完成它的设计。</p><p id="69ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来,<code class="du lv lw lx ly b">startCamera</code>函数在上下文执行器角色中设置摄像机未来提供者:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="5801" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，我们“瀑布式”选择摄像机(首选后置摄像机)，然后将用例绑定到提供商:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><ul class=""><li id="c0e3" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">按照本文开头描述的<code class="du lv lw lx ly b">bindToLifecycle</code>方法签名，需要一个<code class="du lv lw lx ly b">CameraSelector</code>实例来指示使用哪个硬件传感器(摄像头)。如果您想在视图上添加一个按钮来切换相机，您可以用所需的传感器更新<code class="du lv lw lx ly b">lensFacing</code>并再次调用<code class="du lv lw lx ly b">bindCameraUseCases</code>——但出于扫描条形码的目的，通常不使用“自拍”相机。</li><li id="a16e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">接下来，我们指定用例来运行图像帧</li><li id="d9b8" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">最后，设置要显示预览的表面。</li></ul><p id="fc3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此时——应用程序正在运行，摄像机正在捕捉帧,<code class="du lv lw lx ly b">CameraX</code> API正在将它们发送到指定的用例。</p><p id="e64c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">读取条形码(图像分析用例)</strong></p><p id="6c96" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是激动人心的部分，展示了CameraX及其用例概念的作用:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><ul class=""><li id="d1d9" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">我们扩展了<code class="du lv lw lx ly b">ImageAnalysis.Analyzer</code>基本用例…</li><li id="4526" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">…并覆盖通过一个<code class="du lv lw lx ly b">ImageProxy</code>实例传递的<code class="du lv lw lx ly b">analyze</code>函数。</li></ul><p id="c70c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lv lw lx ly b">imageProxy</code>包含帮助器来获取/设置图像上的数据——在这个例子中，我们简单地将帧作为一个<code class="du lv lw lx ly b">Image</code>实例——但是代理也:</p><ul class=""><li id="0064" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">暴露原始像素缓冲区</li><li id="e2fe" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">启用设置和获取裁剪矩形(子图像)</li><li id="cca5" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">获取图像类型、尺寸和旋转等。</li></ul><blockquote class="mb mc md"><p id="492b" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">注意:图像帧的旋转(或方向)对于推断任务很重要，因为许多CV模型是在某个方向的数据上训练的。您还可以看到它被传递给了BarcodeScanner (MLKit) API。</p></blockquote><p id="d11a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们通过MLKit提供的<code class="du lv lw lx ly b">BarcodeScanner</code> API运行该帧——它有一个回调函数，包含该帧中所有已识别的条形码，然后调用我们的监听器，并给出结果(如果有的话)</p><p id="08b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，<strong class="jq hj"> <em class="ma">以及最重要的</em> </strong>，我们调用<code class="du lv lw lx ly b">imageProxy.close()</code>——这是为了让<code class="du lv lw lx ly b">CameraProvider</code>知道我们已经完成了对帧的处理。不这样做将导致其他用例(包括预览)冻结，因为它假设用例仍在处理中。</p><h1 id="3c40" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">绩效说明</strong></h1><p id="4a15" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">当我们初始化分析器时，我们规定了几个标志来定义<code class="du lv lw lx ly b">CameraProvider</code>的帧缓冲行为:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mi l"/></div></figure><p id="a8a2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">背压</strong></p><p id="714b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于性能来说，这可能是最有用的标志，这取决于您是否想要处理来自相机的每一帧，或者您是否乐于只接收最新的帧。</p><p id="eccb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lv lw lx ly b">ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST</code>将向您的用例发送最新的可用帧。</p><p id="7783" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lv lw lx ly b">ImageAnalysis.STRATEGY_BLOCK_PRODUCER</code>将“暂停”摄像机，直到所提供的帧被分析(并且<code class="du lv lw lx ly b">imageProxy.close()</code>被调用)</p><p id="b994" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">队列深度</strong></p><p id="aa04" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，如果你需要处理每一帧，如果你的代码没有被优化或者花费太长时间，这将会影响性能，所以在这种情况下为了进一步帮助，可以指定一个<code class="du lv lw lx ly b">ImageQueueDepth</code>。根据<a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis.Builder#setImageQueueDepth(int)" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="mb mc md"><p id="30af" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">为<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis#STRATEGY_BLOCK_PRODUCER" rel="noopener ugc nofollow" target="_blank">ImageAnalysis.STRATEGY_BLOCK_PRODUCER</a></code>模式设置摄像机管道可用的图像数量。</p><p id="1977" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">图像队列深度是相机可用以填充数据的图像数量。这包括目前正在被<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis.Analyzer#analyze(androidx.camera.core.ImageProxy)" rel="noopener ugc nofollow" target="_blank">ImageAnalysis.Analyzer.analyze(ImageProxy)</a></code>分析的图像。根据背压策略，增加图像队列深度可能会使相机操作更平滑，但会增加内存使用量。</p><p id="7a5a" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">当背压策略设置为<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis#STRATEGY_BLOCK_PRODUCER" rel="noopener ugc nofollow" target="_blank">ImageAnalysis.STRATEGY_BLOCK_PRODUCER</a></code>时，增加图像队列深度可能会使高负载下的系统上的摄像机流水线运行更平稳。然而，对于当前帧速率，花费在分析图像上的时间仍应保持在单个帧周期内，平均为<em class="hi"/>，以避免停止相机流水线。</p><p id="85d0" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">该值仅适用于<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis#STRATEGY_BLOCK_PRODUCER" rel="noopener ugc nofollow" target="_blank">ImageAnalysis.STRATEGY_BLOCK_PRODUCER</a></code>模式。对于<code class="du lv lw lx ly b"><a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageAnalysis#STRATEGY_KEEP_ONLY_LATEST" rel="noopener ugc nofollow" target="_blank">ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST</a></code>，该值被忽略。</p><p id="96d5" class="jo jp ma jq b jr js ij jt ju jv im jw me jy jz ka mf kc kd ke mg kg kh ki kj hb bi translated">如果未设置，并且此选项由选定的背压策略使用，则默认为6个图像的队列深度。</p></blockquote><p id="7f00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">高级注意:跟踪FPS </strong></p><p id="d845" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如在<a class="ae jn" href="https://github.com/android/camera-samples/blob/2690075bca44d51e4e37df07273d1f8d7fe9846f/CameraXBasic/app/src/main/java/com/android/example/cameraxbasic/fragments/CameraFragment.kt#L547" rel="noopener ugc nofollow" target="_blank">中暗示的，CameraX </a>的官方谷歌示例应用代码<code class="du lv lw lx ly b">ImageAnalysis</code>用例可以在运行时计算当前的FPS速率。</p><p id="f341" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管executor通常运行在自己的后台线程上，但在某些情况下，如果FPS低于某个阈值，简单地调用<code class="du lv lw lx ly b">imageProxy.close()</code>而不是处理帧可能是有用的。</p><p id="8ff1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将这种技术与上面设置的缓冲区标志结合使用，您可以根据需要微调性能。</p><h1 id="267a" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">结论</h1><p id="380e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">本文给出了一个使用新的CameraX API的基本示例。围绕<code class="du lv lw lx ly b">ImageAnalysis</code>基本用例有更多的可能性，我希望在未来的帖子中探索更多的可能性。</p><p id="06bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读，我希望你得到一些有用的见解！</p></div></div>    
</body>
</html>
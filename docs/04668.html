<html>
<head>
<title>JWT(jsonwebtoken) Token Based Authentication using nodeJS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用nodeJS的基于JWT(jsonwebtoken)令牌的身份验证。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jwt-jsonwebtoken-token-based-authentication-using-nodejs-6af661d5a64?source=collection_archive---------8-----------------------#2021-07-01">https://medium.com/geekculture/jwt-jsonwebtoken-token-based-authentication-using-nodejs-6af661d5a64?source=collection_archive---------8-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">首先，我们必须知道什么是JWT？JWT(jsonwebtoken)是npm包，用于在用户<strong class="ih hj">登录到我们的应用程序</strong>时创建<strong class="ih hj">令牌</strong>。</p><ul class=""><li id="ee94" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">令牌的基本结构如下</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es jv"><img src="../Images/6ca341cc49fdfe57c1478d31a805325a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlWL_BxFFQiBuV8h5Lqeqw.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">JWT token structure</figcaption></figure><ul class=""><li id="1bf6" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">头</strong>:-JWT令牌中的头包含一些关于令牌的元数据。我们作为用户不需要在里面写任何东西。</li><li id="44bc" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated"><strong class="ih hj"> Payload </strong> :- Payload是我们必须添加到令牌中以备将来使用的信息。</li><li id="2e58" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated"><strong class="ih hj"> Signature </strong> :- Signature是使用服务器中可用的头、有效载荷和秘密制作的URLencoded文本。将来，同样的秘密将被用于从令牌中提取信息。使用这个秘密是为了只有授权的服务器才能解码令牌。</li></ul><p id="17ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看如何在服务器中使用令牌。</p><h1 id="4f03" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">步骤1:-安装JWT并设置定位部件。</h1><ul class=""><li id="4fd5" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">首先，我们必须使用以下代码将jsonwebtoken包安装到我们的express应用程序中。</li></ul><pre class="jw jx jy jz fd lt lu lv lw aw lx bi"><span id="db26" class="ly kr hi lu b fi lz ma l mb mc"><strong class="lu hj">npm i jsonwetoken --save</strong></span></pre><ul class=""><li id="9ccc" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">现在，我们必须处理应用程序的注册部分。这部分在我之前的博客里有解释。如需进一步参考，请参见下图。</li><li id="20d6" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在我们必须处理“<strong class="ih hj">/用户/注册</strong>”路线。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es md"><img src="../Images/b5307021c6b1929e26e3df78a46e1653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*2bIlisg90pKGLx8QEDobGQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">handling registration part</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="e7fc" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤2:-处理登录路由</h1><ul class=""><li id="721b" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">在这一步中，我们必须验证用户提供的凭证并返回正确的结果。</li><li id="e463" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">对此，可以参考我的另一篇博客《<a class="ae mq" rel="noopener" href="/nerd-for-tech/registration-login-using-the-mongodb-to-store-data-in-expressjs-dba79c8886f2"> <strong class="ih hj"> <em class="mr">注册/登录使用MongoDB在expressJS中存储数据</em> </strong> </a>》链接:-“<a class="ae mq" rel="noopener" href="/nerd-for-tech/registration-login-using-the-mongodb-to-store-data-in-expressjs-dba79c8886f2">https://medium . com/nerd-for-tech/Registration-log in-using-the-MongoDB-to-store-data-in-express js-DBA 79 c 8886 f 2</a>。</li><li id="ffab" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">一旦用户凭据得到验证，我们现在必须创建令牌。</li></ul></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="43a6" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤3:-创建令牌</h1><ul class=""><li id="3a31" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">为了创建令牌，我们必须将<strong class="ih hj"> createToken() </strong>方法添加到我们的<strong class="ih hj">用户</strong>模型中。</li></ul><blockquote class="ms mt mu"><p id="466a" class="if ig mr ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated">提示:-在创建<strong class="ih hj"> createToken </strong>()时，不要使用<strong class="ih hj">箭头功能</strong>。因为我们不得不使用<strong class="ih hj">这个</strong>关键字，它对箭头功能不起作用。</p></blockquote><ul class=""><li id="739a" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">首先，我们必须创建有效负载对象，并添加我们需要添加到令牌内部的数据，以供将来使用。</li><li id="61ac" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在，我们必须将jsonwebtoken导入到用户模型的顶部变量jwt中。</li></ul><pre class="jw jx jy jz fd lt lu lv lw aw lx bi"><span id="218c" class="ly kr hi lu b fi lz ma l mb mc"><strong class="lu hj">let jwt = require('jsonwebtoken');</strong></span></pre><ul class=""><li id="bdea" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">现在，我们可以使用jwt.sign()方法创建一个令牌，它将接受payload作为第一个参数，Secret作为第二个参数。</li></ul><blockquote class="ms mt mu"><p id="aa9d" class="if ig mr ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated">提示:-记住添加秘密到。env文件并使用dotenv包来保守你的秘密。</p></blockquote><ul class=""><li id="12a3" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">创建令牌后，返回令牌。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es my"><img src="../Images/ef7588c2770a88c87ade41523101fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*Nyvv5OknJXvlKRsvwVpSQQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">createToken()</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="2722" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤4:-在我们调用createtoken()的地方返回令牌。</h1><ul class=""><li id="3508" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">还记得我们在哪里调用了createToken()。这是在处理“/用户/登录”路由时发生的。</li><li id="0a0c" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在我们已经在名为<strong class="ih hj"> token的变量中创建了token。</strong></li><li id="fe1c" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在，我们可以随心所欲地用这个作为信物。现在我们正在返回令牌和用户数据。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mz"><img src="../Images/004025be0be70345607102685b7f11db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*zMz5pH31szKtlmtvZTKVKA.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">handling /users/login route</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="72a8" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤5:-使用令牌进行身份验证。</h1><ul class=""><li id="91bf" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">现在，我们有了一个令牌，我们必须使用它来保护路由，只允许登录的用户访问它们。</li><li id="835d" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">这可以通过使用令牌来实现。令牌可用于查找登录用户的信息。</li><li id="a141" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">在React中，我们可以在访问路由时直接传递令牌，但现在，我们将使用POSTMAN应用程序在请求路由时将令牌发送到标头中。</li><li id="fd1f" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">在POSTMAN应用程序中，我们必须在头中创建一个名为“Authorization”的新字段，并且作为一个值，我们必须粘贴一个令牌。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es na"><img src="../Images/278a25c7581d62276d75179c89cab85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOkieLb1njW8QRnvlB5kwQ.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">using postman to send tokens.</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="502f" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤6:-在中间件文件夹中创建auth.js文件</h1><ul class=""><li id="cab4" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">现在，我们必须在名为<strong class="ih hj">中间件</strong>的文件夹中创建一个<strong class="ih hj"> auth.js </strong>文件。</li><li id="14cc" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在，我们必须在<strong class="ih hj"> auth.js </strong>文件的<strong class="ih hj"> </strong>内部编写一个名为<strong class="ih hj"> isLoggedIn() </strong>的方法。</li><li id="bf19" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">首先，在文件顶部导入jsonwebtoken。</li><li id="2db2" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">现在，在isLoggedIn()中，我们可以通过访问<strong class="ih hj"> req.headers. </strong>来访问由POSTMAN应用程序发送的令牌</li><li id="1cc5" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">如果没有令牌，那么我们可以向用户发送一条错误消息。</li><li id="5993" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">如果有令牌，我们可以使用<strong class="ih hj"> jwt.verify() </strong>方法，该方法接受<strong class="ih hj">令牌</strong>作为第一个参数，接受<strong class="ih hj">秘密</strong>作为第二个参数。</li><li id="caaa" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">jwt.verify() 方法返回令牌内的有效负载作为结果。</li><li id="03c5" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">一旦我们有了有效负载，我们就可以将它放入req.user并调用next()方法。由于这个信息，有效载荷内的信息可用于下一个中间件。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es nb"><img src="../Images/c310606fee07d75b7142d1a0c42e1723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*qSMsDU1pphXqKzOJJ3YDGQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">isLoggedIn() inside auth.js file</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="ee0a" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">步骤7:-当我们需要授权时，在auth.js文件中使用“isLoggedIn()”方法。</h1><ul class=""><li id="8cec" class="jm jn hi ih b ii lo im lp iq lq iu lr iy ls jc jr js jt ju bi translated">对于任何路由，如果我们需要保护它不被未登录的用户访问，我们可以使用isLoggedIn()方法。</li><li id="8e1a" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">假设我们必须保护route "/profiles/:profileName "不被未登录的用户访问。</li><li id="411e" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">我们可以在处理路由时添加auth.isLoggedIn中间件，如下所示。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es nc"><img src="../Images/b3909d1daf4524414abed45ea5b1829e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*1O5R0laxuOrd_JOdVYezag.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">using <strong class="bd ks">auth.isLoggedIn</strong> middleware</figcaption></figure><ul class=""><li id="3b45" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">一旦我们添加了这个中间件，只有已登录的用户才能看到正确的响应，而未登录的用户将会收到一条错误消息“您需要登录”。</li><li id="e933" class="jm jn hi ih b ii kl im km iq kn iu ko iy kp jc jr js jt ju bi translated">还有一个特性是我们可以访问存在于<strong class="ih hj"> req.user </strong>对象中的登录用户信息。</li></ul></div></div>    
</body>
</html>
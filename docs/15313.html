<html>
<head>
<title>Dynamics Modelling and Simulation of Self-balancing Robot in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于C++的自平衡机器人动力学建模与仿真</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dynamics-modelling-and-simulation-of-self-balancing-robot-in-c-d32a3b835bbf?source=collection_archive---------6-----------------------#2022-10-25">https://medium.com/geekculture/dynamics-modelling-and-simulation-of-self-balancing-robot-in-c-d32a3b835bbf?source=collection_archive---------6-----------------------#2022-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a1c6e1205149025c0a2ac2ea85bbfb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DEeGlnodwFh6hwiCOGvjBQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">(by author)</figcaption></figure><div class=""/><p id="6d44" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的文章展示了开发机器人和控制系统的动态模型的通用方法。本文将关注一个简单的自平衡机器人(<a class="ae js" href="https://en.wikipedia.org/wiki/Segway" rel="noopener ugc nofollow" target="_blank"> Segway </a>)，由二阶运动方程(<a class="ae js" href="https://en.wikipedia.org/wiki/Lagrangian_mechanics" rel="noopener ugc nofollow" target="_blank">拉格朗日力学</a>描述。</p><p id="0534" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将一步一步地向您展示如何实现这样的解决方案，但是，我不打算将重点放在运动物理现象和数学关系上(这里用于控制系统目的)。运动方程通过应用数值方法求解(Rutte Kuta fort order——我在以前的一篇文章中详细讨论过——<a class="ae js" rel="noopener" href="/geekculture/numerical-computation-in-c-part-2-33dcdbe6c726">这里</a>)。我用C++进行了整个模拟，但是我用Python (SymPy库)计算的符号方程的解。你可以在我的<a class="ae js" href="https://github.com/markusbuchholz/modelling_Self-balancing_Robot_in_Cpp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到以下项目的文件。</p><p id="7eda" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，了解如何建立机器人或其他动态系统的物理模型，我相信知道如何解决微分方程是很重要的。在这个项目中，你会发现解决这类方程的简单方法。请仔细学习，这样它会让你在未来解决类似或更复杂的挑战。</p><p id="a61e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里你可以看到机器人在工作。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es jt"><img src="../Images/b8f3bf25512076f1b217a45591f135bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*pbTbGx0yfBkzkzXJKyle8g.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">medium.com (by <a class="ae js" rel="noopener" href="/@dominiknowak_87058">Dominik Nowak</a>)</figcaption></figure><p id="ea28" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">已经使用头文件(用于绘图库)绘制了模拟，头文件必须包含在与您的cpp相同的文件夹中(您可以从我的存储库中克隆所有文件)。<br/>你的程序可以编译如下:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="03de" class="kd ke hx jz b fi kf kg l kh ki">//compile<br/>g++ my_prog.cpp -o my_prog -I/usr/include/python3.8 -lpython3.8// </span><span id="9b56" class="kd ke hx jz b fi kj kg l kh ki">//run<br/>./my_prog</span><span id="c6c1" class="kd ke hx jz b fi kj kg l kh ki">//folder tree<br/>├── my_prog<br/>├── my_prog.cpp<br/>├── matplotlibcpp.h</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="11f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">动态模型可推导如下(查看<a class="ae js" href="https://www.tandfonline.com/doi/pdf/10.1080/21642583.2017.1413436" rel="noopener ugc nofollow" target="_blank">系统科学&amp;控制工程期刊文章</a>)。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kr"><img src="../Images/7ef66ca7929fd76e283eb78b46468d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LHzIdnnnPROA5E-PszvOw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">self-balancing robot model (by author)</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="7ed6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了描述所描绘的机器人的模型，我们使用拉格朗日方程，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es ks"><img src="../Images/fbe1f7106e6491e8dab3b84cad246948.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*60ROoVWT_sVcUGzwnXi9kg.png"/></div></figure><p id="929c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其中<strong class="iw hy"> L </strong>为拉格朗日量(系统中动能<strong class="iw hy"> K </strong>和势能<strong class="iw hy"> U </strong>之和)。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kt"><img src="../Images/7044cc957824de3620496f9eb37d9479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*j7O9yiHd_tVqeRryYh_v1w.png"/></div></figure><p id="31c9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据上图，我们可以推导出一组动力学方程(拉格朗日方程)，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ku"><img src="../Images/6f1cdcd6b83c170c49e854e9b5c4a0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8vWxQQ2UHhW31K9_XrRHA.png"/></div></div></figure><p id="145f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其中<strong class="iw hy"> u </strong>是安装在机器人车轮上的电机扭矩。</p><p id="72b1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了求解这些方程，我们可以将它们转换成如下表示的矩阵，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/08bf8f3ae60b71cf4600ea649d55c80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4Ji2bkdxEDYsZ4Sj4ILmQ.png"/></div></div></figure><p id="a741" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">利用这个公式，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/683eeb117959582fcbfe6dba78115618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*4w0KTF0_WwD1DWCMnt5-MQ.png"/></div></figure><p id="b990" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们得到一组<strong class="iw hy">微分方程</strong>(用C++实现的详细解见Jupyter笔记本) :</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kx"><img src="../Images/f511fd328d5520723bff033c8a686c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*o7nlEKC8UspWw8uOoxxcjQ.png"/></div></figure><p id="c153" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在哪里，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es ky"><img src="../Images/7d3ee0d85a8a81971c68541b0f124cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*TBxUuKlHsX3xrm7DAGE1oA.png"/></div></figure><p id="d650" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">稍后，平衡机器人的电机扭矩计算如下(这是一个<a class="ae js" href="https://en.wikipedia.org/wiki/PID_controller" rel="noopener ugc nofollow" target="_blank"> PD控制器</a>，其系数在开发过程中进行了调整)。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kz"><img src="../Images/57882bf4d266649cb4514de30471f5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe0PqWdi-y7ORDITTZ_JGw.png"/></div></div></figure><p id="a402" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，计算加速度的微分方程包括控制信号<strong class="iw hy"> u </strong>(扭矩)——上面的定义，其是在动态系统的当前状态的相同时间戳中计算的。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="bef8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下一节中，我将描述一些模拟，您可以自己运行这些模拟。既然要计算动态模型，就必须正确选择<strong class="iw hy"> u(t) </strong>信号中的系数。鼓励调整不同的系数并模拟机器人的初始位置。</p><p id="b282" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于摆锤的初始位置等于30度，我们可以画出摆锤(蓝色)和轮子(橙色)的位置，KD2 = 1000。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/7c27cdf8db8102284821c62dd73a0a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2LJCXJFIeB2zJMgD3fTbg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">pendulum and wheel positions</figcaption></figure><p id="1bb8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于摆锤的初始位置等于30度，我们可以绘制摆锤(蓝色)和轮子(橙色)的角速度，KD2 = 2000。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/12909b819cc18f54ac6a5d6c1d6c8218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiG1rPeLQsRsvgIByUQr5A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">pendulum and wheel angular speeds</figcaption></figure><p id="9e99" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">类似地，对于摆锤的相同初始位置等于30度，我们可以模拟并绘制摆锤(蓝色)和滚轮(橙色)的位置，但是微分增益KD2 = 500。如你所见，稳定机器人需要更长的时间。</p><p id="72a4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">角度位置，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/d0ae6e68dd7cb14989980ff4df61eda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRad-EwMVbLB6hO234xSNQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">pendulum and wheel positions</figcaption></figure><p id="3674" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">角速度，</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/2e006428280f93194f58a77db2b1d644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwLJC6vaMRqn9_HeLR_MEA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">pendulum and wheel angular speeds</figcaption></figure><p id="bea2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
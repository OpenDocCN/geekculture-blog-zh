<html>
<head>
<title>Demystifying Object-Oriented Programming in a Software Architect Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从软件架构师的角度揭开面向对象编程的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/demystifying-object-oriented-programming-in-a-software-architect-perspective-4191186aebe2?source=collection_archive---------40-----------------------#2021-06-29">https://medium.com/geekculture/demystifying-object-oriented-programming-in-a-software-architect-perspective-4191186aebe2?source=collection_archive---------40-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fa52e78a3aa54d83599e3d20c01a7989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3V7__7IxWFZtKMj"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@killerfvith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex wong</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1153" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">工作的软件和正确工作的软件是有区别的。构建有效的软件，只考虑它的行为，是一项半途而废的工作。软件工程师应该通过考虑软件的结构来构建灵活且可伸缩的软件。好的软件来自好的结构，好的结构来自好的架构。因此，像软件架构师一样思考是很重要的。</p><h2 id="27f2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">面向对象编程</h2><p id="8d92" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">十之八九的人将面向对象编程(OOP)描述为“模拟现实世界的一种方式”，或者使用以下概念:<strong class="ix hj">封装</strong>、<strong class="ix hj">继承</strong>和<strong class="ix hj">多态</strong>。然而，封装、继承和多态对于OOP来说并不独特，也不新奇；事实上，这些概念已经在c等非面向对象语言中广泛使用。</p><blockquote class="kt ku kv"><p id="d083" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">如果所谓的OOP概念不是OOP独有的，是什么让OOP如此强大和特别？</p></blockquote><p id="4faa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Bob叔叔回答这个问题时说<strong class="ix hj">“OO是使用多态性获得对系统中每个源代码依赖的绝对控制的能力。”</strong></p><p id="7358" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为他的回答揭示了我们为什么使用OOP的本质。在面向对象语言出现之前，多态性是手工操作的，而且有风险，因为工程师必须显式地使用指向函数的指针。然而，面向对象语言使多态更加容易和安全，允许工程师最大化多态的好处。在本文中，我将用具体的例子来论证他的答案。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><blockquote class="kt ku kv"><p id="05ca" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">当我使用术语<strong class="ix hj">多态</strong>时，我指的是动态多态，也称为运行时多态。</p></blockquote><h2 id="f2e1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">多态性概述</h2><p id="abbb" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">多态性是采取多种形式的能力。当子类或基类从超类继承一个方法并重新定义它时，多态性通过方法覆盖来实现。您可以通过使用继承重写超类的方法或实现接口的方法来重写方法。</p><ul class=""><li id="df11" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js lm ln lo lp bi translated"><strong class="ix hj">继承</strong>是在子类中使用超类的结构和行为。继承使用<em class="kw"> extend </em>关键字对“is-a”关系进行建模。</li><li id="3934" class="lh li hi ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">接口正在用方法签名定义一组行为。接口使用<em class="kw">实现</em>关键字来建模“能够”关系。</li></ul><h2 id="6ec0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">为什么我们使用多态性</h2><p id="2bbf" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">多态性可以概括、分离和消除源代码之间的依赖性。让我们看一个非常简化的例子。</p><p id="3c54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有一个将用户名保存到数据库Redis的业务类。Redis类是一个简单的类，具有读写方法。</p><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="d58c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如图所示，依赖关系和控制流是一致的。业务类<strong class="ix hj">依赖于</strong>Redis类，因为业务类明确地提到并访问Redis类。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/4e5801bbfcb3446396ffe39f9eb7498a.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*GggHZLjiYLAApAvext4pKQ.png"/></div></figure><p id="22ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个系统运行良好，直到你的经理要求你使用不同的数据库。如果你想增加或改变数据库，你必须<strong class="ix hj">改变</strong>业务类的代码。现在，这将是一个很好的时机来想办法<strong class="ix hj">消除商业类对Redis类的依赖</strong>。这就是<strong class="ix hj">多态性</strong>发挥作用的地方。</p><h2 id="dc5f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">多态性和依赖性倒置</h2><p id="9e1f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">通过使用多态性，我们可以完全控制源代码的依赖性。回到例子，让我们抽象Redis类并创建一个数据库接口。</p><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="bea4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Redis类可以实现数据库接口并覆盖读写方法。</p><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="9253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以将Redis实例化为一种数据库类型。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="1daa" class="jt ju hi md b fi mh mi l mj mk">Database redisDatabase = new Redis();</span></pre><p id="7eb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以更改saveName方法，将Database而不是Redis作为其参数。</p><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="f9f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在发生了什么？商务类对Redis一无所知，也不提Redis类。换句话说，业务类不再依赖于Redis类。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/41b5e63c03fd7d2cb0201320a4647384.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*8WITZFQSox1gLTfCMH60qw.png"/></div></figure><p id="b602" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Redis实现并依赖于数据库接口，但是控制流是从业务类到Redis类的。因此，Redis和数据库接口之间的代码依赖与控制流的方向相反。这就是<strong class="ix hj">依赖反转</strong>！根据依赖倒置原则(DIP)，"<strong class="ix hj">最灵活的系统是那些源代码依赖仅指抽象而非具体化的系统。</strong>“在我们的例子中，数据库接口是抽象的，Redis类是具体化的。</p><p id="4dd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用多态性，当我们想要添加或更改数据库时，我们不再需要更改业务类。我们所要做的就是创建一个实现数据库接口的新的具体类。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="d102" class="jt ju hi md b fi mh mi l mj mk">Database redisDatabase = new Redis();<br/>business.saveName(redisDatabase, "Sohee");</span><span id="89b3" class="jt ju hi md b fi mm mi l mj mk">Database mySqlDatabase = new MySql();<br/>business.saveName(mySqlDatabase, "Sohee");</span></pre></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="c28a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">面向对象语言中的多态性给了工程师们很大的力量来构建一个更加灵活的系统，并且可以扩展。特别是在变化频繁的易变系统中，依赖倒置有助于打破耦合。我希望你能更好地理解鲍勃叔叔的观点。如果有人问OO是什么，你可以引用他的话，说"<strong class="ix hj">它是通过使用多态性，获得对系统中每个源代码依赖的绝对控制的能力。</strong></p><blockquote class="kt ku kv"><p id="ceec" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">这篇文章基于罗伯特·c·马丁的《干净的建筑》。鲍勃叔叔。我使用的所有引语都来自这本书。我强烈推荐阅读它。</p></blockquote></div></div>    
</body>
</html>
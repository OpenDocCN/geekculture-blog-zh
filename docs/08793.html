<html>
<head>
<title>LeetCode — Symmetric tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —对称树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-symmetric-tree-b977d2970806?source=collection_archive---------17-----------------------#2021-11-14">https://medium.com/geekculture/leetcode-symmetric-tree-b977d2970806?source=collection_archive---------17-----------------------#2021-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="377c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="c4ff" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定二叉树的<em class="kb">根</em>，<em class="kb">检查它是否是自身</em>的镜像(即围绕其中心对称)。</p><p id="8463" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/symmetric-tree T4】</p><p id="0791" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/978889b29fd9336eed2548edaeff3379.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*vB3xwj1zPmQ15K6v.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="1683" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [1, 2, 2, 3, 4, 4, 3] <br/>Output: true</span></pre><p id="074d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es la"><img src="../Images/c7a329b7f22345642a7576ef013b8cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*_0H5t2z43SXSTO63.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="a90a" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [1, 2, 2, null, 3, null, 3] <br/>Output: false</span></pre><p id="d389" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束条件</strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="3062" class="kv ig hi kr b fi kw kx l ky kz">- The number of nodes in the tree is in the range [1, 1000]. <br/>- -100 &lt;= Node.val &lt;= 100</span></pre><h1 id="6974" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="445c" class="kv ig hi bd ih lb lc ld il le lf lg ip jo lh li it js lj lk ix jw ll lm jb ln bi translated">递归函数</h2><p id="bcc5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在解决与树相关的问题时，递归是最佳选择。如果不是递归，迭代方法将使用队列。</p><p id="d48a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们在这篇博客中探索一个简单的递归方法。方法是使用两个指针作为指向树的根的参数。第一个指针向左移动，第二个向右移动，验证节点是否相同。</p><p id="b271" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="d3ae" class="kv ig hi kr b fi kw kx l ky kz">// main function<br/>- call recursive function areSymmetric(root, root)<br/><br/>// areSymmetric function(root1, root2)<br/>- if !root1 &amp;&amp; !root2<br/>  - return true<br/>- else<br/>  - if root1 &amp;&amp; root2<br/>    - if root1-&gt;val == root2-&gt;val<br/>      - return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right, root2-&gt;left)<br/><br/>- return false</span></pre><h2 id="5441" class="kv ig hi bd ih lb lc ld il le lf lg ip jo lh li it js lj lk ix jw ll lm jb ln bi translated">C++解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="cdc0" class="kv ig hi kr b fi kw kx l ky kz">bool areSymmetric(TreeNode* root1, TreeNode* root2){<br/>    if(!root1 &amp;&amp; !root2){<br/>        return true;<br/>    } else {<br/>        if(root1 &amp;&amp; root2){<br/>            if(root1-&gt;val == root2-&gt;val){<br/>                return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp;<br/>                    areSymmetric(root1-&gt;right, root2-&gt;left);<br/>            }<br/>        }<br/>        return false;<br/>    }<br/>}<br/><br/>class Solution {<br/>public:<br/>    bool isSymmetric(TreeNode* root) {<br/>        return areSymmetric(root, root);<br/>    }<br/>};</span></pre><h2 id="e3b8" class="kv ig hi bd ih lb lc ld il le lf lg ip jo lh li it js lj lk ix jw ll lm jb ln bi translated">戈朗溶液</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="eda9" class="kv ig hi kr b fi kw kx l ky kz">func areSymmetric(root1 *TreeNode, root2 *TreeNode) bool {<br/>    if root1 == nil &amp;&amp; root2 == nil {<br/>        return true<br/>    } else {<br/>        if root1 != nil &amp;&amp; root2 != nil {<br/>            if root1.Val == root2.Val {<br/>                return areSymmetric(root1.Left, root2.Right) &amp;&amp; areSymmetric(root1.Right, root2.Left)<br/>            }<br/>        }<br/>    }<br/><br/>    return false<br/>}<br/><br/>func isSymmetric(root *TreeNode) bool {<br/>    return areSymmetric(root, root)<br/>}</span></pre><h2 id="d4a7" class="kv ig hi bd ih lb lc ld il le lf lg ip jo lh li it js lj lk ix jw ll lm jb ln bi translated">Javascript解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="9d38" class="kv ig hi kr b fi kw kx l ky kz">var areSymmetric = function(root1, root2) {<br/>    if(!root1 &amp;&amp; !root2) {<br/>        return true;<br/>    } else {<br/>        if(root1 &amp;&amp; root2) {<br/>            if(root1.val == root2.val) {<br/>               return areSymmetric(root1.left, root2.right) &amp;&amp; areSymmetric(root1.right, root2.left);<br/>            }<br/>        }<br/>    }<br/><br/>    return false;<br/>}<br/><br/>var isSymmetric = function(root) {<br/>    return areSymmetric(root, root);<br/>};</span></pre><p id="2bd8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="04e5" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [1, 2, 2, 3, 4, 4, 3]<br/><br/>// in main function<br/>Step 1: return areSymmetric(root, root)<br/><br/>// in areSymmetric function<br/>Step 2: if !root1 &amp;&amp; !root2<br/>          - root1 != nil<br/>            1 != nil<br/>            true<br/><br/>          - root2 != nil<br/>            1 != nil<br/>            true<br/><br/>          - !true &amp;&amp; !true<br/>          - false<br/><br/>        else<br/>          if root1 &amp;&amp; root2<br/>            - 1 &amp;&amp; 1<br/>            - true<br/><br/>            if root1-&gt;val == root2-&gt;val<br/>               - 1 == 1<br/>               - true<br/><br/>               return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right &amp;&amp; root2-&gt;left)<br/>               return areSymmetric(2, 2) &amp;&amp; areSymmetric(2, 2)<br/><br/>               // we will ignore the 2nd condition here, since both are same.<br/>               // In actual recursive call it will be evaluated.<br/><br/>Step 3: if !root1 &amp;&amp; !root2<br/>          - root1 != nil<br/>            2 != nil<br/>            true<br/><br/>          - root2 != nil<br/>            2 != nil<br/>            true<br/><br/>          - !true &amp;&amp; !true<br/>          - false<br/><br/>        else<br/>          if root1 &amp;&amp; root2<br/>            - 2 &amp;&amp; 2<br/>            - true<br/><br/>            if root1-&gt;val == root2-&gt;val<br/>               - 2 == 2<br/>               - true<br/><br/>            return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right &amp;&amp; root2-&gt;left)<br/>            return areSymmetric(3, 3) &amp;&amp; areSymmetric(4, 4)<br/><br/>// areSymmetric(3, 3)<br/>Step 4: if !root1 &amp;&amp; !root2<br/>          - root1 != nil<br/>            3 != nil<br/>            true<br/><br/>          - root2 != nil<br/>            3 != nil<br/>            true<br/><br/>          - !true &amp;&amp; !true<br/>          - false<br/><br/>        else<br/>          if root1 &amp;&amp; root2<br/>            - 3 &amp;&amp; 3<br/>            - true<br/><br/>            if root1-&gt;val == root2-&gt;val<br/>               - 3 == 3<br/>               - true<br/><br/>            return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right &amp;&amp; root2-&gt;left)<br/>            return areSymmetric(nil, nil) &amp;&amp; areSymmetric(nil, nil)<br/><br/>// areSymmetric(nil, nil)<br/>Step 5: if !root1 &amp;&amp; !root2<br/>          - root1 != nil<br/>            nil != nil<br/>            false<br/><br/>          - root2 != nil<br/>            nil != nil<br/>            false<br/><br/>          - !false &amp;&amp; !false<br/>          - true<br/><br/>// areSymmetric(4, 4)<br/>Step 6: if !root1 &amp;&amp; !root2<br/>          - root1 != nil<br/>            4 != nil<br/>            true<br/><br/>          - root2 != nil<br/>            4 != nil<br/>            true<br/><br/>          - !true &amp;&amp; !true<br/>          - false<br/><br/>        else<br/>          if root1 &amp;&amp; root2<br/>            - 4 &amp;&amp; 4<br/>            - true<br/><br/>            if root1-&gt;val == root2-&gt;val<br/>               - 4 == 4<br/>               - true<br/><br/>            return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right &amp;&amp; root2-&gt;left)<br/>            return areSymmetric(nil, nil) &amp;&amp; areSymmetric(nil, nil)<br/><br/>            // areSymmetric(nil, nil) returns true<br/>            // so we move back from step 6 to step 5 till step 2 and evaluate<br/><br/>            return areSymmetric(root1-&gt;left, root2-&gt;right) &amp;&amp; areSymmetric(root1-&gt;right &amp;&amp; root2-&gt;left)<br/><br/>            // which is true<br/><br/>So the answer we return is true.</span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="48c1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原发布于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-symmetric-tree" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>useCallbackState: the hook that let you run code after a setState operation finished.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">useCallbackState:让您在setState操作完成后运行代码的钩子。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/usecallbackstate-the-hook-that-let-you-run-code-after-a-setstate-operation-finished-25f40db56661?source=collection_archive---------4-----------------------#2022-01-21">https://medium.com/geekculture/usecallbackstate-the-hook-that-let-you-run-code-after-a-setstate-operation-finished-25f40db56661?source=collection_archive---------4-----------------------#2022-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e817f437ba5e936961afbd4bcccf2399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EU5ECPbg5FD8PvQnSg7CWA.png"/></div></div></figure><p id="f10e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React中功能组件的状态由useState挂钩管理。这个钩子返回一个tuple(一个有两个元素的数组，但是你知道tuple看起来更专业)，其中第一个元素是状态变量，第二个元素是这个状态的setter。</p><p id="f2e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是不可避免的，因为这就是React处理反应的方式。React可以知道它需要重新渲染，因为您已经使用了setState函数来改变状态，如果您试图直接改变状态变量，它将不会重新渲染。</p><p id="9242" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">setState函数的另一个注意事项是它是异步的:如果你正在运行一个函数并且你正在设置状态，你不能在同一个函数中访问更新的值。更重要的是，如果你必须在变量设置后运行一些代码，你没有办法在函数内部运行。你需要做的是创建一个依赖于你正在设置的状态变量的useEffect，并在useEffect中执行你的逻辑。</p><p id="e366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不仅可读性差得多，而且还有一个小小的警告，在某些特定的情况下可能并不可取。只有在运行特定的setState时，您才无法运行代码。使用useEffect，你的代码将在每次变量改变时运行，不管是谁改变了它。</p><p id="a350" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你有可以设置你的状态的按钮，你只想在按钮A设置状态后运行代码，而不想在按钮B设置状态时运行。使用useEffect方法无法做到这一点。</p><p id="4287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，今天一切都变了！</p><h1 id="5aa4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">useCallbackState挂钩</h1><p id="ee58" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我创建了一个定制的钩子来解决这个问题。初始api与react中的useState挂钩相同，唯一的区别是setState函数也可以接受回调作为输入。这个回调保证在状态更新后被调用，并且新的状态也作为输入被传递。</p><p id="de03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一下代码，然后我们可以评论它做了什么。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="427c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它做的第一件事是创建一个传递initialValue的状态变量。然后，它在ref中创建一个回调队列，该队列以空数组开始。</p><p id="713d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们找到了钩子的核心:有一个useEffect钩子，它在每次状态改变时再次运行，遍历回调数组并调用每个传递新状态的回调。在循环之后，它刷新队列。</p><p id="9cbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后是setState函数，最后get返回给用户:它接受新值和回调作为输入，设置新的状态，如果有回调并且是函数，就把回调添加到队列中。这确保了当useEffect运行时，只有设置了回调的setState会执行他的代码。</p><p id="ef04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将元组返回给用户。</p><p id="c8bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法相当简单:</p><pre class="kr ks kt ku fd kx ky kz la aw lb bi"><span id="bbf4" class="lc jp hi ky b fi ld le l lf lg">import useCallbackState from "./hooks/useCallbackState";</span><span id="4fd9" class="lc jp hi ky b fi lh le l lf lg">import "./styles.css";</span><span id="10b4" class="lc jp hi ky b fi lh le l lf lg">export default function App() {</span><span id="e2eb" class="lc jp hi ky b fi lh le l lf lg">const [test, setTest] = useCallbackState&lt;boolean&gt;(true);</span><span id="df6f" class="lc jp hi ky b fi lh le l lf lg">return (<br/>    &lt;&gt;<br/>        &lt;button onClick={() =&gt; { setTest((prev) =&gt; !prev,<br/>            (newVal) =&gt;{<br/>                console.log("The value changed", newVal);<br/>            });}}&gt;<br/>                Change<br/>        &lt;/button&gt;<br/>        &lt;button onClick={() =&gt; { setTest((prev) =&gt; !prev);}}&gt;<br/>                Change noCallback<br/>        &lt;/button&gt;<br/>    &lt;/&gt;<br/>);}</span></pre><p id="8a14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个按钮将在更改后触发控制台日志，第二个按钮不会。</p><p id="6713" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想让一个类型安全的钩子与你的精彩的类型脚本项目一起工作，我还准备了一个类型脚本版本的钩子。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2143" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想快速地使用钩子，这里有一个代码沙箱供你使用。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="li kw l"/></div></figure></div></div>    
</body>
</html>
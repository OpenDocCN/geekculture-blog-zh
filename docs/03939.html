<html>
<head>
<title>Go &amp; GitHub Workflows: Automating Database-Dependent Application Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go &amp; GitHub工作流:自动化数据库相关的应用程序测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/go-github-workflows-automating-database-dependent-application-tests-4a79ee489848?source=collection_archive---------49-----------------------#2021-06-17">https://medium.com/geekculture/go-github-workflows-automating-database-dependent-application-tests-4a79ee489848?source=collection_archive---------49-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c5d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我开发了一个Go应用程序，其测试套件依赖于MySQL来运行。</p><p id="8e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文演示了如何在GitHub Actions工作流中运行测试套件。</p><p id="5179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自动化Docker构建和推送过程，同时确保只有在测试通过的情况下映像才会被推送到Docker Hub，这提高了我的部署管道的效率。</p><p id="74c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker文件的内容、一些shell脚本和工作流的配置(在一个名为<code class="du jd je jf jg b">main.yml</code>的文件中定义)将是这里的重点。</p><p id="8845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我假设读者熟悉Docker和GitHub操作的基础。</p><p id="cf98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，我是GitHub Actions的初学者，如果这些不是最佳实践，我会感谢更有经验的人的反馈。</p><p id="cd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">docker file</strong></p><p id="9ebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker文件的第一步指示构建获取最新的Golang图像，并定义一些设置环境变量的构建参数。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="909e" class="jp jq hi jg b fi jr js l jt ju">FROM golang:latest as go</span><span id="430e" class="jp jq hi jg b fi jv js l jt ju">LABEL author=”Joe Soap &lt;joesoap@somedomain.com&gt;”</span><span id="f788" class="jp jq hi jg b fi jv js l jt ju">ARG DB_HOST<br/>ENV DB_HOST=$DB_HOST<br/>ARG DB_PORT<br/>ENV DB_PORT=$DB_PORT<br/>ARG DB_USERNAME<br/>ENV DB_USERNAME=$DB_USERNAME<br/>ARG DB_PASSWORD<br/>ENV DB_PASSWORD=$DB_PASSWORD<br/>ARG DB_DATABASE<br/>ENV DB_DATABASE=$DB_DATABASE<br/>ARG DB_CONNECTION<br/>ENV DB_CONNECTION=$DB_CONNECTION</span></pre><p id="8611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，构建被指示创建一个项目目录，在那里安装Revel框架，然后将工作目录指向项目目录，并将项目的内容复制到那里。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="dc7e" class="jp jq hi jg b fi jr js l jt ju">RUN mkdir $GOPATH/github.com<br/>RUN mkdir $GOPATH/github.com/…<br/>RUN mkdir $GOPATH/github.com/…/…<br/>RUN go get github.com/revel/revel<br/>RUN go get github.com/revel/cmd/revel<br/>RUN export PATH=”$PATH:$GOPATH/bin”<br/>WORKDIR $GOPATH/github.com/…/…<br/>COPY . .</span></pre><p id="973c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是安装项目的Go依赖项的指令:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="6b7b" class="jp jq hi jg b fi jr js l jt ju">RUN go list -m -u all</span></pre><p id="97e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…以及向项目根目录中的两个shell脚本授予执行权限的指令:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="c911" class="jp jq hi jg b fi jr js l jt ju">RUN chmod +x ./start.sh<br/>RUN chmod +x ./test.sh</span></pre><p id="4048" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一条指令运行<code class="du jd je jf jg b">test.sh</code>脚本。如果测试通过，映像构建将完成(稍后将详细介绍):</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="4145" class="jp jq hi jg b fi jr js l jt ju">RUN ./test.sh<br/>EXPOSE 9000<br/>CMD [“./start.sh”]</span></pre><p id="cd4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">外壳脚本</strong></p><p id="4c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的两个shell脚本是<code class="du jd je jf jg b">start.sh </code>和<code class="du jd je jf jg b">test.sh</code>。</p><p id="6209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一开始，两个脚本都执行创建应用程序模式的命令(如果还不存在)，并运行任何未完成的数据库迁移以更新模式。</p><p id="4e18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此后，<code class="du jd je jf jg b">start.sh</code>将启动API服务，而<code class="du jd je jf jg b">test.sh</code>将运行应用程序测试。<code class="du jd je jf jg b">test.sh</code>仅在构建过程中运行(根据Dockerfile <code class="du jd je jf jg b">RUN ./test.sh</code>中的指令)。<code class="du jd je jf jg b">start.sh </code>是容器本身运行时运行(<code class="du jd je jf jg b">CMD ["./start.sh"]</code>)。</p><p id="bb56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行时，应用程序的容器通过主机网络访问主机操作系统的MySQL服务(稍后将详细介绍)。因此，测试需要反映这种行为。</p><p id="8fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">test.sh</code>的内容是:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="d0a6" class="jp jq hi jg b fi jr js l jt ju">#!/bin/bash</span><span id="9003" class="jp jq hi jg b fi jv js l jt ju">echo “executing test shell”<br/>go run command/main.go make-database<br/>go run command/main.go migrate up</span><span id="b1bf" class="jp jq hi jg b fi jv js l jt ju">echo “running tests”<br/>if revel test -a . -v | grep -q ‘All Tests Passed.’; then<br/>   echo “All Tests Passed.”<br/>else raise error “API tests failed”<br/>fi</span></pre><p id="7c1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前两个命令(<code class="du jd je jf jg b">...make-database </code>和<code class="du jd je jf jg b">...migrate up</code>)创建和/或更新数据库。当在构建过程中执行时，总是会创建一个新的模式并使其保持最新。</p><p id="6004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三个也是最后一个命令运行应用程序测试(<code class="du jd je jf jg b">revel test -a . -v</code>)，如果测试命令的输出不是“所有测试都通过”，则通过抛出一个错误来评估结果在这种情况下，构建过程将失败，Docker Hub上的<code class="du jd je jf jg b">latest </code>映像将不会被替换。</p><p id="c0e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作流程中执行测试时，可以看到测试的输出:</p><figure class="jh ji jj jk fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jw"><img src="../Images/d55b1746f490125f325b8b36e8684517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wy59noJGKicz4pqy6FJeaQ.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Excerpt from a Workflow’s output</figcaption></figure><p id="6bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">main . yml</strong></p><p id="570a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简洁起见，将只详细讨论<strong class="ih hj"> main.yml </strong>文件中向构建公开主机网络所必需的部分。</p><p id="c933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，<code class="du jd je jf jg b">main.yml </code>定义了工作流的触发器:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="6e56" class="jp jq hi jg b fi jr js l jt ju">name: CI to Docker Hub<br/>on:<br/> push:<br/>  branches: [ master ]<br/> pull_request:<br/>  branches: [ master ]<br/> workflow_dispatch:</span></pre><p id="3c74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，它定义了工作流将要执行的作业(在本例中只有一个— <code class="du jd je jf jg b">build</code>)。它还使用属性<code class="du jd je jf jg b">runs-on</code>指定构建将在其中发生的主机操作系统(最新的Ubuntu):</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="6273" class="jp jq hi jg b fi jr js l jt ju"> jobs:<br/>  build:<br/>   runs-on: ubuntu-latest</span></pre><p id="ca4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ubuntu-latest</code>默认安装了MySQL，<code class="du jd je jf jg b">build</code>启动服务的第一步和第二步分别是:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="5f08" class="jp jq hi jg b fi jr js l jt ju">   steps:<br/>    - name: Set up MySQL<br/>      run: <em class="ki">|<br/>       </em>sudo /etc/init.d/mysql start</span></pre><p id="e647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…然后检查它是否处于活动状态:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="f86a" class="jp jq hi jg b fi jr js l jt ju">   - name: Check MySQL Connection<br/>     run: <em class="ki">|<br/>      </em>mysql --version<br/>      sudo apt-get install -y mysql-client<br/>      mysql --host 127.0.0.1 --port 3306 -uroot -proot -e "SHOW DATABASES"</span></pre><p id="d224" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用的密码(<code class="du jd je jf jg b">-proot</code>)是“root”，因为这是root用户在<code class="du jd je jf jg b">ubuntu-latest</code>上的默认MySQL密码。</p><p id="a52d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在MySQL服务被启动和检查之后，该作业将检查存储库并使用GitHub secrets⁴.登录到Docker Hub</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="66a9" class="jp jq hi jg b fi jr js l jt ju">   - name: Check Out Repo<br/>     uses: actions/checkout@v2</span><span id="d91c" class="jp jq hi jg b fi jv js l jt ju">   - name: Login to Docker Hub<br/>     uses: docker/login-action@v1<br/>     with:<br/>      username: ${{ secrets.- }}<br/>      password: ${{ secrets.- }}</span></pre><p id="40e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的步骤使用Docker Buildx，它将构建Docker映像。⁵</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="7cea" class="jp jq hi jg b fi jr js l jt ju">   - name: Set up Docker Buildx<br/>     id: buildx<br/>     uses: docker/setup-buildx-action@v1<br/>     with:<br/>      driver-opts: network=host<br/> </span></pre><p id="61ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里指定驱动程序选项<code class="du jd je jf jg b">network=host</code>很重要，因为这将把主机操作系统的网络(以及它的MySQL服务)暴露给构建。</p><p id="9ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的步骤负责构建Docker映像并将其推送到Docker Hub的<code class="du jd je jf jg b">latest</code>标签下。它使用Docker构建和推送操作来实现这一点:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="4d2e" class="jp jq hi jg b fi jr js l jt ju">   - name: Build and push<br/>     id: docker_build<br/>     uses: docker/build-push-action@v2<br/>     with:<br/>      context: ./<br/>      file: ./Dockerfile<br/>      network: host<br/>      allow: network.host<br/>      build-args: <em class="ki">|<br/>       </em>DB_HOST=localhost<br/>       DB_PORT=3306<br/>       DB_PASSWORD=root <br/>       DB_USERNAME=root<br/>       DB_CONNECTION=mysql<br/>     push: true<br/>      tags: ${{ secrets.- }}/someproject:latest<br/>      cache-from: type=local,src=/tmp/.buildx-cache<br/>      cache-to: type=local,dest=/tmp/.buildx-cache</span></pre><p id="1d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jd je jf jg b">with:</code>属性下指定<code class="du jd je jf jg b">network:host</code>和<code class="du jd je jf jg b">allow: network.host</code>很重要。</p><p id="22c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该注意这里的构建参数(<code class="du jd je jf jg b">build-args:</code>)。这些在Dockerfile文件中定义(见上文)，并利用主机操作系统的MySQL凭证作为映像的环境变量(<code class="du jd je jf jg b">localhost</code>是主机操作系统的网络)。MySQL将在<code class="du jd je jf jg b">ubuntu-latest</code>中的默认端口3306上运行。</p><p id="cd66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du jd je jf jg b">test.sh</code>脚本在这个步骤中运行时(见上文)，如果任何测试失败，构建都不会完成。</p><p id="a4ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后两步将图像摘要回显到终端并运行layer-caching⁶(分别为):</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="1e9d" class="jp jq hi jg b fi jr js l jt ju">   - name: Image digest<br/>     run: echo ${{ steps.docker_build.outputs.digest }}<br/>   <br/>   - name: Cache Docker layers<br/>     uses: actions/cache@v2<br/>     with:<br/>      path: /tmp/.buildx-cache<br/>      key: ${{ runner.os }}-buildx-${{ github.sha }}<br/>      restore-keys: <em class="ki">|<br/>       </em>${{ runner.os }}-buildx-</span></pre><p id="dce1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是完整的<code class="du jd je jf jg b">main.yml</code>文件:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="41b2" class="jp jq hi jg b fi jr js l jt ju">name: CI to Docker Hub<br/>on:<br/> push:<br/>  branches: [ master ]<br/> pull_request:<br/>  branches: [ master ]<br/> workflow_dispatch:<br/>  jobs:<br/>   build:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>     - name: Set up MySQL<br/>       run: <em class="ki">|<br/>        </em>sudo /etc/init.d/mysql start</span><span id="c251" class="jp jq hi jg b fi jv js l jt ju">     - name: Check MySql Connection<br/>       run: <em class="ki">|<br/>        </em>mysql --version<br/>        sudo apt-get install -y mysql-client<br/>        mysql --host 127.0.0.1 --port 3306 -uroot -proot -e "SHOW DATABASES"</span><span id="1b62" class="jp jq hi jg b fi jv js l jt ju">     - name: Check Out Repo<br/>       uses: actions/checkout@v2</span><span id="5f1d" class="jp jq hi jg b fi jv js l jt ju">     - name: Login to Docker Hub<br/>       uses: docker/login-action@v1<br/>       with:<br/>        username: ${{ secrets.- }}<br/>        password: ${{ secrets.- }}<br/>    <br/>     - name: Set up Docker Buildx<br/>       id: buildx<br/>       uses: docker/setup-buildx-action@v1<br/>       with:<br/>        driver-opts: network=host</span><span id="4532" class="jp jq hi jg b fi jv js l jt ju">     - name: Build and push<br/>       id: docker_build <br/>       uses: docker/build-push-action@v2<br/>       with:<br/>        context: ./<br/>        file: ./Dockerfile<br/>        network: host<br/>        allow: network.host<br/>        build-args: <em class="ki">|<br/>         </em>DB_USERNAME=root<br/>         DB_PASSWORD=root<br/>         DB_PORT=3306<br/>         DB_HOST=localhost<br/>         DB_CONNECTION=mysql<br/>       push: true<br/>       tags: ${{ secrets.- }}/someproject:latest<br/>       cache-from: type=local,src=/tmp/.buildx-cache<br/>       cache-to: type=local,dest=/tmp/.buildx-cache<br/>    <br/>     - name: Image digest<br/>       run: echo ${{ steps.docker_build.outputs.digest }}</span><span id="a16f" class="jp jq hi jg b fi jv js l jt ju">     - name: Cache Docker layers<br/>       uses: actions/cache@v2<br/>       with:<br/>        path: /tmp/.buildx-cache<br/>        key: ${{ runner.os }}-buildx-${{ github.sha }}<br/>        restore-keys: <em class="ki">|<br/>         </em>${{ runner.os }}-buildx-</span></pre><p id="276d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重述</strong></p><p id="6762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要在GitHub工作流程中让Docker构建过程可以使用主机操作系统的网络，这是一种方法。</p><p id="5c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户也可以在Docker构建期间运行shell脚本。该脚本可以创建一个最新的模式(通过运行应用程序使用的任何数据库版本控制命令)，以及运行依赖于该模式的任何应用程序测试。</p><p id="1f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要做到这一点，必须确保主机的网络暴露在构建过程中。这是通过以下方式实现的:</p><ol class=""><li id="2fe7" class="kj kk hi ih b ii ij im in iq kl iu km iy kn jc ko kp kq kr bi translated">在Dockerfile文件中使用适当的构建参数；</li><li id="c9c4" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated">配置GitHub工作流，以便将主机网络暴露给构建；而且，</li><li id="d6f0" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated">声明包含主机操作系统的MySQL凭证的构建参数，并通过<code class="du jd je jf jg b">build-args</code>属性在工作流的构建步骤中设置它们。</li></ol><p id="6173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读本文！</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="6dc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]: <a class="ae le" href="https://bludog.app" rel="noopener ugc nofollow" target="_blank"> https://bludog.app </a></p><p id="fb6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]:在Go项目中使用框架是有争议的。许多开发人员认为它们是不必要的抽象。我对这种批评很敏感。这个项目很少使用Revel。它有自己的ORM (Revel不包含ORM)、数据库版本控制系统、作业调度程序和响应处理程序。无论如何，框架的使用与本文中概述的技术没有关系，这些技术可以在任何依赖于数据库的测试中实现，这些测试可以从命令行运行。</p><p id="df31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[3]:我决定不对这个项目的数据库进行容器化；一般来说，我宁愿避免这样做。</p><p id="a97e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4]:参见<a class="ae le" href="https://docs.docker.com/ci-cd/github-actions/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/ci-cd/github-actions/</a>了解这些步骤的更多细节</p><p id="d75e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[5]:关于Docker Buildx的更多细节，请参见<a class="ae le" href="https://docs.docker.com/buildx/working-with-buildx/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/buildx/working-with-buildx/</a></p><p id="f0ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【6】:<a class="ae le" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank">https://github.com/actions/cache</a></p></div></div>    
</body>
</html>
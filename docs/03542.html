<html>
<head>
<title>mTLS with NGINX and NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NGINX和NodeJS的MTL</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/mtls-with-nginx-and-nodejs-e3d0980ed950?source=collection_archive---------1-----------------------#2021-06-10">https://medium.com/geekculture/mtls-with-nginx-and-nodejs-e3d0980ed950?source=collection_archive---------1-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7da2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个双方互相认证的例子</h2></div><p id="9d45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当通过互联网或其他网络进行安全通信时，通常由SSL/TLS处理身份验证。它只验证服务器的身份。服务器在不同的级别对客户端进行身份验证，大多数情况下是在应用层。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/955717274fa369ef09d8ff66f871e41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o1MSL4wF5sfonW_P"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Photo by <a class="ae kj" href="https://unsplash.com/@bernardhermant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bernard Hermant</a> on <a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="857a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我写这篇文章的目的是向您介绍相互认证的世界。本教程将带您完成使用NGINX服务器和一个简单的NodeJS应用程序配置双向安全性的步骤。因此，我假设您对上述技术以及Bash和Docker的使用有所了解。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="d567" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们深入研究并开始配置解决方案之前，让我引导您了解mTLS身份验证的基础知识。</p><h1 id="7d0d" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">了解mTLS身份验证</h1><p id="e307" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">要启用基于证书的相互SSL身份验证，双方需要通过提供有效的证书来接受对方的授权。证书颁发机构(CA)从服务器和客户端验证这些数字密钥。</p><p id="cec8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这包括一些开销，不适用于普通用户应用程序。这就是为什么mTLS身份验证在B2B应用程序中更为普遍的原因，在B2B应用程序中，安全性要求通常更严格，连接到特定服务的客户端数量有限。</p><p id="b18e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的场景指出了请求流，并描述了客户端和服务器之间的证书交换顺序。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lo"><img src="../Images/a5a49b0c379b0ef9eeb8b6fdf92d88f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*AeygepIJxBwo9zbmgjGB2w.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">mTLS authentication flow</figcaption></figure><p id="3715" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端请求服务器端[1]上的资源，该资源将使用服务器[2]的证书来应答。收到证书后，客户端验证它是否有效[3]。如果验证成功，客户端会将其证书发送给服务器[4]。他那边的服务器也对传入的证书进行验证[5]。当一切正常并且客户机证明了它的身份时，资源就为请求做好了准备，双方就可以交换信息了[6]。</p><p id="4a65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，服务器的SSL证书不一定要由与客户端证书相同的机构进行签名。任何权威，比如最熟悉的，LetsEncrypt <em class="lp"> </em>都可以使用。但是，双方都应该知道各自的CA。</p><h1 id="8ad8" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">生成证书</h1><p id="4d86" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">为了交换证书，它们必须由权威机构创建和签名。创建了一个CA，在本例中，服务器和客户机都依赖于它。输出是密钥对<em class="lp"> ca.key </em>和<em class="lp"> ca.crt </em>，可用于签署演员证书。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="7038" class="lv ks hi lr b fi lw lx l ly lz">openssl req \<br/>  -newkey rsa:4096 \<br/>  -x509 \<br/>  -keyout <strong class="lr hj">ca.key</strong> \<br/>  -out <strong class="lr hj">ca.crt</strong> \<br/>  -days 30 \<br/>  -nodes \<br/>  -subj "/CN=<strong class="lr hj">my_ca</strong>"</span></pre><p id="ba47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，创建服务器密钥和证书:这样就创建了一个证书签名请求(CSR ),其通用名称为(CN) localhost(可以使用任何其他名称)。CSR与<em class="lp"> ca.key </em>和<em class="lp"> ca.crt </em>一起用于创建签名证书。<br/>每个连接到服务器的客户端都可以访问服务器证书；另一方面，私钥是一个安全的实体。它应该存放在限制进入的地方。然而，它必须在以后对NGINX可用。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="a7a2" class="lv ks hi lr b fi lw lx l ly lz">openssl req \<br/>  -newkey rsa:4096 \<br/>  -keyout <strong class="lr hj">server.key</strong> \<br/>  -out <strong class="lr hj">server.csr</strong> \<br/>  -nodes \<br/>  -days 30 \<br/>  -subj "/CN=<strong class="lr hj">localhost</strong>"</span><span id="e7c2" class="lv ks hi lr b fi ma lx l ly lz">openssl x509 \<br/>  -req \<br/>  -in <strong class="lr hj">server.csr</strong> \<br/>  -out <strong class="lr hj">server.crt</strong> \<br/>  -CA ca.crt \<br/>  -CAkey ca.key \<br/>  -CAcreateserial \<br/>  -days 30</span></pre><p id="d8c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建客户机密钥和证书的过程是不言自明的，它与服务器的过程相同。使用上述步骤，用客户机的任意通用名称替换CSR。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="b658" class="lv ks hi lr b fi lw lx l ly lz">openssl req \<br/>  -newkey rsa:4096 \<br/>  -keyout <strong class="lr hj">client.key</strong> \<br/>  -out <strong class="lr hj">client.csr</strong> \<br/>  -nodes \<br/>  -days 30 \<br/>  -subj "/CN=<strong class="lr hj">client</strong>"</span><span id="e792" class="lv ks hi lr b fi ma lx l ly lz">openssl x509 \ <br/>  -req \<br/>  -in <strong class="lr hj">client.csr</strong> \<br/>  -out <strong class="lr hj">client.crt</strong> \<br/>  -CA ca.crt \<br/>  -CAkey ca.key \<br/>  -CAcreateserial \<br/>  -days 30</span></pre><p id="bf53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每个实例，运行以下命令来显示证书的内容。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="ebb5" class="lv ks hi lr b fi lw lx l ly lz"><em class="lp">### display the contents of ca.crt</em><strong class="lr hj"><br/></strong>openssl x509 -in ca.crt -text -noout</span><span id="e589" class="lv ks hi lr b fi ma lx l ly lz"><em class="lp">### output</em><strong class="lr hj"><br/></strong>Certificate:<br/>    Data:<br/>        Version: 1 (0x0)<br/>        Serial Number: 9377707732938553850 (0x82244f7f753c79fa)<br/>    Signature Algorithm: sha256WithRSAEncryption<br/>        Issuer: CN=CA_NAME<br/>        Validity<br/>            Not Before: Feb 27 14:56:53 2021 GMT<br/>            Not After : Feb 27 14:56:53 2022 GMT<br/>        Subject: CN=CA_NAME<br/>        Subject Public Key Info:<br/>            Public Key Algorithm: rsaEncryption<br/>                Public-Key: (4096 bit)<br/>                Modulus:<br/>                    00:f8:5a:b9:c9:99:82:5b:45:d2:1e:9f:05:6e:60:<br/>                    ....<br/>                Exponent: 65537 (0x10001)<br/>    Signature Algorithm: sha256WithRSAEncryption<br/>         42:7c:d8:93:e9:01:f0:c9:21:db:dc:94:68:77:92:a6:3e:6f:<br/>         ...</span><span id="b100" class="lv ks hi lr b fi ma lx l ly lz"><em class="lp">### display the contents of server.crt</em><strong class="lr hj"><br/></strong>openssl x509 -in server.crt -text -noout</span><span id="42ef" class="lv ks hi lr b fi ma lx l ly lz">...</span><span id="e64d" class="lv ks hi lr b fi ma lx l ly lz"><em class="lp">### display the contents of client.crt</em><strong class="lr hj"><br/></strong>openssl x509 -in client.crt -text -noout</span><span id="4aef" class="lv ks hi lr b fi ma lx l ly lz">...</span></pre><h1 id="0002" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">设置NGINX服务器</h1><p id="5c48" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">一旦我们有了合适的证书，让我们继续配置NGINX服务器。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">nginx configuration</figcaption></figure><p id="ba6d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器的证书位置是NGINX配置文件中设置的第一个位置。上面创建的服务器证书<em class="lp"> server.crt </em>和私钥<em class="lp"> server.key </em>的位置被指定给NGINX指令<strong class="iz hj"> ssl_certificate </strong>和<strong class="iz hj"> ssl_certificate_key </strong>。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="ccb8" class="lv ks hi lr b fi lw lx l ly lz">ssl_certificate     /etc/ssl/server.crt; <br/>ssl_certificate_key /etc/ssl/server.key;</span></pre><p id="935d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> ssl_client_certificate </strong>指定用于验证客户端证书的CA文件。设置指令<strong class="iz hj"> ssl_verify_client </strong>激活客户端验证。<em class="lp">可选的</em>参数要求每个客户端传输其证书，并检查该证书是否存在。结果存储在<strong class="iz hj"> $ssl_client_verify </strong>变量中。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="210d" class="lv ks hi lr b fi lw lx l ly lz">ssl_client_certificate  /etc/nginx/client_certs/ca.crt;    ssl_verify_client       optional;</span></pre><p id="04f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在将传入的请求转发到应用程序时，NGINX执行SSL客户端验证，如果<strong class="iz hj">$ SSL _ client _ verify</strong><em class="lp"/>值<em class="lp"> </em>没有设置成功，则返回403禁止。例如，这可能是由于缺少客户端证书造成的。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="bf97" class="lv ks hi lr b fi lw lx l ly lz">if ($ssl_client_verify != SUCCESS) { return 403; }</span></pre><p id="1a64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有关NGINX配置处理ssl证书的更多细节，请查看<a class="ae kj" href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> ssl_module </em>文档</a>。</p><h1 id="8a91" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">实现节点JS应用程序</h1><p id="4fc8" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">“保持简单，专注于重要的事情。”孔子的名言最好地描述了下面这个例子的难度。</p><p id="404f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NodeJS应用程序包含一个Express服务器，并提供一个GET操作，用包含客户机证书信息的消息进行回复。<br/>单个返回值就足够了，因为NGINX服务器已经过滤掉了无效的请求。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">basic node application</figcaption></figure><p id="afeb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NGINX服务器将转发带有头变量的客户端证书信息。节点应用程序需要这些参数才能利用这些信息。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="33c1" class="lv ks hi lr b fi lw lx l ly lz">proxy_set_header     SSL_Client_Issuer $ssl_client_i_dn;        proxy_set_header     SSL_Client $ssl_client_s_dn;        proxy_set_header     SSL_Client_Verify $ssl_client_verify;</span></pre><p id="f5f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到我们将使用Docker Compose交付整个设置，您需要创建一个Docker文件和应用程序。请看<a class="ae kj" href="https://github.com/judif/mtls-nginx-nodejs-example/blob/main/node-server/Dockerfile" rel="noopener ugc nofollow" target="_blank">这里</a>的一个例子，我根据自己的需要基于一个简单的NodeJS映像进行了定制。</p><h1 id="edf2" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">部署NGINX服务器和NodeJS应用程序</h1><p id="d5e2" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">Docker为本地机器和云虚拟机都提供了该解决方案。确实有其他环境可供选择，但是OpenSSL和NodeJS是必须的，需要提前安装。</p><p id="7f81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了最终启动之前实现的所有组件，我们使用Docker Compose来部署NGINX和NodeJS应用程序。以下面的yaml文件为例。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">docker-compose.yml</figcaption></figure><p id="d8a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在考虑了所有的步骤之后，项目现在可以开始了，可以进行测试了。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="d1a4" class="lv ks hi lr b fi lw lx l ly lz">docker-compose build<br/><br/>docker-compose up<br/></span><span id="46e6" class="lv ks hi lr b fi ma lx l ly lz"><em class="lp">### Alternatively combine both commands into one:</em></span><span id="1266" class="lv ks hi lr b fi ma lx l ly lz">docker-compose up --build</span></pre><h1 id="5d1a" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">测试解决方案</h1><p id="4f9c" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">要确定设置是否正确接合，一切工作是否顺利，可以使用cURL。下面是测试上面提供的接口的命令，因为组件可以在本地访问。接受服务器的ca需要<br/> <em class="lp"> ca.crt </em>。<em class="lp"> client.crt </em>和<em class="lp"> client.key </em>必须是请求的一部分，因为它们证明了客户的身份。</p><pre class="ju jv jw jx fd lq lr ls lt aw lu bi"><span id="a675" class="lv ks hi lr b fi lw lx l ly lz">curl <a class="ae kj" href="https://localhost" rel="noopener ugc nofollow" target="_blank">https://localhost</a> \<br/>  --cacert ca.crt \<br/>  --key client.key \<br/>  --cert client.crt</span><span id="989f" class="lv ks hi lr b fi ma lx l ly lz"><em class="lp">### successful response with correct parameters should be returned<br/></em>Hello <strong class="lr hj">client</strong>, your certificate was issued by <strong class="lr hj">my_ca</strong>!</span></pre><h1 id="731c" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">继续</h1><p id="f960" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我已经将我在本教程中使用的片段上传到GitHub，在那里你可以在我的帐户上找到更多功能的完整示例。如果您感兴趣，可以随意克隆<a class="ae kj" href="https://github.com/judif/mtls-nginx-nodejs-example" rel="noopener ugc nofollow" target="_blank">库</a>并使用它。尝试任何扩展和修改，以更好地理解。</p><p id="ec7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文和示例为双向身份验证提供了一个起点，这是获得更多关于该主题的知识并基于它构建更复杂的解决方案的机会。</p><p id="130e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">玩得开心，直接跳进去吧！</p></div></div>    
</body>
</html>
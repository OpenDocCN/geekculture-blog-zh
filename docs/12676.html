<html>
<head>
<title>Code Injection with Dyld Interposing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">插入Dyld的代码注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/code-injection-with-dyld-interposing-3008441c62dd?source=collection_archive---------5-----------------------#2022-05-26">https://medium.com/geekculture/code-injection-with-dyld-interposing-3008441c62dd?source=collection_archive---------5-----------------------#2022-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/40a950c87fd30cb405aa5ac326eb0640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmBNCY522hwNepvv5fELaw.jpeg"/></div></div></figure><div class=""/><p id="4482" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Objective-C运行时的动态特性可以用于许多目的，包括方法重组。有很多教程解释了如何使用swizzling，它可以完成很多任务。但是，不能一直用。</p><p id="7886" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Swizzling处理Objective-C方法，但不能用于C/C++函数。当对iOS应用程序进行逆向工程时，一些非Obj-C底层调用可能是最有用的，有时您需要在没有源代码的应用程序中拦截它们。</p><p id="57e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本帖中，我们将会看到一种鲜为人知的在函数调用中注入代码的技术，这种技术适用于C/C++函数和未修改的应用程序二进制文件。这些基本构件支撑了许多开发工具，包括我使用的<a class="ae jo" href="https://www.emergetools.com" rel="noopener ugc nofollow" target="_blank"> Emerge Tools </a>。</p><h2 id="57e3" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">例子</h2><p id="74a7" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">假设您正在尝试对一个应用程序进行逆向工程，以了解它如何使用钥匙串。您知道在某个时候应用程序调用了<code class="du kp kq kr ks b"><a class="ae jo" href="https://developer.apple.com/documentation/security/1398306-secitemcopymatching" rel="noopener ugc nofollow" target="_blank">SecItemCopyMatching</a></code>，但是不确定存储了什么数据以及它存储在什么键下。这个函数不能swizzled，因为它不客观-C .你也不能修改原始源代码，你有的只是编译好的app。</p><p id="7c52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将实现一个解决方案，在应用程序运行时，将从keychain请求的所有数据打印到stdout。该解决方案使用了一个插入了<code class="du kp kq kr ks b">SecItemCopyMatching</code>的框架，并在启动时用DYLD_INSERT_LIBRARIES加载。</p><h2 id="af5f" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">DYLD _插入_库</h2><p id="3791" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">虽然对于插入来说并不是绝对必要的，但是插入库通常与插入结合在一起，对于任何探索iOS内部的人来说都是一个极好的资源，因此值得快速浏览一下。</p><p id="8966" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DYLD_INSERT_LIBRARIES是一个环境变量，允许您向应用程序的进程添加代码。该格式只是一个冒号分隔的框架列表，将在应用程序启动时链接。例如:<code class="du kp kq kr ks b">DYLD_INSERT_LIBRARIES=@executable_path/Frameworks/InterposingSample.framework/InterposingSample</code>。如果你曾经在Linux/Android上使用过LD_PRELOAD，这就是iOS的等价物。</p><p id="727b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个环境变量[1]有很大的潜力，你可以写一个+load方法来添加任何你想应用程序启动的额外逻辑，包括swizzling，响应NSNotifications，或者呈现一个全新的UI。这甚至被SwiftUI预览使用，从预览中检查一个崩溃报告会显示一行:<code class="du kp kq kr ks b">DYLD_INSERT_LIBRARIES=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot//System/Library/PrivateFrameworks/PreviewsInjection.framework/PreviewsInjection</code></p><h2 id="1d02" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">DYLD_INTERPOSE</h2><p id="2400" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">当你使用dyld插入时，你甚至不需要使用初始化器，比如+load，因为它是一个比swizzling更具声明性的API。正如<a class="ae jo" href="https://www.emergetools.com/blog/posts/SwiftReferenceTypes" rel="noopener ugc nofollow" target="_blank">我在</a>之前讨论过的，应用启动时运行的第一个代码是dyld，而不是你写的代码。dyld的职责之一就是将调用从一个二进制绑定到另一个，比如从你的应用绑定到苹果的框架。插入是告诉dyld用一个绑定函数替换另一个绑定函数的一种方式。</p><p id="96b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> Dyld绑定</strong></p><p id="79a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嵌入在你的二进制文件中的是一个外部引用的符号表，我在<a class="ae jo" href="https://www.emergetools.com/blog/posts/iOS15LaunchTime" rel="noopener ugc nofollow" target="_blank">之前的博客文章</a>中写过这个数据的新iOS 15格式。一些符号只是在第一次被使用时才被延迟绑定，这是通过每个名为<code class="du kp kq kr ks b">dyld_stub_helper</code>的应用程序中包含的一个功能实现的。其他符号在应用程序启动时绑定。这两种方法都允许dyld对另一个二进制文件中定义的任何函数的地址拥有最终发言权，幸运的是，它给了您修改这个地址以指向您自己的函数的机会。</p><p id="ddb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">插入</strong></p><figure class="ku kv kw kx fd hk er es paragraph-image"><div class="er es kt"><img src="../Images/cb525cca81228bbb1e61afa1bf6a59da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*SBGFORRXE1rSkFwu9wo4qA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Interposing SecItemCopyMatching with an inserted framework</figcaption></figure><p id="6c48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插入的工作方式是添加一个新的Mach-O部分(__DATA，_ _ interpose)，该部分包含一个元组列表，该列表保存替换函数和被替换对象的地址。如果任何库(包括插入的库)包含Mach-O部分(__DATA，__interpose)，那么dyld将使用这个列表用替换来替换对被替换对象的任何调用，只要调用不是来自包含替换函数的二进制文件。<strong class="is hu">这意味着对你试图插入到你插入的框架中的函数的任何调用仍然会转到原始函数。</strong></p><p id="5aac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看dyld的源代码，我们可以准确地看到这些插入的地址是在哪里加载的:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/8c35291cf20a97f574829d4a1d98b22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncnEBjsIVXhhTy4r8MebtA.png"/></div></div></figure><p id="fd03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在你的二进制文件中制作这个新的部分，苹果提供了一个<a class="ae jo" href="https://github.com/apple-opensource/dyld/blob/b6b86eb2db14440d373f6f7fd21be4a2bc0da897/include/mach-o/dyld-interposing.h" rel="noopener ugc nofollow" target="_blank">方便的宏</a>:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/dd54b72fdbb379600a1c99d1113aa0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrupnPtczTWTtmsCQujPfw.png"/></div></div></figure><p id="24d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，将所有这些放在一起，我们可以看到如何实现一个框架来完成我们从最初的示例中想要的功能:</p><figure class="ku kv kw kx fd hk"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="0fda" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">你能用这个做什么？</h2><p id="be42" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">很多！在<a class="ae jo" href="https://www.emergetools.com" rel="noopener ugc nofollow" target="_blank"> Emerge Tools </a>，我们将这种技术用于所有的运行时性能测量，例如订单文件生成和性能测试。通过插入，你可以连接到未修改的应用程序，以测量应用程序的行为，提取信息，或完全改变行为。它是开发人员工具可以利用的强大的运行时工具。任何时候你发现自己需要调用一个C/C++函数或者任何不是Objective-C的一部分的东西(所以它不能被调用),意识到插入是你可以求助的一种选择是很好的。一个免责声明:我没有在app store的应用程序中尝试过，但一般来说，我会推荐它只用于本地测试！</p><h2 id="0d28" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">其他方法</h2><p id="02b8" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在iOS应用程序的Objective-C运行时之外，还有其他一些方法可以实现代码注入。<a class="ae jo" href="https://github.com/facebook/fishhook" rel="noopener ugc nofollow" target="_blank">鱼钩</a>是脸书发明的一种广受欢迎的鱼钩。类似于dyld插入，它利用了Mach-O符号绑定。有了fishhook，你不需要一个单独的dylib，如果你能控制应用程序的源代码，这就方便多了。如果可能的话，我更喜欢使用dyld插入，因为这是一个完全第一方的解决方案，但是fishhook只有几百行C代码，对于从较低的层次了解符号绑定过程是如何工作的很有帮助。</p><p id="8dee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">勇敢的读者可能会注意到dyld源代码中的另一个特性:用函数<code class="du kp kq kr ks b">dyld_dynamic_interpose</code>进行动态插入。这只是在运行时告诉dyld开始插入函数的一种方式。这类似于fishook的工作方式；您不需要总是插入一个函数，而是可以通过编程安装一个钩子。Peter Steinberger在Chrome源代码中发现了这个API的至少一个用例。看起来Chrome正在覆盖CoreAudio来修改它的行为，有趣的是看到了一个在生产中使用插入的例子！</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="b30a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]如果您对其他dyld环境变量感兴趣，请查看<code class="du kp kq kr ks b">man dyld</code></p></div></div>    
</body>
</html>
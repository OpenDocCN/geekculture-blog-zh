<html>
<head>
<title>Angular Component Unit Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角分量单位测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-component-unit-test-cfa8f650880e?source=collection_archive---------20-----------------------#2021-09-20">https://medium.com/geekculture/angular-component-unit-test-cfa8f650880e?source=collection_archive---------20-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f36977b2dea654e11465bb7387a81d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SxTpMEMGiz0c0ks0_NGiQ.jpeg"/></div></div></figure><h1 id="2461" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="0f8a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">组件是最小的单元，也是Angular中最常见的用例。到目前为止，我们已经学习了如何用Angular编写单元测试，涵盖了一些基本概念、<a class="ae km" href="https://simpleweblearning.com/writing-your-first-test-in-angular" rel="noopener ugc nofollow" target="_blank">茉莉匹配器</a>和<a class="ae km" href="https://simpleweblearning.com/working-with-spies-in-angular-unit-test" rel="noopener ugc nofollow" target="_blank">与间谍一起工作</a>。在本教程中，我们将应用到目前为止所学的知识，并演示如何用角度组件编写单元测试。</p><p id="3ae6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">对于本教程，我们准备了一个简单的购物车应用程序:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/0628219f39eb032e076491b99742f4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2YHaJ145UcewSeHA.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Shopping Cart Application</figcaption></figure><p id="3d31" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">该应用程序由两个组件组成，我们将针对这两个组件编写单元测试HomeComponent和ShoppingListComponent。该应用程序由两个组件组成，我们将针对这两个组件编写单元测试HomeComponent和ShoppingListComponent。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/13738ddfa5da550699d538d890799451.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/0*An9quOj5oiV45B6A.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Component Files</em></figcaption></figure></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="99f6" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">准备试验台</h1><p id="a8da" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当您通过运行<strong class="jq hj"> ng test </strong>命令开始测试时，您会注意到，即使没有为这两个组件编写任何测试，输出浏览器上也已经出现了许多错误。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/60bec4cde2ed0287bc67264616f76713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aaaj23h-fxLR4tSl.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Initial Fail Tests</em></figcaption></figure><p id="9366" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这是因为我们还没有建立我们的试验台。正如在第一篇教程中提到的，在角度测试环境中，我们必须明确定义测试床中需要的任何模块、服务或子组件。在控制台中，指令<strong class="jq hj"> ngModel </strong>无法识别，因为我们还没有导入FormsModule。</p><p id="249e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">通过在测试床配置部分添加一个<strong class="jq hj"> imports </strong>数组，我们可以很容易地将FormsModule导入到我们的测试床中。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/1d467a25c58c598bd2cc737435c6a756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*A3M9dJrF7Tu27hbB.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Import FormsModule</em></figcaption></figure><p id="37af" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在我们导入FormsModule并再次保存后，我们将看到ngModel错误已经解决，现在又出现了新的错误。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/008fe48f264004f56fb655cfde643957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ghHQTLgG0XvV1I_.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">After importing FormsModule</em></figcaption></figure><p id="971a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这一次，Angular抱怨它不能识别我们的shipping-list组件指令。为了解决这个问题，我们需要在我们的测试床中声明这个组件。</p><p id="1e6b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">虽然您可以在声明数组中声明真正的组件，但是建议您创建一个模拟类组件，这样我们可以尽可能简单地保持模拟组件。</p><p id="bdee" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我们定义一个模拟购物清单组件:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/07ed668ce315925f2e524687c1f4ce65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yyTNddsubv7F1owl.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Declare Mock Child Component</em></figcaption></figure><p id="4964" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可以在测试套件之前直接声明一个模拟组件。正如您从上面的图片中看到的，在我们的模拟组件中，我们将组件模板设置为空，只是为了使它更简单。真正重要的是，您需要保持选择器与实际组件一致，以便Angular知道您在测试期间在HTML中引用了这个组件。此外，如果您的子组件包含任何输入或输出声明，您还必须将它们包含在您的模拟组件类中，以便您可以在父组件中引用它们。</p><p id="dc53" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">修复后，我们将在屏幕上看到一个成功的输出。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/cf8caebb0181d57998456a6909215b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tjtaYxT14KXvGxfq.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Result after declaring mock component</em></figcaption></figure><p id="43fd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在让我们也为ShoppingListComponent修复测试平台。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/4c4222377255a738e55e25bc789c77b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/0*KbxjwFE8JGiSDdzH.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Fix TestBed for the ShoppingListComponent</em></figcaption></figure><p id="a057" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在导入了FontAwesomeModule之后，我们现在看到了一个成功的屏幕，可以开始进行单元测试了。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/6a1e9c5d7b9def432d974156a93ec36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X-t502rcnAOxxYpU.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Results after fixing TestBed for ShoppingListComponent</em></figcaption></figure></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="dbbb" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">角形部件要测试什么？</h1><p id="7267" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在Angular中的组件测试中，有三个主要方面需要在测试中涵盖:</p><ol class=""><li id="fce3" class="lv lw hi jq b jr kn jv ko jz lx kd ly kh lz kl ma mb mc md bi translated">HTML <br/>在HTML相关的测试中，您想要测试HTML是否按照您期望的方式组织或编写。这种测试的目的是让您知道，如果有一天您或其他开发人员以不同于组件最初设计的方式更改了HTML</li><li id="bb55" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl ma mb mc md bi translated">TypeScript <br/> TypeScript是我们组件的主要逻辑所在，因此也是大多数单元测试的内容。通常，在为component.ts文件编写测试时，您希望测试每个函数是否有正确的输入/输出，以及它们是否以正确的顺序执行(例如，当函数A被执行时，函数B是否会被调用，等等)。</li><li id="a60f" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl ma mb mc md bi translated">TypeScript与HTML的关系<br/>这种单元测试主要测试当TypeScript中的某些变量被更新时，HTML是否被正确呈现。有些人会认为这种测试是集成测试，但是，我更愿意把它看作是组件单元测试的一部分..因为HTML和TypeScript都必须正确运行，组件才能被认为正常工作。</li></ol><h2 id="e705" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">HTML测试</h2><p id="8743" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在我们针对HTML编写测试之前，让我们看看我们的HTML文件。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/a6c05601d92a0c0a3520eccdf5a61437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Py_STjofqQ7LY-o4.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">home.component.html</em></figcaption></figure><h2 id="7f6b" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">测试DOM元素是否存在</h2><p id="8dd6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">虽然HTML中没有多少行代码，但是如果你一行一行地测试它们，那就很奇怪了，而且很容易丢失。一个简单的方法是从外面的前两层开始一层一层地检查它们。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es my"><img src="../Images/e316448ce5acf35edec79ee90dddb009.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*17qj4JPIwsI7uUv-.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">First two layers of HTML of home.component.html</em></figcaption></figure><p id="20e3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">对于这两个层，我们想要测试是否确实有一个具有CSS类page-layout的div元素，并且在page-layout元素内部，有一个h1元素和一个具有类inner-page-wrapper的div元素。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/1a3aa54290ba7e4d2ad099c87387c400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UKyhe7A2O3G3sOy6.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">First two layers tests</em></figcaption></figure><p id="378c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">完整的测试，请在<a class="ae km" href="https://github.com/chen1223/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="9b2b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了测试DOM上是否存在HTML元素，我们使用了来自<strong class="jq hj"> fixture.debugElement </strong>的<strong class="jq hj">查询</strong>函数。</p><p id="f3df" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在查询功能中，有几个选项可供您选择:</p><ul class=""><li id="8f60" class="lv lw hi jq b jr kn jv ko jz lx kd ly kh lz kl na mb mc md bi translated">这种方法允许你用css选择器访问DOM元素。这是一个非常强大的功能，因为您可以使用CSS选择器选择DOM上的任何元素。语法将与使用<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" rel="noopener ugc nofollow" target="_blank"> document.querySelector </a>相同。</li><li id="cc4e" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl na mb mc md bi translated">如果您的目标是HTML上特定类型的DOM元素，这种方法更适合。您可以传递元素类型。举例来说，如果你正在使用有角度的材质按钮，并且你想要测试在DOM上是否有MatButton。您可以像这样查询它们:</li></ul><pre class="kt ku kv kw fd nb nc nd ne aw nf bi"><span id="ee32" class="mj ir hi nc b fi ng nh l ni nj">const el = fixture.debugElement.query(By.directive(MatButton));</span></pre><p id="073e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意。如果你想一次选择多个元素，使用<strong class="jq hj"> queryAll </strong>代替query。另外，当您通过功能导入<strong class="jq hj">时，请确保您是从<strong class="jq hj">@ angular/platform-browser</strong>导入的。量角器实例仅用于角度端到端测试。</strong></p><h2 id="f263" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">测试DOM元素属性</h2><p id="36ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时我们想测试一个DOM元素是否确实具有我们期望的属性。在这种情况下，您可以首先查询元素，然后从nativeElement调用<strong class="jq hj"> getAttribute </strong>函数。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/cce59284356a59aa6d1a5fd67ffcc786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fgZlMgkZnTL-zPg9.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test DOM element attributes</em></figcaption></figure><h2 id="be9d" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">测试DOM元素显示的文本</h2><p id="6ef8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要测试DOM元素(例如span、h2元素)中显示的文本，可以从innerText属性访问它们。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/8bd8b1fb74ecdeb22ddf47dd3bb3f0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*stxeVwXNGXGnZekX.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test DOM element displayed text</em></figcaption></figure><h2 id="3d95" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">测试DOM元素CSS类</h2><p id="f28a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">DOM元素CSS类可以通过nativeElement.classList属性进行测试。classList属性将返回一个包含DOM元素上所有类的数组。为了测试一个类是否存在于classList数组中，我们可以使用Jasmine的toContain匹配器。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/e6b6473a7db4dc74151fd3c0416a67e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-rHiq0Z6tC0M0hmt.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test DOM element CSS class</em></figcaption></figure><h2 id="267d" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">触发DOM元素事件</h2><p id="b8f6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果您需要在单元测试期间触发DOM元素事件，有几种方法可以实现。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/86223a50861ba0f917ce063972924340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*diWscnl9nM6FzN-B.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Trigger Button Click event</em></figcaption></figure><ul class=""><li id="c75d" class="lv lw hi jq b jr kn jv ko jz lx kd ly kh lz kl na mb mc md bi translated"><strong class="jq hj">triggerEventHandler</strong><br/>可以直接在查询函数返回的debugElement上调用<strong class="jq hj"> triggerEventHandler </strong>函数来触发事件。</li><li id="20d0" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl na mb mc md bi translated"><strong class="jq hj"> dispatchEvent </strong> <br/>你也可以使用原生<strong class="jq hj"> dispatchEvent </strong>。然而，由于这是一个本机DOM方法，您将需要从nativeElement访问它，而不是直接从debugElement调用它。</li><li id="ff2c" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl na mb mc md bi translated">一些DOM元素有自己的方法，你可以直接调用。为了调用它们的本地方法，您需要首先将nativeElement转换成相应的DOM元素。</li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="af45" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">类型脚本测试</h1><p id="63c1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们来看看HomeComponent的TypeScript代码。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/06c97fc1c0d3c8aa4f67e0200f003f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TRm8QL5IobezDLgi.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">home.component.ts</em></figcaption></figure><p id="fad4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在TypeScript测试中，我们可以通过与测试相关的函数对测试进行分组。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es np"><img src="../Images/017ff5e43b4f6764800b636f47c2e91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*iVKOXcWaRFzffk8A.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Group tests by functions</em></figcaption></figure><p id="d2ff" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我们来看看addItem函数，专门演示如何编写TypeScript单元测试。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es nq"><img src="../Images/439d6db96c824f9af01e949cb865a500.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*4mTrIVxUSwJ1AFEl.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">addItem function</em></figcaption></figure><p id="be58" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">调用addItem时，主要执行两个操作:</p><ol class=""><li id="f903" class="lv lw hi jq b jr kn jv ko jz lx kd ly kh lz kl ma mb mc md bi translated">具有newItemName和newItemQty值的新商品被推送到购物车数组</li><li id="2ab3" class="lv lw hi jq b jr me jv mf jz mg kd mh kh mi kl ma mb mc md bi translated">newItemName和newItemQty被清除</li></ol><p id="14c6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们可以为每个动作编写单元测试。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/d20b122138ac8cf86f6d50891dd14a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FFePKtx5KUXGPZ81.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test new item added to cart</em></figcaption></figure><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/447461a309d609dc33a90b6c81dee58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SM4JjG_wG1BffWQk.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test newItemName and newItemQty are cleared</em></figcaption></figure><p id="e199" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在为TypeScript代码编写单元测试时要记住的一个要点是，要确保单元测试中包含了函数中的所有路径。例如，如果您的函数有一个If语句，那么您至少应该编写两个单元测试来测试到达和未到达if语句的情况。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="b114" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">测试HTML和TypeScript之间的关系</h1><p id="e90b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在一个组件中，通常有不同的方式来链接HTML和ts文件。我们希望确保我们的单元测试也涵盖了这些关系。</p><h2 id="0d00" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">事件绑定</h2><p id="26e8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于事件绑定，您希望确保在事件发出时调用相应的事件。</p><p id="b8ab" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">例如:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/f7f52afe8f46222cbaea2cb9254a49dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XLtWBMoycoc7XA5r.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test function called on event triggered</em></figcaption></figure><p id="f5c0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在本例中，我们在addItem方法上创建一个Spy实例，并检查当按钮发出click事件时是否会调用该函数。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="f984" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">角度指令测试</h1><p id="4b70" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">角度指令在角度应用中非常常见。让我们来看看本节中最常用的两个指令:ngFor和ngif。</p><h2 id="ef1d" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">NgIf</h2><p id="6166" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">NgIf将隐藏/显示DOM上的HTML元素。当一个元素被ngIf隐藏时，Angular实际上是将它从DOM元素中完全移除，而不是通过CSS隐藏。这最终实际上使测试变得更加容易。为了测试一个元素是否被ngIf隐藏/显示，我们只需要测试我们是否能成功地查询这个元素。</p><p id="504f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">例如，在ShoppingListComponent中，当shoppingList输入中没有条目时，我们将显示空消息。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/3be9b05f14c2af6f3e5c22cd7ce4ef45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z58VZJZtM13tfbky.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">shipping-list.component.html</em></figcaption></figure><p id="3175" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了测试当shoppingList中没有项目时，空消息是否正确显示，我们准备了以下测试用例。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/813415a37618ae9fe8c7f1a8a6a35e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WYRdSqjbt6tBdW-m.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test empty messages shown correctly</em></figcaption></figure><p id="22a5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">相比之下，我们可以测试购物清单是否正确显示，如下例所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/aef6491ab476da512e8d2a14976470d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sIBMd8-cG4c5aYN3.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test shopping list shown correctly</em></figcaption></figure><h2 id="3621" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">NgFor</h2><p id="864e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">NgFor指令允许我们在HTML上快速创建重复的元素。在ShoppingListComponent中，我们希望根据shoppingList变量中指定的元素在HTML上创建购物项目。我们可以通过下面的例子来测试这种行为:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/62fe5e444ff707d0fdcc51fd9ecb0c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A4azkOY-r0Hl_TrH.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">ngFor testcase</em></figcaption></figure><p id="5fb6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这个测试案例中，我们将随机数量的元素放入shoppingList数组，并测试HTML上呈现的元素数量是否正确。此外，我们使用forEach循环来检查每个元素是否正确显示其内容。</p><p id="1b7d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意。在第90行到第93行，我们不是从fixture.debugElement查询，而是从之前已经获取的itemEl查询。这种查询将在item元素的范围内执行搜索。当您想要测试您正在寻找的元素是否是HTML元素的子元素时，这种方法特别有用。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="6a9b" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">父组件和子组件之间的通信</h1><p id="b8a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在我们的演示应用程序中，我们让HomeComponent(作为父组件)与ShoppingListComponent(子组件)来回通信。在角状发育中，这是很常见的。在这一部分，我们将演示如何测试他们的通信是否正常工作。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/dc827b333863e0be97ffa580e7ce8831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*srHZFP2gpJPzlq98.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">ShoppingListComponent in the home.component.html</em></figcaption></figure><p id="e1b6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">父组件和子组件通过<strong class="jq hj">@输入</strong>和<strong class="jq hj">@输出</strong>指令进行通信。HomeComponent将cart变量作为<strong class="jq hj"> shoppingList </strong> <strong class="jq hj">输入</strong>传递给ShoppingListComponent，并从ShoppingListComponent接收<strong class="jq hj"> itemRemove </strong>、<strong class="jq hj"> print </strong>和<strong class="jq hj"> clear </strong> <strong class="jq hj">输出事件</strong>。</p><h2 id="1bd7" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">输入测试</h2><p id="60c5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在下面的测试用例中，我们向HomeComponent中的<strong class="jq hj"> cart </strong>数组添加一个项目(第192行到第199行)。然后我们直接和ShoppingListComponent的<strong class="jq hj"> componentInstance </strong>中的shoppingList变量进行比较(第191行和第200行)。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/f25c50ed4b92406da99995b366a5000b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9MLcNw6s7QiVtAJv.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test input passes to the ShoppingListComponent</em></figcaption></figure><p id="434a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在角度测试中，componentInstance的工作方式与组件实例相同。它允许我们访问组件中定义的变量或函数。在这个测试用例中，我们首先使用HTML选择器从HTML中查询ShoppingListComponent，然后直接从componentInstance访问ShoppingListComponent的shoppingList输入。</p><h2 id="4e47" class="mj ir hi bd is mk ml mm iw mn mo mp ja jz mq mr je kd ms mt ji kh mu mv jm mw bi translated">输出测试</h2><p id="dd2c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通常，当一个子组件从它的输出中发出一个事件时，我们会从父组件中执行一个函数。我们可以在下面的测试案例中测试这种行为。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/a1e6265ef5c4b096fda2e5e3bd9f4560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y9wtXPVSm-T9Yqhx.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Output binding test cases</em></figcaption></figure><p id="d7f3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在上面的三个测试案例中，我们首先在父函数上设置一个Spy对象，当子函数发出事件时，我们希望执行这个对象(第205行、第212行和第219行)。</p><p id="60d1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后，我们使用它的HTML选择器查询ShoppingListComponent(第203行、第210行和第217行)。</p><p id="1052" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最后，我们通过ShoppingListComponent的<strong class="jq hj"> componentInstance </strong>手动发出事件(第206行、第213行和第220行)，并测试我们的间谍是否被调用。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="397f" class="iq ir hi bd is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn bi translated">结论</h1><p id="3fa8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本教程中，我们已经讨论了为角度组件编写单元测试时的许多主题。尽管浏览这个购物清单演示应用程序的所有测试用例是相当困难的，但是我们已经涵盖了为了编写角度组件的单元测试而需要学习的大多数场景。完整的代码及其单元测试可以在<a class="ae km" href="https://github.com/chen1223/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> GitHub上找到。你可以找到我为这个演示应用程序准备的所有测试用例。</a></p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/e68d98d36beb277991302eb75fd2e062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uwnjZzT5wUP1EKsW.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx"><em class="lc">Test Coverage of the Shopping List Application</em></figcaption></figure><p id="28bb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">正如你可能已经注意到的，尽管我们已经在本教程中涵盖了这么多的主题，我们还是完全忽略了角形的单元测试。这是因为角形测试包含了大量的主题，这些主题本身就可以形成一个教程。在下一个教程中，我们将看看如何为角形编写单元测试。</p></div></div>    
</body>
</html>
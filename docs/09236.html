<html>
<head>
<title>Deploying Docker Registry on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上部署Docker注册表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploying-docker-registry-on-kubernetes-3319622b8f32?source=collection_archive---------2-----------------------#2021-12-02">https://medium.com/geekculture/deploying-docker-registry-on-kubernetes-3319622b8f32?source=collection_archive---------2-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/447485e6d7300906733dfc5d1cbbc2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJNQaGM-MFitDCgAj-unzA.png"/></div></figure><div class=""/><p id="e556" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在之前的一篇文章中，我们建立了一个裸机Kubernetes集群，随后我们又发布了另一篇文章，展示了如何在其上部署Redis集群。现在，我们将在我们的集群上部署一个Docker注册表。</p><p id="a8d0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为什么要在集群上部署Docker注册中心？有时候，我喜欢运行一个带有自定义映像的集群，这些映像只在那个特定的集群上运行。在其他情况下，我们可能希望将集群隔开，这样就有了一个docker注册表，每个集群节点都可以获取映像。</p><p id="078d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">幸运的是，在Kubernetes上运行Docker注册中心并不太难。为了使本指南简单明了，我们将部署一个带有自签名证书的Docker注册表。完成此操作后，我们可以随时添加用户身份验证和/或LetsEncrypt证书。</p><h1 id="da38" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">创建密钥和证书</h1><p id="b283" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">如<a class="ae jk" href="https://docs.docker.com/registry/insecure/" rel="noopener ugc nofollow" target="_blank"> Docker指南</a>所述，创建一个新的自签名证书，如下所示:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4003" class="kx jm hp kt b fi ky kz l la lb">$ mkdir -p certs<br/>$ openssl req \<br/>  -newkey rsa:4096 -nodes -sha256 -keyout certs/registry.key \<br/>  -addext "subjectAltName = IP:10.211.55.250" \<br/>  -x509 -days 3650 -out certs/registry.crt</span></pre><p id="c62b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里重要的一点是，我们将<code class="du lc ld le kt b">subjectAltName</code>设置为我们的MetalLB负载平衡器将分配的IP号。在我们的集群中，我们将把<code class="du lc ld le kt b">10.211.55.250 </code>分配给Docker注册服务(见后面)。</p><h1 id="6d67" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">将密钥和证书存储在群集中</h1><p id="10cd" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">Kubernetes的好处在于，它允许您存储秘密，并使所有节点都可以安全地访问它们。现在，让我们将创建的密钥和证书存储在我们的群集上:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e203" class="kx jm hp kt b fi ky kz l la lb">kubectl create secret tls registry-cert \<br/>    --cert=certs/registry.crt \<br/>    --key=certs/registry.key \<br/>    -n test</span></pre><p id="2a39" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的命令将把<code class="du lc ld le kt b">registry.crt</code>和<code class="du lc ld le kt b">registry.key</code>存储在名称空间<code class="du lc ld le kt b">test</code>中一个名为<code class="du lc ld le kt b">registry-cert</code>的TLS秘密中。我们将在这个名称空间中部署Docker注册中心。</p><h1 id="5088" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">为Docker注册表创建永久卷</h1><p id="f10b" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">为存储在我们的注册表中的docker映像使用一个永久卷是一个好主意。这样，如果我们的注册表运行的Pod被重新安排到另一个节点，我们将不会丢失我们存储在其中的所有图像。</p><p id="ab7f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用以下内容创建一个名为<code class="du lc ld le kt b">registry-pvc.yaml</code>的文件:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="912b" class="kx jm hp kt b fi ky kz l la lb">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: registry-data-pvc<br/>  namespace: test<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  storageClassName: longhorn<br/>  resources:<br/>    requests:<br/>      storage: 50Gi</span></pre><p id="5473" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面将在Longhorn上创建一个持久的卷声明，在<code class="du lc ld le kt b">test</code>名称空间中声明50G。立即创建:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="418a" class="kx jm hp kt b fi ky kz l la lb">$ kubectl create -f registry-pvc.yaml</span></pre><h1 id="571e" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">在集群上部署Docker注册表</h1><p id="a0c8" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">使用以下内容创建一个名为<code class="du lc ld le kt b">registry-deployment.yaml</code>的部署描述符:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8966" class="kx jm hp kt b fi ky kz l la lb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    run: registry<br/>  name: registry<br/>  namespace: test<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      run: registry<br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: registry<br/>    spec:<br/>      nodeSelector:<br/>        node-type: worker<br/>      containers:<br/>      - name: registry<br/>        image: registry:2<br/>        ports:<br/>        - containerPort: 5000<br/>        env:<br/>        - name: REGISTRY_HTTP_TLS_CERTIFICATE<br/>          value: "/certs/tls.crt"<br/>        - name: REGISTRY_HTTP_TLS_KEY<br/>          value: "/certs/tls.key"<br/>        volumeMounts:<br/>        - name: registry-certs<br/>          mountPath: "/certs"<br/>          readOnly: true<br/>        - name: registry-data<br/>          mountPath: /var/lib/registry<br/>          subPath: registry<br/>      volumes:<br/>      - name: registry-certs<br/>        secret:<br/>          secretName: registry-cert<br/>      - name: registry-data<br/>        persistentVolumeClaim:<br/>          claimName: registry-data-pvc</span></pre><p id="2ecd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们配置一个pod，使用我们之前创建的TLS密钥和证书从<code class="du lc ld le kt b">registry:2</code>映像创建一个容器。我们告诉容器它可以在<code class="du lc ld le kt b">/certs</code>目录下找到这些。他们如何到达那里？为此，我们使用卷安装。我们定义一个名为<code class="du lc ld le kt b">registry-certs</code>的只读<code class="du lc ld le kt b">volumeMount</code>，将其安装在容器中的<code class="du lc ld le kt b">/certs</code>下。这个<code class="du lc ld le kt b">registry-certs</code> volumeMount引用了<code class="du lc ld le kt b">volumes</code>段中的秘密卷<code class="du lc ld le kt b">registry-cert</code>。</p><p id="9afb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还在容器中的目录<code class="du lc ld le kt b">/var/lib/registry</code>下挂载持久卷声明<code class="du lc ld le kt b">registry-data-pvc</code>。</p><p id="ea76" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继续在我们的集群上部署注册中心，如下所示:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2895" class="kx jm hp kt b fi ky kz l la lb">$ kubectl create -f registry-deployment.yaml</span></pre><p id="00bc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您应该能够看到在名称空间<code class="du lc ld le kt b">test</code>中的集群上运行的registry pod。您可以按如下方式进行检查:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="afc6" class="kx jm hp kt b fi ky kz l la lb">$ kubectl -n test get all</span></pre><h1 id="8b34" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">创建注册表服务</h1><p id="f7ad" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">既然我们的registry pod已经启动并运行，我们需要为它定义一个服务，以便我们的pod可以访问它。还记得我们在生成密钥和证书时使用的IP号吗？我们现在就用它。用以下内容创建一个名为<code class="du lc ld le kt b">registry-service.yaml</code>的服务描述符:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d0e1" class="kx jm hp kt b fi ky kz l la lb">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: registry-service<br/>  namespace: test<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    run: registry<br/>  ports:<br/>    - name: registry-tcp<br/>      protocol: TCP<br/>      port: 5000<br/>      targetPort: 5000<br/>  loadBalancerIP: 10.211.55.250</span></pre><p id="cec9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将指示负载平衡器暴露IP <code class="du lc ld le kt b">10.211.55.250</code>上的端口<code class="du lc ld le kt b">5000</code>。继续创建服务:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7e21" class="kx jm hp kt b fi ky kz l la lb">$ kubectl create -f registry-service.yaml</span></pre><p id="f69c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太好了！现在，您应该能够访问注册表了。让我们来测试一下:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="43b8" class="kx jm hp kt b fi ky kz l la lb">$ curl --cacert certs/registry.crt \<br/>        <a class="ae jk" href="https://test.example.org:5000/v2/_catalog" rel="noopener ugc nofollow" target="_blank">https://10.211.55.250:5000/v2/_catalog</a></span></pre><h1 id="cde5" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">在ca证书中加载证书</h1><p id="557a" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">因为我们处理的是自签名证书，所以我们需要指示主机操作系统信任这个证书。通常情况下，您可以使用证书颁发机构(CA)证书来完成这项工作，但是由于这是自签名的，因此该证书既是注册中心服务的证书，也是其自己的CA证书。因此，让我们将<code class="du lc ld le kt b">registry.cert</code>作为一个新的CA加载到所有集群节点上。我们需要这样做，因为所有集群节点上的k3s服务都需要能够从这个存储库中提取，并且它必须信任这个证书。我们可以使用Ansible轻松做到这一点:</p><figure class="ko kp kq kr fd hk"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4fbc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，我们在这里使用的是我们在之前的博客文章<a class="ae jk" rel="noopener" href="/geekculture/bare-metal-kubernetes-with-metallb-haproxy-longhorn-and-prometheus-370ccfffeba9">裸机Kubernetes </a>中定义的<code class="du lc ld le kt b">hosts</code>文件。</p><p id="653b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，证书已经加载到每个集群节点上，我们需要重新启动k3s服务，以便它能够接受更改。首先按如下方式重新启动工作节点:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d49c" class="kx jm hp kt b fi ky kz l la lb">ansible -i hosts workers -b -K -m shell \<br/>    -a "systemctl restart k3s-agent"</span></pre><p id="625e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，重新启动控制(也称为主)节点:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="57c1" class="kx jm hp kt b fi ky kz l la lb">ansible -i hosts control -b -K -m shell \<br/>    -a "systemctl restart k3s"</span></pre><h1 id="6467" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">测试一下！</h1><p id="2d84" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">随着工人和控制器的重新启动，让我们测试我们的新注册表！创建一个标记有新注册表的新图像，如下所示:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b443" class="kx jm hp kt b fi ky kz l la lb">$ docker pull alpine<br/>$ docker tag alpine 10.211.55.250:5000/alpine:latest<br/>$ docker push 10.211.55.250:5000/alpine:latest</span></pre><p id="467d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切顺利，重新标记的alpine映像现在应该在集群上的本地docker注册表中。现在，让我们尝试使用这个新映像部署一个pod。用以下内容创建一个名为<code class="du lc ld le kt b">alpine-test-pod.yaml</code>的文件:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9352" class="kx jm hp kt b fi ky kz l la lb">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: alpine-test<br/>  namespace: test<br/>spec:<br/>  containers:<br/>  - name: alpine<br/>    image: 192.168.137.250:5000/alpine:latest<br/>    command: ["sleep", "60s"]<br/>  restartPolicy: "Never"</span></pre><p id="3741" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">部署它:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f5b5" class="kx jm hp kt b fi ky kz l la lb">$ kubectl create -f alpine-test-pod.yaml</span></pre><p id="bece" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">检查部署是否顺利:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7d23" class="kx jm hp kt b fi ky kz l la lb">$ kubectl -n test describe pod alpine-test</span></pre><p id="66f2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切顺利，pod应该已经创建并成功启动了！现在，您可以在群集上“本地”存储映像了！</p></div></div>    
</body>
</html>
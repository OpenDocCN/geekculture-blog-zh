<html>
<head>
<title>Removing the Magic Veil of Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开算法的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/removing-the-magic-veil-of-algorithms-e10216ea3099?source=collection_archive---------50-----------------------#2021-08-31">https://medium.com/geekculture/removing-the-magic-veil-of-algorithms-e10216ea3099?source=collection_archive---------50-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1165" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">理解算法的快速指南</h2></div><p id="4ccb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“算法”这个词在媒体中经常被使用。毕竟，谷歌使用的是一种算法……还有Twitter、Tinder、Instagram、Medium等等。在电影和电视中，算法只由想要终结世界或拯救世界的超级天才创造。这可能会让人感到有些畏惧。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="3b94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果我告诉你一个算法不一定要像你想象的那么复杂呢？事实上，你可能在日常生活中使用某种形式的算法？</p><h1 id="65a6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">凯西…</h1><p id="e097" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">简单地说，算法就是用来实现预期结果的一系列指令。这样想:你有没有在使用食谱的时候烹饪或烘焙过？或者用宜家的说明书组装一件家具？配方和说明实际上是算法。</p><h1 id="fe0a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">…凯达布拉！</h1><p id="f788" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">就这样，面纱消失了。是的，就是这么简单。</p><h1 id="973b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk io kl ip km ir kn is ko iu kp iv kq kr bi translated">算法的类型</h1><p id="dc2e" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">说到计算机算法，我们可以将它们分为6种不同的类型:</p><ol class=""><li id="536e" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">递归算法</li><li id="8487" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">分治算法</li><li id="3f60" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">动态编程算法</li><li id="dec4" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">贪婪算法</li><li id="1e84" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">暴力算法</li><li id="ceb5" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">回溯算法</li></ol><p id="6f4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细看看其中的每一个:</p><h2 id="cc3e" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">递归算法</h2><p id="e325" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">简而言之，递归算法是直接或间接调用自身的算法。例如，阶乘函数:</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="bee8" class="ll kb hi ma b fi me mf l mg mh">function factorial(n) {<br/>   if(n == 1)<br/>   {<br/>      return 1;<br/>   }<br/>   else<br/>   {<br/>      return n * factorial(n ‑ 1);<br/>   }<br/>}</span></pre><p id="20d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经在循环中看到了另一个这样的例子！</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="1267" class="ll kb hi ma b fi me mf l mg mh">let i = 0; i &lt; a.length; i++</span></pre><p id="84dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">眼熟吗？这在每次迭代后调用自身，直到满足条件。</p><h2 id="61ed" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">分治算法</h2><p id="8c3e" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">这种马基雅维利式的方法已经在你的代码中广泛使用，你可能甚至不知道。JavaScript的分治函数就是一个很好的例子。排序()</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="18af" class="ll kb hi ma b fi me mf l mg mh">const array = [5,3,1,2,4]</span><span id="c767" class="ll kb hi ma b fi mi mf l mg mh">array.sort();<br/>console.log(array);<br/>// [1,2,3,4,5]</span></pre><p id="6444" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其工作方式是划分数组——从5和3开始——询问，5是大于、小于还是等于3？根据答案移动5。它将数组分成更小的部分，然后将求解出的更小的部分放回一起。</p><h2 id="9d07" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">动态编程算法</h2><p id="34d2" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">动态编程是一种将问题分解成更小的问题，并保存结果以备将来使用的技术。斐波那契数列就是一个很好的例子。</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="496a" class="ll kb hi ma b fi me mf l mg mh">function fibonacci(num) {  <br/>   if (num &lt;= 1) return 1;   <br/>   <br/>   return fibonacci(num - 1) + fibonacci(num - 2);<br/>}</span><span id="aa59" class="ll kb hi ma b fi mi mf l mg mh">// =&gt; 2,3,5,8,13,21...</span></pre><p id="0823" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来是不是有点眼熟？确实如此。那是因为这个函数也是递归的！动态编程主要是对普通递归的优化。每当我们看到递归解决方案重复调用相同的输入时，我们可以使用动态编程来优化它。</p><h2 id="a70f" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">贪婪算法</h2><p id="fedc" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">贪婪算法接受一个问题，并在每一步做出局部最优选择(给定点的最佳解决方案),希望找到全局最佳解决方案。这是另一种解决问题的递归方法。以下面的例子为例，我们希望以尽可能小的阻力从节点B到达G:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/ea9d1a47a3e6bef324e329c5518f0434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXsYHEX0Ph1Yjcm0bYST2Q.png"/></div></div></figure><p id="d338" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上图可以看出，贪婪算法(red = 19)并不是可用的最佳路径。在这里，启发式解决方案(绿色= 18)实际上是最优的。有时候，贪婪算法甚至会让你离你要寻找的解决方案更远。</p><h2 id="5324" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">暴力算法</h2><p id="362a" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">蛮力算法就像它们听起来的那样——解决问题的简单方法，依靠纯粹的计算能力和尝试每一种可能性，而不是先进的技术来提高效率。</p><p id="2456" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设您忘记了银行帐户的PIN。强力算法将从头开始，遍历所有可能的组合，直到找到正确的组合(0000，0001，0002，0003…等等)。代码示例如下所示:</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="82bc" class="ll kb hi ma b fi me mf l mg mh">function bruteForceSubstringSearch(text, pattern) {<br/>    const lengthOfText = text.length;<br/>    const lengthOfPattern = pattern.length;<br/>    for (let i = 0; i &lt; lengthOfText; i++) {<br/>        let j;<br/>        for (j = 0; j &lt; lengthOfPattern; j++) {<br/>            if (text.charAt(i + j) !== pattern.charAt(j)) {<br/>                   break;<br/>            }<br/>        }<br/>        if (j === lengthOfPattern) return i;<br/>    }<br/>    return lengthOfText;<br/>}<br/><br/>bruteForceSubstringSearch('this is a test', 'test');</span></pre><p id="0a16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你在递归函数中使用递归函数所看到的那样，这些算法继续发挥作用，并相互依赖。</p><h2 id="5084" class="ll kb hi bd kc lm ln lo kg lp lq lr kk jg ls lt km jk lu lv ko jo lw lx kq ly bi translated">回溯算法</h2><p id="da77" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">回溯是一种以增量方式寻找问题解决方案的技术。它通过一次解决一部分问题来递归地解决问题。如果其中一个解决方案失败了，我们就删除它，然后回溯寻找另一个解决方案。</p><p id="5f4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，考虑解决一个数独难题需要什么:我们尝试一个接一个地填充数字，但每当我们发现当前数字不能导致解决方案时，我们就移除它(回溯)并尝试下一个数字。</p><pre class="jt ju jv jw fd lz ma mb mc aw md bi"><span id="72f9" class="ll kb hi ma b fi me mf l mg mh">// N is the size of the 2D matrix (N*N)<br/>let N = 9;</span><span id="1bed" class="ll kb hi ma b fi mi mf l mg mh">function<!-- --> <!-- -->solveSuduko(grid, row, col){<br/>    if<!-- --> <!-- -->(row == N - 1 &amp;&amp; col == N)<br/>       return<!-- --> <!-- -->true;<br/>    if<!-- --> <!-- -->(col == N){<br/>       row++;<br/>       col = 0;<br/>    }<br/>    if<!-- --> <!-- -->(grid[row][col] != 0)<br/>       return<!-- --> <!-- -->solveSuduko(grid, row, col + 1);</span><span id="3073" class="ll kb hi ma b fi mi mf l mg mh">    for(let num = 1; num &lt; 10; num++){<br/>       if<!-- --> <!-- -->(isSafe(grid, row, col, num)){<br/>         <!-- -->grid[row][col] = num;<br/>         <!-- -->if<!-- --> <!-- -->(solveSuduko(grid, row, col + 1))<br/>            return true;<br/>        }<br/>        <!-- -->grid[row][col] = 0;<br/>     }<br/>  return false;<br/>}</span></pre></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mx jz l"/></div></figure><p id="0931" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这个简短的概述给你一个好的起点，让你在这些粗糙的算法水域中导航。永远记住，就像口头语言修辞一样，对于我们将面临的所有问题，没有一个放之四海而皆准的解决方案。为手头的工作使用最好的工具很重要。现在去施法吧，你们这些巫师！</p><p id="7c83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！</p></div></div>    
</body>
</html>
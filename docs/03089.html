<html>
<head>
<title>Using A Database for Unit Testing With Docker in GitLab Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GitLab管道中使用Docker对数据库进行单元测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-a-database-for-unit-testing-with-docker-in-gitlab-pipeline-c919121e25ef?source=collection_archive---------18-----------------------#2021-05-31">https://medium.com/geekculture/using-a-database-for-unit-testing-with-docker-in-gitlab-pipeline-c919121e25ef?source=collection_archive---------18-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e81f5e8231d1c5c168def5edf8862db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TpZFGeLohM3fTXW1"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@exdigy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dominik Lückmann</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b9fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我有机会使用GitLab为各种微服务构建CI管道。当到了运行单元测试的时候，问题就来了，因为一些项目没有使用mocker，而是想要连接到一个测试数据库。谢天谢地，我们有办法生成一个临时数据库用于测试。</p><p id="e10f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个场景中，我将使用git lab dind Docker-In-Docker(dind)来构建、测试和部署映像。</p><p id="d827" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从一个例子<code class="du jt ju jv jw b">Dockerfile</code>开始，为此我将假设我们使用一个简单的NodeJs项目</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="5fe2" class="kf kg hi jw b fi kh ki l kj kk">FROM node:14-alpine AS node</span><span id="25aa" class="kf kg hi jw b fi kl ki l kj kk"># Builder stage<br/>FROM node AS builder</span><span id="92fc" class="kf kg hi jw b fi kl ki l kj kk">ENV APP_PORT 8080</span><span id="d44e" class="kf kg hi jw b fi kl ki l kj kk">WORKDIR /app</span><span id="1942" class="kf kg hi jw b fi kl ki l kj kk">COPY . .</span><span id="38d5" class="kf kg hi jw b fi kl ki l kj kk"># Copy .env configuration<br/>COPY .env.test ./.env</span><span id="90fb" class="kf kg hi jw b fi kl ki l kj kk"># Install dependencies<br/>RUN npm ci</span><span id="9efb" class="kf kg hi jw b fi kl ki l kj kk"># Port public untuk akses<br/>EXPOSE 8080</span><span id="e18a" class="kf kg hi jw b fi kl ki l kj kk"># Run development server<br/>CMD [ "npm", "run", "dev" ]</span></pre><p id="4e92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我使用的是<strong class="ix hj"> CMD </strong>而不是<strong class="ix hj">入口点</strong>。这是因为它将允许我在旋转容器时覆盖启动命令。</p><p id="026f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我推荐使用<strong class="ix hj">入口点</strong>作为生产就绪的映像。</p><p id="1819" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在对于<code class="du jt ju jv jw b">.gitlab-ci.yaml</code>，我们将只做一个基本的构建和测试步骤</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0eba" class="kf kg hi jw b fi kh ki l kj kk">image: docker:latest<br/>services:<br/>  - name: docker:dind</span><span id="5cdd" class="kf kg hi jw b fi kl ki l kj kk">stages:<br/>  - build<br/>  - test<br/>  - deploy</span><span id="29d2" class="kf kg hi jw b fi kl ki l kj kk">variables:<br/>  DOCKER_DRIVER: overlay2<br/>  # See <a class="ae iu" href="https://github.com/docker-library/docker/pull/166" rel="noopener ugc nofollow" target="_blank">https://github.com/docker-library/docker/pull/166</a><br/>  DOCKER_TLS_CERTDIR: ""</span><span id="9081" class="kf kg hi jw b fi kl ki l kj kk">  # Autogenerated for tags<br/>  TAG_LATEST: $CI_REGISTRY_IMAGE:latest<br/>  TAG_COMMIT: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA</span><span id="31c1" class="kf kg hi jw b fi kl ki l kj kk">  # This should be set from within gitlab<br/>  CI_REGISTRY: &lt;regsitry_endpoint&gt;<br/>  CI_REGISTRY_USER: &lt;registry_username&gt;<br/>  CI_REGISTRY_PASSWORD: &lt;registry_password&gt;</span><span id="dea7" class="kf kg hi jw b fi kl ki l kj kk"># We build the image and push it to our registry<br/>build:<br/>  stage: build<br/>  script:<br/>    - docker build --pull -t $TAG_COMMIT .<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"   "$CI_REGISTRY"<br/>    - docker push $TAG_COMMIT</span><span id="8622" class="kf kg hi jw b fi kl ki l kj kk"># We pull the image again and running the docker by overwriting the command<br/>test:<br/>  stage: test<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"<br/>    - docker pull $TAG_COMMIT<br/>    - docker run $TAG_COMMIT_DEV sh -c "npm run test"</span><span id="6078" class="kf kg hi jw b fi kl ki l kj kk"># We re-tag it for latest when its successful<br/>deploy:<br/>  stage: deploy<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"<br/>    - docker pull $TAG_COMMIT<br/>    - docker tag $TAG_COMMIT_DEV $TAG_LATEST_DEV<br/>    - docker push $TAG_LATEST_DEV</span></pre><p id="08a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将利用docker网络映射，自动将服务绑定到其环境。因此，如果你有一个不同的数据库或服务，它应该可以通过<name> _PORT_ <port> _ADDR访问，它会返回给你它自动生成的IP地址。</port></name></p><p id="7004" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看Postgres是什么样子的</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="e8f7" class="kf kg hi jw b fi kh ki l kj kk">image: docker:latest<br/>services:<br/>  - name: docker:dind<br/>  - name: postgres:12.2-alpine</span><span id="fc5a" class="kf kg hi jw b fi kl ki l kj kk">...</span><span id="c13d" class="kf kg hi jw b fi kl ki l kj kk">variables:<br/>  POSTGRES_DB: sample_db<br/>  POSTGRES_USER: admin<br/>  POSTGRES_PASSWORD: password<br/>  POSTGRES_HOST_AUTH_METHOD: trust<br/>  ...</span><span id="3f6e" class="kf kg hi jw b fi kl ki l kj kk">...</span><span id="efea" class="kf kg hi jw b fi kl ki l kj kk">test:<br/>  stage: test<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"<br/>    - docker pull $TAG_COMMIT <br/>    #we capture the IP address<br/>    - env | grep POSTGRES_PORT_5432_TCP_ADDR<br/>    # Now we overwrite the Image environment<br/>    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="postgres://admin:password@${POSTGRES_PORT_5432_TCP_ADDR}:5432/sample_db" npm run test"</span><span id="e5ac" class="kf kg hi jw b fi kl ki l kj kk">...</span></pre><p id="c484" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和MongoDB</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b99c" class="kf kg hi jw b fi kh ki l kj kk">image: docker:latest<br/>services:<br/>  - name: docker:dind<br/>  - name: mongo:latest</span><span id="a9a8" class="kf kg hi jw b fi kl ki l kj kk">...</span><span id="d784" class="kf kg hi jw b fi kl ki l kj kk">variables:<br/>  MONGO_INITDB_ROOT_USERNAME: admin<br/>  MONGO_INITDB_ROOT_PASSWORD: password<br/>  MONGO_INITDB_DATABASE: sample_db<br/>  ...</span><span id="8801" class="kf kg hi jw b fi kl ki l kj kk">test:<br/>  stage: test<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"<br/>    - docker pull $TAG_COMMIT <br/>    #we capture the IP address<br/>    - env | grep POSTGRES_PORT_5432_TCP_ADDR<br/>    # Now we overwrite the Image environment<br/>    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="admin:password@${MONGO_PORT_27017_TCP_ADDR}" npm run test"</span><span id="69f8" class="kf kg hi jw b fi kl ki l kj kk">...</span></pre><p id="0605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后是Redis</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="7855" class="kf kg hi jw b fi kh ki l kj kk">image: docker:latest<br/>services:<br/>  - name: docker:dind<br/>  - name: redis:latest</span><span id="5dc6" class="kf kg hi jw b fi kl ki l kj kk">...</span><span id="5e4d" class="kf kg hi jw b fi kl ki l kj kk">test:<br/>  stage: test<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"<br/>    - docker pull $TAG_COMMIT <br/>    #we capture the IP address<br/>    - env | grep REDIS_PORT_6379_TCP_ADDR<br/>    # Now we overwrite the Image environment<br/>    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="admin:password@${REDIS_PORT_6379_TCP_ADDR}" npm run test"</span><span id="2e52" class="kf kg hi jw b fi kl ki l kj kk">...</span></pre><p id="93a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这有所帮助！</p><p id="55ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">祝你建立管道好运。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Getting Started With Docker in Your React.Js Application — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的Docker入门。Js应用程序—基础</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/getting-started-with-docker-in-your-react-js-application-the-basics-6e5300cf749d?source=collection_archive---------0-----------------------#2021-05-08">https://medium.com/geekculture/getting-started-with-docker-in-your-react-js-application-the-basics-6e5300cf749d?source=collection_archive---------0-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9fd6889977b61b764a713f0052bc5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*e8u6teTHyalPejIBauj4Jw.png"/></div></figure><p id="c20a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将回顾在React应用程序中使用docker的步骤。出于讨论的目的，我决定将docker添加到一个简单的React项目中。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="b356" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">克隆React应用程序</h2><p id="a52c" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">下面，我粘贴了一个项目的链接，所以你可以在你的终端上运行下面的命令来克隆它；</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6ac0" class="jr js hi kw b fi la lb l lc ld">git clone <a class="ae le" href="https://github.com/OyinloluB/React-Docker.git" rel="noopener ugc nofollow" target="_blank">https://github.com/OyinloluB/React-Docker.git</a></span></pre><p id="e80b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">克隆应用程序并在本地运行后，您应该会看到下面的屏幕:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/87700905012bda8d22baca328ce1ae52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUGmbjGzKnSpSyoMCMc5Og.png"/></div></div></figure><p id="af97" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者，你可以在你的个人项目中编码——两者都可以。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="c5ec" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">下载Docker</h2><p id="918c" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">为了能够使用docker，您需要在您的计算机上安装docker。不用担心，这是一个非常简单的过程。你所要做的就是去docker网站专门为你的操作系统下载Docker。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/62a15de4dce556674ea5fab3b6a15f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kk6SGUjkhEZ4qLljhJGE1A.png"/></div></div></figure><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/ba840ebf2764fd4b1b2eddc36308a64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHLCv-VGDIFJDm6W4EKGzg.png"/></div></div></figure><p id="720c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要确认您是否已经成功地将docker安装到您的系统上，您可以在您的终端中运行以下命令:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9263" class="jr js hi kw b fi la lb l lc ld">docker -v</span></pre></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="f10a" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">理解条款</h2><p id="e6a8" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">使用docker时，您会经常遇到一些术语。理解它们的含义很重要，为此，我将在下面定义这些术语:</p><ul class=""><li id="cd95" class="lk ll hi io b ip iq it iu ix lm jb ln jf lo jj lp lq lr ls bi translated"><strong class="io hj">码头工人:</strong></li></ul><blockquote class="lt lu lv"><p id="2fa9" class="im in lw io b ip iq ir is it iu iv iw lx iy iz ja ly jc jd je lz jg jh ji jj hb bi translated">Docker，简单来说就是Y <a class="ae le" href="https://www.youtube.com/watch?v=gAkwW2tuIqE" rel="noopener ugc nofollow" target="_blank"> ouTube </a>上的<a class="ae le" href="https://www.youtube.com/channel/UCsBjURrPoezykLs9EqgamOA" rel="noopener ugc nofollow" target="_blank"> Fireship </a>所定义的，是一种打包软件的方式，所以它能够在任何硬件上运行。</p></blockquote><p id="38e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Docker将您的web应用程序部署到容器中。这些容器获取您的代码、依赖项和它需要的一切，然后允许它在任何环境下运行。</p><ul class=""><li id="e758" class="lk ll hi io b ip iq it iu ix lm jb ln jf lo jj lp lq lr ls bi translated"><strong class="io hj">图像:</strong>docker图像包含运行应用程序所需的一切。它是一个模板，包含创建工作容器所需的一组指令。</li><li id="663f" class="lk ll hi io b ip ma it mb ix mc jb md jf me jj lp lq lr ls bi translated"><strong class="io hj">容器:</strong>这是一个正在运行的映像进程/实例。如上所述，docker容器“包含”了应用程序运行所需的一切，并且可以在任何环境中运行应用程序。</li><li id="d675" class="lk ll hi io b ip ma it mb ix mc jb md jf me jj lp lq lr ls bi translated"><strong class="io hj">docker file:</strong>docker file是定义如何构建映像的蓝图/一组指令。这是您定义的一系列步骤，必须在成功构建映像之前完成。</li><li id="c531" class="lk ll hi io b ip ma it mb ix mc jb md jf me jj lp lq lr ls bi translated"><strong class="io hj"> Docker hub: </strong>想到Github。Docker hub是一个注册表，允许您托管您的图像，并让您访问大量其他Docker图像，您可以提取和使用这些图像。</li><li id="f530" class="lk ll hi io b ip ma it mb ix mc jb md jf me jj lp lq lr ls bi translated"><strong class="io hj">Dockerignore:</strong><em class="lw">。dockerignore </em>文件的作用类似于<em class="lw">。gitignore </em>文件。它包含本地应用程序中不希望出现在docker映像中的任何文件。</li></ul><p id="0500" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们已经学习了这些术语，我们可以开始在编写我们的简单应用程序时应用它们。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="7205" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">入门指南</h2><p id="528d" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">在React应用程序中，我们要做的第一件事是在根目录下创建一个名为<em class="lw"> Dockerfile </em>的文件。我们将其定义为一系列步骤、一组说明、一个蓝图，它定义了如何构建您的映像。我们还说过一个<em class="lw">映像</em>包含你创建一个工作容器所需的每一条指令，一个<em class="lw">容器</em>是一个映像的运行实例，它允许你的应用程序在任何环境下运行。现在我们都赶上了，让我们在dockerfile中写一些一步一步的说明，告诉它我们希望如何建立我们的形象。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c5e2" class="jr js hi kw b fi la lb l lc ld">FROM node:latest</span></pre><p id="34e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里的关键字是来自的<strong class="io hj">，这里我们的第一步/指令说我们想要使用最新的节点映像。</strong></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5489" class="jr js hi kw b fi la lb l lc ld">WORKDIR /app</span></pre><p id="4eb2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里的WORKDIR 说我们想要将应用程序的源代码添加到图像中。这行指令在我们的映像中创建了一个名为<em class="lw"> app </em>的目录，并将我们的源代码添加到该目录中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="deb4" class="jr js hi kw b fi la lb l lc ld">COPY package.json ./</span></pre><p id="b46c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的应用程序中，我们已经安装了一些依赖项。<strong class="io hj">复制</strong>这里复制我们<em class="lw"> packge.json </em>文件的内容。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4873" class="jr js hi kw b fi la lb l lc ld">RUN npm install</span></pre><p id="ec84" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">运行</strong> npm install继续在我们的映像中安装我们可能已经本地安装的所有依赖项。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f920" class="jr js hi kw b fi la lb l lc ld">COPY . .</span></pre><p id="816c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样做的目的是将本地目录中的所有文件复制到在我们的映像中创建的<em class="lw"> /app </em>目录中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ca01" class="jr js hi kw b fi la lb l lc ld">CMD ["npm", "start"]</span></pre><p id="402b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这最后一个命令在每一步都成功导航后启动应用程序。</p><p id="d4f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你的<em class="lw"> dockerfile </em>现在应该是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4e63" class="jr js hi kw b fi la lb l lc ld">FROM node:latest</span><span id="160a" class="jr js hi kw b fi mf lb l lc ld">WORKDIR /app</span><span id="5d8a" class="jr js hi kw b fi mf lb l lc ld">COPY package.json ./</span><span id="eb29" class="jr js hi kw b fi mf lb l lc ld">RUN npm install</span><span id="7554" class="jr js hi kw b fi mf lb l lc ld">COPY . .</span><span id="df6c" class="jr js hi kw b fi mf lb l lc ld">CMD ["npm", "start"]</span></pre></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="7a08" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">使用。dockerignore</h2><p id="df58" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">在运行我们的应用程序以查看我们的设置是否有效之前，我们必须做一件事。现在的<em class="lw">。dockerignore </em>文件是你不希望出现在docker映像中的所有东西的家。在我们的应用程序中，我们的映像中不需要的一个东西是<em class="lw"> node_module </em>文件夹。为什么？在我们的<em class="lw"> dockerfile </em>中，我们正在运行<em class="lw"> npm install </em>以便访问我们应用程序中的所有依赖项。这本身将创建一个<em class="lw"> node_modules </em>文件夹。</p><p id="fc72" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们将所有文件从本地复制到映像时，我们也复制了<em class="lw"> node_modules </em>文件夹。为了抑制这种情况，在您的根目录中，创建一个<em class="lw">。dockerignore </em>文件。我们在这里要做的事情非常简单，我们包括了与我们的docker映像无关的文件:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d192" class="jr js hi kw b fi la lb l lc ld">node_modules</span><span id="7953" class="jr js hi kw b fi mf lb l lc ld">Dockerfile</span><span id="d284" class="jr js hi kw b fi mf lb l lc ld">.git</span></pre></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="dd21" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">建立我们的形象</h2><p id="960d" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">现在要启动并运行我们的容器，我们必须首先运行build命令。这个命令遍历了我们在over文件中定义的每一步，当您运行它时会看到:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ba2d" class="jr js hi kw b fi la lb l lc ld">docker build -t nameofyourapp:latest .</span></pre><p id="9f65" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当它运行时，在您的终端中，您会看到它遍历了我们在over文件中定义的每一步。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mg"><img src="../Images/39df4c7a6507928845e54a2be75328ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75svS3GaD_y2lUfymC4DyA.png"/></div></div></figure></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="586f" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">运行我们的容器</h2><p id="565b" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">要运行我们的docker容器，在您的终端中编写命令:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cbfb" class="jr js hi kw b fi la lb l lc ld">docker run --name nameofyourchoice -d -p 3000:3000 nameofyourapp:latest</span></pre><ul class=""><li id="e48f" class="lk ll hi io b ip iq it iu ix lm jb ln jf lo jj lp lq lr ls bi translated"><strong class="io hj"> -d: </strong>这将在分离模式下运行容器。简单地说，当您离开终端会话时，它会让您的容器保持运行。</li><li id="d2ac" class="lk ll hi io b ip ma it mb ix mc jb md jf me jj lp lq lr ls bi translated"><strong class="io hj"> -p: </strong>这用于发布您希望您的应用程序运行的端口。如果您运行您的容器而不发布端口，那么无论您的容器中运行什么，都只能在您的容器中访问。</li></ul><p id="0ad7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在您的容器成功运行后，您将会看到如下id:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="54a5" class="jr js hi kw b fi la lb l lc ld">6d1670d1e2ff97997fa1a071aff4e558cfd4ff33a4d7efb5001565832887af24</span></pre><p id="046b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您的id会有所不同，因为它特定于您的应用程序。</p><p id="ebd9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了进一步确认我们的应用程序是否按预期运行，您可以运行这个命令来查看当前正在运行的图像:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c500" class="jr js hi kw b fi la lb l lc ld">docker images</span></pre><p id="7a2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它会向您展示如下内容:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a4b2" class="jr js hi kw b fi la lb l lc ld">REPOSITORY      TAG       IMAGE ID       CREATED          SIZE  <br/>react          latest    64027c617dab   15 minutes ago   1.37GB</span></pre><p id="80f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了进一步确认，让我们在浏览器中运行我们发布的端口，看看是否会出现任何问题。因此，在你的浏览器中——如果你还在运行早先的<em class="lw"> localhost:3000 </em>上的React应用程序，进入你的终端并停止该进程，然后再次打开<em class="lw"> localhost:3000 </em>而不运行<em class="lw"> npm start </em>。您应该会看到一个简单的页面，上面写着“Hello World”，如下所示:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/e5084f4e7fc4203747f92ecc9260e5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESvCqobtP-AbWt8Q0--3tQ.png"/></div></div></figure></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="aad7" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated">结论</h2><p id="5a84" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">在这篇文章中，我们学习了如何对我们的React应用程序进行dockerize。当在任何应用程序中使用Docker时，还有更多的东西需要考虑。为了了解更高级的概念或更深入地研究这里所涉及的概念，您可以进一步阅读或查看Youtube视频中的详细内容。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Building a Machine Learning Model for Banknote Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建用于钞票认证的机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-machine-learning-model-for-banknote-authentication-f9c6855a9057?source=collection_archive---------4-----------------------#2021-04-11">https://medium.com/geekculture/building-a-machine-learning-model-for-banknote-authentication-f9c6855a9057?source=collection_archive---------4-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3873f255cbe6aa6bada6944a3ddfcf02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-QnUWk0zm6NFO1JpodaHw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jakobowens1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="94df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">目的是在给定从照片中获取的多个测量值的情况下，预测给定钞票是否是真实的。</em></p><p id="06c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">实现的算法:</em></p><ul class=""><li id="0d19" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><em class="jt">支持向量机</em></li><li id="1bc7" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt"> K最近邻</em></li><li id="6225" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">高斯朴素贝叶斯</em></li><li id="91cd" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">感知器学习</em></li></ul><p id="2c28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">机器学习库&amp;模块:</em></p><ul class=""><li id="dd8d" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><em class="jt"> Scikit学习库</em></li><li id="3769" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt"> csv模块</em></li><li id="abe6" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">随机模块</em></li></ul><p id="6983" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">如果你不知道Pandas，NumPy，etc机器学习库，这些模块会有助于你理解。因为这些模块就像基本的python语法。</em></p><h1 id="f265" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">介绍</h1><p id="b2f9" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">机器学习！！！🤪当今世界非常有趣的技术😉。我知道你已经听说了很多。今天我们要建立一个机器学习模型来鉴别钞票的真伪💵。</p><p id="1ad0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当你去银行存一些现金时，出纳员都会把钞票放进一台机器里，这台机器能辨别钞票是真的还是假的。机器使用一些分类技术来做这件事。分类有很多机器学习算法。分类是一种有监督的机器学习。分类中有多种机器学习算法。我们理解作为初学者很难知道每个算法的理论概念。如果对你来说是真的，没什么好恐慌的。🤪</p><p id="7cf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将实现' K最近邻，支持向量机，感知器学习&amp;高斯朴素贝叶斯'算法&amp;将解释建立一个钞票认证系统的过程。读完这篇文章，你将能够理解分类系统是如何使用机器学习算法构建的。</p><h1 id="4045" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">背景/兴趣</h1><p id="4aae" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">本文是Nuruzzaman Faruqui在孟加拉国达卡城市大学进行的“人工智能”课程的实验报告的一部分。这是孟加拉国最好的AI课程。</p><p id="5ffd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个课程中，我们从零开始学习AI。我们从基本的python开始，到自然语言处理结束。我们在“CSE 417:人工智能”课程中适当地学习了理论概念、基本数学，然后在实验室课程“CSE 418:人工智能实验室”中实施我们的知识。</p><p id="2321" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了掌握这门课程，我们已经做了很多实验，逐渐地，我们学会了人工智能的每个必要概念。现在我们可以建立我们的机器学习模型，也可以建立一个神经网络来解决一个复杂的问题。</p><h1 id="b671" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题陈述</h1><p id="1519" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">机器学习算法从数据集学习。因此，为了鉴别一张钞票是真是假，我们需要一个真钞和伪钞的数据集以及它们的不同特征。</p><p id="0233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下载免费数据集的一些来源有Kaggle、UCI机器学习库等。</p><p id="e841" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道数据是杂乱的。数据集可能包含多个缺失值。在这种情况下，我们必须清理数据集。为了避免这种麻烦，我们将使用预先清理过的数据集。您可以下载数据集(。CSV文件)。链接如下(<a class="ae iu" href="https://github.com/Muhammad-Taufiq-Khan/BanknoteClassificationModel" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/f354a38fac79e8818268f7d2407c8fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q3h_iBS2lCf-tbhY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">fig1: a snapshot of the CSV Dataset by Author</figcaption></figure><p id="d9d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该数据集包含总共1372条不同纸币的记录。左边的四列是我们可以用来预测钞票是真的还是假的数据，它是由人提供的外部数据，编码为0和1，其中0代表真的，1代表伪钞/假钞。机器学习算法需要特征和标签彼此分离的数据。标签表示输出类或输出类别。在我们的数据集中，方差、偏斜、曲率和熵是特征，而类列包含标签。</p><p id="fc52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以在这个数据集上训练我们的模型，看看我们是否可以预测新钞是否是真的。</p><h1 id="5d12" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">构建机器学习模型的Python代码</h1><p id="898d" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated"><em class="jt">注意:不要盲目复制粘贴代码。阅读解释部分，以便更好地理解。你会在我的</em> <a class="ae iu" href="https://github.com/Muhammad-Taufiq-Khan/BanknoteClassificationModel" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> Github </strong> </a> <em class="jt">资源库中找到可执行代码和CSV文件。</em></p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6102" class="lv kj hi lr b fi lw lx l ly lz">#import sklearn<br/># pip install scikit-learn</span><span id="13ff" class="lv kj hi lr b fi ma lx l ly lz">import csv</span><span id="4e37" class="lv kj hi lr b fi ma lx l ly lz">import random<br/></span><span id="327e" class="lv kj hi lr b fi ma lx l ly lz">from sklearn import svm</span><span id="9b50" class="lv kj hi lr b fi ma lx l ly lz">from sklearn.linear_model import Perceptron</span><span id="dfb4" class="lv kj hi lr b fi ma lx l ly lz">from sklearn.naive_bayes import GaussianNB</span><span id="3898" class="lv kj hi lr b fi ma lx l ly lz">from sklearn.neighbors import KNeighborsClassifier</span><span id="a4fb" class="lv kj hi lr b fi ma lx l ly lz">#Loading Algorithm in model variable</span><span id="891e" class="lv kj hi lr b fi ma lx l ly lz">model = svm.SVC()</span><span id="7936" class="lv kj hi lr b fi ma lx l ly lz">#model = Perceptron()</span><span id="6adb" class="lv kj hi lr b fi ma lx l ly lz"># model = KNeighborsClassifier(n_neighbors=3)</span><span id="7486" class="lv kj hi lr b fi ma lx l ly lz"># model = GaussianNB()</span><span id="6913" class="lv kj hi lr b fi ma lx l ly lz"># Read data in from file</span><span id="a0b4" class="lv kj hi lr b fi ma lx l ly lz">with open("banknotes.csv") as f:<br/>    reader = csv.reader(f)</span><span id="923f" class="lv kj hi lr b fi ma lx l ly lz">    next(reader)</span><span id="90df" class="lv kj hi lr b fi ma lx l ly lz">    data = []</span><span id="3b6e" class="lv kj hi lr b fi ma lx l ly lz">    for row in reader:</span><span id="ee3c" class="lv kj hi lr b fi ma lx l ly lz">    data.append({</span><span id="f92b" class="lv kj hi lr b fi ma lx l ly lz">        "feature": [float(cell) for cell in row[:4]],</span><span id="bb02" class="lv kj hi lr b fi ma lx l ly lz">        "label": "Authentic" if row[4] == "0" else "Counterfeit"</span><span id="a84c" class="lv kj hi lr b fi ma lx l ly lz">    })</span><span id="927c" class="lv kj hi lr b fi ma lx l ly lz"># Separate data into training and testing groups</span><span id="7d92" class="lv kj hi lr b fi ma lx l ly lz">holdout = int(0.40 * len(data))</span><span id="aa48" class="lv kj hi lr b fi ma lx l ly lz">random.shuffle(data)</span><span id="80fe" class="lv kj hi lr b fi ma lx l ly lz">testing = data[:holdout]</span><span id="b80e" class="lv kj hi lr b fi ma lx l ly lz">training = data[holdout:]</span><span id="3e17" class="lv kj hi lr b fi ma lx l ly lz"># Train model on training set</span><span id="2852" class="lv kj hi lr b fi ma lx l ly lz">X_training = [row["feature"] for row in training]</span><span id="f88b" class="lv kj hi lr b fi ma lx l ly lz">y_training = [row["label"] for row in training]</span><span id="64f5" class="lv kj hi lr b fi ma lx l ly lz">model.fit(X_training, y_training)</span><span id="fc70" class="lv kj hi lr b fi ma lx l ly lz"># Make predictions on the testing set</span><span id="dffb" class="lv kj hi lr b fi ma lx l ly lz">X_testing = [row["feature"] for row in testing]</span><span id="35f4" class="lv kj hi lr b fi ma lx l ly lz">y_testing = [row["label"] for row in testing]</span><span id="cd5d" class="lv kj hi lr b fi ma lx l ly lz">predictions = model.predict(X_testing)</span><span id="be84" class="lv kj hi lr b fi ma lx l ly lz"># Compute how well we performed</span><span id="59e9" class="lv kj hi lr b fi ma lx l ly lz">correct = 0</span><span id="d0bc" class="lv kj hi lr b fi ma lx l ly lz">incorrect = 0</span><span id="1aea" class="lv kj hi lr b fi ma lx l ly lz">total = 0</span><span id="7fa5" class="lv kj hi lr b fi ma lx l ly lz">for actual, predicted in zip(y_testing, predictions):</span><span id="3cee" class="lv kj hi lr b fi ma lx l ly lz">    total += 1</span><span id="6f0b" class="lv kj hi lr b fi ma lx l ly lz">    if actual == predicted:</span><span id="b3b9" class="lv kj hi lr b fi ma lx l ly lz">        correct += 1<br/>    else:</span><span id="5147" class="lv kj hi lr b fi ma lx l ly lz">        incorrect += 1</span><span id="4b22" class="lv kj hi lr b fi ma lx l ly lz"># Print results</span><span id="eaab" class="lv kj hi lr b fi ma lx l ly lz">print(f"Results for model {type(model).__name__}")</span><span id="c23c" class="lv kj hi lr b fi ma lx l ly lz">print(f"Correct: {correct}")</span><span id="f851" class="lv kj hi lr b fi ma lx l ly lz">print(f"Incorrect: {incorrect}")</span><span id="3fe5" class="lv kj hi lr b fi ma lx l ly lz">print(f"Accuracy: {100 * correct / total:.2f}%")</span></pre><h2 id="f847" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">输出</h2><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/f83e0a77d826c2ccae308da463af64f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/0*fyLcUYHdaYfjK6oJ"/></div><figcaption class="iq ir et er es is it bd b be z dx">Fig2: Output terminal By Author</figcaption></figure><p id="aebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用“支持向量机”算法训练了这个模型。要使用另一种算法进行训练，只需用不同的算法注释掉任何模型变量，并在其他算法中进行注释。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/de1a8daf85f92639bf88235a03c4a8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PyTEZBSMZ8UW7AMyfkGug.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">fig3: Snapshot of all models</figcaption></figure><h1 id="4a30" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结果</h1><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/1b98a469433392fb0f2139f269f14084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcMJzjEEHhvp7QevMqP7WQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig4: Accuracy of all of the model</figcaption></figure><h1 id="28e3" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">为了更好地理解，对整个代码进行解释</h1><h2 id="3180" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">1.导入所需模块</h2><p id="6979" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">在将数据集导入我们的机器学习模型并执行分析之前，我们需要导入一些库。以下脚本用于导入python模块:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="d695" class="lv kj hi lr b fi lw lx l ly lz">import csv<br/>import random</span></pre><h2 id="43a4" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">2.从sci-kit学习库中加载机器学习算法</h2><p id="06ee" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们使用了支持向量机、K近邻、感知器学习、高斯朴素贝叶斯算法，这是机器学习分类问题中最常用的四种算法。</p><ol class=""><li id="7bee" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js mr ka kb kc bi translated">支持向量机</li></ol><p id="2549" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了训练支持向量机，我们使用了“sklearn.svm”模块中的SVC类。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6147" class="lv kj hi lr b fi lw lx l ly lz">from sklearn import svm<br/>model = svm.SVC()</span></pre><p id="8c26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.感知机学习</p><p id="c160" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了训练感知器学习，我们从“sklearn.linear_model”模块中导入了感知器。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="cb51" class="lv kj hi lr b fi lw lx l ly lz">from sklearn.linear_model import Perceptron<br/>model = Perceptron()</span></pre><p id="304a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.高斯朴素贝叶斯</p><p id="03a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了训练高斯朴素贝叶斯，我们从“sklearn.naive_bayes”模块中导入高斯。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="ff92" class="lv kj hi lr b fi lw lx l ly lz">from sklearn.naive_bayes import GaussianNB<br/>model = GaussianNB()</span></pre><p id="8613" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.k最近邻</p><p id="0262" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了训练支持向量机，我们从“sklearn.neighbors”模块中导入了KNeighborsClassifier。我们考虑了三个最近的邻居。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="524c" class="lv kj hi lr b fi lw lx l ly lz">from sklearn.neighbors import KNeighborsClassifier<br/>model = KNeighborsClassifier(n_neighbors=3)</span></pre><p id="e95c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">脚本:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="3475" class="lv kj hi lr b fi lw lx l ly lz">from sklearn import svm<br/>from sklearn.linear_model import Perceptron<br/>from sklearn.naive_bayes import GaussianNB<br/>from sklearn.neighbors import KNeighborsClassifier<br/># Loading Algorithm in model<br/>model = svm.SVC()<br/>#model = Perceptron()<br/>#model = KNeighborsClassifier(n_neighbors=3)<br/>#model = GaussianNB()</span></pre><p id="03d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，导入算法后，我们可以选择使用哪个模型。代码的其余部分将保持不变。</p><h2 id="396b" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">3.加载数据集</h2><p id="a055" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">导入库后，下一步是将数据集加载到我们的应用程序中。为此，我们使用核心python文件功能打开文件，并使用csv模块的“csv.reader()”函数，该函数读取csv格式的数据集。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="9e1d" class="lv kj hi lr b fi lw lx l ly lz"># Read data from the file<br/>with open("banknotes.csv") as f:<br/>    reader = csv.reader(f)<br/>    next(reader)</span></pre><h2 id="34e2" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">4.将数据集分为要素和标注</h2><p id="edfe" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">在我们的数据集中，方差、偏斜、曲率和熵是特征，而类列包含标签。以下脚本和加载部分将数据分为要素和标注集。然后将特征和标签存储到列表data = []</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="1d99" class="lv kj hi lr b fi lw lx l ly lz">#Read data from csv file<br/>with open("banknotes.csv") as f:<br/>    reader = csv.reader(f)</span><span id="73f6" class="lv kj hi lr b fi ma lx l ly lz">    next(reader)</span><span id="2352" class="lv kj hi lr b fi ma lx l ly lz">    data = []</span><span id="0c55" class="lv kj hi lr b fi ma lx l ly lz">    for row in reader:</span><span id="91b3" class="lv kj hi lr b fi ma lx l ly lz">        data.append({</span><span id="8829" class="lv kj hi lr b fi ma lx l ly lz">            "feature": [float(cell) for cell in row[:4]],</span><span id="ef84" class="lv kj hi lr b fi ma lx l ly lz">            "label": "Authentic" if row[4] == "0" else "Counterfeit"</span><span id="02bc" class="lv kj hi lr b fi ma lx l ly lz">        })</span></pre><p id="5d13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">for循环我们要从数据集中过滤的索引，在“feature”:[float(cell)for cell in row[:4]]行中，我们过滤了包含我们的特征集的第0列到第3列。在“label”中:“Authentic”if row[4]= =“0”else“fake”，我们只过滤了包含标签(class)的第四列中的记录。其中，如果标签为0，则该纸币是真实的/真的，而当标签为0时，该纸币是伪造的/假的。</p><h2 id="3fe6" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">5.将数据集分成训练组和测试组</h2><p id="097a" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">训练集用于训练机器学习算法，而测试集用于评估机器学习算法的性能。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="3d4b" class="lv kj hi lr b fi lw lx l ly lz"># Separate data into training and testing groups<br/>holdout = int(0.40 * len(data))<br/>random.shuffle(data)<br/>testing = data[:holdout]<br/>training = data[holdout:]</span></pre><p id="b936" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们在holdout = int(0.40 * len(data))中计算数据列表的长度，并使用random.shuffle(data)中random模块的random.shuffle()函数对数据元素进行混排，以获得更好的性能</p><p id="d0eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们在测试组中存储40%的数据，在训练组中存储60%的数据。</p><h2 id="cc5d" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">6.在训练集上训练模型</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="07ad" class="lv kj hi lr b fi lw lx l ly lz"># Train model on the training set<br/>X_training = [row["feature"] for row in training]<br/>y_training = [row["label"] for row in training]<br/>model.fit(X_training, y_training)</span></pre><p id="bbbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">训练特征集存储为x _ training，而训练标签集存储为y_training，然后传递给“fit()”方法。</p><h2 id="0489" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">7.在测试集上测试模型</h2><p id="7e5c" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">训练完算法后，我们对测试集进行了预测。为了进行预测，使用了“predict()”方法。要预测的记录作为参数传递给“predict()”方法，如下所示:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="26bb" class="lv kj hi lr b fi lw lx l ly lz"># Make predictions on the testing set<br/>X_testing = [row["evidence"] for row in testing]<br/>y_testing = [row["label"] for row in testing]<br/>predictions = model.predict(X_testing)</span></pre><h2 id="7e04" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">8.评估模型性能</h2><p id="8255" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们通过简单的python代码评估了模型的性能:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="b2df" class="lv kj hi lr b fi lw lx l ly lz"># Compute how well we performed</span><span id="b80c" class="lv kj hi lr b fi ma lx l ly lz">correct = 0</span><span id="5b44" class="lv kj hi lr b fi ma lx l ly lz">incorrect = 0</span><span id="71e5" class="lv kj hi lr b fi ma lx l ly lz">total = 0</span><span id="38d1" class="lv kj hi lr b fi ma lx l ly lz">for actual, predicted in zip(y_testing, predictions):</span><span id="568e" class="lv kj hi lr b fi ma lx l ly lz">    total += 1</span><span id="3d23" class="lv kj hi lr b fi ma lx l ly lz">    if actual == predicted:</span><span id="973b" class="lv kj hi lr b fi ma lx l ly lz">        correct += 1</span><span id="9e9b" class="lv kj hi lr b fi ma lx l ly lz">    else:</span><span id="7321" class="lv kj hi lr b fi ma lx l ly lz">        incorrect += 1</span></pre><h2 id="3618" class="lv kj hi bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">9.模型的打印精度</h2><p id="a3fb" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">最后，打印出模型的准确性，以便更好的理解</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="1d9c" class="lv kj hi lr b fi lw lx l ly lz"># Print results<br/>print(f"Results for model {type(model).__name__}")<br/>print(f"Correct: {correct}")<br/>print(f"Incorrect: {incorrect}")<br/>print(f"Accuracy: {100 * correct / total:.2f}%")</span></pre><h1 id="7e6a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="eab8" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">钞票鉴别是一项重要的任务。很难人工检测假钞。机器学习算法可以在这方面提供帮助。在本文中，我们解释了如何使用机器学习技术解决钞票认证问题。我们比较了四种不同算法的性能，并得出结论，KNN和SVM算法是用于钞票认证的最佳算法，准确率为100%和99.45%。</p><p id="9566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，您可以自己建立一个模型来对相似的数据集进行分类(例如，癌症肿瘤细胞分类、药物分类、情感分析等)...)通过实现上面给出的相同/稍微修改的代码片段。这是由Nuruzzaman Faruqui Sir在孟加拉国达卡城市大学进行的“CSE 418:人工智能实验室”课程的一个简单易行的实现。孟加拉国最好的AI课程是哪个？</p><p id="d110" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以从这里随意复制代码或您的项目的一些其他结论。</p></div></div>    
</body>
</html>
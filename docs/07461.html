<html>
<head>
<title>Face Detection in Unity using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV的Unity人脸检测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/face-detection-in-unity-using-opencv-2df17a9e8ecd?source=collection_archive---------8-----------------------#2021-09-19">https://medium.com/geekculture/face-detection-in-unity-using-opencv-2df17a9e8ecd?source=collection_archive---------8-----------------------#2021-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5fc19308f843d98b1d442e2a52446d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KtJwQpHudUAwDvrPg8n-g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image by <a class="ae iu" href="https://pixabay.com/users/tumisu-148124/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5946820" rel="noopener ugc nofollow" target="_blank">Tumisu</a> from <a class="ae iu" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5946820" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="fca4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人脸检测是使用算法在图像中识别人脸的过程。有很多这样的算法，OpenCV中提供的“Haar cascades”算法是一种广泛使用的技术。</p><p id="04eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将开发一个可以在Android上运行的人脸检测的Unity应用程序。</p><p id="a502" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们将这些步骤分成两个主要部分:</p><ol class=""><li id="352f" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">安装</li><li id="db3c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">编码</li></ol><h2 id="8e9e" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated"><strong class="ak">设置</strong></h2><p id="1301" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在开始实现代码之前，我们需要设置一些东西。</p><ol class=""><li id="7262" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">首先，让我们创建一个Unity项目，并向UI画布添加一个RawImage。我已经将游戏窗口中的画布大小从自由纵横比更改为4:3，并调整了RawImage的大小。设置应该如下所示:</li></ol><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/f7724d6d2f49efc2a365d3c716728b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6GiEGQDECp573vjwGAf6w.jpeg"/></div></div></figure><ol class=""><li id="1a12" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">接下来，我们需要将OpenCV导入到我们的项目中。</li></ol><p id="da4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该资产可在以下位置找到:</p><p id="e892" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://assetstore.unity.com/packages/tools/integration/opencv-for-unity-21088" rel="noopener ugc nofollow" target="_blank">OpenCV for Unity | Integration | Unity Asset Store</a>。</p><p id="786e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.接下来，我们需要将“Haar scade _ front alface _ default . XML”包含到我们的项目中。为此，先将<a class="ae iu" href="https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_default.xml" rel="noopener ugc nofollow" target="_blank">中的<strong class="ix hj">文件下载到</strong>中的</a>。然后在Unity项目的Assets文件夹中创建一个名为“StreamingAssets”的文件夹，并将上述xml文件包含在该文件夹中。</p><p id="b459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lm">提示:</em> <a class="ae iu" href="https://github.com/opencv/opencv/tree/master/data" rel="noopener ugc nofollow" target="_blank"> <em class="lm"> OpenCV github资源库</em> </a> <em class="lm">中为人脸检测算法提供了其他几种预训练的分类算法。你也可以试试。</em></p><p id="e9aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.接下来，让我们创建一个C#脚本并将其命名为“FaceDetection.cs ”,然后在Visual Studio或您首选的IDE中打开它。</p><p id="b51c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们已经完成了开始编码所需的配置设置。让我们继续下一部分。</p><h2 id="059e" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">2.编码</h2><p id="1025" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">首先，我们需要导入以下包:</p><pre class="li lj lk ll fd ln lo lp lq aw lr bi"><span id="2af0" class="kh ki hi lo b fi ls lt l lu lv">using OpenCVForUnity.CoreModule;<br/>using OpenCVForUnity.ImgprocModule;<br/>using OpenCVForUnity.ObjdetectModule;<br/>using OpenCVForUnity.UnityUtils;<br/>using UnityEngine;<br/>using UnityEngine.UI;</span></pre><p id="0472" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要用于WebCamTexture的变量和用于存储xml文件名的变量，一个用于加载xml数据的“CascadeClassfier”变量，一个用于存储提取的人脸的“MatOfRect”变量，一个用于将检测到的人脸渲染到RawImage的“Texture2D”变量，以及两个用于存储rgb帧和灰度帧的mat。让我们按如下方式创建这些成员变量:</p><pre class="li lj lk ll fd ln lo lp lq aw lr bi"><span id="889e" class="kh ki hi lo b fi ls lt l lu lv">private WebCamTexture webcamTexture;<br/>private string filename;<br/>private CascadeClassifier cascade;<br/>private MatOfRect faces;<br/>private Texture2D texture;<br/>private Mat rgbaMat;<br/>private Mat grayMat;</span></pre><p id="e383" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们创建一个函数来初始化上述变量。注意，我们将把这个脚本添加到UI中的RawImage。因此，我们可以从代码中直接访问RawImage。因此，首先，我们获得RawImage的RectTransform组件，并且我们将根据WebCamTexture的旋转来旋转RawImage。这样做是因为在Android设备上，相机馈送是旋转的。接下来，我们将把xml文件数据加载到级联变量中，并初始化其他变量，如下所示:</p><pre class="li lj lk ll fd ln lo lp lq aw lr bi"><span id="bfd9" class="kh ki hi lo b fi ls lt l lu lv">void initializeData()<br/>{<br/> //rotate RawImage according to rotation of webcamtexture<br/> this.GetComponent&lt;RectTransform&gt;().Rotate(new Vector3(0, 0, 360 - webcamTexture.videoRotationAngle));</span><span id="a701" class="kh ki hi lo b fi lw lt l lu lv">//store name of xml file<br/> filename = "haarcascade_frontalface_default.xml";</span><span id="8ed8" class="kh ki hi lo b fi lw lt l lu lv"> //initaliaze cascade classifier<br/> cascade = new CascadeClassifier();</span><span id="7505" class="kh ki hi lo b fi lw lt l lu lv"> //load the xml file data<br/> cascade.load(Utils.getFilePath(filename));</span><span id="e6b3" class="kh ki hi lo b fi lw lt l lu lv"> //initalize faces matofrect<br/> faces = new MatOfRect();</span><span id="1f63" class="kh ki hi lo b fi lw lt l lu lv">//initialize rgb and gray Mats<br/> rgbaMat = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/> grayMat = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/> <br/> //initialize texture2d<br/> texture = new Texture2D(rgbaMat.cols(), rgbaMat.rows(), TextureFormat.RGBA32, false);<br/>}</span></pre><p id="33ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要获得可用的相机设备，初始化WebCamTexture并调用上面的' initializeData()'函数。让我们在“Start()”方法中实现这一点。</p><pre class="li lj lk ll fd ln lo lp lq aw lr bi"><span id="33aa" class="kh ki hi lo b fi ls lt l lu lv">void Start()<br/>{<br/> //obtain cameras avialable<br/> WebCamDevice[] cam_devices = WebCamTexture.devices;</span><span id="167b" class="kh ki hi lo b fi lw lt l lu lv"> //create camera texture<br/> webcamTexture = new WebCamTexture(cam_devices[0].name, 480, 640, 30);</span><span id="7ec5" class="kh ki hi lo b fi lw lt l lu lv"> //start camera<br/> webcamTexture.Play();</span><span id="12ca" class="kh ki hi lo b fi lw lt l lu lv"> // initialize members;<br/> initializeData();<br/>}</span></pre><p id="7754" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要对相机馈送的每一帧执行面部检测。为此，我们可以使用“Update()”方法，该方法在应用程序运行时每帧执行一次。</p><p id="8dc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要将webcamTexture转换为Mat。为此，我们使用OpenCV提供的“Utils.webCamTextureToMat()”方法。接下来，我们使用' Imgproc.cvtColor()'方法将此Mat转换为灰度。之后，我们可以提取使用' cascade.detectMultiScale()'方法检测到的面部，并使用' Imgproc.rectangle()'方法在它们周围绘制矩形。最后，我们可以使用“Utils.fastMatToTexture2D()”方法将这个Mat转换为纹理，并将其呈现为RawImage。让我们看看我们如何能做到这一点。</p><pre class="li lj lk ll fd ln lo lp lq aw lr bi"><span id="20cc" class="kh ki hi lo b fi ls lt l lu lv">void Update()<br/>{<br/> //convert webcamtexture to rgb mat<br/> Utils.webCamTextureToMat(webcamTexture, rgbaMat);</span><span id="0b9f" class="kh ki hi lo b fi lw lt l lu lv"> //convert rgbmat to grayscale<br/> Imgproc.cvtColor(rgbaMat, grayMat, Imgproc.COLOR_RGBA2GRAY);</span><span id="91ec" class="kh ki hi lo b fi lw lt l lu lv"> //extract faces<br/> cascade.detectMultiScale(grayMat, faces, 1.1, 4);</span><span id="dc79" class="kh ki hi lo b fi lw lt l lu lv"> //store faces in array<br/> OpenCVForUnity.CoreModule.Rect[] rects = faces.toArray();</span><span id="e50d" class="kh ki hi lo b fi lw lt l lu lv"> //draw rectangle over all faces<br/> for (int i = 0; i &lt; rects.Length; i++)<br/> {<br/>  Debug.Log("detect faces " + rects[i]);<br/>  Imgproc.rectangle(rgbaMat, new Point(rects[i].x, rects[i].y), new Point(rects[i].x + rects[i].width, rects[i].y + rects[i].height), new Scalar(255, 0, 0, 255), 2);<br/> }</span><span id="2eb1" class="kh ki hi lo b fi lw lt l lu lv">//convert rgb mat back to texture<br/> Utils.fastMatToTexture2D(rgbaMat, texture);<br/> <br/> //set rawimage texture<br/> this.GetComponent&lt;RawImage&gt;().texture = texture;<br/>}</span></pre><p id="9c23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们也完成了编码部分。现在您所要做的就是将这个脚本作为一个组件附加到RawImage上，并运行应用程序。</p><p id="afda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我的结果:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/163263db5581d787d3cb5cc7dd0af976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*5T2cbCn6HvpzE2RKixMdXQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image used - <a class="ae iu" href="https://pixabay.com/photos/friend-student-graduate-young-2727305/" rel="noopener ugc nofollow" target="_blank">Friend Student Graduate — Free photo on Pixabay</a></figcaption></figure><p id="d885" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(我已经用手机向网络摄像头显示了来自<a class="ae iu" href="https://pixabay.com/photos/friend-student-graduate-young-2727305/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>的图像，这样就可以看到检测到的多张脸)。</p><p id="f8c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，要从这个应用程序中创建一个Android应用程序，从播放器设置中切换到Android平台，根据需要调整原始图像的大小，然后构建并运行这个应用程序。</p><p id="3678" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我的结果:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/1d58f96b56c8b56fc2b91bbc8ad1af6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*HBYp4sc4PbE9XCEoAOCjrQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image Used — <a class="ae iu" href="https://pixabay.com/photos/woman-fashion-beauty-glamour-1274056/" rel="noopener ugc nofollow" target="_blank">Woman Fashion Beauty — Free photo on Pixabay</a></figcaption></figure><p id="69ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个项目到此为止。请让我知道你的反馈。谢谢大家！干杯！😀</p><h1 id="3d49" class="lz ki hi bd kj ma mb mc kn md me mf kr mg mh mi ku mj mk ml kx mm mn mo la mp bi translated">参考</h1><p id="c1e1" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated"><a class="ae iu" href="https://github.com/EnoxSoftware/OpenCVForUnity/blob/master/Assets/OpenCVForUnity/Examples/MainModules/objdetect/FaceDetectionExample/FaceDetectionWebCamTextureExample.cs" rel="noopener ugc nofollow" target="_blank">主enox software/OpenCVForUnity GitHub上的OpenCVForUnity/facetectionwebcamtextureexample . cs</a></p><p id="29cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://towardsdatascience.com/face-detection-in-2-minutes-using-opencv-python-90f89d7c0f81" rel="noopener" target="_blank">使用OpenCV &amp; Python在2分钟内进行人脸检测| Adarsh Menon |走向数据科学</a></p></div></div>    
</body>
</html>
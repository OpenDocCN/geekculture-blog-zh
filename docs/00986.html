<html>
<head>
<title>How to Set Up Continuous Integration for Monorepo Using Buildkite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Buildkite为Monorepo设置持续集成</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/set-up-continuous-integration-for-monorepo-using-buildkite-61539bb0ed76?source=collection_archive---------4-----------------------#2021-03-23">https://medium.com/geekculture/set-up-continuous-integration-for-monorepo-using-buildkite-61539bb0ed76?source=collection_archive---------4-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5c556108040b4e03a2553c3f1d6236c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1RrQ2QHL6taF4AVCy560Q.jpeg"/></div></div></figure><p id="7a1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Monorepo是一个单一的存储库，它将所有代码和多个项目保存在一个单一的git存储库中。Monorepo设置非常吸引人，因为它具有在一个存储库中管理各种服务和前端的灵活性和能力。它还消除了跟踪多个存储库中的变更以及随着项目变更更新依赖关系的麻烦。</p><p id="d76a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，monorepo也面临着挑战，特别是在持续集成方面。当monorepo中的单个子项目发生变化时，我们需要确定哪些子项目发生了变化，以构建和部署发生变化的子项目。这篇文章一步一步地介绍了:</p><ol class=""><li id="567c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">在Bulidkite中为monorepo配置持续集成。</li><li id="e2fb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用自动伸缩将Buildkite代理部署到AWS EC2实例。</li><li id="7044" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">配置Github以触发Bulidkite CI管道。</li><li id="0d3a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">配置Buildkite，以便在monorepo中的子项目发生变化时触发适当的管道。</li><li id="1c65" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用bash脚本自动完成以上所有工作。</li></ol><h1 id="61ad" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">先决条件</h1><ol class=""><li id="ee96" class="jo jp hi is b it la ix lb jb lc jf ld jj le jn jt ju jv jw bi translated"><a class="ae lf" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> AWS </strong> </a> <strong class="is hj"> </strong>账号部署Buildkite代理。</li><li id="7252" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">配置<a class="ae lf" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> AWS CLI </strong> </a>与AWS账户对话。</li><li id="740c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lf" href="https://buildkite.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Buildkite </strong> </a>账号创建持续集成管道。</li><li id="2e8c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lf" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Github</strong></a><strong class="is hj"/>账号托管monorepo源代码。</li></ol><p id="5a13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的源代码可以在Github的<a class="ae lf" href="https://github.com/adikari/buildkite-monorepo" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">build kite-mono repo</strong></a>中找到。</p><h1 id="cc0a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置概述</h1><p id="a269" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">Buildkite工作流程由<a class="ae lf" href="https://buildkite.com/docs/pipelines" rel="noopener ugc nofollow" target="_blank">管道</a>和步骤组成。用于建模和定义工作流的顶级容器称为管道。步骤运行单个任务或命令。</p><p id="a87d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图列出了我们正在设置的管道、它们的相关触发器以及管道运行的每个步骤。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/06dac0a48da9e28eba0833ef10b2faff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVE8-HVD6JRbADm-MTuIwQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Pipeline and triggers</figcaption></figure><h1 id="c46c" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">拉式请求工作流</h1><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/f574719917a429e674bfbbe999afcc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1AF2ysOAF-Dk3ARQbi6Yw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Pull Request Workflow</figcaption></figure><p id="6b24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图显示了拉请求管道的工作流。在Github中创建新的Pull请求会触发Buildkite中的<code class="du lt lu lv lw b">pull-request</code>管道。然后这个管道运行<code class="du lt lu lv lw b">git diff</code>来识别monorepo中的哪些文件夹(项目)发生了变化。如果它检测到变化，那么它将动态地触发为该项目定义的适当的拉请求管道。Buildkite向<a class="ae lf" href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-status-checks" rel="noopener ugc nofollow" target="_blank"> Github状态检查报告每个管道的状态。</a></p><h1 id="35be" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">合并工作流</h1><p id="c9c4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">当Github中的所有状态检查都通过时，Pull请求被合并。合并拉请求会触发Buildkite中的<code class="du lt lu lv lw b">merge</code>管道。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/cebc7e45c51264d3f544e514e5649a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbDiLQYy82JnKHuLZdouVA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Merge Workflow</figcaption></figure><p id="6016" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与前面的管道类似，合并管道识别已经变更的项目，并为其触发相应的<code class="du lt lu lv lw b">deploy</code>管道。部署管道最初将更改部署到临时环境中。一旦部署到暂存完成，生产部署将被手动发布。</p><h1 id="29e5" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">最终项目结构</h1><pre class="lk ll lm ln fd ly lw lz ma aw mb bi"><span id="b6bc" class="mc kd hi lw b fi md me l mf mg">.<br/>├── .buildkite<br/>│   ├── diff<br/>│   ├── merge.yml<br/>│   ├── pipelines<br/>│   │   ├── deploy.json<br/>│   │   ├── merge.json<br/>│   │   └── pull-request.json<br/>│   └── pull-request.yml<br/>├── bar-service<br/>│   ├── .buildkite<br/>│   │   ├── deploy.yml<br/>│   │   ├── merge.yml<br/>│   │   └── pull-request.yml<br/>│   └── bin<br/>│       └── deploy<br/>├── bin<br/>│   ├── create-pipeline<br/>│   ├── create-secrets-bucket<br/>│   ├── deploy-ci-stack<br/>│   └── stack-config<br/>└── foo-service<br/>    ├── .buildkite<br/>    │   ├── deploy.yml<br/>    │   ├── merge.yml<br/>    │   └── pull-request.yml<br/>    └── bin<br/>        └── deploy</span></pre><h1 id="b392" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置项目</h1><p id="8bb7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">创建一个新的git项目，并将其推送到Github。在CLI中运行以下命令。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/d627823ca18133859cb6125055da3044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAjfZRH89eWlA7Plt7HaPQ.png"/></div></div></figure><h1 id="803e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置Buildkite基础结构</h1><ol class=""><li id="17a0" class="jo jp hi is b it la ix lb jb lc jf ld jj le jn jt ju jv jw bi translated">创建一个bin目录，其中包含一些可执行脚本。</li></ol><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="200c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.将以下内容复制到<code class="du lt lu lv lw b">create-secrets-bucket</code>中。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Generate SSH Key and copy it to S3 bucket</figcaption></figure><p id="5ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的脚本创建了一个用于存储ssh密钥的S3存储桶。Buildkite使用这个键连接到Github repo。该脚本还生成ssh密钥并正确设置其权限。</p><p id="3ecb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">运行脚本</strong></p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/20fe720c300d714cd651cdcc8444cd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AnXxZJFHjXWK9qZC8k8Cw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">running create-secrets-bucket script</figcaption></figure><p id="1d2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该脚本将生成的公钥和私钥复制到<code class="du lt lu lv lw b">~/.ssh</code>文件夹中。稍后可以使用这些键ssh到EC2实例，运行Buildkite代理进行调试。</p><p id="d564" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，验证存储桶是否存在，以及新的S3存储桶中是否存在密钥。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/10b6db3c57f1cf07bfcc019eda501ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWj3q2x4uMeLmgsAqOzVBQ.png"/></div></div></figure><p id="2360" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导航到<a class="ae lf" href="https://github.com/settings/keys" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/keys</a>，添加新的SSK密钥，然后粘贴<code class="du lt lu lv lw b">id_rsa_buildkite.pub</code>的内容。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/eabbae0285cab36c7052d4909bf0d092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t-9bUdhTIPaLJmOVj1WzA.png"/></div></div></figure><h1 id="01c3" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">部署AWS弹性CI云架构堆栈</h1><p id="e6a9" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">Buildkite的人员已经为AWS   <strong class="is hj">，</strong>创建了<a class="ae lf" href="https://github.com/buildkite/elastic-ci-stack-for-aws" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">弹性CI堆栈，它在AWS中创建了一个私有的、自动伸缩的Buildkite代理集群。让我们将基础设施部署到我们的AWS客户。</strong></a></p><p id="e1dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个新文件<code class="du lt lu lv lw b">bin/deploy-ci-stack</code>并将下面的脚本内容复制到其中。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="174b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以从BUILDKITE控制台的<strong class="is hj">代理</strong>选项卡中获取“BUILDKITE_AGENT_TOKEN”。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/8911dd7e18aa8e74d9da6a64a3568810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bP_WOPCOK3iJ6NNLPYQBOA.png"/></div></div></figure><p id="e0ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，创建一个名为<code class="du lt lu lv lw b">bin/stack-config</code>的新文件。该文件中的配置会覆盖Cloudformation参数。弹性CI使用的<a class="ae lf" href="https://s3.amazonaws.com/buildkite-aws-stack/latest/aws-stack.yml" rel="noopener ugc nofollow" target="_blank"> Cloudformation模板</a>中提供了完整的参数列表。</p><p id="caf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第2行，用之前创建的存储桶替换存储桶名称。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="7613" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在CLI中运行脚本来部署Cloudformation堆栈。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f27e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">脚本需要一些时间来完成。打开AWS Cloudformation控制台查看进度。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/17b11943610b6ea356b2f7f42d7da24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17sQafKmHFsNhZ_0T9IhJw.png"/></div></div></figure><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/410abaa7204bba0a80d0f7b022beb7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ygh4ZA04-SZYN0WZOqNPg.png"/></div></div></figure><p id="755e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cloudformation堆栈将创建一个自动缩放组，Buildkite将使用它来生成EC2实例。Buildkite代理和构建在那些EC2实例中运行。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/74b11e1e2a261df759eae8fb7036e00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4eC59PoA52X2nhaOArQUw.png"/></div></div></figure><h1 id="14a8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在Bulidkite中创建构建管道</h1><p id="2d9b" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">此时，我们已经有了运行Buildkite所需的基础设施。接下来，我们配置Buildkite并创建一些管道。</p><p id="44d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae lf" href="https://buildkite.com/user/api-access-tokens" rel="noopener ugc nofollow" target="_blank">https://buildkite.com/user/api-access-tokens</a>创建API访问令牌，并将范围设置为<code class="du lt lu lv lw b">write_builds</code>、<code class="du lt lu lv lw b">read_pipelines</code>和<code class="du lt lu lv lw b">write_pipelines</code>。关于代理令牌的更多信息在本<a class="ae lf" href="https://buildkite.com/docs/agent/v3/tokens" rel="noopener ugc nofollow" target="_blank">文档</a>中。</p><p id="03c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保<code class="du lt lu lv lw b">BUILDKITE_API_TOKEN</code>设置在环境上。在运行脚本之前，要么使用<a class="ae lf" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>要么将其导出到环境中。</p><p id="2707" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下脚本的内容复制到<code class="du lt lu lv lw b">bin/create-pipeline</code>。可以在Buildkite控制台中手动创建管道，但是自动化和创建可复制的基础设施总是更好。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="525a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过设置正确的权限(chmod +x)使脚本可执行。在CLI中运行<code class="du lt lu lv lw b">./bin/create-pipeline -h</code>获得帮助。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/00d60268bd46c983838e6bd9cfc44b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_oJvruTvg2OYFDR4R3JMg.png"/></div></div></figure><p id="054e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该脚本使用<a class="ae lf" href="https://buildkite.com/docs/apis/rest-api" rel="noopener ugc nofollow" target="_blank"> Buildkite REST API </a>来创建具有给定配置的管道。该脚本使用定义为<code class="du lt lu lv lw b">json</code>文档的管道配置，并将其发布到REST API。管道配置位于<code class="du lt lu lv lw b">.bulidkite/pipelines</code>文件夹中。</p><p id="cbf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要定义<code class="du lt lu lv lw b">pull-request</code>管道的配置，使用以下内容创建<code class="du lt lu lv lw b">.buildkite/pipelines/pull-request.json</code>。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="af13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，用下面的内容创建<code class="du lt lu lv lw b">./buildkite/pipelines/merge.json</code>。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="da6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，用下面的内容创建<code class="du lt lu lv lw b">.buildkite/pipelines/deploy.yml</code>。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a718" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，运行<code class="du lt lu lv lw b">./bin/create-pipeline</code>命令来创建一个拉请求管道。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/93fd4d145e433bff7956d04e7b319969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBqJv_WCmt3jl5V2jIOk3A.png"/></div></div></figure><p id="a666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从控制台输出中复制<code class="du lt lu lv lw b">Webhook url</code>并在Github中创建一个webhook集成。如果将来需要，可以在Buildkite控制台的pipeline设置中找到webhook URL。我们只需要为<code class="du lt lu lv lw b">pull-request</code>和<code class="du lt lu lv lw b">merge</code>管道配置webhook。所有其他管道都是动态触发的。</p><p id="8acf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导航到Github库<code class="du lt lu lv lw b">Settings &gt; Webhooks</code>并添加一个webhook。选择<code class="du lt lu lv lw b">Just the push event</code>然后添加webhook。对两条管线重复此操作。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/47775406b216186cab6f1b8d9da36850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBPAb0ZYFzR6RqAFhCtz-g.png"/></div></div></figure><p id="de72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在在Buildkite控制台中，应该有两条新创建的管道。🎉</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/b885b785394e77c3ee3dc07068804581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZFMo8T41CwARMnMrN4gDg.png"/></div></div></figure><p id="c833" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，添加Github集成，允许Buildkite向Github发送状态更新。每个帐户只需设置一次集成。它位于Buildkite控制台的<code class="du lt lu lv lw b">Setting &gt; Integrations &gt; Github</code>处。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/bddc05c818f8a7905a996afcf95a9042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5Zd8jSdA0NRhrGIrCjCCQ.png"/></div></div></figure><p id="ee2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，创建剩余的管道。这些管道将由<code class="du lt lu lv lw b">pull-request</code>和<code class="du lt lu lv lw b">merge</code>管道动态触发，因此我们不需要创建Github集成。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/9dfd4e07b54fc07d6328794291481a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9syIVilPFQaTNaP16BmUw.png"/></div></div></figure><p id="edd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Buildkite控制台现在应该列出了所有的管道。🥳</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/be2cfc92155be8b056e5ac792d91d2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rclucX7ddwlU4ou0vAFX0g.png"/></div></div></figure><h1 id="5773" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置构建风筝的步骤</h1><p id="a129" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">现在，管道已经准备好了，为每个管道配置要运行的步骤。</p><p id="aa99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lt lu lv lw b">.buildkite/diff</code>中添加以下脚本。该脚本区分针对主分支的提交中更改的所有文件。脚本的输出用于动态触发相应的管道。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f409" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更改脚本的权限，使其可执行。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="aef5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个新文件<code class="du lt lu lv lw b">.buildkite/pullrequest.yml</code>并添加以下步骤配置。我们使用<a class="ae lf" href="https://github.com/chronotc/monorepo-diff-buildkite-plugin" rel="noopener ugc nofollow" target="_blank">build kite-monorepo-diff</a>插件来运行<code class="du lt lu lv lw b">diff</code>脚本，并自动上传和触发各自的管道。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="c93d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，通过在<code class="du lt lu lv lw b">.buildkite/merge.yml</code>中添加以下内容来创建合并管道的配置。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="af96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们已经配置了最顶层的<code class="du lt lu lv lw b">pull-request</code>和<code class="du lt lu lv lw b">merge</code>管道。现在我们需要为每个服务配置单独的管道。</p><p id="7134" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先为<code class="du lt lu lv lw b">foo-service</code>配置管道。用以下内容创建<code class="du lt lu lv lw b">foo-service/.buildkite/pull-request.yml</code>。当foo服务的<code class="du lt lu lv lw b">pull-request</code>管道运行时，指定<code class="du lt lu lv lw b">lint</code>和<code class="du lt lu lv lw b">test</code>命令运行。<code class="du lt lu lv lw b">command</code>选项也可以触发其他脚本。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="50ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，通过在<code class="du lt lu lv lw b">foo-service/.buildkite/merge.yml</code>中添加以下内容，为foo服务设置合并管道。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="66b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当<code class="du lt lu lv lw b">foo-service-merge</code>管道运行时，会发生以下情况:</p><ol class=""><li id="2e73" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">管道运行健全性检查。</li><li id="12fe" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">然后<code class="du lt lu lv lw b">foo-deploy</code>流水线被动态触发。我们通过<code class="du lt lu lv lw b">STAGE</code>环境来识别运行部署的环境。</li><li id="8553" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">一旦部署到登台完成，管道将被阻塞，并且不会自动触发后续管道。按下“发布到生产”按钮，可以恢复流水线。</li><li id="d499" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">解除管道阻塞再次触发<code class="du lt lu lv lw b">foo-deploy</code>管道，但这一次使用<code class="du lt lu lv lw b">production</code>阶段。</li></ol><p id="ffdc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，通过添加<code class="du lt lu lv lw b">foo-service/.buildkite/deploy.yml</code>为<code class="du lt lu lv lw b">foo-deploy</code>管道添加配置。在部署配置中，我们触发一个bash脚本并传递从<code class="du lt lu lv lw b">foo-service-merge</code>管道接收的<code class="du lt lu lv lw b">STAGE</code>变量。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="6795" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，创建部署脚本<code class="du lt lu lv lw b">foo-service/bin/deploy</code>并添加以下内容。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="02ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使部署脚本可执行。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="50ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lt lu lv lw b">foo-service</code>的流水线和步骤配置完成。重复上述所有步骤，为<code class="du lt lu lv lw b">bar service</code>配置管线。</p><h1 id="97ce" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">测试整体工作流程</h1><p id="927c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我们已经配置了Buildkite、Github，并建立了适当的基础设施来运行构建。接下来，测试整个工作流并观察它的运行。</p><p id="778d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试工作流程，首先创建一个新的分支，并修改<code class="du lt lu lv lw b">foo-service</code>中的一些文件。将更改推送到Github并创建一个拉请求。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/910cbb280beb5512797e1669a750c222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08wpUhllksniN7J5NSy6IA.png"/></div></div></figure><p id="65d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将更改推送到Github应该会触发Buildkite中的<code class="du lt lu lv lw b">pull-request</code>管道，然后触发<code class="du lt lu lv lw b">foo-service-pull-request</code>管道。Github应该在Github检查中报告状态。可以启用Github分支保护，要求在合并Pull请求之前通过检查。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/9b187f6b87ad454321b7f833bae5c1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ivvcpqm5DGgXzbbcKPy21A.png"/></div></div></figure><p id="2125" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦Github中的所有检查都通过了，就合并Pull请求。这个合并将触发Buildkite中的<code class="du lt lu lv lw b">merge</code>管道。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/02a1d6de115f9a062cd5542d5349d1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ1BwAc86_jpxveapADxmQ.png"/></div></div></figure><p id="2263" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检测到foo服务的变化，触发<code class="du lt lu lv lw b">foo-service-merge</code>流水线。当<code class="du lt lu lv lw b">foo-service-deploy</code>在登台环境中运行时，管道最终会被阻塞。通过手动单击<code class="du lt lu lv lw b">Release to Production</code>按钮来针对生产运行部署，从而解除管道阻塞。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/ad3aaf763f8c859801d5f95138b99b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7jOA9XxK62V-vpxWkn1zA.png"/></div></div></figure><h1 id="37cf" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">摘要</h1><p id="d9bc" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在本文中，我们使用Buildkite、Github和AWS为monorepo建立了一个持续集成管道。管道将我们的代码从开发机器转移到登台，然后转移到生产。构建代理和步骤在自动缩放的AWS EC2实例中运行。我们还创建了一系列bash脚本来创建这种设置的易于复制的版本。作为对当前设计的改进，考虑使用<a class="ae lf" href="https://github.com/buildkite-plugins/docker-compose-buildkite-plugin" rel="noopener ugc nofollow" target="_blank">build kite-docker-compose-plugin</a>来隔离Docker容器中的构建。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="87b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ne">在</em><a class="ae lf" href="https://twitter.com/adikari" rel="noopener ugc nofollow" target="_blank"><em class="ne">Twitter</em></a><em class="ne">上关注我或者在</em><a class="ae lf" href="https://github.com/adikari" rel="noopener ugc nofollow" target="_blank"><em class="ne">Github</em></a><em class="ne">上查看我的项目。</em></p></div></div>    
</body>
</html>
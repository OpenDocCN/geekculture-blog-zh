<html>
<head>
<title>Angular:Using SwitchMap operator with @HostListener in a Directive that is reusable across multiple components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:在可跨多个组件重用的指令中使用带有@HostListener的SwitchMap运算符</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-using-switchmap-operator-with-hostlistener-in-a-directive-that-is-reusable-across-multiple-7d014b6f80c6?source=collection_archive---------5-----------------------#2022-01-10">https://medium.com/geekculture/angular-using-switchmap-operator-with-hostlistener-in-a-directive-that-is-reusable-across-multiple-7d014b6f80c6?source=collection_archive---------5-----------------------#2022-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直认为switchMap是RXJS在搜索或过滤操作等场景中提供的最有用的扁平化操作符之一，在这些场景中，用户会非常快速地改变要搜索的数据。</p><p id="f617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每个场景中，用户的一个<strong class="ih hj"> keyup事件或一个变化事件</strong>触发搜索或过滤过程。指令对于事件处理来说是最理想的，因为angular负责清理过程，我们真的不必担心删除事件侦听器。</p><p id="67f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是我们的目标:</p><ol class=""><li id="7cdc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">在AppComponent中创建两个子组件:<strong class="ih hj">子组件</strong>和<strong class="ih hj">子组件</strong>。正如你在下面的截图中看到的，这两个组件都是通过点击按钮来加载的。</li></ol><p id="bbe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前一个组件将包含一个应用了指令<strong class="ih hj"> EventDirective </strong>的<strong class="ih hj">文本框</strong>，以演示如何使用<strong class="ih hj"> switchMap操作符和@HostListener </strong>进行优化的搜索操作。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/e9273e316a009d7a70ace177e3a38ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6Q3Jk_1mH4192Du6L-4cA.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx">ChildComponent</figcaption></figure><p id="efd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们将显示作为Http请求的一部分发送的<strong class="ih hj">最终搜索文本</strong>,或者用于消息中的任何其他操作，如下所示。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/ad3e223befc1d10c9d8ccef31179f6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChJkjHNMg_wyaece4gvJ8w.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx">Search Text displayed</figcaption></figure><p id="1b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj"> ChildBComponent </strong>的目的纯粹是为了演示当我从ChildAComponent切换到ChildBComponent时，即当ChildComponent被销毁时，在<strong class="ih hj"> EventDirective </strong>中订阅的<strong class="ih hj"> observable </strong>将如何取消订阅。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/f7cafaceb42ab046225da911119f25a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRQFVWtwBtRprSoKTi_X4w.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx">ChildComponentB</figcaption></figure><p id="ef75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从<strong class="ih hj">子组件模板开始。</strong>该模板包含一个文本框，其中应用了一个指令<strong class="ih hj">event directive(app event)</strong>和一个&lt; p &gt;标签，该标签显示了<strong class="ih hj"> final </strong> <strong class="ih hj">搜索词</strong>，该搜索词将用于进一步操作或作为http请求的一部分发送到服务器。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="7839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">子组件类:</strong></p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="ke kf l"/></div></figure><ol class=""><li id="5861" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">消息属性是包含两个属性的对象:<strong class="ih hj">状态</strong>和<strong class="ih hj">结果</strong>。<strong class="ih hj">结果属性</strong>包含从<strong class="ih hj"> EventDirective </strong>接收的最终搜索词。根据指令中执行的优化操作的结果，状态属性可以包含字符串“成功”或“危险”。我们很快就会看到这是如何发生的。</li><li id="3dd0" class="jd je hi ih b ii kg im kh iq ki iu kj iy kk jc ji jj jk jl bi translated"><strong class="ih hj"> showAlert() </strong>在EventDirective通过<strong class="ih hj"> @Output </strong>向ChildComponent发回最终搜索词时触发。该方法为<strong class="ih hj">消息属性</strong>赋值，以便在模板上显示。在这个方法中，我们可以使用最终的搜索词来进一步操作它，或者将它作为Http请求的一部分来发送，以获取搜索结果。</li></ol><p id="c132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> EventDirective类:</strong>该指令将包含整个优化逻辑，以便在需要时可以多次重用。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="ke kf l"/></div></figure><ol class=""><li id="3a9d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">让我们从<strong class="ih hj">ngOnInit()</strong>lifecycle钩子开始。</li></ol><p id="6ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服务</strong>是对<strong class="ih hj">测试服务</strong>的引用，它定义了<strong class="ih hj">主题sub </strong>。</p><pre class="jn jo jp jq fd kl km kn ko aw kp bi"><span id="6c80" class="kq kr hi km b fi ks kt l ku kv">@Injectable()<br/>export class <strong class="km hj">TestService </strong>{<br/>constructor() {}<br/><strong class="km hj">public sub = new Subject&lt;any&gt;();</strong><br/>}</span></pre><p id="c80a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经在EventDirective内订阅了这个sub<strong class="ih hj">sub</strong>。在实际订阅发生之前，我们执行3个操作。让我们看看这里到底发生了什么。</p><p id="52ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;当用户按下文本框中的一个键时，触发一个<strong class="ih hj"> keyup </strong>事件。EventDirective中的<strong class="ih hj"> @HostListener() </strong>被配置为监听此类keyup事件，并调用<strong class="ih hj"> onKeyUp() </strong>来处理事件。在这个方法中，我们在subject <strong class="ih hj"> sub </strong>上调用<strong class="ih hj"> next() </strong>，将文本框中输入的文本作为参数传递。</p><p id="e4d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;当调用<strong class="ih hj"> next() </strong>传递作为参数键入的文本时，外部可观察对象<strong class="ih hj">sub asobservable()</strong>发出作为值的键入文本。</p><p id="686e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj">反跳时间操作符延迟外部可观察到的键入文本的发射。</strong>在本例中，它延迟了3秒钟。</p><p id="30c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj"> switchMap </strong>正在将这个文本映射到一个使用()操作符的<strong class="ih hj">创建的内部可观察对象。()操作符</strong>的<strong class="ih hj">的目的仅仅是创建一个与外部可观察对象发出的文本相对应的内部可观察对象。</strong></p><p id="9667" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每3秒执行一次检查，3秒后用户输入的文本使用of()操作符映射到内部可观察对象。用户在这3秒钟内输入的任何文本都将被丢弃。</p><p id="83df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;开关映射也订阅内部可观察值。怎么会？<strong class="ih hj">当外部可观察体发出用户输入的任何新文本时，开关映射取消订阅当前订阅的不完整内部可观察体。</strong>这确保了先前的搜索文本被丢弃，并且仅使用最近的搜索文本。</p><p id="b1bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;如果以上步骤没有错误，一切顺利，我们调用<strong class="ih hj">this . return data({ status:' success '，result:result })</strong>else<strong class="ih hj">this . return data({ status:' error '，result: err }) </strong></p><p id="b9b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果属性</strong>包含最终搜索文本或错误细节，而<strong class="ih hj">状态属性</strong>将包含“成功”或“错误”。</p><p id="1d59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;最后我们还有<strong class="ih hj"> takeUntil() </strong>操作符，它必须是<strong class="ih hj">管道</strong>中的最后一个操作符。该操作符确保外部可观察对象<strong class="ih hj">asobservable()</strong>将一直发出值，直到作为参数传递给takenUntil()的<strong class="ih hj"> stop$ observable </strong>发出一个值。这有助于我们在ChildComponent被销毁时取消订阅外部可观察对象。我们将很快看到什么是stop$以及它如何帮助我们退订。</p><p id="dc4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.在<strong class="ih hj"> returnData() </strong>中，我们使用<strong class="ih hj"> @Output </strong>触发一个事件，将作为参数传递给该方法的对象(包含结果和状态属性)发送给ChildComponent。</p><p id="be0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在让我们转到“退订可观察”部分。我们已经讨论过<strong class="ih hj"> takeUntil </strong>操作员如何帮助退订。现在让我们看看什么是<strong class="ih hj">止损$可观察值</strong>。</p><p id="43c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意EventDirective类扩展了一个父类<strong class="ih hj">UnsubscribeFromObservable</strong>。我们给这个类分配了创建stop$ observable的任务，从stop$ observable发出一个值，最后完成observable。</p><pre class="jn jo jp jq fd kl km kn ko aw kp bi"><span id="a268" class="kq kr hi km b fi ks kt l ku kv">export class EventDirective <strong class="km hj">extends UnsubscribeFromObservable</strong>{<br/><strong class="km hj">constructor(private service: TestService) {<br/>super();<br/>}</strong><br/>//remaining methods<br/>}</span></pre><p id="602b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我点击AppComponent中的<strong class="ih hj"> Load ChildB Component </strong>按钮时，EventDirective中的<strong class="ih hj"> ngOnDestroy() </strong>被调用。在ngOnDestroy()中，我们调用父类<strong class="ih hj">的<strong class="ih hj"> destroy() </strong>。</strong></p><pre class="jn jo jp jq fd kl km kn ko aw kp bi"><span id="2204" class="kq kr hi km b fi ks kt l ku kv"><strong class="km hj">ngOnDestroy() {</strong><br/>console.log(‘ngDestroy() called on EventDirective’);<br/><strong class="km hj">super.destroy();</strong><br/>console.log(this.subs1);<br/>}</span></pre><p id="9950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看在父类的<strong class="ih hj"> destroy() </strong>方法中发生了什么。我们在<strong class="ih hj"> stop$ observable </strong>上调用了<strong class="ih hj"> next() </strong>，以防止EventDirective中的外部可观察对象<strong class="ih hj">sub asobservable()</strong>发出任何进一步的值，最后我们也完成了stop$ observable。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="e0dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个父类也是可重用的，可以用于取消订阅应用程序中任何组件的任何可观察对象。</p><p id="0407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在销毁ChildComponent之前和销毁ChildComponent之后，观察EventDirective 中订阅对象的<strong class="ih hj"> closed属性，确认该可观察对象已经成功退订。</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kw"><img src="../Images/bcd4d2b0f221f87d070e5743c08b6bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iL78qdQfbJTWYfvJc1fYzg.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx">Before the ChildComponent is Destroyed</figcaption></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kw"><img src="../Images/17d4cc84186b9bb84a740320b9568d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJClJX14duuX-n5YuC6omw.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx">After ChildComponent is destroyed</figcaption></figure><p id="b6b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在这里查看整个工作示例。</p><div class="kx ky ez fb kz la"><a href="https://stackblitz.com/edit/angular-5ysnyn?file=src/app/event.directive.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">角形(叉形)堆叠</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">编辑描述</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">stackblitz.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jw la"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Angular Translations: a novel approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度平移:一种新方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-translations-a-novel-approach-2fbeb542b470?source=collection_archive---------29-----------------------#2021-07-27">https://medium.com/geekculture/angular-translations-a-novel-approach-2fbeb542b470?source=collection_archive---------29-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0fc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">对语言文件使用ngx-translate</em></p><h2 id="e8f9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">介绍</h2><p id="6d74" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我一直在研究如何处理翻译，现在，我不得不接受错误的方式…也就是说，在应用程序中管理翻译文件(而不是我认为合适的方式，由第三方CMS支持的API抽象，等等)。).管理应用程序中的翻译意味着开发人员可能需要对翻译、构建、测试等进行修改。等等。—开发周期。管理这些<em class="jd">类型的问题</em>很可能不是您的应用程序的责任。</p><p id="57d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于本文的目的，我分两个阶段，第一个阶段是预先加载翻译，第二个阶段(也是即将到来的阶段)是支持动态语言翻译。)</p><p id="8f1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开发翻译解决方案的过程中，我发现了几个微妙的方面，迫使我提出一个解决方案来处理翻译，与ngx-translate库规定的略有不同。<em class="jd">规定的管理异步加载的翻译的方式</em>是使用<em class="jd">异步</em>管道。</p><p id="7a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种技术将异步地响应变化，而不需要进行任何手工编码。我们遇到的问题主要是设置我们的第三方网格列标题网格— <em class="jd">我们需要在组件中提供翻译，而不是直接在视图中提供</em>。</p><h2 id="06be" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">组件翻译文件</h2><p id="00ea" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我决定为每个组件创建一个翻译文件(并作为原理图的一部分)，我有一个构建脚本，它将<em class="jd">连接</em>所有这些翻译到一个文件中(我的计划是按模块分解它，让每个<em class="jd">懒惰</em>模块<em class="jd">加载</em>处理它们自己的所有翻译，但是为了讨论的缘故，这不是必需的)。</p><blockquote class="ke kf kg"><p id="892e" class="if ig jd ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">用于在整个应用程序中连接语言文件的脚本</p></blockquote><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/76f95c73fa6395460470538399d51bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mAqPFOM8vqa-qvxr"/></div></div></figure><h1 id="fa17" class="kw jf hi bd jg kx ky kz jk la lb lc jo ld le lf jr lg lh li ju lj lk ll jx lm bi translated">问题</h1><p id="079c" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在某些情况下，我们需要通过组件添加翻译，而不是在视图中添加:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ln"><img src="../Images/c1fc198d2a78b2bdca2ba505fc56dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qm_-tI-XabBLJxYDtm0xg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Example of fetching translations via the component — this is <em class="ls">sync</em>, since all is preloaded.</figcaption></figure><p id="fdc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着在组件初始化时，我们需要网格列标题(第三方@grapecity wijmo flexgrid)组件的即时同步翻译。然而，同步方面(使用即时方法)与加载语言文件翻译相冲突，因为它是一个异步过程。<em class="jd">我们如何解决这个问题，而不会因为竞争条件而妨碍我们的翻译输出呢？</em></p><h1 id="2723" class="kw jf hi bd jg kx ky kz jk la lb lc jo ld le lf jr lg lh li ju lj lk ll jx lm bi translated">解决办法</h1><p id="bb7c" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我决定给我们的惰性加载路由添加一个解析器，以便在路由解析之前将所有翻译加载到内存中——在一个<em class="jd">可观察的$cache </em>中。</p><p id="4da3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> TranslationsResolver </strong>将通过<em class="jd"> get </em>进行http调用，并将结果加载到＄cache—<strong class="ih hj"><em class="jd">相关模块中的翻译现在立即可用(通过ngx翻译服务使用即时方法)</em> </strong>。<strong class="ih hj"/></p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lt"><img src="../Images/aca7e0c86341d2fca6bae4d2e6030f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*hhNcp_Ycw5CuP6q_VZ4WTg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Translations resolver will load translation file into memory.</figcaption></figure><p id="5658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个路由解析器，可以根据需要显式地应用于任何惰性加载的模块。它将缓存每个路由解析的翻译。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lu"><img src="../Images/2e1a21b06e04e96ebdc7a14801e9583a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vtVOlutOr4zpBWi8h_v0g.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Add the resolver for the lazy loaded route.</figcaption></figure><h1 id="3273" class="kw jf hi bd jg kx ky kz jk la lb lc jo ld le lf jr lg lh li ju lj lk ll jx lm bi translated">结论</h1><p id="df51" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">现在，您可以在应用程序中使用翻译，而不会受到惩罚——不需要等待或担心将翻译文件加载到内存中的异步过程。您现在可以使用下面的<strong class="ih hj"> <em class="jd">即时</em> </strong>方法，而不用担心翻译不可用。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lv"><img src="../Images/49ae0bfbf936f83a2bbae2eaaa4a6160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUJuzmuGgPMiHv7kjrySIg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Use the instant method to load translation without any async wait time.</figcaption></figure><p id="1f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第2部分:</strong>按需/即时处理语言翻译——根据用户输入指导的语言选择重新绑定新翻译。</p></div></div>    
</body>
</html>
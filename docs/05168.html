<html>
<head>
<title>Implementing HTTP from socket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从套接字实现HTTP</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-http-from-socket-89d20a1f8f43?source=collection_archive---------2-----------------------#2021-07-13">https://medium.com/geekculture/implementing-http-from-socket-89d20a1f8f43?source=collection_archive---------2-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5be6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">利用TCP套接字用Python实现HTTP服务器和客户端</em></p><p id="a450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP代表超文本传输协议。它是一种应用层协议，用于使用浏览器在客户端和服务器之间进行数据通信。我们可以使用套接字来实现HTTP。我们必须根据HTTP规范(<a class="ae je" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" rel="noopener ugc nofollow" target="_blank"> RFC2616 </a>)对消息进行解码/编码，它只是一个文本。在本文中，我们将实现HTTP协议的基础。</p><h2 id="f245" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">HTTP服务器</h2><p id="9a8d" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我们将创建一个TCP套接字。HTTP的默认端口是80。但是我们将使用8080来运行我们的测试。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="98e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用请求模块接收来自自定义HTTP服务器的响应。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="4f81" class="jf jg hi kn b fi kr ks l kt ku">&gt;&gt;&gt; import requests<br/>&gt;&gt;&gt; data = requests.get("<a class="ae je" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a>")<br/>&gt;&gt;&gt; data.status_code<br/>200<br/>&gt;&gt;&gt; data.text<br/>'Hello World'<br/>&gt;&gt;&gt; data.headers<br/>{}</span></pre><p id="949a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在服务器上，您可以看到:</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="d703" class="jf jg hi kn b fi kr ks l kt ku"><em class="jd">GET / HTTP/1.1<br/>Host: 127.0.0.1:8080<br/>User-Agent: python-requests/2.22.0<br/>Accept-Encoding: gzip, deflate<br/>Accept: */*<br/>Connection: keep-alive</em></span></pre><blockquote class="kv"><p id="ffe6" class="kw kx hi bd ky kz la lb lc ld le jc dx translated">请求</p></blockquote><p id="c625" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">HTTP请求由以下内容组成。</p><ol class=""><li id="de65" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><code class="du lt lu lv kn b"><strong class="ih hj"><em class="jd">Request line</em></strong></code> <em class="jd">:一行标识请求类型和路径。</em></li><li id="2a45" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc lp lq lr ls bi translated"><code class="du lt lu lv kn b"><strong class="ih hj"><em class="jd">Headers</em></strong></code> <em class="jd">:一组可选的RFC-822样式报头</em></li><li id="d724" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc lp lq lr ls bi translated"><code class="du lt lu lv kn b"><strong class="ih hj"><em class="jd">Data</em></strong></code> <em class="jd">:可选数据。</em></li></ol><p id="83af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请求行</strong></p><p id="7af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概括地说，我们可以说请求行包括</p><p id="5ca7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lt lu lv kn b">METHOD REQUEST-URL HTTP-VERSION CRLF</code></p><p id="81f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述请求的请求行是:<code class="du lt lu lv kn b">GET / HTTP/1.1</code></p><p id="dc1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法是<code class="du lt lu lv kn b">GET</code>。也就是说我们想从服务器上获取数据。请注意，该方法区分大小写。这里资源的路径是<code class="du lt lu lv kn b">/. HTTP/1.0</code>是我们正在使用的HTTP协议版本。而<code class="du lt lu lv kn b">\r\n</code>是CRLF。CR-LF表示回车。它表示线路结束。</p><p id="dc3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">标题</strong></p><p id="8547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lt lu lv kn b">Host, User-Agent, Accept, Accept-Encoding, Connection </code>是请求头字段。</p><p id="56da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据</strong></p><p id="0a39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的请求中，我们没有发送任何数据。让我们发送另一个请求来更好地理解事情。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="d22d" class="jf jg hi kn b fi kr ks l kt ku">&gt;&gt;requests.<strong class="kn hj">post</strong>(url=”<a class="ae je" href="http://127.0.0.1:8080?a=1" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080?a=1</a>", headers= <strong class="kn hj">{“header1”: “value1”, “header2”: “value2”</strong>},data=<strong class="kn hj">{“key1”: “value1”, “key2”: “value2”}</strong>)</span></pre><p id="30a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在印刷品中我们可以看到:</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="8ac8" class="jf jg hi kn b fi kr ks l kt ku"><strong class="kn hj"><em class="jd">POST</em></strong><em class="jd"> </em><strong class="kn hj"><em class="jd">/?a=1</em></strong><em class="jd"> HTTP/1.1<br/>Host: 127.0.0.1:8080<br/>User-Agent: python-requests/2.22.0<br/>Accept-Encoding: gzip, deflate<br/>Accept: */*<br/>Connection: keep-alive<br/></em><strong class="kn hj"><em class="jd">header1: value1<br/>header2: value2</em></strong><em class="jd"><br/>Content-Length: 23<br/>Content-Type: application/x-www-form-urlencoded</em></span><span id="6c58" class="jf jg hi kn b fi mb ks l kt ku"><strong class="kn hj"><em class="jd">key1=value1&amp;key2=value2</em></strong></span></pre><p id="5a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此处，方法已更改为post。我们可以看到请求url已经被修改为<code class="du lt lu lv kn b">?a=1</code>。添加了我们的自定义标题<code class="du lt lu lv kn b"> header1</code>和<code class="du lt lu lv kn b">header2</code>。我们发送的数据<code class="du lt lu lv kn b">key1</code>和<code class="du lt lu lv kn b">key2</code>也存在。</p><blockquote class="kv"><p id="42f5" class="kw kx hi bd ky kz mc md me mf mg jc dx translated">浏览器</p></blockquote><p id="f930" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们可以从浏览器访问服务器。打开浏览器，输入<code class="du lt lu lv kn b">127.0.0.1:8080</code></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/d5dfc1efccd60563aed33859df2df86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*He2Qt22yMhCS8kj1ISFvkg.png"/></div></div></figure><p id="acce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在终端中，您将看到以下结果。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="04d7" class="jf jg hi kn b fi kr ks l kt ku"><em class="jd">GET / HTTP/1.1<br/>Host: 127.0.0.1:8080<br/>User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Connection: keep-alive<br/>Upgrade-Insecure-Requests: 1<br/>Cache-Control: max-age=0</em></span></pre><h2 id="5391" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">HTTP客户端</h2><p id="f765" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我们可以使用相同的原理实现我们自己的HTTP客户端。这是一个简单的套接字程序。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="c357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将打印出来:</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="4fc5" class="jf jg hi kn b fi kr ks l kt ku">HTTP/1.1 200 OK</span><span id="1408" class="jf jg hi kn b fi mb ks l kt ku">Hello World</span></pre><ul class=""><li id="5915" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc mo lq lr ls bi translated"><code class="du lt lu lv kn b">HTTP/1.1</code>是我们正在使用的协议。</li><li id="308e" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc mo lq lr ls bi translated"><code class="du lt lu lv kn b">200</code>是表示请求成功的状态代码。状态代码是三位数。</li><li id="78e9" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc mo lq lr ls bi translated"><code class="du lt lu lv kn b">OK</code>这是一个简单的单线阶段，说明原因。</li><li id="dcfc" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc mo lq lr ls bi translated"><code class="du lt lu lv kn b">Hello World</code>是消息的正文。它是被修改的部分。</li></ul><blockquote class="kv"><p id="517e" class="kw kx hi bd ky kz la lb lc ld le jc dx translated">反应</p></blockquote><p id="e746" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">回应是:</p><ol class=""><li id="b010" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><em class="jd">一行给出响应代码</em></li><li id="a9e4" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc lp lq lr ls bi translated"><em class="jd">一组可选的RFC-822样式的报头</em></li><li id="580c" class="lk ll hi ih b ii lw im lx iq ly iu lz iy ma jc lp lq lr ls bi translated"><em class="jd">可选数据</em></li></ol><p id="9c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结论:</p><p id="3a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是简单的裸骨。更多信息，我发现C python源代码很有用。<a class="ae je" href="https://github.com/python/cpython/blob/main/Lib/http/client.py" rel="noopener ugc nofollow" target="_blank">https://github . com/python/cpython/blob/main/Lib/http/client . py</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Easy Ways to Deliver Adaptive Image Formats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提供自适应图像格式的简单方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/easy-ways-to-deliver-adaptive-image-formats-4f461a66b136?source=collection_archive---------13-----------------------#2022-12-05">https://medium.com/geekculture/easy-ways-to-deliver-adaptive-image-formats-4f461a66b136?source=collection_archive---------13-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ff83c1951978be0e5a6b133f5d13b073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmP-YaC6FGXUg-DdIQBSBA.jpeg"/></div></div></figure><p id="3d07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与JPEG或PNG等传统图像格式相比，WebP和AVIF等下一代图像格式使用高级无损和有损压缩算法来实现更高的压缩效率、更好的细节保留和更少的块效应。它极大地优化了图像传输的大小，并提高了大量图像网站的性能。通常建议网站在支持这些格式时使用它们。</p><p id="4f2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然WebP和AVIF已经得到了大多数浏览器的最新版本的普遍支持，但它们仍然会引起对传统图像格式兼容性的担忧。本文向您展示了如何将这些优化的图像适应性地交付给最终用户。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/d755ff3d581e83e9f3e76358984673b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRYS3nRMtE-KeXis5E59IA.jpeg"/></div></div></figure><h1 id="87ea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">标准方法</h1><p id="c580" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">最常见和直接的方法是在提供WebP格式的图片之前检查浏览器的兼容性。有几种方法可以提供HTML、JS和CSS格式的WebP图片。</p><h2 id="1515" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">超文本标记语言</h2><p id="3fd1" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">使用<code class="du lk ll lm ln b">&lt;picture&gt;</code>标签语法进行WebP格式的自适应加载，同时使用常规格式作为备份。</p><pre class="jp jq jr js fd lo ln lp bn lq lr bi"><span id="7b17" class="ls ju hi ln b be lt lu l lv lw">&lt;picture&gt; <br/>  &lt;source srcSet="https://images.example.com/resouces/hero.jpg~aptx-4869.webp" type="image/web" /&gt; <br/>  &lt;img decoding="async" loading="lazy" src="https://images.example.com/resouces/hero.jpg~aptx-4869.jpeg" /&gt;<br/>&lt;/picture&gt;</span></pre><h2 id="8277" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">射流研究…</h2><p id="ca73" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们可以用JS来检测浏览器是否支持WebP。如果支持，使用WebP格式，否则使用JPEG/PNG。</p><p id="1033" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种简单的方法可以做到:</p><ol class=""><li id="42b1" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">使用<code class="du lk ll lm ln b">Canvas</code> <code class="du lk ll lm ln b">toDataURL()</code></li></ol><p id="c1fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lk ll lm ln b">HTMLCanvasElement.toDataURL()</code>方法返回一个<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs" rel="noopener ugc nofollow" target="_blank">数据URL </a>，其中包含一个由<code class="du lk ll lm ln b">type</code>参数指定格式的图像表示。对于支持编码分辨率元数据的文件格式，创建的图像数据将具有96dpi的分辨率。</p><p id="b695" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当将参数<code class="du lk ll lm ln b">image/webp</code>传递给方法，但返回值以<code class="du lk ll lm ln b">data:image/png</code>开头时，则表明不支持WebP。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/25fbb5b2b4d1b366c6204f0ec1d9b801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSoxlpQgzt5puTqQ8fI8kw.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Chrome 108 supports WebP</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/e1f6c41fefd32d900bbfc99fce1d611d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j897D3QfMK1FZvcMi27fCg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Safari 15.6.1 on macOS 10.15 Catalina doesn’t support WebP</figcaption></figure><p id="9809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们可以定义一个函数，并使用它来检测WebP支持。</p><pre class="jp jq jr js fd lo ln lp bn lq lr bi"><span id="f6e9" class="ls ju hi ln b be lt lu l lv lw">var isSupportWebp = function () {<br/>  try {<br/>    return document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0;<br/>  } catch(err) {<br/>    return false;<br/>  }<br/>}<br/><br/>isSupportWebp()</span></pre><p id="4de0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.通过加载WebP映像来检查兼容性</p><p id="830e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方法可以在<a class="ae mg" href="https://developers.google.com/speed/webp/faq" rel="noopener ugc nofollow" target="_blank">谷歌的WebP官方FAQ </a>中找到。它试图加载一个WebP图像并检查该图像的高度和重量。如果身高和体重都不能返回，那么浏览器不支持WebP。</p><pre class="jp jq jr js fd lo ln lp bn lq lr bi"><span id="e182" class="ls ju hi ln b be lt lu l lv lw">// check_webp_feature:<br/>//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.<br/>//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)<br/>function check_webp_feature(feature, callback) {<br/>    var kTestImages = {<br/>        lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",<br/>        lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",<br/>        alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",<br/>        animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"<br/>    };<br/>    var img = new Image();<br/>    img.onload = function () {<br/>        var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0);<br/>        callback(feature, result);<br/>    };<br/>    img.onerror = function () {<br/>        callback(feature, false);<br/>    };<br/>    img.src = "data:image/webp;base64," + kTestImages[feature];<br/>}</span></pre><h2 id="8df2" class="kw ju hi bd jv kx ky kz jz la lb lc kd jb ld le kh jf lf lg kl jj lh li kp lj bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h2><p id="e8a0" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">为了用CSS自适应地加载WebP格式，我们首先需要检测支持度。如果浏览器支持WebP，那么我们将<code class="du lk ll lm ln b">WebP</code>添加到<code class="du lk ll lm ln b">classList</code>:</p><pre class="jp jq jr js fd lo ln lp bn lq lr bi"><span id="2092" class="ls ju hi ln b be lt lu l lv lw">document.documentElement.classList.add('webp')</span></pre><p id="d846" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以使用选择器的优先级规则来实现自适应图像格式交付。在CSS中代码可以改变如下。</p><pre class="jp jq jr js fd lo ln lp bn lq lr bi"><span id="a57f" class="ls ju hi ln b be lt lu l lv lw">.img { background-image: url('https://images.example.com/resouces/hero.jpg~aptx-4869.jpeg') }<br/><br/>.webp .img { background-image: url('https://images.example.com/resouces/hero.jpg~aptx-4869.webp') }</span></pre><h1 id="9c21" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自动批处理解决方案</h1><p id="fd69" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">对于拥有大量图像并不断添加所需图像的生产站点，手动处理图像格式转换和交付是不可行的。</p><p id="f1e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到大多数前端项目都与Webpack捆绑在一起，开发一个Webpack插件(或使用现有的插件)将图像转换为WebP并自适应地提供服务是有意义的。在本地完成所有格式转换通常很耗时，找到一个可靠的云解决方案可以帮助减少处理时间。</p><p id="94e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">批处理通常包括三个步骤:</p><ol class=""><li id="9337" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><strong class="is hj">上传图片并转换。</strong>现有的开源工具如<a class="ae mg" href="https://github.com/webpack-contrib/file-loader" rel="noopener ugc nofollow" target="_blank">文件加载器</a>是可用的。</li><li id="ea8e" class="lx ly hi is b it mn ix mo jb mp jf mq jj mr jn mc md me mf bi translated"><strong class="is hj">为资产注入WebP标签。</strong>许多阶段依赖于浏览器对WebP的支持。拥有一个全局标签很有帮助，这样我们可以在页面呈现之前检测兼容性。<br/>我们可以使用像<a class="ae mg" href="https://github.com/jantimon/html-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> html-webpack-plugin </a>这样的工具来帮助构建带有webpack包的html文件。这个插件提供的钩子可以用来在<code class="du lk ll lm ln b">alterAssetTagGroup</code>阶段添加检测代码。</li></ol><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/83e877e2fc6070e8e12bdc67884cddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HlSOxRDHyTsVxVX7qDqNKA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">flow of html-webpack-plugin</figcaption></figure><p id="9b94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<strong class="is hj">替换图片网址。</strong>基于全局标签，我们可以用WebP或JPEG/PNG版本替换图像URL。这可以在JS或CSS中完成。</p><h1 id="fa53" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">更全面的解决方案</h1><p id="acd3" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">如你所见，整个过程可以用定制或开源工具来DIY。然而，如果你的网站上有大量的图片，你可能也需要CDN来获得更好的图片和网站的整体性能。如果是这样，为什么不让你的CDN提供商为你做兼容性检测、图像格式转换和自适应交付呢？</p><p id="a12c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很多CDN提供商都有自己的镜像解决方案。比如Akamai提供<a class="ae mg" href="https://www.akamai.com/products/image-and-video-manager" rel="noopener ugc nofollow" target="_blank">图像&amp;视频管理器</a>，Cloudflare有<a class="ae mg" href="https://www.cloudflare.com/products/cloudflare-images/" rel="noopener ugc nofollow" target="_blank"> Cloudflare图像</a>。这些解决方案不仅帮助您通过边缘服务器从CDN端提供自适应图像格式，还具有图像缩放、优化等附加功能，最重要的是，减轻了图像资产管理的痛苦。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Sorting Records in Database(MongoDB)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对数据库中的记录进行排序(MongoDB)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sorting-records-in-database-mongodb-c1b45b104ae2?source=collection_archive---------26-----------------------#2021-05-20">https://medium.com/geekculture/sorting-records-in-database-mongodb-c1b45b104ae2?source=collection_archive---------26-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/36c1b3ba7d5408efd8e3e64f8f83b5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EyZth5wB6tjOLs-w.png"/></div></div></figure><p id="8d90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将解释如何在MongoDB中对记录(用户)进行排序。MongoDB中有一个函数，名为$sort但是在我的大学里，我们不用这个函数。所以我必须为此找到一个方法。开始吧！</p><p id="344d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要知道我们的记录数量。在MongoDB中，我们有find()和count函数。使用这两个，我们基本上可以找到这样的计数:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2953" class="jx jy hi jt b fi jz ka l kb kc">const count = await User.find().count();</span></pre><p id="a406" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户是数据库的名称。然后我们用let为用户创建一个数组。意思是，我们可以随时改变它。我们将把数据库中的用户放到这个数组中。为此，我们需要一个For循环。在循环中，我们将使用MongoDB中的findOne()函数。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4467" class="jx jy hi jt b fi jz ka l kb kc">for (let i = 0; i &lt; count; i++) {</span><span id="10a2" class="jx jy hi jt b fi kd ka l kb kc">users[i] = await User.findOne({ id: i })</span><span id="c871" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="250c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将使用递归冒泡排序，因为它易于理解和编码。对于这个算法，我们需要一个临时变量。当我们对其他记录进行排序时，temp将存储一个记录。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b1dd" class="jx jy hi jt b fi jz ka l kb kc">for (k = 0; k &lt; count - 1; k++) {</span><span id="f30a" class="jx jy hi jt b fi kd ka l kb kc">for (l = 0; l &lt; count - k - 1; l++) {</span><span id="5a87" class="jx jy hi jt b fi kd ka l kb kc">if (users[l].point &lt; users[l + 1].point) {</span><span id="90a2" class="jx jy hi jt b fi kd ka l kb kc">temp = users[l]</span><span id="7e5d" class="jx jy hi jt b fi kd ka l kb kc">users[l] = users[l + 1];</span><span id="c28f" class="jx jy hi jt b fi kd ka l kb kc">users[l + 1] = temp</span><span id="8577" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="1e84" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="f529" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="870e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这段代码中，最重要的部分是‘如果’。如果一个用户的点数比另一个小，我们存储一个小记录，等于一个大记录，并用temp改变它。这叫做交换，仅此而已。</p><p id="8a23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我选择在数组中存储用户名、点数和id。为此，我编写了以下代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e821" class="jx jy hi jt b fi jz ka l kb kc">let names = []</span><span id="331f" class="jx jy hi jt b fi kd ka l kb kc">let points = []</span><span id="43b3" class="jx jy hi jt b fi kd ka l kb kc">let _ids = []</span><span id="df82" class="jx jy hi jt b fi kd ka l kb kc">for (let i = 0; i &lt; count; i++) {</span><span id="98ec" class="jx jy hi jt b fi kd ka l kb kc">names[i] = users[i].name</span><span id="4457" class="jx jy hi jt b fi kd ka l kb kc">points[i] = users[i].point</span><span id="c0fd" class="jx jy hi jt b fi kd ka l kb kc">_ids[i] = users[i]._id</span><span id="ed4d" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="9c92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后带着</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a434" class="jx jy hi jt b fi jz ka l kb kc">return <em class="ke">res</em>.json({</span><span id="54f6" class="jx jy hi jt b fi kd ka l kb kc">data: {</span><span id="daa1" class="jx jy hi jt b fi kd ka l kb kc">_ids,</span><span id="af10" class="jx jy hi jt b fi kd ka l kb kc">names,</span><span id="7e36" class="jx jy hi jt b fi kd ka l kb kc">points</span><span id="a0c8" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="bb42" class="jx jy hi jt b fi kd ka l kb kc">})</span></pre><p id="4ae4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！当我们用npm start启动服务器并转到Postman时，我们将在用户信息中看到id、名称和点数。</p><p id="9b80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文以此结束。当然，对于这个例子，您可以只使用$sort函数。但是我找不到没有$sort的方法，所以我想解释一下怎么做。感谢阅读！</p></div></div>    
</body>
</html>
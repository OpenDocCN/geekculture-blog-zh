<html>
<head>
<title>React Hooks or Redux — choosing the right state management strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks或Redux —选择正确的状态管理策略</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-or-redux-choosing-the-right-state-management-strategy-f70cc0840735?source=collection_archive---------15-----------------------#2021-08-04">https://medium.com/geekculture/react-hooks-or-redux-choosing-the-right-state-management-strategy-f70cc0840735?source=collection_archive---------15-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="96ad" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">Christian Miles给了React开发人员一些管理应用程序状态的建议。他们应该使用哪个——Hooks还是Redux？</p></blockquote><p id="5081" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在我的日常工作中，在<a class="ae jk" href="https://cambridge-intelligence.com/" rel="noopener ugc nofollow" target="_blank">剑桥智能</a>，我与许多React开发人员一起工作。</p><p id="2805" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当我问他们首选的状态管理策略时，我得到了一个复杂的回答。一些依赖于<a class="ae jk" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>，这是JavaScript应用程序流行的状态容器，而另一些则更喜欢<a class="ae jk" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>。</p><p id="c3ba" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在本文中，我将探索这两种方法，并介绍第三种混合方法。自始至终，我将根据我与开发人员的经验和讨论提出有用的建议，这些开发人员使用我们的<a class="ae jk" href="https://cambridge-intelligence.com/products/" rel="noopener ugc nofollow" target="_blank">React SDK</a>构建生产级数据可视化工具。</p><h1 id="52d7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">应用程序状态基础</h1><p id="9ed8" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">当您构建React web应用程序时，所有信息都保存在我们称之为状态的地方。因此，要更新应用程序，我们只需更新该状态。简单吧？</p><p id="8324" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">不完全是。国家管理是一个众所周知的难题。</p><p id="0171" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">管理状态就是控制在应用程序的不同组件之间传递的数据。考虑共享这些数据的最佳策略很重要——我们如何让开发人员更容易理解和控制组件之间的数据流动？</p><p id="9ca6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用像React这样的易于理解的框架意味着大多数核心应用程序生命周期事件都可以为您处理。但是对于实现和状态管理有很多选择。随着偏好的改变和最佳实践的转变，这些选项可能会让人不知所措。</p><h1 id="39ff" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">React Hooks作为Redux的替代品？</h1><p id="0cdb" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">在过去的几年里，React状态管理环境发生了巨大的变化。有影响力的Redux库强调<a class="ae jk" href="https://redux.js.org/faq/immutable-data" rel="noopener ugc nofollow" target="_blank">的不变性</a>激发了核心变化——最显著的是16.8版本中增加的钩子。</p><p id="3f3e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">参见<a class="ae jk" href="https://cambridge-intelligence.com/hooks-in-regraph/" rel="noopener ugc nofollow" target="_blank">在你的ReGraph代码</a>中使用钩子，了解更多关于钩子的细节。</p><p id="26fd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">许多其他新的状态管理方法已经出现，还有无数的JavaScript库需要考虑。由于我们从事数据可视化业务，我将重点介绍构建<a class="ae jk" href="https://cambridge-intelligence.com/graph-analytics-101/" rel="noopener ugc nofollow" target="_blank">图形分析应用</a>的建议。</p><h1 id="869b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">国家管理战略规划</h1><p id="3bf0" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">让我们考虑两个状态管理难题:我需要存储什么状态，为什么？</p><p id="8857" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">并非数据可视化应用程序中的所有状态都相同。你将有不同类型的数据来传递。下面是一个图形分析项目的简化但有代表性的组件架构:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b903" class="kx jm hi kt b fi ky kz l la lb">&lt;App&gt;<br/>    &lt;VisualizationContainer&gt;<br/>        &lt;Chart/&gt;<br/>        &lt;Timeline/&gt;<br/>    &lt;/VisualizationContainer&gt;<br/>    &lt;Sidebar/&gt;<br/>&lt;/App&gt;</span></pre><p id="0652" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们的ReGraph图表组件与VisualizationContainer中的<a class="ae jk" href="https://cambridge-intelligence.com/kronograph/" rel="noopener ugc nofollow" target="_blank"> KronoGraph </a>时间轴成对出现。</p><p id="3d1e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们希望在图表中显示节点和链接(项目)以查看连接，并与时间轴组件共享数据，以便我们可以深入研究数据集中的时间戳。我们的侧边栏包括UI元素来运行搜索和更新我们的图表和时间线。我们的目标是一个图形和时间线可视化，如下所示:</p><figure class="ko kp kq kr fd ld er es paragraph-image"><div class="er es lc"><img src="../Images/ccfd1ae79f8533d7da2fea32bd0c1936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-EwmND1uq_JvZWN3"/></div></figure><p id="a47e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当您计划您的状态管理策略时，有必要将您的状态绘制在一个轴上，以了解您在处理什么:</p><figure class="ko kp kq kr fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/5f7720c40ddf27181761c2f4ace1dac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rFkF38mtduSEL7fo"/></div></div></figure><p id="f038" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这些是我遵循的指导原则:</p><p id="2993" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">项目类型:除非您正在构建一个通用的应用程序，否则图表和时间线中的节点类型(人、地点、车辆)很可能是静态的。我可以提前定义它们，因为它们不需要处于状态，所以它们在我们存储库中的配置文件中。</p><p id="5d12" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">项目样式:逻辑上包括每个节点和链接类型的核心样式，以及预期的节点和链接的定义。</p><p id="a21d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">主题选择:给用户在黑暗和光明模式之间切换的选项，导致一个相对易变的状态项来跟踪用户的偏好。</p><p id="cb32" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">UI状态:UI状态的其他部分既是静态的也是临时的。但是没有必要在我们的状态中存储所有的表单交互(这是一个常见的错误，会导致应用程序没有响应)。</p><p id="6f79" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">项目位置和时间线范围:您的节点位置(以及找到节点的网络)非常不稳定:</p><ul class=""><li id="2ffe" class="ll lm hi il b im in iq ir jh ln ji lo jj lp jg lq lr ls lt bi translated">在他们的ReGraph图表中，用户可以运行一个布局，并按照他们喜欢的方式手动定位节点。</li><li id="f0fd" class="ll lm hi il b im lu iq lv jh lw ji lx jj ly jg lq lr ls lt bi translated">在KronoGraph时间轴中，用户可以放大感兴趣的时间范围。</li><li id="2132" class="ll lm hi il b im lu iq lv jh lw ji lx jj ly jg lq lr ls lt bi translated">在不同的会话中保持这些位置是一个常见的要求，这样用户可以从他们停止的地方继续。</li></ul><p id="b18c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">撤销/重做堆栈:这是一个允许用户撤销操作的流行请求。在高级应用程序中，您可能需要在多个会话中持久保存这些撤销/重做数据，但通常的设计决策是仅在当前会话中使用这些数据。</p><p id="49fa" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">来自API的数据:您可能需要从外部位置或API接收数据。这个数据是动态的和临时的。强大的应用程序缓存来自端点的结果，并在应用程序状态中持久保存相关的位。</p><h1 id="08db" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">react Hooks vs Redux——还有别的办法吗？</h1><p id="e9b2" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">既然我们已经描述了我们的状态，我们可以考虑应用程序中的数据层次。有两种主要的状态管理方法可供选择:</p><ul class=""><li id="b3e5" class="ll lm hi il b im in iq ir jh ln ji lo jj lp jg lq lr ls lt bi translated">在我们的组件中处理状态，并在必要时使用钩子在它们之间传递。这种方法通常被称为“适当的训练”或“提升状态”，推荐用于基本应用程序。</li><li id="58fa" class="ll lm hi il b im lu iq lv jh lw ji lx jj ly jg lq lr ls lt bi translated">使用某种所有组件都可以访问的全局存储。像Redux这样的库为此提供了能力。</li></ul><p id="8525" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是还有第三种甚至更好的方法:一种混合方法，将钩子与什么状态是重要的仔细考虑在一起。</p><p id="b7ec" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们使用数据可视化应用程序来进一步探索这些方法，从Redux开始。</p><h1 id="114e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">冗余状态管理</h1><p id="3c0c" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">自2015年发布以来，Redux已经成为React生态系统的关键组成部分。</p><p id="56bf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Redux使用不变性来简化应用程序开发和逻辑。通过对状态中的所有项目强制不变性，我们可以跟踪数据的变化，并避免可能导致错误的意外数据突变。</p><p id="a522" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">随着时间的推移，Redux变得有些臃肿，但对于具有复杂状态的大型应用程序来说，它仍然是一个极好的选择。为了帮助降低库的复杂性，2019年推出了<a class="ae jk" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux工具包</a>。现在推荐使用Redux的方式。</p><h1 id="20f0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">一致的状态更新</h1><p id="f936" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">Redux中的一个核心概念是减速器。对于那些有函数式编程经验的人来说，这是一个接受多个输入并将其“简化”为单个输出的函数。在状态管理中，这可以扩展到这样一种思想，即您可以接受一个或多个状态更新指令，并为您的图表产生一致的状态更新。</p><p id="256b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们考虑一个标准的图形可视化用例:在图表中添加和删除节点。我希望它在我的全局存储中，所以我在我的存储中创建了一个状态“切片”。以下是我在store.js中创建商店的代码:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="9039" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">为了让我的应用程序中的其他组件访问商店，我将应用程序包装如下:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="eca8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">提供者部分意味着下游的任何东西都可以访问那个存储。在itemsSlice.js中，我为这些项目定义了我的状态切片:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="498b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这里发生了很多事情:</p><ul class=""><li id="99bf" class="ll lm hi il b im in iq ir jh ln ji lo jj lp jg lq lr ls lt bi translated">我们的ReGraph items prop是一个由节点和链接组成的对象，通过ID进行索引。核心数据结构非常常见，Redux Toolkit有一些助手函数来处理这种格式的数据。这里我使用<a class="ae jk" href="https://redux-toolkit.js.org/api/createEntityAdapter" rel="noopener ugc nofollow" target="_blank"> createEntityAdapter </a>来利用适配器提供的addMany、addOne、removeMany、removeOne函数。</li><li id="1e58" class="ll lm hi il b im lu iq lv jh lw ji lx jj ly jg lq lr ls lt bi translated">在Redux中，选择器允许我们从存储中获取一部分状态。我利用适配器上的<a class="ae jk" href="https://redux-toolkit.js.org/api/createEntityAdapter#selector-functions" rel="noopener ugc nofollow" target="_blank"> getSelectors </a>来避免自己编写状态查询代码。滑头！</li><li id="8c97" class="ll lm hi il b im lu iq lv jh lw ji lx jj ly jg lq lr ls lt bi translated">最后，我导出所有内容，以便可以在应用程序的其他地方使用它</li></ul><p id="a06e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在我的应用程序代码中，我可以利用存储、缩减器和选择器:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="231c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用<a class="ae jk" href="https://react-redux.js.org/api/hooks#useselector" rel="noopener ugc nofollow" target="_blank"> Redux Hooks useSelector </a>，我可以很容易地利用我的切片代码提供的选择器。与此同时，<a class="ae jk" href="https://react-redux.js.org/api/hooks#usedispatch" rel="noopener ugc nofollow" target="_blank"> useDispatch </a>允许我们针对我们的状态“调度”一个动作Redux的另一个有用之处是允许我们改变状态。</p><figure class="ko kp kq kr fd ld er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mb"><img src="../Images/14cc78acf51c449199508192b8836a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lts-AP0YFE1Oizb8"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Adding and removing nodes with Redux managing state</figcaption></figure><p id="eaa3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Redux Toolkit使用流行的不变性库<a class="ae jk" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank"> Immer </a>，对状态进行干净的更新，而不需要编写复杂的克隆和更新逻辑。这被我的itemsAdapter进一步抽象了。</p><p id="52a0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这里，我已经直接在组件中设计了图表项的样式。一个聪明的选择是按照这个<a class="ae jk" href="https://cambridge-intelligence.com/styled-components-tutorial-for-graph-visualizations/" rel="noopener ugc nofollow" target="_blank">样式的组件教程来进行图形可视化</a>。</p><p id="a92d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当您从外部数据源获取数据时，应用程序状态和数据库存储之间的界限有点模糊。<a class="ae jk" href="https://redux-toolkit.js.org/tutorials/rtk-query" rel="noopener ugc nofollow" target="_blank"> RTK Query </a>(来自Redux Toolkit的创造者)和其他流行的库，如<a class="ae jk" href="https://daveceddia.com/react-state-management/" rel="noopener ugc nofollow" target="_blank"> react-query </a>与Redux配合得很好，避免了从头开始编写缓存等功能。我们将在以后的博客文章中介绍RTK查询的使用。</p><p id="4695" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果我只依赖Redux，我会把我的整个应用程序状态放在全局存储中，并从我的每个组件中访问它。实际上，只有一些可视化组件状态需要存储在存储中Hooks和Redux的混合方法提供了两个世界的最佳之处。</p><p id="cc7c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们把注意力转向钩子。</p><h1 id="64a0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">现代React作为Redux的替代品？</h1><p id="c373" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">您可能不愿意在应用程序中引入另一个依赖项。当Hooks在2019年加入React时，它在复制Redux的深度功能方面走了很长的路。</p><p id="104d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们看看如何在应用程序中利用钩子，以及上下文API和prop drilling。</p><h1 id="362a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">支柱钻井</h1><p id="5e65" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">在肯特·c·多兹的这篇精彩文章中，他提出了重要的观点:</p><p id="e0bd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">让状态尽可能靠近需要它的地方。</strong></p><p id="7d7f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">对于我们的例子，这意味着如果我希望在图表和时间线组件之间共享数据(我知道在其他任何地方都不需要它)，我可以通过prop drilling使事情尽可能简单。</p><p id="3421" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果谨慎使用，这是跨组件共享状态的一种有效、干净的方式。如果我在应用程序中将我的状态呈现给VisualizationContainer，我可以将数据作为道具传递给每个组件。</p><p id="7b88" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当然，如果我需要在一个复杂的层次结构中上下传递，我也可以使用Redux或类似的方法。但是对于我们的基本应用程序，保持简单是有意义的。</p><p id="372d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">由于其强大的API和一些精心设计的道具，ReGraph在控制其内部状态方面做得很好。没有必要在支撑图表的组件之外增加很多这样的道具。</p><h1 id="bd6f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">反应钩</h1><p id="c43c" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">正如我们之前在博客中讨论过的，今天我将集中讨论与Redux相似的特性。</p><p id="2bd1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">对于我们的图表组件，我想使用简单的<a class="ae jk" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank"> useState </a>和<a class="ae jk" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef </a>钩子来处理状态中的基本配置。ReGraph将优雅地处理状态的多次更新，因此使用单独的useState调用是合理的人机工程学，除非您确信您将经常一起更新道具组。</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="ab1f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用过Redux的人对<a class="ae jk" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a>钩子非常熟悉。</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="1d88" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">注意，在这个例子中，我正在手写我的reducer。没有Redux Toolkit的帮助，我需要改变我的组合对象。这意味着编写更多的代码，但是对于像ReGraph这样的小应用程序和干净的API，这是合理的。</p><p id="f61c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">React的useReducer和Redux中的Reducer有概念上的区别。在React中，我们想写多少reducers就写多少:它们只是钩子，使更新状态更容易。在Redux中，这些使用片作为概念上的分离来对抗中央存储。</p><p id="d3d1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们可以为ReGraph编写一个定制的钩子来封装我们需要利用的所有属性。这可能是这样的:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0d8c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">请注意，ReGraph使用的每个属性都有许多useState调用。我可以把这些放入一个简单的对象中，用一个函数处理更新，但是我喜欢把它们分开——这是个人喜好。</p><p id="745a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">对于一个简单的实现，我使用<a class="ae jk" href="https://lodash.com/docs/4.17.15" rel="noopener ugc nofollow" target="_blank"> lodash merge </a>来合并我的项目更新。在生产中，我会使用Immer或类似产品来提高性能。</p><h1 id="7bc1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">上下文API</h1><p id="af38" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">如果我只需要从一个组件控制图表，我的自定义useChart钩子就很好。但是如果我想用我的工具条来驱动它呢？</p><p id="294f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这是Redux在全球范围内解决的问题。没有Redux我们还能做什么？</p><p id="9abd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">多年来，上下文一直是React API的一部分。我们可以使用它使数据在用户定义的范围内可访问，因此它可以帮助我们实现一些接近我们在Redux中创建的全局存储的东西。</p><p id="7170" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">利用上下文的现代方法是什么？有一个钩子！</p><p id="3e5f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">关于“语境”和“T2使用语境”是否是Redux的可行和合理的替代，还有一些争论。有一点是肯定的:这是一个干净的API，可以在组件间一致地共享上下文。</p><p id="7b0b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">从<a class="ae jk" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively/" rel="noopener ugc nofollow" target="_blank">的另一篇来自肯特·c·多兹的博客文章</a>中获得灵感，我可以把这个挂钩“语境化”成它自己的东西:</p><figure class="ko kp kq kr fd ld"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="65e8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现在，我用我的自定义ChartProvider上下文包装任何需要访问图表细节和设置器的组件:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dcb1" class="kx jm hi kt b fi ky kz l la lb">&lt;App&gt;</span><span id="8190" class="kx jm hi kt b fi mg kz l la lb">    &lt;ChartProvider&gt;</span><span id="3d9b" class="kx jm hi kt b fi mg kz l la lb">        &lt;VisualizationContainer&gt;</span><span id="0d6d" class="kx jm hi kt b fi mg kz l la lb">            &lt;Chart/&gt;</span><span id="caee" class="kx jm hi kt b fi mg kz l la lb">            &lt;Timeline/&gt;</span><span id="4c86" class="kx jm hi kt b fi mg kz l la lb">        &lt;/VisualizationContainer&gt;</span><span id="893e" class="kx jm hi kt b fi mg kz l la lb">        &lt;Sidebar/&gt;</span><span id="3b49" class="kx jm hi kt b fi mg kz l la lb">    &lt;/ChartProvider&gt;</span><span id="c1ca" class="kx jm hi kt b fi mg kz l la lb">&lt;/App&gt;</span></pre><p id="f22a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">然后我导入useChart并获得当前的图表状态和应用程序层次结构中任意位置的一些调度函数。只需简单地调用useChart:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bb76" class="kx jm hi kt b fi ky kz l la lb"><em class="ik">const </em>[state, { setLayout }] = useChart();</span></pre><h1 id="7a10" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Context vs Redux？</h1><p id="8790" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">使用上下文和Redux store的关键区别在于，上下文不会自动对应用程序的其余部分可用:由您自己来定义范围。</p><p id="7ede" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这是功能，不是bug。</p><p id="9e9f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">它让我们更有意识地使用逻辑，但这也是为什么上下文不能直接替代Redux的原因。就像使用useReducer一样，创建许多不同的上下文供应用程序使用是一种常见的做法。</p><h1 id="7fdc" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">什么对你有用？</h1><p id="2867" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">我们在这篇文章中已经介绍了很多！我们从一个全面的状态管理策略开始，使用Redux工具包来利用全局存储。然后我们探索了一个简单的应用程序如何使用core React钩子来获得同样的好处。</p><p id="07f6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">你如何解决你的国家管理难题？你对React Hooks vs Redux的争论持什么态度？</p></div></div>    
</body>
</html>
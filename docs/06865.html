<html>
<head>
<title>Ansible Automation - Importing Operators into OCP OLM in Restricted Networks — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ansi ble Automation——在受限网络中将运算符导入OCP OLM——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ansible-automation-importing-operators-into-ocp-olm-in-restricted-networks-part-1-7839ce8fca92?source=collection_archive---------23-----------------------#2021-08-31">https://medium.com/geekculture/ansible-automation-importing-operators-into-ocp-olm-in-restricted-networks-part-1-7839ce8fca92?source=collection_archive---------23-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/82ab60bf1604a92b2b720d49689aa417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w-ayAUGDFoSYBXV6.png"/></div></div></figure><h1 id="ca3d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">自动化是关键</h1><p id="3122" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我不得不承认，我手动做这个过程太多次了；直到有一次我忘记了一个命令，解决这个问题只是耗费时间(和动力)。</p><p id="aeed" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最终，不可避免地，一个(明显的)解决方案会出现；所以我坐下来，写了一个“小”可行的剧本，从头到尾做了所有的工作，我唯一的遗憾是我没有早点这么做。</p><p id="b1c7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">完全公开——我写它是为了个人使用，因此——它是作为“概念验证”来写的——这意味着有很大的空间来完善它，但作为一个原型，它工作得非常好。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="910b" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">该操作有两个主要步骤</h2><ol class=""><li id="f9b0" class="lm ln hi jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated">镜像我的目标操作员需要的所有相关图像，并将其存档</li><li id="c96a" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">提取内部/受限网络中的档案，并将其导入到我们的Openshift集群中</li></ol><p id="6098" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这篇“第1部分”文章将关注第一步，我将为另一个写另一篇。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/0da61cef237cf5989cbb279b2da9a013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vMEG84Tg4ZaqVKU7"/></div></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="dcfb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">整个ansible-driven解决方案位于我的<a class="ae mf" href="https://github.com/tommeramber/ocp-automations" rel="noopener ugc nofollow" target="_blank"> Github </a>中，本文将描述它包含的内容和需要的步骤。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="45c8" class="iq ir hi bd is it mg iv iw ix mh iz ja jb mi jd je jf mj jh ji jj mk jl jm jn bi translated">安全说明</h1><p id="a034" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">由于某些任务需要更高的权限，因此本行动手册可以作为高权限用户运行。由于首先应该运行它的只有集群管理员，而且它运行在一个连接的网络中，所以在Fedora/RHEL虚拟机上以root用户身份运行它看起来并没有那么不合理。</p><h1 id="753b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">先决条件</h1><p id="d967" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">1.克隆我的回购</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="5817" class="ky ir hi mm b fi mq mr l ms mt">$ sudo su -<br/># git clone <a class="ae mf" href="https://github.com/tommeramber/ocp-automations.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tommeramber/ocp-automations.git</a><br/># cd ocp-automations/Operator-Importing-for-Restricted-Networks</span></pre><p id="64ce" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">2.安装下列Ansible模块；不必要地提到你必须确保你已经安装了Ansible。</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="05e3" class="ky ir hi mm b fi mq mr l ms mt"># sudo ansible-galaxy collection install community.crypto<br/># sudo ansible-galaxy collection install containers.podman<br/># sudo ansible-galaxy collection install community.general</span></pre><p id="6cfb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">3.<strong class="jq hj">确保对YAML <em class="mu">角色/部署-本地-注册表/任务/生成-拉取-秘密. yaml </em> </strong> <em class="mu">做所有需要的调整。</em>此处指定了所需的更改:<a class="ae mf" href="https://github.com/tommeramber/ocp-automations/blob/main/Operator-Importing-for-Restricted-Networks/roles/deploy-local-registry/tasks/README.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tommeramber/OCP-automations/blob/ansi ble-roles/Operator-Importing-for-Restricted-Networks/roles/deploy-local-registry/tasks/readme . MD</a></p><h1 id="a12b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">角色结构</h1><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="9ea0" class="ky ir hi mm b fi mq mr l ms mt">[Operator-Importing-for-Restricted-Networks]# tree<br/>.<br/>├── <strong class="mm hj">playbook.yaml</strong><br/>├── README.md<br/>└── roles<br/>    ├── <strong class="mm hj">cleanup</strong><br/>    │   ├── tasks<br/>    │   │   └── main.yml<br/>    ├── <strong class="mm hj">deploy-local-registry</strong><br/>    │   ├── tasks<br/>    │   │   ├── generate-pull-secret.yaml<br/>    │   │   ├── login-to-external-registries.yaml<br/>    │   │   ├── main.yml<br/>    │   │   └── run-registry.yaml<br/>    ├── <strong class="mm hj">install-required-tools</strong><br/>    │   ├── tasks<br/>    │   │   └── main.yml<br/>    └── <strong class="mm hj">run-custom-index-container-and-mirror</strong><br/>        ├── tasks<br/>        │   ├── generate-custom-index-image.yaml<br/>        │   ├── main.yml<br/>        │   ├── mirror-manifests-and-generate-mapping-file.yaml<br/>        │   └── skopeo-copy-the-relevant-images-and-compress.yaml</span></pre><p id="08b7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">本行动手册由4个角色组成</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="6abb" class="ky ir hi mm b fi mq mr l ms mt">---<br/>- hosts: localhost<br/>  vars:<br/>    # In use in both: "run-custom-index-container-and-mirror" and "cleanup" roles<br/>    index_image: community-operator<br/>    index_image_version: v4.6</span><span id="2393" class="ky ir hi mm b fi mv mr l ms mt">roles:</span><span id="965a" class="ky ir hi mm b fi mv mr l ms mt">- role: <strong class="mm hj">deploy-local-registry</strong><br/>      vars:<br/>        user: "dummy"<br/>        password: "dummy"</span><span id="b739" class="ky ir hi mm b fi mv mr l ms mt">- role: <strong class="mm hj">install-required-tools</strong><br/>      vars:<br/>        ocp_version: "4.6.8"<br/>        opm_version: "v1.18.0"<br/>        grpcurl_latest_version_number: "v1.8.2"</span><span id="13ab" class="ky ir hi mm b fi mv mr l ms mt">- role: <strong class="mm hj">run-custom-index-container-and-mirror</strong><br/>      vars:<br/>        required_operator: argocd</span><span id="9b30" class="ky ir hi mm b fi mv mr l ms mt">- role: <strong class="mm hj">cleanup</strong></span></pre><p id="fa37" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如你所看到的，它是以这样一种方式设计的，你只需要改变几个变量就可以用最少的努力得到不同的操作符。</p><p id="37da" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它一次只对一个操作员有效。</p><p id="fba4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在上面的代码中，你可以看到我正在使用community-operator-index-image(var:<code class="du mw mx my mm b">index_image</code>)，用于openshift v4.6 (var: <code class="du mw mx my mm b">index_image_version</code>和var: <code class="du mw mx my mm b">ocp_version</code>)，并且我想获得<em class="mu"> ArgoCD </em>操作符(var: <code class="du mw mx my mm b">required_operator</code>)。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/f5ee4a8cce1876718aa71d82ce99bc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HmiMGoxAFb_5xCfw"/></div></div></figure><p id="db7e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我想得到官方的RedHat Openshift-GitOps操作符，我需要做的就是改变:</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="4e3c" class="ky ir hi mm b fi mq mr l ms mt"># In the playbook role I'm using a "like" comparison that gives the first match found <br/>required_operator: <strong class="mm hj">gitops</strong> </span><span id="dfc7" class="ky ir hi mm b fi mv mr l ms mt">index_image: <strong class="mm hj">redhat-operator</strong></span></pre><p id="74d9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我想要一个不同版本的Openshift集群的映像，我将更改:</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="64c8" class="ky ir hi mm b fi mq mr l ms mt"># Change X to correleate to your OCP minor-version<br/>ocp_version: "4.7.<strong class="mm hj">X</strong>"<br/>index_image_version: v4.7</span></pre><p id="8388" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">注意<code class="du mw mx my mm b">index_image_version</code>也应该被改变。</p><p id="39cc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另外，请注意，您可能需要根据文档中的<a class="ae mf" href="https://docs.openshift.com/container-platform/4.6/operators/admin/olm-restricted-networks.html" rel="noopener ugc nofollow" target="_blank">规范，为您的特定Openshift版本(我在此概念验证中使用的是4.6版本)更改一些其他变量(例如<code class="du mw mx my mm b">opm_version</code>)。</a></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="f598" class="iq ir hi bd is it mg iv iw ix mh iz ja jb mi jd je jf mj jh ji jj mk jl jm jn bi translated">角色1 — <strong class="ak">部署本地注册表</strong></h1><blockquote class="na nb nc"><p id="d728" class="jo jp mu jq b jr km jt ju jv kn jx jy nd ko kb kc ne kp kf kg nf kq kj kk kl hb bi translated">我们将关注以下路径中的YAML文件:<strong class="jq hj">OCP-automation/roles/deploy-local-registry/</strong></p></blockquote><p id="4eef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">该过程从创建一个本地注册表开始，该注册表最终将包含我们期望的操作符所需的所有图像，以及使导入部分尽可能平滑所需的所有额外文件；</p><p id="56e3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这第一部分是根据红帽在Openshift博客中的精彩文章:<a class="ae mf" href="https://cloud.redhat.com/blog/openshift-4-2-disconnected-install" rel="noopener ugc nofollow" target="_blank">https://cloud . Red Hat . com/blog/open shift-4-2-disconnected-install</a></p><p id="b6a3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注意！</strong>我不会在这里展示每一个可行的任务，因为很多都是非常基本的。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="d2f3" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第1部分—角色/部署-本地-注册表/任务/运行-注册表. yaml</h2><p id="c837" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">最初的几项任务非常简单；我们正在确保机器上安装了Podman、Httpd和Httpd-tools。</p><p id="0518" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">之后，我们将创建3个目录，作为我们本地注册表的未来卷；从这些，本地注册表容器将从&amp;到&amp;拉&amp;推数据/文件。</p><p id="5679" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，我们将记录“myregistry”添加到<code class="du mw mx my mm b">/etc/hosts</code>中，这样我们以后就可以通过名称来访问它。</p><p id="2e0a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们为以后的证书创建生成一个OpenSSL私钥；为此，我们安装了<code class="du mw mx my mm b">community.crypto</code> Ansible模块；</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="01fa" class="ky ir hi mm b fi mq mr l ms mt">- name: Generate an OpenSSL private key with the default values (4096 bits, RSA)<br/>community.crypto.openssl_privatekey:<br/>  path: /tmp/myregistry/certs/myregistry_key.pem</span></pre><p id="7d5a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，我们为将要生成的未来证书生成一个基本证书签名请求(CSR)。注意<code class="du mw mx my mm b">common_name</code>等于我们编辑的<code class="du mw mx my mm b">/etc/hosts</code>文件中的记录</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="8359" class="ky ir hi mm b fi mq mr l ms mt">- name: Generate an OpenSSL Certificate Signing Request<br/>community.crypto.openssl_csr:<br/>  path: /tmp/myregistry/certs/myregistry.csr<br/>  privatekey_path: /tmp/myregistry/certs/myregistry_key.pem<br/>  common_name: myregistry</span></pre><p id="5f35" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你在这方面遇到问题，只需复制CSR文件的内容并解码；请确保常用名是正确的。</p><figure class="mb mc md me fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/b992b8aa87108f2cbd8db25df6f4935e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*BPjhSpt28Y0IF0O0Z_3Zhg.png"/></div></figure><p id="d811" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一旦我们有了有效的CSR文件，我们就可以为我们的注册中心生成自签名证书:</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="8f85" class="ky ir hi mm b fi mq mr l ms mt">- name: Generate a Self Signed OpenSSL certificate for myregistry<br/>  openssl_certificate:<br/>    path: /tmp/myregistry/certs/myregistry_crt.crt<br/>    privatekey_path: /tmp/myregistry/certs/myregistry_key.pem<br/>    csr_path: /tmp/myregistry/certs/myregistry.csr<br/>    provider: selfsigned</span></pre><p id="4506" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">稍后，我们将新生成的证书复制到我们的<code class="du mw mx my mm b">/etc/pki/ca-trust/source/anchors</code>，并运行<code class="du mw mx my mm b">update-ca-trust extract</code> <em class="mu">。</em></p><p id="c48d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们为我们的注册中心添加相关的端口，以便正确地操作<code class="du mw mx my mm b">firewalld</code>策略，最后，我们用所有需要的附件和卷运行注册中心；</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="30c9" class="ky ir hi mm b fi mq mr l ms mt">- name: Create a registry container<br/>  containers.podman.podman_container:<br/>    name: myregistry<br/>    image: docker.io/library/registry:2<br/>    state: started<br/>    ports:<br/>      - 5000:5000<br/>    volume:<br/>      - /tmp/myregistry/data:/var/lib/registry:z<br/>      - /tmp/myregistry/auth:/auth:z<br/>      - /tmp/myregistry/certs:/certs:z<br/>    env:<br/>        REGISTRY_AUTH: "htpasswd"<br/>        REGISTRY_AUTH_HTPASSWD_REALM: "Registry"<br/>        REGISTRY_HTTP_SECRET: "ALongRandomSecretForRegistry"<br/>        REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd<br/>        REGISTRY_HTTP_TLS_CERTIFICATE: /certs/myregistry_crt.crt<br/>        REGISTRY_HTTP_TLS_KEY: /certs/myregistry_key.pem</span></pre><h2 id="a562" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">解释者</h2><ul class=""><li id="fce3" class="lm ln hi jq b jr js jv jw jz lo kd lp kh lq kl nh ls lt lu bi translated">使用图像:<code class="du mw mx my mm b">docker.io/library/registry:2</code></li><li id="946f" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl nh ls lt lu bi translated">通过主机上的端口<code class="du mw mx my mm b">5000/tcp</code>导出对注册服务<code class="du mw mx my mm b">(5000/tcp)</code>的访问</li><li id="40ee" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl nh ls lt lu bi translated">附上相关的卷</li></ul><ol class=""><li id="07f0" class="lm ln hi jq b jr km jv kn jz ni kd nj kh nk kl lr ls lt lu bi translated">主机上的<code class="du mw mx my mm b">/tmp/myregistry/data</code>将被装载到<code class="du mw mx my mm b">/var/lib/registry</code>，这是我们所有镜像映像最终将被保存的位置</li><li id="c066" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">主机上的<code class="du mw mx my mm b">/tmp/myregistry/auth</code>将被挂载到<code class="du mw mx my mm b">/auth</code>上，这样容器就可以访问<code class="du mw mx my mm b">htpasswd</code>文件，并且能够验证它从我们这里接收到的调用</li><li id="6eec" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">主机上的<code class="du mw mx my mm b">/tmp/myregistry/certs</code>将被安装到<code class="du mw mx my mm b">/certs</code>上，因此该容器将允许HTTPS访问它</li></ol><ul class=""><li id="bfdc" class="lm ln hi jq b jr km jv kn jz ni kd nj kh nk kl nh ls lt lu bi translated">配置所需的环境变量</li></ul><p id="a02b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最后但同样重要的是，我们将<code class="du mw mx my mm b">podman save</code> <em class="mu"> </em>作为我们的注册表基础映像；我们将把它<code class="du mw mx my mm b">(podman load)</code>导入到受限网络中，以便运行myregistry容器，其中包含操作员的所有图像。</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="1f7e" class="ky ir hi mm b fi mq mr l ms mt">- name: Podman save the registry image to tar<br/>  shell: "podman save &gt; registryimage.tar docker.io/library/registry:2"</span></pre></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="a580" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第2部分—roles/deploy-local-registry/tasks/generate-pull-secret . YAML</h2><p id="0626" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这个yaml文件中，我们正在运行与创建pull-secret.json文件相关的任务；这将有助于我们登录所有不同的注册表。</p><blockquote class="nl"><p id="a045" class="nm nn hi bd no np nq nr ns nt nu kl dx translated">请注意，您需要使用不同的令牌来编辑它。</p></blockquote><p id="cce3" class="pw-post-body-paragraph jo jp hi jq b jr nv jt ju jv nw jx jy jz nx kb kc kd ny kf kg kh nz kj kk kl hb bi translated"><strong class="jq hj">此处指定了所需的更改:</strong><a class="ae mf" href="https://github.com/tommeramber/ocp-automations/blob/main/Operator-Importing-for-Restricted-Networks/roles/deploy-local-registry/tasks/README.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tommeramber/OCP-automations/blob/main/Operator-Importing-for-Restricted-Networks/roles/deploy-local-registry/tasks/readme . MD</a></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="2b06" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第3部分—roles/deploy-local-registry/tasks/log in-to-external-registries . YAML</h2><p id="7e4b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个YAML由我们之前创建的pull-secret.json文件中指定的所有注册中心的<code class="du mw mx my mm b">podman login</code> <em class="mu"> </em>任务组成。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="50b8" class="iq ir hi bd is it mg iv iw ix mh iz ja jb mi jd je jf mj jh ji jj mk jl jm jn bi translated">角色2—安装所需工具</h1><p id="1a04" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个名字太字面了，老实说，我没有什么别的要说的了。</p><p id="f5ff" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">该角色yaml位于:<strong class="jq hj">roles/install-required-tools/tasks/main . yml</strong></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="9fde" class="iq ir hi bd is it mg iv iw ix mh iz ja jb mi jd je jf mj jh ji jj mk jl jm jn bi translated">角色3 —运行-自定义-索引-容器-镜像</h1><p id="a155" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">棘手的部分来了。</p><h2 id="2dd8" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第1部分-roles/run-custom-index-container-and-mirror/tasks/generate-custom-index-image . YAML</h2><p id="4bb6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们需要知道哪个索引图像提供了我们的操作符；您可以在这里看到不同的选项:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/430833ef54ee6723e458ce9b6d6979c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkdiu-uN5VT1dvr2o7zieQ.png"/></div></div></figure><p id="832c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您不确定，只需登录到一个已连接的Openshift环境，并为所需的操作员运行以下命令:</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="5688" class="ky ir hi mm b fi mq mr l ms mt">$ oc get packagemanifest -n openshift-marketplace | grep &lt;operator&gt;</span></pre><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ob"><img src="../Images/3f8ab8546af342214c41b230c574c413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwoxQWdABuUkYT7RIhjXHA.png"/></div></div></figure><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="f967" class="ky ir hi mm b fi mq mr l ms mt">$ oc describe packagemanifest &lt;desired_operator_name&gt; -n openshift-marketplace | grep "Catalog Source:"</span></pre><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oc"><img src="../Images/43a0b6bffa44fc26c2d63fa63f60adef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lj35c_BragHb078vmS38Bw.png"/></div></div></figure><p id="4d53" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">根据您的发现编辑OCP-automations/Operator-Importing-for-Restricted-Networks/playbook . YAML</strong>中的<em class="mu"> index_image </em>和<em class="mu">required _ Operator</em>ansi ble变量。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><ol class=""><li id="e504" class="lm ln hi jq b jr km jv kn jz ni kd nj kh nk kl lr ls lt lu bi translated">拉出相关的索引图像</li><li id="c5bf" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">运行它</li><li id="c07c" class="lm ln hi jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">抓住它提供的运营商包</li></ol><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="4038" class="ky ir hi mm b fi mq mr l ms mt">- name: Pull the Marketplace index image<br/>  containers.podman.podman_image:<br/>    name: registry.redhat.io/redhat/{{index_image}}-index:{{index_image_version}}<br/>    auth_file: /tmp/pull-secret.json</span><span id="cf46" class="ky ir hi mm b fi mv mr l ms mt">- name: Run the index image<br/>  containers.podman.podman_container:<br/>    name: "{{index_image}}-index"<br/>    image: registry.redhat.io/redhat/{{index_image}}-index:{{index_image_version}}<br/>    state: started<br/>    ports:<br/>      - 50051:50051</span><span id="d4c2" class="ky ir hi mm b fi mv mr l ms mt">- name: Run grpcurl to get the list of packages (Operators) available<br/>  shell: /usr/local/bin/grpcurl -plaintext myregistry:50051 api.Registry/ListPackages &gt; operators-packages.txt</span></pre><p id="981f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，我们使用所需的操作符名称过滤operators-packages列表——注意，如果我们的字符串有多个匹配项，那么只有第一个匹配项会出现。</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="178f" class="ky ir hi mm b fi mq mr l ms mt">- name: filtering for desired operators from the index list<br/>  shell: cat operators-packages.txt | grep "{{ required_operator }}" | sed 's/"//g'| awk '{print $2}' | head -n 1<br/>  register: filtering_result</span></pre><p id="cbf3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">之后，我们修剪原始列表并生成一个定制的索引图像，其中只包含我们想要的操作符。将新的索引图像保存在本地的<code class="du mw mx my mm b">my-{{index-image}}-index:v1</code>下</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="8d06" class="ky ir hi mm b fi mq mr l ms mt">- name: 'Prunning the original index image and generate a new one'<br/>  shell: "sudo /usr/local/bin/opm index prune -f registry.redhat.io/redhat/{{index_image}}-index:{{index_image_version}} -p {{ filtering_result.stdout }} -t my-{{index_image}}-index:v1"<br/>  register: prunning_output</span></pre><p id="6bf7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最后，使用auth.json(我们复制到另一个位置的pull-secret.json)删除旧的索引图像并将新的图像推送到我们的myregistry容器中；</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="ef03" class="ky ir hi mm b fi mq mr l ms mt">- name: Stop the original index container<br/>  containers.podman.podman_container:<br/>    name: "{{index_image}}-index"<br/>    state: absent</span><span id="51d8" class="ky ir hi mm b fi mv mr l ms mt">- name: Push new image to local registry<br/>  containers.podman.podman_image:<br/>    name: "my-{{index_image}}-index:v1"<br/>    push: yes<br/>    auth_file: /run/containers/0/auth.json<br/>    tag: v1<br/>    push_args:<br/>      dest: "myregistry:5000/myindeximages/my-{{index_image}}-index:v1"<br/>    validate_certs: no</span></pre><h2 id="5cb2" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第2部分-roles/run-custom-index-container-and-mirror/tasks/mirror-manifest-and-generate-mapping-file . YAML</h2><p id="17e7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">此时，我们可以开始镜像我们想要的操作员所需的映像清单</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="36fd" class="ky ir hi mm b fi mq mr l ms mt">- name: mirror the manifests of the required operators from the new, custom index image on myregistry<br/>  shell: sudo /usr/local/bin/oc adm catalog mirror myregistry:5000/myindeximages/my-{{index_image}}-index:v1 myregistry:5000 -a /run/containers/0/auth.json --manifests-only --insecure</span></pre><p id="d2dd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个命令将在我们当前的目录中创建一个新的目录，这个目录以我们的自定义索引图像命名，它应该包含我们稍后将使用的<code class="du mw mx my mm b">mapping.txt</code>文件和<code class="du mw mx my mm b">imageContentSourcePolicy.yaml</code>。</p><p id="e80c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这一部分以我们基于自动生成的映射文件创建一个新的映射文件结束。</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="9772" class="ky ir hi mm b fi mq mr l ms mt">- name: "Generate my_mapping.txt file."<br/>  shell: "cat my-{{index_image}}-index-manifests/mapping.txt | awk -F'=' '{print $1}' | awk -F'{{url_prefix.stdout}}' '{print $2}' &gt;&gt; my_mapping.txt"</span></pre><h2 id="a406" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">第3部分-roles/run-custom-index-container-and-mirror/tasks/sko peo-copy-the-relevant-images-and-compress . YAML</h2><p id="97c4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">基于我们新的映射文件，我们将生成包含更新后的<code class="du mw mx my mm b">skopeo copy</code>命令的<code class="du mw mx my mm b">run.sh</code>文件</p><pre class="mb mc md me fd ml mm mn mo aw mp bi"><span id="8407" class="ky ir hi mm b fi mq mr l ms mt">- name: Generate the Skopeo commands for mirroring the operators required images to your local registry<br/>  shell: cat my_mapping.txt | awk '{print "sudo skopeo copy --all --authfile=/run/containers/0/auth.json docker://{{url.stdout}}"$1" docker://myregistry:5000"$1 " --dest-tls-verify=false"}' &gt;&gt; run.sh</span></pre><p id="0189" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，剧本将所有相关数据(包括我们的操作员所需的图像)复制到一个目录中，并对其进行压缩，以便以后在受限网络中提取。</p><h1 id="8003" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">角色4—清理</h1><p id="f51b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们希望在系统上留下最少的剩余部分，并让系统做好再次运行剧本的准备，以防我们需要额外的操作员。</p><p id="7c2f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">位于:OCP-automations/Operator-Importing-for-Restricted-Networks/roles/clean up/tasks/main . yml</strong></p><h1 id="a2e3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">情况就是这样</h1><p id="9ac3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">只需在您运行剧本的同一个目录中运行<code class="du mw mx my mm b">ls</code>，您应该会看到<code class="du mw mx my mm b">data.tar.gz</code> —将其复制到可移动介质并导入受限网络。</p><p id="3bb5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另一篇后续文章即将发表。</p></div></div>    
</body>
</html>
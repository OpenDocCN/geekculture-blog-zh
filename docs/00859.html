<html>
<head>
<title>Should HTML Parsing in Browsers Be Standardized?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器中的HTML解析是否应该标准化？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/should-html-parsing-in-browsers-be-standardized-50f5012ae9f7?source=collection_archive---------29-----------------------#2021-03-15">https://medium.com/geekculture/should-html-parsing-in-browsers-be-standardized-50f5012ae9f7?source=collection_archive---------29-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案可能在现代浏览器的词法分析和解析与过去XHTML的僵化之间。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/99cde88dab09bccb2a41019bf6821854.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*T9RXSSxiUi9tLcRRwemURQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">A good HTML parser puts lipstick on a pig.</figcaption></figure><p id="cb25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在20世纪90年代早期图形web浏览器的出现中，Netscape Navigator做出了一个重要的决定——在像XHTML这样的更严格的推动下，它已经用HTML5模拟了我们今天所知道的互联网:</p><h1 id="ad6e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">他们认为浏览器实现的HTML解析器不能严格解析标记。</h1></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="bd61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ky">严格解析？这意味着什么呢？</em>当你访问一个网页时，HTML解析器有一项重要的工作。这些由数百万行C++代码组成的浏览器不仅利用HTTP来代表您请求资源，而且还要在您的屏幕上显示返回的内容——更具体地说，是在您的浏览器窗口中。</p><p id="550f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程看起来有点像下图</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/41805c1069e6e1cfdb3c22bba37fed0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*9pinlctdB1EPHlWZWgupkg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Note: this is a WebKit model but all modern browsers share the HTML parsing step.</figcaption></figure><p id="0db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何HTML文件形式的资源都是通过HTML解析器运行的，解析器构建了一个由称为节点的元素组组成的DOM树。一个单独的CSS解析器将样式应用于每个节点。布局过程准确地确定了每个节点在浏览器中的显示位置。最后，一幅内容丰富的画面出现在你所请求的网站的屏幕上。但是如果HTML文件是…嗯..<em class="ky">不好，语义HTML </em>？</p><p id="030a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不管怎样，这是有效的。</strong>没错——它确实有效。这些底层的HTML解析器已经变成了一种黑盒，它会接收无数行HTML，宽容地解释其中的所有错误，并且不管它是不是有效的标记，都会组装一个作为该标记结果的DOM树。也就是说，即使这个标记…</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="2124" class="lf ju hi lb b fi lg lh l li lj">&lt;html&gt;<br/>  &lt;mytag&gt;<br/>  &lt;/mytag&gt;<br/>  &lt;div&gt;<br/>  &lt;p&gt;<br/>  &lt;/div&gt;<br/>    Really lousy HTML<br/>  &lt;/p&gt;<br/>&lt;/html&gt;</span></pre><p id="1d26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…会工作得很好。</p><h1 id="1566" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">那么问题是什么呢？</h1><p id="cebd" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">在我看来，问题是HTML规范从来没有真正给出任何关于浏览器应该如何处理这些不同错误的硬性规则。在一个每个人都参与建设一个更好、更快的互联网的世界里，我认为我们忽略了一个事实，即解析标记是一个问题，原因有几个。</p><h2 id="9e4c" class="lf ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated">1.解析器本身需要解决这些错误，这并不总是容易做到的。看看WebKit关于错误处理的评论:</h2><blockquote class="mc md me"><p id="f724" class="if ig ky ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">“……我们必须至少注意以下错误情况:</p><p id="360a" class="if ig ky ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">被添加的元素在一些外部标签中被明确禁止。在这种情况下，我们应该关闭所有标签，直到禁止该元素的标签，然后再添加它。</p><p id="4cfa" class="if ig ky ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">我们不允许直接添加元素。可能是写文档的人忘记了中间的某个标签(或者中间的标签是可选的)。以下标签可能就是这种情况:HTML HEAD BODY TBODY TR TD LI(我忘记了什么吗？).</p><p id="0886" class="if ig ky ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">我们希望在内联元素中添加一个block元素。关闭所有行内元素，直到下一个更高的块元素。</p><p id="b7b4" class="if ig ky ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">如果这不起作用，请关闭元素，直到我们被允许添加元素——或者忽略标签。你有没有见过互联网发展到这样的地步…</p></blockquote><h2 id="b202" class="lf ju hi bd jv lp lq lr jz ls lt lu kd iq lv lw kh iu lx ly kl iy lz ma kp mb bi translated"><strong class="ak"> 2。由于浏览器之间没有标准化，不同的解析器可以用不同的方式解决这些错误。</strong></h2><p id="f5f8" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">让我们再来看一下前面的例子。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="47c2" class="lf ju hi lb b fi lg lh l li lj">&lt;html&gt;<br/>  &lt;mytag&gt;<br/>  &lt;/mytag&gt;<br/>  &lt;div&gt;<br/>  &lt;p&gt;<br/>  &lt;/div&gt;<br/>    Really lousy HTML<br/>  &lt;/p&gt;<br/>&lt;/html&gt;</span></pre><p id="533c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于每种主流的现代浏览器对这些日益复杂的解析器都有不同的实现，人们可能会将上面的标记与此相协调:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="5f10" class="lf ju hi lb b fi lg lh l li lj">&lt;div&gt;<br/>  &lt;p&gt;<br/>    Really lousy HTML<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="a36c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…另一个，这个:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="0f91" class="lf ju hi lb b fi lg lh l li lj">&lt;p&gt;<br/>  Really lousy HTML<br/>&lt;/p&gt;</span></pre><p id="e975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…第三，这个:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="44b4" class="lf ju hi lb b fi lg lh l li lj">Really lousy HTML</span></pre><p id="153a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…完全没有包装标签！因为是由浏览器来决定最终产品应该是什么，这增加了开发人员和用户在浏览器之间的不一致性。</p><h1 id="6265" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.它是懒惰的，并且没有朝着更好、更快的互联网努力</h1><p id="9295" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">HTML5侧重于语法特性和语义元素、对SVG的支持以及其他改进中的新属性。他们甚至就<a class="ae mi" href="https://www.w3.org/TR/2011/WD-html5-20110113/parsing.html" rel="noopener ugc nofollow" target="_blank">如何在解析器</a>中解决错误提出了一些建议。我们非常愿意建立一个更好、更快的互联网，但在我看来，通过重新审视我们在标记中的僵化和控制，使互联网标准化，并在我们为web应用程序创建的结构中，使从语义html到可访问性功能的一切都成为一种要求，而不是一种功能，可以做出巨大的改进。</p></div></div>    
</body>
</html>
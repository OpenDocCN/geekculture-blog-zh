<html>
<head>
<title>How to securely save passwords in the databases ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在数据库中安全地保存密码？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-securely-save-passwords-in-the-databases-fc5e9890c4b2?source=collection_archive---------18-----------------------#2022-09-30">https://medium.com/geekculture/how-to-securely-save-passwords-in-the-databases-fc5e9890c4b2?source=collection_archive---------18-----------------------#2022-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据库中保存用于用户认证的密码是许多应用程序中的常见用例。我一直想知道我们是如何做到这一点的，以及我们如何确保即使我们的数据库遭到破坏，我们也不会将用户置于风险之中。因此，我做了一些研究，了解了当前我们在数据库中保存密码时为实现安全性而遵循的做法。这是我的学习..</p><p id="00bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您一定已经猜到了，密码不是以纯文本格式保存的，因为如果数据库遭到破坏，密码也很容易被破坏。这里更大的威胁是用户可能对其他应用程序或帐户使用相同的密码。这有可能给我们的用户带来更大的风险。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="e722" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了安全地保存密码，我们使用<code class="du jk jl jm jn b">Hashing</code>算法。</p><h1 id="628a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">哈希是什么？</h1><p id="c508" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">哈希是将输入文本转换为特定字节大小的随机文本的过程。现在，散列的美妙之处在于，生成的随机文本不能回溯到输入文本中。</p><p id="3e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于散列的另一件事是，相同的输入文本在散列时将总是生成相同的特定字节大小的随机文本。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/336b98114c4ada883463f6fca905efbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aABhXI6d4vaiVs9NnAOlbg.png"/></div></div></figure><p id="3095" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如上图中，<strong class="ih hj"> ABC </strong>哈希后总会给<strong class="ih hj"> XYZ </strong>。并且<strong class="ih hj"> XYZ </strong>不能回溯到<strong class="ih hj"> ABC </strong>。</p><p id="e911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以使用几种散列算法，并将密码以散列格式保存在数据库中。</p><p id="78a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将确保即使数据库遭到破坏，黑客也不可能知道实际的密码是什么。</p><p id="63f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们如何验证用户在认证过程中输入的实际密码？</strong></p><ol class=""><li id="42fd" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">我们使用在数据库中保存密码时使用的相同散列算法对用户输入的密码进行散列。</li><li id="1fd7" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">我们将计算出的密码散列与保存在数据库中的散列进行比较。如果匹配，用户就通过了身份验证。</li></ol></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="6ccb" class="jo jp hi bd jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh lv kj kk kl bi translated">就这样吗？我们只是散列密码，我们是安全的！….不，不是真的。</h1><p id="210d" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">由于被称为<code class="du jk jl jm jn b">Dictionary Attack</code>的攻击，被泄露的散列密码仍然是一个威胁。</p><p id="4108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，在这种攻击中，黑客<strong class="ih hj">在查找表</strong> (map)中存储大量纯文本密码和它们的散列，作为键-值对，其中<strong class="ih hj">键是散列密码，值是纯密码。</strong></p><p id="5e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，查找表看起来像这样。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lw"><img src="../Images/e1dc4d5e4c5f5c9c1ad029318fb08634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MuthQFqTaDf-_TA0sjI5g.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Dictionary Attack</figcaption></figure><p id="c198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，正如您可能已经猜到的那样，如果散列密码“XYZ”遭到破坏，最终实际的普通密码“ABC”也会由于这种字典攻击而遭到破坏。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="150b" class="jo jp hi bd jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh lv kj kk kl bi translated">该死……那么我们该如何解决这个问题呢？</h1><p id="3cb3" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">帮助黑客破解明文密码的关键是<strong class="ih hj">查找表</strong>。为了创建这个查找表，黑客必须散列大量随机的纯文本字符串，并将它们保存为键值对。</p><p id="be58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使是大量的字符串，在最新技术的帮助下，创建这个查找表也不会花费太多时间。</p><p id="e4fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">但是，如果我们在数据库中保存密码时使用的哈希算法耗费大量资源且速度缓慢，该怎么办？</strong></p><p id="574c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用这种缓慢且资源密集的散列算法，那么对于黑客来说，创建这个巨大的查找表将是<strong class="ih hj">近乎不可能的</strong>。</p><p id="8857" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">因为，使用资源密集型散列算法来散列大量的纯文本字符串将会花费很长时间。</strong></p><p id="93a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这就是我们如何确保即使我们的散列密码被泄露，也不会有问题。</p><p id="81ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几种缓慢且资源密集的算法。Bcrypt哈希算法就是其中之一。</p><p id="fafb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们如何在数据库中安全地存储密码。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Java Backend Developer Interview Questions (Pt. 1–10)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java后端开发人员面试问题(Pt。1–10)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-backend-developer-interview-questions-pt-1-10-1c74c76442bd?source=collection_archive---------1-----------------------#2021-12-16">https://medium.com/geekculture/java-backend-developer-interview-questions-pt-1-10-1c74c76442bd?source=collection_archive---------1-----------------------#2021-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c1ff53808b27f9baab363902fee06e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4hlVr1Rhy5h2lLmzq6gXw.jpeg"/></div></div></figure><p id="06bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。JVM的作用是什么？</strong> <br/> JVM是Java虚拟机的简称。它为Java代码提供了一个运行时环境。它确保Java只需编译一次，就可以在任何地方运行，而不用考虑操作系统和处理器。</p><p id="869c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。Java源代码的编译过程如何？</strong> <br/> Java源代码经过源代码开发- &gt;词法分析器- &gt;语法分析器- &gt;语义分析器- &gt;字节码生成器。</p><p id="1dfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。JVM的结构是怎样的？</strong> <br/> JVM主要由三个子系统组成:类加载器子系统、运行时数据区和执行引擎(详见下图)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/67b560a43ec38b8bf609ed7326af8965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*d3iiqc2AFfphG-fN4Xictg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx"><a class="ae jx" href="https://dzone.com/articles/jvm-architecture-explained" rel="noopener ugc nofollow" target="_blank">https://dzone.com/articles/jvm-architecture-explained</a></figcaption></figure><p id="2272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。在JVM运行时数据区，多线程之间共享的组件是什么？<br/> </strong>方法区在线程间共享。堆区存储全局变量、对象实例和可以在应用程序中任何地方访问的东西。所以堆区也是共享空间。由于每个线程都有不同的调用方法和变量，所以存储线程内的方法和局部变量的堆栈区域是不共享的。PC寄存器跟踪关于线程应该如何进行的命令，因此它对于每个线程也是独立的。本机方法堆栈类似于堆栈区域，也包含局部变量和方法。因此本机方法堆栈不能在多个线程之间共享。</p><p id="aaf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。Java中线程之间的通信方式有哪些？<br/> </strong> 1)共享内存<br/> volatile关键字，synchronized关键字</p><p id="94e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2)等待和通知机制<br/> wait()和notify()是Java对象的方法。wait()方法使对象从运行状态转换到阻塞状态。一旦满足某个条件，另一个线程将调用notify()方法来唤醒第一个线程，并让它进入可运行状态。</p><p id="32c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3)锁/条件机制<br/>锁是Java提供的类，用来限制对一个对象的访问。锁类调用了条件。一个锁可以创建多个条件。使用Condition.await()和Condition.signal()方法，我们可以让一个线程休眠或者唤醒一个线程来完成它的工作。</p><p id="2a84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 6。什么是易变和同步关键词？<br/> </strong> Volatile关键字针对一个字段，或者一个方法中的一个变量，这样当多个线程访问同一个变量时，保证了数据的一致性。这是通过强制通过主内存而不是高速缓存访问变量来实现的。</p><p id="6230" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Synchronized关键字用于代码块。它只允许一个线程在给定的时间点访问资源。当一个线程正在操作资源时，不允许其他想要访问同一对象的线程执行。</p><p id="3deb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7 .<strong class="is hj">。volatile和synchronized有什么区别？<br/> </strong> Volatile是轻量级锁，而synchronized是重量级锁。在同步块写入/修改资源后，变量值被刷新回共享内存空间。这会导致并发问题，因为受同步保护的同一对象上的线程不能并发执行。相比之下，volatile允许多个线程并发执行，强制它们直接从主内存而不是CPU缓存中读取变量。此外，同步是基于操作系统实现的，这导致线程进入内核模式，而不是用户模式，这是一个耗时的过程。</p><p id="ffc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 8。ThreadLocal有什么用？<br/>T5【thread local】是一种保证线程安全的机制。它允许开发人员存储与特定线程相关的变量，这样多个线程就不需要访问共享变量，从而避免对数据一致性造成危害。<br/>每个<em class="jy">线程</em>类都有一个名为<em class="jy"> threadLocals </em>的字段，类型为<em class="jy"> ThreadLocal。ThreadLocalMap </em>。<em class="jy"> threadLocals </em>的键是对当前ThreadLocal的引用，值是开发者想要存储的变量(T类类型)。要写入或读取变量，需要调用ThreadLocal.get()或set()方法。</strong></p><p id="baa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 9。Java中的反射是什么？<br/> </strong> Java是一种静态语言。Java中的反射赋予了程序自省的能力，使其更具动态性。它允许开发者在运行时检查或修改方法、类或接口的行为。</p><p id="e609" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 10。为什么HashMap是线程不安全的？<br/> </strong> 1)来自多个线程的多次put可能导致元素<br/>的丢失2)当put和get并发执行时，get的返回值可能为空。当线程放置的元素超过阈值时会发生这种情况，导致重新散列操作，get方法将导致空值。<br/>3)JDK 1.7中的并发put可能会导致循环链表导致get中出现无限循环。为了确保线程安全，请使用ConcurrentHashMap。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="fdbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章对你有所帮助。如果你像我一样渴望学习一些与技术相关的东西，或者定期反思工作和生活，请关注我的频道，了解我日常工作和生活中的最新灵感。</p><p id="63a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">相关</strong> : <br/> <a class="ae jx" rel="noopener" href="/@wdn0612/java-backend-developer-interview-questions-pt-11-20-edd176b5c425"> Java后端开发者面试问题(Pt。11–20)</a><br/><a class="ae jx" rel="noopener" href="/@wdn0612/java-backend-developer-interview-questions-pt-21-30-b6c227d1b3c9">Java后端开发者面试问题(Pt。21–30)</a><br/><a class="ae jx" rel="noopener" href="/@wdn0612/java-backend-developer-interview-questions-pt-31-40-c81245b322dc">Java后端开发者面试问题(Pt。31–40)</a></p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="00df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">演职员表:<br/><a class="ae jx" href="https://www.bilibili.com/video/BV1634y1d7nJ" rel="noopener ugc nofollow" target="_blank">https://www.bilibili.com/video/BV1634y1d7nJ</a><br/><a class="ae jx" href="https://github.com/lokles/Web-Development-Interview-With-Java" rel="noopener ugc nofollow" target="_blank">https://github . com/lok les/we B- Development-Interview-With-Java</a></p></div></div>    
</body>
</html>
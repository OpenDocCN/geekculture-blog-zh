<html>
<head>
<title>Understanding correctly that messy keyword ‘const’ in C++ (I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确理解C++ (I)中杂乱的关键字“const”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-i-62f210291247?source=collection_archive---------19-----------------------#2021-06-10">https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-i-62f210291247?source=collection_archive---------19-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ffeec33b9993f671d6c9e3429ed46243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUZ0_4h5F34WhEIQMVWJGw.jpeg"/></div></div></figure><div class=""/><h1 id="0d17" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">第一部分:常量类型。</h1><h2 id="c4ed" class="jo ir ht bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">在C++中，限定符“const”指定了一个编译时约束，即对象或变量不能被修改。编译器验证对象或变量永远不会改变，并在您试图修改或重新分配它时阻止您。然而，编写“const”正确的代码比仅仅在一些行中使用关键字，然后让编译器找出什么有意义要有挑战性得多。在这个由三部分组成的指南中，你会得到一些如何正确使用它的提示。</h2><p id="83c2" class="pw-post-body-paragraph kf kg ht kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">在我作为C++程序员的早期，我并没有太关注关键字'<em class="la"> const </em>'。当我沉浸在PASCAL和Delphi编程中时，我甚至没有太注意常量，可能是因为我仍然依赖于我基础时代的一些习惯。所以对我来说，C++ ' <em class="la"> const </em>'是一些深奥的限定词，并不代表太多的兴趣或价值。如果我定义了一个只在函数体内部使用的变量(我确信没有什么能改变它)，为什么要费心把它变成常量呢？此外，C++有非常笨拙和看起来很难的用法'<em class="la"> const </em>'，不值得我在最初的学习曲线中发现它们的含义。这里有一个有趣的例子:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="e611" class="jo ir ht lg b fi lk ll l lm ln">//The Most Constant Method<br/>const int *const TMCMethod (const int *const&amp; value) const</span></pre><p id="a261" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">如果你感到困惑，不要担心！我保证我们会一步一步解决。尽管这有点困难，但它并不像那句名言那样让大多数C/C++程序员头脑发热。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2c90" class="jo ir ht lg b fi lk ll l lm ln">// declare f as array of pointer to function returning pointer <br/>// to function returning void<br/>void (*(*f[])())()</span></pre><p id="176d" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">那么…你准备好了吗？让我们从基础开始。首先要知道的是，当你声明任何变量或对象时，限定词'<em class="la">const【T7]'可以写在类型的前面或后面。</em></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2c07" class="jo ir ht lg b fi lk ll l lm ln">int const anIntegerConstant = 5;</span></pre><p id="71bd" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">所以上面的代码行对编译器来说与下面的代码行完全一样:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c745" class="jo ir ht lg b fi lk ll l lm ln">const int anIntegerConstant = 5;</span></pre><p id="6532" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">好的。这并不难，对吧？上面的规则适用于任何你想保持不变的东西，包括数组。所以，下面几行对编译器来说意义完全相同:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="d1a8" class="jo ir ht lg b fi lk ll l lm ln">// This style could be confusing<br/>int const anIntegerConstantArray[] = {3,5,4,1,2};<br/> </span><span id="f5cb" class="jo ir ht lg b fi lt ll l lm ln">// The style I prefer to use<br/>const int anIntegerConstantArray[] = {3,5,4,1,2};</span></pre><p id="0944" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">但是，为了清楚起见，我总是把关键字'<em class="la"> const </em>'放在前面。这就是我从现在开始要保持的代码风格。</p><p id="ebe4" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">让我们进入下一个阶段。您可以声明指向常量类型的变量指针:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7f63" class="jo ir ht lg b fi lk ll l lm ln">int varValue = 5;<br/>const int *aConstant = &amp;varValue;</span></pre><p id="cb9f" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">当然，参考值是否为常数并不重要:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8495" class="jo ir ht lg b fi lk ll l lm ln">const int constantValue = 5;<br/>const int *aConstant = &amp;constantValue;</span></pre><p id="a249" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">您甚至可以拥有一个指向常量类型的常量数组，并递增指针:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="5910" class="jo ir ht lg b fi lk ll l lm ln">const int anIntegerConstantArray[] = {3,5,4,1,2}; <br/>const int *aConstant = anIntegerConstantArray;</span><span id="11ef" class="jo ir ht lg b fi lt ll l lm ln">// Prints 3 and then increments the pointer<br/>std::cout &lt;&lt; aConstant++ &lt;&lt; std::endl;</span><span id="3490" class="jo ir ht lg b fi lt ll l lm ln">// Prints 5<br/>std::cout &lt;&lt; aConstant &lt;&lt; std::endl;</span></pre><p id="d192" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">但是，如果指向一个常量类型，即使指针是可变的，也不可能使用解引用操作符来改变它所指向的值。您将得到一个编译器错误，因为您试图在只读位置进行赋值:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8acf" class="jo ir ht lg b fi lk ll l lm ln">const int constantValue = 5;<br/>const int *aConstant = &amp;constantValue;</span><span id="c1a7" class="jo ir ht lg b fi lt ll l lm ln">// This line will not compile<br/>*aConstant = 8;</span></pre><p id="3bbf" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">也可以声明一个指向变量类型的常量指针。存储在指针中的地址本身是不变的，所以指针在声明时必须被初始化。即使以后可以更改它所指向的值，也不可能更改地址本身:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8136" class="jo ir ht lg b fi lk ll l lm ln">int varValue = 5;<br/>int anotherValue = 6;<br/>int *const aConstantPointer = &amp;varValue;</span><span id="4422" class="jo ir ht lg b fi lt ll l lm ln">// This line will compile<br/>*aConstantPointer = 8;</span><span id="77e1" class="jo ir ht lg b fi lt ll l lm ln">// This line will not compile</span><span id="ba9f" class="jo ir ht lg b fi lt ll l lm ln">aConstantPointer = &amp;anotherValue;</span><span id="df5b" class="jo ir ht lg b fi lt ll l lm ln">// Also invalid<br/>aConstantPointer++;</span></pre><p id="8f80" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">最后，您可以声明一个指向常量类型的常量指针。由于存储的地址是常数，指针需要在声明中初始化。以后，就不可能更改它所指向的值，也不可能更改地址:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="99d4" class="jo ir ht lg b fi lk ll l lm ln">int varValue = 5;<br/>int anotherValue = 6;<br/>const int *const aConstantPointerToConstant = &amp;constantValue;</span><span id="b530" class="jo ir ht lg b fi lt ll l lm ln">// This line will not compile<br/>*aConstantPointerToConstant = 8;<br/>   <br/>// This line will also not compile<br/>aConstantPointerToConstant = &amp;anotherValue;</span><span id="e951" class="jo ir ht lg b fi lt ll l lm ln">// Also invalid<br/>aConstantPointerToConstant++;</span></pre><p id="95ea" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">好了，到目前为止，我们已经解决了文章开头那个古怪例子的前半部分。在我们结束之前，还有最后一件事要考虑。使用常量转换可以抛弃常量。它们的工作方式与C++中的常规类型转换非常相似，只是它们不能在类型之间进行转换，也不能向下转换类的层次结构。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="03b3" class="jo ir ht lg b fi lk ll l lm ln">const char *x = "abcdefg";</span><span id="5b68" class="jo ir ht lg b fi lt ll l lm ln">char *x2 = const_cast&lt;char *&gt;(x) ;</span></pre><p id="27ce" class="pw-post-body-paragraph kf kg ht kh b ki lo kk kl km lp ko kp jv lq kr ks jy lr ku kv kb ls kx ky kz hb bi translated">然而，有一个更好的改变常量变量的方法，我将在第二部分向你展示，在那里我们将探索如何在一个类的方法中使用常量。暂时就这样吧！直到下一个，编码快乐！</p></div></div>    
</body>
</html>
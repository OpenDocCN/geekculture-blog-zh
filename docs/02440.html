<html>
<head>
<title>Building a Token Refresh service for the Fitbit API with Azure Functions and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Azure函数和C#为Fitbit API构建令牌刷新服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-token-refresh-service-for-the-fitbit-api-with-azure-functions-and-c-55027bf9d267?source=collection_archive---------10-----------------------#2021-05-15">https://medium.com/geekculture/building-a-token-refresh-service-for-the-fitbit-api-with-azure-functions-and-c-55027bf9d267?source=collection_archive---------10-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ea53" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们可以用一个简单的定时器触发函数生成一个刷新和访问令牌，以编程方式调用Fitbit API。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6129ce262e2c76d5044d607e2fe973b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7buUKC2UX8lxrCtLgXhug.png"/></div></div></figure><p id="9630" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为我个人发展的一部分，我正在Azure中建立自己的个人健康平台。我喜欢记录各种不同的健康指标，比如日常活动、食物摄入量和睡眠模式。为了收集这些数据，我使用了Fitbit Ionic。</p><p id="08fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在过去，我习惯于下载一个每月的CSV文件，并对其进行一些基本的分析。这有点乏味，因为在我可以做任何事情之前，我必须手动清理数据。这花费了我不想浪费的时间，所以我想创建一个管道，只调用Fitbit API来检索我的数据，而不必自己手动清理文件。</p><p id="1a75" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用Fitbit API相对简单。具有挑战性的部分可能是确保我们的更新令牌和访问令牌不会过期。默认情况下，这些将在8小时后过期。</p><p id="4ed0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">幸运的是，我们可以使用Azure函数计时器触发器来请求新的访问令牌，并使用Azure Key Vault来安全地存储这些令牌。本文将向您展示如何使用Azure函数和Key Vault刷新Fitbit API的访问令牌。</p><p id="42ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这个例子主要关注Fitbit API，但是您可以将这个方法应用于其他API键。</p><p id="a942" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">刷新令牌和访问令牌如何为Fitbit API工作</strong></p><p id="8a87" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Fitbit使用OAuth 2.0对用户进行授权，并通过Fitbit API的认证。OAuth 2.0框架需要我们的应用程序调用Fitbit API来获取访问令牌。这用于向API发出HTTPS请求。</p><p id="f592" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Fitbit支持授权码授权和隐式授权流。对于我的项目，我使用授权代码授权流。这是使用应用程序的客户端机密进行服务器到服务器通信的推荐选项。</p><p id="03a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用授权码授权流，用户将同意与具有一些或所有范围的应用程序共享他们的Fitbit数据。当同意后，Fitbit会给我们一个授权码，作为回叫URL的一部分。我们的应用程序将此代码交换一个访问和刷新令牌(我们将存储在密钥库中)。</p><p id="0537" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">默认情况下，这些令牌将过期。刷新令牌用于获得对新的访问和刷新令牌的访问。刷新令牌只能使用一次，因此我们需要在重新生成这些令牌时，将新的访问令牌和刷新令牌对存储在密钥库中。</p><p id="081f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您想了解如何在Fitbit中设置应用程序，获取客户端id和客户端密码，并生成授权码，以便能够生成刷新和访问令牌，我强烈推荐您观看下面的视频(本期视频为Franchyze923大喊！超级有帮助！)</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="4b7d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">介绍我们的功能</strong></p><p id="f524" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦你看了那个视频，你应该有一个客户端id，客户端密码和一个base64编码的字符串，你的客户端id和密码用冒号连接(不知道我在说什么？再看一遍视频😉)</p><p id="cbfb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要将它与我们之前生成的刷新令牌一起存储在我们的密钥库中。</p><p id="d61d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在深入研究代码之前，让我们看看这个函数端到端地试图做什么。查看下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kh"><img src="../Images/133cfef169803c5332946f50f0d22762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*yQ_rATrFyy_1virySw_lPw.png"/></div></figure><p id="c4ee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每隔6小时，我们要启动一个刷新令牌的过程。我们可以增加刷新令牌的频率，但6小时对我来说已经足够了。当我们启动这个函数时，我们希望调用Fitbit API来刷新我们的令牌。</p><p id="9a92" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，我需要我现有的刷新令牌以及我的Fitbit凭证，我已经将它们作为秘密存储在Key Vault中。一旦我们有了这些，我们需要使用我们的令牌和凭证向Fitbit API发出请求，以生成新的令牌。</p><p id="8132" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦我们有了令牌，我们希望将它们保存在Key Vault中，这样下次我们调用函数来再次刷新令牌时，我们将使用更新后的值。</p><p id="ff03" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们深入研究一下代码，让这一点更清楚。</p><p id="e805" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">使用HTTP客户端拨打电话</strong></p><p id="f570" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要调用Fitbit API，我们可以使用HttpClient库！为了请求新的刷新令牌，我们需要进行以下API调用:</p><pre class="iy iz ja jb fd ki kj kk kl aw km bi"><span id="7488" class="kn ko hi kj b fi kp kq l kr ks">POST https://api.fitbit.com/oauth2/token<br/>Authorization: Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=<br/>Content-Type: application/x-www-form-urlencoded<br/><br/>client_id=22942C&amp;grant_type=authorization_code&amp;redirect_uri=https%3A%2F%2Fexample.com%2Ffitbit_auth&amp;code=&lt;somecode&gt;</span></pre><p id="7712" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用HttpClient库来构建POST请求，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kt kg l"/></div></figure><p id="a268" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本课程中，我们将做以下工作:</p><ul class=""><li id="e8e4" class="ku kv hi jl b jm jn jp jq js kw jw kx ka ky ke kz la lb lc bi translated">从密钥库中检索我们现有的刷新令牌和Fitbit凭据。(我使用密钥库C# SDK的包装器简化了这些调用)。</li><li id="85b3" class="ku kv hi jl b jm ld jp le js lf jw lg ka lh ke kz la lb lc bi translated">清除我们的请求头，定义我们希望向其发出POST请求的URI，然后将查询参数定义为该URI的一部分。我们需要在这里使用我们的刷新令牌。</li><li id="5fa4" class="ku kv hi jl b jm ld jp le js lf jw lg ka lh ke kz la lb lc bi translated">将请求定义为对我们的URI的POST请求。</li><li id="92a2" class="ku kv hi jl b jm ld jp le js lf jw lg ka lh ke kz la lb lc bi translated">将内容设置为空字符串，将标题和内容类型设置为使用“application/x-www-form-urlencoded ”,将我们的AuthorizationHeaderValue设置为使用基本身份验证并传入我们的Fitbit凭据。</li><li id="2df3" class="ku kv hi jl b jm ld jp le js lf jw lg ka lh ke kz la lb lc bi translated">然后，我们发出POST请求，确保它成功，并在返回之前将我们的响应反序列化为RefreshTokenResponse对象。</li></ul><p id="b034" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">RefreshTokenResponse是我创建的一个自定义类，因此我可以将它用作返回类型。其定义如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kt kg l"/></div></figure><p id="3d42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此类应该有助于将以下示例响应反序列化为强类型:</p><pre class="iy iz ja jb fd ki kj kk kl aw km bi"><span id="ce33" class="kn ko hi kj b fi kp kq l kr ks">{<br/>  "access_token": "eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MzAzNDM3MzUsInNjb3BlcyI6Indwcm8gd2xvYyB3bnV0IHdzbGUgd3NldCB3aHIgd3dlaSB3YWN0IHdzb2MiLCJzdWIiOiJBQkNERUYiLCJhdWQiOiJJSktMTU4iLCJpc3MiOiJGaXRiaXQiLCJ0eXAiOiJhY2Nlc3NfdG9rZW4iLCJpYXQiOjE0MzAzNDAxMzV9.z0VHrIEzjsBnjiNMBey6wtu26yHTnSWz_qlqoEpUlpc",<br/>  "expires_in": 3600,<br/>  "refresh_token": "c643a63c072f0f05478e9d18b991db80ef6061e4f8e6c822d83fed53e5fafdd7",<br/>  "token_type": "Bearer",<br/>  "user_id": "26FWFL"<br/>}</span></pre><p id="0a15" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们有了新的访问令牌和刷新令牌，我们可以将它们保存到密钥库。</p><p id="6168" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">在钥匙库里保存我们的秘密</strong></p><p id="9b27" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要保存我们的刷新和访问令牌，我们只需执行以下操作:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kt kg l"/></div></figure><p id="5e58" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我将传递我们的RefreshTokenResponse对象，该对象是我之前在RefreshTokenService类中获得的，然后使用之前的相同包装器将RefreshToken和AccessToken保存到密钥库中。</p><p id="f08d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">端到端完成功能</strong></p><p id="8797" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我已经将这两个组件分成了各自的类。经过一些整理，这是可能的，但是希望这个例子很容易理解。我们现在可以将这些服务注入到我们的功能中，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kt kg l"/></div></figure><p id="c683" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">结论</strong></p><p id="f92c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">手动生成新的刷新令牌会很麻烦。幸好有了Azure函数定时器触发器，我们可以按计划生成令牌。通过将访问令牌存储在Key Vault中，我们可以在需要调用Fitbit API时检索令牌。</p><p id="91cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这个例子主要关注Fitbit API，但是希望您可以将这个例子应用到其他需要您在需要时刷新访问令牌的服务中。</p><p id="bf34" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您想查看这个示例的代码库，可以在这里查看:</p><div class="li lj ez fb lk ll"><a href="https://github.com/willvelida/MyHealth.Auth.RefreshToken" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">willvelida/MyHealth。授权刷新令牌</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">为willvelida/MyHealth做贡献。Auth.RefreshToken开发通过在GitHub上创建一个帐户。</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz jh ll"/></div></div></a></div><p id="5456" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">希望你喜欢这篇文章。如果您有任何问题或意见，请随时在下面发表评论或在<a class="ae ma" href="https://twitter.com/willvelida" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我。</p></div></div>    
</body>
</html>
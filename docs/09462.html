<html>
<head>
<title>Automating ML Workflow using DVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DVC自动化ML工作流</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/automating-ml-workflow-using-dvc-a649efd43e30?source=collection_archive---------10-----------------------#2021-12-12">https://medium.com/geekculture/automating-ml-workflow-using-dvc-a649efd43e30?source=collection_archive---------10-----------------------#2021-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f2be" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实践教程</h2></div><h1 id="fa0c" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="828a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我在之前的<a class="ae kl" rel="noopener" href="/@thanakornpanyapiang/3-reasons-why-you-should-automate-your-machine-learning-workflow-9b59b4a0aa6">帖子</a>中解释了自动化ML工作流如何有利于ML开发人员的生产力。在本文中，我将一步一步地展示如何使用名为DVC的开源工具做到这一点。</p><p id="c9fa" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们开始吧！</p><h1 id="a433" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">项目详细信息</h1><p id="30ff" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们将建立一个工作流程，用于训练语义分割模型来识别图像中的云。本项目的数据集来自于Q. Li，W. Lu，J. Yang 的论文<em class="kr">A Hybrid Thresholding Algorithm for Cloud Detection on Ground-Based Color Images】</em>，该论文可从github知识库 <em class="kr">下载。</em>这里是我们希望从训练好的模型中得到的一些样本输出。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/92c364d6165604d178f3db99296c5346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FneB8j_fcFJH-bSeghQMg.jpeg"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Samples of final results.</figcaption></figure><p id="3e4f" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">构建模型的工作流程分为以下4个阶段:</p><ol class=""><li id="7233" class="li lj hi jr b js km jv kn jy lk kc ll kg lm kk ln lo lp lq bi translated"><strong class="jr hj">数据预处理</strong>:数据集中的图像大小不同。为了使模型训练更有效，我们将把它们分成大小相等的小块。</li><li id="d1b6" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk ln lo lp lq bi translated"><strong class="jr hj">数据验证</strong>:拆分后有很多面片是无云的。我们将只选择有大量云的图像，这样数据集就不会被负类淹没。此外，在这一阶段，我们将把所有图像分为训练集、验证集和测试集。</li><li id="6939" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk ln lo lp lq bi translated"><strong class="jr hj">模型训练</strong>:我们将训练一个深度学习模型来对图像中的云像素进行分类。在这个项目中，我们使用的模型是UNet。</li><li id="9130" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk ln lo lp lq bi translated"><strong class="jr hj">模型验证:</strong>我们将测量一些性能指标，看看模型的表现如何。</li></ol><p id="ef91" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">该项目由4个Python脚本组成，其中每个脚本分别代表工作流的一个阶段，如下所示:</p><ul class=""><li id="d93f" class="li lj hi jr b js km jv kn jy lk kc ll kg lm kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">split_image</strong>.<strong class="jr hj">py</strong></code></li><li id="abc7" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">select_image.py</strong></code></li><li id="6833" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">train_model.py</strong></code></li><li id="7d77" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">eval.py</strong></code></li></ul><p id="5447" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">脚本的所有参数都在如下的<code class="du lx ly lz ma b">params.yaml</code>中。</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="5958" class="mf iy hi ma b fi mg mh l mi mj">preprocessing:<br/>  patch_height: 128<br/>  patch_width: 128<br/>  min_cloud_ratio: 0.05<br/>  val_ratio: 0.1<br/>  test_ratio: 0.2</span><span id="58b4" class="mf iy hi ma b fi mk mh l mi mj">model:<br/>  n_classes: 1<br/>  in_channels: 3</span><span id="b6b3" class="mf iy hi ma b fi mk mh l mi mj">training:<br/>  batch_size: 16<br/>  n_epochs: 10<br/>  optimizer: Adam<br/>  lr: 0.001</span></pre><p id="da28" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这个项目的代码在这个<a class="ae kl" href="https://github.com/thanakorn/cloud_segmentation/tree/v1" rel="noopener ugc nofollow" target="_blank">仓库</a>里。</p><p id="f424" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">传统上，您必须逐个手动运行每个脚本。但是，这是非常低效的。我们希望有一个单一的命令来为我们做所有的事情，而且它应该比简单地运行所有的事情更智能。例如，如果模型参数被更新，它应该知道只有<code class="du lx ly lz ma b">train_model.py</code>和<code class="du lx ly lz ma b">eval.py</code>需要运行，因为这种变化与数据预处理无关。</p><h1 id="9135" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">该工具</h1><p id="1d19" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们用来自动化工作流程的工具是DVC。首先，您必须在您的项目中安装并启动它，这很简单，只需使用以下命令。一旦完成，你就可以开始了(如果你想学习DVC的基础知识，看看这个<a class="ae kl" rel="noopener" href="/@thanakornpanyapiang/data-versioning-with-dvc-a474af1247f5">帖子</a>):</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="92b4" class="mf iy hi ma b fi mg mh l mi mj">pip install dvc<br/>dvc init</span></pre><p id="19ba" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">然后，你必须创建<code class="du lx ly lz ma b">dvc.yaml</code>文件，其格式如下:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ml"><img src="../Images/208e5fe7b0429f3bc57c4fd25d2c2de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttBPl5wwGuPzIh-OqZrdcg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Sample dvc.yaml file. (Image by author)</figcaption></figure><p id="b6dd" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><code class="du lx ly lz ma b">dvc.yaml</code>定义您的工作流程。<code class="du lx ly lz ma b">stages</code>部分包含流程的所有阶段。每个阶段有如下三个组成部分:</p><ul class=""><li id="dce2" class="li lj hi jr b js km jv kn jy lk kc ll kg lm kk lw lo lp lq bi translated"><code class="du lx ly lz ma b">cmd<br/></code>执行该阶段的命令。支持任何Unix命令。</li><li id="d43d" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b">deps<br/></code>阶段所依赖的文件或文件夹。通常，这个部分包含代码文件及其所有输入。</li><li id="1a51" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b">params<br/></code>这指定了<code class="du lx ly lz ma b">params.yaml</code>文件中的阶段参数。您可以在YAML文件中指定一个特定值或一个部分。</li><li id="cc3b" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b">outs</code> <br/>舞台产生的输出。与<code class="du lx ly lz ma b">deps</code>类似，文件和目录都支持。每个阶段必须至少有一个输出，否则就是错误。</li></ul><p id="c7f9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请注意，<code class="du lx ly lz ma b">dvc.yaml</code>文件中的顺序并没有定义工作流程的顺序。DVC将根据每个阶段对另一个阶段的依赖性来解决订单问题。</p><h1 id="1767" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">添加阶段</h1><p id="3e3b" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">让我们将第一个阶段<code class="du lx ly lz ma b">split_image.py</code>添加到工作流中。该脚本获取文件夹<code class="du lx ly lz ma b">data/images</code>和<code class="du lx ly lz ma b">data/gt</code>中的所有图像，并根据<code class="du lx ly lz ma b">params.yaml</code>的<code class="du lx ly lz ma b">preprocessing</code>部分中配置的大小将它们分割成小块。然后，将所有补丁保存到<code class="du lx ly lz ma b">data/preprocessed/images</code>和<code class="du lx ly lz ma b">data/preprocessed/gt</code>文件夹中。所有这些分别是阶段的依赖、参数和输出。所以，我们要做的就是把它们放入<code class="du lx ly lz ma b">dvc.yaml</code>的相关部分，就像这样</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="4f76" class="mf iy hi ma b fi mg mh l mi mj">stages:<br/>  split_image:<br/>    cmd: python src/workflow/split_image.py<br/>    deps:<br/>    - src/workflow/split_image.py<br/>    - data/images<br/>    - data/gt<br/>    params:<br/>    - preprocessing.patch_height<br/>    - preprocessing.patch_width<br/>    outs:<br/>    - data/preprocessed/gt<br/>    - data/preprocessed/img</span></pre><p id="9e70" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">要执行工作流，只需在终端中运行以下命令</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="8668" class="mf iy hi ma b fi mg mh l mi mj">dvc repro</span></pre><p id="5368" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">完成后，所有的依赖项和输出都会自动进行版本控制，这意味着如果您进行了更改，但不喜欢结果，您可以随时将其恢复。此外，如果您运行工作流而不做任何更改，您会得到以下结果:</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="377e" class="mf iy hi ma b fi mg mh l mi mj">Stage 'split_image' didn't change, skipping                                     <br/>Data and pipelines are up to date.</span></pre><p id="9588" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">没有不必要的运行。越来越聪明了，对吧？</p><h1 id="eeb9" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">将所有阶段链接在一起</h1><p id="1f7d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">将其余部分添加到工作流类似于第一个。首先列出所有相关数据，然后将它们逐个放入<code class="du lx ly lz ma b">dvc.yaml</code>文件中。以下是其余阶段的依赖项、参数和输出:</p><ul class=""><li id="4c5f" class="li lj hi jr b js km jv kn jy lk kc ll kg lm kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">select_image.py</strong></code> <br/> -依赖:<code class="du lx ly lz ma b">data/preprocessed/img</code><code class="du lx ly lz ma b">data/preprocessed/gt</code><br/>-参数:<code class="du lx ly lz ma b">min_cloud_ratio</code><code class="du lx ly lz ma b">val_ratio</code><code class="du lx ly lz ma b">test_ratio</code><br/>-输出:<code class="du lx ly lz ma b">train.txt</code><code class="du lx ly lz ma b">val.txt</code><code class="du lx ly lz ma b">text.txt</code></li><li id="7209" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">train_model.py</strong></code> <br/> -依赖:<code class="du lx ly lz ma b">train.txt</code>和<code class="du lx ly lz ma b">val.txt<br/></code> -参数:<code class="du lx ly lz ma b">params.yaml</code> <br/>中<code class="du lx ly lz ma b">model</code>和<code class="du lx ly lz ma b">training</code>下的所有内容-输出:<code class="du lx ly lz ma b">model/model.pth</code></li><li id="6e3c" class="li lj hi jr b js lr jv ls jy lt kc lu kg lv kk lw lo lp lq bi translated"><code class="du lx ly lz ma b"><strong class="jr hj">eval.py<br/></strong></code> -依赖:<code class="du lx ly lz ma b">model/model.pth</code>和<code class="du lx ly lz ma b">data/preprocessed/test.txt<br/></code> -参数:- <br/> -输出:<code class="du lx ly lz ma b">model/performance.json</code></li></ul><p id="f39c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们通过使一个阶段的输出成为下一个阶段的依赖项来将阶段链接在一起，以此类推。这样，工作流变得比把所有东西都放在一个文件或笔记本里更容易维护和追踪。当然设计需要时间，但是相信我，这是值得的。</p><p id="2c35" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">综上所述，<code class="du lx ly lz ma b">dvc.yaml </code>文件看起来是这样的:</p><pre class="kt ku kv kw fd mb ma mc md aw me bi"><span id="6946" class="mf iy hi ma b fi mg mh l mi mj">stages:<br/>  split_image:<br/>    cmd: python src/workflow/split_image.py<br/>    deps:<br/>      - src/workflow/split_image.py<br/>      - data/gt<br/>      - data/images<br/>    params:<br/>      - preprocessing.patch_height<br/>      - preprocessing.patch_width<br/>    outs:<br/>      - data/preprocessed/gt<br/>      - data/preprocessed/img<br/>  select_image:<br/>    cmd: python src/workflow/select_image.py<br/>    deps:<br/>      - src/workflow/select_image.py<br/>      - data/preprocessed/img<br/>      - data/preprocessed/gt<br/>    params:<br/>      - preprocessing.min_cloud_ratio<br/>      - preprocessing.val_ratio<br/>      - preprocessing.test_ratio<br/>    outs:<br/>      - data/preprocessed/train.txt<br/>      - data/preprocessed/val.txt<br/>      - data/preprocessed/test.txt<br/>  train_model:<br/>    cmd: python src/workflow/train_model.py<br/>    deps:<br/>      - src/workflow/train_model.py<br/>      - data/preprocessed/train.txt<br/>      - data/preprocessed/val.txt<br/>    params:<br/>      - model<br/>      - training<br/>    outs:<br/>      - model/model.pth<br/>  eval:<br/>    cmd: python src/workflow/eval.py<br/>    deps:<br/>      - model/model.pth<br/>      - data/preprocessed/test.txt<br/>    params:<br/>    outs:<br/>      - model/performance.json</span></pre><p id="38c1" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，当你运行<code class="du lx ly lz ma b">dvc repro</code>时，整个过程按正确的顺序执行，你会得到你想要的最终结果。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mm"><img src="../Images/118283ccc49f86d92c7cc720d1258fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y_bfDqZZ6odrO1RhG6f2TQ.gif"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Image by author</figcaption></figure><p id="ae45" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">从现在开始，<code class="du lx ly lz ma b">dvc repro</code>是我们需要产生结果的唯一命令。不需要记住哪个脚本做什么，或者哪个跟随哪个。都是自动的。</p><h1 id="efea" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">当数据被修改(和恢复)时</h1><p id="c6fd" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">假设我们希望训练一个模型的时间长一点，所以我们增加了<code class="du lx ly lz ma b">params.yaml</code>中的历元数。关于数据预处理没有什么变化，对吗？因此，当我们运行时，只需要执行<code class="du lx ly lz ma b">train_model</code>和<code class="du lx ly lz ma b">eval</code>。让我们看看进展如何。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mm"><img src="../Images/f7eb6dc0a405ac01980409b5ab0b42b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vsni2jixQiONMRgSIqTjAw.gif"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Image by author</figcaption></figure><p id="e3b3" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">正如我们所希望的那样，只运行必要的阶段，它会自动发生。不需要人工决策。这也适用于其他类型的变化。比如数据文件夹里有新的图片，Python脚本被修改等等。</p><p id="03dc" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">工作流程完成后，我们发现我们更喜欢旧的。因此，我们决定恢复超参数并重新运行</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mm"><img src="../Images/188b8dab03ff3628678e795b3ba7261b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JMPAKyXni4ihTlNFJaP2Ow.gif"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Image by author</figcaption></figure><p id="9ecd" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">嘿，看，旧的结果被缓存了。我可以在瞬间恢复它们。不需要重新培训。</p><p id="70ec" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果你想自己尝试一下，代码可以在这里<a class="ae kl" href="https://github.com/thanakorn/cloud_segmentation/tree/dvc-integration" rel="noopener ugc nofollow" target="_blank">找到。</a></p><h1 id="128b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结论</h1><p id="3392" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们已经学习了如何使用DVC来自动化数据科学项目的ML工作流。为了使这篇文章简明扼要，我略去了一些关于DVC的细节。如果你认为这是一个很棒的工具，并且想长期使用它，我强烈推荐你进一步研究它(我也有一篇关于DVC基础的<a class="ae kl" rel="noopener" href="/@thanakornpanyapiang/data-versioning-with-dvc-a474af1247f5">文章</a>)。</p><p id="49d8" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">最后一件事，记住这个工具只是帮助你更容易和更快地完成你的工作。构建组织良好且可重复的数据科学项目始于您的工作方法。如果你仍然以一种无组织的方式工作，比如把所有的东西都放在一个笔记本里，那么任何工具都是无用的。但是，如果你花时间设计它如何正常工作，把整体分成一个小的可管理的部分，你就真的接近目标了。</p><p id="e9b4" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">感谢阅读。如果你喜欢这篇文章，你可以<a class="ae kl" rel="noopener" href="/subscribe/@thanakornpanyapiang">在Medium上关注我</a>。下一篇文章再见。</p></div></div>    
</body>
</html>
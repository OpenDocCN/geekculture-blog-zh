<html>
<head>
<title>Intro To Algorithms: Understanding QuickSort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法简介:了解快速排序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/intro-to-algorithms-understanding-quicksort-562317806218?source=collection_archive---------22-----------------------#2021-06-29">https://medium.com/geekculture/intro-to-algorithms-understanding-quicksort-562317806218?source=collection_archive---------22-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c01d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">分而治之策略</h2><div class=""/><div class=""><h2 id="d0d4" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">解释了一个基本算法</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/84f5c4796d48eff81d7042b7c311c588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukyRBqKOSWUN4VScQ6PFPA.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@brlimaproj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">David Bruno Silva</a> on <a class="ae jw" href="https://unsplash.com/s/photos/files?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="911b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hs">快速排序</strong> </a>算法是利用<a class="ae jw" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="kt">分治范例</em> </a>的众多例子之一。顾名思义，这种范式包括将问题分解成越来越小的块，直到达到一个<a class="ae jw" href="https://en.wikipedia.org/wiki/Recursion#base_case" rel="noopener ugc nofollow" target="_blank">基础案例</a>。在这一点上，你已经把问题分解成足够小的部分，对于存在的少数基本情况来说更容易解决。在我们研究如何实现快速排序算法时，请记住这一策略。</p><h1 id="20fd" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">分割:分割问题</h1><p id="3b3e" class="pw-post-body-paragraph jx jy hi jz b ka lm is kc kd ln iv kf kg lo ki kj kk lp km kn ko lq kq kr ks hb bi translated">简单地说，QuickSort的工作原理是选择一个<strong class="jz hs"> pivot元素</strong>，然后使用它对数组中的剩余元素进行排序。值小于或等于pivot的任何元素被移动到数组中pivot的“<em class="kt">左</em>”，而大于pivot的任何元素被移动到“<em class="kt">右</em>”。随着父数组<strong class="jz hs">被分割</strong>(或者<strong class="jz hs"> <em class="kt">将</em> </strong>一分为二)，我们接着使用相同的方法对子数组进行排序，不断分割数组，直到所有元素都被排序。</p><p id="9ca8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">让我们来看看Javascript是什么样子的:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Syntactically clear quickSort function. It does not sort “<a class="ae jw" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">in place</a>” and is therefore not the most memory-efficient implementation.</figcaption></figure><p id="7e60" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">分区逻辑从第17行开始，将小于或等于pivot的所有元素推入<code class="du lt lu lv lw b">front</code>子数组，将大于pivot的所有元素推入<code class="du lt lu lv lw b">back</code>子数组。这些元素相对于枢轴被<em class="kt">分开</em>，但是按照它们被处理的顺序被放置到它们相应的子数组中。这些子数组没有被排序，但是我们已经成功地将问题一分为二，并且可以继续这样做，直到我们达到我们的基本情况。</p><h1 id="38fa" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">征服基础案例</h1><p id="315b" class="pw-post-body-paragraph jx jy hi jz b ka lm is kc kd ln iv kf kg lo ki kj kk lp km kn ko lq kq kr ks hb bi translated">快速排序的基本情况非常简单。<strong class="jz hs">如果当前数组的元素少于两个(即，它要么只有一个元素，要么为空),则按原样排序并返回。</strong>每个子数组被重复分割，递归分割，直到达到基本情况，此时各个子数组被连接在一起以返回排序的父数组。</p><p id="2d3c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">虽然上面的代码示例实现了<em class="kt">和</em>的功能，但这并不是你在技术面试中想要写出来的东西。<em class="kt">一个合适的快速排序算法应该将</em> <a class="ae jw" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hs"> <em class="kt">就地</em> </strong> </a>排序，对提供的数组进行排序而不使用额外的数据结构。上面的实现实际上返回了一个新的排序后的数组，同时保持原来的数组不变。</p><p id="a075" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="kt">暂且不说</em> </strong> <em class="kt"> : QuickSort的速度部分源于它对集合进行就地排序的能力。MergeSort和QuickSort的平均运行时间都是O(n log(n))，但是QuickSort就地排序，而MergeSort必须分配额外的内存。分配和释放内存会给MergeSort的运行时间增加一个常数。在分析算法运行时，常量通常会被忽略。但是，由于QuickSort和MergeSort具有相同的时间复杂度，内存分配带来的额外常数使MergeSort成为较慢的算法。</em> <a class="ae jw" href="https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">点击此处了解更多关于合并排序与快速排序的对比</em> </a></p><h1 id="3371" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated"><strong class="ak">分区就位</strong></h1><p id="f731" class="pw-post-body-paragraph jx jy hi jz b ka lm is kc kd ln iv kf kg lo ki kj kk lp km kn ko lq kq kr ks hb bi translated">有两种流行的算法用于就地划分数组。Lamuto和Hoare分区方案都成功地对给定的数组进行了排序，尽管Hoare方案通常被认为更有效。Lamuto的方案平均执行3倍于Hoare的方案。当数组包含许多重复的元素时，霍尔的方案胜出，因为Lamuto的方案会不必要地重复交换重复的元素。</p><h1 id="89cf" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">拉穆托的计划</h1><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lx ls l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Visual demonstration of Lamuto’s scheme. As mentioned in the video description, it is more efficient to swap the pivot with the element at array[i + 1] than to shift all the elements down.</figcaption></figure><p id="3e17" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">传统上，Lamuto的分区方案使用数组中的最后一个元素作为支点。然后，两个索引<code class="du lt lu lv lw b">i</code>和<code class="du lt lu lv lw b">j</code>遍历数组。<code class="du lt lu lv lw b">i</code>跟踪最后一个小于或等于主元的元素。当<code class="du lt lu lv lw b">array[j]</code>小于或等于支点时，<code class="du lt lu lv lw b">i</code>递增，然后<code class="du lt lu lv lw b">array[i]</code>和<code class="du lt lu lv lw b">array[j]</code>交换。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Javascript implementation of the Lamuto partition scheme. Note: there are minor differences between the code shown above and the visualization, but the effect is the same.</figcaption></figure><h2 id="2477" class="ly kv hi bd kw lz ma mb la mc md me le kg mf mg lg kk mh mi li ko mj mk lk ho bi translated">霍尔方案</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ml ls l"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Visualization via <a class="ae jw" href="https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/visualize/" rel="noopener ugc nofollow" target="_blank">HackerEarth</a></figcaption></figure><p id="2d1b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">霍尔的方案也使用了两个指针，尽管方式不同。指针逐渐收敛，搜索相对于其位置而言过大或过小的元素。交换这两个元素，指针继续收敛，直到它们相互交叉。当指针交叉时，所有元素都被排序到数组的正确一侧，我们用第一个已知大于或等于枢轴值的元素交换枢轴。返回分区索引(即中枢的最终排序位置)，以便可以递归排序剩余的子数组。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="0da2" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">不足之处</h1><p id="d383" class="pw-post-body-paragraph jx jy hi jz b ka lm is kc kd ln iv kf kg lo ki kj kk lp km kn ko lq kq kr ks hb bi translated">如前所述，<strong class="jz hs"> QuickSort通常比MergeSort快，尽管有些情况下MergeSort更好</strong>。因为QuickSort依赖于对数据集合的<em class="kt">随机访问</em>(不按顺序读取集合中的元素)<strong class="jz hs">，所以在对存储在外部存储上的大型数据集进行排序时效率较低</strong>。MergeSort依赖于对内存的顺序访问，这使它在处理外部存储时具有优势。外部存储通常保存在硬盘上，<a class="ae jw" href="https://www.youtube.com/watch?v=IvVZ7jf8wqw" rel="noopener ugc nofollow" target="_blank">随机访问数据的成本高于顺序访问</a>。</p><p id="b5c6" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">同样的，<strong class="jz hs"> QuickSort在处理链表</strong>时也并不出色。同样，因为链表天生需要顺序访问，所以快速排序使用的随机访问不是最佳的。在这些情况下，MergeSort的性能更好。</p><p id="242e" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs"> QuickSort在处理所有元素都有相同值的数组时性能很差</strong>。由于算法的性质，具有相同值的元素在划分过程中不必要地交换，导致时间复杂度为O(n)。</p><p id="4059" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs">如果没有选择随机枢纽——而是选择总是选择数组中的第一个(或最后一个)元素——那么当所提供的数组已经排序时，二次时间复杂度可靠地发生</strong>。我们的分区方法——不考虑所选的方案——返回枢轴的最终排序索引，该索引用于划分父数组并对其进行递归排序。如果第一个元素总是我们的枢纽，并且父数组已经排序，那么分区过程每次只删除一个元素。我们最终遍历每个pivot元素的所有元素，导致O(n)时间复杂度。</p><h1 id="1001" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">结论</h1><p id="74a0" class="pw-post-body-paragraph jx jy hi jz b ka lm is kc kd ln iv kf kg lo ki kj kk lp km kn ko lq kq kr ks hb bi translated">QuickSort将提供的数据集划分为更小的块，快速降低了问题的复杂性，并允许相对快速的排序算法。在这篇文章中多次提到的MergeSort，也利用了分而治之的策略(也许将是下一篇文章的主题？).QuickSort擅长数组和较小的数据集，但在链表、较大的数据集和有多个重复值的情况下却很吃力。</p><pre class="jh ji jj jk fd mm lw mn mo aw mp bi"><span id="92ef" class="ly kv hi lw b fi mq mr l ms mt"><strong class="lw hs">References and Further Reading</strong></span><span id="75b2" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="https://www.youtube.com/watch?v=7h1s2SojIRw" rel="noopener ugc nofollow" target="_blank">QuickSort Algorithm — Abdul Bari</a></span><span id="da23" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank">QuickSort — GeeksForGeeks</a></span><span id="4c9b" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="https://www.geeksforgeeks.org/hoares-vs-lomuto-partition-scheme-quicksort/" rel="noopener ugc nofollow" target="_blank">Hoare's vs Lomuto Partition Scheme in QuickSort — GeeksForGeeks</a></span><span id="09a1" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="http://Quick Sort(Hoare’s Partition) Visualization using JavaScript" rel="noopener ugc nofollow" target="_blank">Quick Sort(Hoare’s Partition) Visualization — GeeksForGeeks</a></span><span id="7be3" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/" rel="noopener ugc nofollow" target="_blank">Quick Sort vs Merge Sort — GeeksForGeeks</a></span><span id="aa07" class="ly kv hi lw b fi mu mr l ms mt"><a class="ae jw" href="https://bookshop.org/books/grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curious-people/9781617292231" rel="noopener ugc nofollow" target="_blank">Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People</a></span></pre></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding the Concept of Virtual Time Using the Time Warp Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用时间扭曲算法理解虚拟时间的概念</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-the-concept-of-virtual-time-using-the-time-warp-algorithm-4579dfe5eca8?source=collection_archive---------10-----------------------#2021-04-10">https://medium.com/geekculture/understanding-the-concept-of-virtual-time-using-the-time-warp-algorithm-4579dfe5eca8?source=collection_archive---------10-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="122c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">简介</strong></h2></div><p id="9a83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是虚拟时间，我们为什么需要它？</p><p id="b90e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着分布式系统在过去十年中的发展和采用，在不同领域出现了许多技术，如数据库、缓存、消息队列等，这些技术建立在其他框架之上，这些框架消除了管理分布式系统的困难。分布式系统中最重要也是最难管理的事情之一是使用时间管理同步性。</p><p id="cc0d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分布式系统中同步技术的一些常见形式有<strong class="iz hj"> <em class="jt">阻塞-恢复</em> </strong>、<strong class="iz hj"> <em class="jt">中止-重试</em> </strong>、<strong class="iz hj"> <em class="jt">前瞻-回滚</em> </strong>。这篇文章将涵盖<strong class="iz hj"><em class="jt"/></strong>时间扭曲算法所使用的<strong class="iz hj"> <em class="jt">前瞻-回滚</em> </strong>，因为虽然不直观，但当比较每种技术的缺点时，它会导致优雅和有效的解决方案。</p><blockquote class="ju jv jw"><p id="81a0" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">虚拟时间系统是一个分布式系统，它与一个报时虚拟时间的虚拟时钟协同运行。虚拟时间本身是一个施加在分布式计算上的全局、一维、时间坐标系统；它用于测量计算进度和定义同步。</p></blockquote><p id="2551" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要目的是在整个系统中有一个单一的虚拟时间(它也可以与真实时间同步),以便当实际上它是一个不可预测的实体时，流程可以总是以一种不透明的方式运行。</p><p id="9d92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有进程通过消息相互通信(本地或远程),消息主要由4个主要字段组成:发送方、虚拟发送时间、接收方、虚拟接收时间。</p><p id="3ca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虚拟时间必须遵守的一些基本规则:</p><blockquote class="ju jv jw"><p id="2e97" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">每条消息的虚拟发送时间必须小于其虚拟接收时间。</p><p id="4079" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">流程中每个事件的虚拟时间必须小于该流程中下一个事件的虚拟时间。</p></blockquote><p id="faa0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还应该注意，任何事件A和B的虚拟时间应该遵循上述规则，只有当在A和B之间存在直接或间接因果关系的事件时。</p><p id="b1e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> Lamport的逻辑时钟</strong></p><p id="bf5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Lamport是第一个证明实时时间顺序，事件之间的因果关系与相对论概念有很强联系的人。他提供了一种算法，一旦分布式系统开始执行，该算法就给事件分配有序的时钟值。时间扭曲算法是Lamport算法的逆算法，在Lamport算法中，它们主要将时间分配给事件，如果发现任何差异，则进行回滚</p><p id="e882" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">里德的伪时间</strong></p><p id="b0a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Reed提出了伪时间的概念，它看起来类似于虚拟时间，但在某种意义上是不同的，伪时间中事件被分配了多版本时间戳，用于并发控制以理解分布式系统中事件的原子时间，在分布式系统中，虚拟时间本质上是相对的，因此与其他时间相比，它主要处理在 之前<strong class="iz hj"> <em class="jt">发生的事件。Reed在他的算法中使用了流产-重试，其中可能存在饥饿、无限重试、死锁等。</em></strong></p><p id="dc31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">施耐德的作品</strong></p><p id="5b28" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Schneider的算法主要包括向所有进程广播同步消息，并且直到从每个进程收到确认才继续。将所有同步的事件保存在它们的本地内存中，进程能够在本地决定事件的顺序。然而，该算法不能满足当今场景的要求，在当今场景中，需要对数万台服务器的数百万条消息执行广播消息和确认。</p><p id="c862" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">时间扭曲算法</strong></p><p id="ba1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个进程维护自己的虚拟时钟，该时钟仅在事件之间改变。每个进程有3个队列；<strong class="iz hj"> <em class="jt">输入消息队列</em> </strong>，<strong class="iz hj"> <em class="jt">输出消息队列</em> </strong>和<strong class="iz hj"> <em class="jt">状态队列。</em> </strong>记住上一节提到的虚拟时间规则，流程的本地队列中的每个事件应该总是按升序排列。</p><p id="08da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">极有可能出现这样的情况:虚拟时间小于流程中当前时间的事件可能会到达，这违反了虚拟时间的规则。在这种情况下，时间扭曲算法遵循前瞻-回滚算法，这导致回滚到传入消息与进程的虚拟时间相适应的点，并且剩余的消息必须以正确的顺序重放。</p><p id="da60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">消息的回滚不能仅仅局限于单个处理器，因为以错误的顺序发送的消息也会影响维护它们自己的队列的其他进程。因此，对于其他相互关联的流程中的错误消息也必须有一个回滚。与带有错误序列的消息没有任何直接或间接联系的其他流程不会受到影响，从而导致较小的网络返工影响。</p><p id="a811" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于回滚，系统中有一个<strong class="iz hj">反消息</strong>的概念，它也可以用于其他目的。消息和反消息的所有字段是相同的，除了一个字段，它是消息的符号。所有发送到其他进程的消息都有一个<strong class="iz hj"> (+) </strong>符号，它们的反消息有一个<strong class="iz hj"> (-) </strong>符号。每当发送消息时，消息存储在<strong class="iz hj">接收方的</strong>输入队列中，反消息存储在<strong class="iz hj">发送方的</strong>输出队列中。</p><blockquote class="ju jv jw"><p id="c769" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">每当一个消息和反消息存在于同一个队列中时，这两个消息相互抵消，因此被删除。</p></blockquote><p id="ce97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">消息和反消息是一起创建的，可以存在于不同的队列中。</p><p id="d186" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到回滚的情况，我们必须将发送的消息回滚到其他进程以保持新的正确顺序，该进程为发送到其他进程的所有不正确消息生成并发送反消息，这些进程也在本地执行相同的操作，从而导致高效回滚的连锁反应。即使在另一个进程中反消息在实际错误消息之前到达的情况下，这两个消息都将被消除，因为同一个队列不可能有两个消息最终将所有进程带到正确的顺序。</p><p id="3a14" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们经历上述机制时，我们需要理解上面列出的所有步骤都发生在进程 的<strong class="iz hj"> <em class="jt">本地上下文中，该进程还不知道全局虚拟时钟。没有一个全局值不允许对队列进行有效的内存管理，因为我们看到消息必须无限期地保存在它们的队列中，这在规模上可能是一个问题。</em></strong></p><p id="6f9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们引入<strong class="iz hj">全球虚拟时间(GVT) </strong>的概念，它在实时<strong class="iz hj"> <em class="jt"> r </em> </strong>时，是下列各项中的最小值</p><ul class=""><li id="f896" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">在<strong class="iz hj"><em class="jt"/></strong>的所有虚拟时钟中的所有虚拟时间</li><li id="c739" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">在时间<strong class="iz hj"> <em class="jt"> r </em> </strong>已经发送但尚未处理/接收的虚拟发送次数。</li></ul><p id="939a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据上述定义，很明显，在整个系统中的任何时间点，GVT也将是系统中的最低值或最低值。GVT象征着GVT下面的消息已经按照正确的顺序进行了处理，可以被遗忘，本地进程可以用它来清理它们的队列。</p><p id="6d55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算GVT的延迟是向进程发送广播消息的总延迟。</p><p id="e979" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">结论</strong></p><p id="d6c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">时间扭曲算法的一个常见反馈包含这样的论点，即在现实生活的用例中，跨数千个进程回滚可能是不可行的。然而，需要指出的是，回滚在现实生活用例中被称为例外，而不是规范。由于进程遵循<strong class="iz hj"> <em class="jt">时间局部性原则</em> </strong>，因此事件按实际顺序到达更有意义，过去到达的事件在最近到达，这意味着回滚较少。</p><blockquote class="ju jv jw"><p id="4a4a" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">前瞻/回滚的唯一替代方法是在与前瞻计算相同的时间长度内阻塞进程(即什么也不做)，这也是一种“浪费”</p></blockquote><p id="1280" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虚拟时间非常类似于虚拟内存，这是内存管理的相同概念，其中最佳页面保存在主内存中。有许多有效的算法试图确定保存在主存储器中的页面，其中数据文件的前瞻部分以块的形式预取几个页面，并按照用户的通常趋势保存。在主存储器中找不到所需页面的情况下，存在页面错误，其从主存储器中交换出最不理想的页面，并用所需页面替换它，这也类似于回滚机制。这种类比可以以各种方式扩展，表明虚拟时间可以在分布式系统中以优雅而有效的方式实现。</p><p id="d792" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">希望你喜欢这篇文章。如果你对这篇文章有任何疑问，请告诉我。快乐阅读！！</em> </strong></p><p id="a556" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考资料:</p><ul class=""><li id="77a8" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated"><a class="ae ko" href="http://cobweb.cs.uga.edu/~maria/pads/papers/p404-jefferson.pdf" rel="noopener ugc nofollow" target="_blank">http://cobweb . cs . uga . edu/~ Maria/pads/papers/p404-Jefferson . pdf</a></li><li id="1c7e" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Lamport_timestamp" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Lamport_timestamp</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Understand SOLID Principles and Replace Your Bad Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解坚实的原则，取代你的坏代码</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understand-solid-principles-and-replace-your-bad-code-7b68b0f9467?source=collection_archive---------4-----------------------#2021-01-13">https://medium.com/geekculture/understand-solid-principles-and-replace-your-bad-code-7b68b0f9467?source=collection_archive---------4-----------------------#2021-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1237" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">成为更好的程序员的一步</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a93c5d4e927c32d89f7d56f66773b26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q77j2otWpaYb1u1p"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@usgs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">USGS</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="90f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于初学者来说，理解坚实的原理是最糟糕的噩梦之一。今天我就用最简单的方式来解释一下。在阅读本文之前，请确保您已经掌握了基本的Java知识。让我们开始吧！</p><h1 id="2e5f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">但是首先，什么是固体？</h1><p id="4712" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在面向对象设计中，<a class="ae jn" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank">固体原则</a>(或简称固体)是一组五个设计原则，旨在使您的代码更干净、更灵活、更容易更改。每一个实心字母代表一个原则。我们将从S到d逐一介绍原理。</p><h1 id="5e00" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">1.单一责任原则</h1><p id="c72c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">第一个原则的概念是:“每个类只应该有一个责任，只做一项工作，这是一个类应该被改变的唯一原因。”</p><p id="6b95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你明白了吗？让我们看看这个LocalWeather.java</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="551e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了获得用户本地地址的当前温度，首先，它调用<code class="du lj lk ll lm b">getLatitude()</code>和<code class="du lj lk ll lm b"> getLongitude()</code>。这个类必须做两件独立的事情:</p><ul class=""><li id="e02d" class="ln lo hi jq b jr js ju jv jx lp kb lq kf lr kj ls lt lu lv bi translated">查找用户位置</li><li id="9506" class="ln lo hi jq b jr lw ju lx jx ly kb lz kf ma kj ls lt lu lv bi translated">使用该位置查找当地温度</li></ul><p id="b896" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正因为如此，它违背了我们的首要原则。为了解决这个问题，我们分成两个班，每个班只做一项工作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5a46" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们有两个班，每个班负责做一件事。</p><h1 id="23c8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">2.开闭原则(OCP)</h1><p id="331f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">第二个原则通常被称为:</p><p id="aa71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mb">“软件实体(类、模块、功能等。)应该是</em> <strong class="jq hj"> <em class="mb">打开</em> </strong> <em class="mb">进行扩展，但是</em> <strong class="jq hj"> <em class="mb">关闭</em> </strong> <em class="mb">进行修改”</em></p><p id="491f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">意思是:如果你的代码需要扩展(做更多的事情，增加一个新的类等等)，不需要修改现有的代码就可以很容易做到。看到这个例子，你就会明白了</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="93e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有两个等级<code class="du lj lk ll lm b">Cat </code>和<code class="du lj lk ll lm b">Dog</code>，都是延伸<code class="du lj lk ll lm b">Animal</code>。而<code class="du lj lk ll lm b">Manager </code>想要命令一个随机的动物说话。那个代码好吗？是啊，有点…</p><p id="776a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不，不是的。</p><p id="6cf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为什么不好？因为每次我们添加一个新的动物，(例如<code class="du lj lk ll lm b">Bird </code>类扩展<code class="du lj lk ll lm b">Animal </code>)我们不仅要添加新的类，还要修改<code class="du lj lk ll lm b">Manager </code>类，这真的是一件坏事。想象一下，如果你必须增加100种新动物。</p><p id="a4ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们应该在<code class="du lj lk ll lm b">Animal </code>中创建一个抽象方法，并在每个孩子中覆盖它。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="332f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在每当我们添加一个新的动物，我们不需要改变<code class="du lj lk ll lm b">Manager </code>类。</p><h1 id="7448" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">3.利斯科夫替代原理</h1><p id="55b3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">很多开发者并不理解和遵循这个规则。但是一旦你得到了，你就会本能地去做。</p><p id="ea79" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">LSP说:"<em class="mb">使用基类引用的函数必须能够在不知道的情况下使用派生类的对象"</em>。</p><p id="7601" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简而言之，派生类必须可以替换基类。如果无法替代，他们就不应该是父子关系。看看下面的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="8eaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以看到代码完美地遵循了LSP(当然，在实际项目中，我们必须检查一个人是否为空以及其他许多事情)，因为如果我们用一个人的任何子代来替换他，应用程序将不会中断。</p><p id="dd73" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么，如果我们有一个新的类，名为<code class="du lj lk ll lm b"><strong class="jq hj">Baby</strong></code>，会怎么样呢？你会怎么做？刚刚做了一个新的Baby.java并扩展了<code class="du lj lk ll lm b">Human </code>类？你认为这样做有什么问题吗？是的，婴儿不会走路。所以如果我们把人类替换成婴儿，代码会抛出一个错误。因此，你不能创建一个扩展Human的baby类。</p><p id="0272" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解决这个问题的方法之一是我们可以将<code class="du lj lk ll lm b">Human </code>类重命名为成人类。<code class="du lj lk ll lm b">MiddleAge </code>和<code class="du lj lk ll lm b">Teenager </code>是从<code class="du lj lk ll lm b">Adult </code>延伸而来的(我知道青少年不是成年人，但我想不出更好的名字，也许是WalkableHuman？).现在<code class="du lj lk ll lm b">Adult </code>和<code class="du lj lk ll lm b">Baby </code>将延伸<code class="du lj lk ll lm b">Human</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="01f3" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak"> 4。接口隔离原则(ISP) </strong></h1><p id="8aaa" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这也许是最简单的原则。</p><p id="c009" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">"<em class="mb">类不应被迫依赖于它们不使用的接口"</em></p><p id="7f13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你也可以理解为你需要把一个大的接口分成更小的接口，一个类应该只实现可以被执行的接口。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="9463" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们有一个接口<code class="du lj lk ll lm b">IShape</code>和两个抽象方法<code class="du lj lk ll lm b">calculateArea() </code>和<code class="du lj lk ll lm b">calculateVolume()</code>。但是许多形状不需要计算体积，如正方形或圆形，只有三维形状需要计算体积(如圆形)。因此，让Square类实现<code class="du lj lk ll lm b">IShape</code>有点多余。我们应该把<code class="du lj lk ll lm b">IShape</code>分成2个更小的接口。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6902" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，2D形状只需要实现<code class="du lj lk ll lm b">IShape2D</code>(只需要覆盖<code class="du lj lk ll lm b">calculateArea()</code>)。如果你想让所有的3D形状计算面积，你需要让它们实现2个不同的接口，或者你可以让<code class="du lj lk ll lm b">IShape3D</code>扩展<code class="du lj lk ll lm b">IShape2D</code>。</p><h1 id="6dd8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak"> 5。依存倒置原则(DIP) </strong></h1><p id="8f95" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">最后，最后一个。这一条不难理解，但一开始真的很难理解，尤其是对初学者来说。</p><p id="6181" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类必须依赖于抽象，而不是具体。它声明高级模块不能依赖于低级模块，但是它们应该依赖于抽象。”</p><p id="06e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么什么是高级和低级模块呢？简而言之，低级模块类似于文件类或记录类，高级类是文件管理器或媒体管理器。低级模块通常是高级模块属性。为了更好地理解，先看这个例子。</p><p id="f5ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lj lk ll lm b">Boss </code>为高级模块，<code class="du lj lk ll lm b">Employee </code>为低级模块。如果老板知道员工的id，他可以给员工分配工作，然后员工执行他/她的任务。你现在可以忽略<code class="du lj lk ll lm b">giveAccessToEmployee() </code>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4e4e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在某些情况下，在工作过程中，员工意识到他/她必须做其他事情来完成任务(例如，外出、去仓库、访问有限的资源……)，他/她需要征得老板的同意，或者换句话说，需要老板在工作过程中对象调用<code class="du lj lk ll lm b">giveAccessToEmployee()</code>方法(在<code class="du lj lk ll lm b">doWork </code>方法内)。你是怎么做到的？初学者通常会在这里犯错误。他们把boss本身改成了这样的<code class="du lj lk ll lm b">doWork</code>方法</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="59cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有些初学者甚至让boss变成了<code class="du lj lk ll lm b">Employee </code>属性。真的是糟糕的代码库。因为如果你让你的低层模块完全接触高层模块，员工可以命令老板做任何事情。想象一个文件对象可以删除所有其他文件。你真的不希望这种情况发生，谁知道有一天你登录你的应用程序，一切都消失了，因为你给了太多的对象删除数据的权限。</p><p id="db7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么，我们怎样才能避免这种情况，同时又给员工向老板提问的权利呢？使用接口。我们将让boss实现IBoss接口，它只有一个方法<code class="du lj lk ll lm b">giveAccessToEmployee</code>。现在员工将<code class="du lj lk ll lm b">IBoss</code>作为财产。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="fee6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整示例如上所示。当employee类只有<code class="du lj lk ll lm b">iBoss </code>而没有<code class="du lj lk ll lm b">Boss </code>作为属性时，<code class="du lj lk ll lm b">iBoss </code>不能调用除<code class="du lj lk ll lm b">giveAccessToEmployee.</code>以外的其他方法</p><p id="ebd4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望这篇文章已经驱散了你的迷雾。理解实体是困难的，但是理解它们更困难。坚持练习，总有一天那些看着你的代码库的前辈会说“这个不错！”。</p></div></div>    
</body>
</html>
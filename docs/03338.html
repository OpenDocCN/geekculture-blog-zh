<html>
<head>
<title>Better unit tests with Parameterized testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过参数化测试实现更好的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/multiplying-the-quality-of-your-unit-tests-part-1-parameterized-tests-539428367222?source=collection_archive---------22-----------------------#2021-06-06">https://medium.com/geekculture/multiplying-the-quality-of-your-unit-tests-part-1-parameterized-tests-539428367222?source=collection_archive---------22-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e5d9c392c4d0dd1873a14e51418d7419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl0F36mQqB_LNtA_dKd3ug.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Image from Unsplash by Markus Spiske</figcaption></figure><div class=""/><p id="bab8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">免费见原文</em> <strong class="iw hy"> <em class="js">带语法高亮</em> </strong> <em class="js"> </em> <strong class="iw hy"> <em class="js">和代码格式化</em> </strong> <em class="js">在我的个人博客:</em><a class="ae jt" href="https://sergiosastre.hashnode.dev/better-unit-tests-with-parameterized-testing" rel="noopener ugc nofollow" target="_blank"><em class="js">https://sergiosastre . hashnode . dev</em></a><em class="js">。</em></p><p id="8f6d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在编写单元测试时，我们经常验证给定一个输入，被测方法的输出是否是预期的。当你用不同的输入和预期输出执行相同的测试几次时，你会得到<em class="js">数据驱动测试</em>或<em class="js">参数化测试</em>。</p><p id="e7aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在第一篇文章中，我将解释我们如何用这种方法不仅增加测试的数量，还增加测试的质量。这些示例是在Junit5中用Kotlin编写的，但也适用于Java。</p><p id="81d2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">*要在Android项目中配置Junit5(我强烈建议至少在JVM测试中使用)，你可以在这里找到完整的指南<a class="ae jt" href="https://www.lordcodes.com/articles/testing-on-android-using-junit-5" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="98ad" class="ju jv hx bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一个常见的测试用例:密码验证器</h1><p id="046d" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">如今，大多数应用程序要求用户创建一个具有“强密码”的账户。假设我们需要在客户端验证用户是否提供了强密码，即:</p><ol class=""><li id="8b40" class="kx ky hx iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated">包含至少1个小写数字。否则显示“无数字”</li><li id="d2fe" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">至少包含一个大写字符。否则显示“无大写字母”</li><li id="139c" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">包含至少6位数字。否则显示“包含少于6个字符”</li></ol><p id="8b20" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然您可以采用另一种方法来实现它，但是我使用了一个<strong class="iw hy">复合模式</strong>:<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/main/java/sergio/sastre/multiplying/quality/of/unittests/PasswordValidator.kt" rel="noopener ugc nofollow" target="_blank">password validator(Composite)</a>和<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/main/java/sergio/sastre/multiplying/quality/of/unittests/Validators.kt" rel="noopener ugc nofollow" target="_blank"> Validators (Leaves) </a>，它接受一个<code class="du ll lm ln lo b">vararg</code>验证器(Leaves)作为其构造函数中的参数，每个值验证一个需求。</p><p id="f2f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了测试我们的密码验证器是否工作，我们为每个需求编写了一个带有断言的测试，如下所示</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="241f" class="lx jv hx lo b fi ly lz l ma mb">@Test<br/>fun passwordValidatorTest() {<br/>    val minCharsCount = 6<br/>    val passwordValidator = PasswordValidator(<br/>        ContainsUpperCaseLetterValidator(),<br/>        MinCharsValidator(minCharsCount),<br/>        ContainsDigitValidator()<br/>    )<br/><br/>    assertThat(<br/>        passwordValidator.validate("123456")<br/>    ).contains("no upper case letters")<br/><br/>    assertThat(<br/>        passwordValidator.validate("1234A")<br/>    ).contains("contains less than $minCharsCount chars")<br/><br/>    assertThat(<br/>        passwordValidator.validate("ABCDEF")<br/>    ).contains("no digits")<br/>}</span></pre><p id="d74b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你不是单元测试的新手，我相信你已经听说过<strong class="iw hy">你应该争取每个测试只有一个断言</strong>。这样做，你的测试是自包含的，并且清楚地陈述了正在被测试的内容。</p><p id="67f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而且，<strong class="iw hy">在6月5日默认断言硬失败</strong>。这意味着，无论何时一个断言失败，<strong class="iw hy">测试执行立即退出</strong>，并显示相应的错误。测试中的后续断言将不会运行，因此不会报告进一步的错误。<em class="js">软断言</em>可以解决这个问题(6月5日的<code class="du ll lm ln lo b">assertAll</code>),但是在这种情况下伸缩性不好。测试将继续变得越来越长。</p><p id="60e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，假设过了一段时间，对强密码的要求变得更加严格，我们还需要验证密码创建的以下内容:</p><ol class=""><li id="950d" class="kx ky hx iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated">包含至少一个小写字符。否则显示“无小写字母”</li><li id="cbc3" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">不包含空格。否则显示“包含空白”</li></ol><p id="d2dd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在添加相应的验证器时，我们的测试变成了这样:</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="62bc" class="lx jv hx lo b fi ly lz l ma mb"><a class="ae jt" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>fun advancedPasswordValidatorTest() {<br/>    val minCharsCount = 6<br/>    val passwordValidator = PasswordValidator(<br/>        ContainsUpperCaseLetterValidator(),<br/>        MinCharsValidator(minCharsCount),<br/>        ContainsDigitValidator(),<br/>        ContainsLowerCaseLetterValidator(),<br/>        NoBlanksValidator()<br/>    )</span><span id="0f5c" class="lx jv hx lo b fi mc lz l ma mb">    assertThat(<br/>       passwordValidator.validate("123456")<br/>    ).contains("no upper case letters")</span><span id="8c96" class="lx jv hx lo b fi mc lz l ma mb">    assertThat(<br/>       passwordValidator.validate("1234A")<br/>    ).contains("contains less than $minCharsCount chars")</span><span id="d444" class="lx jv hx lo b fi mc lz l ma mb">    assertThat(<br/>       passwordValidator.validate("ABCDEF")<br/>    ).contains("no digits")</span><span id="23f3" class="lx jv hx lo b fi mc lz l ma mb">    assertThat(<br/>       passwordValidator.validate("HELLO")<br/>    ).contains("no lower case letters")</span><span id="4275" class="lx jv hx lo b fi mc lz l ma mb">    assertThat(<br/>       passwordValidator.validate("12 3 456")<br/>    ).contains("contains blanks")<br/>}</span></pre><p id="bd65" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">*您可以在此处找到完整的初始和高级强密码示例，其中包含多个断言<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/multipleasserts/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank"/></p><p id="43f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一眼看去，我们注意到以下情况:</p><ol class=""><li id="fc7b" class="kx ky hx iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated"><strong class="iw hy">测试变长</strong>:长代码一般更复杂，更难阅读，更难维护。要求越多，由于额外的断言，时间就变得越长。</li><li id="666e" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated"><strong class="iw hy">测试变得不那么集中</strong>:密码要求越多，添加的断言就越多。断言越多，就越难看出测试实际验证的是什么。</li></ol><h1 id="0b61" class="ju jv hx bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">每个需求一个测试:简短和集中的测试！…但是重复</h1><p id="79c2" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">通过为每个需求创建一个测试，我们可以解决这两个问题。每个测试都只会断言一件事。如果测试失败，我们直接知道失败的原因。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="575c" class="lx jv hx lo b fi ly lz l ma mb">val passwordValidator = PasswordValidator(<br/>     ContainsUpperCaseLetterValidator(),<br/>     MinCharsValidator(6),<br/>     ContainsDigitValidator(),<br/>     ContainsLowerCaseLetterValidator(),<br/>     NoBlanksValidator()<br/> )<br/><br/>@Test<br/>fun passwordValidatorNoUpperCaseTest_showsError() {<br/>    assertThat(<br/>         passwordValidator.validate("123456")<br/>    ).contains("no upper case letters")<br/>}<br/><br/>@Test<br/>fun passwordValidatorNoLowerCaseTest_showsError() {<br/>     assertThat(<br/>          passwordValidator.validate("HELLO")<br/>     ).contains("no lower case letters")<br/>}<br/><br/>@Test<br/>fun passwordValidatorNoDigitsTest_showsError() {<br/>     assertThat(<br/>          passwordValidator.validate("ABCDEF")<br/>     ).contains("no digits")<br/>}<br/>...</span></pre><p id="6da7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">*你可以在这里找到带有一个断言<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/onetestperassert/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank">的全套测试</a></p><p id="cc78" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，<strong class="iw hy">所有的测试看起来都非常重复</strong>。如果我们添加更多的需求，新的测试基本上是任何先前测试的<strong class="iw hy">复制粘贴，但是具有不同的输入和预期输出值。它们<strong class="iw hy">没有很好地扩展。</strong></strong></p><p id="0dbb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以做得更好。这就是<em class="js">参数化测试</em>派上用场的地方…</p><h1 id="649c" class="ju jv hx bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参数化测试:简短而集中的测试！…而且简洁、可扩展！</h1><p id="b79c" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated"><em class="js">参数化测试</em>使我们能够<strong class="iw hy">使用不同的参数</strong>多次执行一个测试方法。在Junit5中，我们可以为此使用<code class="du ll lm ln lo b">@ParameterizedTest</code>注释。这样，我们可以将测试中的密码及其预期的错误消息作为输入进行传递，从而解决我们所面临的问题。</p><p id="3884" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由此产生的<em class="js">参数化测试</em>将如下所示:</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="204f" class="lx jv hx lo b fi ly lz l ma mb">val passwordValidator = PasswordValidator(<br/>     ContainsUpperCaseLetterValidator(),<br/>     MinCharsValidator(6),<br/>     ContainsDigitValidator(),<br/>     ContainsLowerCaseLetterValidator(),<br/>     NoBlanksValidator()<br/> )<br/><br/>@DisplayName("PasswordValidator for invalid passwords")<br/>@ParameterizedTest(name = "When password is \"{0}\", the error contains \"{1}\"")<br/>@CsvSource(<br/>    "123456, no upper case letters",<br/>    "ABCDEF, no digits",<br/>    "HELLO, no lower case letters",<br/>    "1234A, contains less than 6 chars",<br/>    "12 3 456, contains blanks"<br/>)<br/>fun testPasswordValidatorRight(password: String?, expectedError: String?) {<br/>    val actualError = passwordValidator.validate(password)<br/>    assertThat(actualError).contains(expectedError)<br/>}</span></pre><p id="1e5a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">*您可以在这里找到完整的参数化测试集<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/tree/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/parameterized" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="md me mf"><p id="6913" class="iu iv js iw b ix iy iz ja jb jc jd je mg jg jh ji mh jk jl jm mi jo jp jq jr hb bi translated"><em class="hx">除了</em> <code class="du ll lm ln lo b"><em class="hx">@CsvSource</em></code> <em class="hx">之外，Junit5还附带了其他注释来提供输入，比如</em><code class="du ll lm ln lo b"><em class="hx">@CsvFileSource</em></code><em class="hx"/><code class="du ll lm ln lo b"><em class="hx">@EnumSource</em></code><em class="hx">甚至</em> <code class="du ll lm ln lo b"><em class="hx">@MethodSource</em></code> <em class="hx">用于更复杂的输入集合。你可以在这里</em>  <em class="hx">更深入的看看它们</em> <a class="ae jt" href="https://www.baeldung.com/parameterized-tests-junit-5" rel="noopener ugc nofollow" target="_blank"> <em class="hx">找到哪一个更符合你的需求。</em></a></p></blockquote><p id="e029" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们运行测试，我们会得到以下结果:</p><figure class="lp lq lr ls fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/e165408ce486d46ec56590f3b2a11689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3h9PituAlxJz7rps"/></div></div></figure><p id="23db" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所看到的，参数化您的测试有以下优点:</p><ol class=""><li id="63ee" class="kx ky hx iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated">你的测试是可伸缩的:每一个新的需求都包括添加一对新的输入和期望输出到我们注入测试的参数中。不再复制粘贴测试。<br/>如果您需要添加忘记的边缘案例，该怎么办？不需要额外的断言或额外的测试。同样，只需向测试中添加新数据。</li><li id="a560" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">你的测试很简洁:测试的名字变得更加简洁，因为它们可以包含参数的值。什么更能说明我们实际测试的内容？什么说出了绝对的事实？<em class="js">passwordValidatorNoDigitsTest _ shows error</em>或<em class="js">当密码为“ABCDEF”时，错误包含“无数字”</em>？</li></ol><p id="b3f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了<em class="js">参数化测试</em>，你的测试仍然像以前一样<strong class="iw hy">简短</strong>和<strong class="iw hy">集中</strong>，但是它们<strong class="iw hy">更简洁</strong>和<strong class="iw hy">规模更好</strong>！你不仅轻松地倍增了它的数量，也倍增了它的质量！</p><h1 id="979f" class="ju jv hx bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="2d2a" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">正如我们在示例中看到的，每当您发现自己在编写一个包含多个断言的测试时，请考虑为每个断言创建一个测试是否有意义。这样你的测试将会更短，更集中，可读性更强。</p><p id="bbf2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果在将原始测试分成几个之后，你发现你可以通过将一些公共代码提取到参数中来对测试进行分组，<em class="js">参数化测试</em>也将帮助你的测试<strong class="iw hy">更好地扩展</strong>，同时<strong class="iw hy">简短</strong>和<strong class="iw hy">集中</strong>。通过使用它的参数来构建测试名，它们也会变得更加简洁。</p><p id="d587" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，不要落入<strong class="iw hy">过度泛化</strong>的陷阱。不要编写使用<strong class="iw hy">太多参数作为参数</strong>的测试。如果您最终得到的<em class="js">参数化测试</em>的名称过于笼统或难以理解，请尝试将它们分成参数较少的单独的<em class="js">参数化测试</em>(甚至是简单测试)。看看我是如何在这里将<em class="js">参数化测试</em> <a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/parameterized/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank">分组，而不是将它们合并成一个。</a></p><p id="f136" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后但同样重要的是，记住<strong class="iw hy">测试也是文档</strong>。因此，它们需要是可理解的，你永远不知道谁将不得不修复那些测试，如果他们失败了！</p><p id="9aa3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">*您可以在本报告中找到验证器代码和更完整的强密码测试样本集合<a class="ae jt" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6173" class="ju jv hx bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">接下来是什么</h1><p id="9ca0" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">在本系列的下一篇文章中，我们将探索基于属性的测试以及它们如何帮助我们使密码验证器测试更加健壮。这里已经有<a class="ae jt" rel="noopener" href="/nerd-for-tech/multiplying-the-quality-of-your-unit-tests-with-property-based-tests-d3c2cb2d5601">了</a>！</p><p id="c577" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你喜欢这篇文章，你可能也会喜欢我写的其他文章:</p><ol class=""><li id="01c7" class="kx ky hx iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated"><a class="ae jt" href="https://sergiosastre.hashnode.dev/writing-bulletproof-code-with-property-based-testing-pbt" rel="noopener ugc nofollow" target="_blank">用基于属性的测试编写防弹代码</a></li><li id="fe69" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated"><a class="ae jt" href="https://sergio-sastre.medium.com/an-introduction-to-snapshot-testing-on-android-in-2021-c9826e22deb1" rel="noopener">2021年安卓快照测试介绍</a></li><li id="f45d" class="kx ky hx iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated"><a class="ae jt" href="https://sergio-sastre.medium.com/styling-dynamic-strings-directly-in-xml-7b93cfe380ab" rel="noopener">直接在Android xml中设计动态字符串</a></li></ol></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="a18d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">最初发布于</em><a class="ae jt" href="https://sergiosastre.hashnode.dev/better-unit-tests-with-parameterized-testing" rel="noopener ugc nofollow" target="_blank"><em class="js">https://sergiosastre . hash node . dev</em></a><em class="js">。</em></p></div></div>    
</body>
</html>
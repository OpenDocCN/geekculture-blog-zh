<html>
<head>
<title>Case Study: A DIY Saga Pattern Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">案例研究:DIY传奇模式的实现</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/case-study-a-diy-saga-pattern-implementation-190927220a0a?source=collection_archive---------12-----------------------#2021-05-14">https://medium.com/geekculture/case-study-a-diy-saga-pattern-implementation-190927220a0a?source=collection_archive---------12-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ebe7820ec21e78ce875ab1eb635d583d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_J7lY0pTHROVZb1Q-GX5g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jorgefdezsalas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jorge Fernández Salas</a> on <a class="ae iu" href="https://unsplash.com/s/photos/airport-el-prat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于软件工程师来说，从事事件驱动架构的工作是最令人满意的经历之一:看到有多少简单的动作协作形成新兴的行为并创造奇迹，这是令人震惊的。<a class="ae iu" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank"> Saga模式</a>是一种以<a class="ae iu" href="http://www09.sigmod.org/disc/disc99/disc/nsf_acad_ind/brewer/" rel="noopener ugc nofollow" target="_blank">基础</a>方式设计长期分布式事务的优雅方式，在能够承受巨大工作负载的分布式反应系统中培养可伸缩性和弹性，同时提供良好的用户体验</p><p id="ca48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将看到如何在不使用专门框架的情况下实现saga模式(如<a class="ae iu" href="https://docs.axoniq.io/reference-guide/axon-framework/sagas" rel="noopener ugc nofollow" target="_blank"> Axon </a>、<a class="ae iu" href="https://eventuate.io/docs/manual/eventuate-tram/latest/getting-started-eventuate-tram-sagas.html" rel="noopener ugc nofollow" target="_blank"> Eventuate Tram </a>等，它们主要用于CQRS/ES/CDC实现的上下文中)。我们的目标是提高对这种机制的理解，看看即使使用“普通的”堆栈，例如流行的Spring Boot/斯普林数据，也能实现这种机制。对于实现，我使用了Kotlin，因为这是一个继续练习这种现代优雅的JVM语言的好机会😊</p><p id="5bf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:通过这篇文章，我们假设读者已经对什么是Saga模式以及它是如何工作的有所了解:有很多文章和论文</strong> <a class="ae iu" href="https://microservices.io/patterns/data/saga.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">对它进行了全面的解释</strong> </a> <strong class="ix hj">。尽管如此，如果你喜欢这个故事，并且想从我这里读到关于模式和分布式系统基础的深入描述，就在这里留下评论吧！</strong></p><blockquote class="jt ju jv"><p id="e99d" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">TL；这是代码:<a class="ae iu" href="https://github.com/cingaldi/sagapattern" rel="noopener ugc nofollow" target="_blank">https://github.com/cingaldi/sagapattern</a></p></blockquote><h1 id="2ec1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">分析阶段</h1><h2 id="4e37" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">要求</h2><p id="92ee" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">让我介绍一下我们的使用案例:</p><blockquote class="jt ju jv"><p id="1dbc" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">我们正在开发一个旅行管理平台:我们的客户可以创建<strong class="ix hj"> <em class="hi">旅行</em> </strong>在那里他们可以预订航班和酒店。我们可以使用第三方服务将使用的<strong class="ix hj">代码</strong>来处理这两种预订。如果成功预订了航班和酒店房间，我们会通知客户行程已经<strong class="ix hj"> <em class="hi">确认。如果行程确认失败，我们会通知客户</em></strong></p></blockquote><p id="be2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先要注意的是:</p><ul class=""><li id="11b3" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">一旦航班和酒店预订完成，行程就可以确定了。假设这两个步骤异步发生。因此，他们可以在几秒钟、几小时或永远不给我们一个结果</li><li id="8dc5" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">出于系统性能的考虑，所有的交互都应该以非阻塞的方式执行</li><li id="4881" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">如果由于某种原因，航班或酒店无法预订，我们应该恢复整个操作。所以每一次预订都应该被取消(看看<em class="jw">最终一致性</em>的概念是如何出现的)</li></ul><p id="d603" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用一个微型的<a class="ae iu" href="https://www.eventstorming.com/" rel="noopener ugc nofollow" target="_blank">事件风暴</a>对这些需求建模，这就是我们想要实现的</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/8660a72af1b6cdd81386aa4b6a778041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Th3MnSYBbLnT8Un4phR4Gg.png"/></div></figure><p id="5f3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看那里的紫色便笺:这被称为<em class="jw">策略</em>，表示在我们的工作流程中有一个步骤需要做出一些决定，可能在我们的系统之外。在这种情况下，我们可以把它概括概括为</p><ul class=""><li id="2d9f" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated"><strong class="ix hj">一旦</strong>航班和酒店被预订<strong class="ix hj">然后</strong>确认行程</li><li id="7193" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><strong class="ix hj">当</strong>航班或酒店取消<strong class="ix hj">时，则</strong>取消旅行</li></ul><p id="31ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，一项政策会转化成一个传奇故事</p><h2 id="be79" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">体系结构</h2><p id="10bf" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">现在想象我们在这样的建筑中工作</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/7945df747e563dd5a61e93ba803bbeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkkdG35CPtvaFJ7JG5qLDw.png"/></div></div></figure><p id="578d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到我们已经准备好异步处理工作流，并为外部服务提供一致的外观。整个事务将由<a class="ae iu" href="https://github.com/cingaldi/sagapattern/blob/master/src/main/kotlin/com/cingaldi/sagapattern/application/TripService.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> TripService </strong> </a>协调，它公开一个REST API来创建一个旅行</p><h1 id="3785" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">传奇的基石</h1><h2 id="91ff" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">传奇经理</h2><p id="7fd0" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated"><a class="ae iu" href="https://github.com/cingaldi/sagapattern/blob/master/src/main/kotlin/com/cingaldi/sagapattern/application/BookTripSagaManager.kt" rel="noopener ugc nofollow" target="_blank">这个</a>是传奇的<em class="jw">入口点</em>,充当粘合代码:简而言之，它为传奇中涉及的每个事件实现一个监听器，并决定在哪个事件之后发送什么命令。Spring framework提供了开箱即用的事件总线，所以我们不会在这个细节上纠缠太多。注意，Saga管理器属于应用程序层:它不实现真正的领域逻辑，它只负责编排流程</p><p id="e2a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，为什么不能在TripService中添加一些事件监听器呢？答案当然是SRP，并指出应用服务包装一个聚合根，而Saga管理器不只是处理一个聚合根</p><h2 id="0696" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">佐贺州和佐贺储存库</h2><p id="67aa" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated"><a class="ae iu" href="https://github.com/cingaldi/sagapattern/blob/master/src/main/kotlin/com/cingaldi/sagapattern/domain/models/TripBookingStatus.kt" rel="noopener ugc nofollow" target="_blank">传奇状态</a>(或者，为了简单起见，只是<em class="jw">传奇)</em>是位于核心的东西，并且是一个领域概念，所以——一般来说——我们可以在我们无处不在的语言中找到它，它的名称代表<em class="jw">状态、</em>进程、进程或类似的东西。它代表了应用程序状态的一部分，所以我们可以把它看作一个域<a class="ae iu" href="https://github.com/cingaldi/sagapattern/tree/master/src/main/kotlin/com/cingaldi/sagapattern/domain/models" rel="noopener ugc nofollow" target="_blank">模型</a>对象，就像实体、聚合根或值对象一样。它是持久的，所以它将有一个关联的<em class="jw">传奇</em> <em class="jw">存储库。</em>我们对这个传奇的期望是</p><ul class=""><li id="fb8d" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated"><strong class="ix hj">建立数据关联</strong>由于saga对来自不同聚合的事件做出反应，我们需要将saga与参与编排的每个聚合绑定。我们可以在代码中看到,<code class="du ml mm mn mo b">hotelCode, flightCode, tripId</code>唯一地标识了这个传奇。因此，saga存储库定义了查询方法来获取与它们相关的状态</li><li id="f418" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><strong class="ix hj">保持现状</strong>无论你发现什么，只要与每一步决策相关，传奇就能持续下去。注意，我们正在定义包含状态转换逻辑的方法，封装对象状态并保持行为接近数据是一个好的OOP习惯</li><li id="696b" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><strong class="ix hj">决定下一步</strong>每次saga状态改变时，一些命令可以被调度，这就是saga如何协调所涉及的组件。因此，每个方法都决定下一步应用什么命令</li></ul><h2 id="5e2f" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">指挥部的门面</h2><p id="606a" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">好吧，这不是生死攸关的问题，但是如果你想要一个很好的关注点分离，一个有表现力的代码，和更高的可扩展性，这个模式正好适合你。简而言之，我们将<strong class="ix hj">命令</strong>的概念实现为一条消息，该消息流入总线并匹配正确的处理程序，该处理程序反过来将该命令应用于一个集合。如果这看起来类似于ApplicationService/UseCase所做的事情，那么你没有错:它是类似的，但是以一种更加分离的方式</p><p id="d3b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现这种模式的方法很少，最简单的是提供一个合适的<strong class="ix hj">facade</strong>对象，它将包装对所需服务的依赖，并公开尽可能多的函数覆盖，就像我们有更多的命令对象一样。最复杂的方法是使用反射和注释来匹配命令和正确的处理程序。让我们坚持一个折中的<a class="ae iu" href="https://github.com/cingaldi/sagapattern/blob/master/src/main/kotlin/com/cingaldi/sagapattern/application/BookTripCommandFacade.kt" rel="noopener ugc nofollow" target="_blank">解决方案，它提供了足够的灵活性并使用了Kotlin的语法糖</a></p><h2 id="fd8f" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">处理截止日期</h2><p id="82e2" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">不要忘记传奇是用来处理<strong class="ix hj">异步</strong>进程的。如果有一件事是所有异步的事情都做的，那就是当你需要它们的时候不要出现。酒店服务器可能会崩溃，航空公司可能会破产，所以有时我们需要以某种方式结束</p><p id="babb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于这个原因，saga可能会有<strong class="ix hj">截止日期。</strong>截止时间是由基于时间的事件触发的特定事件监听器。它可以在传奇故事开始一段时间后触发。在这两种情况下，尽管解决方案在SagaManager级别上看起来微不足道，但它的实现依赖于可用的基础设施工具</p><p id="4b0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以只使用一个cronjob或者一个<a class="ae iu" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank">外部触发器</a>。此外，一些面向消息的中间件(如<a class="ae iu" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-timers.html" rel="noopener ugc nofollow" target="_blank">亚马逊SQS </a>或<a class="ae iu" href="https://stackoverflow.com/questions/4444208/delayed-message-in-rabbitmq" rel="noopener ugc nofollow" target="_blank"> with some hacks，RabbitMQ </a>)提供<em class="jw">延迟消息</em> <strong class="ix hj"> <em class="jw"> </em> </strong>功能，让您在saga启动时发出命令，如“10分钟后，触发超时事件”。在这一点上，我们将让我们的传奇优雅地失败</p><p id="ac66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们将使用Kotlin协程来采用一种快速而简单的解决方案。现在只需要扩展代码来持久化预定的任务并健壮地为它们服务。此外，像优化一样，为saga管理器提供定位任务和在成功完成的情况下取消任务的方法会很好</p><h2 id="e5a5" class="ky kb hi bd kc kz la lb kg lc ld le kk jg lf lg ko jk lh li ks jo lj lk kw ll bi translated">测试传奇</h2><p id="8a72" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">通常，我们可以从测试的样子中得到多少代码是好的。重要的是要有一个简单的方法来测试整个故事，定义工作流可以遵循的所有可能的路径，并断言结果是预期的。在使用了<em class="jw"> Axon Framework </em>之后，我爱上了他们流畅的、行为驱动的测试工具。基本上，我们想测试(也)SagaManager，测试应该是这样的:</p><pre class="mg mh mi mj fd mp mo mq mr aw ms bi"><span id="4752" class="ky kb hi mo b fi mt mu l mv mw">given(SomePriorEvents)<br/>when(CertainEventTriggered)<br/>then(DispatchedThisCommand)</span></pre><p id="00b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，断言反对CommandDispatcher很有帮助。此外，为了跨步骤调用保持状态，我们可以使用一个<a class="ae iu" href="https://github.com/cingaldi/sagapattern/tree/master/src/test/kotlin/com/cingaldi/sagapattern/__fakes" rel="noopener ugc nofollow" target="_blank">假的SagaRepository </a>，它保存了saga的一个实际实例。这可以增加关于解决方案的<a class="ae iu" href="https://github.com/cingaldi/sagapattern/blob/master/src/test/kotlin/com/cingaldi/sagapattern/application/BookTripSagaManagerTest.kt" rel="noopener ugc nofollow" target="_blank">测试</a>信心，其中我们使用存根来测试单个步骤</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/f2a2005f3141da83fc4bb4ce93c5ecc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CWUCu4N0dBb2lRhwzMIfQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">how it looks like</figcaption></figure><h1 id="93d5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">少了什么？</h1><ul class=""><li id="2c50" class="lr ls hi ix b iy lm jc ln jg my jk mz jo na js lw lx ly lz bi translated">我们只实施了快乐之路，但是当酒店或航班未被确认时会发生什么？</li><li id="09c1" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">我们并没有真正管理内部故障。如何克服并发写入导致的异常？如果消息代理无法将任务分配给酒店/航班服务，会发生什么情况？</li><li id="f3aa" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">航班(或酒店)甚至可以在确认后取消，这可能会触发客户的退款政策。我们如何扩展这个传奇来完成这个过程的这一部分？</li></ul><h1 id="c58b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="e7aa" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在本文中，我们实现了一个小应用程序，它借助Saga模式编排了一个分布式事务。用例相当简单，实现离生产级还很远。尽管如此，开发它对我来说很有趣，也给了我一些小挑战。希望读者也是如此，我将以一个提示结束这个故事:<strong class="ix hj">如果你想知道更好的东西，就从头开始编码吧！</strong></p></div></div>    
</body>
</html>
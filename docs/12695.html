<html>
<head>
<title>Path Sum III — Leetcode 437</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">路径和III — Leetcode 437</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/path-sum-iii-leetcode-437-588d8e56acac?source=collection_archive---------2-----------------------#2022-05-27">https://medium.com/geekculture/path-sum-iii-leetcode-437-588d8e56acac?source=collection_archive---------2-----------------------#2022-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你好，我自己<a class="ae jd" rel="noopener" href="/@gauriwankhade"> Gauri wankhade </a>，<br/>软件开发人员，印度班加罗尔</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ee767f81f491eba47903a20d9e0afb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zww1em-yk5uGNXCOBFxszQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">image source — <a class="ae jd" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/</a></figcaption></figure><p id="e441" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将为下面的问题陈述解决<a class="ae jd" href="https://leetcode.com/problems/path-sum-iii/" rel="noopener ugc nofollow" target="_blank"> leetcode问题</a>。</p><p id="e83c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">问题陈述:- </strong></p><p id="fdc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定二叉树的<code class="du ju jv jw jx b">root</code>和一个整数<code class="du ju jv jw jx b">targetSum</code>，返回<em class="jy">路径的数量，其中沿着路径的值的总和等于</em> <code class="du ju jv jw jx b">targetSum</code>。</p><p id="1c5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">路径不需要在根或叶子处开始或结束，但是它必须向下(即，仅从父节点行进到子节点)。</p><p id="6736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="jf jg jh ji fd jz jx ka kb aw kc bi"><span id="ae02" class="kd ke hi jx b fi kf kg l kh ki"><strong class="jx hj">Input:</strong> root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><span id="2b9a" class="kd ke hi jx b fi kj kg l kh ki"><strong class="jx hj">Output:</strong> 3</span><span id="195b" class="kd ke hi jx b fi kj kg l kh ki"><strong class="jx hj">Explanation:</strong> The paths that sum to 8 are shown below.</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kk"><img src="../Images/18543c0546453ec23af13a11b0c2dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-5KCdJQyEYTe9DLkFVOeA.png"/></div></div></figure><p id="877d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong></p><ul class=""><li id="34bf" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">树中的节点数量在范围<code class="du ju jv jw jx b">[0, 1000]</code>内。</li><li id="8fac" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du ju jv jw jx b">-109 &lt;= Node.val &lt;= 109</code></li><li id="3fac" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du ju jv jw jx b">-1000 &lt;= targetSum &lt;= 1000</code></li></ul><p id="3a59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">思维过程:- </strong></p><p id="00ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到总和等于target的所有路径，我们需要考虑从父节点到子节点的树中所有可能的路径。最基本的方法是将每个节点视为根节点，并计算来自该节点的路径的总和。</p><p id="5cae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下图中，我们将值为10的节点视为根节点，并计算了路径和。在探索路径时，如果我们遇到路径和等于目标，则递增计数器。</p><p id="9a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对所有节点重复相同的操作，并继续递增计数器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/3c021fdafa6d7f0c88b15368efe993ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rxYOBbs0uMFjp-npqUEAA.png"/></div></div></figure><p id="d60e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">代码:- </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="e775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">复杂性分析:- </strong></p><ul class=""><li id="50aa" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">时间复杂度:- O(N)其中N是树中节点的数量</li><li id="1030" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">空间复杂度:- O(N ),因为我们使用堆栈来存储每个节点。</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="353e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经讨论了给定问题的强力方法。在前面的解决方案中，有许多重复的操作，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/815d6a10504d7c42364939b6b68145f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99L9SQoijhgaXcBKLd4Scw.png"/></div></div></figure><p id="7e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们可以看到在两种情况下遍历了相同的路径。类似的重复将发生在所有下层。</p><blockquote class="lk"><p id="4a4c" class="ll lm hi bd ln lo lp lq lr ls lt jc dx translated">我们可以通过存储路径和来优化时间复杂度吗？</p></blockquote><p id="56b3" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">这里，我们使用前缀求和来优化我们的方法。<a class="ae jd" href="https://en.wikipedia.org/wiki/Prefix_sum" rel="noopener ugc nofollow" target="_blank">前缀求和</a>是一种通过增加切片大小来计算和存储切片中连续数字之和的技术。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/e09c7d87f19da429ff8b4853d3da5e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAv8p18aW85GrqE4hWEckg.png"/></div></div></figure><p id="bb92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用Prefix-sum在二叉树中查找其值总和达到目标总和的节点。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/6c9461cc64d8fea35451b0530b79e702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zBhCNji56uetYS-goSXAg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">image source- <a class="ae jd" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/</a></figcaption></figure><h2 id="5749" class="kd ke hi bd mb mc md me mf mg mh mi mj iq mk ml mm iu mn mo mp iy mq mr ms mt bi translated">它是如何工作的？</h2><p id="70ce" class="pw-post-body-paragraph if ig hi ih b ii mu ik il im mv io ip iq mw is it iu mx iw ix iy my ja jb jc hb bi translated">考虑上面的例子，我们试图搜索其总和等于目标的节点，然后在前缀-总和映射中搜索某个值，其中当前总和与目标之间的差等于该值。</p><p id="e45c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是证据</p><pre class="jf jg jh ji fd jz jx ka kb aw kc bi"><span id="0e53" class="kd ke hi jx b fi kf kg l kh ki">arr          = [10,  5,  3,  3]<br/>prefix-sum   = [10, 15, 18, 21]<br/>target       = 8</span><span id="2f84" class="kd ke hi jx b fi kj kg l kh ki">In the third iteration we have found the subarray whose sum adds up to target.</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mz"><img src="../Images/e6d21eabef2ee9d548220926f6a8e7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLSaEGOCIkmqTtIUchBmLA.png"/></div></div></figure><p id="745d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">解决方案(优化):- </strong></p><p id="301b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步</p><p id="c9d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从根节点开始遍历，将前缀和存储在某个地方，最好存储在hashmap中，因为它以恒定的时间进行搜索操作。</p><p id="b0cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步</p><p id="1459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">维护一个计数器来存储结果。在以下两种情况下增加计数器的值—</p><ul class=""><li id="1ef8" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">当前总和等于目标值</li><li id="ee7f" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">在前缀和映射中找到当前和与目标之间的差值</li></ul><p id="95cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三步</p><p id="f19e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦任何节点的左右子树都被遍历，从前缀和数组中删除它们的和。这是为了避免无效路径(不遵循父到子流程)</p><p id="fa99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jy">注:- </em> </strong></p><p id="9665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jy">我们在前缀和映射中遇到(当前和-目标)的次数，这将是目前子阵列的数量，其和加起来达到目标。</em></p><p id="6754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">代码:- </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">⚡ <strong class="ih hj">复杂性分析:- </strong></p><ul class=""><li id="a47c" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">时间复杂度:- O(N)，其中N是树中节点的数量</li><li id="7895" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">空间复杂度:- O(N)，我们使用hashmap存储前缀和</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="d849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这篇文章有用，请分享和喜欢。在medium <a class="na nb ge" href="https://medium.com/u/6966187582ce?source=post_page-----588d8e56acac--------------------------------" rel="noopener" target="_blank"> Gauri wankhade </a>和Twitter<a class="ae jd" href="https://twitter.com/gauri_infj" rel="noopener ugc nofollow" target="_blank">Gauri _ infj</a>上关注我。</p><p id="0eaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢！！！</p><p id="12e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐学习…</p></div></div>    
</body>
</html>
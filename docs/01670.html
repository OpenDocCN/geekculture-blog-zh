<html>
<head>
<title>Functional Composition in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的功能成分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/functional-composition-in-ruby-a9929055899a?source=collection_archive---------20-----------------------#2021-04-19">https://medium.com/geekculture/functional-composition-in-ruby-a9929055899a?source=collection_archive---------20-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="450d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们来探索一下函数式思维，以及它在wrt Ruby中意味着什么。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/56c6edb04d48b79381379259ebe14b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKfbA-8V1PXdDJJi5LfsWg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@valeriabold?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Valeria Bold</a> on <a class="ae jn" href="https://unsplash.com/s/photos/functional-composition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3070" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们都知道Ruby是一种面向对象的语言，虽然这是事实，但是我们仍然可以以一种纯函数的方式使用Ruby。如果我们那样做，就不会太Ruby了，所以让我们看看我们可以从函数式编程中得到什么启发。</p><p id="73e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">函数式编程本质上就像编写一个数学程序。让我们通过一个例子来理解这一点，假设我想找出数组中的第一个奇数。现在我们将写两个目标相同的函数，一个用Ruby方式，另一个用函数方式。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="0731" class="kp kq hi kl b fi kr ks l kt ku"># Ruby way<br/>def first_odd(array)<br/>  for i in 0...array.size<br/>    break i if i.odd?<br/>  end<br/>end</span></pre><p id="adcd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Ruby函数中，我们在循环的每次迭代中重新分配I的值，这在数学函数中是不可能的，因为我们定义了一个变量，这是定义而不是赋值。这是函数式编程和非函数式编程的主要区别，函数式编程强调不变性和引用透明性(意思是如果你一次又一次地传递相同的值给一个函数，输出总是相同的。)现在，让我们看看如何以函数方式编写相同的方法:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="6ef5" class="kp kq hi kl b fi kr ks l kt ku"># Functional way<br/>def first_odd(array)<br/>  i = array.shift <br/>  return nil if array.empty?<br/>  if i.odd?<br/>    return i<br/>  else<br/>    first_odd(array) <br/>  end <br/>end</span></pre><p id="4c07" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用函数的方式我们写了一个递归程序，它就像一个数学函数，即它检查第一个元素是否是奇数，如果不是，它用剩余的元素调用自己。由此我们可以得出关于函数式编程的三个要点，我们需要记住:</p><ol class=""><li id="be9c" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated">函数是定义，而不是指令列表。</li><li id="7318" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">我们不分配变量，我们定义事物。</li><li id="91b8" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">我们可以在另一个函数中传递函数，就像变量一样。</li></ol><p id="9879" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们更深入地探讨功能组合如何在日常生活问题中拯救我们。假设我们有一个狗收养申请，我们被要求提供一份关于这些狗被收养情况的报告。你已经有了一个狗及其属性的列表。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="0817" class="kp kq hi kl b fi kr ks l kt ku"># We have:<br/>$ dogs.sample<br/>=&gt; #&lt;struct Dog adoption_fees: 12, rating: 4, breed: :golden, adopted: 22&gt;</span></pre><p id="207e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以在报告中要求的第一件事非常简单，只是平均收养费用。为此，我们可以创建一个报告类，然后添加一个inititalize方法来获取并存储所有狗的列表，然后添加一个run方法来计算平均收养费用。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="e24c" class="kp kq hi kl b fi kr ks l kt ku">class Report<br/>  def initialize(dogs)<br/>    @dogs = dogs<br/>  end</span><span id="4ce2" class="kp kq hi kl b fi lj ks l kt ku">  # <a class="ae jn" href="https://apidock.com/ruby/Enumerable/inject" rel="noopener ugc nofollow" target="_blank">inject</a> is an enumerable function<br/>  def run<br/>    money_taken = @dogs.inject(0) do |total, dog| <br/>      (dog.adoption_fees * dog.adopted) + total<br/>    end<br/>    <br/>    total_adoption =  @dogs.inject(0) do |total, dog| <br/>      dog.adopted + total<br/>    end<br/>    <br/>    money_taken / total_adoption<br/>  end <br/>end</span><span id="56ae" class="kp kq hi kl b fi lj ks l kt ku">$ Report.new(dogs).run<br/>=&gt; 20</span></pre><p id="839b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最近，由于COVID，许多Golden被收养，现在我们需要一份新的报告来显示组织从中获得的平均收养费用。我们可以调整前面的代码来添加一个新的参数，这个参数只选择一个给定的品种并进行计算。接下来我们需要被收养的前三个品种。这些请求会使我们报告类变得更长，随着新请求的到来，这种方法将变得更难维护，并将引入许多标志和条件逻辑。有很多方法可以重构这种情况，但是因为我们在看函数组合，所以让我们看看用Ruby的函数编程思想可以做些什么。</p><p id="fa8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">#注意:这部分会大量使用lambdas，所以如果你需要修改:<a class="ae jn" href="https://anjali-jaiswal.medium.com/block-proc-and-currying-in-ruby-6c00f91959f6" rel="noopener"> Ruby Blocks，Procs和Lambdas </a></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="3843" class="kp kq hi kl b fi kr ks l kt ku"># lambda for summing up using inject<br/>sum = -&gt; list { list.inject(&amp;:+) } </span><span id="a1bd" class="kp kq hi kl b fi lj ks l kt ku"># lambda for calculating average adoption fee<br/>total_adoption_fee = -&gt; dogs do<br/>  adoption_fee = dogs.map { |dog| dog.adoption_fees * dog.adopted }<br/>  sum[adoption_fee]<br/>end<br/> <br/># lambda for calculating average adoption fee<br/>avg_adoption_fee = -&gt; dogs do<br/>  total_adoption_fee[dogs]/ total_adoptions[dogs]<br/>end</span><span id="b95b" class="kp kq hi kl b fi lj ks l kt ku"># lambda for getting number of dogs adopted<br/>total_adoption = dogs { sum[dogs.map(&amp;:adopted)] }</span><span id="2ab2" class="kp kq hi kl b fi lj ks l kt ku">$ avg_adoption_fee[DOGS] <br/>=&gt; 20</span><span id="a925" class="kp kq hi kl b fi lj ks l kt ku"># now, we need to get adoption fees only for golden's<br/># hence we will add a new lambda for getting jut one breed<br/>golden = -&gt; dogs { dogs.select { |dog| dog.breed == :golden }}</span></pre><p id="957d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们重写我们的Reports类，在这里我们可以使用我们刚刚创建的lambdas。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="979a" class="kp kq hi kl b fi kr ks l kt ku">class FunctionalReport<br/> <br/>  # splated argument will take a list of functions generated at<br/>  # each stage of report<br/>  def initialize(dogs, *fns)<br/>    @dogs = dogs<br/>    @fns = fns<br/>  end</span><span id="4c7e" class="kp kq hi kl b fi lj ks l kt ku">  def run<br/>    @fns.inject(@dogs) do |last_result, fn|<br/>      fn[last_result]<br/>    end<br/>  end<br/>end</span><span id="ee72" class="kp kq hi kl b fi lj ks l kt ku">$ FunctionalReport.new(DOGS, avg_adoption_fee).run<br/>=&gt; 20<br/>$ FunctionalReport.new(DOGS, golden, avg_adoption_fee).run<br/>=&gt; 12</span><span id="fa65" class="kp kq hi kl b fi lj ks l kt ku"># We can create more lambdas and work accordingly, lets say someone # wants to know adoption fees of dogs which have rating of three and # higher</span><span id="a196" class="kp kq hi kl b fi lj ks l kt ku">high_rating = -&gt; dogs { dogs.select { |d| d.rating &gt;= 3 }}</span><span id="04d8" class="kp kq hi kl b fi lj ks l kt ku">$ FunctionalReport.new(DOGS, high_rating, avg_adoption_fee).run<br/>=&gt; 15</span></pre><p id="ce4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如上所述，通过使用函数式编程，我们可以安全地推断出:</p><ol class=""><li id="9ac3" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated">我们可以在不修改现有代码的情况下添加新功能</li><li id="53aa" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">用很少的代码创建报告的每一步</li><li id="c4e9" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">不需要支持来自其他步骤的无关代码</li></ol><p id="3f1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但问题是这不是很Rubish，并且忽略了Ruby必须提供的很多表现力和能力。那么，我们可以从Ruby的函数式编程中得到什么呢？</p><blockquote class="lk"><p id="3bee" class="ll lm hi bd ln lo lp lq lr ls lt kj dx translated">我们可以使用像map、select、inject、blocks这样的方法来创建数据列表，lambdas用于以后运行代码..</p></blockquote><p id="9609" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">现在从这篇文章中得到的应该是方法，我们编写了实现一些小的特定任务的lambdas，并找到了让它们一起工作的方法。我们可以对实现小的特定规则的对象做同样的事情，并找到将它们组合在一起的方法。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="3748" class="kp kq hi kl b fi kr ks l kt ku">class BreedFilter<br/>  def initialize(breed)<br/>    @breed = breed<br/>  end</span><span id="0f74" class="kp kq hi kl b fi lj ks l kt ku">  def apply(dogs)<br/>    dogs.select { |dog| dog.breed == @breed }<br/>  end<br/>end</span></pre><p id="3591" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种面向对象的编码方式更容易阅读和思考，在编写Ruby时感觉更自然，最重要的是它将数据视为不可变的。函数式编程有很多东西要教我们，我们不必编写纯粹的函数式代码来获得好处。希望这有助于您理解如何编写更好的代码。再见了，稍后我们会带来新的花絮。保持快乐，保持安全。</p></div></div>    
</body>
</html>
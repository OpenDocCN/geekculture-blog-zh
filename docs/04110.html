<html>
<head>
<title>Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贮藏</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/caching-b863bbce4bf?source=collection_archive---------51-----------------------#2021-06-21">https://medium.com/geekculture/caching-b863bbce4bf?source=collection_archive---------51-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bbff" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">缓存使您能够更好地利用已经拥有的资源</h2></div><p id="0ebb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缓存利用了引用局部性原则:<strong class="iz hj">最近请求的数据可能会再次被请求</strong>。缓存类似于短期内存:它的空间有限，但通常比原始数据源快，并且包含最近访问的项目。</p><p id="3883" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们几乎用于每个计算层:硬件、操作系统、web浏览器、web应用程序等等。缓存可以存在于体系结构中的所有级别，但通常位于最靠近前端的位置，在那里实现缓存以快速返回数据，而不会加重下游级别的负担。</p><h1 id="a625" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">应用服务器缓存</h1><p id="887f" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">将缓存直接放在<strong class="iz hj">请求层节点</strong>上，可以实现响应数据的本地存储。每次向服务发出请求时，节点都会快速返回本地缓存的数据(如果存在的话)。如果数据不在缓存中，发出请求的节点将从磁盘中获取数据。一个请求层节点上的缓存也可以位于内存中(非常快)和节点的本地磁盘上(比访问网络存储更快)。</p><p id="6c83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你把它扩展到许多节点时会发生什么？如果请求层扩展到多个节点，仍然完全有可能让每个节点托管自己的缓存。但是，如果您的负载平衡器在节点之间随机分配请求，相同的请求将会到达不同的节点，从而增加缓存未命中。克服这个障碍的两个选择是<strong class="iz hj">全局缓存</strong>和<strong class="iz hj">分布式缓存</strong>。</p><h1 id="eb50" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">内容交付(或分发)网络(CDN)</h1><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/4093a5ce0d8fc868faa5b637e540c8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBxbm9NHJBXcbukkqGWjZA.png"/></div></div></figure><p id="28ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">cdn是一种缓存，用于为大量静态媒体服务的网站。请求将首先向CDN请求一块静态媒体；如果内容在本地可用，CDN将提供该内容。如果它不可用，CDN将向后端服务器查询该文件，将其缓存在本地，并提供给发出请求的用户。</p><p id="9912" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们正在构建的系统不够大，无法拥有自己的CDN，我们可以通过使用Nginx之类的轻量级HTTP服务器从单独的子域(例如static.yourservice.com)提供静态媒体，并在以后将DNS从您的服务器切换到CDN，从而简化未来的过渡。</p><h1 id="832d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">缓存失效</h1><p id="2ddf" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">虽然缓存很棒，但需要一些维护来保持缓存与真实来源(如数据库)的一致性。如果数据在数据库中被修改，它应该在缓存中失效。否则，这会导致不一致的应用程序行为。</p><p id="97e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决这个问题被称为缓存失效；为此使用了三种主要方案:</p><h2 id="b437" class="lc ju hi bd jv ld le lf jz lg lh li kd jg lj lk kf jk ll lm kh jo ln lo kj lp bi translated">直写高速缓存</h2><p id="93e1" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在这种方案下，数据被同时写入缓存和相应的数据库。缓存的数据允许快速检索，并且由于相同的数据写入永久存储，我们将在缓存和存储之间实现完全的数据一致性。此外，该方案确保在崩溃、电源故障或其他系统中断的情况下不会丢失任何东西。</p><p id="827c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管直写最大限度地降低了数据丢失的风险，但由于在向客户端返回成功之前，每个写操作都必须执行两次，因此这种方案的缺点是写操作延迟更长。</p><h2 id="7f96" class="lc ju hi bd jv ld le lf jz lg lh li kd jg lj lk kf jk ll lm kh jo ln lo kj lp bi translated">写回缓存</h2><p id="ecd7" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">这种技术类似于直写缓存，但数据直接写入永久存储，绕过缓存。这可以减少缓存被随后不会被重新读取的写操作淹没，但缺点是对最近写入的数据的读请求将产生“缓存未命中”，并且必须从较慢的后端存储读取，并且经历较高的延迟。</p><h2 id="f060" class="lc ju hi bd jv ld le lf jz lg lh li kd jg lj lk kf jk ll lm kh jo ln lo kj lp bi translated">回写高速缓存</h2><p id="1a4d" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在这种模式下，数据被单独写入缓存，并立即向客户端确认完成。在指定的时间间隔后或在某些条件下，向永久存储器写入数据。这为写密集型应用带来了低延迟和高吞吐量；但是，这种速度会带来数据丢失的风险，因为写入数据的唯一副本在缓存中。</p><h1 id="0c8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">缓存回收策略</h1><p id="f79b" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">以下是一些最常见的缓存回收策略:</p><ul class=""><li id="9f78" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">先进先出</li></ul><p id="4e52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高速缓存会驱逐首先被访问的第一个块，而不考虑它之前被访问的频率或次数。</p><ul class=""><li id="ce22" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">后进先出法</li></ul><p id="82b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高速缓存首先驱逐最近访问的块，而不考虑它之前被访问的频率或次数。</p><ul class=""><li id="cb5c" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">最近最少使用(LRU)</li></ul><p id="458f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先丢弃最近最少使用的项目。LRU是最流行的缓存回收策略。</p><ul class=""><li id="71f0" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">最近使用的(MRU)</li></ul><p id="b225" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与LRU相反，首先丢弃最近使用的项目。</p><ul class=""><li id="4e00" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">最不常用(LFU)</li></ul><p id="64b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算需要某个项目的频率。那些最不常用的首先被丢弃。</p><ul class=""><li id="b431" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">随机替换</li></ul><p id="6f2d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随机选择一个候选物品，并在必要时丢弃它以腾出空间。</p></div></div>    
</body>
</html>
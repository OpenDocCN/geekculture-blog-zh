<html>
<head>
<title>Modern C++ with ESP32</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有ESP32的现代C++</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modern-c-with-esp32-dcd3918dd978?source=collection_archive---------1-----------------------#2022-01-17">https://medium.com/geekculture/modern-c-with-esp32-dcd3918dd978?source=collection_archive---------1-----------------------#2022-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d405ea7995c96c0ee53f3e4bfed70433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvqBFoh6dPvbsSyaLoPEgA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">ESP32-SOLO-1 board. Photo from <a class="ae iu" href="http://stringfixer.com" rel="noopener ugc nofollow" target="_blank">stringfixer.com</a></figcaption></figure><p id="08e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传统上，微控制器编程是使用C编程语言来完成的，尤其是当您使用小型微控制器时。感谢Arduino，我们都能够轻松地将C++用于小型微控制器，如ATmega328P (Arduino UNO)。众所周知，与C相比，C++拥有丰富的特性，但是在微控制器编程中，我们能使用多少C++特性呢？</p><p id="bbf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了回答这个问题，我们将使用ESP32，因为它非常强大，具有相对较大的存储容量(512 KB RAM和4 MB SPI闪存)。另一个原因是Arduino对ESP32的支持默认启用了C++11特性。因此，您可以开始使用现代C++而无需额外的配置。</p><p id="2ce6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像C++14、C++17甚至C++20这样的新标准怎么样？简而言之，你可以使用它们，但是要启用它们还需要做很多额外的工作，我们不会在这篇文章中一一介绍。</p><p id="2bd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们打算先用C++11，在以后的帖子里再转到下一个标准版本。所以，让我们开始吧！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="5a97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Arduino for ESP32在其构建脚本中默认启用C++11。下面是直接从GitHub的<a class="ae iu" href="https://github.com/espressif/arduino-esp32" rel="noopener ugc nofollow" target="_blank"> espressif/arduino-esp32 </a>库中的platform.txt文件中获取的完整的ESP32 c++构建标志。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="4880" class="kj kk hi kf b fi kl km l kn ko">compiler.cpp.flags.esp32=-mlongcalls -Wno-frame-address -ffunction-sections -fdata-sections -Wno-error=unused-function -Wno-error=unused-variable -Wno-error=deprecated-declarations -Wno-unused-parameter -Wno-sign-compare -ggdb -Os -freorder-blocks -Wwrite-strings -fstack-protector -fstrict-volatile-bitfields -Wno-error=unused-but-set-variable -fno-jump-tables -fno-tree-switch-conversion <strong class="kf hj">-std=gnu++11</strong> -fexceptions -fno-rtti  -MMD -c</span></pre><p id="9777" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，它使用C++11，但启用了GNU扩展，而不是使用普通的C++11。我不知道他们为什么使用GNU扩展，但是我们会在以后的文章中解决这个问题。</p><p id="a263" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，确认了Arduino for ESP32默认使用C++11(带GNU扩展)。所以我们开始用C++11写应该不需要额外的配置。</p><p id="478a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">C++11有很多新特性，但我不打算在这篇文章中一一介绍。我建议你去看看<a class="ae iu" href="https://www.youtube.com/watch?v=D5n6xMUKU3A" rel="noopener ugc nofollow" target="_blank">简森·特纳的视频</a>，它在十二分钟内突出了C++11的重要部分。他很好地解释了C++11的每个重要部分。请随意跳到视频，然后回到这里。</p><p id="e3c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看下面的代码清单</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="c6c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码清单中，我们使用了C++11的一些特性。</p><p id="31b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们使用了函数版本的<code class="du kr ks kt kf b">attachInterrupt</code>函数。通常情况下，你必须像这样用旧的C函数风格来定义函数</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="12f8" class="kj kk hi kf b fi kl km l kn ko">void interruptFunction()<br/>{<br/> // ...<br/>}</span></pre><p id="49ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">as <code class="du kr ks kt kf b">attachInterrupt</code>函数接受一个指向函数类型<code class="du kr ks kt kf b">void (*interruptCallback)(void)</code>的指针。C++11引入了包装函数的<a class="ae iu" href="https://en.cppreference.com/w/cpp/utility/functional/function" rel="noopener ugc nofollow" target="_blank"> std::function </a>类模板。</p><p id="3762" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kr ks kt kf b">FunctionalInterrupt.h</code>头文件引入了接受<code class="du kr ks kt kf b">std::function&lt;void(void)&gt;</code>而不是函数指针的<code class="du kr ks kt kf b">attachInterrupt</code>函数版本。这样，我们可以使用一个<em class="ku"> lambda函数</em>来处理中断！</p><p id="04d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第7行引入了<code class="du kr ks kt kf b">using</code>关键字，它作为引用先前定义的类型的<a class="ae iu" href="https://en.cppreference.com/w/cpp/language/type_alias" rel="noopener ugc nofollow" target="_blank">类型别名</a>，类似于<code class="du kr ks kt kf b">typedef</code>关键字。但是，我们为什么要为中断函数定义类型别名呢？我们很快就会知道了。</p><p id="2403" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们定义了一个类型为<code class="du kr ks kt kf b">InterruptFn</code>的<a class="ae iu" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank"> lambda函数</a>,这是我们之前定义的。该函数坚持其给定的类型，因为它不接受任何参数，也不返回任何内容(void)。</p><p id="a70e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用<a class="ae iu" href="https://en.cppreference.com/w/cpp/language/list_initialization" rel="noopener ugc nofollow" target="_blank">列表初始化语法</a>初始化lambda函数<code class="du kr ks kt kf b">interruptFuncion</code>。在这种情况下，它的作用与下面的代码清单相同</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="249b" class="kj kk hi kf b fi kl km l kn ko">InterruptFn interruptFunction = []() {<br/>  // ...<br/>};</span></pre><p id="94e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第19行，我们使用了<a class="ae iu" href="https://en.cppreference.com/w/cpp/language/auto" rel="noopener ugc nofollow" target="_blank"> auto </a>关键字，让我们在不知道赋值的实际类型的情况下定义变量。如果你正在初始化一个有长名字的类的实例，这个关键字是很有帮助的，特别是当你使用<code class="du kr ks kt kf b">new</code>关键字时，你必须键入类名两次。</p><h2 id="e9c9" class="kj kk hi bd kv kw kx ky kz la lb lc ld jg le lf lg jk lh li lj jo lk ll lm ln bi translated">放弃</h2><p id="14fd" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">通常，你不希望使用lambda函数来处理中断，因为这可能会有性能问题。使用旧的函数语法和<code class="du kr ks kt kf b">IRAM_ATTR</code>属性仍然被认为是定义中断处理程序的最佳方法。我在这里使用lambda的唯一原因是为了演示C++11的新特性。我不鼓励您在生产环境中也这样做。所以，使用起来风险自担！</p><p id="f528" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果我们将此代码编译并上传到任何具有内置LED(引脚定义为<code class="du kr ks kt kf b">LED_BUILTIN</code>)并具有连接到GPIO 0的物理按钮的ESP32供电板，我们可以看到LED状态(开/关)取决于按钮状态(按下/释放)。</p><h2 id="9975" class="kj kk hi bd kv kw kx ky kz la lb lc ld jg le lf lg jk lh li lj jo lk ll lm ln bi translated">如果我们不定义和使用InterruptFn别名会怎样？</h2><p id="e274" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">ESP32的<code class="du kr ks kt kf b">attachInterrupt</code>函数是在ESP32的Arduino核心中声明和定义的。如果我们包含了<code class="du kr ks kt kf b">Arduino.h</code>头，我们将得到带有以下签名的<code class="du kr ks kt kf b">attachInterrupt</code>函数</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="9954" class="kj kk hi kf b fi kl km l kn ko">void attachInterrupt(uint8_t pin, <strong class="kf hj">void (*)(void)</strong>, int mode);</span></pre><p id="5ef7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，第二个参数是一个指向函数的指针。</p><p id="a752" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们还包括了<code class="du kr ks kt kf b">FunctionalInterrupt.h</code>头，它提供了<code class="du kr ks kt kf b">attachInterrupt</code>功能，但是具有不同的签名</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="49d1" class="kj kk hi kf b fi kl km l kn ko">void attachInterrupt(uint8_t pin, <strong class="kf hj">std::function&lt;void(void)&gt; intRoutine</strong>, int mode);</span></pre><p id="9c9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们不明确指定中断函数的类型，编译器会感到困惑，因为我们的实现与两个<code class="du kr ks kt kf b">attachInterrupt</code>函数声明都匹配。这将导致如下所示的编译器错误</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="1a41" class="kj kk hi kf b fi kl km l kn ko">src/main.cpp:24:54: error: call of overloaded 'attachInterrupt(uint8_t&amp;, setup()::&lt;lambda()&gt;&amp;, int)' is ambiguous</span></pre><p id="4215" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种方法都会产生与上面相同的错误</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="36d8" class="kj kk hi kf b fi kl km l kn ko">auto interruptFunction{<br/>  // ...<br/>};</span><span id="79ed" class="kj kk hi kf b fi lt km l kn ko">// or </span><span id="e657" class="kj kk hi kf b fi lt km l kn ko">attachInterrupt(button, [](){ /* ... */ }, CHANGE);</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="138a" class="kj kk hi bd kv kw kx ky kz la lb lc ld jg le lf lg jk lh li lj jo lk ll lm ln bi translated">结论</h2><p id="6aa6" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">这是ESP32使用现代C++的第一篇帖子的结尾。我们没有涵盖C++11的所有漂亮和酷的特性，因为C++中引入了很多东西，我还没有找到ESP32特性的用例，但至少我们知道我们可以使用C++11而无需额外的配置。</p><p id="7867" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！请不要犹豫给我你的反馈。</p></div></div>    
</body>
</html>
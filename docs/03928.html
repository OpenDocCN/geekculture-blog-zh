<html>
<head>
<title>Are your REST APIs really RESTful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的REST APIs真的是RESTful的吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/are-your-rest-apis-really-restful-a6459406d52?source=collection_archive---------38-----------------------#2021-06-17">https://medium.com/geekculture/are-your-rest-apis-really-restful-a6459406d52?source=collection_archive---------38-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a714" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">REST是分布式超媒体系统的一种架构风格。遵循REST架构的API通常被称为RESTful。<br/>写这篇文章背后的动机是我自己长期以来对REST的误解。仅仅使用HTTP作为传输协议并不足以将web API归类为RESTful(这是我最初用来分类它们的方式:p)。事实上，REST本身是独立于传输协议的。也就是说，本文假设HTTP是底层传输协议。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e4a9e377a3b388d8c697cb1837e8f31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1VD0SANNsqpwH6r2xOafg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jt" href="https://unsplash.com/s/photos/interface?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d17c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文试图解释在设计一个真正RESTful的API时应该遵循的约束，但是我应该提到，开发人员应该选择他们认为对他们的用例有益的东西，而不是教条地对待这些约束。比如，如果你同时控制API的客户端和服务器端，那么使用一些流行的RPC实现(比如gRPC)来设计RPC风格的API可能会更加高效和快速。解决了这个问题，让我们开始研究REST APIs。</p><p id="22ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">罗伊·菲尔丁在2000年的著名论文<a class="ae jt" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener ugc nofollow" target="_blank">中首次描述了REST。REST旨在通过定义客户端和服务器交互的一些约束，在客户端和服务器之间定义一个统一的连接器接口。它根据资源定义了客户机和服务器之间的交互，客户机请求获取/更新资源(或资源集合)，服务器以JSON和XML等简单格式返回所请求资源的表示。HTTP动词可以用来描述需要在资源上执行的操作。以下是REST架构的不同原则:</a></p><h1 id="4b5f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">客户端-服务器</strong></h1><p id="8c56" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">用户界面问题应该与数据存储问题分开。服务器保存资源，客户端向服务器发送请求来操作这些数据。REST系统必须按照这种客户机-服务器模型运行。</p><h1 id="c2cf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">无状态</strong></h1><p id="00b9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是REST风格最常见、最广为人知的约束，您可能已经意识到了这一点。它规定服务器不应该在调用之间保存客户端的任何上下文，并且从客户端到服务器的每个请求必须包含理解请求所必需的所有信息。</p><h1 id="01e7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">缓存</strong></h1><p id="43c4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">响应必须将自己定义为可缓存或不可缓存，以潜在地提高可伸缩性。这里的重点是HTTP缓存，而不是服务器端缓存。像<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" rel="noopener ugc nofollow" target="_blank"> ETag </a>这样不同的东西可以用于HTTP缓存。</p><h1 id="c191" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">分层系统</strong></h1><p id="fce9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在大型系统中，客户端不直接连接到终端应用服务器，可以有多个层，如负载平衡器、其他服务器等。介于两者之间。分层系统约束声明客户机不知道它是连接到终端服务器，还是连接到中间服务器。为了简化架构，这些层应该对客户端完全隐藏。</p><h1 id="d2c1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">按需编码(可选)</strong></h1><p id="6ccc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是一个可选约束，规定服务器可以可选地向客户端发送代码以在本地执行/下载(例如，服务器发送JavaScript代码)。</p><h1 id="49f9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">统一界面</strong></h1><p id="4217" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">REST的核心特性之一是强调统一接口。在REST风格中，任何信息交换都应该在资源方面进行。服务器提供的任何可以命名的信息都是潜在的资源，如文档、图像、用户、帖子等资源集合。每个资源都由一个唯一的URI表示，客户端可以使用它来与资源进行交互。客户端还需要有一个资源的表示，它可以将它发送到服务器进行更新。例如，假设一个<em class="kx">用户</em>资源具有客户端可用的以下信息:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="da0e" class="ld jv hi kz b fi le lf l lg lh">Representation: {<br/> “userId”: integer<br/> “userName”: string<br/> “email”: string<br/> “passwordHash”: string<br/>}</span></pre><p id="88aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk kz b">URI: <a class="ae jt" href="http://server.com/user/{userId" rel="noopener ugc nofollow" target="_blank">http://server.com/user/{userId</a>}</code>:这里userId应该是客户端发送的。<br/>有了这些信息，为了更新id为<em class="kx"> 1 </em>的用户的<em class="kx">用户名</em>，客户端可以首先使用GET调用获取该用户:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="bcb9" class="ld jv hi kz b fi le lf l lg lh">GET <a class="ae jt" href="http://server.com/user/1" rel="noopener ugc nofollow" target="_blank">http://server.com/user/1</a></span></pre><p id="83bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用PUT动词将接收到的具有新的<em class="kx">用户名</em>的表示发送到同一个端点:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="7d6b" class="ld jv hi kz b fi le lf l lg lh">PUT <a class="ae jt" href="http://server.com/user/1" rel="noopener ugc nofollow" target="_blank">http://server.com/user/1</a> (HTTP request body should have the updated representation of the user).</span></pre><p id="cc67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在REST中，请求和响应必须是自描述的，这意味着接收方接收所有必要的信息来理解消息，例如，不能等待另一条解释如何解释数据的消息。通过使用标准方法(例如，正确的HTTP动词)发送REST消息来操纵资源，消息的接收者(服务器或客户机)接收所有必要的信息来完成其任务。</p><p id="97e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">统一接口的另一个重要约束是<strong class="ih hj"> HATEOAS </strong>(作为应用程序状态引擎的超媒体)。该约束规定服务器响应消息必须提供相关资源的链接。这些资源链接根据客户端的当前状态为客户端提供其他当前可用的操作，这些操作在整个API中充当导航系统。例如，假设一个API端点用于通过ID获取帐户:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="f33a" class="ld jv hi kz b fi le lf l lg lh">Request: GET <a class="ae jt" href="http://www.server.com/account/12345" rel="noopener ugc nofollow" target="_blank">http://www.server.com/account/12345</a><br/>Response body: {<br/>  “account”: {<br/>    “account_number”: 12345,<br/>    “balance”: {<br/>      “currency”: “usd”,<br/>      “value”: 100.00<br/>    },<br/>    “links”: {<br/>      “deposit”: “/accounts/12345/deposit”,<br/>      “withdraw”: “/accounts/12345/withdraw”,<br/>      “transfer”: “/accounts/12345/transfer”,<br/>      “close”: “/accounts/12345/close”<br/>    }<br/>  }<br/>}</span></pre><p id="efa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的响应中，有一些链接(如存款、取款等。)可以被客户用来对账户执行不同的动作，而不需要预先知道这些链接的结构。这主要是HATEOAS的本质。以RPC风格设计的相同API将产生以下5种不同的API:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="1f84" class="ld jv hi kz b fi le lf l lg lh">getAccountById(…)<br/>depositToAccount(…)<br/>withdrawFromAccount(…)<br/>transferToAccount(…)<br/>closeAccount(…)</span></pre><p id="b0a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，客户端需要知道所有公开的端点，并在其代码中与它们紧密耦合。</p><p id="9de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我想讨论的REST风格的六个主要原则。我希望这篇文章能够提高您对RESTful APIs的理解。我很想在下面的评论中知道你对这些休息原则的看法。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="b787" class="ju jv hi bd jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr bi translated">一些有趣的阅读</h1><ul class=""><li id="3477" class="lx ly hi ih b ii ks im kt iq lz iu ma iy mb jc mc md me mf bi translated"><a class="ae jt" href="https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/" rel="noopener ugc nofollow" target="_blank">https://stack overflow . blog/2020/03/02/best-practices-for-rest-API-design/</a></li><li id="fcbf" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae jt" href="https://cloud.google.com/blog/products/application-development/rest-vs-rpc-what-problems-are-you-trying-to-solve-with-your-apis" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/products/application-development/rest-vs-RPC-你想用你的API解决什么问题</a></li><li id="148d" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae jt" href="https://www.researchgate.net/publication/325770704_An_Analysis_of_Public_REST_Web_Service_APIs" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/publication/325770704 _ An _ Analysis _ of _ Public _ REST _ Web _ Service _ APIs</a>—包含了一些对REST APIs的很好的分析，以及它们在多大程度上符合REST原则。</li></ul></div></div>    
</body>
</html>
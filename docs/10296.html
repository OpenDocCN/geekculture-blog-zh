<html>
<head>
<title>Taking advantage of Junit 5 extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Junit 5扩展</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/taking-advantage-of-junit-5-extensions-4a9622184125?source=collection_archive---------2-----------------------#2022-01-22">https://medium.com/geekculture/taking-advantage-of-junit-5-extensions-4a9622184125?source=collection_archive---------2-----------------------#2022-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b6a5522baad8a1eec16ad5dc09032b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJ0Bc_SY-it9ZrWY79Cmqw.jpeg"/></div></div></figure><h1 id="b6da" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="7ce3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">JUnit 5是JUnit的下一代。目标是为JVM上的开发人员端测试创建一个最新的基础。这包括关注Java 8和更高版本，以及支持许多不同风格的测试。</p><p id="6b64" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在本文中，我们将重点关注Junit 5的特性之一，即扩展，在整篇文章中，您将发现如何使用扩展来定制测试的行为。</p><blockquote class="kr ks kt"><p id="7129" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated"><strong class="jq hj">注:</strong>通过阅读这篇文章，假设你已经熟悉Junit 5，并想更进一步，如果你对Junit 5或Junit完全不熟悉，我建议你在深入文章之前先看一看。</p></blockquote><h1 id="90fc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是Junit 5扩展</h1><p id="5dfe" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在Junit 5之前，为了扩展测试的行为，有必要使用基于反射的<strong class="jq hj">运行器</strong>或<strong class="jq hj">规则</strong>，反射的问题是它破坏了封装，Junit 5通过引入扩展的概念来克服这个问题，你很快就会发现，这使得使用Junit 4的代码与使用反射的代码强耦合，使得代码难以发展。</p><h2 id="3535" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">Junit 5的扩展</h2><p id="f407" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">与JUnit 4中竞争的<strong class="jq hj"> Runner </strong>、<strong class="jq hj"> TestRule </strong>和<strong class="jq hj"> MethodRule </strong>扩展点相比，JUnit 5扩展模型由一个单一的、连贯的概念组成:扩展API。但是，请注意，扩展本身只是一个标记接口。</p><h2 id="723a" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">Junit 5模块化</h2><p id="e819" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Junit框架的发展需要一种模块化的方法，该架构必须允许Junit与使用不同工具和ide的不同编程客户机进行交互。需要对关注点进行逻辑分离</p><p id="c0a0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-编写测试的API，主要供开发人员使用<br/> -发现和运行测试的机制<br/> -允许与ide和工具轻松集成以运行测试的API。</p><p id="0ca2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Junit 5中的扩展是允许Junit框架具有这种模块化的元素之一</p><h2 id="4183" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">Junit 5扩展模型</h2><p id="e684" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Junit 4通过<strong class="jq hj"> Runners </strong>和<strong class="jq hj"> Rules </strong>提供了扩展，但是Junit 5只有一个概念:扩展API。</p><p id="5c6f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">扩展本身只是一个标记接口(或者标记或令牌接口)，一个内部没有字段或方法的接口。它用于标记这样一个事实，即实现此类接口的类有一些特殊的行为。最著名的Java标记接口有<strong class="jq hj">可串行化的</strong>和<strong class="jq hj">可克隆的</strong></p><p id="30a8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">JUnit 5可以扩展测试的类或方法的行为，并且这些扩展可以被许多测试重用。JUnit 5扩展与测试执行期间特定事件的发生相关联。这种事件称为扩展点。</p><p id="e59e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当测试的生命周期达到这样一个点时，JUnit <br/>引擎会自动调用注册的扩展。</p><p id="2dea" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">可用的扩展点如下:<br/> -条件测试执行——控制测试是否应该运行<br/> -生命周期回调——对测试生命周期中的事件做出反应<br/> -参数解析——在运行时，解析测试接收到的参数<br/> -异常处理——定义测试遇到特定类型的异常时的行为<br/> -测试实例后处理——在创建测试实例后执行</p><p id="a497" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，扩展主要用在框架和构建工具中。它们也可以用于应用程序编程，但程度不同。扩展的创建和使用遵循共同的原则；本章将展示适合常规应用程序开发的例子。</p><h2 id="385b" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">创建您的第一个Junit 5扩展</h2><p id="c84a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将通过一个小而简单的程序来说明Junit 5提供的所有扩展的可能性，该程序将元素保存在数据库(内存数据库)中</p><h2 id="f5bb" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">1.条件测试执行</h2><p id="1f34" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时，我们需要测试只在特定的条件或上下文中运行，为了说明这一点，我们将创建一个“context.properties”文件，在该文件中，我们将放入表示上下文的信息，并且根据该上下文，我们将设置一个扩展，该扩展将根据上下文禁用或启用测试的执行</p><p id="d020" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要创建条件执行扩展，我们只需创建一个实现<strong class="jq hj"> ExecutionCondition </strong>接口的类，然后实现<strong class="jq hj">evaluateExecutionCondition</strong>方法，如下面的代码片段所示。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="5c2b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如您所看到的，下面的代码读取了在<strong class="jq hj"> context.properties </strong>文件中定义的上下文属性，根据该属性的值，我们返回<strong class="jq hj">conditionevaluationresult . disabled(" Message ")</strong>来禁用测试的执行，或者返回<strong class="jq hj">conditionevaluationresult . enabled(" Message ")</strong>来启用测试的执行。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/c5f40d7e4848a69658ab80997bf739b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*_CuwXM_nvwEa2E9g61fihA.png"/></div></figure><p id="0552" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">做得好，您已经创建了您的第一个Junit 5扩展，现在要定义一个测试可以根据这个扩展定义的逻辑来执行，您只需使用<strong class="jq hj"> ExtendWith </strong>注释，通过将扩展传递给它，如下面的代码所示，当测试将被启动时，任何使用这个扩展的测试将根据在<strong class="jq hj"> context.properties </strong>文件中定义的上下文来执行或禁用</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="d437" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">2.生命周期回调</h2><p id="fb64" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设您想要测试您的数据库，正如您已经知道的，要运行对数据库的查询，您需要建立到数据库的连接，然后在运行测试后立即关闭到数据库的连接，</p><p id="15e3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用<strong class="jq hj"> BeforeAll </strong>或<strong class="jq hj"> AfterAll </strong>注释可以很容易地完成这个操作，但是如果要在几个测试上完成这个操作，它可能会变得非常快速地重复，为了解决这个问题，我们将创建一个扩展，它将根据测试生命周期为我们执行一些操作，但是这会在我们的数据库周围建立不同的</p><p id="1476" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了简单起见，我们将使用JDBC和H2作为我们的数据库系统，让我们定义允许我们管理数据库的组件。</p><p id="6570" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">连接管理器</strong></p><p id="cf92" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个类将允许我们管理数据库版本连接，即建立到数据库服务器的连接，并在没有更多请求时关闭连接。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="88b1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个类将允许我们管理数据库中唯一的表，它有一个方法创建不存在的表，另一个方法删除存在的表。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="298a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">数据访问对象</strong></p><p id="ddc8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要发出请求，UserDao类必须实现这个接口</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="5f22" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">用户数据访问对象</strong></p><p id="73ba" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个类实现了之前定义的DAO，这个类将被用来向我们的数据库发出请求，为了工作，这个类需要依赖于允许我们执行SQL请求的“连接”对象。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="5ed7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">生命周期扩展</strong> <br/>现在，所有允许与我们的数据库交互的元素都可用了，现在是时候创建一个能够根据我们测试的生命周期执行某些操作的扩展了。</p><p id="7abd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用这个扩展，我们不必在每次运行与数据库相关的测试时都配置数据库，我们所要做的就是将这个扩展应用到相应的测试中，它将为我们处理配置和清理工作。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d1fd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如你已经注意到的，这个类实现了4个接口<strong class="jq hj"> BeforeAllCallback </strong>，<strong class="jq hj"> AfterAllCallback </strong>，<strong class="jq hj"> BeforeEachCallback </strong>，<strong class="jq hj"> AfterEachCallback </strong>，并且它的每个接口都有一个根据其名称执行的方法。</p><p id="94ef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-在所有测试之前执行的<strong class="jq hj"> beforeAll </strong>方法中，我们建立到数据库的连接，并通过删除之前存在的表来创建表。</p><p id="d540" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-在所有测试后执行的<strong class="jq hj"> afterAll </strong>方法中，我们关闭了与数据库的连接。</p><p id="ba6b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-在每次测试前执行的<strong class="jq hj"> beforeEach </strong>方法中，我们执行自动提交，然后保存状态。</p><p id="3cc3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-在每次测试后执行的<strong class="jq hj"> afterEach </strong>方法中，我们执行回滚</p><p id="3962" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可能已经理解了，前面的方法对应于所有前的<strong class="jq hj">、所有</strong>后的<strong class="jq hj">、每个</strong>前的<strong class="jq hj">、每个</strong>后的<strong class="jq hj">注释。</strong></p><p id="6074" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">应用扩展</strong></p><p id="d4e8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们的扩展已经准备好了，我们只需要像以前一样使用它。</p><p id="2dd4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用这个扩展，我们不必在每次运行与数据库相关的测试时都配置数据库，我们所要做的就是将这个扩展应用到相应的测试中，它将为我们处理配置和清理工作(关闭数据库连接等)。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="be92" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您尝试运行测试，您会注意到您将得到一个错误，这是由于<strong class="jq hj"> DatabaseTest </strong>类将<strong class="jq hj"> UserDao </strong>作为参数，而Junit不知道在哪里寻找它。我们将在下一节中解决这个问题。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/b8653bf08e1a0bde0fffe261c003f79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuSFVu7ZswMKHBgzl6IW9A.png"/></div></div></figure><h2 id="5666" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated"><strong class="ak"> 3。参数解析</strong></h2><p id="235d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在前面的部分中，当我们试图运行测试时，我们得到了一个错误，这是由于测试类接受了一个参数，而Junit不知道如何创建它，这个错误将允许我们引入另一种可以用Junit 5创建的扩展</p><p id="78e4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将创建一个扩展，允许我们将依赖项注入到我们的测试类中，为此，让我们创建一个名为<strong class="jq hj">userdaoparameteresolverextension</strong>的扩展，它实现了Junit 5提供的<strong class="jq hj"> ParameterResolver </strong>接口。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d395" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如你所看到的，<strong class="jq hj">参数解析器</strong>有两个方法，第一个允许我们定义我们想要创建的依赖类型，第二个允许我们创建依赖，在我们的例子中它是一个类型为<strong class="jq hj"> UserDao </strong>的对象</p><p id="ff87" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们的扩展已经准备好使用了，我们只需要使用<strong class="jq hj"> ExtendWith </strong>注释来应用这个扩展，为了将几个扩展应用到同一个类，你可以使用多个<strong class="jq hj"> ExtendWith </strong> extensions，也可以使用一个单独的扩展和一个扩展数组</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="1c31" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，如果您再次执行测试，一切都按预期运行。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/7064eb169840662ba0df33a551fcdd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYMLbgtz3MktGiRPgZYrQg.png"/></div></div></figure><h2 id="e584" class="ky ir hi bd is kz la lb iw lc ld le ja jz lf lg je kd lh li ji kh lj lk jm ll bi translated">4.异常处理</h2><p id="4517" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时，当出现异常时，我们需要更明确的错误消息，在这一节中，我们将看到Junit 5如何允许捕捉异常。</p><p id="e67f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将创建一个异常，当我们试图添加一个id已经存在于数据库中的元素时，将引发该异常而不是SqlException。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="ab86" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于我们的异常已经准备好了，我们只需在<strong class="jq hj"> UserDAO </strong>的<strong class="jq hj"> save </strong>方法中使用它，如下面的清单所示。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="c143" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们所要做的就是创建一个能够捕捉这个异常的扩展，并执行适当的操作，在我们的例子中，我们将限制自己显示一个日志，如果这个异常不是我们定义的异常，我们只需重新抛出这个异常。</p><p id="61ee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为此，我们将创建一个<strong class="jq hj">exception handler extension</strong>类，该类实现Junit 5提供的<strong class="jq hj">TestExecutionExceptionHandler</strong>接口，该接口迫使我们实现<strong class="jq hj">handleTestExecutionException</strong>方法，该方法有两个参数，即上下文和刚刚触发的异常</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="b051" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要使用这个扩展，我们按照你之前已经学过的方法来做。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="58b7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，每次您尝试添加一个元素两次时，您都会看到一条消息，如下图所示。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/05094eb6e5c54cfd074b44dafd115f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuhQCKgiq1eWiYAhl0e6Ig.png"/></div></div></figure><h1 id="0274" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="fe45" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本文中，我们探索了Junit 5框架带给我们的一个非常强大的特性，正如您很快理解的那样，Junit 5允许我们以一种非常舒适的方式扩展我们的测试行为，同时带给我们一种在Junit 5之前没有的模块化，我希望本文会让您想了解更多关于Junit 5的知识，以便轻松地测试您的软件。</p><h1 id="21ef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考</h1><div class="lv lw ez fb lx ly"><a href="https://junit.org/junit5/docs/current/user-guide/#extensions" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">JUnit 5用户指南</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">用法:console launcher[-h][-disable-ansi-colors][-disable-banner][-fail-if-no-tests][-scan-modules]…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">junit.org</p></div></div></div></a></div></div></div>    
</body>
</html>
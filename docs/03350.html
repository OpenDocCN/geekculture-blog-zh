<html>
<head>
<title>Cron jobs in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的Cron作业</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cron-jobs-in-node-js-8df170445588?source=collection_archive---------2-----------------------#2021-06-07">https://medium.com/geekculture/cron-jobs-in-node-js-8df170445588?source=collection_archive---------2-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个开发人员迟早都会面临如何处理cron作业的问题。cron作业用例的列表非常庞大:缓存失效、报告生成、从外部源刷新数据、通知、备份等。当然，还有我最喜欢的一个:每天晚上在内存泄漏的情况下重启服务:)今天，我们将从开发和基础设施的角度来看几个预定任务的实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1442ecc24b5214f87f2244541137118f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfcvLyHSCu_9lG-OB0wB-w.jpeg"/></div></div></figure><p id="5eda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">历史上，Cron作业有一种特殊的调度定义格式<a class="ae jp" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cron</a>。我觉得有点可笑的是，我们仍然在使用70年代开发的格式，这一点也不直观。但是不要害怕，有很多在线工具可以将星号、斜线和数字转换成人类可读的格式。比如这个:<a class="ae jp" href="https://www.freeformatter.com/cron-expression-generator-quartz.html" rel="noopener ugc nofollow" target="_blank">https://www . free formatter . com/cron-expression-generator-quartz . html</a>。</p><p id="384b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，歌词够了，我们动起来练吧！</p><h1 id="11ed" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">老方法(Linux方法)</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/b3ef18d51babd8725ef105257b15aa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlLmvPTn0XsmcANuxWCIWw.jpeg"/></div></div></figure><p id="014e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每台Linux机器都安装并运行cron守护进程。所以你只需要为你的任务写一个脚本，执行所有需要的操作和退出，然后用Ansible或者Puppet添加到cron。这是一个经典的解决方案，但有几个缺点。</p><ul class=""><li id="0002" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">首先，它与服务器的操作系统紧密结合，开发者不应该担心服务器的环境。</li><li id="f9c8" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">负载平衡。对于每个新的cron任务，Linux管理员需要找到一个有足够空闲资源的服务器。这可能非常困难，因为cron作业按计划运行，并且Linux管理员必须在过去的计划时间检查有关服务器负载的历史监控数据。</li><li id="abd2" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">同时执行。如果你只有一台服务器，那根本不是问题。但是如果有多台服务器，就需要确保cron作业只部署在一台服务器上，否则就会同时执行。您的客户不会乐意收到两封相同的电子邮件，因为您的通知cron作业被部署了两次。</li></ul><p id="a806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前所说，这是一个经典的久经考验的解决方案。如果您在一台Linux服务器上部署了一个小项目，这是一个不错的选择。</p><h1 id="c158" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Node.js端的Cron</h1><p id="4efa" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">这种方法与前一种方法相反。我们可以用像https://www.npmjs.com/package/node-cron的<a class="ae jp" href="https://www.npmjs.com/package/node-cron" rel="noopener ugc nofollow" target="_blank">这样的库将cron调度放到Node.js中，而不是依赖于基础设施。这里有一个例子:</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="e730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个脚本永远不会结束，它就像一个守护进程。这个解决方案不依赖于基础设施，它可以在任何地方运行，包括Docker。您还可以在一个脚本中组合几个cron作业，此外，您还可以在运行时动态创建新的cron作业。这非常方便和灵活，但就像前面的解决方案一样，您需要确保您的应用程序只在一个实例中执行。</p><h1 id="9fe8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">公牛模块</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/8b689f3674857d79c0f2a2da55c345cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wW8lIQubvWHnPtDEhCmBSQ.jpeg"/></div></div></figure><p id="3b32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Bull是一个Node.js库，用于任务队列<a class="ae jp" href="https://www.npmjs.com/package/bull" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/bull</a>，支持cron作业。与前两种解决方案不同，它不保证同时执行作业。它非常容易使用:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="d6cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到，Bull使用Redis作为任务存储。但是如果我们重启这个脚本会发生什么呢？会不会再次调度<code class="du ll lm ln lo b">testQueue</code>每分钟执行两个任务？不，布尔会处理的。让我们安排相同的任务许多任务:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="efa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它仍然每分钟打印一条消息。如果已经存储在Redis中，Bull不会创建新作业。如果我们同时运行这个脚本两次或更多次会怎么样？你猜怎么着？Bull将在脚本之间分割任务，这对于繁重的cron任务非常有用。此外，Bull支持延迟作业，就像它们被调度的cron作业一样，但是它只会被执行一次。</p><p id="eab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于公牛的最后一个想法:</p><ul class=""><li id="7a1b" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">不依赖于基础架构，除非它需要Redis</li><li id="71b1" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">防止同时执行作业</li><li id="20cc" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">完全动态</li><li id="7efe" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">可攀登的</li></ul><p id="0fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依我拙见，公牛是对付克隆乔布斯的最佳选择。</p><h1 id="02c5" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">库伯内特·克朗乔布</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/9f7d8964b1dfc711e8f6c7beee81a00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtpXuvBAQz_eIcMRbiBKTA.jpeg"/></div></div></figure><p id="246e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是Kubernetes的一个新功能，你可以在这里阅读文档<a class="ae jp" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/concepts/workloads/controllers/cron-jobs/</a>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="c89c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes CronJob做了一件非常简单的事情，它按计划运行您的docker映像。这意味着您应该首先用它建立一个docker映像。Kubernetes CronJob是Bull的一个很好的替代品，因为它节省了您的Kubernetes资源。Bull应该像守护进程一样运行，它会永久消耗服务器资源。Kubernetes CronJob启动一个pod，等待它退出，然后移除该pod。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="931f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不想写结论，你已经阅读了4种不同的方法及其利弊，你可以自己决定哪种更适合你:)</p><p id="a6e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">下次见！Servus！</em></p></div></div>    
</body>
</html>
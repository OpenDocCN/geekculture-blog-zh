<html>
<head>
<title>Robot Operating System: Controlling a Robot with the ROS Gazebo Plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器人操作系统:用ROS Gazebo插件控制机器人</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/robot-operating-system-controlling-a-robot-with-the-ros-gazebo-plugins-e8055cf28f44?source=collection_archive---------6-----------------------#2022-01-10">https://medium.com/geekculture/robot-operating-system-controlling-a-robot-with-the-ros-gazebo-plugins-e8055cf28f44?source=collection_archive---------6-----------------------#2022-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/24b728d23d2aae4681166b5e0530dc1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq3YmCPH96DZ5VMC9aZEiA.png"/></div></div></figure><p id="bdb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我最近关于ROS和我的项目RADU的文章中，我展示了如何在Gazebo中启动一个定制的机器人模型，并通过特殊的控制节点暴露其关节。这些节点接受命令来改变它们的努力、速度或位置。然而，节点本身并不翻译命令和移动你的机器人，你仍然需要编写与Gazebo接口的代码。</p><p id="4c79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gazebo插件与典型的ROS安装捆绑在一起。插件支持几种致动器，如差动驱动或滑动驱动，以及传感器，如相机、深度相机和IMU。插件通过内部的控制器节点进行通信，您不需要公开它们。相反，他们会发布相关的主题，如向机器人发送线性和角运动命令的<code class="du jo jp jq jr b">/cmd_vel</code>，或表示自模拟开始以来机器人位置的<code class="du jo jp jq jr b">/odom</code>。</p><p id="3044" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是关于Gazebo插件的实践研讨会。你将学习插件是如何工作的，我们将看到如何使用ROS2中的diff-drive插件来控制一个四轮机器人。</p><p id="01b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">本文原载于我的博客</em><a class="ae jt" href="https://admantium.com/blog/ros09_controlling_a_robot_in_gazebo/" rel="noopener ugc nofollow" target="_blank"><em class="js">admantium.com</em></a>。</p><h1 id="3b1e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Gazebo插件</h1><p id="0bf9" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在我的机器人项目期间，我查看了社区的其他几个机器人项目。我很疑惑为什么有些项目没有衍生出任何控制器节点，但上面提到的话题<code class="du jo jp jq jr b">/cmd_vel</code>和<code class="du jo jp jq jr b">/odom</code>还是被发表了。我的假设是这些机器人的插件会自动启动控制器。查看官方的Gazebo文档，我们可以找到这样一段话:</p><blockquote class="kx ky kz"><p id="a267" class="iq ir js is b it iu iv iw ix iy iz ja la jc jd je lb jg jh ji lc jk jl jm jn hb bi translated"><em class="hi">Gazebo以前的版本使用控制器。这些插件的行为与插件非常相似，但是被静态编译到Gazebo中。插件更加灵活，允许用户挑选在他们的模拟中包含什么功能。</em></p></blockquote><p id="033e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">来源:</em> <a class="ae jt" href="http://gazebosim.org/tutorials?tut=plugins_hello_world&amp;cat=write_plugin" rel="noopener ugc nofollow" target="_blank"> <em class="js">官方凉亭文档</em> </a>。</p><p id="1a88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插件是遵循<a class="ae jt" href="http://gazebosim.org/tutorials?tut=plugins_hello_world&amp;cat=write_plugin" rel="noopener ugc nofollow" target="_blank">插件开发指南</a>中概述的约定的C++库。这些插件继承了一个基类——比如传感器、系统、视觉或世界——并公开了<code class="du jo jp jq jr b">Load</code>功能。这是插件开发指南中的一个例子。</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="2873" class="ll jv hi jr b fi lm ln l lo lp">#include &lt;gazebo/gazebo.hh&gt;</span><span id="ec7e" class="ll jv hi jr b fi lq ln l lo lp">namespace gazebo<br/>{<br/>  class WorldPluginTutorial : public WorldPlugin {<br/>    public: WorldPluginTutorial() : WorldPlugin() {<br/>      printf("Hello World!\n");<br/>    }</span><span id="4aa7" class="ll jv hi jr b fi lq ln l lo lp">    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf) { }<br/>  };</span><span id="8f59" class="ll jv hi jr b fi lq ln l lo lp">  GZ_REGISTER_WORLD_PLUGIN(WorldPluginTutorial)<br/>}</span></pre><p id="c06c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译完成后，插件需要通过机器人的URDF模型加载。</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="e119" class="ll jv hi jr b fi lm ln l lo lp">&lt;?xml version="1.0"?&gt;<br/>&lt;sdf version="1.4"&gt;<br/>  &lt;world name="default"&gt;<br/>    &lt;plugin name="hello_world" filename="libhello_world.so"/&gt;<br/>  &lt;/world&gt;<br/>&lt;/sdf&gt;</span></pre><p id="521a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用一个预制的插件时，我们只需要将它添加到URDF模型中。</p><h1 id="fbe1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">ROS2插件</h1><p id="4c0b" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">自ROS2问世以来，插件一直在稳步转换。<a class="ae jt" href="https://github.com/ros-simulation/gazebo_ros_pkgs/wiki" rel="noopener ugc nofollow" target="_blank">状态页面</a>显示摄像机等独立插件被合并到一个包中。以此为参考，我们可以选择和合并我们选择的插件，使它们与我们的原型一起工作。</p><p id="c2d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想控制机器人如何移动。插件支持四种不同的转向原理:差速驱动、滑移驱动、阿克曼驱动和三轮驱动。我的RADU机器人是一辆四轮车，可以作为滑行驱动来控制。因此，我们将使用<code class="du jo jp jq jr b">ros_diff_drive</code>插件。</p><h1 id="e53c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">使用差异驱动插件</h1><p id="d7ce" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">除了机器人的物理模型之外，使用插件比手动添加控制器节点要简单得多。事实上，您只需要添加一个<code class="du jo jp jq jr b">&lt;plugin&gt;</code>标签！</p><p id="eb10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是完整的示例:</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="afa2" class="ll jv hi jr b fi lm ln l lo lp">&lt;plugin name="wheel_drive_controller" filename="libgazebo_ros_diff_drive.so"&gt;</span><span id="816f" class="ll jv hi jr b fi lq ln l lo lp">  &lt;!-- wheels --&gt;<br/>  &lt;num_wheel_pairs&gt;2&lt;/num_wheel_pairs&gt;<br/>  &lt;left_joint&gt;base_link_left_wheel_frontside&lt;/left_joint&gt;<br/>  &lt;left_joint&gt;base_link_left_wheel_backside&lt;/left_joint&gt;<br/>  &lt;right_joint&gt;base_link_right_wheel_frontside&lt;/right_joint&gt;<br/>  &lt;right_joint&gt;base_link_right_wheel_backside&lt;/right_joint&gt;</span><span id="baae" class="ll jv hi jr b fi lq ln l lo lp">  &lt;!-- kinematics --&gt;<br/>  &lt;wheel_separation&gt;0.4&lt;/wheel_separation&gt;<br/>  &lt;wheel_diameter&gt;0.1&lt;/wheel_diameter&gt;<br/>  &lt;max_wheel_torque&gt;20.0&lt;/max_wheel_torque&gt;<br/>  &lt;max_wheel_acceleration&gt;10.0&lt;/max_wheel_acceleration&gt;</span><span id="a584" class="ll jv hi jr b fi lq ln l lo lp">  &lt;!-- odometry  --&gt; <br/>  &lt;odometry_source&gt;world&lt;/odometry_source&gt;<br/>  &lt;odometry_frame&gt;odom&lt;/odometry_frame&gt;<br/>  &lt;robot_base_frame&gt;base_link&lt;/robot_base_frame&gt;</span><span id="2551" class="ll jv hi jr b fi lq ln l lo lp">  &lt;!-- topic &amp; re remappings --&gt;<br/>  &lt;ros&gt;<br/>    &lt;namespace&gt;/&lt;/namespace&gt;<br/>    &lt;argument&gt;/cmd_vel:=cmd_vel&lt;/argument&gt;<br/>    &lt;argument&gt;/odom:=odom&lt;/argument&gt;<br/>  &lt;/ros&gt;</span><span id="b5cb" class="ll jv hi jr b fi lq ln l lo lp">  &lt;publish_odom&gt;true&lt;/publish_odom&gt;<br/>  &lt;publish_odom_tf&gt;true&lt;/publish_odom_tf&gt;<br/>  &lt;update_rate&gt;100.0&lt;/update_rate&gt;<br/>&lt;/plugin&gt;</span></pre><p id="089f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该声明由4个配置块组成。每个块中的标签应该是不言自明的，所以我只简单解释一下。</p><ul class=""><li id="7665" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">车轮:指定车轮的数量，然后参考哪些关节考虑用于右侧，哪些关节参考用于左侧转向</li><li id="0939" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">运动学:车轮的附加物理配置:沿y轴的分离、直径、扭矩和加速度</li><li id="89c2" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">里程计:如果您发布里程计信息，您需要指定其来源和框架以及基础框架</li><li id="8921" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">主题:这个块配置您想要发布的主题、发布的名称空间/名称以及更新的速度。</li></ul><h1 id="7ac6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">启动凉亭并控制机器人</h1><p id="22a8" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">一旦插件在你的机器人描述中可用，我们可以开始Gazebo和所需的节点。我们需要显式启动三个节点——Gazebo、关节状态控制器和机器人状态发布器——然后生成机器人。最后一步为插件创建一个额外的控制器节点。</p><p id="2f41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是启动文件:</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="a4ab" class="ll jv hi jr b fi lm ln l lo lp">#!/usr/bin/python3<br/># -*- coding: utf-8 -*-<br/>import os</span><span id="3658" class="ll jv hi jr b fi lq ln l lo lp">from ament_index_python.packages import get_package_share_directory<br/>from launch import LaunchDescription<br/>from launch.actions import DeclareLaunchArgument<br/>from launch.actions import IncludeLaunchDescription<br/>from launch.launch_description_sources import PythonLaunchDescriptionSource<br/>from launch_ros.actions import Node</span><span id="5f0f" class="ll jv hi jr b fi lq ln l lo lp">from time import sleep<br/>import xacro</span><span id="585d" class="ll jv hi jr b fi lq ln l lo lp">package_name = 'radu_bot'<br/>world_file = 'living_room3.sdf'</span><span id="0998" class="ll jv hi jr b fi lq ln l lo lp">def generate_launch_description():</span><span id="61f9" class="ll jv hi jr b fi lq ln l lo lp">    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')<br/>    pkg_radu_simulation = get_package_share_directory(package_name)<br/>    rviz_config_path = os.path.join(pkg_radu_simulation, 'config/urdf_config.rviz')</span><span id="2066" class="ll jv hi jr b fi lq ln l lo lp">    robot_description_path =  os.path.join(<br/>        pkg_radu_simulation,<br/>        "urdf",<br/>        "gazebo.xacro",<br/>    )</span><span id="04b3" class="ll jv hi jr b fi lq ln l lo lp">    robot_description = {"robot_description": xacro.process_file(robot_description_path).toxml()}</span><span id="21e6" class="ll jv hi jr b fi lq ln l lo lp">    print("MODEL %s" % robot_description['robot_description'])</span><span id="0035" class="ll jv hi jr b fi lq ln l lo lp">    sleep(3)</span><span id="e3ef" class="ll jv hi jr b fi lq ln l lo lp">    joint_state_publisher_node = Node(<br/>        package='joint_state_publisher',<br/>        executable='joint_state_publisher',<br/>        name='joint_state_publisher'<br/>    )</span><span id="e7fa" class="ll jv hi jr b fi lq ln l lo lp">    robot_state_publisher_node = Node(<br/>        package="robot_state_publisher",<br/>        executable="robot_state_publisher",<br/>        output="both",<br/>        parameters=[robot_description],<br/>    )</span><span id="1d45" class="ll jv hi jr b fi lq ln l lo lp">    gazebo_node = IncludeLaunchDescription(<br/>        PythonLaunchDescriptionSource(<br/>            os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py'),<br/>        )<br/>    )</span><span id="22ee" class="ll jv hi jr b fi lq ln l lo lp">    robot_spawner = Node(<br/>            package='gazebo_ros',<br/>            executable='spawn_entity.py',<br/>            name='urdf_spawner',<br/>            output='screen',<br/>            arguments=["-topic", "/robot_description", "-entity", "radu_bot", "-x", "-3.0", "-y", "-1.5"])</span><span id="f3ed" class="ll jv hi jr b fi lq ln l lo lp">    print("STARTING ALL NODES")</span><span id="69e8" class="ll jv hi jr b fi lq ln l lo lp">    sleep(3)</span><span id="fe37" class="ll jv hi jr b fi lq ln l lo lp">    world_arg = DeclareLaunchArgument(<br/>          'world',<br/>          default_value=[os.path.join(pkg_radu_simulation, 'worlds', world_file), ''],<br/>          description='SDF world file')    </span><span id="7e96" class="ll jv hi jr b fi lq ln l lo lp">    no_sim_time = DeclareLaunchArgument(<br/>            'use_sim_time',<br/>            default_value='false',<br/>            description='Use simulation (Gazebo) clock if true')</span><span id="c2a2" class="ll jv hi jr b fi lq ln l lo lp">    return LaunchDescription([<br/>        world_arg,<br/>        no_sim_time,<br/>        joint_state_publisher_node,<br/>        robot_state_publisher_node,<br/>        gazebo_node,<br/>        robot_spawner<br/>    ])</span></pre><p id="dbab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用<code class="du jo jp jq jr b">ros2 launch radu_bot control.launch.py</code>启动它，然后我们可以看到可用的节点:</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="66fd" class="ll jv hi jr b fi lm ln l lo lp">$&gt; ros2 node list<br/>/gazebo<br/>/joint_state_publisher<br/>/robot_state_publisher<br/>/wheel_drive_controller</span></pre><p id="2e63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个节点<code class="du jo jp jq jr b">wheel_drive_controller</code>，订阅了主题<code class="du jo jp jq jr b">cmd_vel</code>，通过它我们可以控制机器人。</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="24b1" class="ll jv hi jr b fi lm ln l lo lp">$&gt; ros2 node info /wheel_drive_controller<br/>/wheel_drive_controller<br/>  Subscribers:<br/>    /clock: rosgraph_msgs/msg/Clock<br/>    /cmd_vel: geometry_msgs/msg/Twist<br/>    /parameter_events: rcl_interfaces/msg/ParameterEvent<br/>  Publishers:<br/>    /odom: nav_msgs/msg/Odometry<br/>    /parameter_events: rcl_interfaces/msg/ParameterEvent<br/>    /rosout: rcl_interfaces/msg/Log<br/>    /tf: tf2_msgs/msg/TFMessage<br/>  Service Servers:<br/>    /wheel_drive_controller/describe_parameters: rcl_interfaces/srv/DescribeParameters<br/>    /wheel_drive_controller/get_parameter_types: rcl_interfaces/srv/GetParameterTypes<br/>    /wheel_drive_controller/get_parameters: rcl_interfaces/srv/GetParameters<br/>    /wheel_drive_controller/list_parameters: rcl_interfaces/srv/ListParameters<br/>    /wheel_drive_controller/set_parameters: rcl_interfaces/srv/SetParameters<br/>    /wheel_drive_controller/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically<br/>  Service Clients:</span><span id="5b5f" class="ll jv hi jr b fi lq ln l lo lp">  Action Servers:</span><span id="c747" class="ll jv hi jr b fi lq ln l lo lp">  Action Clients:</span></pre><p id="cc78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了控制机器人，我们运行<code class="du jo jp jq jr b">teleop_twist_keyboard</code>命令，该命令将方向键盘按键转换成<code class="du jo jp jq jr b">/cmd_vel</code>消息。</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="1298" class="ll jv hi jr b fi lm ln l lo lp">$&gt; ros2 run teleop_twist_keyboard teleop_twist_keyboard --ros-args --remap cmd_vel:=/cmd_vel</span><span id="3866" class="ll jv hi jr b fi lq ln l lo lp">This node takes keypresses from the keyboard and publishes them<br/>as Twist messages. It works best with a US keyboard layout.<br/>---------------------------<br/>Moving around:<br/>   u    i    o<br/>   j    k    l<br/>   m    ,    .</span></pre><p id="e175" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是当移动机器人时，它表现得很奇怪:轮子是沿着y轴旋转的！</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/08a2530077047a9c2f8e0fe7d4727c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r97ChMFnGWA4mEYM.png"/></div></div></figure><p id="ee83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个问题，我们需要向关节添加显式的<code class="du jo jp jq jr b">&lt;axis&gt;</code>和<code class="du jo jp jq jr b">&lt;limit&gt;</code>标签。</p><pre class="ld le lf lg fd lh jr li lj aw lk bi"><span id="3452" class="ll jv hi jr b fi lm ln l lo lp">&lt;xacro:macro name="wheel_joint" params="name parent child xyz "&gt;<br/>  &lt;joint name="${name}" type="continuous"&gt;<br/>    &lt;parent link="${parent}" /&gt;<br/>    &lt;child link="${child}" /&gt;<br/>    &lt;origin xyz="${xyz}" rpy="1.570796 0 0"/&gt;<br/>    &lt;axis rpy="0 0 0" xyz="0 0 1"/&gt;<br/>    &lt;limit effort="1" velocity="1"/&gt;<br/>    &lt;joint_properties damping="1.0" friction="1.0"/&gt;<br/>  &lt;/joint&gt;<br/>&lt;/xacro:macro&gt;</span></pre><p id="2ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后机器人顺利移动。</p><h1 id="a2e4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="e7ac" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">漫长的开发之旅告一段落:终于，Gazebo中的RADU机器人仿真建模正确，可以在模拟世界中移动。为了实现这个目标，我们需要了解三个不同的主题。首先，兼容露台的URDF模型需要哪些额外的物理属性。第二，我们需要在我们的ROS系统中增加控制节点，以暴露机器人的关节来进行力度、速度或位置操作，并让这些节点翻译<code class="du jo jp jq jr b">cmd_vel</code>命令来改变模拟。第三，插件承担了第二部分的重任，只需要一个正确配置的规范和附加连接状态/机器人状态连接的开始。在此基础上，机器人现在可以配备图像相机和深度相机，用于在凉亭中进行模拟。</p></div></div>    
</body>
</html>
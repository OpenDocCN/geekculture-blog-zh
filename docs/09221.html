<html>
<head>
<title>Next.JS —Application Setup and File Based Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一个。JS—应用程序设置和基于文件的路由</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/next-js-application-setup-and-file-based-routing-cbb0b70d514c?source=collection_archive---------11-----------------------#2021-12-01">https://medium.com/geekculture/next-js-application-setup-and-file-based-routing-cbb0b70d514c?source=collection_archive---------11-----------------------#2021-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cdaf7fa34ab8d395f301c6450e74a750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VZC0VCjG0uvqJxhG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danist Soh</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="46f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">当涉及到前端应用程序开发时，我们通常会更多地通过优化来提高应用程序的性能。作为一名React开发人员，我沉迷于无数的节点包和配置来提高性能。从react-router到webpack，从图像的延迟加载到服务器端渲染，都需要多次手动微调。然后是一个基于React.js库构建的框架，它有多个内置特性，可以减少生产就绪应用程序的手动干预— <strong class="ix hj"> Next.js </strong></p><h1 id="9528" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">功能齐全的Next.js</h1><p id="dc6b" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">Next.js是一个基于Node.js的开源开发框架，支持基于React的web应用程序功能。<a class="ae iu" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel(原名ZEIT) </a>，维护并领导<a class="ae iu" href="https://github.com/vercel/next.js" rel="noopener ugc nofollow" target="_blank"> Next.js </a>开源开发。</p><p id="6a96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Next.js是一个React框架，能够创建在客户机和服务器上运行的应用程序，也称为通用JavaScript应用程序。该框架通过简化客户端路由和页面布局等基本功能，同时简化服务器端渲染和代码拆分等高级功能，帮助您更快地构建通用应用。</p><blockquote class="lf lg lh"><p id="c78d" class="iv iw li ix b iy iz ja jb jc jd je jf lj jh ji jj lk jl jm jn ll jp jq jr js hb bi translated">React文档在“推荐的工具链”中提到了Next.js，建议开发人员在“使用Node.js构建服务器呈现的网站”时将其作为一个解决方案</p></blockquote><h2 id="6c08" class="lm kd hi bd ke ln lo lp ki lq lr ls km jg lt lu kq jk lv lw ku jo lx ly ky lz bi translated">Next.js提供的内置特性</h2><ol class=""><li id="0791" class="ma mb hi ix b iy la jc lb jg mc jk md jo me js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/basic-features/fast-refresh" rel="noopener ugc nofollow" target="_blank">快速刷新(热重装)</a></li><li id="89c2" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/routing/introduction" rel="noopener ugc nofollow" target="_blank">基于文件的路由(静态和动态路由)</a></li><li id="eb99" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/advanced-features/dynamic-import" rel="noopener ugc nofollow" target="_blank">自动代码分割</a></li><li id="cb69" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/basic-features/image-optimization" rel="noopener ugc nofollow" target="_blank">图像组件和优化</a>(延迟加载)</li><li id="6a31" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" rel="noopener ugc nofollow" target="_blank">预渲染&amp;服务器端渲染</a></li><li id="6cde" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/basic-features/eslint" rel="noopener ugc nofollow" target="_blank"> ESLint集成</a></li><li id="c9d3" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><a class="ae iu" href="https://nextjs.org/docs/basic-features/typescript" rel="noopener ugc nofollow" target="_blank">打字稿支持</a></li><li id="c06b" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">内置组件—图像、标题、脚本等等。</li></ol><h1 id="65ee" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Next.js应用程序设置</h1><p id="7733" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">通过在您的终端上运行<code class="du mo mp mq mr b">npm create-next-app</code>，一个基本的样板代码将在您的系统中建立起来。文件夹结构将如下所示</p><figure class="mt mu mv mw fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/36fe18523818886cd5548751d55bca6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*dbAPuv7BZd44Bn9pwQAY2Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Next.js Folder structure</figcaption></figure><p id="4c8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到像<code class="du mo mp mq mr b">pages</code>、<code class="du mo mp mq mr b">public</code>、<code class="du mo mp mq mr b">node_modules</code>、<code class="du mo mp mq mr b">styles</code>这样的文件夹。<code class="du mo mp mq mr b">pages</code>文件夹有助于Next.js应用程序中基于文件的路由，它应该包含所有的主页面。<code class="du mo mp mq mr b">public</code>文件夹是为所有静态资产准备的，比如图像、图标等。<code class="du mo mp mq mr b">styles</code>文件夹包含您的应用程序CSS文件。</p><p id="066a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mo mp mq mr b">next.config.js</code>是您的Next.js应用程序配置文件，它有助于配置环境变量、图像/文件扩展名配置等。<br/>这个配置文件是一个常规的Node.js模块，不是一个JSON文件。它由Next.js服务器和构建阶段使用，不包含在浏览器构建中。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><h1 id="6c65" class="kc kd hi bd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz bi translated">基于文件的路由</h1><p id="c54a" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在单页面应用程序中，路由是从一个页面导航到另一个页面需要实现的关键元素之一。Next.js通过其名为<em class="li">基于文件的路由</em>的内置路由技术为您解决了这个问题。</p><p id="3257" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mo mp mq mr b">pages</code>文件夹帮助完成Next.js中基于文件的路由，该文件夹包含<code class="du mo mp mq mr b">_app.js</code>和<code class="du mo mp mq mr b">index.js</code>，分别是应用根文件和主页或主起始页。</p><figure class="mt mu mv mw fd ij er es paragraph-image"><div class="er es nj"><img src="../Images/5acc47eba92180d0e790f101d88ba9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*J6xglyGlCxNY4_TD8RfGOw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">file-based routing folder structure</figcaption></figure><p id="21cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，您可以看到<code class="du mo mp mq mr b">pages</code>文件夹包含静态、动态和嵌套路线的文件和文件夹。<code class="du mo mp mq mr b">pages</code>文件夹应该只包含组件和所有其他文件，如常量、实用程序必须从<code class="du mo mp mq mr b">pages</code>文件夹中移出。</p><p id="3fe4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将研究如何实现<strong class="ix hj"> <em class="li">静态、动态和嵌套路由</em> </strong>。</p><figure class="mt mu mv mw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/00a6506e96fb64cbbaf6bc7e8bf60e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8H1M5NFaYAMVjznPEj7SQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Files-based routing technique</figcaption></figure><h2 id="5d7f" class="lm kd hi bd ke ln lo lp ki lq lr ls km jg lt lu kq jk lv lw ku jo lx ly ky lz bi translated">静态路由</h2><p id="878c" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在上图中，你可以看到<code class="du mo mp mq mr b">pages</code>文件夹包含一个名为<code class="du mo mp mq mr b">about.js</code>的文件。JS文件的名称本身将成为一个路由，在这种情况下，是一个静态路由。现在，当您导航到<code class="du mo mp mq mr b">my-domain.com/about</code>时，浏览器将呈现<code class="du mo mp mq mr b">about.js</code>组件。</p><p id="59c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，对于嵌套路由，您可以在<code class="du mo mp mq mr b">pages</code>文件夹中创建一个文件夹，比如说<code class="du mo mp mq mr b">company</code>，在其中，您可以包含一个<code class="du mo mp mq mr b">index.js</code>来拥有<code class="du mo mp mq mr b">my-domain.com/company</code>。现在，如果我们需要一条类似于<code class="du mo mp mq mr b">my-domain.com/company/contactus</code>的路线，我们需要在<code class="du mo mp mq mr b">company</code>文件夹中添加一个名为<code class="du mo mp mq mr b">contact.js</code>的文件。就是这样！您现在已经实现了静态路由！</p><h2 id="c29d" class="lm kd hi bd ke ln lo lp ki lq lr ls km jg lt lu kq jk lv lw ku jo lx ly ky lz bi translated">动态路线</h2><p id="dc58" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">假设我们需要一条类似于<code class="du mo mp mq mr b">my-domain.com/products/1</code>的路线。当产品ID发生变化(动态)时，我们需要使用相同的组件获取特定产品的数据。</p><p id="f890" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，你可以看到<code class="du mo mp mq mr b">products</code>文件夹驻留在<code class="du mo mp mq mr b">pages</code>文件夹中，因此我们有了<code class="du mo mp mq mr b">my-domain.com/products</code>。为了处理路由的动态部分，也就是<code class="du mo mp mq mr b">my-domain.com/products/1</code>，我们需要在<code class="du mo mp mq mr b">products</code>文件夹中添加一个JS文件，但是因为我们需要一个动态路由，我们需要用方括号<code class="du mo mp mq mr b">[]</code>来命名这个文件。这里，我们将<code class="du mo mp mq mr b">[id].js</code>文件添加到<code class="du mo mp mq mr b">products</code>文件夹中。在这个文件中，我们可以有一个组件来使用Id获取产品数据并呈现视图。</p><p id="ba8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用名为<code class="du mo mp mq mr b">useRouter</code>的内置钩子来访问路由参数和查询。在下面的示例中，您可以看到如何读取<strong class="ix hj"> <em class="li">路径名</em> </strong>和<strong class="ix hj"> <em class="li">动态Id </em> </strong> <em class="li">。</em></p><figure class="mt mu mv mw fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="69b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们需要一个类似于<br/> <code class="du mo mp mq mr b">my-domain.com/blog/2021/my-only-blog</code>的URL，在我们的路由中需要多个动态参数，该怎么办？这可以通过使用以下格式实现— <code class="du mo mp mq mr b">[...blogid].js</code>。将此文件添加到您的<code class="du mo mp mq mr b">blog</code>文件夹中——查看本文的第二张图片。现在，<code class="du mo mp mq mr b">[...blogid].js</code>组件可以在URL中有多个动态参数。</p><p id="449c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要读取动态查询参数，使用— <code class="du mo mp mq mr b">router.query</code>,它返回一个数组中的所有动态参数。</p><figure class="mt mu mv mw fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/c36a41ae5dc32a5c2719ef63f6569d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*AqQRtha-kpQrCJNU1gZZtg.png"/></div></figure><h2 id="57bb" class="lm kd hi bd ke ln lo lp ki lq lr ls km jg lt lu kq jk lv lw ku jo lx ly ky lz bi translated">404找不到页面</h2><p id="7e1e" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">当输入错误的路由/URL时，Next.js默认提供一个干净的404错误页面。不需要任何配置或代码。</p><p id="559b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认的404页面看起来像…</p><figure class="mt mu mv mw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/73f888c3dafecb224bbd20e37b9c96b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnxGCr3NbpXG8gzN7csKpw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Default 404 error page provided by Next.js</figcaption></figure><p id="caac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，Next.js允许开发人员添加自定义的404页面。添加一个404组件，并在<code class="du mo mp mq mr b">pages</code>文件夹内将该文件命名为<code class="du mo mp mq mr b">404.js</code>(查看文件夹结构图)。就是这样。现在你有了自己的自定义404页面。当找不到路由时，Next.js检查应用程序中的<code class="du mo mp mq mr b">404.js</code>页面并呈现它，否则它将呈现默认的404错误页面。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="d580" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是Next.js应用程序设置和基于文件的路由实现的全部内容。</p><p id="8c2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看本文的第二部分，我在这里解释了Next.js中的<strong class="ix hj">预渲染</strong>，如何在Next.js中实现<strong class="ix hj">静态站点生成(SSG)和服务器端渲染(SSR)</strong></p><div class="np nq ez fb nr ns"><a rel="noopener follow" target="_blank" href="/@dsVinay/next-js-static-site-generation-and-server-side-rendering-explained-bc9cae0885c6"><div class="nt ab dw"><div class="nu ab nv cl cj nw"><h2 class="bd hj fi z dy nx ea eb ny ed ef hh bi translated">下一个。JS——静态站点生成和服务器端渲染解释</h2><div class="nz l"><h3 class="bd b fi z dy nx ea eb ny ed ef dx translated">Next.JS简单而强大的内置渲染特性。</h3></div><div class="oa l"><p class="bd b fp z dy nx ea eb ny ed ef dx translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og io ns"/></div></div></a></div><p id="7586" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="li">查看示例Next.js应用代码</em> <a class="ae iu" href="https://github.com/vinayds21/NextJS-Application" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="li">此处</em> </strong> </a> <em class="li">。我在这里实现了Next.js提供的所有路由技术，同样，在这里</em>   <strong class="ix hj"> <em class="li">查看生产URL。</em> </strong></p></div></div>    
</body>
</html>
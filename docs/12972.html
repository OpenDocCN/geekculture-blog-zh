<html>
<head>
<title>Technologies Behind No-code &amp; Low-code Solutions and How to Build Your Own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无代码和低代码解决方案背后的技术以及如何构建自己的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/technologies-behind-no-code-low-code-solutions-and-how-to-build-your-own-1709d051904f?source=collection_archive---------6-----------------------#2022-06-11">https://medium.com/geekculture/technologies-behind-no-code-low-code-solutions-and-how-to-build-your-own-1709d051904f?source=collection_archive---------6-----------------------#2022-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/37d3a84c22641ce4ec08a1ac4adbc3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8Ppm42w7p8VkVQ3pw5sEQ@2x.jpeg"/></div></div></figure><p id="0f35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无/低代码平台最近成为一个时髦的话题。但是几乎没有关于如何创建自己的这种解决方案的信息。因此，我们将关注开发方法、低代码和无代码平台的架构以及分解。让我们来看看无代码平台是如何构建的。</p><p id="682c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将定义低代码/无代码开发。这个术语指的是一个平台，用户可以在这个平台上通过UI界面生成任何供外部使用的IT产品。它可以是单独的网页、完整的网站、移动应用程序、PWA或聊天流生成器。据<a class="ae jo" href="https://www.statista.com/topics/8461/low-code-and-no-code-platforms/#dossierKeyfigures" rel="noopener ugc nofollow" target="_blank"> Statista </a>预测，2027年全球低码平台市场收入预计将达到650亿美元。所以，前面提到的IT产品都有发展前景。</p><p id="e99a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对商业应用的高需求推动了对开发新的低代码和无代码平台的需求。在大多数情况下，任何无代码平台都包括:</p><ul class=""><li id="1f5c" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">UI部分—具有组件、拖放对象和表单的可视界面。它允许用户为他们的产品创建界面。用户界面必须是直观的，易于广大没有技术背景的人使用。<a class="ae jo" href="https://mobidev.biz/services/ui-ux-design" rel="noopener ugc nofollow" target="_blank"> UI/UX设计师</a>经常在这个舞台上投入很多心血。</li><li id="087d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">UI到代码转换器——这一部分通常看起来像某种魔法，因为应用程序代码是从可视化界面及其组件中生成的。</li><li id="8b15" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">业务逻辑—支持后端接口功能(注册、计费等)的组件的实现。)</li><li id="047f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">自动化代码构建器——一个可选部件，允许自动将代码打包到应用程序或网站中，并将其部署到生产中。</li></ul><p id="7edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的观察表明，主要的困难可能出现在系统的第二部分(代码转换器中的UI)，然而在每一步都有微妙之处需要研究。我们将基于构建站点的案例考虑所有组件的开发，注意聊天构建器和移动应用程序构建器的特定时刻是最常见的案例。</p><p id="d132" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开始产品开发之旅时，最终用户首先看到的是什么？它是一个与构造函数相关的UI接口。因此，专业的方法和界面分析在这里至关重要——许多人不明白为什么这个阶段如此耗时。这仅仅是因为编辑器界面的进步影响了易用性。易用性意味着创建软件产品花费的精力更少，从而为最终用户简化了流程。</p><p id="42fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">建造者的设计对平台的成功至关重要，必须由了解这一领域的专业人士来实施。此外，有必要将用于创建所开发的软件产品的UI界面的构造器和用于描述其逻辑的构造器分开。在第二种情况下，可能会出现与该功能的设计相关的困难。</p><h1 id="ef26" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">无代码/低代码平台背后的技术</h1><p id="d0f2" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">构建内部编辑器架构的方法可能会有所不同，从而影响平台功能。</p><p id="360c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，<strong class="is hj">有三种主要方法</strong>来构建内部架构:</p><ol class=""><li id="e5c1" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">编辑器-&gt;代码+元信息-&gt;代码</li><li id="af22" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">编辑器-&gt; JSON -&gt;代码</li><li id="cbfe" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">编辑器-&gt;中间组件-&gt;代码</li></ol><p id="bad9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们仔细看看这些方法，并找出相关的用例。</p><h1 id="3ddd" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">编辑器-&gt;代码+元信息-&gt;代码</h1><p id="595e" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这种方法可以随时生成结果代码，并允许用户通过可视化编辑器选择和定制某些元素。对某个元素的定制完成后，它会自动更改代码库，使其与更改保持同步。在绝大多数情况下，这种方法被精确地用作编辑web页面的基础:代码变成了可视化的HTML页面。由于所有的编辑都是在浏览器端完成的，所以通过浏览器复制DOM结构可以很容易地将最终代码导出为产品。</p><p id="822e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一种方法的微妙之处包括以下几点:</p><ul class=""><li id="5cf5" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">不需要处理所有的HTML标记，只需要处理组件</strong>。任何见过复杂页面的HTML布局的人都可以理解这可能会带来挑战。如果你允许用户编辑每一个标签，那么界面会变得一团糟，变得不合适。从头开始构建页面比应用这样的构造函数更容易。因此，需要一种额外的标记，即所谓的元数据。编辑器的信息以HTML标记的自定义属性的形式添加。数据表明，内部块可以编辑或转移，而参数和属性很容易修改。</li><li id="846a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">元素或块的位置——绝对的、相对的、静态的、固定的和粘性的——可能很棘手</strong>。这是什么原因呢？关于这一点，一切都更复杂，不仅仅是表面上的，因为每个元素的位置直接影响整个页面上其他UI块的位置。这相当于一个玻璃杯，不同的球被倒入其中。如果你试着把一个木块放在玻璃中间，所有的球都会改变它们的位置，因为它们会被挤出它们的位置。我们可以在描述的情况和页面上元素的位置之间进行类比。但是，与块的位置相关的参数的情况稍微复杂一些。块的排列和“压缩”定律取决于指定的参数。</li><li id="5af2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">有限的拖放功能可能会激怒用户，因为它只与某些UI块相关</strong>。在不涉及这个问题太多细节的情况下，我们应该提到它类似于块的定位。</li><li id="24e3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">CSS(层叠样式表)中的样式不会像用户预期的那样工作</strong>。原因在于继承:为父组件设置的样式将直接影响子组件，这将使最终用户困惑，并且看起来像一个明显的UI缺陷或bug。反过来，平台的UX及其使用将会减少。幸运的是，这可以在独特的CSS类或内联样式的帮助下得到解决，尽管最终用户仍将面临副作用的挑战。</li><li id="806f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">无法导入代码</strong>。除了直接的HTML标记(在我们的例子中是这样)，编辑器还需要将自定义属性作为模板添加到标记中，模板负责编辑器的功能。</li></ul><p id="8fc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于上述原因，基于scheme Editor-&gt; code+meta-information-&gt; code的方法通常不是在无代码平台中使用，而是在低代码平台中使用，其最终用户了解技术规范和修改的副作用。低代码平台的目标受众缩小到了解类似或更有效工具的开发人员。</p><h1 id="10a9" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">编辑器-&gt; JSON -&gt;代码</h1><p id="37e3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">为了解决第一种方法的缺点，并扩展支持平台的列表，而不局限于可以显示为UI组件的HTML或代码，我们可以考虑基于中间数据模型的编辑器架构(编辑器-&gt; JSON -&gt;代码)。</p><p id="22ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一种中间数据格式，JSON可以被任何其他格式替代。尽管它提供了一些优点，这将在下面更详细地讨论。</p><p id="c306" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编辑器使用中间数据模型，因此它不会对UI部分有任何限制，并且可以实现各种UI组件的完全成熟的拖放功能。编辑器UI部分的主要任务是尽可能准确地将UI转换成中间数据模型。</p><p id="47e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从数据模型到代码的转换在转换器或编译器的帮助下实现。这一部分造成了主要的困难，因为它不仅需要编辑器所基于的技术方面的高水平的专业知识，还需要代码编译领域的高水平的专业知识。遗憾的是，我们无法给出这方面的提示和建议，因为这完全取决于项目和目标技术。</p><p id="3d26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，以下是一些需要注意的事项:</p><ul class=""><li id="79e5" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">这种方法适用于UI界面和应该描述逻辑的用例</strong>。在这些用例中，正在创建编辑器流，稍后它将形成应用程序的基础。这样，我们不仅可以编写有UI的应用程序的逻辑，还可以编写聊天机器人构建器或自动化平台的逻辑。</li></ul><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="4673" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">编译有三种方法</strong>:</li></ul><ol class=""><li id="e069" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">如果有必要建立一个逻辑流程。例如，作为聊天构建器，开发了逻辑节点之间的交换协议。在根据来自JSON的流结构执行逻辑的过程中，逻辑节点以默认顺序启动。逻辑节点是隔离的，并且其中逻辑的执行不会以这些节点的状态的形式引起第三方影响，因此该系统设计非常简单并且工作可靠。<a class="ae jo" href="https://en.wikipedia.org/wiki/Flow-based_programming" rel="noopener ugc nofollow" target="_blank">基于流程的编程</a>不同于其他范式和概念，包括面向对象编程。</li><li id="440e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">在对UI部分使用这种方法时，可以从相似的模板中插入子组件的特定块的模板正在被应用。</li><li id="ffc0" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">很少使用的第三种方法类似于<a class="ae jo" href="https://www.baeldung.com/java-sax-parser" rel="noopener ugc nofollow" target="_blank">SAX</a>(XML的简单API)解析器。它与前一个相似，但是更容易考虑代码生成的上下文。它既复杂又灵活。</li></ol><ul class=""><li id="8ffe" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">这种方法更接近于开发中的瀑布</strong>，因为在开始开发之前，有必要预先分析和描述将要使用的那些UI块的所有可能属性。如果对存储非标准数据或属性的元信息使用类似的方法，就可以绕过这个限制。</li></ul><p id="6085" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们已经提到的，JSON不是必需的，尽管JSON和XML很方便，因为它们可以完成UI代码的序列化或反序列化，而不管最终代码是为哪种技术生成的。此外，动态地创建界面是可能的，并且可能节省流量，因为，例如，JSON比带有样式的相同HTML布局要经济得多。</p><p id="6f04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，也可以导入外部代码，但需要引入额外的导出格式。每个平台的这种独特性并不方便，尽管它扩大了受众并有助于平台的流行。</p><p id="a0a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法对于服务器端逻辑流的实现是最理想的，正如编译方法中已经描述的那样。正确设计的服务器端应该总是无状态的，这使得我们更容易将业务逻辑实现为一系列独立的节点。这并不是什么独特的东西，因为像流开发范例一样，概念上类似的方法也用在RX和后端框架中，比如express/koa等等。</p><h1 id="4a7f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">编辑器-&gt;中间组件-&gt;代码</h1><p id="710f" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">第三种实现架构的方法(编辑器-&gt;中间组件-&gt;代码)，乍一看，与前一种没有太大区别。还有UI块或组件，也有负责它们在屏幕上的位置的代码。然而，本质的区别是，负责这些组件的代码并没有生成，因为它是连接到应用程序的库的一部分，并且作为程序的外部插件资源工作。</p><p id="3048" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构造器从专有库(本服务的库)的预先准备的组件组装产品的UI。这就是为什么这部分最复杂的逻辑，即编译成代码，实际上被忽略了。这样的解决方案要简单得多——您只需要创建一个可用于指定目标技术的组件库，并创建一个使用原语(组件)的编辑器。然而，这导致了大量额外的微妙之处，选择哪种方法更好必须依赖于业务需求。</p><p id="5fa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">库中的组件代码实现组件本身的功能，并且编辑器包括附加的配置文件，使得编辑器可以理解该组件允许什么操作以及它对应于库中的组件中的什么参数。</p><p id="6ef0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以注意到这种方法的以下特征:</p><ul class=""><li id="0013" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">导入外部代码将是最困难的</strong>，因为你必须指定一个包含最大功能的通用组件格式。</li><li id="6a10" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">实时组件库的更新(更扩展)版本可能不支持旧版本，这可能导致支持问题</strong>。</li><li id="b2ee" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">更快的上市时间，因为随着功能的进一步扩展，单个组件易于测试</strong>。事实上，这样的解决方案仍然会受到更多的限制，并且依赖于支持该平台的团队的能力。</li><li id="78a4" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">可靠性更高</strong></li><li id="eaca" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">小/大的性能下降</strong>(取决于目标平台和组件库实时代码的质量)。这些组件不是编译的，而是实时工作的，使用插件库作为本机组件的包装库。</li></ul><p id="a112" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，FlutterFlow就使用了这种方法。</p><p id="5fc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经研究了实现大多数无代码和低代码平台的主要部分的三种主要方法。这会帮助你选择正确的发展方向。</p><h1 id="a13f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">构建自己的无代码/低代码平台需要什么</h1><p id="b185" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在你的特定产品的开发过程中起决定性作用的另外几点也值得考虑。</p><p id="ad4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个问题是，为什么导入外部代码、模板或代码片段可以在您与无代码或低代码平台相关的业务中发挥决定性作用。一切都很基本:这种平台主要用于POC或MVP阶段，以测试商业想法或尽快进入市场。如果用例简单明了并且不需要额外的特性，它也可以用于构建利基解决方案。</p><p id="b4cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在随后的阶段，一组有限的组件或功能(现成的模块)扮演着至关重要的角色，这阻止了实现任何独特的功能或获得竞争优势。</p><p id="ce78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">支持后端逻辑的巨大成本也很重要，尽管在正确设计的情况下可以最小化。要解决功能有限的问题，可以导入外部代码——具有封闭和开放组件的npm模型就是一个例子。这样一个低代码平台将会得到社区的支持，为商业带来积极的变化。</p><p id="ac93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，如果我们谈论这种平台的实施时间，那么它明显超过了社交网络或ERP系统等标准项目。在规划阶段必须考虑到这一点。</p><p id="3855" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最后，一个小想法作为对本文的奖励:</strong>您可以使用文本描述来生成您的应用程序的框架。例如，<a class="ae jo" href="https://mobidev.biz/blog/natural-language-processing-nlp-use-cases-business" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP)，</a>将文本解析成客观和主观的实体，形成你的应用程序的结构，然后生成代码。这不会是一个理想的解决方案，就目前的技术状态而言，谈论这种用于无代码平台的方法还为时过早，但作为新的低代码平台的一个关键特性，它在不久的将来可能会非常有效。</p><p id="a938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由<a class="ae jo" href="https://mobidev.biz/our-team/yuriy-luchaninov" rel="noopener ugc nofollow" target="_blank">塞维多夫·卢恰尼诺夫</a>撰写，MobiDev 的JavaScript小组组长。</p><p id="3a6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ln">全文原载于</em><a class="ae jo" href="https://mobidev.biz/blog/technologies-behind-no-code-low-code-platforms-how-to-build-your-own" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://mobidev . biz</em></a><em class="ln">，基于mobi dev技术研究。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Stop Using Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用构造函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/stop-using-constructors-5ae7c91e1502?source=collection_archive---------9-----------------------#2022-12-26">https://medium.com/geekculture/stop-using-constructors-5ae7c91e1502?source=collection_archive---------9-----------------------#2022-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c1afbd526f5b6d59fe512680340b81d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVvi_RsH0LaIFzN30a23tg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">P.C. <a class="ae hv" href="https://cutt.ly/80034QC" rel="noopener ugc nofollow" target="_blank">https://cutt.ly/80034QC</a></figcaption></figure><div class=""/><p id="d6dc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建类的对象的传统方法是什么？我们为一个类提供构造方法来创建它的实例。但是软件工程师或开发人员应该遵循另一种技术。那是什么？一个类可以提供一个公共静态工厂方法，该方法可以返回该类的实例。</p><blockquote class="jt"><p id="e2dc" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">考虑静态工厂方法而不是构造函数</p></blockquote><p id="7de5" class="pw-post-body-paragraph iv iw hy ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">这都是关于这篇文章的。一个类可以为它的客户提供带有或不带有公共构造函数的静态工厂方法。但是提供公共静态工厂方法而不是公共构造函数既有优点也有缺点。</p><h2 id="e0a0" class="ki kj hy bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated"><strong class="ak">使用静态工厂方法的优势</strong></h2><ol class=""><li id="03c0" class="ld le hy ix b iy lf jc lg jg lh jk li jo lj js lk ll lm ln bi translated">静态工厂方法有名字，而构造函数没有。</li></ol><p id="52fd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以给静态工厂方法起一个自描述性的名称，这样更容易使用，也更容易阅读客户端代码。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="edb7" class="lx kj hy lt b be ly lz l ma mb">// TypeScript or JavaScript<br/>Array.from("foo");<br/><br/>// PHP<br/>Closure::fromCallable("strlen");<br/><br/>// Java<br/>Date date = Date.from(instant);</span></pre><p id="c368" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们不需要构造函数来创建对象。所有的类都有一个名为<code class="du mc md me lt b">from</code>的静态工厂方法。我们可以很容易地猜测对象是如何从其他类型创建的；例如，这个<code class="du mc md me lt b">[‘f’, ‘o’, ‘o’]</code>数组是从字符串<code class="du mc md me lt b">foo</code>创建的。</p><p id="bb79" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.与构造函数不同，静态工厂方法不需要在每次被调用时创建一个新对象。</p><p id="006d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，当我们创建一个类的一些对象时，每个实例都变得独立于其他实例。如果我们不允许一个类总是创建一个新对象呢？使用构造函数不可能一次又一次地返回同一个对象，只能返回静态工厂方法。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="afd1" class="lx kj hy lt b be ly lz l ma mb">// TypeScript/JavaScript<br/>static singleton(): Database {<br/>  if (! Database.instance) {<br/>    return new Database();<br/>  }<br/><br/>  return Database.instance;<br/>}<br/><br/>// PHP<br/>static function singleton(): Database<br/>{<br/>  if (! static::$instance) {<br/>    return new Database();<br/>  }<br/><br/>  return static::$instance;<br/>}<br/><br/>// Java<br/>static Database singleton() {<br/>  if (null == instance) {<br/>    return new Database();<br/>  }<br/><br/>  return instance;<br/>}</span></pre><p id="5c09" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以保证在一个脚本的生命周期中不存在两个实例，并且这个类将是一个完全不可变的类。但是使用构造函数你不能做到这一点。否则，如果创建对象的成本很高，那么通过重复调用返回同一个实例可以提高性能。</p><p id="c3cd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.与构造函数不同，静态工厂方法可以返回其返回类型的任何子类型的对象。</p><p id="c2fc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着如果一个方法的返回类型是一个基类/父类或接口，那么该方法可以使它返回该父类或接口的子类的对象。这是不可能的。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="0e32" class="lx kj hy lt b be ly lz l ma mb">// TypeScript/JavaScript<br/>static newInstance(target: String): Parent {<br/>  if ('specified type' === target)<br/>    return new Child();<br/>  else<br/>    return new OtherChild();<br/>}<br/><br/>// PHP<br/>static function newInstance(string $target): Parent<br/>{<br/>  if ('specified type' === $target)<br/>    return new Child();<br/>  else<br/>    return new OtherChild();<br/>}<br/><br/>// Java<br/>static Parent newInstance(String target) {<br/>  if ('specified type' == target)<br/>    return new Child();<br/>  else<br/>    return new OtherChild();<br/>}</span></pre><p id="6e1a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意方法的返回类型。该方法返回子对象，而不是父对象。因为父类可能是抽象类或接口。所以使用静态工厂来选择返回对象的类是非常灵活的。</p><p id="75cc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.<strong class="ix hz">作为输入参数的函数，返回对象的类可以随调用而变化。</strong></p><p id="fc12" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过查看这个<code class="du mc md me lt b">EnumSet.of()</code>方法的Java OpenJDK实现可以清楚地理解这一点，它使用这个<code class="du mc md me lt b">EnumSet.noneOf()</code>方法来使其工作。请注意，我已经省略了这两个方法的部分签名，以使它们尽可能简单。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="b4d8" class="lx kj hy lt b be ly lz l ma mb">static EnumSet of(E e1, E e2, E e3) {<br/><br/>  EnumSet result = noneOf(...); // see below<br/><br/>  result.add(e1);<br/>  result.add(e2);<br/>  result.add(e3);<br/><br/>  return result;<br/>}</span></pre><pre class="mf ls lt lu bn lv lw bi"><span id="72e3" class="lx kj hy lt b be ly lz l ma mb">static EnumSet noneOf(...) {<br/>  ...<br/><br/>  if (universe.length &lt;= 64)<br/>      return new RegularEnumSet(...); // note this line and <br/>  else<br/>      return new JumboEnumSet(...); // this line<br/>}</span></pre><p id="2fea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将返回<code class="du mc md me lt b">EnumSet</code>的哪个实现取决于<code class="du mc md me lt b">EnumSet.of()</code>方法参数的长度。如果长度小于或等于64 <code class="du mc md me lt b">RegularEnumSet</code>则返回对象，否则返回<code class="du mc md me lt b">JumboEnumSet</code>。</p><p id="363f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.<strong class="ix hz">编写包含方法的类时，返回对象的类不需要存在。</strong></p><p id="a774" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个优势是关于服务提供商的服务访问API。这个访问API可以通过静态工厂方法来实现。这种优势的目的是在缺少搜索服务的标准的情况下获得服务的默认实现。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="0786" class="lx kj hy lt b be ly lz l ma mb">// Expect a specific implementation<br/>Service.get('ge me this service', 'with this implementation');<br/><br/><br/>// Without specifying a particular implemenation<br/>Service.get('ge me this service');</span></pre><p id="3f08" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意第二个示例代码。这里缺少标准。因此，在没有特定标准的情况下，它应该返回预期服务的默认实现的对象。</p><h2 id="dce4" class="ki kj hy bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">使用静态工厂方法的缺点</h2><ol class=""><li id="abdd" class="ld le hy ix b iy lf jc lg jg lh jk li jo lj js lk ll lm ln bi translated"><strong class="ix hz">没有公共或受保护构造函数的类不能被子类化。</strong></li></ol><p id="4564" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您提供静态工厂方法，通常您会将该类的构造函数设为私有。这意味着该类没有公共的或受保护的构造函数。因此，您不能从类继承。对于一些编程语言来说确实如此。</p><p id="f4bd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但这可能不是问题。因为有一个原则——<strong class="ix hz">重合成轻继承</strong>。</p><p id="a306" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.静态工厂方法的第二个限制是程序员很难找到它们。</p><p id="b139" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你给一个类提供静态工厂方法，那么这个类的用户可能不知道名字是什么。所以他们需要这门课的文档。但是现在这不再是一个问题了，因为ide帮助很大。</p><p id="f778" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我强烈建议您遵循社区标准和最佳实践。跟随他们，你首先帮助自己，然后是别人。</p><p id="ca8f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以通过遵循如下常见命名约定来解决第二个限制:</p><ol class=""><li id="2007" class="ld le hy ix b iy iz jc jd jg mg jk mh jo mi js lk ll lm ln bi translated"><strong class="ix hz"> from </strong> —一种类型转换方法，采用单个参数并返回该类型的相应实例。以字符串返回数组为例。</li></ol><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="abf9" class="lx kj hy lt b be ly lz l ma mb">Array.from("foo");</span></pre><p id="60ef" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="ix hz"> of </strong> —一种聚合方法，采用多个参数并返回一个包含这些参数的此类型的实例，例如。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="7cd2" class="lx kj hy lt b be ly lz l ma mb">Array.of(1, 2, 3); // [1, 2, 3]<br/><br/>Set&lt;Rank&gt; faceCards = EnumSet.of (JACK, QUEEN, KING);</span></pre><p id="e7e1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<strong class="ix hz">value of</strong>——一种替代<code class="du mc md me lt b">from</code>和<code class="du mc md me lt b">of</code>的更详细的方法。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="485f" class="lx kj hy lt b be ly lz l ma mb">BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</span></pre><p id="2460" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.<strong class="ix hz">实例</strong>或<strong class="ix hz"> getInstance </strong> —返回由其参数(如果有的话)描述但不能说具有相同值的实例。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="7385" class="lx kj hy lt b be ly lz l ma mb">Registry::getInstance(); // Returns an registry object<br/><br/>StackWalker luke = StackWalker.getInstance(options);</span></pre><p id="1d1b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.<strong class="ix hz">创建</strong>或<strong class="ix hz">new instance</strong>——类似于<strong class="ix hz">实例</strong>或<strong class="ix hz"> getInstance </strong>，除了该方法保证每个调用返回一个新实例。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="11f7" class="lx kj hy lt b be ly lz l ma mb">ReflectionClass::newInstance($param1, $param2, ...);<br/><br/>Object newArray = Array.newInstance(classObject, arrayLen);</span></pre><p id="96bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.<strong class="ix hz"> getType </strong> —类似于<strong class="ix hz"> getInstance </strong>，但是在工厂方法在不同的类中时使用。<strong class="ix hz">类型</strong>是工厂方法返回的对象类型。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="6145" class="lx kj hy lt b be ly lz l ma mb">// Here FileStore is the target type<br/>FileStore fs = Files.getFileStore(path);</span></pre><p id="b9cd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.<strong class="ix hz"> newType </strong> —类似于<strong class="ix hz"> newInstance </strong>，但是如果工厂方法在不同的类中使用。<strong class="ix hz">类型</strong>是工厂方法返回的对象类型。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="61e6" class="lx kj hy lt b be ly lz l ma mb">// Here BufferedReader is the target type<br/>BufferedReader br = Files.newBufferedReader(path);</span></pre><p id="6f33" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.<strong class="ix hz">类型</strong>——getType和<strong class="ix hz"> newType </strong>的简洁替代。</p><pre class="lo lp lq lr fd ls lt lu bn lv lw bi"><span id="5e09" class="lx kj hy lt b be ly lz l ma mb">// Here List is the target type<br/>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</span></pre><h2 id="9303" class="ki kj hy bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">决定</h2><p id="b995" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg mj ji jj jk mk jm jn jo ml jq jr js hb bi translated">现在的问题是:我应该总是使用静态工厂方法而不是构造函数吗？看情况。静态工厂方法和构造函数都有自己的用途。但是在使用构造函数之前，您应该首先考虑静态工厂方法。</p><p id="a646" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">注意</strong>本出版物是来自<a class="ae hv" href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997" rel="noopener ugc nofollow" target="_blank"> Effective Java </a>一书的“项目1:考虑静态工厂方法而不是构造函数”的简短版本，作者是<a class="ae hv" href="https://en.wikipedia.org/wiki/Joshua_Bloch" rel="noopener ugc nofollow" target="_blank"> Joshua Bloch </a>。我强烈推荐这本书。然后你看“第一项”。</p><p id="3840" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Medium、<a class="ae hv" href="https://github.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Github、</a><a class="ae hv" href="https://twitter.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Twitter、</a>或<a class="ae hv" href="https://www.linkedin.com/in/unclexo" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How network protocols really work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络协议是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-network-protocols-really-work-99a31d623c15?source=collection_archive---------12-----------------------#2022-02-08">https://medium.com/geekculture/how-network-protocols-really-work-99a31d623c15?source=collection_archive---------12-----------------------#2022-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2053f0e58efc697911beccbae7976acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuZzoXwfF9HwYTAZ8b3f0w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/photos/M5tzZtFCOfs" rel="noopener ugc nofollow" target="_blank">Taylor Vick</a> on <a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5cd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">互联网网络协议入门。</p><h1 id="325a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="5c1e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当弹出gRPC、DNS或TCP/IP这样的名字时，你是否感到害怕？你希望你能自由地浏览这些东西，知道这封信是如何相互关联的，并就这个主题提出适当的问题吗？</p><p id="6860" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个故事将让你对网络协议是如何真正工作的有一个坚实的理解。</p><h1 id="f1ac" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">OSI模型</h1><p id="ac6e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">每一项关于网络协议的研究都会让你进入<strong class="ix hj"> OSI </strong>模型。简而言之，OSI是一个概念性的<strong class="ix hj">分层</strong>模型，由国际标准化组织在20世纪80年代开发。OSI试图标准化当时不同的网络方法，为网络(最终成为互联网)的未来发展提供坚实的基础。</p><p id="fb2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OSI还提供了多个协议的实际实现，支持每个概念层，这套协议也被称为<a class="ae iu" href="https://en.wikipedia.org/wiki/OSI_protocols" rel="noopener ugc nofollow" target="_blank"> OSI协议</a>。但是OSI的实现并没有使它成为互联网，输掉了与TCP/IP协议栈的战斗。</p><p id="4d08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管如此，OSI的分层网络的概念是如此成功，以至于它仍然被用作描述互联网网络的参考模型。</p><p id="6ad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然<a class="ae iu" href="https://en.wikipedia.org/wiki/OSI_model" rel="noopener ugc nofollow" target="_blank"> OSI理论</a>描述了7层网络模型，但其中2层有些过于理论化和冗余，因此我们将使用OSI的5层子集，因为它更简单且与现实世界的协议更相关。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/2e6c1e2c6e0edab27027889e1ab9123e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*bVHxVl-9_Hz-D20Rb5ejxA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">5 layers of OSI model</figcaption></figure><p id="00c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OSI层可以被视为抽象层，其中一层使用较低层提供的方法来实现其功能，而底层完全不知道那些较高层的字节到底代表什么。</p><h2 id="a963" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">物理层</h2><p id="150b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Physical_layer" rel="noopener ugc nofollow" target="_blank">物理层</a>负责设备和物理<a class="ae iu" href="https://en.wikipedia.org/wiki/Transmission_medium" rel="noopener ugc nofollow" target="_blank">传输介质</a>之间非结构化原始数据的传输和接收。如何在某种介质中表示1和0的每一个巧妙的概念都是在这一层上规定的，因此它将数字比特转换成电、无线电或光信号(反之亦然)。例如，物理层规范包含在无处不在的<a class="ae iu" href="https://en.wikipedia.org/wiki/Bluetooth" rel="noopener ugc nofollow" target="_blank">蓝牙</a>、<a class="ae iu" href="https://en.wikipedia.org/wiki/Ethernet_physical_layer" rel="noopener ugc nofollow" target="_blank">以太网</a>和<a class="ae iu" href="https://en.wikipedia.org/wiki/USB" rel="noopener ugc nofollow" target="_blank"> USB </a>标准的规范中。</p><h2 id="fc2a" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">数据链路层</h2><p id="f20d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Data_link_layer" rel="noopener ugc nofollow" target="_blank">数据链路层</a>在两个<strong class="ix hj">直接连接的</strong>节点之间提供传输链路。它检测并可能纠正物理层中可能出现的错误。它定义了在两个物理连接的<strong class="ix hj"> </strong>设备之间建立和终止连接的协议。在这一层，<strong class="ix hj"> MAC地址</strong>开始识别网络中的节点。由于这一层只负责直接连接的节点之间的通信，它不足以建立一个像互联网这样的全球网络，因此我们需要下一个抽象层次，网络层。</p><h2 id="fc8b" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">网路层</h2><p id="cad5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Network_layer" rel="noopener ugc nofollow" target="_blank">网络层</a>允许在“不同网络”(可能在地球的不同一端)中的实体之间传输数据。这个过程被称为<a class="ae iu" href="https://en.wikipedia.org/wiki/Routing" rel="noopener ugc nofollow" target="_blank">路由</a>，由寻址和识别系统支持。简而言之，网络层允许通过任意长的路由器序列路由数据包，以到达其最终目的地。这个范围内的主要协议是<strong class="ix hj">互联网协议</strong> (IP)，它确实是互联网的主干！在这一层，全球网络的实体可以通过其<strong class="ix hj"> IP地址</strong>到达。</p><h2 id="40f9" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">传输层</h2><p id="4263" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">好了，现在我们有能力向任何连接到互联网的IP地址发送原始字节包，这要感谢IP协议。但是，如果一台机器需要同时接收多个只有一个IP地址的数据流，它如何区分数据包并将其路由到正确的应用程序呢？这个问题的解决方案是<a class="ae iu" href="https://en.wikipedia.org/wiki/Multiplexing" rel="noopener ugc nofollow" target="_blank">复用</a>，它是一种通用的方法，通过<a class="ae iu" href="https://en.wikipedia.org/wiki/Shared_medium" rel="noopener ugc nofollow" target="_blank">共享介质</a>将多个模拟或数字信号组合成一个信号。在IP之上的传输层实现了两种主要的互联网协议，即<strong class="ix hj"> TCP </strong>和<strong class="ix hj"> UDP </strong>，在指定连接地址时，这两种协议都使用了<strong class="ix hj">port</strong>(0–65535)的概念来实现复用。</p><p id="6862" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">UDP 只是IP之上的一个轻量级抽象，它只是引入了端口的概念，并提供一些错误检查功能。如果数据包丢失，UDP将不会做任何事情，甚至也不会试图找出数据包是否已送达接收方。它没有<a class="ae iu" href="https://en.wikipedia.org/wiki/Handshaking" rel="noopener ugc nofollow" target="_blank">握手</a>对话，因此将用户的程序暴露给底层网络的任何不可靠性；不保证交付、订购或重复保护。对时间敏感的应用程序(如在线游戏或视频通话)经常使用UDP，因为丢失数据包比等待因<a class="ae iu" href="https://en.wikipedia.org/wiki/Retransmission_(data_networks)" rel="noopener ugc nofollow" target="_blank">重传</a>而延迟的数据包更可取，这在<a class="ae iu" href="https://en.wikipedia.org/wiki/Real-time_system" rel="noopener ugc nofollow" target="_blank">实时系统</a>中可能不是一个选项。</p><p id="cf34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> TCP，</strong>另一方面，<strong class="ix hj"> </strong>检测任何类型的连接问题，请求重新传输丢失的数据，重新排列无序的数据，甚至帮助最小化网络拥塞，以减少其他问题的发生。如果数据仍未送达，则通知源系统此故障。一旦TCP接收器重组了最初传输的八位字节序列，它就将它们传递给接收应用程序。因此，TCP从底层网络细节中抽象出应用程序的通信。</p><p id="25d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望现在您已经看到了这种模式:每一个下一层的协议都只是一个使用底层协议所提供的方法的概念。这个概念被称为协议封装，下层协议封装上层协议提供的数据。</p><p id="1f8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，IP协议允许您将数据发送到指定的IP地址，然后TCP和UDP协议都使用IP数据包的某个预定义部分来指定端口值。<em class="lp">端口</em>只是传输层的一个概念，旨在复用数据，而不是物理上存在于网络设备中的东西。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/6e89ed37c96e720f07bab147458e9033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii6EFhIcuaQXGWwRaXQKOQ.png"/></div></div></figure><h2 id="f8c0" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">应用层</h2><p id="3acf" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在深入这一层之前，让我们回顾一下(或者说向下看)，看看我们从底层得到了什么:</p><ul class=""><li id="54b0" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">在物理层<em class="lp">上通过各种媒介(有线、无线)连接设备</em></li><li id="55ca" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">使用<em class="lp">链路层</em>将直接连接的设备聚集成小型网络</li><li id="2f74" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">由于<em class="lp">网络层</em>特别是IP协议，具有在小型网络之间路由数据的能力，有效地呈现具有寻址方案的全球网络</li><li id="ddff" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">多路传输流量的能力，使用<em class="lp">端口、</em>和<em class="lp"> </em>的概念选择我们是需要一个可靠的自动错误恢复(TCP)传输协议，还是仅仅需要一个基于IP (UDP)的快速轻量级包装器</li></ul><p id="c419" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，我们已经具备了通过互联网以对等方式进行可靠数据通信所需的一切。</p><p id="32e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，留给应用层的任务是指定应用程序数据的格式。数据格式规范本质上是<em class="lp">应用层</em> <em class="lp">协议</em>。有时它是预定义的结构化规范(例如DNS)，有时协议只是描述它所期望的文本数据的解析规则(例如HTTP)。</p><h1 id="17d2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">协议图</h1><p id="5c04" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我画了一张地图，上面有一些流行的网络协议。既然您已经理解了协议封装的概念，这将非常有意义。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/36dc07326c29188c389314ec7d3cab72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R62lnHCscBIxDggqSxYvfw.png"/></div></div></figure><h1 id="9c7a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="374d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在本文中，我们探讨了网络协议是如何工作的，并展示了分层和协议封装的概念。理解了这些基本概念，您就有了坚实的基础来分析您可能会遇到的任何新协议。</p></div></div>    
</body>
</html>
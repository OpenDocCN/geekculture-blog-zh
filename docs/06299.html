<html>
<head>
<title>Context-API in ReactJS, Why and How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS中的Context-API，为什么和如何？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/context-api-in-reactjs-why-and-how-a493fe7705de?source=collection_archive---------25-----------------------#2021-08-16">https://medium.com/geekculture/context-api-in-reactjs-why-and-how-a493fe7705de?source=collection_archive---------25-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/390698711cc78b91b184bb052aa6f073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQE3KTxljMTkBxu0mZFB-g.jpeg"/></div></div></figure><h1 id="344d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么使用Context-API？</h1><ul class=""><li id="97c8" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">为了理解为什么要使用Context-API，我们先来看看什么是<strong class="jq hj">道具训练</strong>。</li></ul><h2 id="6dee" class="kg ir hi bd is kh ki kj iw kk kl km ja jv kn ko je jx kp kq ji jz kr ks jm kt bi translated">-道具-钻孔:-</h2><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/94425f03f339c526289efc2c3ac96fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOpxRXP7O0laXUDIqzm2_Q.png"/></div></div></figure><ul class=""><li id="d0cd" class="jo jp hi jq b jr kz jt la jv lb jx lc jz ld kb kc kd ke kf bi translated">请看左边的组件树图像。</li><li id="fbc6" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">可能会有这样的情况，树底部的<strong class="jq hj">子组件</strong>需要数据。但是，<strong class="jq hj">容器组件</strong>或中间的<strong class="jq hj">子组件可能不需要这些数据。</strong></li><li id="53d4" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">在这种情况下，即使中间组件不需要数据，它们也需要接收数据，以便传递给子组件。</li><li id="6655" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">如果您的应用程序太大，那么这将导致一个大问题。开发人员需要不断地将数据从一个组件传递到下一个组件。</li><li id="db65" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">这个问题被称为道具演练。</li></ul></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h2 id="fd0e" class="kg ir hi bd is kh ki kj iw kk kl km ja jv kn ko je jx kp kq ji jz kr ks jm kt bi translated"><strong class="ak"> <em class="lq">克服道具钻上下文问题——引入API。</em>T15】</strong></h2><ul class=""><li id="a70b" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">在Context-API中，在组件树之外创建了一个单独的存储空间，我们必须在其中存储数据。</li><li id="96fd" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">现在，如果我们需要任何组件中的数据，我们可以直接从Context-API访问数据。</li><li id="f3a2" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">现在让我们通过一个例子来看看这是如何工作的。</li></ul></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="207d" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">步骤1:-创建上下文API并在其中存储数据:-</h1><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><ul class=""><li id="fc49" class="jo jp hi jq b jr kz jt la jv lb jx lc jz ld kb kc kd ke kf bi translated">要创建上下文，我们可以使用<strong class="jq hj">的<strong class="jq hj"> createContext() </strong>。</strong></li><li id="bac5" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">一旦创建了用户上下文，我们就必须导出它。</li><li id="b4b2" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">现在，要在上下文中添加数据，我们必须用<strong class="jq hj"> &lt; UserContext包装父元素。提供者&gt; </strong>或<strong class="jq hj"> &lt;用户提供者&gt;。</strong></li><li id="0596" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">一旦我们用包装器包装，那么我们必须将数据传递到<strong class="jq hj">值</strong>属性中。</li></ul><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="f622" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">现在有三种方法来使用这个上下文。</h1><blockquote class="ly"><p id="1110" class="lz ma hi bd mb mc md me mf mg mh kb dx translated">1)在功能组件中。</p><p id="e342" class="lz ma hi bd mb mc md me mf mg mh kb dx translated">2)在类组件的生命周期方法中。</p><p id="b4c5" class="lz ma hi bd mb mc md me mf mg mh kb dx translated">3)在类组件的Render方法中。</p></blockquote><h1 id="1283" class="iq ir hi bd is it iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn bi translated">1)在功能组件中:-</h1><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><ul class=""><li id="ce22" class="jo jp hi jq b jr kz jt la jv lb jx lc jz ld kb kc kd ke kf bi translated">在功能组件或钩子内部，我们必须使用React包提供的<strong class="jq hj"> useContext() </strong>钩子。</li><li id="1755" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">现在我们必须导入UserContext并将其传递给<strong class="jq hj"> useContext() </strong>。</li><li id="2743" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated"><strong class="jq hj">use Context(user context)</strong>将返回context .中的用户数据，我们可以进一步使用这些数据。</li></ul></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="7ae6" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">2)在类组件的生命周期方法中。</h1><ul class=""><li id="5df7" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">从类组件访问上下文最常见的方式是通过静态的<code class="du ml mm mn mo b">contextType</code>。</li><li id="84f7" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">如果您需要来自<code class="du ml mm mn mo b">render</code>之外的上下文的值，或者在生命周期方法中，您将这样使用它。</li></ul><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="fac3" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">3) <em class="lq">在类组件的渲染方法中。</em></h1><ul class=""><li id="2975" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">检索上下文值的传统方法是将子组件包装在<code class="du ml mm mn mo b">Consumer</code>中。</li><li id="61ad" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">从那里，您将能够以<code class="du ml mm mn mo b">props</code>的形式访问价值主张。</li><li id="065f" class="jo jp hi jq b jr le jt lf jv lg jx lh jz li kb kc kd ke kf bi translated">您可能仍然会看到这种情况，但这更像是一种访问上下文的传统方式。</li></ul><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Can Stream API and JPA be friends?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stream API和JPA能成为朋友吗？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/can-stream-api-and-jpa-be-friends-4e48d6af04aa?source=collection_archive---------15-----------------------#2021-07-25">https://medium.com/geekculture/can-stream-api-and-jpa-be-friends-4e48d6af04aa?source=collection_archive---------15-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c257ac10c799d32c194b372e40368f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZtWVavdB7_Rnq_KdAsgdcg.jpeg"/></div></figure><p id="9002" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我将向社区介绍JPAstreamer库。这个库的想法非常简单，但同时也很巧妙——从数据库中获取我们需要的实体，就像我们只是在streamer中处理一个实体流一样。</p><p id="c29b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我们有一个问题——我们在应用程序中使用JPA，我们希望以某种方式更有效地在数据库上执行选择。同时，我们希望有一个直观的界面，就像在流API中一样。</p><p id="2eec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了解决这样的问题，发明了以下技术——Hibernate查询语言(HQL)和Java持久性查询语言(JPQL)。但是它们提供了相当复杂的解决问题的方法，现在还不是很清楚。</p><p id="2aeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用JPAstreamer库，检索实体的方法发生了变化。它允许我们以类似流的方式编写实体选择，然后在基础上执行。</p><p id="350c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们按顺序看看这是如何发生的。</p><p id="e483" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在幕后，JPAstreamer使用了一个注释处理器，比如Lombok中的那个。在编译时，它为JPA实体分析我们的代码，并为它们生成一个元模型。也就是说，如果我们的代码有标有<a class="ae jk" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank"> @Entity </a>注释的Book class，它将生成带有元模型的Book$ class。在这里找到这个类:target/generated-sources/annotations，或者，如果您使用的是Gradle，则是build/generated/sources/annotation processor。</p><p id="4a06" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为什么我们需要元模型？</p><p id="f7da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为最终我们只想使用流接口，所以我们必须让库知道我们何时传递了关于选择的信息，以及我们何时已经处理了获得的结果。因此，我们基于我们的实体创建一个元模型，并对每个字段进行描述。</p><p id="bd6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，当我们使用元模型的字段时，我们描述了实体选择规则。当我们使用实体字段时，我们处理选择返回的结果。</p><p id="8123" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实际上，我们来看一个例子。为此，我将在Spring Boot创建一个项目，并向其中添加几个实体。</p><p id="0f30" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们将依赖项添加到项目中:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="5a9d" class="ju jv hi jq b fi jw jx l jy jz">implementation ‘com.speedment.jpastreamer:jpastreamer-core:1.0.2’ annotationProcessor “com.speedment.jpastreamer:fieldgenerator-standard:1.0.2” implementation ‘com.speedment.jpastreamer.integration.spring:spring-boot-jpastreamer-autoconfigure:1.0.2’</span></pre><p id="68f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们创建实体:</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="6320" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">库生成的类将如下所示:</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e73b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看一些如何使用库的例子。</p><p id="822a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我已经上传了一个示例代码<a class="ae jk" href="https://github.com/r331/jpastreamer-sample/blob/main/src/test/java/dev/ivanov/jpastream/StreamerTest.java" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="7a5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了获得所有的实体，只需运行代码:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="06c8" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class).toList();</span></pre><p id="e71e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们试着过滤掉2020年以前的书。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="1873" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class) .filter(Book$.year.greaterOrEqual(2020)) .toList();</span></pre><p id="3bc5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在控制台上，我们将看到以下请求:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="4706" class="ju jv hi jq b fi jw jx l jy jz">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i5_1_, book0_.price as price2_1_, book0_.title as title3_1_, book0_.year as year4_1_ from book book0_ where book0_.year&gt;=?</span></pre><p id="3b12" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果过滤不是通过元模型类完成的呢？</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="1c73" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class) .filter(x -&gt; x.getYear() &gt;= 2020) .toList();</span></pre><p id="0b78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将导致控制台上出现以下查询:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="d65e" class="ju jv hi jq b fi jw jx l jy jz">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i5_1_, book0_.price as price2_1_, book0_.title as title3_1_, book0_.year as year4_1_ from book book0_</span></pre><p id="7ef1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实际上，在这种情况下，我们已经在过滤中使用了选择的结果，因此我们必须使用元模型的字段来创建有效的选择。</p><p id="2023" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以组合选择:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="6508" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class) .filter(Book$.year.greaterOrEqual(2020)) .filter(Book$.price.in(1000.0, 1700.0)) .toList();</span></pre><p id="1437" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">排序:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="6106" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class) .sorted(Book$.price) .toList();</span></pre><p id="e0bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">相应地，数据库中的查询:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="4a72" class="ju jv hi jq b fi jw jx l jy jz">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i5_1_, book0_.price as price2_1_, book0_.title as title3_1_, book0_.year as year4_1_ from book book0_ order by book0_.price asc</span></pre><p id="b96e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">排序可以变得更复杂:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="363e" class="ju jv hi jq b fi jw jx l jy jz">jpaStreamer.stream(Book.class) .sorted(Book$.price.reversed().thenComparing(Book$.title.comparator())) .toList();</span></pre><p id="10fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还可以使用skip和limit方法执行分页操作:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="fb4b" class="ju jv hi jq b fi jw jx l jy jz">var books = jpaStreamer.stream(Book.class)<br/>.sorted(Book$.price).skip(3).limit(3).toList();</span></pre><p id="6735" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据库请求:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="a0c3" class="ju jv hi jq b fi jw jx l jy jz">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i5_1_, book0_.price as price2_1_, book0_.title as title3_1_, book0_.year as year4_1_ from book book0_ order by book0_.price asc limit ? offset ?</span></pre><p id="17c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还可以创建更复杂的查询，比如连接操作。</p><p id="a2da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们将获得所有书籍的作者:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="4deb" class="ju jv hi jq b fi jw jx l jy jz">var authors = jpaStreamer.stream(Book.class).map(Book::getAuthor) .toList();</span></pre><p id="4d8c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们会在控制台上看到:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="7d43" class="ju jv hi jq b fi jw jx l jy jz">Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_ from author author0_ where author0_.id=? Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_ from author author0_ where author0_.id=? Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_ from author author0_ where author0_.id=? Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_ from author author0_ where author0_.id=?</span></pre><p id="5510" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样不好:)我们通过加盟来解决这个问题:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="2c35" class="ju jv hi jq b fi jw jx l jy jz">var configuration = StreamConfiguration.of(Book.class) .joining(Book$.author); <br/>var authors = jpaStreamer.stream(configuration) .map(Book::getAuthor).toList();</span></pre><p id="2dbe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在一切都很好。</p><p id="895e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">连接配置是可配置的，有一个枚举:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="9f39" class="ju jv hi jq b fi jw jx l jy jz">public enum JoinType { <br/><em class="kc">/** Inner join. */</em> INNER, <br/><em class="kc">/** Left outer join. */</em> LEFT, <br/><em class="kc">/** Right outer join. */</em> RIGHT }</span></pre><p id="cf8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">值得一提的是，文档中的作者制作了一个漂亮的表格，其中列出了SQL操作及其到流的映射:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/83cf36cdb312a0e8238f674bbfbcb24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6seLnE8xk7gpRdOSKUZhCg.png"/></div></div></figure><p id="618e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结论</p><p id="bd75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我真的很喜欢溪流，这个图书馆对我来说是一个愉快的发现。在我看来，它允许对数据库查询所需的逻辑进行更加透明和简单的描述。这反过来又会导致更可靠、更易于维护的应用程序。感谢您的关注！</p></div></div>    
</body>
</html>
<html>
<head>
<title>A bird’s-eye view of Google JAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌JAX鸟瞰图</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-birds-eye-view-of-google-jax-61f3d47926cc?source=collection_archive---------22-----------------------#2021-06-13">https://medium.com/geekculture/a-birds-eye-view-of-google-jax-61f3d47926cc?source=collection_archive---------22-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要我总结Google Jax是什么，我会说它是函数式编程(FP)风格和可微分NumPy操作的异构混合体，运行在加速器上。</p><p id="b4e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对NumPy和FP的熟悉使它很特别。可以说，它无副作用的做事方式使它变得安全。不允许你做突变，即原地修饰。有些人可能认为这可能会妨碍它的性能，但通常不是这样；编译器会处理它。它提供了一种异步调度机制，在这种机制下，不需要等待计算完成，就可以将控制权交还给用户。本质上，我们得到了一个与它被计算(promise)解耦的未来对象。这种模式促进了灵活性和分布式计算。另一个亮点是即时编译(jit)，它允许我们使用XLA(一个优化的线性代数编译器)一起编译多个操作。除此之外，我们还可以通过vmap API获得矢量化地图。</p><p id="90da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来谈谈jax提供的grad函数。从FP的观点来看，</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e296" class="jm jn hi ji b fi jo jp l jq jr">grad :: Differentiable f =&gt; f -&gt; f’</span></pre><p id="8f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，对于一个可微函数f，我们得到它的梯度。grad(f)是计算梯度的函数，grad(f) (x)是f在x处计算的梯度。为了说明如何一起使用grad和vmap，这里有一个简单的函数</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es js"><img src="../Images/6f8f10b3395b0accec7011f2de2a3c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*ZP5dMk_CiofVMcsxVQ43Yw.png"/></div></div></figure><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es ka"><img src="../Images/c3edade2f0fea7c911650a0a5b1066e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*Xx6SGESRTC45--tdqRxqyw.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">plot_func_and_deriv(lambda x: x**3)</figcaption></figure><p id="0363" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">jax.grad(f) (x)是f在x处的梯度</p><p id="7e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无处不在的地图被定义为:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5e78" class="jm jn hi ji b fi jo jp l jq jr">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></pre><p id="302c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增强的vmap更进一步，我们获得了自动矢量化的好处。默认情况下，零数组轴用于映射所有参数。vmap的一些使用案例包括:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="06c2" class="jm jn hi ji b fi jo jp l jq jr">mat = random.normal(key, (150,100))<br/>batched_x = random.normal(key, (10, 100))</span><span id="3585" class="jm jn hi ji b fi kf jp l jq jr">def apply_matrix(v):<br/>    return jnp.vdot(mat, v)</span><span id="c3d7" class="jm jn hi ji b fi kf jp l jq jr">vmap(lambda mat,v: jnp.dot(mat, v), (None,0) ) (mat, batched_x)<br/>vmap(lambda v: jnp.dot(mat, v), 0) (batched_x)<br/>(vmap(lambda v: jnp.dot(mat, v), 1, 0) (random.normal(key, (100, 10))))<br/>(vmap(lambda v: jnp.dot(mat, v), 1, 1) (random.normal(key, (100, 10))))</span><span id="6455" class="jm jn hi ji b fi kf jp l jq jr">vv = lambda v1, v2: jnp.vdot(v1,v2)<br/>mv = vmap(vv, (0,None), 0) #([b,a], [a]) -&gt; [b]<br/>mm = vmap(mv, (None, 1), 0) # Note: (None, 0), normally. Here, we have unusual (10, None) shape</span><span id="72f4" class="jm jn hi ji b fi kf jp l jq jr">mm(mat, batched_x.T)<br/>vmap(mv, (None, 0), 0) (mat, batched_x)</span></pre><p id="9210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一提的一个特性是，我们可以通过实现Pytree接口来注册自己的自定义数据类型。Pytree是一种树状结构，由类似容器的Python对象构建而成。通过这样做，JAX函数转换可以应用于接受数组pytrees作为输入并产生数组pytrees作为输出的函数。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2011" class="jm jn hi ji b fi jo jp l jq jr">from jax.tree_util import register_pytree_node</span><span id="7f2e" class="jm jn hi ji b fi kf jp l jq jr"><a class="ae kg" href="http://twitter.com/register_pytree_node" rel="noopener ugc nofollow" target="_blank">@register_pytree_node</a>_class<br/>class Point:<br/>    def __init__(self, x, y, z):<br/>        self.x = x<br/>        self.y = y<br/>        self.z = z</span><span id="8d0d" class="jm jn hi ji b fi kf jp l jq jr">def __repr__(self):<br/>        return f"Point({self.x}, {self.y}, {self.z})"</span><span id="746a" class="jm jn hi ji b fi kf jp l jq jr">def tree_flatten(self):<br/>        return ((self.x, self.y, self.z), None)</span><span id="fb76" class="jm jn hi ji b fi kf jp l jq jr"><a class="ae kg" href="http://twitter.com/classmethod" rel="noopener ugc nofollow" target="_blank">@classmethod</a><br/>    def tree_unflatten(cls, aux_data, children):<br/>        return cls(*children)</span></pre><p id="8725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以定义对我们的数据类型进行操作的任意函数，并使它们可微分:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e3a1" class="jm jn hi ji b fi jo jp l jq jr">@jit<br/>def dist_orig(pt: Point):<br/>    return jnp.sqrt(pt.x**2 + pt.y**2 + pt.z**2)</span><span id="397d" class="jm jn hi ji b fi kf jp l jq jr">grad(dist_orig)(Point(1., 2., 3.))</span></pre><p id="72dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说两个基本运算:雅可比矢量积和矢量-雅可比积。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kh"><img src="../Images/765d2fa0bf7e6f02fc045556fdf25a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgT4XobCY0eshlHpdPS0Aw.png"/></div></div></figure><p id="f1ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVP是给定向量在算子的雅可比矩阵上的投影。它捕捉关于深度神经网络(DN)输入-输出映射的局部几何结构的关键信息，这是其流行背后的主要原因之一。不幸的是，对于真实世界的DN架构来说，jvp的计算开销很大。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a43b" class="jm jn hi ji b fi jo jp l jq jr">import jax.numpy as jnp<br/>from jax import grad, jit, vmap<br/>from jax import random</span><span id="e412" class="jm jn hi ji b fi kf jp l jq jr">key = random.PRNGKey(0)<br/># Linear logistic model</span><span id="1760" class="jm jn hi ji b fi kf jp l jq jr">def predict(W, b, inputs):<br/>    return sigmoid(jnp.dot(inputs, W) + b)  # inputs is data matrix</span><span id="e4aa" class="jm jn hi ji b fi kf jp l jq jr">inputs = jnp.array([[0.52, 1.12, 0.77],<br/>                    [0.88, -1.08, 0.15],<br/>                    [0.52, 0.06, -1.39],<br/>                    [0.74, -2.49, 1.39]])</span><span id="5938" class="jm jn hi ji b fi kf jp l jq jr">targets = jnp.array([True, True, False, True])</span><span id="fc81" class="jm jn hi ji b fi kf jp l jq jr"># loss is a scalar</span><span id="8840" class="jm jn hi ji b fi kf jp l jq jr">def loss(W, b):<br/>    preds = predict(W, b, inputs)<br/>    label_probs = preds * targets + (1 - preds)*(1 - targets)<br/>    return -jnp.sum(jnp.log(label_probs))</span><span id="c130" class="jm jn hi ji b fi kf jp l jq jr">key, W_key, b_key = random.split(key, 3)<br/>W = random.normal(W_key, (3,))<br/>b = random.normal(b_key, ())</span><span id="1d72" class="jm jn hi ji b fi kf jp l jq jr">from jax import jvp<br/># Isolate the function from the weight matrix to the predictions<br/>def f(W): return predict(W, b, inputs)</span><span id="bc2d" class="jm jn hi ji b fi kf jp l jq jr">key, subkey = random.split(key)<br/>v = random.normal(subkey, W.shape)</span><span id="619e" class="jm jn hi ji b fi kf jp l jq jr"># Push forward the vector `v` along `f` evaluated at `W`<br/>y, u = jvp(lambda W: predict(W, b, inputs), primals=(W,), tangents=(v,))</span></pre><p id="8b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">矢量雅可比乘积构成反向模式自动微分的基础。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ki"><img src="../Images/17989216613bcadbc11309bb6c3b166b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1-EhCkwqpmYefvoV-aNYA.png"/></div></div></figure><p id="9255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kj kk kl ji b"><strong class="ih hj">vjpfun</strong></code>是从一个与<code class="du kj kk kl ji b"><strong class="ih hj">primals_out</strong></code>形状相同的余切向量到一个与<code class="du kj kk kl ji b"><strong class="ih hj">primals</strong></code>形状相同的余切向量元组的函数，代表在<code class="du kj kk kl ji b"><strong class="ih hj">primals</strong></code>求值的<code class="du kj kk kl ji b"><strong class="ih hj">fun</strong></code>的向量-雅可比乘积。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="76e6" class="jm jn hi ji b fi jo jp l jq jr">from jax import vjp</span><span id="3615" class="jm jn hi ji b fi kf jp l jq jr">y, vjp_fun = vjp(lambda W: predict(W, b, inputs), W)</span><span id="beb1" class="jm jn hi ji b fi kf jp l jq jr">key, subkey = random.split(key)<br/>u = random.normal(subkey, y.shape)<br/>identity = jnp.eye(*y.shape, dtype=jnp.float32)<br/># Pull back the covector `u` along `f` evaluated at `W`<br/>vjp_fun(u)<br/>print("Recovering Jacobian elements row-wise!")<br/>print(vjp_fun(identity[0]),<br/>      vjp_fun(identity[1]),<br/>      vjp_fun(identity[2]),<br/>      vjp_fun(identity[3]), sep="\n")</span></pre><p id="8d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的例子中，我试图说明JAX的关键亮点，包括它的FP启发的方法，它鼓励可组合性并产生干净的代码。如果这篇文章引起了您的兴趣，请查阅官方文档。</p></div></div>    
</body>
</html>
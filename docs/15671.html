<html>
<head>
<title>Memory Leak in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的内存泄漏</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/memory-leak-in-c-7a02eee0c085?source=collection_archive---------6-----------------------#2022-11-13">https://medium.com/geekculture/memory-leak-in-c-7a02eee0c085?source=collection_archive---------6-----------------------#2022-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="47c3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你的程序有内存泄漏吗？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/82a0d735fcffd5b7d3478b42295c1ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*palPo6hwE994I-ww"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@liam_1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Liam Briese</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><pre class="iy iz ja jb fd jo jp jq jr aw js bi"><span id="e02f" class="jt ju hi jp b fi jv jw l jx jy">ERROR: LeakSanitizer: detected memory leaks</span></pre><p id="c7c5" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">哦不，内存泄漏？怎么发生的？</p><p id="aea9" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">当在堆中分配了内存，但在使用后没有释放内存时，就会发生内存泄漏。因此，它将减少可用的内存。</p><h1 id="3ae6" class="kv ju hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">简单的例子</h1><p id="a04f" class="pw-post-body-paragraph jz ka hi kb b kc lm ij ke kf ln im kh ki lo kk kl km lp ko kp kq lq ks kt ku hb bi translated">为了说明它是如何发生的，我们将使用一些带有“危险”关键字的简单示例，<code class="du lr ls lt jp b">new</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="0e43" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">要运行并观察内存泄漏，您可以在运行程序的同时<strong class="kb hj">检查本地计算机的内存。确保您的计算机至少有4GB的内存，并准备终止程序！</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="656e" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">您会观察到内存使用量<strong class="kb hj">逐渐增加</strong>，直到您终止程序。如果您将<code class="du lr ls lt jp b">BigMemory</code>中的<code class="du lr ls lt jp b">10</code>的值增加到一个更大的数字，例如<code class="du lr ls lt jp b">20</code>，情况可能会更糟。请注意，<code class="du lr ls lt jp b">BigMemory</code>结构中的<code class="du lr ls lt jp b">usleep</code>和<code class="du lr ls lt jp b">10</code>的值有助于减缓内存泄漏，并且只泄漏一小部分仍可观察到的内存。请不要试图泄漏太多的内存，或者在观察到内存增长后不要终止程序，否则可能会发生的情况是在您的计算机冻结之前填满交换分区，这取决于您的操作系统的处理。</p><p id="7e58" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">从上面的代码来看，对于默认构造函数<code class="du lr ls lt jp b">BadClass</code>的每次调用，<code class="du lr ls lt jp b">new</code>操作将为<code class="du lr ls lt jp b">BigMemory</code>分配堆内存，然后复制指向<code class="du lr ls lt jp b">big_memory_</code>成员变量的指针。但是，由于对象中没有释放内存，所以会发生内存泄漏。</p><p id="1368" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">要对这个例子进行简单的修正，只需添加一个析构函数，在对象被销毁时删除分配的内存。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="165a" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">现在再次运行代码，您不会看到任何内存泄漏。</p><h1 id="3c74" class="kv ju hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">可能隐藏内存泄漏的示例</h1><p id="e4db" class="pw-post-body-paragraph jz ka hi kb b kc lm ij ke kf ln im kh ki lo kk kl km lp ko kp kq lq ks kt ku hb bi translated">有时，内存泄漏可能隐藏在代码中，与前面的例子相比不太容易识别。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="72c3" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">如果类中有很多公共成员函数，那么<code class="du lr ls lt jp b">AddNewId(int id)</code>中的<code class="du lr ls lt jp b">new</code>关键字很容易被忽略。</p><p id="eef0" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">现在用<code class="du lr ls lt jp b">HiddenBadClass</code>再次运行示例代码，您会发现内存再次泄漏。这次是因为分配了包含<code class="du lr ls lt jp b">BigMemory</code>的<code class="du lr ls lt jp b">BadClass</code>。</p><p id="69b6" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">如果我们在析构函数中使用前面的方法来<code class="du lr ls lt jp b">delete</code>，我们必须小心地删除映射中每个分配的内存</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="adb6" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">我相信你们中的一些人可能会想到RAII(资源获取是初始化)和智能指针来简化代码，并消除记住何时正确删除分配的内存的需要。你说得对，我们可以做得更好</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="e88b" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">然而，请注意，如果<code class="du lr ls lt jp b">BadClass</code>是析构函数中没有<code class="du lr ls lt jp b">delete</code>的初始版本，这个<code class="du lr ls lt jp b">StillHiddenBadClass</code>仍然会泄漏内存。</p><h1 id="9505" class="kv ju hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">我们能做什么来避免可能的内存泄漏</h1><p id="ae0b" class="pw-post-body-paragraph jz ka hi kb b kc lm ij ke kf ln im kh ki lo kk kl km lp ko kp kq lq ks kt ku hb bi translated">因此，我们能做什么来防止可能的内存泄漏呢？答案之一是让洗手液来帮你。例如，您可以在上面的示例中尝试的简单方法是在编译期间添加一个标志</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="5f34" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">运行内存泄漏的代码会导致</p><pre class="iy iz ja jb fd jo jp jq jr aw js bi"><span id="e38c" class="jt ju hi jp b fi jv jw l jx jy">ERROR: LeakSanitizer: detected memory leaks</span></pre><p id="46b9" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">但是对于<code class="du lr ls lt jp b">StillHiddenBadClass</code>，当泄漏发生在<code class="du lr ls lt jp b">BadClass</code>时，可能检测不到。因此，首先理解程序中的内存泄漏是很重要的。</p><h1 id="9e13" class="kv ju hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">泄漏的额外可能原因</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="d433" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">从上面的代码来看，不再有<code class="du lr ls lt jp b">new</code>或者<code class="du lr ls lt jp b">delete</code>，它只是一个基类和派生类。</p><p id="4039" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">然而，调用下面的代码</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="ba52" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">还是会造成memory_leak。</p><p id="8377" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">为什么会这样？</p><p id="4db2" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这是因为当派生类对象离开作用域并通过一个指向带有非虚拟析构函数<strong class="kb hj">的基类的指针被销毁时，结果是未定义的。运行时通常会发生的情况是派生类永远不会被销毁。因此，对象被部分破坏，分配给<code class="du lr ls lt jp b">DerivedClass</code>中的<code class="du lr ls lt jp b">BigMemory</code>的内存将会泄漏。</strong></p><p id="6820" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">解决方案很简单，给基类<code class="du lr ls lt jp b">virtual</code>一个析构函数。</p><pre class="iy iz ja jb fd jo jp jq jr aw js bi"><span id="447d" class="jt ju hi jp b fi jv jw l jx jy">virtual ~BaseClass() = default;</span></pre><p id="f736" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">在这种情况下，整个对象将被销毁，包括派生类中的部分</p><p id="5de1" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这也是为什么我们在有效的C++中有<em class="lw">“第7项:在多态基类</em>中声明虚析构函数”。</p><p id="4c5f" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">帖子的结尾到了，希望我已经向你“泄露”了一些关于内存泄漏的见解。</p><p id="b325" class="pw-post-body-paragraph jz ka hi kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">谢谢你的阅读！</p></div></div>    
</body>
</html>
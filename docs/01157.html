<html>
<head>
<title>C#: Interfaces to Functions, With FuncR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#:函数接口，使用FuncR</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/c-interfaces-to-functions-with-funcr-e7ea897ce39?source=collection_archive---------3-----------------------#2021-03-30">https://medium.com/geekculture/c-interfaces-to-functions-with-funcr-e7ea897ce39?source=collection_archive---------3-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="db31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现自己经常需要将某个方法提取到一个全新的服务中。这个新的服务现在有了<strong class="ih hj">的唯一目的</strong>来容纳那个方法。</p><p id="584d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当处理与<strong class="ih hj">基础设施</strong>(日志、文件、网络、API)进行通信的代码时，通常就是这种情况。这段代码大部分是静态的，不需要全新的服务实现。但是，仍然需要创建一个新的类来保持这个功能。</p><p id="9181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我开始寻找<strong class="ih hj">最简洁的形式</strong>来编写功能，<strong class="ih hj">不需要</strong>引入一个新的服务实现类，<strong class="ih hj">一个函数的接口，</strong>可以这么说…</p><p id="188e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项工作的成果已经打包到一个名为<a class="ae jd" href="https://github.com/merken/FuncR" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> FuncR </strong> </a>的小库中，请允许我详细说明…</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/f9a6b5f219167f718421eb6b43377853.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*d-kqExgdWSdwg1om"/></div></figure><p id="c04a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FuncR是一个小的。NET标准库，使您能够在C#中针对<strong class="ih hj">接口</strong>注册<strong class="ih hj">函数</strong>。</p><p id="8c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">简而言之，它让你从这个:</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jn"><img src="../Images/277a47470099e6e551b88ddf167b8368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rjxd-YLChNk0vh5TJ2uJpQ.png"/></div></div></figure><p id="4b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">变成这样:</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es js"><img src="../Images/2500e45e0a9791ad297ec0b8386f2ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLqF3yyFcuipxi3I7v9RQg.png"/></div></div></figure><p id="65a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> FuncR </strong>使用<strong class="ih hj"> DispatchProxy </strong>生成一个<strong class="ih hj">代理类</strong>，它在运行时实例化接口，并且<strong class="ih hj">将</strong>注册的<strong class="ih hj">函数</strong>挂接到<strong class="ih hj">接口方法。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jt"><img src="../Images/5f160a0f1986d48b02e951fd35b551a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5D3nlx5Iu9I2L7ArdxxxQ.png"/></div></div></figure><p id="4804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这允许你<strong class="ih hj">将接口</strong>注入到你的服务中，并像<strong class="ih hj">你的域中的任何其他服务</strong>一样使用它。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ju"><img src="../Images/3e51035387f940204d79c8d83513b2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nvdsrt4oAkAngnr0H3-FFQ.png"/></div></div></figure><p id="62ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将所有这些放在一个. NET控制台应用程序中！</p><p id="3a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建新的控制台应用程序(在中)。网络核心2、3或。净5):</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="19bf" class="ka kb hi jw b fi kc kd l ke kf">mkdir Your.First.Function<br/>cd Your.First.Function<br/>dotnet new console</span></pre><p id="250c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加FuncR包:</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="505b" class="ka kb hi jw b fi kc kd l ke kf">dotnet add package FuncR</span></pre><p id="76e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编写实现:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="4978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行实现:</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="38d1" class="ka kb hi jw b fi kc kd l ke kf">dotnet run</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ki"><img src="../Images/3c1e21c1718e2701d03c1bb39b1f791e.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*9OE5aJRciehmTNqR6jV6Qg.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">dotnet run output</figcaption></figure><h2 id="e880" class="ka kb hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">示例的详细信息</h2><p id="12f2" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><a class="ae jd" href="https://gist.github.com/merken/a3b9ba335a8b3b99e410580d3ba28e1b#file-program-cs-L8" rel="noopener ugc nofollow" target="_blank">第8行</a>为我们的服务接口搭建了舞台。</p><p id="38c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://gist.github.com/merken/a3b9ba335a8b3b99e410580d3ba28e1b#file-program-cs-L19" rel="noopener ugc nofollow" target="_blank">第19行</a>为<strong class="ih hj"> IFooService </strong>注册<strong class="ih hj">代理</strong></p><p id="eea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://gist.github.com/merken/a3b9ba335a8b3b99e410580d3ba28e1b#file-program-cs-L20" rel="noopener ugc nofollow" target="_blank">第20行</a>为代理上的名字<strong class="ih hj"> Foo </strong>注册<strong class="ih hj">函数指针</strong></p><p id="3c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://gist.github.com/merken/a3b9ba335a8b3b99e410580d3ba28e1b#file-program-cs-L22-L28" rel="noopener ugc nofollow" target="_blank">第22-28行</a>以<strong class="ih hj"> &lt; TParameter1Type，TReturnType &gt; </strong>的形式为代理注册了函数的<strong class="ih hj">实际实现</strong>，如同任何<a class="ae jd" href="https://docs.microsoft.com/en-us/dotnet/api/system.func-2?view=net-5.0" rel="noopener ugc nofollow" target="_blank"> C# Func </a></p><p id="c2db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第30行从依赖注入容器中解析我们注册的服务。</p><p id="9468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://gist.github.com/merken/a3b9ba335a8b3b99e410580d3ba28e1b#file-program-cs-L34-L36" rel="noopener ugc nofollow" target="_blank">第34行和第36行</a>调用代理，代理将查找注册的函数并调用它。</p><h1 id="a9a5" class="ll kb hi bd kn lm ln lo kr lp lq lr kv ls lt lu ky lv lw lx lb ly lz ma le mb bi translated">📚证明文件</h1><p id="8fd7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">FuncR附带了<a class="ae jd" href="https://merken.github.io/FuncR/#/" rel="noopener ugc nofollow" target="_blank">广泛的文档</a>和示例项目来帮助您开始！</p><p id="143e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这包括:<strong class="ih hj">通过依赖注入的服务解析</strong>，<strong class="ih hj">异步函数</strong>和<strong class="ih hj">嵌套函数</strong>。</p></div></div>    
</body>
</html>
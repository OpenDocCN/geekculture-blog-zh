<html>
<head>
<title>How to Solve Merging Communities Union Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决合并社区联盟问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-solve-merging-communities-union-problem-ea0e8ee96f42?source=collection_archive---------10-----------------------#2022-12-09">https://medium.com/geekculture/how-to-solve-merging-communities-union-problem-ea0e8ee96f42?source=collection_archive---------10-----------------------#2022-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="380b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不使用库解决合并联合问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/94468471d4106758c06224575da7f879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HSpjGMkdqI53psU7"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roman Synkevych 🇺🇦</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="85cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">合并是一个常见的问题。对此有许多解决方案。特别是一些高级编程语言或脚本都有现有的库可以使用。但是如何自己解决这个问题呢？</p><h2 id="c89a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题</h2><p id="9697" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">人们在社交网络中相互联系。人I和人j之间的联系被表示为Mij。当属于不同社区的两个人连接时，净效应是I和j所属的社区的合并。</p><p id="af15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一开始，有n个人代表n个社区。假设人1和2连接，然后2和3连接，那么1、2和3将属于同一个社区。</p><p id="69d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有两种类型的查询:</p><ol class=""><li id="6f10" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">Mij:如果包含人I和j的社区属于不同的社区，则它们被合并。</li><li id="eb5e" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">齐:打印我所属社区的大小。</li></ol><p id="01dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">HackerRank原问题如下:</p><div class="ly lz ez fb ma mb"><a href="https://www.hackerrank.com/challenges/merging-communities/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">合并社区| HackerRank</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">人们在社交网络中相互联系。人与人之间的联系被表示为。当两个…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.hackerrank.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jh mb"/></div></div></a></div><h2 id="e7b3" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">解决办法</h2><p id="077e" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如上所述，有多种实现方式。这里将举例说明两种解决方案。但是在Java中，合并树是最有效的方法之一。Java中没有这方面的现有数据结构。</p><p id="e310" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">版本1 :使用Java HashSet——它可以工作，并且是通用的，但是效率不高。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="1f52" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.util.*;<br/><br/><br/>public class Solution {<br/><br/>    public static void main(String[] args) {<br/>        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */<br/>        Scanner sc = new Scanner(System.in);<br/>        int n = sc.nextInt();<br/>        int q = sc.nextInt();<br/>        if (n &lt; 1 || q &lt; 1) {<br/>            sc.close();<br/>            return;<br/>        }<br/>        <br/>        /// HashMap solution<br/>        Map&lt;Integer, Set&lt;Integer&gt;&gt; hash = new HashMap&lt;&gt;();<br/>        while (q-- &gt; 0) {<br/>            String c = sc.next();<br/>            if (c.equals("M")) {<br/>                int a = sc.nextInt();<br/>                int b = sc.nextInt();  <br/>                Set&lt;Integer&gt; seta = null;<br/>                Set&lt;Integer&gt; setb = null;<br/>                if (hash.containsKey(a)) {<br/>                    seta = hash.get(a);    <br/>                }<br/>                if (hash.containsKey(b)) {<br/>                    setb = hash.get(b);    <br/>                }     <br/>                if (seta == null &amp;&amp; setb == null) {<br/>                    seta = new HashSet&lt;Integer&gt;();<br/>                    seta.add(a);<br/>                    seta.add(b);<br/>                    hash.put(a, seta);<br/>                    hash.put(b, seta);<br/>                }<br/>                else if (seta == null) {<br/>                    setb.add(a);<br/>                    hash.put(a, setb);    <br/>                }<br/>                else if (setb == null) {<br/>                    seta.add(b);<br/>                    hash.put(b, seta);<br/>                }<br/>                else {<br/>                    seta.addAll(setb);<br/>                    for (Integer i : setb) {<br/>                        hash.put(i, seta);<br/>                    }<br/>                }     <br/>            }<br/>            else if (c.equals("Q")) {<br/>                int i = sc.nextInt();<br/>                if (hash.containsKey(i)) {<br/>                    System.out.println(hash.get(i).size());<br/>                }<br/>                else {<br/>                    System.out.println(1);    <br/>                }<br/>            }<br/>        }<br/>        <br/>    }<br/>}</span></pre><p id="76c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">版本2 </strong>:针对这个问题使用树合并的方法进行了优化。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="44d7" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.util.*;<br/><br/>class Node {<br/>    int parent = -1;<br/>    int num = 1;<br/>    static int findRoot(Node [] tree, int i) {<br/>        // assume it's the root, or fix it<br/>        int root = i;<br/>        while (tree[root].parent != -1) {<br/>            root = tree[root].parent;    <br/>        }<br/>        <br/>        // flat the tree<br/>        if (root != i) {<br/>            tree[i].parent = root;<br/>            // further optimize<br/>            // int j = i;<br/>            // while (j != root) {<br/>            //     int p = tree[j].parent;<br/>            //     tree[i].parent = root;<br/>            //     j = p;<br/>            // }<br/>        }<br/>        <br/>        return root; <br/>    }<br/>}<br/><br/>public class Solution {<br/><br/>    public static void main(String[] args) {<br/>        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */<br/>        Scanner sc = new Scanner(System.in);<br/>        int n = sc.nextInt();<br/>        int q = sc.nextInt();<br/>        if (n &lt; 1 || q &lt; 1) {<br/>            sc.close();<br/>            return;<br/>        }<br/>        <br/>        // Tree solution<br/>        Node [] tree = new Node[n+1];<br/>        for (int i = 1; i &lt; tree.length; i++) {<br/>            tree[i] = new Node();<br/>        }<br/>        while (q-- &gt; 0) {<br/>            String c = sc.next();<br/>            if (c.equals("M")) {<br/>                int a = sc.nextInt();<br/>                int b = sc.nextInt();<br/>                int ra = Node.findRoot(tree, a);<br/>                int rb = Node.findRoot(tree, b);<br/>                if (ra != rb) {<br/>                    tree[ra].parent = rb;<br/>                    tree[rb].num += tree[ra].num;<br/>                }<br/>            }<br/>            else if (c.equals("Q")) {<br/>                int i = sc.nextInt();<br/>                int ri = Node.findRoot(tree, i);<br/>                System.out.println(tree[ri].num);<br/>            }<br/>        }<br/>        sc.close();<br/>        <br/>    }<br/>}</span></pre><p id="0ecd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此树合并是解决这种合并问题的有效方法。</p><p id="d585" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="d144" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="nh">问题，想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>String algorithms: What is the prefix function and how to compute it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">字符串算法:什么是前缀函数，如何计算它</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/string-algorithms-what-is-the-prefix-function-and-how-to-compute-it-7fa80035651b?source=collection_archive---------28-----------------------#2021-08-02">https://medium.com/geekculture/string-algorithms-what-is-the-prefix-function-and-how-to-compute-it-7fa80035651b?source=collection_archive---------28-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="343c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多字符串算法都使用前缀函数，包括用于字符串匹配的Knuth-Morris-Pratt算法。本文推导、实现并分析了一种在线性时间内计算给定字符串前缀函数的算法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/04d3e5235db3ed85362552323a7758f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dBusGDWD0vv3te7E"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glen Carrie</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6e24" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">符号、术语</h1><p id="fddb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我将在本文中使用以下符号和术语:</p><ul class=""><li id="1452" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">除非另有说明，大写字母表示字符串，小写字母表示字符串的长度(例如，<em class="lg"> S </em>是长度为<em class="lg"> s </em>的字符串)。</li><li id="db0f" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><em class="lg"> S </em>的索引是介于1和<em class="lg"> s </em>之间的整数。</li><li id="99f2" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><em class="lg"> TU </em>表示由<em class="lg"> T </em>和<em class="lg"> U </em>串联而成的字符串，其中<em class="lg"> T </em>和<em class="lg"> U </em>可以是字符串或字符。</li><li id="c1bb" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated">对于<em class="lg"> T </em>的所有索引<em class="lg"> i，j </em>，<em class="lg"> T </em> [ <em class="lg"> i </em> ]表示<em class="lg"> T </em>和<em class="lg"> T </em> [ <em class="lg"> i </em>的第<em class="lg"> i </em>个字符..<em class="lg"> j </em>表示字符串<em class="lg">T</em>[<em class="lg">I</em>……<em class="lg">T</em>[<em class="lg">j</em>]。</li></ul><h1 id="97ed" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">边框和前缀功能</h1><p id="5b1d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们考虑一串<em class="lg"> S </em>。然后，我们可以如下定义边界:</p><blockquote class="lm ln lo"><p id="2928" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated"><strong class="ih hj">定义:</strong></p><p id="44d1" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">S的边界是字符串B，它是S的真前缀和真后缀。</p></blockquote><p id="379d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如空字符串<em class="lg"> ε </em>是任何非空字符串的边框，但是<em class="lg"> ε </em>没有边框(因为它唯一的子串是它自己，不是<em class="lg">专有的</em>前缀或后缀)。字符串<code class="du ls lt lu lv b">baobaba</code>的最长边框是<code class="du ls lt lu lv b">ba</code>。</p><blockquote class="lm ln lo"><p id="9ab7" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated"><strong class="ih hj">定义:</strong></p><p id="532e" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">s的前缀函数是将s的索引I映射到s[1]的最长边界长度的函数𝜋..我】。</p></blockquote><p id="e8f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们考虑字符串<code class="du ls lt lu lv b">baobaba</code>，那么𝜋(1) = 𝜋(2) = 𝜋(3) = 0，𝜋(4) = 1，𝜋(5) = 2，𝜋(6) = 1，𝜋(7) = 2。</p><p id="76c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是写一个算法，它接受一个字符串并给出它的前缀函数。</p><h1 id="6f0b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">铺平我们的道路</h1><p id="85cd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">borders的第一个有趣的性质告诉我们，S的每个边界都是S的子串的最长边界。更准确地说:</p><blockquote class="lm ln lo"><p id="43f1" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated"><strong class="ih hj">属性1: </strong></p><p id="a774" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">S的第n条最长边是S的第(n-1)条最长边的最长边。</p></blockquote><p id="9bd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">证据就在这些方面:</p><blockquote class="lm ln lo"><p id="1774" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated"><strong class="ih hj">证明大纲:</strong></p><p id="65bf" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">我们可以从证明A和B是S的边开始，那么a &lt; b implies that A is a border of B. In particular, the n-th longest border of S is a border of the (n-1)-th. We now need to prove that it is the longest. Suppose that it is not: the (n-1)-th longest border of S has a border B which is strictly longer than the n-th longest border of S. Since B is a border of a border of S, it must be a border of S as well. It is strictly shorter than the (n-1)-th longest and strictly longer than the n-th longest: this is impossible.</p></blockquote><p id="f32b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">We will use this property to derive a recurrence relation to find all values of 𝜋.</p><p id="dd18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The base case is simple: the longest border of a string containing one single character is ε. Therefore, 𝜋(1) = 0.</p><p id="2d66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Suppose that <em class="lg"> S </em>的长度<em class="lg"> s </em> ≥ 2。当且仅当下列条件都满足时，<em class="lg"> B </em>为<em class="lg"> S </em>的非空边界:</p><ol class=""><li id="6556" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lw ld le lf bi translated"><em class="lg">B</em>[<em class="lg">B</em>]=<em class="lg">S</em>[<em class="lg">S</em>；</li><li id="1391" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lw ld le lf bi translated"><em class="lg">B</em>【1..<em class="lg">b</em>-1】=<em class="lg">S</em>[<em class="lg">S</em>-<em class="lg">b</em>..<em class="lg">s</em>-1】；</li><li id="bcb2" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lw ld le lf bi translated"><em class="lg">B</em>[<em class="lg">B</em>]=<em class="lg">S</em>[<em class="lg">B</em>]；</li><li id="6284" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lw ld le lf bi translated"><em class="lg">B</em>【1..<em class="lg"> b </em> - 1] = <em class="lg"> S </em> [1..<em class="lg">b</em>-1】；</li><li id="47bd" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lw ld le lf bi translated"><em class="lg"> b </em> ≤ <em class="lg"> s </em> - 1 <em class="lg">。</em></li></ol><p id="d0f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们刚刚重新表述了定义，将边界的最后一个符号与其余符号分开。报表1。第二。相当于说<em class="lg"> B </em>是<em class="lg"> S </em>的后缀，语句3。第四。相当于说<em class="lg"> B </em>是<em class="lg"> S </em>和语句5的前缀。暗示<em class="lg"> B </em>是<em class="lg">S</em>的前缀/后缀。这使得能够找到S的边界和<em class="lg">S</em>【1】的边界之间的关系..<em class="lg"> s </em> - 1]:</p><blockquote class="lm ln lo"><p id="1842" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">B是S的非空边界当且仅当:B[1..b - 1]是S[1]的边界..s - 1]和B[b] = S[b] = S[s]。</p></blockquote><p id="6db3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<em class="lg"> S </em>的任何边框都是通过将<em class="lg"> S </em> [ <em class="lg"> s </em> ]附加到<em class="lg">S</em>【1】的边框上而构建的..<em class="lg"> s </em> - 1】，前提是<em class="lg">S</em>[<em class="lg">S</em>]=<em class="lg">S</em>[<em class="lg">b</em>。因此:</p><blockquote class="lm ln lo"><p id="f7f8" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated"><strong class="ih hj">属性二:</strong></p><p id="04d5" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">当且仅当:S[1..s - 1]的边界长度为b - 1，S[b] = S[s]。</p></blockquote><h1 id="101d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">编写解决方案</h1><p id="2a6f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">因此，我们可以建立以下非正式算法:</p><blockquote class="lm ln lo"><p id="dcad" class="if ig lg ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">为了找到𝜋(i)，迭代s[1]的所有边界长度b..i - 1]按降序排列。第一次S[b + 1] = S[i]，我们设𝜋(i) = b + 1。如果它从未发生，𝜋(i = 0。</p></blockquote><p id="eda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们从最长的边界<em class="lg">S</em>【1】开始..<em class="lg"> i </em> -1】，长度𝜋( <em class="lg"> i </em> -1)。如果s[𝜋(<em class="lg">I</em>-1)+1]=<em class="lg">s</em>[<em class="lg">I</em>]，我们可以设𝜋(i) = 𝜋( <em class="lg"> i </em> -1) + 1。否则，我们需要找到S[1]的第二长边界的长度..<em class="lg">我</em> -1】。<strong class="ih hj"> <em class="lg">性质1 </em> </strong>告诉我们是𝜋(𝜋(i - 1)给定的:s的第二长边是<em class="lg"> S的最长边</em>的最长边。所以我们需要检查S[1..𝜋(𝜋(<em class="lg">I</em>-1))+1]=<em class="lg">s</em>[<em class="lg">I</em>]，这种情况下我们设𝜋(i) = 𝜋(𝜋(i - 1)) + 1。我们不断重复，直到找到最长的边界——如果我们永远找不到，我们设置𝜋(i = 0。</p><p id="3066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这用伪代码给出了下面的算法(数组和字符串索引从1开始):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/a5adef80414721bd0d461d6f6e3d5613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmaLvGNwLKthYihpirnUaw.png"/></div></div></figure><p id="661f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先初始化一个对应于前缀函数的数组(第4行)，并将其第一个值设置为0(这是基本情况)。</p><p id="2884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">while循环(第10行)以降序遍历S的所有边界长度。我们确保<code class="du ls lt lu lv b">borderLength</code>保持正面(𝜋(0不会有任何意义)。如果字符串的第(<code class="du ls lt lu lv b">borderLength</code> + 1)个字符等于第<em class="lg"> i </em>个字符，那么我们就找到了我们最长的边界(它的长度为<code class="du ls lt lu lv b">borderLength</code> + 1)。</p><p id="1f86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果条件线13被满足，那么我们已经找到S[1]的最长边界的长度..<em class="lg"> i </em>并相应设置<code class="du ls lt lu lv b">borderLength</code>的值。否则，<code class="du ls lt lu lv b">borderLength</code>为零，这对应于S[1]的最大边界长度..我】。</p><p id="5463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以定义𝜋( <em class="lg"> i </em>并继续前进。</p><h1 id="1252" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">分析</h1><p id="84ba" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">正如承诺的那样，算法根据字符串的长度在θ(<em class="lg">s</em>)时间内运行。这并不明显，特别是因为while循环。</p><p id="ef30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">决定while循环迭代次数的唯一变量是<code class="du ls lt lu lv b">borderLength</code>。它被初始化为0，可以增加(第14行)或减少(第11行)。</p><p id="1173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<code class="du ls lt lu lv b">borderLength</code>总是非负的，所以它的减少不能超过它的增加。它增加不超过<em class="lg">s</em>-1(for循环每次迭代一次)，这证明while循环在整个程序执行过程中运行不超过<em class="lg"> s </em> - 1次。</p><p id="f698" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于for循环恰好运行<em class="lg"> s </em> - 1次，所以<code class="du ls lt lu lv b">compute-𝜋</code>的总复杂度为θ(<em class="lg">s</em>)。</p></div></div>    
</body>
</html>
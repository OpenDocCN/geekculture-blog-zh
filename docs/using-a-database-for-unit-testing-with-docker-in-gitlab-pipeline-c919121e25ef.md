# 在 GitLab 管道中使用 Docker 对数据库进行单元测试

> 原文：<https://medium.com/geekculture/using-a-database-for-unit-testing-with-docker-in-gitlab-pipeline-c919121e25ef?source=collection_archive---------18----------------------->

![](img/e81f5e8231d1c5c168def5edf8862db5.png)

Photo by [Dominik Lückmann](https://unsplash.com/@exdigy?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

最近我有机会使用 GitLab 为各种微服务构建 CI 管道。当到了运行单元测试的时候，问题就来了，因为一些项目没有使用 mocker，而是想要连接到一个测试数据库。谢天谢地，我们有办法生成一个临时数据库用于测试。

在这个场景中，我将使用 git lab dind Docker-In-Docker(dind)来构建、测试和部署映像。

让我们从一个例子`Dockerfile`开始，为此我将假设我们使用一个简单的 NodeJs 项目

```
FROM node:14-alpine AS node# Builder stage
FROM node AS builderENV APP_PORT 8080WORKDIR /appCOPY . .# Copy .env configuration
COPY .env.test ./.env# Install dependencies
RUN npm ci# Port public untuk akses
EXPOSE 8080# Run development server
CMD [ "npm", "run", "dev" ]
```

注意，我使用的是 **CMD** 而不是**入口点**。这是因为它将允许我在旋转容器时覆盖启动命令。

我推荐使用**入口点**作为生产就绪的映像。

现在对于`.gitlab-ci.yaml`，我们将只做一个基本的构建和测试步骤

```
image: docker:latest
services:
  - name: docker:dindstages:
  - build
  - test
  - deployvariables:
  DOCKER_DRIVER: overlay2
  # See [https://github.com/docker-library/docker/pull/166](https://github.com/docker-library/docker/pull/166)
  DOCKER_TLS_CERTDIR: "" # Autogenerated for tags
  TAG_LATEST: $CI_REGISTRY_IMAGE:latest
  TAG_COMMIT: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA # This should be set from within gitlab
  CI_REGISTRY: <regsitry_endpoint>
  CI_REGISTRY_USER: <registry_username>
  CI_REGISTRY_PASSWORD: <registry_password># We build the image and push it to our registry
build:
  stage: build
  script:
    - docker build --pull -t $TAG_COMMIT .
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"   "$CI_REGISTRY"
    - docker push $TAG_COMMIT# We pull the image again and running the docker by overwriting the command
test:
  stage: test
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker pull $TAG_COMMIT
    - docker run $TAG_COMMIT_DEV sh -c "npm run test"# We re-tag it for latest when its successful
deploy:
  stage: deploy
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker pull $TAG_COMMIT
    - docker tag $TAG_COMMIT_DEV $TAG_LATEST_DEV
    - docker push $TAG_LATEST_DEV
```

我们将利用 docker 网络映射，自动将服务绑定到其环境。因此，如果你有一个不同的数据库或服务，它应该可以通过 <name>_PORT_ <port>_ADDR 访问，它会返回给你它自动生成的 IP 地址。</port></name>

现在让我们看看 Postgres 是什么样子的

```
image: docker:latest
services:
  - name: docker:dind
  - name: postgres:12.2-alpine...variables:
  POSTGRES_DB: sample_db
  POSTGRES_USER: admin
  POSTGRES_PASSWORD: password
  POSTGRES_HOST_AUTH_METHOD: trust
  ......test:
  stage: test
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker pull $TAG_COMMIT 
    #we capture the IP address
    - env | grep POSTGRES_PORT_5432_TCP_ADDR
    # Now we overwrite the Image environment
    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="postgres://admin:password@${POSTGRES_PORT_5432_TCP_ADDR}:5432/sample_db" npm run test"...
```

和 MongoDB

```
image: docker:latest
services:
  - name: docker:dind
  - name: mongo:latest...variables:
  MONGO_INITDB_ROOT_USERNAME: admin
  MONGO_INITDB_ROOT_PASSWORD: password
  MONGO_INITDB_DATABASE: sample_db
  ...test:
  stage: test
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker pull $TAG_COMMIT 
    #we capture the IP address
    - env | grep POSTGRES_PORT_5432_TCP_ADDR
    # Now we overwrite the Image environment
    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="admin:password@${MONGO_PORT_27017_TCP_ADDR}" npm run test"...
```

最后是 Redis

```
image: docker:latest
services:
  - name: docker:dind
  - name: redis:latest...test:
  stage: test
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker pull $TAG_COMMIT 
    #we capture the IP address
    - env | grep REDIS_PORT_6379_TCP_ADDR
    # Now we overwrite the Image environment
    - docker run $TAG_COMMIT_DEV sh -c "DATABASE_URL="admin:password@${REDIS_PORT_6379_TCP_ADDR}" npm run test"...
```

希望这有所帮助！

祝你建立管道好运。
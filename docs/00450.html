<html>
<head>
<title>Learning JavaScript By Roughly Cloning Coolors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过粗略克隆酷派来学习JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/learning-javascript-by-roughly-cloning-coolors-20115cab8a8e?source=collection_archive---------6-----------------------#2021-02-10">https://medium.com/geekculture/learning-javascript-by-roughly-cloning-coolors-20115cab8a8e?source=collection_archive---------6-----------------------#2021-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="6737" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直到最近，我才具备了非常基础的JavaScript知识，我已经以令人满意的速度和内存使用解决了一些leetcode问题，我可以在DOM元素上设置事件监听器来做一些基本的事情，我甚至尝试过向API发出请求。尽管如此，我还是感觉不到使用python或ruby时的自信。在过去的几周里，我埋头于JavaScript的研究，并真正对这种语言的工作原理有了更好的理解。为了激发我对几个概念的理解，我制作了一个我喜欢的应用程序Coolors的基本仿制品。这是一个允许你通过按空格键生成我称之为“监督随机”调色板的应用程序。</p><p id="4e52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于这个应用程序的整体结构，我使用了rails JSON API和一个普通的JavaScript/html/CSS前端。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="95fe" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">后端</h1><p id="461d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">对于应用程序的后端，我用rails创建了一个简单的JSON API，我想做的就是:</p><ol class=""><li id="0d3a" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">要求指定数量的随机选择的颜色。</li><li id="b998" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">将新的调色板(带有标题列的HABTM颜色模型)保存到数据库中。</li><li id="bcb8" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">请求数据库中所有调色板的信息。</li></ol><p id="bba9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用API标志用rails创建一个API非常简单，如下所示</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="893f" class="lk jl hi lg b fi ll lm l ln lo">rails new PROJECT_NAME --api</span></pre><p id="2132" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用api标志rails将自动省略通常包含在常规rails应用程序中的多余中间件，使应用程序控制器从ActionController::API继承而不是基本省略浏览器使用的任何ActionController功能，并告诉生成器跳过视图。生成资源时的助手和资产。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="a706" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">模型</h1><p id="49bd" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我的API有两个模型:颜色和调色板。这两个模型通过has _ and _ owners _ to _ many关系相关联，事后看来，这对于我最终使用的功能来说是不必要的，但是当我刚刚开始这个项目时，我计划拥有一个“最流行的颜色”功能，并且通过颜色可以访问调色板会使这很容易做到。</p><p id="a5dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">颜色:</strong></p><p id="d0fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">颜色模型具有用于存储值的列，这些值允许颜色被格式化为几种格式:“名称”、十六进制、RGB、HSL、HSV。</p><p id="5471" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">调色板:</strong></p><p id="1a5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了时间戳之外，调色板模型只有一列，即名称。</p><h1 id="cecf" class="jk jl hi bd jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh bi translated">关于源数据的说明:</h1><p id="191b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">为了给数据库播种，我写了一个网页抓取器，从维基百科<a class="ae lu" href="https://en.wikipedia.org/wiki/List_of_colors" rel="noopener ugc nofollow" target="_blank">页面</a>中抓取971种颜色</p><p id="8707" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">scraper搜索所有三个页面(A-F、G-M、N-Z ),并返回一个散列数组，其中包含表中每种颜色的值。</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lv"><img src="../Images/3ca8251c79e898702622687be3e8c226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*421FP3UWWtj35_oSd2HF3w.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Wikipedia list of colors</figcaption></figure><p id="ab3e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用该数组，数据库中会填充颜色记录。在颜色被记录到数据库之后，调色板类方法被用来创建5个随机选择的颜色的25个调色板。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2157" class="lk jl hi lg b fi ll lm l ln lo">def self.newRandom()<br/>   palette = Palette.new(name: "palette-#{("a".."z").to_a.concat((0..9).to_a).shuffle.slice(0,4).join("")}")<br/>   palette.colors.concat(Color.all.sample(5))<br/>   palette.save()<br/>   return palette<br/>end</span></pre><p id="7b5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这为乱搞和使用app提供了充足的数据。</p><h1 id="98af" class="jk jl hi bd jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh bi translated">端点</h1><p id="bb1a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">因为应用程序只有3个端点，所以我在routes.rb中显式声明了它们</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7b7d" class="lk jl hi lg b fi ll lm l ln lo">Rails.application.routes.draw do<br/>  get '/api/colors', to: 'colors#index'<br/>  get '/api/palettes', to: 'palettes#index'<br/>  post '/api/palettes', to: 'palettes#create'<br/>end</span></pre><ol class=""><li id="df24" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">Get /api/colors:第一条路径由colors控制器的index操作处理。向/api/colors发送GET请求将返回JSON格式的所有颜色，或者使用“count”查询字符串，返回JSON格式的指定数量的随机选择的颜色，这用于在用户打开调色板创建页面时填充新的调色板，以及在调色板创建期间更改未锁定的颜色。</li><li id="8166" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">Get /api/palettes:第二条路线由palettes控制器的index操作处理。此操作以JSON格式返回数据库中的所有调色板，或者接受类似colors route的“count”查询字符串，以返回指定数量的最近创建的调色板。这在调色板视图页面上使用，并呈现调色板创建界面下的三个小调色板。</li><li id="f2f7" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">Post /api/palettes:最终的路径由palettes控制器的create操作处理，当用户保存调色板名称时，使用JavaScript将所选颜色的id发送到api。在create动作中，使用一个实例方法从JSON数据创建一个调色板。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="4355" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">克-奥二氏分级量表</h1><p id="a352" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">关于CORS或跨源资源共享的补充说明。简而言之，CORS是浏览器确定允许客户端请求资源是否安全的一种方式。开箱即用的JavaScript前端将被阻止向API发出请求。要启用CORS，您可以将“rack-cors”添加到Gemfile并运行bundle install，您还必须告诉rails应用程序使用application.rb文件中的rack-cors中间件<a class="ae lu" href="https://github.com/cyu/rack-cors" rel="noopener ugc nofollow" target="_blank">有关更多信息，请参考文档</a>。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="9713" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">前端</h1><p id="7bcc" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">有了API，剩下的就是用JavaScript来消费它了。</p><h1 id="5cdf" class="jk jl hi bd jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh bi translated">责任</h1><p id="b107" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">通过写出我希望前端做的所有事情，我能够将所有功能分成4个独立的块(不包括主例程)</p><ol class=""><li id="0475" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated"><strong class="io hj">调色板:</strong>调色板类处理如下任务:实例化和管理调色板中的颜色，将未锁定的颜色更改为新的随机颜色，在保存调色板时创建散列以发送到api，添加新颜色，将加号按钮添加到调色板中的最后一种颜色。</li><li id="2f91" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated"><strong class="io hj">Color:</strong>Color类处理如下任务:访问颜色的DOM元素，当颜色更新时改变DOM元素的背景，当颜色的锁定状态改变时切换锁图标，更新DOM元素的数据属性。</li><li id="b7c5" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">API:API对象是处理与API通信的函数的散列:获取n种颜色，获取n个调色板，并在保存调色板时将调色板散列发送给API</li><li id="8069" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated"><strong class="io hj">Render:</strong>Render对象也是函数的散列，这次处理DOM元素的创建:创建显示在主调色板创建界面下面的迷你调色板，一个助手接受一个标签和一个可选的类名数组，返回一个指定标签的DOM元素和提供的类名(如果有的话)。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="3b51" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">主程序</h1><p id="9f80" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">全部JavaScript功能都是在事件侦听器触发器中由DOMContentLoaded事件执行的，这意味着JavaScript会等到整个页面加载到浏览器中后才开始执行，这可以防止程序在加载静态DOM元素之前尝试访问它们。</p><p id="94bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">流量</strong></p><ol class=""><li id="6d29" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">首先实例化一个新的palette对象，并将保存迷你palette元素的容器div保存到一个变量中，以便于访问。</li><li id="50ca" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">接下来，对palette对象调用initColors()方法，该方法使用api.getColor()从api获取4种颜色，并将一个新的颜色实例推送到Palette实例的Colors数组中。</li><li id="0b1e" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">palette.initColors()调用是"。然后与renderColors() palette方法进行“d ”,该方法清除DOM调色板的颜色行，然后将每个调色板实例的颜色元素追加到DOM调色板的颜色行。</li><li id="a732" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">一个事件侦听器被添加到save button DOM元素中，该元素调用调色板上的savePalette方法。该方法检查是否使用了自定义名称，否则它使用浏览器警告来指示用户这样做，然后它向API发送调色板名称和调色板颜色id的字典。当请求完成时，该方法调用render方法，该方法刷新页面底部的小调色板以显示最近保存的调色板。</li><li id="22b2" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">一个事件监听器被添加到文档主体中，该事件监听器通过按下键盘键来触发，如果该键是空格键，并且当前聚焦的元素不是调色板名称输入，则调用palette.shuffle()方法。shuffle方法遍历调色板的颜色，如果颜色被解锁，则调用updateColor()方法，并使用api.getColor()方法提供新的颜色哈希</li><li id="17cc" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">最后，调用render.palettes()方法在调色板创建界面下呈现最近保存的3个调色板。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="a0b7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用</h1><p id="6271" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">当客户端在浏览器中打开时，用户会看到调色板界面，三个最近创建的调色板和一个查看数据库中每个调色板的链接。</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mh"><img src="../Images/186fdf243abbd8231ea49e79f07ff24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hASzyHEXJURzxHa47tpTeg.png"/></div></div></figure><p id="9007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">按空格键将更改所有未锁定列的颜色，按下锁图标将锁定该列，以保留调色板中所需的颜色。</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mi"><img src="../Images/218507657b41b716d0235d40ca3d978f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PfQv-NBzC-SnsHXJ9hlmA.png"/></div></div></figure><p id="e169" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">按加号图标将向调色板添加另一种颜色。</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mj"><img src="../Images/c48f48179387e64173ff6778ee5c08d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cjkqT3xGSrfTul2EdfO0A.png"/></div></div></figure><p id="5676" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要保存调色板，必须更改标题。按照“查看更多”链接查看数据库中的所有调色板</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mk"><img src="../Images/a401bc9f33ea59f5f5d7b546d7e3f6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TyJQ8XDSpkJeZ9kbxTOxKw.png"/></div></div></figure><p id="6785" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">单击调色板以查看调色板的十六进制和RGB值</p><figure class="lb lc ld le fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es ml"><img src="../Images/bdf64d11cfc29551b292bf9356626a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyEnWqffR0p49ivvGhS-bQ.png"/></div></div></figure><h1 id="ce4b" class="jk jl hi bd jm jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh bi translated">笔记</h1><p id="3497" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我最初让我所有的API方法接受回调，但是很快就陷入了<a class="ae lu" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>，所以我切换到使用async/await，这极大地提高了我代码的可读性。</p><p id="a347" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你喜欢我的写作，请随时查看我的<a class="ae lu" href="https://svrourke.com/" rel="noopener ugc nofollow" target="_blank">网站</a>，并通过<a class="ae lu" href="https://www.linkedin.com/in/samuel-v-rourke/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系</p></div></div>    
</body>
</html>
<html>
<head>
<title>Demystifying HTTP Handlers in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘Golang中的HTTP处理程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/demystifying-http-handlers-in-golang-a363e4222756?source=collection_archive---------1-----------------------#2021-07-29">https://medium.com/geekculture/demystifying-http-handlers-in-golang-a363e4222756?source=collection_archive---------1-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9caff42a69e770c65c0c861a13097574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RZU7fFE4BbyEFBzX"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@techntravel_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathieu Olivares</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c4a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我开始学习Golang，并使用GoLang本身提供的核心包构建HTTP服务。也就是说，我玩了一下<a class="ae iu" href="https://pkg.go.dev/net/http" rel="noopener ugc nofollow" target="_blank"> net/http </a>包，以及它如何让开发人员轻松地建立快速http服务。</p><p id="2150" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">net/http包使用<a class="ae iu" href="https://pkg.go.dev/net/http#Handler" rel="noopener ugc nofollow" target="_blank">处理程序</a>来处理发送到特定路径的http请求。当深入研究这个包时，我注意到包中定义了各种方法和类型，对于希望使用这个包来构建HTTP服务的初学者来说，这在开始时可能会有些混乱。本文的目的是对Golang中的处理程序结构有一个简单的了解。</p><p id="5083" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最重要的是，有处理程序接口。处理程序接口是一个带有单一方法ServeHTTP的接口，它采用HTTP。响应和一个http。请求作为输入。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7dcc" class="kc kd hi jy b fi ke kf l kg kh">type Handler interface {<br/>	ServeHTTP(<a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>)<br/>}</span></pre><p id="d93d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个方法可以说是“响应”给定http请求的核心方法。我们可以在自己的HandlerClass中实现这个接口，并给出自己的ServeHTTP实现。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b436" class="kc kd hi jy b fi ke kf l kg kh">type helloWorldhandler struct</span><span id="a062" class="kc kd hi jy b fi ki kf l kg kh">func (h helloWorldHandler) ServeHTTP(w <a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, r *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>){</span><span id="55b4" class="kc kd hi jy b fi ki kf l kg kh">     fmt.Fprintf(w,"HeloWorld")</span><span id="3887" class="kc kd hi jy b fi ki kf l kg kh">}</span></pre><p id="dff0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要将给定的处理程序映射到某个路径，我们可以使用<code class="du kj kk kl jy b">http.Handle()</code>方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5260" class="kc kd hi jy b fi ke kf l kg kh">func Handle(pattern <a class="ae iu" href="https://pkg.go.dev/builtin#string" rel="noopener ugc nofollow" target="_blank">string</a>, handler <a class="ae iu" href="https://pkg.go.dev/net/http#Handler" rel="noopener ugc nofollow" target="_blank">Handler</a>)</span></pre><p id="5a85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">调用这个函数时，Go将给定的处理程序注册到给定的路径，并在请求到达该路径时调用处理程序的ServeHTTP方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7b56" class="kc kd hi jy b fi ke kf l kg kh">http.Handle("/helloWorld",helloWorldHandler)</span></pre><p id="d661" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本例中，当HTTP请求命中“/helloWorld”路径时，将调用helloWorldHandler的ServeHTTP方法。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="ca5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述处理HTTP方法的一个缺点可以说是，如果我们想要处理来自不同路径的大量HTTP请求，我们需要为实现处理程序接口的每个单独的处理程序创建处理程序类型。为此，net/http包提供了一个特殊的函数<code class="du kj kk kl jy b">HandleFunc</code>。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="28ee" class="kc kd hi jy b fi ke kf l kg kh">func HandleFunc(pattern <a class="ae iu" href="https://pkg.go.dev/builtin#string" rel="noopener ugc nofollow" target="_blank">string</a>, handler func(<a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>))</span></pre><p id="9e76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl jy b">HandleFunc</code>的职责与<code class="du kj kk kl jy b">http.Handle(w,r)</code>相同，都是向一个处理程序注册一个给定的路径，但是它以不同的方式完成。如果你看一下上面方法的签名，你会发现它将一个函数作为<code class="du kj kk kl jy b">HandleFunc()</code>的第二个参数，而不是像<code class="du kj kk kl jy b">http.Handle()</code>中的处理程序类型。</p><p id="7457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在这种情况下我们可以给http。HandleFunc()任何具有签名<code class="du kj kk kl jy b">func(<a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>)</code>的函数，它将使用该函数来处理命中给定路径的请求。因此，这里不需要为每条路径创建处理程序类型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ad18" class="kc kd hi jy b fi ke kf l kg kh">myHelloWorldFunc := func (w <a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, r *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>) <br/>{fmt.Fprintf(w,"HeloWorld Function")}</span><span id="cbee" class="kc kd hi jy b fi ki kf l kg kh">http.HandleFunc("/helloWorld", myHelloWorldFunc)</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="8f7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后是类型<a class="ae iu" href="https://pkg.go.dev/net/http#HandlerFunc" rel="noopener ugc nofollow" target="_blank"> HandlerFunc </a>。这可以说是一个适配器，它允许我们像http一样使用普通的功能。汉德勒。</p><p id="f01c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你看看这个类型的定义，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="65fb" class="kc kd hi jy b fi ke kf l kg kh">type HandlerFunc func(<a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>)</span></pre><p id="07c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以看到HandlerFunc是一个具有类型<code class="du kj kk kl jy b">func(<a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>)</code>的类型。HandlerFunc类型本身实现ServeHTTP函数，如下所示。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3750" class="kc kd hi jy b fi ke kf l kg kh">type <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;bpv=1;bpt=1;l=2045?gsn=HandlerFunc&amp;gs=kythe%3A%2F%2Fgolang.org%3Flang%3Dgo%3Fpath%3Dnet%2Fhttp%23type%2520HandlerFunc" rel="noopener ugc nofollow" target="_blank">HandlerFunc</a> func(<a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;drc=refs%2Ftags%2Fgo1.16.6;l=95" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, *<a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/request.go;drc=refs%2Ftags%2Fgo1.16.6;l=103" rel="noopener ugc nofollow" target="_blank">Request</a>)</span><span id="d811" class="kc kd hi jy b fi ki kf l kg kh">func (<a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;bpv=1;bpt=1;l=2048?gsn=f&amp;gs=kythe%3A%2F%2Fgolang.org%3Flang%3Dgo%3Fpath%3Dnet%2Fhttp%23param%2520HandlerFunc.ServeHTTP%253Af" rel="noopener ugc nofollow" target="_blank">f</a> <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;drc=refs%2Ftags%2Fgo1.16.6;l=2042" rel="noopener ugc nofollow" target="_blank">HandlerFunc</a>) <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;bpv=1;bpt=1;l=2048?gsn=ServeHTTP&amp;gs=kythe%3A%2F%2Fgolang.org%3Flang%3Dgo%3Fpath%3Dnet%2Fhttp%23method%2520HandlerFunc.ServeHTTP" rel="noopener ugc nofollow" target="_blank">ServeHTTP</a>(<a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;bpv=1;bpt=1;l=2048?gsn=w&amp;gs=kythe%3A%2F%2Fgolang.org%3Flang%3Dgo%3Fpath%3Dnet%2Fhttp%23param%2520HandlerFunc.ServeHTTP%253Aw" rel="noopener ugc nofollow" target="_blank">w</a> <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;drc=refs%2Ftags%2Fgo1.16.6;l=95" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, <a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/server.go;bpv=1;bpt=1;l=2048?gsn=r&amp;gs=kythe%3A%2F%2Fgolang.org%3Flang%3Dgo%3Fpath%3Dnet%2Fhttp%23param%2520HandlerFunc.ServeHTTP%253Ar" rel="noopener ugc nofollow" target="_blank">r</a> *<a class="ae iu" href="https://cs.opensource.google/go/go/+/refs/tags/go1.16.6:src/net/http/request.go;drc=refs%2Ftags%2Fgo1.16.6;l=103" rel="noopener ugc nofollow" target="_blank">Request</a>) {</span><span id="8090" class="kc kd hi jy b fi ki kf l kg kh">   f(w,r)</span><span id="54de" class="kc kd hi jy b fi ki kf l kg kh">}</span></pre><p id="2e20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们可以说HandlerFunc函数本身实现了http。处理程序接口。如上所示，如果我们查看ServeHTTP方法的实现，我们可以看到，它所做的只是调用HandlerFunc所基于的主函数。如果我们看一个例子，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7386" class="kc kd hi jy b fi ke kf l kg kh">myHelloWorldFunc2 := func (w <a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, r *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>) <br/>{fmt.Fprintf(w,"HeloWorld Function")}</span><span id="5511" class="kc kd hi jy b fi ki kf l kg kh">handlerFromHelloFunc := http.HandlerFunc(myHelloWorldFunc2)</span><span id="463b" class="kc kd hi jy b fi ki kf l kg kh">http.Handle("/helloWorld", handlerFromHelloFunc)</span></pre><p id="4921" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在上面的例子中我们可以看到，函数myHelloWorldFunc2被<code class="du kj kk kl jy b">http.HandlerFunc()</code>转换为<code class="du kj kk kl jy b">http.Handler</code>类型，然后在<code class="du kj kk kl jy b">http.Handle</code>方法中作为普通的处理程序使用。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="fbc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇简短的文章到此结束，文章的目的是让读者对使用core net/http包处理HTTP请求的各种实现有一点了解。作为总结，我们讨论了处理HTTP请求的给定路径的3种主要方法。</p><ol class=""><li id="7d64" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">创建一个处理程序类型，实现ServeHTTP方法并使用<code class="du kj kk kl jy b">http.Handle(path, Handler)</code>注册它。</li><li id="4ba6" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">用签名<code class="du kj kk kl jy b"> func (w <a class="ae iu" href="https://pkg.go.dev/net/http#ResponseWriter" rel="noopener ugc nofollow" target="_blank">ResponseWriter</a>, r *<a class="ae iu" href="https://pkg.go.dev/net/http#Request" rel="noopener ugc nofollow" target="_blank">Request</a>)</code>创建一个函数并使用<code class="du kj kk kl jy b">http.HandleFunc(path, function)</code>注册它</li><li id="cdb6" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">使用<code class="du kj kk kl jy b">http.HandlerFunc</code>支持类型创建一个函数并将其转换为处理程序，并在<code class="du kj kk kl jy b">http.Handle(path, handler)</code>方法中使用它来注册它。</li></ol><p id="8c40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您读到本文的这一部分，我希望您已经对Golang中不同的HTTP处理程序有了更多的了解。如果您有任何问题或更正，请随时评论。</p><p id="01e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关注更多关于API、微服务、Java和Golang的内容:)</p><div class="lh li ez fb lj lk"><a href="https://www.linkedin.com/in/rashmin95/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">Ravindu Rashmin -软件工程师- WSO2 | LinkedIn</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">在世界上最大的职业社区LinkedIn上查看Ravindu Rashmin的个人资料。Ravindu列出了7个工作…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.linkedin.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly io lk"/></div></div></a></div><div class="lh li ez fb lj lk"><a href="https://github.com/rashm1n" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">rashm1n -概述</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">喜欢java，音乐和足球块或报告一个基本的Java项目创建一个AWS Lambda函数Java后端…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">github.com</p></div></div><div class="lt l"><div class="lz l lv lw lx lt ly io lk"/></div></div></a></div></div></div>    
</body>
</html>
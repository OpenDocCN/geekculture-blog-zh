<html>
<head>
<title>Leveling Up Your JavaScript (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升您的JavaScript水平(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leveling-up-your-javascript-part-1-es6-edition-13447e30980?source=collection_archive---------4-----------------------#2021-10-10">https://medium.com/geekculture/leveling-up-your-javascript-part-1-es6-edition-13447e30980?source=collection_archive---------4-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/055a6cac0e3f687cd3215e6ea4db1e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kAQazkEpTN43dkzNbjBWg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">image from <a class="ae hv" href="https://wallpaperbat.com" rel="noopener ugc nofollow" target="_blank">wallpaperbat.com</a></figcaption></figure><div class=""/><p id="4cca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继我的上一篇文章<a class="ae hv" rel="noopener" href="/geekculture/writing-clean-javascript-es6-edition-834e83abc746">编写干净的JavaScript </a>之后，我决定更进一步，讨论在我的职业生涯中证明有用的相当高级的<strong class="ix hz"> JavaScript </strong>概念。</p><p id="dab5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将要讨论的概念是这门语言的基础，不管你使用什么样的框架，这些概念都会存在。此外，当您决定学习或使用流行的JavaScript库或框架时，很好地掌握这些概念将是非常宝贵的。</p><p id="419d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是由两部分组成的系列文章的第一部分，在这个系列文章中，我介绍了提高JavaScript技能应该掌握的几个重要概念。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="28e2" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.“这”是什么？</h1><p id="a1df" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果你已经有了一些使用其他语言的经验，比如C++或者Java，你可能已经处理过关键字<code class="du ld le lf lg b">this</code>，或者Python的<code class="du ld le lf lg b">self</code>。对于这些语言，<code class="du ld le lf lg b">this</code>指的是在一个类的方法中被调用时当前对象的实例。</p><p id="a10b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，JavaScript使用<code class="du ld le lf lg b">this</code>的方式有所不同:<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">this</a></code>关键字可以在函数或方法的上下文之外使用——即在全局上下文中，根据使用的模式，它会有不同的行为。</p><h2 id="8f8a" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">全球背景</h2><p id="8270" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">全局上下文只是定义为浏览器中的<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/API/Window" rel="noopener ugc nofollow" target="_blank">window</a></code>对象或节点JS中的<code class="du ld le lf lg b"><a class="ae hv" href="https://nodejs.org/api/globals.html#globals_global" rel="noopener ugc nofollow" target="_blank">global</a></code>对象的<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object" rel="noopener ugc nofollow" target="_blank">全局对象</a>。不管使用“严格”还是“非严格”模式，<code class="du ld le lf lg b">this</code>在全局上下文中的行为总是相同的。</p><p id="3d1e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，以下内容在任何浏览器中都有效:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="9e26" class="lh kb hy lg b fi md me l mf mg">console.log(this === window) // true</span><span id="cefc" class="lh kb hy lg b fi mh me l mf mg">this.foo = "This is a global variable"<br/>console.log(window.foo) // This is a global variable</span></pre><h2 id="5fcd" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">功能上下文</h2><p id="2e8c" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在函数内部，<code class="du ld le lf lg b">this</code>的行为由调用函数的方式和使用的模式决定。</p><p id="c3e1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在JavaScript中，可以用4种不同的方式调用函数。在下面的例子中，我将展示<code class="du ld le lf lg b">this</code>在每种情况下的表现:</p><p id="97ae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">一、简单的函数调用</strong></p><p id="02cc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在“非严格”模式下，调用函数时，<code class="du ld le lf lg b">this</code>会引用全局对象。然而，在“严格”模式下<code class="du ld le lf lg b">this</code>将被设置为<code class="du ld le lf lg b">undefined.</code></p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="f461" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">二。方法调用</strong></p><p id="ce47" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一个对象的方法内部，<code class="du ld le lf lg b">this</code>将简单地引用包含它的对象:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="5d13" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果我们将<code class="du ld le lf lg b">getCountry</code>存储在另一个变量中会怎么样呢？</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="65ca" class="lh kb hy lg b fi md me l mf mg">const getCountry = address.getCountry;</span></pre><p id="ff98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设代码在使用“非严格”模式的浏览器中执行，<code class="du ld le lf lg b">this</code>将退回到<code class="du ld le lf lg b">window</code>。因此，<code class="du ld le lf lg b">getCountry()</code>将计算为<code class="du ld le lf lg b">window.country</code>，因为在这种情况下没有指定父对象:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="09a4" class="lh kb hy lg b fi md me l mf mg">console.log(getCountry()); // undefined</span></pre><p id="a164" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们为什么要用<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">Function.prototype.bind</a></code>的原因。<code class="du ld le lf lg b">bind</code>方法，顾名思义，将<em class="mk">绑定</em>一个新的对象到指定的函数，公开对象的<code class="du ld le lf lg b">this</code>。</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="8594" class="lh kb hy lg b fi md me l mf mg">const getCountry = address.getCountry.bind({ country: "USA" });<br/>console.log(getCountry()); // USA</span></pre><p id="06ae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">三世。构造函数调用</strong></p><p id="5975" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用<code class="du ld le lf lg b">new</code>关键字初始化时，函数可以用作构造函数。当<code class="du ld le lf lg b">new</code>关键字被使用时，一个新的对象被<code class="du ld le lf lg b">this</code>引用初始化。省略<code class="du ld le lf lg b">new</code>关键字会将<code class="du ld le lf lg b">this</code>设置为回退全局值并导致错误。</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="0fbd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了防止这种行为，应该向构造函数添加额外的处理:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ba23" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多信息将在<a class="ae hv" href="#48b9" rel="noopener ugc nofollow">原型章节</a>中介绍。</p><p id="b5da" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">四。间接调用</strong></p><p id="f16b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JavaScript函数支持在被调用时通过<code class="du ld le lf lg b">this</code>关键字引用其他对象。我们可以通过使用<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank">Function.prototype.call</a></code>或<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">Function.prototype.apply</a></code>来实现这个行为。<code class="du ld le lf lg b">call</code>和<code class="du ld le lf lg b">apply</code>做的完全一样。唯一的区别是<code class="du ld le lf lg b">call</code>期望一个对象和尽可能多的参数，而<code class="du ld le lf lg b">apply</code>期望所有的参数——除了对象之外——作为数组传递。</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><blockquote class="ml mm mn"><p id="bae4" class="iv iw mk ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">最后，注意<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> ES6箭头函数</a>没有自己的执行上下文，而是从它们的外部父类继承<code class="du ld le lf lg b">this</code>。这就是为什么我们不能使用箭头函数来定义函数或类方法的原因。</p></blockquote><p id="c2a4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有关<code class="du ld le lf lg b">this</code>的更多详细示例，请查看本文<a class="ae hv" href="https://www.javascripttutorial.net/javascript-this/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="48b9" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.原型</h1><p id="26db" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">所有JavaScript对象都从原型<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">继承属性和方法</a>。原型允许我们给对象添加方法和属性，并相互继承特性。</p><p id="432a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用前面介绍的构造函数调用时，我们会注意到JavaScript会将<em class="mk">原型属性</em>添加到我们的对象中，该属性指向原始的构造函数:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="3c45" class="lh kb hy lg b fi md me l mf mg">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span></pre><figure class="lv lw lx ly fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/7903e2d6b0707ce5f7c896e3fa15920a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLoU96OxpEvvV48DWA-vVA.png"/></div></div></figure><p id="70bf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在原始构造函数中添加一个方法来获取出生年份。添加此方法后，所有将<code class="du ld le lf lg b">Person</code>作为其<em class="mk">原型对象</em>的对象将<em class="mk">继承</em>此方法:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="f202" class="lh kb hy lg b fi md me l mf mg">Person.prototype.getYearOfBirth = function () {<br/>  return new Date().getFullYear() - this.age;<br/>};</span></pre><figure class="lv lw lx ly fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/ebd808a2744e8ab26249905d8f05f322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJTjuLmZumDffbtxthXLmw.png"/></div></div></figure><p id="578c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用相同的过程，我们可以添加或修改现有JavaScript原型对象的方法和属性，例如<code class="du ld le lf lg b">Array.prototype</code>或<code class="du ld le lf lg b">Date.prototype</code>，但是，这通常是不可取的。</p><p id="1d9e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会涉及任何关于原型的额外材料，但是你可以随时查看文档来了解高级概念。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="668d" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.班级</h1><p id="2b64" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6类</a>只是基于JavaScript原型继承的特殊函数。这就是为什么JavaScript类总是被称为“语法糖”的原因。这些类没有提供其他OOP语言中的额外特性，比如面向对象的继承，但是，它们是构造对象的一个很好的模板。</p><p id="ec11" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们如何实现一个类似于我们之前的原型对象的类:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><figure class="lv lw lx ly fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mt"><img src="../Images/fdf1fc514da95e715c5708c3b2b354df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKPnRTja3Cug_5LG4GYa2g.png"/></div></div></figure><p id="79a7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，ES6类只是为常规原型对象提供了更简洁的语法，以类似于其他语言(如Java和C++)中的类，而没有添加任何OOP特性。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0e44" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">4.领域</h1><p id="1a6d" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">JavaScript中的<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" rel="noopener ugc nofollow" target="_blank">作用域</a>定义了如何在整个代码中访问值和函数。根据定义，JavaScript中的所有作用域都可以描述为<strong class="ix hz">全局</strong>或<strong class="ix hz">局部。</strong></p><h2 id="50c1" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">全球范围</h2><p id="e267" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">简单来说，所有函数和花括号<code class="du ld le lf lg b">{}</code>之外定义的东西都属于全局范围。在全局范围内定义的变量可以在代码中的任何地方使用。</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ab48" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，您希望尽可能地限制全局变量的数量，因为:</p><ul class=""><li id="5fe0" class="mu mv hy ix b iy iz jc jd jg mw jk mx jo my js mz na nb nc bi translated">使用全局变量可能会导致代码缩放时的命名冲突。注意，重新声明<code class="du ld le lf lg b">const</code>或<code class="du ld le lf lg b">let</code>变量会抛出错误，而重新声明<code class="du ld le lf lg b">var</code>会覆盖变量。</li><li id="f6d9" class="mu mv hy ix b iy nd jc ne jg nf jk ng jo nh js mz na nb nc bi translated">在浏览器中，全局变量是用户和页面上运行的任何脚本都可以访问的<code class="du ld le lf lg b">window</code>对象的成员。因此，使用全局值可能会带来安全问题。</li><li id="1d08" class="mu mv hy ix b iy nd jc ne jg nf jk ng jo nh js mz na nb nc bi translated">JavaScript执行变量查找，从当前范围开始，向上到下一个父级，直到到达全局范围。拥有许多全局变量可能会导致性能问题。</li></ul><h2 id="3ee5" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">局部范围</h2><p id="c923" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">局部范围是局部变量的范围。局部范围由<strong class="ix hz">功能</strong>和<strong class="ix hz">块</strong>范围组成。</p><ul class=""><li id="183f" class="mu mv hy ix b iy iz jc jd jg mw jk mx jo my js mz na nb nc bi translated"><strong class="ix hz">功能范围</strong></li></ul><p id="4722" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在函数中声明的变量只能在同一个函数中访问。该规则适用于使用<code class="du ld le lf lg b">var</code>、<code class="du ld le lf lg b">let</code>或<code class="du ld le lf lg b">const</code>声明的变量:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><ul class=""><li id="8c05" class="mu mv hy ix b iy iz jc jd jg mw jk mx jo my js mz na nb nc bi translated"><strong class="ix hz">封锁范围</strong></li></ul><p id="709d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在ES6中引入，在任何花括号<code class="du ld le lf lg b">{}</code>中使用<code class="du ld le lf lg b">const</code>或<code class="du ld le lf lg b">let</code>声明的变量都有块范围，这意味着它们只能在同一个块中访问。块作用域实际上是函数作用域的子集— <em class="mk">，除了带有隐式返回的箭头函数的情况</em>。</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3531" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">5.提升</h1><p id="17a1" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在JavaScript中，提升是在代码执行之前将变量和函数声明移动到当前范围顶部的默认过程。这在技术上意味着您可以在声明变量之前使用它们。</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="a919" class="lh kb hy lg b fi md me l mf mg">foo = "Variable to declare later";<br/>console.log(foo); <em class="mk">// Variable to declare later<br/></em>var foo;</span></pre><p id="96a2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重要的是要知道只有声明被移动到顶部，而初始化没有被移动到顶部:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="d832" class="lh kb hy lg b fi md me l mf mg">console.log(foo); <em class="mk">// undefined<br/></em>var foo = "Variable initialized later";</span></pre><p id="7f35" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，<code class="du ld le lf lg b">foo</code>的声明被移到了顶部，但是因为它只是在稍后才被初始化，所以它将首先保存值<code class="du ld le lf lg b">undefined</code>。</p><h2 id="b0be" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">分段范围和吊装</h2><p id="f14d" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如前所述，<code class="du ld le lf lg b">const</code>和<code class="du ld le lf lg b">let</code>是块范围的。该块"<em class="mk">知道这些变量的</em>，但是在声明它们之前不能使用它们。用<code class="du ld le lf lg b">const</code>和<code class="du ld le lf lg b">let</code>声明的值在声明之前被称为处于"<em class="mk">时间死区"</em>"中。</p><p id="4b04" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在声明前初始化<code class="du ld le lf lg b">let</code>会抛出一个<code class="du ld le lf lg b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" rel="noopener ugc nofollow" target="_blank">ReferenceError</a></code>:</p><figure class="lv lw lx ly fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ni"><img src="../Images/d7cad668852095e062dc479ab0bf9546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erBsqn0NPHi4l4lvd1QNrg.png"/></div></div></figure><p id="f384" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在声明之前初始化<code class="du ld le lf lg b">const</code>会抛出一个<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" rel="noopener ugc nofollow" target="_blank">语法错误</a>，所以代码甚至不会运行:</p><figure class="lv lw lx ly fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nj"><img src="../Images/a846db1421b39e30443bd5369f097e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9sLkvuRELQ9xhZlhWYdDQ.png"/></div></div></figure><h2 id="be33" class="lh kb hy bd kc li lj lk kg ll lm ln kk jg lo lp ko jk lq lr ks jo ls lt kw lu bi translated">功能提升</h2><p id="4deb" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">使用<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" rel="noopener ugc nofollow" target="_blank">函数声明</a>时，函数会被提升到当前作用域的顶部。这意味着您可以在声明函数之前使用它。</p><p id="159d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相比之下，如果使用<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>，函数就不会被提升，所以你只需要在函数被声明后使用它:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="0ea6" class="ka kb hy bd kc kd nk kf kg kh nl kj kk kl nm kn ko kp nn kr ks kt no kv kw kx bi translated">6.关闭</h1><p id="9570" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">规范中<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭合</a>的定义是:</p><blockquote class="ml mm mn"><p id="dbfa" class="iv iw mk ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">函数和声明该函数的词法环境的组合。</p></blockquote><p id="1cc1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，闭包是一个内部函数，它可以访问其封闭函数或外部函数的变量。因此我们可以得出结论，一个闭包有三个作用域链:</p><ul class=""><li id="a1d5" class="mu mv hy ix b iy iz jc jd jg mw jk mx jo my js mz na nb nc bi translated">访问自己的<strong class="ix hz">块范围</strong></li><li id="517d" class="mu mv hy ix b iy nd jc ne jg nf jk ng jo nh js mz na nb nc bi translated">进入其封闭函数(或外部函数)的<strong class="ix hz">范围</strong></li><li id="bf4a" class="mu mv hy ix b iy nd jc ne jg nf jk ng jo nh js mz na nb nc bi translated">访问<strong class="ix hz">全局范围</strong></li></ul><p id="2234" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下面的例子:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="68f6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的例子中，我们可以看到如何嵌套闭包，每个闭包都可以访问其封闭函数的所有变量、局部变量和全局变量。我在这里使用超时来演示闭包最重要的特性:</p><blockquote class="np"><p id="5828" class="nq nr hy bd ns nt nu nv nw nx ny js dx translated">即使外部函数已经返回，内部函数仍然可以访问外部函数的值。</p></blockquote></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="b19f" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">7.Currying</h1><p id="3761" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">JavaScript中的<strong class="ix hz">闭包</strong>的概念使我们能够从<strong class="ix hz">curring</strong>中受益，curring是<em class="mk">一个重要的函数式编程概念</em>。</p><blockquote class="ml mm mn"><p id="fa0e" class="iv iw mk ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">Currying是一种函数转换，它将一个函数从可调用的as <code class="du ld le lf lg b">f(a, b, c)</code>转换成可调用的as <code class="du ld le lf lg b">f(a)(b)(c)</code></p></blockquote><p id="41e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，一旦你传递了一个参数，一个curried函数将不会返回值。相反，该函数将继续返回一个新函数，期待集合中的下一个参数，直到所有参数都用完。一旦传递了最后一个参数，将返回所有函数的结果。下面是加法函数的实现:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="5634" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个更现实的currying用例是用预定义的参数实现事件处理程序。以下面这个简单的React组件为例:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ab5b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，只有点击按钮时才会弹出警告。由于closure，警告消息将与第一次调用curried函数时传递的消息相同。</p><p id="11c4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以查看这篇文章来更好地理解currying及其用例。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="cb97" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">8.生活</h1><p id="09f4" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">life(立即调用的函数表达式)</a>是一个一旦定义就被调用的函数。函数很重要，因为在这些函数内部声明的所有变量都不能被外部作用域访问。一般来说，当您希望直接执行一些代码并保证数据隐私时，您最有可能使用这些函数。</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="7f3f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个重要的用例是利用IIFEs和JavaScript的<a class="ae hv" href="https://javascript.plainenglish.io/data-hiding-with-javascript-module-pattern-62b71520bddd" rel="noopener ugc nofollow" target="_blank">模块模式</a>来实现一个<strong class="ix hz">单例</strong>对象:</p><figure class="lv lw lx ly fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="58e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">稍后，当我们将单例对象导入到其他地方时，我们将只能访问一个实例:</p><pre class="lv lw lx ly fd lz lg ma mb aw mc bi"><span id="328f" class="lh kb hy lg b fi md me l mf mg">import MySingletonDAO from "./MyDAO"</span><span id="f368" class="lh kb hy lg b fi mh me l mf mg">const instance1 = MySingletonDAO.getInstance()<br/>const instance2 = MySingletonDAO.getInstance()</span><span id="4010" class="lh kb hy lg b fi mh me l mf mg">console.log(instance1 === instance2) // true</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6262" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一部分中，我简要讨论了提高JavaScript技能需要掌握的几个概念。在下一部分中，我将更多地关注其他重要主题，如异步函数和迭代器。我希望你喜欢你的阅读，到时候见！</p><figure class="lv lw lx ly fd hk er es paragraph-image"><a href="http://buymeacoffee.com/jalkhurfan"><div class="er es nz"><img src="../Images/169f8b1142e42f66cc1f8d36823ed21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*gzdOEDskvMA1wW6CUF3RkA.png"/></div></a><figcaption class="hr hs et er es ht hu bd b be z dx">Support me to write more!</figcaption></figure></div></div>    
</body>
</html>
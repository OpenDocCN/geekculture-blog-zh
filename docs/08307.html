<html>
<head>
<title>Serial Connection between Raspberry Pi and Raspberry Pico</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树莓Pi和树莓Pico之间的串行连接</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/serial-connection-between-raspberry-pi-and-raspberry-pico-d6c0ba97c7dc?source=collection_archive---------0-----------------------#2021-10-25">https://medium.com/geekculture/serial-connection-between-raspberry-pi-and-raspberry-pico-d6c0ba97c7dc?source=collection_archive---------0-----------------------#2021-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/86578e1a6e13153a9fc80c9c09e05a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qO6EhOgxArKogxfv_YV5lg.png"/></div></div></figure><p id="73aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2021年初，我开始了我的机器人项目。其中一个子项目是熟悉Arduino和C编程。Arduino在传感器和致动器库方面无可匹敌，在“连接和工作”体验方面也无与伦比。然而，在年中，我决定改用Raspberry Pico和MicroPython来实现我的机器人。这一选择的动机是将一种且仅一种编程语言用于机器人中间件、SBD和微控制器，并利用RealSense D435相机提供的强大Python库进行图像识别。</p><p id="dacd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我需要重新学习运行MicroPython的Raspberry Pico和运行Python的Raspberry Pi之间串行连接的基本知识。这篇文章解释了成功连接的基础。</p><p id="1991" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于我的博客</em><a class="ae jp" href="https://admantium.com/blog/micro16_micropython_serial_connection/" rel="noopener ugc nofollow" target="_blank"><em class="jo">admantium.com</em></a></p><h1 id="e19d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">硬件连接选项</h1><p id="c98a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">要从Pi连接到Pico，有三种选择:</p><ul class=""><li id="4ff9" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">直接USB到USB</li><li id="b38b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">直接Tx/Rx引脚</li><li id="e631" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">USB-TTL至Rx/Rx</li></ul><p id="b622" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于Raspberry Pico仍然相对年轻，MicroPython堆栈的技术成熟度会影响这些连接中的哪一个可以被使用。</p><p id="23a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你使用选项A或C时，你可以跳到例子中。如果要使用选项B，需要按照下一节描述的步骤使能Tx/Rx引脚。</p><h1 id="4b5e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">如何在Raspberry Pi上使能Tx/Rx引脚</h1><p id="06c8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在这篇<a class="ae jp" href="https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3-4/" rel="noopener ugc nofollow" target="_blank">伟大的文章</a>之后，你需要做以下事情:</p><ul class=""><li id="b0e2" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">通过Raspi-Config初始化串行端口</li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="03a1" class="lq jr hi lm b fi lr ls l lt lu">$&gt; sudo raspi-config</span><span id="2562" class="lq jr hi lm b fi lv ls l lt lu">  =&gt; 3. Interface Option<br/>  =&gt; P6. Serial Port<br/>    =&gt;  Would you like a login shell to be accessible over serial?<br/>        Answer with 'No'<br/>    =&gt;  Would you like the serial port hardware to be enabled?<br/>        Answer with 'Yes'</span></pre><ul class=""><li id="9e07" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">禁用<code class="du lw lx ly lm b">/dev/ttyS0</code>服务</li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="021e" class="lq jr hi lm b fi lr ls l lt lu">$&gt; sudo systemctl stop serial-getty@ttyS0.service<br/>$&gt; sudo systemctl disable serial-getty@ttyS0.service</span></pre><ul class=""><li id="505b" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">从引导中移除控制台</li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="68b0" class="lq jr hi lm b fi lr ls l lt lu">$&gt; sudo nano /boot/cmdline.txt<br/>    =&gt; Remove or comment out a line that says 'console=serial0,115200'</span></pre><p id="8cdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，Pi仍将通过Tx/Rx引脚发送系统消息——这可能是您一直在寻找的一个特定用例。下面是我关闭Pi时的示例输出。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="533f" class="lq jr hi lm b fi lr ls l lt lu">&gt;&gt; [  OK  ] Stopped LSB: automatic crash report generation.<br/>&gt;&gt; [  OK  ] Stopped User Manager for UID 1000.<br/>&gt;&gt; [  OK  ] Stopped Login Service.<br/>&gt;&gt; RPI 4 Model B (0xc03111)</span></pre><h1 id="3fc9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从Pi向Pico发送数据</h1><p id="3a49" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在所有示例中，从Raspberry Pi向Pico发送数据的代码都是相同的，只是稍有修改:Pico连接的端口。</p><p id="60c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下样板代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="21ec" class="lq jr hi lm b fi lr ls l lt lu"># sender.py<br/>import time<br/>import serial</span><span id="d99e" class="lq jr hi lm b fi lv ls l lt lu">ser = serial.Serial(<br/>  port='/dev/ttyS0', # Change this according to connection methods, e.g. /dev/ttyUSB0<br/>  baudrate = 115200,<br/>  parity=serial.PARITY_NONE,<br/>  stopbits=serial.STOPBITS_ONE,<br/>  bytesize=serial.EIGHTBITS,<br/>  timeout=1<br/>)</span><span id="e7f1" class="lq jr hi lm b fi lv ls l lt lu">msg = ""<br/>i = 0</span><span id="1228" class="lq jr hi lm b fi lv ls l lt lu">while True:<br/>    i+=1<br/>    print("Counter {} - Hello from Raspberry Pi".format(i))<br/>    ser.write('hello'.encode('utf-8'))<br/>    time.sleep(2)</span></pre><p id="f994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释:</p><ul class=""><li id="ce83" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第2行:导入启用串行连接的<code class="du lw lx ly lm b">serial</code>库</li><li id="26ba" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第4行:创建一个串行对象，其配置与默认Pico UART配置完全相同(波特率115200，字节大小8位等。).<code class="du lw lx ly lm b">port</code>部分需要根据连接方法进行定制——详见下文</li><li id="fa89" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第19行:要发送数据，首先<code class="du lw lx ly lm b">encode</code>字符串数据，然后<code class="du lw lx ly lm b">write</code>它到串行对象</li></ul><p id="29cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来看看接收器端。</p><h1 id="6b38" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接收数据:USB到USB连接</h1><p id="0d9b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在撰写本文时，运行在Pico上的MicroPython的最新版本是<code class="du lw lx ly lm b">MicroPython v1.16 on 2021-06-18</code>。该版本没有内置的USB串行通信库。</p><p id="926b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在这个<a class="ae jp" href="https://www.raspberrypi.org/forums/viewtopic.php?t=302889" rel="noopener ugc nofollow" target="_blank"> Pico论坛线程</a>中，一个用户提供了一个纯粹的MicroPython实现，它在第二个Pico CPU内核上产生一个线程，该线程主动侦听通过USB传入的字节。我在我早期的机器人原型中尝试了这个代码，并可以使用它通过Pico上的USB接收命令我的机器人移动的消息。</p><p id="f688" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我的工作示例:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="620d" class="lq jr hi lm b fi lr ls l lt lu"># receiver.py / USB =&gt; USB<br/>import sys<br/>sys.path.append('/radu')</span><span id="2278" class="lq jr hi lm b fi lv ls l lt lu">import os</span><span id="cfc2" class="lq jr hi lm b fi lv ls l lt lu">from bot import Bot<br/>from rusb import USB</span><span id="eb5c" class="lq jr hi lm b fi lv ls l lt lu">from _thread import start_new_thread<br/>from time import sleep_ms</span><span id="30e8" class="lq jr hi lm b fi lv ls l lt lu">radu = Bot('Radu MK1')<br/>usb = USB()</span><span id="1ddb" class="lq jr hi lm b fi lv ls l lt lu">input_msg = None<br/>bufferSTDINthread = start_new_thread(usb.bufferSTDIN, ())</span><span id="9ba1" class="lq jr hi lm b fi lv ls l lt lu">while True:<br/>  input_msg = usb.getLineBuffer()<br/>  if input_msg and 'ros_msg' in input_msg:<br/>    obj = eval(input_msg)<br/>    radu.notify(obj)</span><span id="5703" class="lq jr hi lm b fi lv ls l lt lu">  sleep_ms(10)</span></pre><h1 id="23ba" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接收数据:Tx/Rx引脚连接</h1><p id="54e3" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Tx/Rx引脚之间的直接连接意味着:</p><ul class=""><li id="db9a" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">连接地:Pi引脚6至Pico引脚3</li><li id="fd82" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">将Tx连接到Rx: Pi引脚8 (GPIO 14)连接到Pico引脚1 (GPIO 0)</li><li id="1833" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">将Tx连接到Rx: Pi引脚10 (GPIO 15)连接到Pico引脚2 (GPIO 1)</li></ul><p id="52dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，您还需要配置您的Raspberry Pi来启用这些引脚。完成后，使用以下代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8ba4" class="lq jr hi lm b fi lr ls l lt lu"># receiver.py / Tx/Rx =&gt; Tx/Rx<br/>import os<br/>import machine<br/>from time import sleep</span><span id="8ce8" class="lq jr hi lm b fi lv ls l lt lu">uart = machine.UART(0, 115200)<br/>print(uart)</span><span id="8b9f" class="lq jr hi lm b fi lv ls l lt lu">b = None<br/>msg = ""</span><span id="b0e3" class="lq jr hi lm b fi lv ls l lt lu">while True:<br/>    sleep(1)<br/>    if uart.any():<br/>        b = uart.readline()<br/>        print(type(b))<br/>        print(b)<br/>        try:<br/>            msg = b.decode('utf-8')<br/>            print(type(msg))<br/>            print("&gt;&gt; " + msg)<br/>        except:<br/>            pass</span></pre><p id="4dce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该计划中:</p><ul class=""><li id="f08a" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第5行:通过访问Pico的内部<code class="du lw lx ly lm b">machine.UART</code>实例来创建一个<code class="du lw lx ly lm b">uart</code>实例。这用与发送者代码配置相同的值来定义。请注意，<a class="ae jp" href="https://docs.micropython.org/en/latest/library/machine.UART.html" rel="noopener ugc nofollow" target="_blank"> MicroPython文档</a>还允许您创建不同配置的UART实例，例如使用较慢的波特率。</li><li id="5055" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第12行:当UART连接上至少有一个字符可用时，条件<code class="du lw lx ly lm b">uart.any()</code>返回一个正整数。</li><li id="961f" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第13行:要读取数据，要么使用<code class="du lw lx ly lm b">read(i)</code>，其中<code class="du lw lx ly lm b">i</code>是字符数，要么使用<code class="du lw lx ly lm b">readline()</code>读取所有字符，直到到达一个新行。处理单个字符更有效、更快，如果需要交换复杂的信息，处理完整的行更可靠。</li><li id="4da6" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第16行:一个<code class="du lw lx ly lm b">try - except</code>块开始，其中...</li><li id="6b9a" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第17行:…接收到的消息被解码，然后打印出来。如果有任何错误，程序将继续运行，而不会引发错误。</li></ul><h1 id="cb28" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接收数据:USB-TTL至Tx/Rx引脚连接</h1><p id="3bfe" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">首先，你需要一个USB-TTL适配器，它至少有两种不同的芯片组:FT232RL和CH340g。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/e330141bf24b7789f1fb3c91053d80c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HERSA5-AVZdtf1SU.png"/></div></div></figure><p id="09eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来源:<a class="ae jp" href="https://images-eu.ssl-images-amazon.com/images/I/51sVhZNyGxL._SY445_SX342_QL70_ML2_.jpg" rel="noopener ugc nofollow" target="_blank"> Amazon.de </a>，<a class="ae jp" href="https://images-eu.ssl-images-amazon.com/images/I/61HcN9SmudL.__AC_SX300_SY300_QL70_ML2_.jpg" rel="noopener ugc nofollow" target="_blank"> Amazon.de </a>。</p><p id="ac48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将适配器插入Picos USB端口，然后使用<code class="du lw lx ly lm b">dmesg</code>查看该设备是如何配置的。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1a79" class="lq jr hi lm b fi lr ls l lt lu">[326612.390873] usb 1-2: new full-speed USB device number 54 using xhci_hcd<br/>[326612.543888] usb 1-2: New USB device found, idVendor=1a86, idProduct=7523, bcdDevice= 2.64<br/>[326612.543893] usb 1-2: New USB device strings: Mfr=0, Product=2, SerialNumber=0<br/>[326612.543895] usb 1-2: Product: USB Serial<br/>[326612.546221] ch341 1-2:1.0: ch341-uart converter detected<br/>[326612.549000] usb 1-2: ch341-uart converter now attached to ttyUSB0</span></pre><p id="a991" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一行是<code class="du lw lx ly lm b">ttyUSB0</code>，所以发送者代码需要修改如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ced7" class="lq jr hi lm b fi lr ls l lt lu"># sender.py / USB-TTL =&gt; Tx/Rx<br/># ...<br/>ser = serial.Serial(<br/>  port='/dev/USB0'<br/>  # ...<br/>)</span></pre><p id="7bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接收数据的代码与直接Tx/Rx连接相同。</p><h1 id="6204" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例输出</h1><p id="1c6a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">现在让我们看看我们的代码在运行。</p><p id="6ed3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Raspberry Pi上执行<code class="du lw lx ly lm b">sender.py</code>会输出以下信息:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b91a" class="lq jr hi lm b fi lr ls l lt lu">&gt;&gt;&gt;<br/>Counter 1 - Hello from Pi4<br/>Counter 2 - Hello from Pi4<br/>Counter 3 - Hello from Pi4<br/>Counter 4 - Hello from Pi4</span></pre><p id="60c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Raspberry Pico上运行<code class="du lw lx ly lm b">receiver.py</code>显示:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4b2e" class="lq jr hi lm b fi lr ls l lt lu">%Run -c $EDITOR_CONTENT<br/>(sysname='rp2', nodename='rp2', release='1.16.0', version='v1.16 on 2021-06-18 (GNU 10.2.0 MinSizeRel)', machine='Raspberry Pi Pico with RP2040')<br/>UART(0, baudrate=115200, bits=8, parity=None, stop=1, tx=0, rx=1, txbuf=256, rxbuf=256, timeout=0, timeout_char=1, invert=None)<br/>&lt;class 'bytes'&gt;<br/>b'hello\n'<br/>&lt;class 'str'&gt;<br/>&gt;&gt; hello</span></pre><h1 id="0db6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="f487" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">本文解释了使用(微)Python连接Raspberry Pi和Raspberry Pico的三个选项。第一种选择是USB到USB，需要一个外部的MicroPython库来接收数据。第二种选择是从两台机器直接连接Rx/Tx。在对您的Pi进行一些配置之后，这就可以稳定地工作了。第三种选择是使用USB FTL连接Tx/Rx。不需要任何配置，开箱即用。</p><p id="f8b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑源代码，在Pi上是<code class="du lw lx ly lm b">pyserial</code>库:打开一个与Pico配置相同的串行连接对象(波特率，停止位)并用<code class="du lw lx ly lm b">serial.write()</code>发送编码数据。在Pico上，是building <code class="du lw lx ly lm b">machine.UART</code>对象，它访问内置UARTs或者是可配置的。使用<code class="du lw lx ly lm b">uart.readline()</code>接收字节，然后使用<code class="du lw lx ly lm b">decode()</code>接收数据。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Every Built-in React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个内置的React挂钩</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/every-built-in-react-hook-943f2735cd01?source=collection_archive---------2-----------------------#2021-04-29">https://medium.com/geekculture/every-built-in-react-hook-943f2735cd01?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/961286e888f682072de57bfe4e4d3f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ijet6kVJqGgul6adezDLQ.png"/></div></div></figure><p id="1be8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用功能组件时，React hooks API提供了流控制、状态管理和组件生命周期的功能。</p><p id="2921" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">规则很简单:</p><p id="0fa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你不能从一个普通的JavaScript函数中调用钩子。</p><p id="8233" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">你只能在React函数组件内部调用钩子或者自定义钩子</strong></p><p id="db1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">钩子函数总是以“<em class="jo">使用”</em>开头，后面跟一个<em class="jo">“超级能力”</em>。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="66f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有几个内置的React挂钩，您可以将它们组合成自定义挂钩，用于应用程序中的特定用例。在本文中，我们将重点关注React内置钩子，有3个基本钩子在常规应用程序中经常使用，另外7个钩子。</p><h2 id="bb00" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">基本挂钩</h2><ul class=""><li id="4187" class="kq kr hi is b it ks ix kt jb ku jf kv jj kw jn kx ky kz la bi translated">使用状态</li><li id="e8b7" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用效果</li><li id="d427" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用上下文</li></ul><h2 id="1662" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">附加挂钩</h2><ul class=""><li id="9661" class="kq kr hi is b it ks ix kt jb ku jf kv jj kw jn kx ky kz la bi translated">用户教育</li><li id="05d7" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用回调</li><li id="0557" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用备忘录</li><li id="2833" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">useRef</li><li id="0046" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">useImperativeHandle</li><li id="1b4e" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">useLayoutEffect</li><li id="4bfb" class="kq kr hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">useDebugValue</li></ul></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="607e" class="ln jw hi bd jx lo lp lq kb lr ls lt kf lu lv lw ki lx ly lz kl ma mb mc ko md bi translated">1.使用状态</h1><p id="22c7" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这是react中最重要也是最常用的钩子。我们使用这个钩子来存储状态，并在组件内部使用它。</p><p id="ec8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用一个表示默认值的参数调用<em class="jo"> useState </em>。它将返回一个有状态的值和一个函数来更新这个值。我们可以简单地使用析构语法来检索和命名值和setter函数。在下一个例子中，count是有状态值，setCount是setter函数。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="3914" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">2.<em class="mn">使用效果</em></h1><p id="d5db" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">作为参数传递给<em class="jo"> useEffect </em>的函数将在渲染提交到屏幕后运行。默认行为是在每次渲染后运行，但是您也可以传递第二个参数，该参数是一个依赖项数组。如果你传递依赖数组，你的函数将在数组中的每一项被改变时运行。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="4615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React类的上下文中，您可以使用这个钩子获得与<em class="jo">componentidmount</em>、<em class="jo">componentiddupdate</em>或<em class="jo">componentidmount</em>类似的结果，唯一的区别是<em class="jo"> useEffect </em>在延迟事件期间被触发。</p><p id="8559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常你需要一个清理功能，一个取消所有听众订阅的地方。</p><p id="a6e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">以下示例包含componentDidMount和componentWillUnmount的类似行为</em></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="c4cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">以下示例包含与componentDidUpdate </em>类似的行为</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="6904" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">3.使用上下文</h1><p id="bb90" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这个挂钩允许您使用React Context API，这是一种允许您使用发布/订阅模型(也称为发布-订阅模型)在组件之间共享数据的机制。</p><p id="fbf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将需要传递一个上下文对象作为这个钩子的参数，它将返回最近的提供者的值。</p><p id="908a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">创建上下文提供者</strong></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="df89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户上下文—上下文对象</p><p id="1cfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">UserProvider —一个函数组件，它在上下文提供者Provider中呈现其子级。</p><p id="9eb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用上下文提供程序</strong></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="ab78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，UserProvider的每个孩子都可以使用带有UserContext作为参数的<em class="jo"> useContext </em>钩子。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="6067" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在断开连接的组件中使用上下文值，重要的是在组件层次结构中要有上面的提供者。在同一个组件树中可以有嵌套的提供者，每个上下文消费者将从最近的提供者中检索值。</p><p id="8fb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你在过去使用上下文消费者，你可能已经使用了消费者组件</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="0394" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useContext挂钩基本上是消费者组件的一个更干净的替代品。</p><h1 id="7766" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">4.用户教育</h1><p id="6b59" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这个钩子用于高级状态管理。它是<em class="jo"> useState </em>的替代，您可以使用这个特殊的钩子来遵循Redux模式。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/c0de0bfa93be545753245bd42c2a11b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdiFUfbTNmk_IxFDNqokqg.png"/></div></div></figure><p id="107e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不是直接更新状态，而是调度一个动作，该动作将触发一个reducer函数，reducer函数计算并确定下一个状态。最后，状态被传递给UI组件。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="a7fa" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">5.使用回调</h1><p id="1ec2" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">在react组件中定义函数时，会为该组件的每次渲染创建一个新的函数对象。在某些情况下，您需要记住这个函数来防止这种行为。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="b4db" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">6.使用备忘录</h1><p id="fa3a" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这个挂钩可以帮助优化计算成本。</p><p id="db38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个昂贵的计算要做，我们想存储渲染之间的值，并在其他值改变事件时重新计算。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="fbbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只有当计数改变时，<em class="jo"> expensiveComputation </em>才会重新运行，在组件的其他重新呈现中，<em class="jo">计算</em>值将是之前<em class="jo"> expensiveComputation </em>调用的结果。</p><h1 id="b9fe" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">7.useRef</h1><p id="6461" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这个钩子有助于创建一个可变的对象，它将在不同的呈现之间保持相同的引用。需要记住的一点是，可变对象不会在变化时触发重新呈现。</p><ul class=""><li id="206a" class="kq kr hi is b it iu ix iy jb mp jf mq jj mr jn kx ky kz la bi translated">useRef 的常见用例是强制访问DOM元素</li></ul><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="bb0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您尝试使用refs在组件内部存储数据，您会注意到，当计数发生变化时，组件不会重新呈现。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="5dfc" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">8.useImperativeHandle</h1><p id="679a" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">你很少会需要这个钩子。</p><p id="8a16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useImperativeHandle用于定制您希望使用对父组件的引用公开的值。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><h1 id="49f0" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">9.useLayoutEffect</h1><p id="9fc3" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">另一个不常见的钩子是<em class="jo"> useLayoutEffect </em>，它类似于<em class="jo"> useEffect </em>钩子，唯一的区别是它将在渲染组件之后但在屏幕上绘制之前运行。这意味着react将在向客户端更新屏幕之前等待函数完成。</p><p id="aa18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，如果您想在DOM可视化更新之前做一些事情，您将需要使用这个钩子。</p><h1 id="6041" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">10.useDebugValue</h1><p id="1815" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">这个钩子用于使用react开发工具调试定制钩子。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mh ju l"/></div></figure><p id="90dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用React开发工具，我们可以看到我们的调试值</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/cd54751218702a693bc90dc58470e3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65M-w2IYQQgXyp8brrN6Vw.png"/></div></div></figure><h1 id="8a61" class="ln jw hi bd jx lo mi lq kb lr mj lt kf lu mk lw ki lx ml lz kl ma mm mc ko md bi translated">参考资料和进一步阅读</h1><p id="9725" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated"><a class="ae mt" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></p></div></div>    
</body>
</html>
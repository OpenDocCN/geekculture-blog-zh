<html>
<head>
<title>NaradaFakeBuster: Fighting Fake News</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NaradaFakeBuster:打击假新闻</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/naradafakebuster-fighting-fake-news-7bd6ac6ebbd?source=collection_archive---------14-----------------------#2021-10-02">https://medium.com/geekculture/naradafakebuster-fighting-fake-news-7bd6ac6ebbd?source=collection_archive---------14-----------------------#2021-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c1f9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我如何使用Google &amp; AWS Lambda构建一个事实检查机器人</h2></div><ol class=""><li id="de1c" class="ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated"><strong class="iz hj">简介</strong></li></ol><p id="d91a" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">尽管假新闻已经存在了几十年，但社交媒体的爆发已经带来了大量数据的混乱。每个人都可以自由访问，他们发布的内容没有过滤，很难选择什么该相信，什么不该相信。核实这些新闻的事实对做出明智的决定很重要。</p><p id="9d59" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">NaradaFakeBuster是一个为事实检查开发的电报机器人，它接受短语或文章标题，并在数据库中运行它们，以检查事实检查是否已经完成。NaradaFakeBuster使用AWS Lambda函数作为其后端。lambda函数调用API来验证事实，它还在elasticsearch索引中记录查询和用户分析，因为查询被记录到一个bot中，python notebook用于检查elasticsearch索引。AWS让创建和部署聊天机器人变得更加容易，有了AWS Lambda，你可以在五分钟内创建聊天机器人。</p><p id="f6ea" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 2。现有架构</strong></p><p id="bcf7" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">核实索赔</p><p id="42e6" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">一些被用作灵感的类似工作包括VERiCLAIM，这是一个自动事实检查系统，它使用了NLP和证据检索方法的最新技术。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/8172a9df5af90b2ed0c1fc9249599a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfF-nFq3iHByD8Zc9OmHDg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Claim-checking framework as provided by the authors</figcaption></figure><p id="786f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(b) CLAIMBUSTER框架</p><p id="a353" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">另一个是名为ClaimBuster的自动化实时事实检查。ClaimBuster项目最初是作为一个人工智能模型开发的，可以自动检测值得检查的索赔，但现在已经成为一个成熟的自动化事实检查系统。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ks"><img src="../Images/681425d684354602c94531008c9dfa3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2yS7XgJU5GY2iYkUUWtdw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Claim Buster Framework</figcaption></figure><p id="63ce" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">上面是一个系统图，描述了当前框架，浅蓝色框中突出显示了索赔定位组件。</p><p id="0e00" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 3。NARADA-FAKEBUSTER BOT架构</strong></p><p id="631b" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">lambda函数中的<strong class="iz hj"> NaradaFakeBuster </strong>的架构是一个模块化的类型，在其中解析文本以提取所需的信息。用户在telegram bot上输入值，它调用webhook，这是lambda的API端点。文本被传递给lambda函数，该函数被进一步解析并用于调用google check API，从API获得的输出被解析并被发送回前端以显示在屏幕上。所有输入查询和用户分析都存储在elasticsearch索引中。然后可以查询来自elasticsearch index的数据来获得用户分析。</p><p id="37bf" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><add an="" architecture="" diagram=""/></p><p id="37ec" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(a)网络挂钩与轮询</p><p id="4325" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">API集成应该足够高效，以便应用程序之间的数据共享为用户提供巨大的价值。在轮询方法中，我们以预定的频率发送对新事件的请求(特别是创建、检索和删除事件，这些事件表示数据的变化),并等待端点响应。如果端点没有响应，则没有新事件可共享。与轮询类似，webhooks为您的应用程序提供了一种从端点消费新事件数据的方式。然而，不是发送新事件的重复请求，而是为端点提供一个URL，通常在应用程序监视的端点UI中。每当endpoint应用程序中发生新事件时，它会将事件数据发布到您指定的URL，实时更新您的应用程序。最初这个机器人是用一种轮询方法创建的，后来它被改成了web-hook方法，因为它们更有效。在轮询中，数据总是过时的，例如，如果轮询频率设置为每6小时一次，则返回的事件可能在这6小时的间隙中的任何时间发生，而在web-hook中，事件会立即发布到受监控的URL，应用程序会立即更新新数据。Zapier 发现超过98.5%的投票都被浪费了。相比之下，webhooks只在有<em class="ku">新数据要发送的时候才传输数据，这使得它们100%有效。这意味着轮询平均比webhooks多产生66倍的服务器负载。这浪费了很多时间，如果您为每个API调用付费，那就是浪费了很多钱。为了把我们从所有的损失中拯救出来，我们使用了网钩法<strong class="iz hj">。</strong></em></p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kv"><img src="../Images/374fc24153ef736aee641136d6a31c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCB8sSG03zpOcfLbzKw5Gg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Polling vs Web-hooks</figcaption></figure><p id="bc64" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(b)利用API网关建立网络挂钩</p><p id="129e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">亚马逊API Gateway上有一个功能叫做stage variables。阶段变量的作用类似于环境变量，可用于为每个部署阶段更改API网关方法的行为；例如，可以根据API运行的阶段到达不同的后端。环境变量很有用，因为它们允许您通过更改API密钥、端点、令牌或服务用来区分环境的任何东西来更改您的环境使用哪个第三方服务环境。API Gateway可以在不调用支持Lambda函数的情况下阻止不正确的请求，这样可以节省Lambda调用成本，还可以从Lambda函数中卸载请求验证。可以从阶段设置控制台启用指标，所有日志记录都以两种形式完成:执行日志和访问日志。从每条消息中捕获的元数据存储在elasticsearch索引中。有了AWS无服务器平台，你可以构建一个独立运行的Webhook，你不必担心监控和管理它。对于NaradaFakeBuster，webhook是使用AWS Lambda和API Gateway创建的。</p><p id="d3e4" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">为了将API网关URL设置为telegram bot的网络挂钩，我们在浏览器窗口上运行以下命令:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="cfcb" class="lb lc hi kx b fi ld le l lf lg"><a class="ae kt" href="https://api.telegram.org/" rel="noopener ugc nofollow" target="_blank">https://api.telegram.org/</a>&lt;bot-token&gt;/setWebHook?url=&lt;api endpoint&gt;</span></pre><p id="d2f8" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 4。发展问题</strong></p><p id="9809" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">在开发bot时，我面临以下两个问题。回想起来，这似乎无关紧要。但找到一个合适的解决方案确实花了一些时间。我希望它能帮助阅读这篇博客的人</p><ol class=""><li id="6090" class="ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated"><em class="ku">谷歌protobuf错误</em></li><li id="db5b" class="ix iy hi iz b ja lh jc li je lj jg lk ji ll jk jl jm jn jo bi translated">和；<em class="ku">连接池错误</em></li></ol><p id="8c04" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(1) Google protobuf错误</p><p id="48a5" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">这个错误是因为lambda函数不能识别google包。当您运行下面的命令来安装我们的<em class="ku"> requirements.txt </em>文件中给出的包时。它会引发一个<em class="ku"> disutils错误&amp;一个protobuf错误</em></p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="4b48" class="lb lc hi kx b fi ld le l lf lg">python3 -m pip install - target=./ - user - upgrade - force-reinstall -r requirements.txt</span></pre><blockquote class="lm ln lo"><p id="cead" class="jp jq ku iz b ja jb ij jr jc jd im js lp jt ju jv lq jw jx jy lr jz ka kb jk hb bi translated">原因是上面的命令安装了具有以下文件夹结构的库</p></blockquote><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="5c90" class="lb lc hi kx b fi ld le l lf lg">python3 -m pip install — t . protobuf</span></pre><p id="77ce" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"># #文件夹结构如下:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="8892" class="lb lc hi kx b fi ld le l lf lg">NaradaMod2<br/>|<br/>|--google<br/>|    |--cloud<br/>|    |    |--bigquery<br/>|    | <br/>|    |--google<br/>|    |    |--protobuf-xxxx</span></pre><p id="687f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">##移动了protobuf文件夹。所以最终的结构如下:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="81be" class="lb lc hi kx b fi ld le l lf lg">NaradaMod2<br/>|<br/>|--google<br/>|    |--cloud<br/>|    |    |--bigquery<br/>|    | <br/>|    |--protobuf-xxxx<br/>|    |</span></pre><p id="a36e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">解决这个问题花了相当长的时间。答案并不直观。但一旦解决，似乎就简单了。</p><p id="9e6b" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(2)连接池错误</p><p id="b721" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">lambda函数引发了连接池错误。在检查云观察日志时，似乎这个错误是因为ES url指向一个它没有访问权限的集群！</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="749a" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 5。代码演练</strong></p><p id="a5c7" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">lambda函数中的主要代码块是<em class="ku"> lambda处理程序。</em>每当该功能被触发时，这是入口点…</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="lu lt l"/></div></figure><p id="08c0" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">lambda处理器:</p><p id="724f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(1)提取文本消息</p><p id="5647" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(2)检查它是否是机器人命令之一(<em class="ku">像帮助</em>)。如果是，它将提供必要的响应</p><p id="2493" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">(3)如果没有，它对命令运行factcheck并打印输出</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="lu lt l"/></div></figure><p id="9f38" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">我们使用以下软件包:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="bf91" class="lb lc hi kx b fi ld le l lf lg">googleapiclient.discovery - this is used to construct a request object to the Google fact-check API endpoint<br/>elasticsearch - helper package for accessing ElasticSearch clusternodes<br/>logging - used for tracking software logs</span></pre><p id="109f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">像API令牌这样的系统变量存储为环境变量，不属于代码的一部分。这使我们能够通过CI/CD流程以安全的方式存储它们，而不会意外暴露它们。</p><p id="8909" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">可以通过调用get-env函数来访问这些变量</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="7381" class="lb lc hi kx b fi ld le l lf lg">os.getenv("TELEGRAM_TOKEN")</span></pre><p id="2e29" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">以下代码为factcheck API构建了一个资源</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="3c23" class="lb lc hi kx b fi ld le l lf lg">#API token for factcheck API<br/>apiToken = os.getenv('GCP_FACTCHECK_TOKEN')</span><span id="a564" class="lb lc hi kx b fi lv le l lf lg"># Build the factcheck API service as a global var<br/>service = build('factchecktools', 'v1alpha1', developerKey = apiToken)</span><span id="7130" class="lb lc hi kx b fi lv le l lf lg">resource = service.claims()</span></pre><p id="83fd" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><em class="ku"> checkCommand </em>功能检查所有消息，包括当用户按下电报机器人上的<strong class="iz hj"> START </strong>时。</p><p id="8a1e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">“<strong class="iz hj"><em class="ku">/启动</em> </strong>”命令为用户提供了一个介绍性的信息。</p><p id="ef2c" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> <em class="ku"> /help </em> </strong>”提供了关于用法的附加帮助。</p><p id="3878" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">"<strong class="iz hj"> <em class="ku"> /factcheck </em> </strong>"后跟一个字符串启动<em class="ku"> factcheck </em>功能。</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="lu lt l"/></div></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lw"><img src="../Images/d0f4496044a6f916005a66ccfb762456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*HZHzGaIDTrXI0FUvZr-E3g.jpeg"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">snapshots from bot screen</figcaption></figure><p id="84a5" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> <em class="ku"> factcheck </em> </strong>函数接收用户编写的文本以检查事实。它保存消息并运行google API，如果它是一个非空字符串，它调用saveFactCheck函数，运行try块搜索数据库。如果搜索时出现错误，它会向用户发送一个响应。如果机器人无法在其数据库中找到事实，它会要求您尝试使用另一个字符串。如果机器人发现你的事实搜索索赔，它会显示所有的网址。</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="lu lt l"/></div></figure><p id="34d0" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 6。结论</strong></p><p id="b14c" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">用来自可信来源的可靠信息来核实事实可能是对抗错误信息传播的最佳方式。通过仔细检查你在社交媒体或在线文章中看到的说法，你可以验证它是否属实。</p><p id="7d14" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">NaradaFakeBuster 是事实核查领域中的一种智能方法，它使用无服务器功能，使我们能够节省成本，同时确保一致的可扩展性能。该机器人本质上是模块化的，因此可以很容易地部署为twitter、reddit或linkedin等其他社交媒体机器人的后端。</p></div></div>    
</body>
</html>
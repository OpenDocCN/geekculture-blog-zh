<html>
<head>
<title>ReactJS: Why Index as a key is an anti-pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS:为什么索引作为键是一种反模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/reactjs-why-index-as-a-key-is-an-anti-pattern-4b9dc6ef0067?source=collection_archive---------6-----------------------#2021-07-27">https://medium.com/geekculture/reactjs-why-index-as-a-key-is-an-anti-pattern-4b9dc6ef0067?source=collection_archive---------6-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="50c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着理解为什么它很重要，每个人都需要花一些时间来深入理解React如何利用幕后的组件密钥以及围绕这一概念的主要思想。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="ad9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">钥匙的作用是什么？</strong></p><p id="5d94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回想一下，在任何状态变化期间，React都会构建虚拟DOM树的新状态，并将其与之前的状态进行比较，并定义一组最佳操作，这些操作应该应用于真实浏览器DOM(图1)以进行新的转换。React将虚拟DOM与一种特殊的<a class="ae jk" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调算法</a>进行比较。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/de5251227210b2d7d0711ea06700b526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX8ofeoyjLAyrGkBuiMqxA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 1 — React workflow</figcaption></figure><p id="3dd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型(图1)是一个由<a class="ae jk" href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree" rel="noopener ugc nofollow" target="_blank"> React元素</a>组成的树，每个React元素都有一个类型。它可以是字符串、反应组件或反应函数。图2中提供了React模型的示例。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kb"><img src="../Images/c97bbcd50012c755ab5c8d432c8c101e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Jgxvx1N_IAqnyPq0NUKFQ.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 2 — React Elements</figcaption></figure><p id="d54f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有意使用纯JS来代替JSX语法，但是使用JSX语法的同一个模型看起来是这样的(图3):</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kc"><img src="../Images/7687946a7a644f907dfea437926e7ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhE5EDnd5A0rhdbKdjJMbQ.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 3 — React model with Pure JS and JSX syntax</figcaption></figure><p id="7ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">协调算法</em>根据类型比较每个React元素。当我们需要呈现一个由<em class="kd"> N </em>个同质React元素组成的列表时，困难就出现了，在我们的例子中，我们呈现了两个类型为<em class="kd"> Item </em>的React元素。</p><p id="7394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想象一下，在应用程序初始化期间，我们需要显示三个项目。用户正在删除索引为0的第一个项目(图4)。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ke"><img src="../Images/228690b4ff2d79161bc7a22e950a5209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZarR1uLKPUQzkImu1yuFQ.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 4 — Transition between states after deleting the first item in the list</figcaption></figure><p id="12aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于所有React元素都具有相同的类型，React无法理解我们的意图。在这种情况下，它会逐个比较每个项目(图5)。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kf"><img src="../Images/9769296ed7402eb9cbeb3058d9724422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlMXvjZ0DgPc4g0ms0gUxA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 5 — Defining DOM operations for transition</figcaption></figure><p id="d9d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到，React定义了3种针对真实DOM的操作。我们可以认为这是一个优化的吗？肯定不是。在这种情况下，只有一个操作就足够了——我们只需要从DOM中删除第一个节点。钥匙在这里就位。</p><p id="8a7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将每一项与一个唯一且稳定的键相关联。通常，它是来自DB的一个项目的ID。在这种情况下，键有助于React识别哪些项目已经更改、添加或删除(图6)。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kg"><img src="../Images/6c9ea444a6f92ae7c7ed829608b32cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ql6RX36CDwmh2GdHDMu5ug.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 6 — An optimized bunch of DOM manipulation for transition</figcaption></figure><p id="adaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们帮助React根据惟一的键将数组中每个组件的确切位置从先前状态匹配到当前状态时，它可能会计算出一组更优化的DOM操作。在图6中，您可以看到react代替了3个操作(图5 ),只需要完成DOM操作。此外，让我们看看图5，问问自己，如果一个列表包含数百万个条目，并且用户正在删除列表中的第一个条目，React将完成多少个操作？</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="f8b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">功能中断</strong></p><p id="1905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一节中，我们解释了key可以帮助React使DOM更新更有效。但是错误的键定义可能会导致应用程序错误。</p><p id="2248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开发一个应用程序，其中我们需要呈现一个用户列表。默认情况下，每个用户条目都是折叠的，如果您想获得更多的细节，您只需要点击它(图7)。此外，该应用程序还允许删除用户条目。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kh"><img src="../Images/0e5f0699eebfc2e5b30c4b76815a35fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9xboyrlN3oIIxTuZhgSew.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">FIgure 7 — Application functionality</figcaption></figure><p id="7ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里没什么难的:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="c8bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这里我们将item key定义为一个数组索引(第20行)。</p><p id="6060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个用户组件都有一个内部状态，允许将状态从<strong class="ih hj"><em class="kd"/></strong>变为<strong class="ih hj"><em class="kd"/></strong>。</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="509c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了玩一会儿，我为你准备了代码沙箱:<a class="ae jk" href="https://codesandbox.io/s/react-key-as-array-index-kn58z?file=/src/components/User.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/react-key-as-array-index-kn58z</a></p><p id="c868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里我们引入了一个bug。图8提供了再现它的过程。假设我们有3个折叠的用户。我们希望看到第二个用户(Marry)的具体细节，我们单击折叠按钮。然后，让我们删除第二个打开的项目。正如你可能看到的，我们不再看到结婚项目，但彼得是打开的，尽管如此，我们以前没有打开这个项目。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kk"><img src="../Images/109978faf45e59027b6cf03cd35a5b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCVr_j473IeoxckPSZzKXw.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 8 — Steps to reproduce the bug</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kl"><img src="../Images/b6c52438ff74c9c98a1717766ec3c257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_994PCQ2EJkFKQt50vHDbA.gif"/></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 9 — Steps to reproduce the bug</figcaption></figure><p id="ddc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么会发生这种情况？您已经看到了这个案例(图5)。因为我们将每个组件与一个数组索引相关联，所以react只是基于它的索引逐个比较每个节点。在前一个状态中，第二个位置(索引1)使用props Marry获取用户组件，我们将内部状态从<em class="kd">假</em>切换到<em class="kd">真</em>。当我们删除Marry item时，第二个位置接受用户组件，但是带有新的道具Peter(图9)。由于新状态只有两个元素，React完全删除了第三个用户元素。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es km"><img src="../Images/d10c2d6190c515ab95a7e48e2b89a26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q01H0Z4--bitVCQUuwasnQ.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 10 — Transition between state, when keys assign as an array index</figcaption></figure><p id="9a44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们需要使用user-id，而不是使用键作为数组索引(第6行):</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="e5f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React然后构建以下更新列表:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kn"><img src="../Images/e15fd36f128190196f1df728f112abc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFsBmPLd70-WjgMdgDiqhg.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 10 — Transition between states, when keys assign as unique and stable values</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kl"><img src="../Images/06bd10f65c061349758bfc8344b4d61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*spC40r-2lU_oTaqGLlv2kw.gif"/></div><figcaption class="jx jy et er es jz ka bd b be z dx">Figure 11 — Get rid of bug when used for ket unique and stable value</figcaption></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="55e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不要忽略开发模式下的警告信息</strong></p><p id="0fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当您忘记输入同构组件列表的键时，React会警告您:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ko"><img src="../Images/e371c966835944a8c0a8e103ca02fc37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-gDPtzwi7WrGVQTHfTVCQ.png"/></div></div></figure><p id="9a50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P.S .嗯，实际上使用id作为键，并不是在所有地方都有必要。如果您正在开发一个不应该从一种状态改变到另一种状态的项目列表，那么使用索引数组是可以的。例如，用于过滤器的选择器，其中定义了所有项目，并且在用户交互期间从不更改。但是，如果条目列表应该具有删除、重新排序、添加新条目的功能，在这种情况下，您必须以适当的方式处理这个键，以避免任何性能问题和意外的错误。</p></div></div>    
</body>
</html>
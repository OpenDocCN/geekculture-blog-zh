<html>
<head>
<title>Create an API Gateway Using NodeJS and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS和Express创建API网关</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-an-api-gateway-using-nodejs-and-express-933d1ca23322?source=collection_archive---------0-----------------------#2021-04-17">https://medium.com/geekculture/create-an-api-gateway-using-nodejs-and-express-933d1ca23322?source=collection_archive---------0-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="afc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您有一堆正在管理的API端点，比如一个大型的微服务集合。也许在某些时候，您希望对路由到您的服务的请求有更多的控制，但是您真的不想单独管理每一个微服务。这就是API网关的用武之地。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ebbef5a3e5f3a9f6e18585e9190a8a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vBBQoqJErD_C9k1Q.png"/></div></div></figure><p id="dbd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API网关的目标是在客户端和您的微服务之间提供一个中间层。通过引入API网关，客户端将请求发送到网关，网关将确保请求被重定向到相应的微服务。这样，API网关可以对传入的请求执行额外的检查和验证，比如身份验证检查、指标收集、消息验证、响应转换、速率限制等等</p><p id="6b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我想展示如何使用NodeJS创建一个非常基本的API网关。在开始实现之前，让我们先看看我们的用例。在本帖中，我们将实现一个可以部署在市场基础设施中的API网关。这个API网关的目标是检查传入的请求，并确保高级服务只能由帐户中有足够信用的用户访问。如果不是这种情况，请求应该被阻止执行。在给定的场景中，这可以归结为以下要求:</p><ul class=""><li id="4e9b" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">所有传入的请求都应该被重定向到一个微服务。</li><li id="3fc6" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">一些路由只允许经过身份验证的请求，其他路由不需要有效的身份验证就可以访问(例如文档端点)。</li><li id="c2cc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们的免费服务需要限速，以减轻我们后端的负担。</li><li id="d8b1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">高级服务要求用户在他们的帐户中有信用以便执行请求。</li></ul><p id="8448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">免责声明— </strong>本帖包含使用Express创建DYI API网关的方法。在企业环境中，最好使用专用工具和软件来实现这一点。一些示例包包括:</p><ul class=""><li id="e25d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">孔(【https://konghq.com/】)</li><li id="7d34" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">特拉菲克(【https://traefik.io/】T4)</li><li id="b7dd" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">F5(<a class="ae kd" href="https://www.f5.com/" rel="noopener ugc nofollow" target="_blank">https://www.f5.com/</a>)</li><li id="6049" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi">…</li></ul><h1 id="c23a" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">先决条件</h1><p id="520a" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在这篇文章的代码中，我们将使用键盘锁(<a class="ae kd" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank">https://www.keycloak.org/</a>)来支持用户授权。有许多关于如何设置Keycloak环境的在线资源。然而，本文中的代码可以在任何支持与NodeJS集成的访问和身份工具中重用。这意味着您可以只替换代码的身份验证部分，以符合您自己的系统。</p><h1 id="0cf3" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">设置✏️</h1><p id="f2c3" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">首先，我们从设置项目和安装正确的依赖项开始。对于我们的API网关的基础，我们将使用一个Express服务器。所以让我们从设置项目和安装Express开始。为此，请执行以下命令:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="9977" class="lm kf hi li b fi ln lo l lp lq">npm init<br/>npm install express --save</span></pre><p id="dd99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了！现在我们可以开始设置我们的基本Express服务器了。为什么不设置一个hello world端点来查看一切是否如我们所预期的那样工作呢？作为任何值得尊敬的程序员，我们需要从一个hello world示例开始…这意味着创建一个名为<em class="lr">server . js</em><strong class="ih hj"><em class="lr"/></strong>的文件，并添加以下代码:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="3c24" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><em class="lr"><br/><br/></em>app.get('/hello', (req, resp) =&gt; {<br/>    <em class="lr">return </em>resp.send('HELLO WORLD!');<br/>})<br/><br/>app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="1a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过运行以下命令之一来测试我们的服务器:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="7b43" class="lm kf hi li b fi ln lo l lp lq">node server.js</span><span id="c70c" class="lm kf hi li b fi ls lo l lp lq">//or</span><span id="4d49" class="lm kf hi li b fi ls lo l lp lq">npm run start</span></pre><p id="d482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">证据就在布丁中，所以打开你的浏览器，导航到<a class="ae kd" href="http://localhost:3000/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello</a>和TADA🎉。你现在可以开始你的庆祝舞蹈了💃</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/45927e52947be91bfac1d3267f4f1eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkwrUTo1PIfoVgM137Tgkw.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/654943ddf5fc4ab7ddef34495c689883.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Qiu_GZhqLl-U1YFbghTN2A.gif"/></div></figure><p id="6ad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，是时候加快步伐了！实现的下一步是向我们的服务器添加不同的特性，以便创建我们的API网关。</p><h1 id="e6b0" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">伐木📓</h1><p id="036c" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们想要添加的第一个特性是记录关于传入请求的信息。这不仅有助于调试，而且有助于收集API网关处理的请求的指标。</p><p id="2b86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们将使用<em class="lr">摩根</em>库(<a class="ae kd" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/morgan</a>)。<em class="lr"> Morgan </em>允许我们用日志功能扩展我们的Express服务器。<em class="lr"> Morgan </em>还支持apache like logging，这使得它很容易集成到现有的日志收集框架中，比如ELK stacks。</p><p id="75f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先在您现有的NodeJS项目中安装<em class="lr"> morgan </em>:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="118c" class="lm kf hi li b fi ln lo l lp lq">npm install morgan --save</span></pre><p id="6379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们创建一个单独的<em class="lr"> logging.js </em>文件来配置我们的日志设置，并通过一个函数导出它们。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="453d" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const morgan </em>= require("morgan");<br/><br/><em class="lr">const </em>setupLogging = (app) =&gt; {<br/>    app.use(<em class="lr">morgan</em>('combined'));<br/>}<br/><br/>exports.setupLogging = setupLogging</span></pre><p id="4eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以将我们的函数包含到现有的<em class="lr"> server.js i </em> n中，以便启用请求日志记录:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="3371" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><strong class="li hj"><em class="lr">const </em>{setupLogging} = require("./logging");</strong><br/><br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><br/><br/><strong class="li hj">setupLogging(app);</strong></span><span id="3439" class="lm kf hi li b fi ls lo l lp lq">app.get('/hello', (req, resp) =&gt; {<br/>    <em class="lr">return </em>resp.send('HELLO WORLD!');<br/>})</span><span id="80d6" class="lm kf hi li b fi ls lo l lp lq">app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="bcd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在重启服务器并刷新浏览器，我们可以看到请求被记录在服务器的控制台中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/7716bfebd513f53430e842b8172782af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Q6z3JC9SLkZGko4JVpJww.png"/></div></div></figure><h1 id="2a98" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">配置🔑</h1><p id="c1af" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在我们继续集成其他特性之前，我们将首先创建我们希望在API网关中支持的不同路由的配置。根据应启用的功能，每条路径可以有多个属性。如何配置这些属性将在专门介绍不同功能的章节中解释。</p><p id="1638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建配置，创建一个新的<em class="lr">routes . js</em><strong class="ih hj"><em class="lr"/></strong>文件，其内容如下:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="2d21" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>ROUTES = [<br/>    {<br/>        url: '/free',<br/>        auth: <em class="lr">false</em>,<br/>        creditCheck: <em class="lr">false</em>,<br/>        rateLimit: {<br/>            windowMs: 15 * 60 * 1000,<br/>            max: 5<br/>        },<br/>        proxy: {<br/>            target: "https://www.google.com",<br/>            changeOrigin: <em class="lr">true</em>,<br/>            pathRewrite: {<br/>                [`^/free`]: '',<br/>            },<br/>        }<br/>    },<br/>    {<br/>        url: '/premium',<br/>        auth: <em class="lr">true</em>,<br/>        creditCheck: <em class="lr">true</em>,<br/>        proxy: {<br/>            target: "https://www.google.com",<br/>            changeOrigin: <em class="lr">true</em>,<br/>            pathRewrite: {<br/>                [`^/premium`]: '',<br/>            },<br/>        }<br/>    }<br/>]<br/><br/>exports.ROUTES = ROUTES;</span></pre><p id="adc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我们确定了两条路由，一条代表免费(/free)服务的端点，另一条代表高级(/premium)服务。每个服务都可以有以下属性:</p><ul class=""><li id="3fea" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj"> url </strong> —与传入请求匹配的url路径。这可以是Express支持的任何路径。这意味着它还可以包含通配符来匹配多个路径。</li><li id="4fb4" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj"> auth </strong> —布尔值，表示用户是否需要通过身份验证才能访问此端点。</li><li id="e602" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">信用检查</strong> —布尔值，表示是否需要对该请求执行信用检查。</li><li id="8ada" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj"> rateLimit </strong> —对服务进行速率限制的配置。</li><li id="2663" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">代理</strong> —代理配置，包含关于请求应该重定向到的目标的信息</li></ul><h1 id="67e5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">代理人📩</h1><p id="7771" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">接下来，我们要设置应该应用于传入请求的代理规则。这是一个重要的特性，因为我们的API网关将负责把传入的请求重定向到实际的微服务。</p><p id="c79c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用一个名为<em class="lr">http-proxy-middleware</em>(<a class="ae kd" href="https://www.npmjs.com/package/http-proxy-middleware" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/http-proxy-middleware</a>)的现有库来为我们的路由配置不同的代理规则。通过执行以下命令来安装它:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="8345" class="lm kf hi li b fi ln lo l lp lq">npm install http-proxy-middleware --save</span></pre><p id="4b52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们创建一个单独的<em class="lr"> proxy.js </em>文件，它将为我们的路由创建代理。该文件的内容如下:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="de5d" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>{ <em class="lr">createProxyMiddleware </em>} = require('http-proxy-middleware');<br/><br/><em class="lr">const </em>setupProxies = (app, routes) =&gt; {<br/>    routes.forEach(r =&gt; {<br/>        app.use(r.url, <em class="lr">createProxyMiddleware</em>(r.proxy));<br/>    })<br/>}<br/><br/>exports.setupProxies = setupProxies</span></pre><p id="859d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能注意到了，这里没发生什么事情。这个代码片段所做的唯一一件事就是为我们配置中的每条路由添加了<em class="lr"> createProxyMiddleware </em>。这确实是所有的人！我们唯一需要做的就是将正确的代理配置添加到我们的<em class="lr"> routes.js </em>配置文件中。你可以使用文档(<a class="ae kd" href="https://www.npmjs.com/package/http-proxy-middleware" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/http-proxy-middleware</a>)来查看不同的选项。如果您习惯使用Angular、Apache或httpd配置，您会注意到许多相似之处。</p><p id="0c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩下唯一要做的就是将代理配置集成到我们的主服务器中。这可以通过将以下代码添加到我们的<em class="lr"> server.js </em>文件中来实现:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="8af4" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><br/><strong class="li hj"><em class="lr">const </em>{ROUTES} = require("./routes");</strong><br/><br/><em class="lr">const </em>{setupLogging} = require("./logging");<br/><strong class="li hj"><em class="lr">const </em>{setupProxies} = require("./proxy");</strong><br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><br/><br/>setupLogging(app);<br/><strong class="li hj">setupProxies(app, ROUTES);</strong><br/><br/>app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="f485" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们已经删除了hello world端点。我们现在进入了更高级的领域，所以不再需要hello world了😉</p><p id="b233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们重启服务器，我们可以通过导航到配置中的一个URL来测试代码。在这个例子中，你会注意到两者都会将你重定向到Google网站。您可以将<em class="lr"> routes.js </em>更改为任何主机和端口组合的代理，并将其与一些奇特的路径重写相结合。</p><h1 id="60e1" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">证明🙈</h1><p id="cb55" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">是时候向我们的API网关添加身份验证了。我们配置中的一些路由将要求在请求中包含有效的用户身份验证，以便允许进一步执行。正如先决条件中提到的，我们将依赖Keycloak来验证传入请求的访问令牌。</p><p id="2381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Keycloak已经通过【https://www.npmjs.com/package/keycloak-connect】的<em class="lr">key cloak-connect</em>(<a class="ae kd" href="https://www.npmjs.com/package/keycloak-connect" rel="noopener ugc nofollow" target="_blank">T5)模块支持快速集成。让我们从所需模块的安装开始:</a></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ae24" class="lm kf hi li b fi ln lo l lp lq">npm install keycloak-connect express-session --save</span></pre><p id="3ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们创建一个名为<em class="lr"> auth.js </em>的单独文件，以便配置我们的身份验证，并将不同的规则应用于我们的配置路由:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="0210" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>Keycloak = require('keycloak-connect');<br/><em class="lr">const session </em>= require('express-session');<br/><br/><em class="lr">const </em>setupAuth = (app, routes) =&gt; {<br/>    <em class="lr">var </em>memoryStore = <em class="lr">new session</em>.MemoryStore();<br/>    <em class="lr">var </em>keycloak = <em class="lr">new </em>Keycloak({ store: memoryStore });<br/><br/>    app.use(<em class="lr">session</em>({<br/>        secret:'&lt;RANDOM GENERATED TOKEN&gt;',<br/>        resave: <em class="lr">false</em>,<br/>        saveUninitialized: <em class="lr">true</em>,<br/>        store: memoryStore<br/>    }));<br/><br/>    app.use(keycloak.middleware());<br/><br/>    routes.forEach(r =&gt; {<br/>        <em class="lr">if </em>(r.auth) {<br/>            app.use(r.url, keycloak.protect(), <em class="lr">function </em>(req, res, next) {<br/>                next();<br/>            });<br/>        }<br/>    });<br/>}<br/><br/>exports.setupAuth = setupAuth</span></pre><p id="e935" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的文件中，我们定义了一个名为<em class="lr"> setupAuth </em>的函数，它将express应用程序和我们的路线配置作为输入参数。为了启用Keycloak集成，我们需要创建一个新的内存存储，设置应用程序以使用会话并激活Keycloak中间件。接下来，我们可以通过下面的代码片段来保护我们的端点:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ab7a" class="lm kf hi li b fi ln lo l lp lq">app.use(r.url, keycloak.protect(), <em class="lr">function </em>(req, res, next) {<br/>      next();<br/>});</span></pre><p id="8141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码在指定的URL上添加了Keycloak中间件(<em class="lr"> keycloak.protect() </em>)。添加了一个额外的回调函数，使我们能够向代码添加额外的日志记录。在这种情况下，我们只需调用<em class="lr"> next() </em>函数，该函数告诉Express继续处理请求。</p><p id="5966" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使Keycloak集成工作，我们还需要一个额外的配置文件，其中包含一些特定于Keycloak的信息。有关设置的更多信息，请参考官方的Keycloak文档。下面是在这个项目中使用的一个示例<em class="lr"> keycloak.json </em>配置:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="08d7" class="lm kf hi li b fi ln lo l lp lq">{<br/>  "realm": "&lt;REALM&gt;",<br/>  "bearer-only": true,<br/>  "auth-server-url": "&lt;AUTH_URL&gt;",<br/>  "ssl-required": "external",<br/>  "resource": "&lt;CLIENT&gt;",<br/>  "confidential-port": 0<br/>}</span></pre><p id="724f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是将认证设置包含到我们的主服务器中。我们可以通过用以下代码更新我们的<em class="lr"> server.js </em>文件来做到这一点:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="cc13" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><br/><em class="lr">const </em>{ROUTES} = require("./routes");<br/><br/><em class="lr">const </em>{setupLogging} = require("./logging");<br/><em class="lr">const </em>{setupProxies} = require("./proxy");<br/><strong class="li hj"><em class="lr">const </em>{setupAuth} = require("./auth");</strong><br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><br/><br/>setupLogging(app);<br/><strong class="li hj">setupAuth(app, ROUTES);</strong><br/>setupProxies(app, ROUTES);<br/><br/>app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="773f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新启动服务器后，您会注意到导航到高级URL(<a class="ae kd" href="http://localhost:3000/premium" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/premium</a>)将会出现一个“拒绝访问”页面。但是，免费的网址(<a class="ae kd" href="http://localhost:3000/free" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/free</a>)仍然可以访问👍。您可以使用Postman之类的工具向您的请求添加一个访问令牌，以便检查Keycloak集成是否正在工作。在这种情况下，当对高级url执行GET请求时，Postman还应该显示Google网站。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/b671b6400bb26972214dbf468cd90255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_Dc5ErupzhOvMC83k4EWw.png"/></div></div></figure><h1 id="70b5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">限速⛔️</h1><p id="9867" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们实施的下一阶段将为我们的网关端点添加速率限制。在我们的例子中，我们将对我们的免费服务应用速率限制。降低某些服务的吞吐量可以带来多种好处，例如降低某些微服务的负载并对其进行更好的控制，鼓励用户购买额外服务以消除吞吐量限制等</p><p id="613d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经实现的其他功能一样，已经有一个名为<em class="lr">express-rate-limit</em>(<a class="ae kd" href="https://www.npmjs.com/package/express-rate-limit" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/express-rate-limit</a>)的NPM库，可用于将速率限制集成到现有的Express服务器中。可以通过执行以下命令来安装它:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ff18" class="lm kf hi li b fi ln lo l lp lq">npm install --save express-rate-limit</span></pre><p id="6d7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装完成后，我们继续开发，创建一个单独的<em class="lr"> ratelimit.js </em>文件，包含以下内容:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="c5fa" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const rateLimit </em>= require("express-rate-limit");<br/><br/><em class="lr">const </em>setupRateLimit = (app, routes) =&gt; {<br/>    routes.forEach(r =&gt; {<br/>        <em class="lr">if </em>(r.rateLimit) {<br/>            app.use(r.url, <em class="lr">rateLimit</em>(r.rateLimit));<br/>        }<br/>    })<br/>}<br/><br/>exports.setupRateLimit = setupRateLimit</span></pre><p id="ef62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将再次注意到它看起来与其他特性的实现非常相似。上面的代码片段遍历了所有路由，并添加了一个速率限制中间件(如果适用于给定的url)。提供给限速中间件的设置可以在模块(<a class="ae kd" href="https://www.npmjs.com/package/express-rate-limit" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/express-rate-limit</a>)的文档中找到，并直接从<em class="lr"> routes.js </em>文件中的路由配置中读取。</p><p id="280f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们查看<em class="lr"> routes.js </em>配置，我们可以看到我们通过指定以下属性对免费路由应用了速率限制:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="6be6" class="lm kf hi li b fi ln lo l lp lq">rateLimit: {<br/>    windowMs: 15 * 60 * 1000,<br/>    max: 5<br/>},</span></pre><p id="4c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些设置将对端点的请求限制为每15分钟最多5个请求。</p><p id="4163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要在创建服务器时激活速率限制设置。这可以通过用以下内容扩展<em class="lr"> server.js </em>文件来实现:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="1402" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><br/><em class="lr">const </em>{ROUTES} = require("./routes");<br/><br/><em class="lr">const </em>{setupLogging} = require("./logging");<br/><strong class="li hj"><em class="lr">const </em>{setupRateLimit} = require("./ratelimit");</strong><br/><em class="lr">const </em>{setupProxies} = require("./proxy");<br/><em class="lr">const </em>{setupAuth} = require("./auth");<br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><br/><br/>setupLogging(app);<br/><strong class="li hj">setupRateLimit(app, ROUTES);</strong><br/>setupAuth(app, ROUTES);<br/>setupProxies(app, ROUTES);<br/><br/>app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="ce9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来测试我们的解决方案。重启你的服务器，并转到位于<a class="ae kd" href="http://localhost:3000/free" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/free</a>的免费端点。什么都没变，对吧？现在刷新页面几次。刷新5次左右，会看到一条错误信息:“请求太多，请重试”。我们现在已经通过应用速率限制成功地限制了我们服务的吞吐量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/1aafd05f1e19d2ca1ce47957b4dd89bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T33iDwTlZ_JwKCBgAN28BQ.png"/></div></div></figure><h1 id="1473" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">信用检查💰</h1><p id="d65f" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们要添加的最后一件事是对高级端点的请求进行信用检查。如果用户在他/她的帐户中没有足够的信用来执行请求，它应该被阻止。</p><p id="eb53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在本帖中，我们将创建一个信用检查示例的更通用的实现。本章的目标是创建任何类型的中间件，在重定向或阻塞请求之前，您需要在其中进行额外的检查。</p><p id="dc62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在前面的段落中可能已经注意到的，我们总是利用Express中间件来将它们组合到一个请求评估/执行链中。Express允许我们创建一个定制的中间件，并将其添加到验证链中。每个中间件都被定义为一个功能:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="9b04" class="lm kf hi li b fi ln lo l lp lq">function(request, response, next) {</span><span id="0c6a" class="lm kf hi li b fi ls lo l lp lq">    // Add custom code here</span><span id="223e" class="lm kf hi li b fi ls lo l lp lq">}</span></pre><p id="022f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在中间件函数中，你可以访问<em class="lr">请求</em>和<em class="lr">响应</em>对象，以及一个名为<em class="lr"> next </em>的函数。在中间件的执行过程中，您有几种选择:</p><ul class=""><li id="e911" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">通过<em class="lr"> response </em>对象向客户端发送响应来结束请求的处理，例如:</li></ul><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="8051" class="lm kf hi li b fi ln lo l lp lq">res.status(500).send({error});</span></pre><ul class=""><li id="7b9b" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">完成中间件，然后继续链中的下一个中间件。这就是<em class="lr"> next() </em>函数的用武之地。它告诉Express您的中间件没有遇到任何错误，它可以通过下一个中间件继续评估请求。</li></ul><p id="92c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在让我们把这个付诸实践。在我们的示例中，我们希望对每个传入的请求进行信用检查。我们首先创建一个函数，它将在名为<em class="lr"> creditcheck.js. </em>的文件中执行实际的信用检查</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="d655" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>checkCredit = (request) =&gt; {<br/>    <em class="lr">return new </em>Promise((resolve, reject) =&gt; {<br/>           // Custom code here <br/>           if (ok) {<br/>              resolve();<br/>           } else {<br/>              reject('No credits');<br/>           } </span><span id="d1cf" class="lm kf hi li b fi ls lo l lp lq">    })<br/>}</span></pre><p id="121f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们忽略了信用检查的实际代码实现，因为这可以由任何自定义代码来替换，您可以根据请求对象进行额外的检查。但是，为了测试代码，我们可以编写一些代码，这些代码将导致延迟500毫秒的负信用检查，模拟额外请求的执行:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="10db" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>checkCredit = (req) =&gt; {<br/>    <em class="lr">return new </em>Promise((resolve, reject) =&gt; {<br/>        console.log("Checking credit with token", req.headers["authorization"]);<br/>        <em class="lr">setTimeout</em>(() =&gt; {<br/>            reject('No sufficient credits');<br/>        }, 500);<br/>    })<br/>}</span></pre><p id="1e83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的代码中看到的，我们将拒绝承诺，这表示用户的错误或负信用余额。通过对另一个实际返回信用量的微服务执行任何附加请求，可以很容易地替换这段代码。</p><p id="ed7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的下一步是添加作为中间件的<em class="lr"> creditCheck </em>函数，以便处理我们的传入请求:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="92d7" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>checkCredit = (req) =&gt; {<br/>    <em class="lr">return new </em>Promise((resolve, reject) =&gt; {<br/>        console.log("Checking credit with token", req.headers["authorization"]);<br/>        <em class="lr">setTimeout</em>(() =&gt; {<br/>            reject('No sufficient credits');<br/>        }, 500);<br/>    })<br/>}<br/><br/><strong class="li hj"><em class="lr">const </em>setupCreditCheck = (app, routes) =&gt; {<br/>    routes.forEach(r =&gt; {<br/>        <em class="lr">if </em>(r.creditCheck) {<br/>            app.use(r.url, <em class="lr">function</em>(req, res, next) {<br/>                checkCredit(req).then(() =&gt; {<br/>                    next();<br/>                }).catch((error) =&gt; {<br/>                    res.status(402).send({error});<br/>                })<br/>            });<br/>        }<br/>    })<br/>}<br/><br/>exports.setupCreditCheck = setupCreditCheck</strong></span></pre><p id="e076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码为每个应该执行信用检查的请求引入了一个新的中间件。根据其执行情况，请求将被重定向或阻止。中间件的实际代码包含在以下代码片段中:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="f4be" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">function</em>(req, res, next) {<br/>   checkCredit(req).then(() =&gt; {<br/>      next();<br/>    }).catch((error) =&gt; {<br/>      res.status(402).send({error});<br/>    })<br/>});</span></pre><p id="e96e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，我们执行<em class="lr"> creditCheck </em>函数并等待其结果。如果解析正确，我们通过调用<em class="lr"> next() </em>函数通知Express中间件已经成功执行。如果信用检查被拒绝，我们就停止处理请求，并向客户机发回一个响应。</p><p id="a6c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们实现的最后一步是将信用检查配置添加到服务器的启动脚本中，从而生成我们最终的<em class="lr"> server.js </em>文件:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="c8ff" class="lm kf hi li b fi ln lo l lp lq"><em class="lr">const </em>express = require('express')<br/><br/><em class="lr">const </em>{ROUTES} = require("./routes");<br/><br/><em class="lr">const </em>{setupLogging} = require("./logging");<br/><em class="lr">const </em>{setupRateLimit} = require("./ratelimit");<br/><strong class="li hj"><em class="lr">const </em>{setupCreditCheck} = require("./creditcheck");</strong><br/><em class="lr">const </em>{setupProxies} = require("./proxy");<br/><em class="lr">const </em>{setupAuth} = require("./auth");<br/><br/><em class="lr">const </em>app = express()<br/><em class="lr">const </em>port = 3000;<br/><br/><br/>setupLogging(app);<br/>setupRateLimit(app, ROUTES);<br/>setupAuth(app, ROUTES);<br/><strong class="li hj">setupCreditCheck(app, ROUTES);</strong><br/>setupProxies(app, ROUTES);<br/><br/>app.listen(port, () =&gt; {<br/>    console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="da1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩下唯一要做的就是重启服务器，信用检查将应用于您的<em class="lr"> routes.js </em>配置中的相关路由。您也可以通过为您的免费路线启用来轻松测试信用检查。如果您重新启动服务器并导航到免费URL(<a class="ae kd" href="http://localhost:3000/free" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/free</a>)，您将会收到一条消息，提示您没有足够的点数👍。</p><p id="9140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请记住</strong>我们也对这条路线应用了限速，因此您可能会太快，不得不等待15分钟或一起禁用限速。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/d6b4eb65f5fdf256e92cbed8ada22eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSZdg2cqomir-a9U8mGrMw.png"/></div></div></figure><h1 id="a687" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">全部完成！👍</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/b7cef073d5eb49ff5766ba75a103308d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6UG_fkxt4f4UFXrX4lpS8g.gif"/></div></figure><p id="be74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干得好！我们已经创建了自定义API网关实现。你也可以在Github(<a class="ae kd" href="https://github.com/JanssenBrm/api-gateway" rel="noopener ugc nofollow" target="_blank">https://github.com/JanssenBrm/api-gateway</a>)上找到完整的代码。我希望这篇文章能让你更好地理解如何在Express中使用中间件，并启发你为API网关添加更多有用的特性。继续编码！</p></div></div>    
</body>
</html>
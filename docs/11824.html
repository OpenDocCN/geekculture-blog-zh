<html>
<head>
<title>Managing memory using stack and heap: all you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用堆栈和堆管理内存:您需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/managing-memory-using-stack-and-heap-all-you-need-to-know-8cb0192f5234?source=collection_archive---------4-----------------------#2022-04-11">https://medium.com/geekculture/managing-memory-using-stack-and-heap-all-you-need-to-know-8cb0192f5234?source=collection_archive---------4-----------------------#2022-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈和堆都是专用的内存区域，用于动态分配和取消分配数据——还有<a class="ae jd" href="https://en.wikipedia.org/wiki/Data_segment" rel="noopener ugc nofollow" target="_blank">个其他内存区域</a>可用于在进程初始化时分配静态数据。</p><p id="1ff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将了解堆栈和堆之间的区别，以及不同的解释和编译编程语言是如何使用它们的。我们还将了解哪些数据通常存储在堆栈中，哪些数据通常存储在堆中，以及原因。</p><h1 id="7d42" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">堆栈</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kc"><img src="../Images/edd71cf96076ed0ffcefb0b6d26e7b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/0*__zXoEgCOOmTFj77"/></div></figure><p id="f650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈是一个LIFO(后进先出)内存区域，通常用于存储执行函数所需的信息，包括:局部变量、返回地址、为被调用者传递的参数以及实现者可能决定的任何内容。</p><p id="1b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用一个函数会使堆栈的大小增加一层，这一层称为堆栈框架，这一层将拥有执行这个特定函数的必要信息，并将执行结果返回给调用函数。</p><p id="b79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为对堆栈的操作是以LIFO方式进行的，这意味着分配和取消分配只是将索引增加/减少一个特定的长度，现代cpu架构提供了专用的寄存器和指令集来操作堆栈。</p><p id="3e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仔细观察前面的陈述，你会发现它的基本意思如下:</p><ul class=""><li id="4c0b" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated">您只能分配预先知道其大小的数据——这在理论上适用于动态数据，例如，如果解释器/编译器可以看到在函数的整个生命周期中添加的元素不超过四个，那么解释器/编译器可能会分配一个最初在堆栈上填充了一个元素的数组</li><li id="bf07" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">分配和释放非常简单快速，只需要改变索引</li><li id="618c" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">读取和修改堆栈中的信息也很简单快速，这是一个索引访问的问题</li></ul><p id="f6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从编程语言的角度来看，这三点实质上是堆栈的定义特征，这意味着固定大小的数据(例如整数、字符串)通常存储在堆栈中。</p><p id="903a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种编程语言是否可能决定只放固定大小的数据或动态大小的数据是一个实现细节，但是通常许多编程语言将决定只把固定大小的数据放在堆栈上，因为确定动态大小的数据的最大大小是不容易/不可行的。</p><p id="45eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面这个用想象力丰富的语言编写的函数——它看起来很像javascript:</p><pre class="kd ke kf kg fd ky kz la lb aw lc bi"><span id="7521" class="ld jf hi kz b fi le lf l lg lh">function mySum() {</span><span id="12f4" class="ld jf hi kz b fi li lf l lg lh">  const arr = []</span><span id="de79" class="ld jf hi kz b fi li lf l lg lh">  arr.push(1, 2);</span><span id="c8d6" class="ld jf hi kz b fi li lf l lg lh">  return arr[0] + arr[1]</span><span id="97e3" class="ld jf hi kz b fi li lf l lg lh">}</span></pre><p id="4063" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的数组<code class="du lj lk ll kz b">arr</code>是动态大小的，但是编译器/解释器可能决定看到它的最大大小为2，这取决于在堆栈或堆上分配数组的实现，但是我们的函数通常要复杂得多，所以想想这个例子:</p><pre class="kd ke kf kg fd ky kz la lb aw lc bi"><span id="cea0" class="ld jf hi kz b fi le lf l lg lh">function myMultiplication() {</span><span id="cb18" class="ld jf hi kz b fi li lf l lg lh">  const arr = [1,2]</span><span id="9460" class="ld jf hi kz b fi li lf l lg lh">  return multi(arr)</span><span id="879c" class="ld jf hi kz b fi li lf l lg lh">}</span></pre><p id="d087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为数组的大小是动态的，所以我们不知道multi会对它做什么。本质上，虽然在堆栈上分配是为了知道某个数据的最大大小，但实际上很难区分初始大小和最大大小，因此通常只有固定初始大小的数据才会在堆栈上分配。当然总会有一些例外，例如C中的<a class="ae jd" href="https://en.wikipedia.org/wiki/Variable-length_array" rel="noopener ugc nofollow" target="_blank">可变长度数组</a>被分配到堆栈上，即使它们是动态大小的数据。</p><blockquote class="lm ln lo"><p id="dabc" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><strong class="ih hj">堆栈与调用堆栈</strong>完全不同，调用堆栈是语言相关的，不同语言之间它做什么和如何做有很大不同。堆栈是一个LIFO内存区域，它适合于实现某些调用堆栈功能，但也可以用于实现者认为合适的任何事情，例如反转字符串。</p></blockquote><p id="4e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用堆栈通常与堆栈相关联，因为使用堆栈来支持调用堆栈的功能是有意义的，但情况并非总是如此，仅有堆栈可能是不够的。</p><p id="e852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以这段javascript代码为例:</p><pre class="kd ke kf kg fd ky kz la lb aw lc bi"><span id="223a" class="ld jf hi kz b fi le lf l lg lh">function outer() {<br/>  const z = 3;<br/>  function inner() {<br/>    console.log(z)<br/>  }</span><span id="9bc0" class="ld jf hi kz b fi li lf l lg lh">  setTimeout(inner, 10)<br/>}</span></pre><p id="8a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果你运行<code class="du lj lk ll kz b">outer</code>，会发生什么？当<code class="du lj lk ll kz b">inner</code>运行时，<code class="du lj lk ll kz b">outer</code>已经执行完了，<code class="du lj lk ll kz b">inner</code>应该抛出一个错误还是只记录3？</p><p id="4368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Javascript内存模型要在堆栈上分配<code class="du lj lk ll kz b">z</code>变量，那么当<code class="du lj lk ll kz b">outer</code>完成执行时<code class="du lj lk ll kz b">z</code>将被释放，而<code class="du lj lk ll kz b">inner</code>将抛出一个错误。然而<code class="du lj lk ll kz b">inner</code>实际上会记录3，本质上这是一个闭包的例子，闭包是一个不被栈直接支持的特性；应该用栈之外的东西来实现它，甚至完全不用栈来实现它。</p><h1 id="5981" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">垃圾堆</h1><p id="239e" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">如果堆栈通常用于分配固定大小的数据，那么堆通常用于分配动态大小的数据。与堆栈不同，分配和释放需要的不仅仅是增加/减少一个索引。</p><p id="c6ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆和栈都是内存中的连续区域，通常它们以相反的方向增长，并且彼此相邻。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es ly"><img src="../Images/58576c2e9f577359139ed81e5dbe74a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/0*5YBljuulZEbUyk1s"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">An example of stack and heap layout in a memory region</figcaption></figure><p id="86b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着你可以很容易地把它们想象成一个数组。举个例子，我们的堆是一个从0到99的100个槽的数组。假设该进程请求10个槽，然后20个，然后30个，然后该进程请求释放前10个槽。所以我们会有这样的东西<code class="du lj lk ll kz b">[10 empty slots, 20 used slots, 30 used slots, 40 empty slots]</code>，现在假设进程需要50个线性槽，我们的堆有50个空槽(前10个和后40个)，但是现在虽然堆有50个空槽，但是它不能将它们授予进程。</p><p id="aca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我刚才描述的是一个称为内存碎片的问题，必须解决这个问题才能使堆分配有效，解决这个问题需要分配和取消分配时的开销，这是为什么在堆栈中分配和取消分配更有效的主要原因——当然，除此之外，在堆栈中分配和取消分配可能有硬件支持。</p><p id="3330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这种开销，现代编程语言试图动态地分配和释放堆栈上容易/可行的东西，以及堆上的其他东西。</p><p id="7de3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这篇文章对你有用吗？拍手声👏它，并帮助他人找到这篇文章。</strong></p></div></div>    
</body>
</html>
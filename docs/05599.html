<html>
<head>
<title>AWS Step Function Training Pipeline for Time series forecasting model using Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于张量流的时间序列预测模型的AWS阶跃函数训练管道</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/aws-step-function-pipeline-for-time-series-forecasting-model-using-tensorflow-d993abc10ddc?source=collection_archive---------13-----------------------#2021-07-26">https://medium.com/geekculture/aws-step-function-pipeline-for-time-series-forecasting-model-using-tensorflow-d993abc10ddc?source=collection_archive---------13-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/89c4afda57685f9419772fa07565a0b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Q7R9cVkdovxo1ZN-Wb4JjQ.jpeg"/></div></figure><p id="d8c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我和一个推荐引擎一起工作，它为用户推荐食物食谱，我们使用推送通知将它发送给用户。然而，不同的用户在一天的不同时间使用该应用程序，这也会在一周和一个月内发生变化。作为这项工作的一部分，我创建了一个深度学习模型，可以预测用户在某一天最有可能使用该应用程序。在这篇分为2部分的文章中，我将更多地强调深度学习管道构建部分，其中第1部分涵盖训练管道，第2部分涵盖推理管道。</p><p id="68b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">端到端训练管道将使用sql获取源数据，预处理数据，使用数据训练Tensorflow GRU模型，并使用该模型创建/更新SageMaker端点。</p><h1 id="8e01" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">特征</h1><p id="0303" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">作为这项研究的一部分，我的假设是，以下功能列表可以帮助预测在某个特定日期用户将使用该应用程序。这些特征可以分为两类。</p><h2 id="fc75" class="ko jm hi bd jn kp kq kr jr ks kt ku jv ix kv kw jz jb kx ky kd jf kz la kh lb bi translated">当前功能</h2><p id="4e22" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">所有这些特征都应该在推断之日计算出来。</p><p id="38c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">星期几</em>:推断访问时间的星期几。<br/> <em class="lc">一月中的某一天</em>:推断拜访时间的一月中的某一天。<br/> <em class="lc">自上次就诊后的天数</em>:自上次就诊后的天数。</p><h2 id="2823" class="ko jm hi bd jn kp kq kr jr ks kt ku jv ix kv kw jz jb kx ky kd jf kz la kh lb bi translated">历史特征</h2><p id="532f" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">所有这些功能都属于用户的最后一次使用。</p><p id="477c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">总花费时间</em>:用户上次访问花费的总时间。<br/> <em class="lc">总浏览量</em>:用户上次访问的总浏览量。<br/> <em class="lc">类型1页面浏览量</em>:用户上次访问的类型1页面浏览量总数。<br/> <em class="lc">第二类页面浏览量</em>:用户上次访问的第二类页面浏览量总数。<br/> <em class="lc">第三类页面浏览量</em>:用户上次访问的第三类页面浏览量总数。<br/> <em class="lc">第4类页面浏览量</em>:用户上次访问的第4类页面浏览量总数。<br/> <em class="lc">第一次就诊时间</em>:最后一次就诊时当天的第一次就诊时间。<br/> <em class="lc">最后就诊时间</em>:最后一次就诊时当天的最后就诊时间。<br/> <em class="lc">每小时的访问量</em>:判断点击是否为每小时新访客的标志。<br/> <em class="lc">星期几</em>:最后一次就诊的星期几。<br/><em class="lc"/>:最后一次访问的日期。<br/><em class="lc"/>:最后一次访问的月份。<br/> <em class="lc">平台</em>:上次访问的用户平台，如iOS或android或其他。</p><h1 id="66e5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">培训渠道</strong></h1><p id="d7f7" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">下面显示的端到端培训管道是使用AWS Step function创建的，这是一种可视化工作流服务，用于自动化AWS服务。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ld"><img src="../Images/a8bbcb2f0de24065e94ba8fb4d925fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*le3OTJhYAfEo7HhLKIJRfQ.png"/></div></div></figure><p id="ff76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，我使用<a class="ae jk" href="https://aws-step-functions-data-science-sdk.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> AWS步骤函数Data Science Python SDK </a>为AWS步骤函数创建工作流定义。AWS步骤功能将通过连接到AWS Athena、AWS s3、AWS Lambda和AWS SageMaker服务来协调工作流程。除了AWS lambda的代码，下面讨论的所有python代码都必须从SageMaker笔记本或本地jupyter python笔记本上运行。</p><p id="9534" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面声明了所有的库和环境变量</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="b57c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于使用用户输入运行的工作流，我们需要预先定义以下值。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="cd47" class="ko jm hi lp b fi lt lu l lv lw">execution_input = ExecutionInput(<br/>schema={<br/>"PreprocessingJobName": str,<br/>"TrainingJobName": str,<br/>"EvaluationProcessingJobName": str,<br/>"ModelName": str,<br/>"EndpointName": str,<br/>"InputFilePath": str<br/>})</span></pre><p id="c617" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di">R</span><strong class="io hj">un source SQL for training data:</strong>这是通过创建一个lambda函数并最终从step函数中调用它来实现的。下面是lambda函数<em class="lc"> ds-StartQueryExecution的代码。</em>该函数从s3位置读取sql文件，并使用<em class="lc">start _ query _ execution</em>API运行sql。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="a60c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们使用下面的代码在step函数中调用这个lambda函数，其中<em class="lc"> LambdaStep </em>调用lambda函数，而<em class="lc"> Catch </em> step捕捉失败，<em class="lc"> Retry </em>在失败的情况下重新调度该步骤。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="6a9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">触发的sql可能是长时间运行的sql，因此要跟踪它，我们需要执行以下任务。</p><p id="27f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di"> W </span>源sql执行的等待:在步骤函数中创建一个等待步骤。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="e555" class="ko jm hi lp b fi lt lu l lv lw">from stepfunctions.steps import Wait<br/>wait_src_query_execution_job =  Wait(state_id="Wait for source sql execution - 30 sec",seconds=30)</span></pre><p id="4a47" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di"> C </span>检查源sql作业:由于sql可以运行更长时间，因此需要使用一个名为<em class="lc"> ds-GetQueryExecution </em>的lambda函数，使用<em class="lc">get _ query _ execution</em>API<em class="lc">来检查其运行状态。</em></p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="f69b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个函数是用下面的代码在step函数中调用的。在这段代码中，<em class="lc"> QueryExecutionId </em>跟踪AWS Athena内部的sql，以及&lt; <em class="lc"> QueryExecutionId &gt;。csv </em>成为存储在s3中的输出文件名。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="9c56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di">是否</span>源sql执行完成:如果sql最终长时间运行，我们需要检查sql执行是否完成。如果没有，等待循环将继续。下面是该步骤的声明(为了变量的可发现性，稍后将进一步添加该代码)。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="5996" class="ko jm hi lp b fi lt lu l lv lw">from stepfunctions.steps import Choice<br/>check_src_sql_run_choice_state = Choice(state_id = "Is the source sql execution complete?")</span></pre><p id="4c86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated">将源文件复制到s3:我想到了这一步，因为我不能将变量文件名传递给下游的ML管道脚本。这个步骤依赖于lambda函数<em class="lc"> ds-CopyS3Content </em>，下面是它的代码。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="f0fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是调用lambda函数的步骤函数代码</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="6ff2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，既然所有下游任务都已定义，我们最终可以对选择状态进行编码，等待输入sql完成，并在成功后开始将数据复制到s3。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="f043" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated">ageMaker预处理步骤:有了输入数据，我们就可以开始预处理了。</p><p id="e3c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一步是将scikit-learn预处理脚本作为处理作业运行，创建一个<em class="lc"> SKLearnProcessor </em>，它允许您使用AWS SageMaker提供的scikit-learn映像在处理作业内部运行脚本。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="2011" class="ko jm hi lp b fi lt lu l lv lw">sklearn_processor = SKLearnProcessor(<br/>framework_version="0.20.0",<br/>role=role_arn,<br/>instance_type="ml.m5.xlarge",<br/>instance_count=1,<br/>max_runtime_in_seconds=1500,<br/>)</span></pre><p id="b7a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二步是使用<a class="ae jk" href="https://aws.amazon.com/blogs/machine-learning/using-tensorflow-eager-execution-with-amazon-sagemaker-script-mode/" rel="noopener ugc nofollow" target="_blank"> SageMaker脚本模式</a>创建一个将在SageMaker docker内部运行的预处理脚本。像早期的python代码一样，这个代码片段在jupyter中运行时，使用<em class="lc"> %%writefile </em> jupyter命令在给定位置创建一个本地python文件<em class="lc"> preprocessing_step.py </em>。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="be6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个python脚本是在一个不同的位置创建的，所以要传输它，我们需要下面的jupyter代码。在SageMaker docker内部执行该代码期间，该代码还将设置输入和输出的路径。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="468e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最终，所有这些都将由步骤函数内预处理步骤用以下代码调用。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="cf2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated"><span class="l ly lz ma bm mb mc md me mf di"> S </span> ageMaker训练步骤:为了使用预处理数据训练模型，我再次利用<a class="ae jk" href="https://aws.amazon.com/blogs/machine-learning/using-tensorflow-eager-execution-with-amazon-sagemaker-script-mode/" rel="noopener ugc nofollow" target="_blank"> SageMaker脚本模式</a>并使用jupyter代码块创建了以下名为<em class="lc"> training_step.py </em>的本地python脚本。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="8b71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像前面一样，这个脚本是在本地创建的，因此要在s3中传输它，需要运行下面的代码。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="5494" class="ko jm hi lp b fi lt lu l lv lw">TRAINING_SCRIPT_LOCATION = 'get-visit-time/training_step.py'</span><span id="095e" class="ko jm hi lp b fi mg lu l lv lw">training_code = sagemaker_session.upload_data(<br/>TRAINING_SCRIPT_LOCATION,<br/>bucket=default_bucket,<br/>key_prefix="get-visit-time/scripts",<br/>)</span></pre><p id="5576" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该脚本需要使用以下代码包装在SageMaker提供的Tensorflow估计器中。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="7cf8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该估计器最终由步骤函数中的<em class="lc">训练步骤</em>调用，并应使用以下代码通过<em class="lc">失败</em>步骤进行错误处理。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="fc65" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated">ave模型:这个模型用下面的代码保存在这里</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="07d3" class="ko jm hi lp b fi lt lu l lv lw">model_step = ModelStep(<br/>"Save model", model=training_step.get_expected_model(), model_name=execution_input["ModelName"],<br/>instance_type="ml.m5.xlarge"<br/>)</span></pre><p id="ea0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi lx translated">创建/更新端点:虽然在前面的步骤中保存了模型用于健全性检查，但是我们更愿意创建一个用于推理的端点，并在重新训练期间使用下面的代码更新它。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="ceca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦创建了所有这些单独的任务，我们需要为所有使用以下代码的任务添加错误处理<em class="lc"> Catch </em>步骤。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="f9ec" class="ko jm hi lp b fi lt lu l lv lw">catch_state_processing = Catch(<br/>error_equals=["States.TaskFailed"],<br/>next_step=failed_state_sagemaker_processing_failure,<br/>)</span><span id="4a0f" class="ko jm hi lp b fi mg lu l lv lw">processing_step.add_catch(catch_state_processing)<br/>training_step.add_catch(catch_state_processing)<br/>model_step.add_catch(catch_state_processing)<br/>endpoint_config_step.add_catch(catch_state_processing)<br/>endpoint_step.add_catch(catch_state_processing)</span></pre><p id="67c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，为了创建完整的工作流，使用以下代码将前4个任务链接起来，最终形成选择状态<em class="lc">check _ src _ SQL _ run _ Choice _ state。</em></p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="8ff2" class="ko jm hi lp b fi lt lu l lv lw">full_workflow_graph= Chain([lambda_state_start_src_query,<br/>                            wait_src_query_execution_job,<br/>                            lambda_get_src_query_execution_status,<br/>                            check_src_sql_run_choice_state<br/>                            ])</span></pre><p id="860e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">成功后，选择状态指向<em class="lc">状态副本源s3文件作业。<br/> </em>由于选择状态不能在步骤函数中链接，我们使用下面的代码创建另一个链，将<em class="lc">lambda _ state _ copy _ source _ S3 _ file _ job</em>作为任务集合中的第一个任务。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="bb82" class="ko jm hi lp b fi lt lu l lv lw">train_workflow_graph = Chain([lambda_state_copy_source_s3_file_job,<br/>                              processing_step,<br/>                              training_step,<br/>                              model_step,<br/>                              endpoint_config_step,<br/>                              endpoint_step<br/>                              ])</span></pre><p id="d564" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们用下面的代码定义工作流。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="0c28" class="ko jm hi lp b fi lt lu l lv lw">full_workflow = Workflow(<br/>name="ds-GetVisitTime-Train-Workflow",<br/>definition=full_workflow_graph,<br/>role=role_arn,<br/>)</span></pre><p id="e480" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以使用这段代码来呈现工作流定义。这是验证你的工作流是否被定义为思想的好方法。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="e185" class="ko jm hi lp b fi lt lu l lv lw">full_workflow.render_graph()</span></pre><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mh"><img src="../Images/a64711f6f588109019af38c2c92e90f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgeJanVTzLmN8Wef9HhwGw.png"/></div></div></figure><p id="f9be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此后，如果我们是第一次创建工作流，我们应该运行</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="0df3" class="ko jm hi lp b fi lt lu l lv lw">full_workflow.create()</span></pre><p id="579b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了更新它，我们应该运行</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="1262" class="ko jm hi lp b fi lt lu l lv lw">full_workflow.update(definition=full_workflow_graph,role=role_arn)</span></pre><p id="fae5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以立即执行工作流，但是为了与AWS同步，最好使用下面的代码等待30秒。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="9d0a" class="ko jm hi lp b fi lt lu l lv lw">time.sleep(30)</span></pre><p id="7810" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以使用以下代码直接从笔记本运行工作流，其中我们需要使用<em class="lc"> uuid </em>库来为SageMaker预处理和训练作业生成唯一的名称。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="c4ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，在生产中使用lambda函数(从AWS CloudWatch events 调用lambda函数<a class="ae jk" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/Create-CloudWatch-Events-Scheduled-Rule.html" rel="noopener ugc nofollow" target="_blank">)进行调度更为现实。</a></p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="644b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用以下命令，可以从AWS步骤功能控制台或jupyter笔记本中找到状态机执行的进度。</p><pre class="le lf lg lh fd lo lp lq lr aw ls bi"><span id="d7fd" class="ko jm hi lp b fi lt lu l lv lw">execution.render_progress()</span></pre><p id="aa42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就完成了获取源数据的端到端训练过程，以便在训练完模型之后创建/更新端点，并且可以在本文的<a class="ae jk" rel="noopener" href="/@tanaychowdhury/aws-step-function-inference-pipeline-for-time-series-forecasting-model-9d5cc3121f88">第2部分</a>中找到使用这里构建的模型的推理。然而，这一培训渠道可以进一步优化，以完成以下任务。</p><ol class=""><li id="9c4f" class="mi mj hi io b ip iq it iu ix mk jb ml jf mm jj mn mo mp mq bi translated">对训练数据集运行交叉验证。</li><li id="7a33" class="mi mj hi io b ip mr it ms ix mt jb mu jf mv jj mn mo mp mq bi translated">仅当RMSE或MAE优于特定阈值时，才更新终点。</li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Build an image browsing App with React Native (3) — Persistent Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Native (3)构建图像浏览应用程序—持久存储</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-an-image-browsing-app-with-react-native-3-persistent-storage-2acdf01f3c62?source=collection_archive---------28-----------------------#2021-06-07">https://medium.com/geekculture/build-an-image-browsing-app-with-react-native-3-persistent-storage-2acdf01f3c62?source=collection_archive---------28-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="5c8e" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi"> React Native为iOS和Android带来了</em> <a class="ae jh" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> React的</em> </a> <em class="hi">声明式UI框架。使用React Native，您可以使用原生UI控件，并拥有对原生平台的完全访问权限。</em><a class="ae jh" href="https://github.com/facebook/react-native" rel="noopener ugc nofollow" target="_blank"><em class="hi">(https://github.com/facebook/react-native</em></a><em class="hi">)</em></p></blockquote><p id="c4c5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们已经在建立了一个图像浏览应用程序</p><div class="jl jm ez fb jn jo"><a rel="noopener follow" target="_blank" href="/geekculture/build-an-image-browsing-app-with-react-native-df303d222a0d"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">使用React Native构建图片浏览应用程序</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">React Native为iOS和Android带来了React的声明式UI框架。使用React Native，您可以使用本机UI控件…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc kd jo"/></div></div></a></div><p id="ef08" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">和</p><div class="jl jm ez fb jn jo"><a href="https://kxie0124.medium.com/build-an-image-browsing-app-with-react-native-2-redux-68f2d7a6744f" rel="noopener follow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">使用React Native(2)-Redux构建图片浏览应用程序</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">React Native为iOS和Android带来了React的声明式UI框架。使用React Native，您可以使用本机UI控件…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">kxie0124.medium.com</p></div></div></div></a></div><p id="edce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在这两篇文章中，我们实现了所有必要的功能，比如从后端API获取图像数据、在列表中显示图像、在用户从列表中单击图像时导航到单个图像的详细页面，以及在Redux store中保存和读取数据。</p><p id="5dce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">但你可能会注意到，当你启动应用程序时，即使你已经运行了应用程序，输入了关键字并浏览了一些图片，应用程序也不会显示任何内容。这是因为我们没有持久存储来保存数据和这些图像，当你关闭应用程序时，一切都消失了。</p><p id="35d4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因此，在本教程中，我们将添加持久存储并保存其中的数据，然后当应用程序启动时，应用程序将显示保存的图像，并等待用户的关键字。</p><p id="1a39" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">实际上，从技术上讲，我们不会保存图像本身，因为它们可能相当大。我们将保存来自后端API的数据，包括图像的所有URL。</p><p id="936f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">使用React Native在移动设备上实现持久存储有很多方法。最简单的方法可能是使用<code class="du ke kf kg kh b"><a class="ae jh" href="https://reactnative.dev/docs/asyncstorage" rel="noopener ugc nofollow" target="_blank">React Native AsyncStorage</a></code>。有了<code class="du ke kf kg kh b">AsyncStorage</code>，我们可以很容易地在移动设备上保存一些带有键值对的数据。但是在本教程中，我将介绍另一种方法，用<code class="du ke kf kg kh b"><a class="ae jh" href="https://github.com/Nozbe/WatermelonDB" rel="noopener ugc nofollow" target="_blank">WatermelonDB</a></code>来实现本地存储。</p><p id="0eff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><code class="du ke kf kg kh b">WatermelonDB</code>是一个反应式数据库框架，在React Native和React web应用中实现了一种处理用户数据的新方法。</p><p id="cfad" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">那我们开始吧。</p><h1 id="ad1e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">安装WatermelonDB</h1><p id="11b1" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">请按照<a class="ae jh" href="https://nozbe.github.io/WatermelonDB/Installation.html" rel="noopener ugc nofollow" target="_blank">https://nozbe.github.io/WatermelonDB/Installation.html</a>安装<code class="du ke kf kg kh b">WatermelonDB</code>。</p><h1 id="709c" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">创建模式</h1><p id="9bf0" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">让我们首先为<code class="du ke kf kg kh b">WatermelonDB</code>创建模式。我建议在<code class="du ke kf kg kh b">src</code>文件夹中创建一个文件夹<code class="du ke kf kg kh b">database</code>，把所有数据库相关的代码放在这个文件夹中。</p><p id="9280" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们在这个文件夹中创建一个新文件<code class="du ke kf kg kh b">Schema.ts</code>，并添加一个新的模式如下:</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="16ad" class="lt kj hi kh b fi lu lv l lw lx">import {appSchema, tableSchema} from '@nozbe/watermelondb';</span><span id="35b0" class="lt kj hi kh b fi ly lv l lw lx">export default appSchema({<br/>  version: 1,<br/>  tables: [<br/>    tableSchema({<br/>      name: 'photos',<br/>      columns: [<br/>        {name: 'photo_id', type: 'number'},<br/>        {name: 'width', type: 'number', isOptional: true},<br/>        {name: 'height', type: 'number', isOptional: true},<br/>        {name: 'url', type: 'string', isOptional: true},<br/>        {name: 'photographer', type: 'string', isOptional: true},<br/>        {name: 'photographer_url', type: 'string', isOptional: true},<br/>        {name: 'photographer_id', type: 'number', isOptional: true},<br/>        {name: 'avg_color', type: 'string', isOptional: true},<br/>        {name: 'src', type: 'string', isOptional: true},<br/>        {name: 'liked', type: 'boolean', isOptional: true},<br/>        {name: 'keyword', type: 'string', isOptional: true},<br/>      ],<br/>    }),<br/>  ],<br/>});</span></pre><p id="ae8a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在这个模式中，我们在数据库中定义了一个表<code class="du ke kf kg kh b">photos</code>，并且在这个表中定义了几个具有适当类型的列，如果它是可选的。</p><h1 id="d691" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">创建模型</h1><p id="c4f0" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">我们还需要相应地创建一个新的数据模型。因此，让我们创建一个新文件<code class="du ke kf kg kh b">Photo.ts</code>，并添加以下数据模型:</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="e1d3" class="lt kj hi kh b fi lu lv l lw lx">import {Model} from '@nozbe/watermelondb';<br/>import {field} from '@nozbe/watermelondb/decorators';</span><span id="a222" class="lt kj hi kh b fi ly lv l lw lx">export default class PhotoModel extends Model {<br/>  static table = 'photos';</span><span id="618c" class="lt kj hi kh b fi ly lv l lw lx">  @field('photo_id') photo_id: number;<br/>  @field('width') width: number;<br/>  @field('height') height: number;<br/>  @field('url') url: string;<br/>  @field('photographer') photographer: string;<br/>  @field('photographer_url') photographerUrl: string;<br/>  @field('photographer_id') photographerId: number;<br/>  @field('avg_color') avgColor: string;<br/>  @field('src') src: string;<br/>  @field('liked') liked: boolean;<br/>  @field('keyword') keyword: string;<br/>}</span></pre><p id="0cda" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这个模型类代表了我们应用程序中的一类东西。</p><h1 id="664b" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">实现数据库操作</h1><p id="2cd1" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">然后我们需要创建一个数据库实例并实现一些CRUD方法。</p><p id="a6af" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因此，让我们创建一个新文件<code class="du ke kf kg kh b">Database.ts</code>，并将以下代码放入其中</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="44e2" class="lt kj hi kh b fi lu lv l lw lx">import {Database} from '@nozbe/watermelondb';<br/>import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite';<br/>import schema from './Schema';<br/>import PhotoModel from './Photo';</span><span id="fe7d" class="lt kj hi kh b fi ly lv l lw lx">// First, create the adapter to the underlying database:<br/>const adapter = new SQLiteAdapter({<br/>  schema,<br/>  // experimental JSI mode, a more advanced version of synchronous: true<br/>  jsi: false,<br/>  // Optional, but you should implement this method:<br/>  onSetUpError: error =&gt; {<br/>    // Database failed to load -- offer the user to reload the app or log out<br/>  },<br/>});</span><span id="381c" class="lt kj hi kh b fi ly lv l lw lx">// Then, make a Watermelon database from it!<br/>const database = new Database({<br/>  adapter,<br/>  modelClasses: [PhotoModel],<br/>  actionsEnabled: true,<br/>});</span><span id="827b" class="lt kj hi kh b fi ly lv l lw lx">export const fetchAll = async (): Promise&lt;Photo[]&gt; =&gt; {<br/>  const photosCollection = database.get('photos');<br/>  const photos = (await photosCollection.query().fetch()) as Array&lt;PhotoModel&gt;;<br/>  return photos.map((photoModel: PhotoModel) =&gt; {<br/>    const photo = {<br/>      id: photoModel.photo_id,<br/>      width: photoModel.width,<br/>      height: photoModel.height,<br/>      url: photoModel.url,<br/>      photographer: photoModel.photographer,<br/>      photographer_url: photoModel.photographerUrl,<br/>      photographer_id: photoModel.photographerId,<br/>      avg_color: photoModel.avgColor,<br/>      src: JSON.parse(photoModel.src),<br/>      liked: photoModel.liked,<br/>      keyword: photoModel.keyword,<br/>    };<br/>    return photo;<br/>  });<br/>};</span><span id="0d67" class="lt kj hi kh b fi ly lv l lw lx">export const insertAll = async (photos: Array&lt;Photo&gt;) =&gt; {<br/>  const photosCollection = database.get('photos');<br/>  await database.action(async () =&gt; {<br/>    await database.batch(<br/>      ...photos.map((photo: Photo) =&gt; {<br/>        const newPhoto = photosCollection.prepareCreate(<br/>          (photoModel: PhotoModel) =&gt; {<br/>            photoModel.photo_id = photo.id;<br/>            photoModel.width = photo.width;<br/>            photoModel.height = photo.height;<br/>            photoModel.url = photo.url;<br/>            photoModel.photographer = photo.photographer;<br/>            photoModel.photographerUrl = photo.photographer_url;<br/>            photoModel.photographerId = photo.photographer_id;<br/>            photoModel.avgColor = photo.avg_color;<br/>            photoModel.src = JSON.stringify(photo.src);<br/>            photoModel.liked = photo.liked;<br/>            photoModel.keyword = photo.keyword;<br/>          },<br/>        );<br/>        return newPhoto;<br/>      }),<br/>    );<br/>  });<br/>};</span><span id="7207" class="lt kj hi kh b fi ly lv l lw lx">export const clearAll = async () =&gt; {<br/>  const photosCollection = database.get('photos');<br/>  const photos = await photosCollection.query().fetch();<br/>  await database.action(async () =&gt; {<br/>    photos.forEach(async (item: {markAsDeleted: () =&gt; any}) =&gt; {<br/>      await item.markAsDeleted(); // syncable<br/>      // await item.destroyPermanently(); // permanent<br/>    });<br/>  });<br/>};</span></pre><p id="6d28" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如这段代码所示，我们实现了一个适配器，一个根据我们之前定义的模式和模型的数据库实例，并实现了3个方法，<code class="du ke kf kg kh b">fetchAll</code>，用它们我们可以从数据库中获取所有图片；<code class="du ke kf kg kh b">insertAll</code>，我们可以添加一些新的图片到数据库中，和<code class="du ke kf kg kh b">clearAll</code>，我们可以删除数据库中的所有图片。</p><p id="aa64" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">到目前为止，我们已经用<code class="du ke kf kg kh b">WatermelonDB</code>实现了从本地数据库保存/获取数据的基本部分，所以我们将在本章中用我们的数据库模型实现持久存储。</p><h1 id="9075" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">分离数据提取</h1><p id="ec42" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">在继续下一步之前，我想介绍一下软件开发中的一个重要原则，真理的单一来源(SSOT)。</p><blockquote class="if ig ih"><p id="d59d" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在信息系统设计和理论中，单一的事实来源是构造信息模型和相关数据模式的实践，这样每个数据元素都只在一个地方被掌握。此数据元素的任何可能链接仅供参考。</p></blockquote><p id="529d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">但是在引入持久存储之后，我们将有两个数据源，后端API和数据库，所以我将修改我们的代码，使数据库成为唯一的真实数据源。</p><p id="48ce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">根据上面的解释，我想把数据获取函数从<code class="du ke kf kg kh b">Home</code>组件中分离出来，因为根据单一的事实来源，我们不应该从任何组件中直接调用这个函数。</p><p id="5d8e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可能会注意到，我们在<code class="du ke kf kg kh b">Home</code>组件中实现了<code class="du ke kf kg kh b">fetchData</code>方法，并将其与当前代码中的React挂钩混合在一起，因此为了更好的结构，让我们将它与<code class="du ke kf kg kh b">Home</code>组件分开。</p><p id="ff33" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们在<code class="du ke kf kg kh b">src</code>文件夹中创建一个新文件夹<code class="du ke kf kg kh b">network</code>，并在其中创建一个新文件<code class="du ke kf kg kh b">FetchData.ts</code>，将<code class="du ke kf kg kh b">fetchData</code>方法移动到该文件中，并做一些小的修改，如下所示</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="447f" class="lt kj hi kh b fi lu lv l lw lx">const requests = new Set();<br/>const fetchData = async (<br/>  ......<br/>) =&gt; {<br/>  ......<br/>    const json = await response.json();<br/><strong class="kh hj">    return json;<br/></strong>  } catch (error) {<br/><strong class="kh hj">    throw error;<br/></strong>  } finally {<br/>    requests.delete(url);<br/>  }<br/>};<br/><strong class="kh hj">export default fetchData;</strong></span></pre><p id="3c4f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">正如我们所看到的，我们将<code class="du ke kf kg kh b">fetchData</code>函数更改为一个纯函数，因为它接受特定的参数并返回一个JSON对象或抛出一个异常。它与任何组件或生命周期都不相关。我们将把这些部分移动到一个抽象的存储库模块中。</p><h1 id="cf09" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">添加存储库</h1><p id="3ef5" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">接下来让我们实现这个抽象存储库模块。</p><p id="5740" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因此，让我们在<code class="du ke kf kg kh b">src</code>文件夹中创建一个新文件夹<code class="du ke kf kg kh b">repository</code>，并在该文件夹中创建一个新文件<code class="du ke kf kg kh b">Repository.ts</code>，并向其中添加以下代码</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="96bf" class="lt kj hi kh b fi lu lv l lw lx">import {insertAll, clearAll, fetchAll} from '../database/Database';<br/>import fetchData from '../network/FetchData';<br/>import {FETCH_SUCCEED, FETCH_FAILED, GET_SUCCEED} from '../redux/Action';<br/>import {store} from '../App';</span><span id="8148" class="lt kj hi kh b fi ly lv l lw lx">export default class Repository {<br/>  static data: Data;<br/>  static cachedData?: Photo[];<br/>  <br/>  static get = async () =&gt; {<br/>    Repository.cachedData = await fetchAll();<br/>    console.log(<br/>      'get',<br/>      Repository.cachedData.map(item =&gt; item.id),<br/>    );<br/>    store.dispatch({<br/>      type: GET_SUCCEED,<br/>      payload: {...Repository.data, photos: Repository.cachedData},<br/>    });<br/>  };</span><span id="7246" class="lt kj hi kh b fi ly lv l lw lx">  static refresh = async (query: string = '', pageIndex: number = 0) =&gt; {<br/>    if (query === '') {<br/>      return;<br/>    }<br/>    try {<br/>      const ids = new Set(Repository.cachedData?.map(item =&gt; item.id));<br/>      Repository.data = await fetchData(query, pageIndex);<br/>      Repository.data?.photos.forEach(item =&gt; (item.keyword = query));<br/>      // console.log('refresh, ids', ids);<br/>      const newPhotos =<br/>        Repository.data &amp;&amp;<br/>        Repository.data?.photos &amp;&amp;<br/>        Repository.data.photos.filter(item =&gt; !ids.has(item.id));<br/>      if (newPhotos &amp;&amp; newPhotos.length &gt; 0) {<br/>        console.log(<br/>          'insert',<br/>          newPhotos.map(item =&gt; item.id),<br/>        );<br/>        insertAll(newPhotos);<br/>      }<br/>      store.dispatch({<br/>        type: FETCH_SUCCEED,<br/>        payload: {<br/>          ...Repository.data,<br/>          photos: Repository.cachedData,<br/>        },<br/>      });<br/>    } catch (error) {<br/>      store.dispatch({type: FETCH_FAILED, payload: error})<br/>    }<br/>  };</span><span id="35be" class="lt kj hi kh b fi ly lv l lw lx">  static clear = async () =&gt; {<br/>    await clearAll();<br/>  };<br/>}</span></pre><p id="4214" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">正如我们看到的，我们在这个<code class="du ke kf kg kh b">Repository</code>类中实现了三个方法，<code class="du ke kf kg kh b">get()</code>从持久存储中获取保存的数据，<code class="du ke kf kg kh b">refresh()</code>从后端API获取新数据并保存到持久存储中，<code class="du ke kf kg kh b">clear()</code>清除数据库。</p><p id="5a3d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">您可能还注意到这段代码中有一个新的动作，<code class="du ke kf kg kh b">GET_SUCCEED</code>。这是因为我们需要分开两个动作来区分从后端API获取数据的成功和从持久存储获取数据的成功。</p><p id="6a21" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">所以我们需要将下面的代码添加到<code class="du ke kf kg kh b">Action.d.ts</code>中</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="d59a" class="lt kj hi kh b fi lu lv l lw lx"><strong class="kh hj">interface GetAction {<br/>  type: string;<br/>  payload: Data | Error | undefined;<br/>}</strong></span></pre><p id="dd5a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并将下面的代码放入<code class="du ke kf kg kh b">Action.ts</code></p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="be41" class="lt kj hi kh b fi lu lv l lw lx"><strong class="kh hj">export const GET_SUCCEED = 'GET_SUCCESS';</strong></span><span id="28ae" class="lt kj hi kh b fi ly lv l lw lx">......<br/><strong class="kh hj">export const getSucceed = (data: Data): GetAction =&gt; ({<br/>  type: GET_SUCCEED,<br/>  payload: data,<br/>});</strong></span></pre><p id="9576" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并将<code class="du ke kf kg kh b">Reducer.ts</code>更新为</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="a8c2" class="lt kj hi kh b fi lu lv l lw lx">import {FETCH_FAILED, FETCH_SUCCEED, <strong class="kh hj">GET_SUCCEED</strong>} from '../redux/Action';</span><span id="6580" class="lt kj hi kh b fi ly lv l lw lx">const INITIAL_STATE: ReducerStateType = {<br/>  data: undefined,<br/>  error: undefined,<br/>};<br/>const isData = (object: any): object is Data =&gt; object;</span><span id="9b03" class="lt kj hi kh b fi ly lv l lw lx">const fetchReducer = (<br/>    state = INITIAL_STATE,<br/>    action: FetchAction,<br/>  ): ReducerStateType =&gt; {<br/>  switch (action.type) {<br/>    case <strong class="kh hj">GET_SUCCEED</strong>:<br/>      if (isData(action.payload)) {<br/><strong class="kh hj">        state = {<br/>          ...state,<br/>          data: {<br/>            ...action.payload,<br/>            photos: action.payload?.photos,<br/>          },<br/></strong>        };<br/>      }<br/>      break;<br/><strong class="kh hj">    case FETCH_SUCCEED:<br/>      if (isData(action.payload)) {<br/>        state = {<br/>          ...state,<br/>          data: {<br/>            ...action.payload,<br/>            photos: state.data?.photos,<br/>          },<br/>          error: undefined,<br/>        };<br/>      }<br/>      break;<br/></strong>    case FETCH_FAILED:<br/>      ......<br/>  }<br/>  return state;<br/>};</span></pre><p id="836a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如我们所见，我们会以不同的方式处理<code class="du ke kf kg kh b">GET_SUCCEED</code>和<code class="du ke kf kg kh b">FETCH_SUCCEED</code>。</p><h1 id="3f7d" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">更新主页组件以从SSOT数据库获取数据</h1><p id="bfb9" class="pw-post-body-paragraph ii ij hi il b im lg io ip iq lh is it ji li iw ix jj lj ja jb jk lk je jf jg hb bi translated">最后一步是将我们上面实现的所有模块组合在一起。所以让我们更新<code class="du ke kf kg kh b">Home</code>组件如下:</p><pre class="ll lm ln lo fd lp kh lq lr aw ls bi"><span id="56d2" class="lt kj hi kh b fi lu lv l lw lx"><strong class="kh hj">import Repository from '../repository/Repository';<br/></strong>......</span><span id="a430" class="lt kj hi kh b fi ly lv l lw lx">const Home = ({navigation}) =&gt; {<br/>  const data: Data = useSelector(state =&gt; state.fetch.data);<br/>  const error: Error = useSelector(state =&gt; state.fetch.error);</span><span id="13a0" class="lt kj hi kh b fi ly lv l lw lx">  const nextPage = async () =&gt; {<br/>    const key = 'page';<br/>    if (data?.next_page) {<br/>      const page = decodeURIComponent(<br/>        ......<br/>      );<br/><strong class="kh hj">      await Repository.refresh(data.photos[0].keyword, parseInt(page, 10) || 0);<br/>      Repository.get();<br/></strong>    }<br/>  };</span><span id="b11d" class="lt kj hi kh b fi ly lv l lw lx">  const onSearch = async (query: string) =&gt; {<br/><strong class="kh hj">    await Repository.clear();<br/>    await Repository.refresh(query, 0);<br/>    await Repository.get();<br/></strong>  };</span><span id="8bf7" class="lt kj hi kh b fi ly lv l lw lx">  useEffect(() =&gt; {<br/><strong class="kh hj">    if (!data &amp;&amp; !error) {<br/>      (async () =&gt; {<br/>        await Repository.get();<br/>      })();<br/>    }<br/></strong>  });<br/>  ......</span></pre><p id="5b8d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">当应用程序启动时，您会发现我们正在调用<code class="du ke kf kg kh b">Home</code>组件中的<code class="du ke kf kg kh b">Repository.get()</code>。并且储存库将从永久存储器中获取一些保存的数据，并分派一个<code class="du ke kf kg kh b">GET_SUCCEED</code>动作。并且一旦缩减器接收到这个动作，它将更新状态。</p><p id="92dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在另一个场景中，如果用户输入一个搜索关键字，那么<code class="du ke kf kg kh b">Repository.refresh()</code>将被触发，然后存储库将清除持久存储并从后端API获取新数据，并将新数据保存到持久存储中。在这之后，另一个<code class="du ke kf kg kh b">Repository.get()</code>将被触发，然后状态将被更新，这与应用程序启动相同。</p><p id="0517" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">第三种情况是，一旦用户滚动到列表的底部，就会触发<code class="du ke kf kg kh b">Repository.refresh()</code>，然后存储库将获取下一页图片并将其附加到当前列表，并更新状态。</p><p id="6a93" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在持久存储是唯一的事实来源，来自后端API的任何新数据都将首先保存到持久存储中，然后更新状态，然后更新视图。</p><p id="e04a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在让我们运行应用程序，你会看到如下</p><figure class="ll lm ln lo fd ma er es paragraph-image"><div class="er es lz"><img src="../Images/badd483d67ff4281f301814d02d20c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*1wd-qjWtZOnUlptuJzCcxA.gif"/></div></figure><p id="89f5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们获取了一些大猩猩的图片并关闭了应用程序，然后再次启动应用程序，我们会看到大猩猩的图片在没有输入任何搜索关键字的情况下显示出来。</p><p id="3270" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在，我们已经在React Native上使用<code class="du ke kf kg kh b">WatermelonDB</code>实现了持久存储，这使得您能够显示一些旧数据，而不是一个空视图，即使网络不可访问或后端API关闭。在某些情况下，它可能会改善用户体验。</p><p id="1971" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">还有一些其他地方可以改进，比如我们使用平面列表来显示图像，但平面列表可能会消耗大量内存，所以我们将在中使用RecyclerListView来优化它</p><div class="jl jm ez fb jn jo"><a href="https://kxie0124.medium.com/build-an-image-browsing-app-with-react-native-4-recyclerlistview-b3cb465e1ef7" rel="noopener follow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">使用React Native (4)构建图像浏览应用程序— RecyclerListView</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">React Native为iOS和Android带来了React的声明式UI框架。使用React Native，您可以使用本机UI控件…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">kxie0124.medium.com</p></div></div></div></a></div><p id="9ef1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">欢迎阅读本文，欢迎任何评论。</p></div></div>    
</body>
</html>
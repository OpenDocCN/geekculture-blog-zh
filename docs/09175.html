<html>
<head>
<title>Javascript 101: Handling Asynchrony — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:处理异步——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-handling-asynchrony-part-2-555bebbaf83e?source=collection_archive---------23-----------------------#2021-11-29">https://medium.com/geekculture/javascript-101-handling-asynchrony-part-2-555bebbaf83e?source=collection_archive---------23-----------------------#2021-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异步调用只有在完成工作后才返回，并且能够阻塞程序执行的主线程。许多语言通过为请求启动一个额外的<strong class="ih hj">线程</strong> ( <em class="jd">一个独立的执行路径</em>)来处理这个问题。另一方面，JavaScript使用一个<strong class="ih hj">事件队列</strong>来记录请求的执行，而<strong class="ih hj">主</strong> ( <strong class="ih hj">单个)线程</strong>则忙于其他事情。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/bae1c82c651c7c96d6c4ff264bf2aece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PyDWXh2-RLoJrHx0.jpg"/></div></div></figure><h1 id="e18a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">事件循环</h1><p id="24f4" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">当一个异步调用发生时，通常会有一个相关的回调，它最终会被放在一个<strong class="ih hj">事件队列的末尾。</strong></p><blockquote class="kt ku kv"><p id="c7af" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">“事件循环”是Javascript引擎在事件队列中连续运行的循环，以执行它遇到的每个回调，直到队列为空。</p></blockquote><p id="cdcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件队列充当线程的待办事项列表，而事件循环则是线程不断检查其待办事项列表，直到列表为空。如果队列为空，线程将进入睡眠状态，但当队列中出现新事件时，循环将重新开始。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/859700a4f2192125c4e7078c2d67a787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-ZoPFlbLw2bL-DBsOEENA.png"/></div></div></figure><p id="c128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是事件循环的一个大大简化的版本。如您所见，while循环代表了一个持续运行的循环(事件循环)，该循环的每次迭代都被称为<strong class="ih hj">“tick”</strong>对于每一个节拍，如果队列中有一个事件在等待，它就会被取走并执行。这些事件是你的函数回调。</p><blockquote class="kt ku kv"><p id="d111" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">一个重要的注意事项是<strong class="ih hj"> ES6 </strong>现在指定了事件循环如何工作，这意味着从技术上来说，它在<strong class="ih hj"> JS引擎</strong>的范围内，而不仅仅是<strong class="ih hj">托管环境。</strong>这种变化的一个主要原因是<strong class="ih hj"> ES6承诺</strong>的引入，因为它们需要能够对事件循环队列上的调度操作进行直接、细粒度的控制</p></blockquote><h1 id="a22c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> SetTimeOut —幕后</strong></h1><p id="fdd8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">看到JS中异步事件是如何操作的，我们理解setTimeout(..)不会将您的回调放在事件循环队列中。它的作用是设置一个计时器。当定时器到期时，JS引擎将您的回调放入事件循环中，以便将来的某个tick会拾取并执行它。</p><p id="24d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如果在那个时刻</em>事件循环中已经有20个项目了怎么办？你的回电在等着。它排在其他人的后面——通常没有抢占队列和跳到队伍前面的路径。这解释了为什么setTimeout(..)定时器可能不会以完美的时间精度触发。您可以保证您的回调不会在您指定的时间间隔之前触发，但它可以在该时间或之后发生，这取决于事件队列的状态。<strong class="ih hj">很神奇吧？😊</strong></p><h1 id="d9f2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">工作队列</strong></h1><p id="f1d8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">从ES6开始，在事件循环队列之上有了一个新的概念，叫做“作业队列”您最有可能接触到的是承诺的异步行为。</p><blockquote class="kt ku kv"><p id="f854" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">“作业队列”是悬挂在事件循环队列中每个滴答末尾的队列。</p></blockquote><p id="3b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在事件循环的节拍期间可能发生的某些异步隐含动作不会导致整个新事件被添加到事件循环队列中，而是将一个项目(也称为作业)添加到当前节拍的作业队列的末尾。</p><p id="e342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个作业还可以导致更多的作业被添加到同一队列的末尾。因此，从理论上讲，一个作业“循环”(一个作业不断添加另一个作业，等等)是可能的。)可能会无限期地旋转，从而使程序无法继续执行下一个事件循环。</p><p id="d372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想象一个调度作业的API(直接，没有黑客)，并把它叫做schedule(..).认为</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/0a114c30a5990ff591058fa0a91e6f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*N568j0GvjCYly05ZWG8QJQ.png"/></div></figure><p id="f4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能希望它打印出B C D，但实际上，它会打印出C D B，因为作业发生在当前事件循环节拍的末尾，计时器触发以调度下一个事件循环节拍(如果可用！)</p><h1 id="ce54" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="3dcf" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">Javascript是单线程的，通过其事件循环模型处理异步流程，以调度需要在以后执行的回调。与多线程编程相比，构建在node.js之上的应用程序使用尽可能少的线程来减少资源使用和复杂性。这是一大优势。</p><p id="fc38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一站— <a class="ae lb" rel="noopener" href="/geekculture/javascript-101-web-workers-1c70bcb4ba90">网络工作者</a></p><h1 id="eb6b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><ul class=""><li id="1e11" class="lc ld hi ih b ii ko im kp iq le iu lf iy lg jc lh li lj lk bi translated"><a class="ae lb" href="https://www.amazon.ca/You-Dont-Know-JS-Performance/dp/1491904224" rel="noopener ugc nofollow" target="_blank">你不知道JS: Async &amp;性能</a></li><li id="9c6f" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated"><a class="ae lb" href="https://www.amazon.ca/Eloquent-JavaScript-3rd-Introduction-Programming/dp/1593279507/ref=pd_lpo_2?pd_rd_i=1593279507&amp;psc=1" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript，第三版:编程的现代介绍</a></li></ul></div></div>    
</body>
</html>
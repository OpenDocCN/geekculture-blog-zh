<html>
<head>
<title>Deploy Express Project with Multiple Routes to Vercel as Multiple Serverless Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Express项目与到Vercel的多条路由一起部署为多个无服务器功能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploy-express-project-with-multiple-routes-to-vercel-as-multiple-serverless-functions-567c6ea9eb36?source=collection_archive---------4-----------------------#2021-08-28">https://medium.com/geekculture/deploy-express-project-with-multiple-routes-to-vercel-as-multiple-serverless-functions-567c6ea9eb36?source=collection_archive---------4-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/824d994dcc01c2840b7faa827ade5491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0IKRbzUwY_lHOH1T1LCSw.png"/></div></div></figure><p id="c501" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>凉了。对于开发人员来说，将NextJs应用程序部署到Vercel非常容易。因为平台就是为它而生的。但对于一个有多条路线的传统快递应用程序，如果你按照Vercel的文档部署快递应用程序，它最终将被部署为一个单一的无服务器功能。</p><p id="9a5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所知，考虑到在Vercel平台上实施的<a class="ae jo" href="https://vercel.com/docs/platform/limits" rel="noopener ugc nofollow" target="_blank">限制</a>，用一个单一的无服务器函数来处理所有请求对于生产来说并不是一个好主意。</p><p id="966c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们直接进入使用多条路线部署ExpressJS应用程序的新方式。</p><p id="383d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以一开始你可能已经用<a class="ae jo" href="https://expressjs.com/en/5x/api.html#router" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">快速路由器</strong> </a> <strong class="is hj">定义好了所有的路线。</strong></p><p id="bd12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在source目录下，创建一个<em class="jp"> routes </em>文件夹。现在将您的所有路线移动到<em class="jp">路线</em>文件夹中。然后在源文件夹中创建另一个文件夹<em class="jp"> api </em>。</p><p id="4fec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您的目录清单将如下所示。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es jq"><img src="../Images/eb2a738a45922fbfe427c60dc07fbcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*fVf9ggAkLF-h3-RyQXVZxA.png"/></div></figure><p id="2e96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"> routes </em>文件夹将以不同路由的形式包含您的所有应用程序逻辑。在<em class="jp"> api </em>文件夹中，Vercel查找要作为无服务器功能添加到平台中的api端点。</p><p id="a17f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，对于应用程序中的每条路线，您可以在您的<em class="jp"> api </em>文件夹中创建一个your-fancy-route-name.js文件，命名为/api/your-fancy-route-name.js。</p><p id="4261" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果您有一个/api/user路径，您可以在<em class="jp"> api </em>文件夹中创建一个user.js文件。您可以创建任意多的函数，但是请记住，如果您使用免费计划，Vercel <strong class="is hj">上的每个部署限制是12个函数。</strong></p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/5730949d0398f19eaf8b12845060beb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*TA6HG8dkMSsIZ3a97n2vMw.png"/></div></figure><p id="8d83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有两个示例路径，分别叫做<strong class="is hj"> /api/book </strong>和<strong class="is hj"> /api/books </strong>。现在我们需要在每个函数中初始化ExpressJS。因此，我们将转到<strong class="is hj"> /api/book.js </strong>，并将这段代码放在那里:</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="abcc" class="kb kc hi jx b fi kd ke l kf kg">const express = require(“express”);<br/>const app = express();</span></pre><p id="da5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们必须在第二个示例API端点<strong class="is hj"> /api/books中做同样的事情。</strong></p><h1 id="6df2" class="kh kc hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">但是有一个问题。</h1><p id="6901" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">将这些行添加到<em class="jp"> api </em>文件夹中的每个文件会带来大量的代码重复。所以我们将把它放在一个名为<strong class="is hj"> app.js ( </strong>或者你想叫它什么)的文件中，这个文件将驻留在你的源文件夹中。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="65a4" class="kb kc hi jx b fi kd ke l kf kg">const express = require(“express”);<br/>const app = express();</span><span id="5edf" class="kb kc hi jx b fi lj ke l kf kg">module.exports = app;</span></pre><p id="fdfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在在我们的<strong class="is hj"> /api/books.js </strong>和<strong class="is hj"> /api/books.js </strong>中我们可以直接导入这个Express app实例。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="4542" class="kb kc hi jx b fi kd ke l kf kg">const app = require(“../app”);</span></pre><p id="4601" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们可以将路由从/routes导入相应的api端点文件，以便在应用程序中使用它们。</p><p id="283e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的示例应用程序中，我有两条路线，它们的名称就像它们所属的路线一样。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/7915cffb63351e384387bff5afe50ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*xMksZRYHitsviwo5VKNKEQ.png"/></div></figure><p id="f0f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> /routes/book.js </strong>文件中，我将拥有我的<strong class="is hj"> /api/books </strong>路径的逻辑。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="baa6" class="kb kc hi jx b fi kd ke l kf kg">const book = require("express").Router();</span><span id="7ee0" class="kb kc hi jx b fi lj ke l kf kg">book.get("/book", async function (req, res) {</span><span id="2e88" class="kb kc hi jx b fi lj ke l kf kg">    const { bookId } = req.query;</span><span id="3b29" class="kb kc hi jx b fi lj ke l kf kg">    if (bookId) {</span><span id="b3db" class="kb kc hi jx b fi lj ke l kf kg">       res.status(200).send(<br/>           { bookName: "Some Book", bookId: bookId }<br/>       );</span><span id="db23" class="kb kc hi jx b fi lj ke l kf kg">    } else {</span><span id="0252" class="kb kc hi jx b fi lj ke l kf kg">       res.send("No book ID");</span><span id="3755" class="kb kc hi jx b fi lj ke l kf kg">    }</span><span id="a94e" class="kb kc hi jx b fi lj ke l kf kg">});</span><span id="221b" class="kb kc hi jx b fi lj ke l kf kg">book.post("/book", async function (req, res) {</span><span id="a779" class="kb kc hi jx b fi lj ke l kf kg">     const { bookId, bookName } = req.body;</span><span id="7d29" class="kb kc hi jx b fi lj ke l kf kg">     //do something</span><span id="0cfc" class="kb kc hi jx b fi lj ke l kf kg">     res.send("Something done");</span><span id="feaf" class="kb kc hi jx b fi lj ke l kf kg">});<br/></span><span id="52db" class="kb kc hi jx b fi lj ke l kf kg">module.exports = book;</span></pre><p id="46f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我们将<strong class="is hj">快速路由器</strong>导入为<strong class="is hj"> book，然后</strong>将GET和POST方法添加到<strong class="is hj"> book </strong>中。现在我们有了<strong class="is hj"> /api/book </strong>路径的逻辑，我们可以在<strong class="is hj"> /api/book.js </strong>文件中使用这个路径。</p><p id="4fc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里 找到这个<strong class="is hj"> /routes/book.js </strong>文件<a class="ae jo" href="https://github.com/qnxdev/express-vercel-serverless/blob/master/routes/book.js" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">。</strong></a></p><p id="b7fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需导入这条路线并使用它。在<strong class="is hj"> /api/book.js </strong></p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="c6b1" class="kb kc hi jx b fi kd ke l kf kg">const app = require("../app");<br/>const route = require("../routes/book");</span><span id="bb6e" class="kb kc hi jx b fi lj ke l kf kg">app.use("/api/", route);</span><span id="6f93" class="kb kc hi jx b fi lj ke l kf kg">module.exports = app;</span></pre><p id="6218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，该文件的默认导出是我们在其中使用相应的路径后从<strong class="is hj"> app.js </strong>导入的app。这将在您部署时由Vercel NodeJS运行时运行。</p><p id="4f3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参见我的<strong class="is hj"> /api/book.js </strong>文件<a class="ae jo" href="https://github.com/qnxdev/express-vercel-serverless/blob/master/api/book.js" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">此处</strong> </a>。</p><h2 id="5da2" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">类似地，我们可以将逻辑添加到<em class="ly"> routes </em>文件夹中的所有其他路由，并将其导入到<em class="ly"> api </em>文件夹中的相应端点。</h2><p id="b5ec" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">现在我们完成了路由和api端点。</p><p id="4774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想在Express应用程序中添加自定义中间件，您可以在我们首次初始化Express应用程序的<strong class="is hj"> app.js </strong>文件中完成。就像这样简单:</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="2b40" class="kb kc hi jx b fi kd ke l kf kg">const express = require("express");<br/>const cors = require("cors");<br/>const helmet = require("helmet");</span><span id="7088" class="kb kc hi jx b fi lj ke l kf kg">var corsOptions = {<br/>    //...cors options...<br/>}</span><span id="d582" class="kb kc hi jx b fi lj ke l kf kg">const app = express();</span><span id="d907" class="kb kc hi jx b fi lj ke l kf kg">app.use(helmet());<br/>app.use(cors(corsOptions));</span><span id="7a54" class="kb kc hi jx b fi lj ke l kf kg">module.exports = app;</span></pre><p id="538e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的例子展示了如何添加中间件，比如<a class="ae jo" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">CORS</strong></a><strong class="is hj"/>和<a class="ae jo" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">头盔</strong> </a>。</p><p id="266d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参见完整的<strong class="is hj"> app.js </strong>文件<a class="ae jo" href="https://github.com/qnxdev/express-vercel-serverless/blob/master/app.js" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">此处</strong> </a>。</p><p id="587e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想添加路由特定的中间件，你可以做同样的<strong class="is hj">app . use(your middleware)；</strong>在<em class="jp"> api </em>文件夹中的特定端点文件中。</p><h1 id="e146" class="kh kc hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">万岁！现在，我们已经为我们的Express应用程序设置了多条要在Vercel上部署的路线。</h1><h2 id="e432" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">但是等等。还有更多..</h2><p id="4627" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">由于我们已经修改了我们的路由，我们可能已经完全搞乱了我们的本地开发服务器配置。我们可以通过三个步骤解决这个问题。</p><h2 id="49ad" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated"><strong class="ak"> 1。添加一个常用的routes.js文件</strong></h2><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/8419fefbe15e6924743d4cacdf36cc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*90RcrMQeNMLcjFBYyRbY8A.png"/></div></figure><p id="c41a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，在<em class="jp">路由</em>文件夹中有一个<strong class="is hj"> router.js </strong>。您可以在您的<em class="jp"> routes </em>文件夹中创建一个新的<strong class="is hj"> routes.js </strong>文件。</p><p id="6cc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个文件中，我们将为开发服务器定义路由逻辑。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="f27b" class="kb kc hi jx b fi kd ke l kf kg">const routes = require("express").Router();</span><span id="1b96" class="kb kc hi jx b fi lj ke l kf kg">const book = require("./book");<br/>const books = require("./books");</span><span id="6338" class="kb kc hi jx b fi lj ke l kf kg">routes.get("/", async function (req, res) { <br/>      res.send(`Reached home!`); <br/>});</span><span id="7bb7" class="kb kc hi jx b fi lj ke l kf kg">routes.use("/", book);<br/>routes.use("/", books);</span><span id="4ed7" class="kb kc hi jx b fi lj ke l kf kg">module.exports = routes;</span></pre><p id="0b85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们导入快速路由器，并将其分配给<strong class="is hj">条路由。有一个为`/'定义的GET路由，它将服务于字符串“到达家！”对于每个请求`/`。</strong></p><p id="d200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我们已经在这里导入了我们的示例<strong class="is hj"> book </strong> route和<strong class="is hj"> books </strong> route，并将其用于<strong class="is hj"> routes。</strong></p><p id="d6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里  <strong class="is hj">找到完整的<strong class="is hj"> /routes/router.js </strong>文件<a class="ae jo" href="https://github.com/qnxdev/express-vercel-serverless/blob/master/routes/router.js" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">。</strong></a></strong></p><h2 id="928e" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">2.为本地开发服务器创建一个devServer.js</h2><p id="2a84" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在源文件夹中创建一个文件<strong class="is hj"> devServer.js </strong>或者任何你想添加到本地服务器的文件名。在该文件中，我们将从<strong class="is hj"> app.js </strong>文件中导入之前定义的Express App初始化。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="5fea" class="kb kc hi jx b fi kd ke l kf kg">const app = require(“./app”);</span></pre><p id="0747" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后导入我们在步骤1中创建的<strong class="is hj">路线</strong>，并与app一起使用。</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="e50f" class="kb kc hi jx b fi kd ke l kf kg">const app = require("./app");<br/>const routes = require("./routes/router");</span><span id="ca54" class="kb kc hi jx b fi lj ke l kf kg">app.use("/", routes);</span><span id="8f4d" class="kb kc hi jx b fi lj ke l kf kg">app.listen(3000,function () {<br/>      console.log("Server started. Go to http://localhost:3000/");<br/>});</span></pre><p id="1744" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在上一部分看到的，我在端口3000启动了服务器。</p><h2 id="2ce2" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">3.将运行脚本添加到<strong class="ak"> package.json </strong></h2><p id="5744" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在你的<strong class="is hj"> <em class="jp"> package.json </em> </strong>中你可以添加这个脚本</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="7f84" class="kb kc hi jx b fi kd ke l kf kg">"scripts": {<br/>    "dev": "nodemon devServer.js"<br/>},</span></pre><p id="0120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，你需要nodemon来完成这项工作</p><pre class="jr js jt ju fd jw jx jy jz aw ka bi"><span id="ac30" class="kb kc hi jx b fi kd ke l kf kg">npm i nodemon</span><span id="ecc8" class="kb kc hi jx b fi lj ke l kf kg">//<em class="jp">then</em></span><span id="9780" class="kb kc hi jx b fi lj ke l kf kg">npm run dev</span></pre><p id="5e8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终的目录结构将看起来像这样..</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/d406fdd4719bad2a661b9f603211b056.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*Gq_IQslUxP3xE4LePI1m9w.png"/></div></figure><p id="58a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在Github上找到这个项目</p><blockquote class="mb mc md"><p id="7ca0" class="iq ir jp is b it iu iv iw ix iy iz ja me jc jd je mf jg jh ji mg jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/qnxdev/express-vercel-serverless" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">https://github.com/qnxdev/express-vercel-serverless</em></strong></a></p></blockquote><p id="4e2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">跟着我<em class="jp">无处可去</em>😝</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="a5ac" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">好吧。是的。完成了。完美。喝茶时间到了。☕️</h2><h2 id="6b63" class="kb kc hi bd ki ll lm ln km lo lp lq kq jb lr ls ku jf lt lu ky jj lv lw lc lx bi translated">再见</h2></div></div>    
</body>
</html>
<html>
<head>
<title>The Brilliance of SvelteJS Stores</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条商店的辉煌</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/svelte-stores-352c61759a88?source=collection_archive---------18-----------------------#2021-06-14">https://medium.com/geekculture/svelte-stores-352c61759a88?source=collection_archive---------18-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9e50a82d38ac006aee252dbc96af4dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3XSMnK_0nXkdAFEC_cjhQ.png"/></div></div></figure><p id="c5d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我看来,<a class="ae jo" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">苗条</a>图书馆最有用的组成部分之一是<em class="jp">“商店”</em>。你可以在这里阅读官方文档<a class="ae jo" href="https://svelte.dev/tutorial/writable-stores" rel="noopener ugc nofollow" target="_blank">，但简而言之，Store是一个反应性对象，在其中你<em class="jp">【subscribe】</em>从你的应用程序内部的任何组件状态变化。再者，店铺可以<em class="jp">【衍生】</em>。例如，商店值可以基于一个或多个其他商店实例的值。</a></p><p id="7fa0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对我来说，随着<em class="jp">“定制”</em>商店的创建，事情变得非常有趣。显然，Svelte的创建者非常清楚这些商店的力量和灵活性，并提供了一个简单的界面来遵循。基本上，任何实现了<em class="jp">“subscribe”</em>方法的对象都是存储！</p><p id="2226" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://feed.army/" rel="noopener ugc nofollow" target="_blank"> Feed Army </a>大量使用反应式存储，因为新的Feed数据通过WebSockets注入应用程序。stores的反应性意味着当提要被更新时，显示逻辑可以在数据被使用时轻松地呈现新的提要内容。</p><p id="357b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在撰写本文时，<a class="ae jo" href="https://feed.army/" rel="noopener ugc nofollow" target="_blank"> Feed Army </a>在内部使用x4定制商店</p><ol class=""><li id="77c9" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">本地存储库</li><li id="0af2" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">地图商店</li><li id="68b1" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">对象存储</li><li id="76c1" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">队列存储</li></ol><p id="4b9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一批x3存储(尤其是Map &amp; Object存储)都扩展了原生JS类型。这很重要，因为你可以利用JS提供的内置和优化的方法。例如，一个新的MapStore实例有一个访问底层<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries" rel="noopener ugc nofollow" target="_blank">映射的访问器。条目</a>方法。这使得像使用任何其他原生JS对象一样使用存储变得很容易。当然还有被动的额外好处。</p><p id="8059" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，我想在这里与你分享的是一个简单的队列存储的内容。创建这样一个商店的原因是由于我对“当”“苗条”<em class="jp">“滴答”</em>以及在DOM/UI中迭代反应对象所做的一个假设。基本上，我的显示组件会<em class="jp"/>“跳过”新的feed条目，这并不理想，因此创建了一个队列。</p><p id="dd81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"> **这里</em>  <em class="jp">可以参考苗条微任务gotcha </em> <a class="ae jo" rel="noopener" href="/geekculture/svelte-gotcha-the-reactive-microtasks-b27f00d53fb6"> <em class="jp">。</em></a></p><p id="ffcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，下面是一个相当简单/直接的队列类的示例内容(在Typescript中):</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="62fe" class="kn ko hi kj b fi kp kq l kr ks">export interface QueueInterface {<br/>  count(): number;<br/>  dequeue?(): any;<br/>  enqueue(...args: any): void;<br/>  flush(): any[];<br/>  reset(): void;<br/>  setFifo(fifo: boolean): void;<br/>  setLifo(lifo: boolean): void;<br/>  truncate(length: number): void;<br/>}</span><span id="372b" class="kn ko hi kj b fi kt kq l kr ks">export class queue {<br/>  protected elements: any[];<br/>  protected fifo = true;<br/>  constructor(...args: any) {<br/>    this.elements = [...args];<br/>  }<br/>  count() {<br/>    return this.elements.length;<br/>  }<br/>  dequeue?(): any {<br/>    if (this.fifo) {<br/>      return this.elements.shift();<br/>    }<br/>    return this.elements.pop();<br/>  }<br/>  enqueue(...args: any) {<br/>    return this.elements.push(...args);<br/>  }<br/>  // Like dequeue but will flush all queued elements<br/>  flush(): any[] {<br/>    let elms = [];<br/>    while (this.count()) {<br/>      elms.push(this.dequeue());<br/>    }<br/>    return elms;<br/>  }<br/>  setFifo(fifo = true) {<br/>    this.fifo = fifo;<br/>  }<br/>  setLifo(lifo = true) {<br/>    this.fifo = !lifo;<br/>  }<br/>  reset(): void {<br/>    this.truncate(0);<br/>  }<br/>  truncate(length: number) {<br/>    if (Number.isInteger(length) &amp;&amp; length &gt; -1) {<br/>      this.elements.length = length;<br/>    }<br/>  }<br/>}</span><span id="c57b" class="kn ko hi kj b fi kt kq l kr ks">export default queue;</span></pre><p id="bec2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这并不奇怪，所以让我们看看这个类是如何通过我的QueueStore使用的:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5c17" class="kn ko hi kj b fi kp kq l kr ks">import { writable, get } from "svelte/store";<br/>import { queue } from "queue";</span><span id="89b3" class="kn ko hi kj b fi kt kq l kr ks">export <em class="jp">interface</em> QueueStore {<br/>  count(): <em class="jp">number</em>;<br/>  dequeue?(): <em class="jp">any</em>;<br/>  enqueue(...<em class="jp">args</em>: <em class="jp">any</em>): <em class="jp">void</em>;<br/>  flush(): <em class="jp">any</em>[];<br/>  reset(): <em class="jp">void</em>;<br/>  self(): <em class="jp">object</em>;<br/>  setFifo(<em class="jp">fifo</em>: <em class="jp">boolean</em>): <em class="jp">void</em>;<br/>  setLifo(<em class="jp">lifo</em>: <em class="jp">boolean</em>): <em class="jp">void</em>;<br/>  subscribe(<em class="jp">v</em>: <em class="jp">any</em>): Unsubscriber;<br/>  truncate(<em class="jp">length</em>: <em class="jp">number</em>): <em class="jp">void</em>;<br/>}</span><span id="254a" class="kn ko hi kj b fi kt kq l kr ks">export const newQueueStore = function () {<br/>  let store = writable(new queue());<br/>  return {<br/>    count: () =&gt; get(store).count(),<br/>    dequeue: () =&gt; {<br/>      let q = get(store);<br/>      const item = q.dequeue();<br/>      store.set(q);<br/>      return item;<br/>    },<br/>    enqueue: (...args: any) =&gt; {<br/>      let q = get(store);<br/>      q.enqueue(...args);<br/>      store.set(q);<br/>    },<br/>    flush: () =&gt; {<br/>      let q = get(store);<br/>      const e = q.flush();<br/>      store.set(q);<br/>      return e;<br/>    },<br/>    reset: () =&gt; {<br/>      let q = get(store);<br/>      q.reset();<br/>      store.set(q);<br/>    },<br/>    self: () =&gt; get(store),<br/>    setFifo(fifo: boolean): void {<br/>      let q = get(store);<br/>      q.setFifo(fifo);<br/>    },<br/>    setLifo(lifo: boolean): void {<br/>      let q = get(store);<br/>      q.setLifo(lifo);<br/>    },<br/>    subscribe: store.subscribe,<br/>    truncate: (length: number) =&gt; {<br/>      let q = get(store);<br/>      q.truncate(length);<br/>      store.set(q);<br/>    },<br/>  } as QueueStore;<br/>};</span></pre><p id="eaec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，为了保持一致性，我总是尝试为底层对象创建访问器。因此，现在有了反应式存储，任何订阅者都会被通知任何队列更新，并可以相应地<em class="jp">“反应”</em>。如果需要，订户甚至可以获得底层队列类实例。例如:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c0bd" class="kn ko hi kj b fi kp kq l kr ks">const qs = newQueueStore();<br/>qs.subscribe((q: QueueStore) =&gt; {<br/>  while (q.count()) {<br/>    const item = q.dequeue();<br/>    console.log(item); // hello world<br/>  }<br/>  console.log(q === qs.self()); // true<br/>});<br/>qs.enqueue("hello world");</span></pre><p id="0129" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个明确的<strong class="is hj"> <em class="jp">【喊出】</em> </strong>给这里苗条的创作者。最灵活和强大的！</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="21ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">原载于</em><a class="ae jo" href="https://www.kylehq.com/2021/06/the-brilliance-of-sveltejs-stores/" rel="noopener ugc nofollow" target="_blank"><em class="jp">https://www.kylehq.com</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>
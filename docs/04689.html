<html>
<head>
<title>Sorting Algorithms 101: Insertion Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法101:插入排序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sorting-algorithms-101-insertion-sort-ee585f6a62cf?source=collection_archive---------29-----------------------#2021-07-01">https://medium.com/geekculture/sorting-algorithms-101-insertion-sort-ee585f6a62cf?source=collection_archive---------29-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/276a6537f96a3e4471286f4e064c68f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q_H9-pjuCJcg4C-j"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1ad5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在今天的文章中，我们将进入下一个排序算法，插入排序！如果你错过了我的前两篇文章，<a class="ae iu" rel="noopener" href="/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa">冒泡排序</a>和<a class="ae iu" rel="noopener" href="/@freda.hon/sorting-algorithms-101-selection-sort-778c201e330a">选择排序</a>，我已经包含了链接。</p><p id="f84b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于那些想要快速回顾的人来说，在每次迭代中，<em class="jt">冒泡排序</em>找到<em class="jt">最大的</em>未排序数，并将其移动到数组的<em class="jt">末端</em>。同时，<em class="jt">选择排序</em>在每次迭代中找到<em class="jt">最小的</em>未排序数，并将其移动到数组的<em class="jt">开始</em>处。这有点过于简单了，但概述了两者之间的最大区别。</p><p id="cdd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与使用“标记”来跟踪和比较元素的选择排序非常相似，插入排序也有自己的变化。所以，如果你准备好了，让我们进入插入排序！</p><h1 id="925b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">插入排序:工作原理</h1><p id="4292" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">假设我们需要对下面的列表进行排序:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0deb" class="lg jv hi lc b fi lh li l lj lk">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]</span></pre><p id="f047" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用一个<em class="jt">键</em>并将其设置为索引1(不是索引0)。我们不想把它设置为索引0，因为我们将把这个键和它左边的数字进行比较。如果密钥比密钥左边的数字小，那么我们交换这两个数字。</p><p id="b136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，如果发生交换，我们需要跟踪工作索引(从密钥交换过来的数字)。我们需要跟踪这个工作索引，因为它将再次与它左边的元素进行比较。只有当没有更多的交换发生时(键左边的所有元素都被排序)，我们才移动键到下一个索引并重复。</p><p id="3918" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">*请注意，与键不同的是，您不必用变量来跟踪工作索引。我提到它，并把它包括在下面，只是作为一个参考。当我们讨论算法时，工作索引本身将被处理成一个条件循环。</em></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="3f4f" class="lg jv hi lc b fi lh li l lj lk">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>            ^<br/>           key</span></pre><p id="2d5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，从上面的例子开始，7是我们的密钥，4是密钥的剩余数字。因为4不大于7，所以不会发生交换，我们将下一个数字1重新指定为密钥。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6530" class="lg jv hi lc b fi lh li l lj lk">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>               ^<br/>              key</span></pre><p id="a25e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为密钥1小于7，所以我们交换这两个数字，得到下面的新列表:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="b389" class="lg jv hi lc b fi lh li l lj lk">list = [ 4, 1, 7, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>            ^<br/>        working index</span></pre><p id="7fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7仍然是关键，而1现在是我们的工作指数，因为它再次与4相比较。4大于1，因此发生交换。因为在这一点上没有更多的交换，所以密钥移动到6。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="679b" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 7, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>                  ^<br/>                 key</span></pre><p id="89bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6小于7。所以两人互换了位置:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="72cd" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 10, 8, 3, 9, 7, 5, 2 ]<br/>               ^      <br/>          working index</span></pre><p id="ed4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">工作索引中没有比6更小的了，所以键现在移到了10，等等。为了让事情进展顺利，我用快速叙述的方式介绍了接下来的几个步骤。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a3fc" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 10, 8, 3, 9, 7, 5, 2 ]<br/>                      ^<br/>                     key</span></pre><p id="4760" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">键移动到8:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2c7a" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 10, 8, 3, 9, 7, 5, 2 ]<br/>                         ^<br/>                        key</span></pre><p id="9d6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8和10互换。8左边的所有数字都被排序，所以键现在移动到3:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8ed5" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 8, 10, 3, 9, 7, 5, 2 ]<br/>                            ^<br/>                           key</span></pre><p id="c9e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3与10互换，成为新的工作指数:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1342" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 8, 3, 10, 9, 7, 5, 2 ]<br/>                        ^<br/>                     working index</span></pre><p id="db59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3作为新的工作指数，与8相比较。因为3小于8，所以两者交换位置:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="b09e" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 4, 6, 7, 3, 8, 10, 9, 7, 5, 2 ]<br/>                     ^<br/>                 working index</span></pre><p id="75d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">稍微往前跳一点，因为我想你已经明白了要点…3会一直沿着4的左边走下去:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5138" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 3, 4, 6, 7, 8, 10, 9, 7, 5, 2 ]<br/>            ^               ^<br/>         working index     key</span></pre><p id="3459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为3不小于1，所以它会停在那里，键最终会移动到9:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c35a" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 3, 4, 6, 7, 8, 10, 9, 7, 5, 2 ]<br/>                               ^<br/>                              key</span></pre><p id="3926" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们一遍又一遍地重复上述过程。直到最后，我们到达倒数第二个数字，也就是10最终结束的地方。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6cdc" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 3, 4, 5, 6, 7, 7, 8, 9, 10, 2 ]<br/>                                     ^<br/>                                    key</span></pre><p id="fb17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10和2交换位置:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6ca1" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 3, 4, 5, 6, 7, 7, 8, 9, 2, 10 ]<br/>                                    ^<br/>                              working index</span></pre><p id="683f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和2作为工作索引，将继续向左交换，直到遇到1，列表最终被完全排序。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="f0f4" class="lg jv hi lc b fi lh li l lj lk">list = [ 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10 ]</span></pre><h1 id="b4c7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">算法</h1><p id="0822" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">像往常一样，我将在下面使用Python，但是请随意使用您选择的语言。</p><p id="825b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们正在遍历数组，所以让我们从循环的<em class="jt">开始。</em></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="30b9" class="lg jv hi lc b fi lh li l lj lk">def insertion_sort(arr):<br/>    for i in range(1, len(arr)):</span></pre><p id="3458" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，<code class="du ll lm ln lc b">i</code>在这里是索引。我们从1开始循环的范围，因为我们想把索引设为1。这样，我们现在可以创建和分配我们的关键变量。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8de0" class="lg jv hi lc b fi lh li l lj lk">def insertion_sort(arr):<br/>    for i in range(1, len(arr)):<br/>        key = arr[i]</span></pre><p id="f755" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们一直在处理键左边的数字，所以让我们也为它设置一个变量，并为这些左边的项定义一个变量<code class="du ll lm ln lc b">j</code>。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2e36" class="lg jv hi lc b fi lh li l lj lk">def insertion_sort(arr):<br/>    for i in range(1, len(arr)):<br/>        key = arr[i]<br/>        j = i - 1</span></pre><p id="0f8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经设置好了两个变量，让我们加入交换的条件:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2170" class="lg jv hi lc b fi lh li l lj lk">def insertion_sort(arr):<br/>    for i in range(1, len(arr)):<br/>        key = arr[i]<br/>        j = i - 1</span><span id="f0f5" class="lg jv hi lc b fi lo li l lj lk">        while j &gt;= 0 and key &lt; arr[j]:    <br/>            arr[i], arr[j] = arr[j], arr[i]     <br/>            i -= 1</span></pre><p id="f4a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能突然看起来很多，所以让我们一步一步地分解它。</p><p id="8df8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在<em class="jt">中陈述了两件事，而</em>是有条件的:</p><ol class=""><li id="b1cb" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated">而索引大于或等于0，以避免负索引，并且</li><li id="cc45" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">而，键小于键的左边的元素(<code class="du ll lm ln lc b">arr[j]</code>)。</li></ol><p id="a0e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只有当这两个条件都满足时，我们才进入<em class="jt">而</em>-循环并交换两个元素(<code class="du ll lm ln lc b">arr[i], arr[j] = arr[j], arr[i]</code>)。然后我们将<code class="du ll lm ln lc b">i</code>减1，继续在列表中向下比较，直到索引j不再大于或等于0。</p><h1 id="b028" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">时间复杂度</h1><p id="ad57" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">让我们假设数组还没有排序。排序数组是最好的情况，复杂度为O(n)。</p><p id="9120" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在大多数情况下，数组是不排序的，插入排序具有<strong class="ix hj">时间复杂度</strong>或<strong class="ix hj">大O符号</strong>的<strong class="ix hj"> O(n2) </strong>。</p><p id="25f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么是O(n2)？</p><p id="3a1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据(n)计算时间复杂度的最简单方法是计数并乘以<em class="jt">嵌套</em>循环的数量。记住，这是<em class="jt">嵌套的</em>循环，不是一般的循环。如果循环存在于彼此之外，您应该添加(n)。</p><p id="2244" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设(n)代表数组中的每个元素。当我们遍历一个数组时，我们遍历代码(n)次——每个元素一次，对吗？</p><p id="dc87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过嵌套循环，我们将每个元素<strong class="ix hj"> <em class="jt">再运行</em> </strong> (n)次，现在使它(n×n)。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1a15" class="lg jv hi lc b fi lh li l lj lk">def insertion_sort(arr):<br/>    for i in range(1, len(arr)):    # n<br/>        key = arr[i]<br/>        j = i - 1</span><span id="4038" class="lg jv hi lc b fi lo li l lj lk">while j &gt;= 0 and key &lt; arr[j]:    <br/>            arr[i], arr[j] = arr[j], arr[i]     # n<br/>            i -= 1</span></pre><p id="f17a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你在上面看到的，-循环的<em class="jt">将运行(n)次，因为它遍历每个元素。</em>循环的<em class="jt">中的<em class="jt"> while </em>循环也将在遍历每个元素时运行(n)次。这意味着上面的代码将运行(n x n)次！</em></p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="adb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">咻！太多了，但我们做到了！</p><p id="0ccc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们刚刚完成了系列中五个排序算法的前三个。接下来，合并排序！感谢您的阅读，我们下次再见！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Let’s Go Fishing! Writing a Minecraft 1.17 Auto-Fishing Bot in Python, OpenCV and PyAutoGUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们去钓鱼吧！用Python、OpenCV和PyAutoGUI编写《我的世界》1.17自动钓鱼机器人</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lets-go-fishing-writing-a-minecraft-1-17-auto-fishing-bot-in-python-opencv-and-pyautogui-6bfb5d539fcf?source=collection_archive---------13-----------------------#2021-06-10">https://medium.com/geekculture/lets-go-fishing-writing-a-minecraft-1-17-auto-fishing-bot-in-python-opencv-and-pyautogui-6bfb5d539fcf?source=collection_archive---------13-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/62c276a15d21b52b3e96b5e51c374470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uceHdO9JIzfeRZWWUvmn6Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Let’s Go Fishing! (<a class="ae iu" href="http://12tails.com/how-to-go-fishing-in-minecraft/" rel="noopener ugc nofollow" target="_blank">screen credit</a>)</figcaption></figure><p id="ea49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我一直在YouTube上观看来自<a class="ae iu" href="https://www.youtube.com/channel/UCfzlCWGWYyIQ0aLC5w48gBQ" rel="noopener ugc nofollow" target="_blank">sendex</a>和<a class="ae iu" href="https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ" rel="noopener ugc nofollow" target="_blank">工程师Man </a>的一些游戏自动化和深度学习/人工智能，我想为了工作而学习它们(顺便说一句，我是这些人的超级粉丝)。</p><p id="e779" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这与此相去甚远，但我的目标是最终通读成千上万的扫描文档并检索数据，这些数据可能是手写的或键入的。这意味着我必须将扫描结果作为图像读取，读取一个字符，转换成一个numpy数组，并对字符是/应该是什么做出一些决定。我最终会使用神经网络来“学习”字符并提高准确性，但现在，我想和孩子们一起做些有趣的事情。</p><p id="a695" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">昨天，新的《我的世界》“洞穴和悬崖”版本(1.17)发布了，我想为我写一个自动钓鱼的小程序可能会很有趣。这纯粹是一个教育的第一步，写一些有趣的东西，并在行动中看到。这并不是说阅读扫描文档不好玩，但是看到自动出现的绿色XP小气泡还是很酷的。都是为了眼前的满足，对吧？！？</p><p id="1927" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始了…</p><p id="3824" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经过几次我不会让你厌烦的尝试和错误之后，我最终决定采用下面的方法…</p><ul class=""><li id="6c24" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">当程序运行时，让角色准备好投射到一个可钓鱼的区域。施法应该是角色的第一个动作，这是使用pyautogui.rightClick()完成的。</li><li id="9021" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用PIL抓取光标周围的一小块区域；例如，如果我将光标放在钓鱼浮子上，在钓鱼光标周围截取一个小正方形屏幕截图。</li><li id="39e9" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">将图像转换为灰度，并将尺寸增大(即放大)到易于管理的程度。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/5e778e0ad36db9d41c4616966901e206.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*1whKMUIcJj7H_bM49wUCwA.png"/></div></figure><ul class=""><li id="0f9d" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">继续拍摄每十分之一秒的灰色缩放屏幕截图。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/24236e39a5ef1216d22f1aff90c9461f.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*1Ig9C6vBbHx3BTxo3rQDlw.png"/></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/844fa7b012429bdfbaacd24e6e5a9cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*Ejr7pwD3s_4NC4UYc63BiQ.png"/></div></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/57d50c11567b32eb078bed22025ceb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*IqsSdqnaifDZpOxEq-qX4w.png"/></div></figure><ul class=""><li id="e113" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">当钓到一条鱼时，黑色的钓鱼线会下降到屏幕截图的下方，这样图像中就不会再有黑色像素了。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/6069d623a3a0317c727e36b2768f61b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*0HoRwGYn2VDMWbtO6G8jYA.png"/></div></figure><ul class=""><li id="32d2" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">一旦一条鱼被“捕获”,再次使用pyautogui.rightClick()来捕获捕获的鱼。</li><li id="fcfe" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">然后，循环整个过程来获得甜蜜的战利品和经验值！</li></ul><p id="44ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在对于代码…请注意，这是一个快速和肮脏的程序，以达到预期的结果。可以添加许多改进，但是scope只是一个概念验证，用于学习OpenCV中的图像操作。这仅用于教育目的！</p><p id="819a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您需要的四个外部库是Pillow或PIL、pyautogui、OpenCV和numpy。我在虚拟环境中运行Python 3.9.1。所以，安装这些:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="35a8" class="kr ks hi kn b fi kt ku l kv kw">pip install --upgrade numpy<br/>pip install --upgrade opencv-python<br/>pip install --upgrade Pillow<br/>pip install --upgrade pyautogui</span></pre><p id="5bc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将以下文件保存到名为autofish.py的新项目中</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cbc1" class="kr ks hi kn b fi kt ku l kv kw">import pyautogui<br/>import cv2<br/>from PIL import ImageGrab<br/>from time import sleep<br/>import numpy as np</span><span id="6315" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">def initializePyAutoGUI():</strong><br/>    # Initialized PyAutoGUI<br/>    # When fail-safe mode is True<br/>    # moving the mouse to the upper-left<br/>    # corner will abort your program. This prevents <br/>    # locking the program up.<br/>    pyautogui.FAILSAFE = True</span><span id="9b18" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">def take_capture(magnification):</strong><br/>    mx, my = pyautogui.position()  # get the mouse cursor position<br/>    x = mx - 15  # move to the left 15 pixels<br/>    y = my - 15  # move up 15 pixels<br/>    capture = ImageGrab.grab(<br/>                  bbox=(x, y, x + 30, y + 30)<br/>              )  # get the box down and to the right 15 pixels (from the cursor - 30 from the x, y position)<br/>    arr = np.array(capture)  # convert the image to numpy array<br/>    res = cv2.cvtColor(<br/>              cv2.resize(<br/>                  arr, <br/>                  None, <br/>                  fx=magnification, <br/>                  fy=magnification, <br/>                  interpolation=cv2.INTER_CUBIC<br/>              ), cv2.COLOR_BGR2GRAY<br/>          )  # magnify the screenshot and convert to grayscale<br/>    return res</span><span id="795e" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">def autofish(tick_interval, threshold, magnification):</strong><br/>    pyautogui.rightClick()  # cast the fishing line<br/>    sleep(2)  # wait a couple of seconds before taking captures<br/>    img = take_capture(magnification)  # take initial capture <br/>    <br/>    # Continue looping to take a capture and convert and check <br/>    # until there are no black pixels in the capture. This will <br/>    # display the image, but it isn't necessary (the imshow method).</span><span id="09d7" class="kr ks hi kn b fi kx ku l kv kw">    # Once there are no black pixels in the capture:<br/>    #     np.sum(img == 0) is looking for black pixels<br/>    #     &gt; threshold is the number of those pixels (0) <br/>    # exit the loop and reel in the catch (pyautogui.rightClick()).</span><span id="0373" class="kr ks hi kn b fi kx ku l kv kw">    # Finally, wait a second and leave the auto-fish method.<br/>    # This will cast, wait and catch one interval. See main method <br/>    # for looping.</span><span id="2e25" class="kr ks hi kn b fi kx ku l kv kw">    while np.sum(img == 0) &gt; threshold:  <br/>        img = take_capture(magnification)<br/>        sleep(tick_interval)<br/>        cv2.imshow('window', img)<br/>        if cv2.waitKey(25) &amp; 0xFF == ord('q'):<br/>            cv2.destroyAllWindows()<br/>            break<br/>    pyautogui.rightClick()<br/>    sleep(1)<br/></span><span id="d0d2" class="kr ks hi kn b fi kx ku l kv kw"># This will wait 5 seconds to allow switching from Python program<br/># to Minecraft. Then loop through the autofish method for 100 <br/># cast and catch loops.<br/># <br/># Launch Minecraft and load up your world<br/># Equip your fishing pole and be ready to cast into a fishable area<br/># Run program through IDLE or your IDE<br/># Switch to the Minecraft while running<br/># Position character so that it is ready to cast <br/># and the cursor will be immediately on top of the bobber <br/># Let it run...<br/># If you need more time, change sleep(5) to something more</span><span id="73ef" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">def main():</strong><br/>    initializePyAutoGUI()<br/>    sleep(5)  <br/>    i = 0<br/>    while i &lt; 100:<br/>        autofish(0.01, 0, 5)<br/>        i += 1<br/><br/><br/>if __name__ == "__main__":<br/>    main()</span></pre><p id="6a2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我之前说过的，我不能否认，这个程序的目的是学习图像捕捉，操作和阅读的基本知识，以便以简单有趣的方式有计划地做出决定。</p><p id="a0f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我花了很长时间比较捕获和检测差异，但气泡使得不可能编码一致的东西。当我放大并查看光标捕获中的行时，我最终决定采用这种方法。</p><p id="6397" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有建议或改进，请告诉我。我很想听听你的想法。</p><p id="c62e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！</p><p id="c028" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编辑更新:《我的世界》窗口需要在屏幕的左上角800 X 600的工作…</p></div></div>    
</body>
</html>
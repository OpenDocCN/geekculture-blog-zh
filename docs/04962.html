<html>
<head>
<title>Why you should not place your invariants inside domain services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该将不变量放在域服务中</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-you-should-not-place-your-invariants-inside-domain-services-365b9f0cc6a4?source=collection_archive---------33-----------------------#2021-07-06">https://medium.com/geekculture/why-you-should-not-place-your-invariants-inside-domain-services-365b9f0cc6a4?source=collection_archive---------33-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ecb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">(非常感谢谭震森给儿子的同行评议！)</em></p><p id="11c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我进行的DDD培训中，我总是建议人们把不变量放在值对象中。如果不可行，那么就使用实体，然后使用聚合根，作为最后的手段，把它放在域服务中(当然，永远不要放在应用程序服务中)。</p><p id="6ded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，当您查看生产代码时，在域服务中看到不变量并不少见。这是为什么呢？遗留代码有时很难处理。我可以接受。但是最近编写并经过良好测试的代码呢？那么没有任何其他依赖的全新领域代码呢？</p><p id="0def" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使面向对象编程(更具体地说是封装原则)已经存在了40多年，但该原则并不总是得到很好的应用。在过程式服务的一系列步骤中间放置不变量仍然是人们使用的一种方法。</p><p id="fbd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">防止心怀不轨的人在代码库中做坏事是不可能的。但是如果你适当地组织你的代码，防止好心人犯诚实的错误是可能的。</p><p id="cd8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在域服务中放置不变量的主要问题是人们不会被迫应用这些不变量。当然，熟记代码库和领域的人不会忘记这一点。但所有其他人都将落入陷阱。上周是我的案子。</p><p id="3efa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给你看一个我误引入的bug。首先，我将向您展示几个我在引入bug时正在处理的代码示例。然后，我将向您展示一个简单的重构是如何让您不可能再犯同样的错误的。</p><p id="4335" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服役期</strong>类。如您所见，您可以向构造函数提供一个偏移量和一个可空的StartDayOfMonth。有趣的部分在第20行。看起来有一个IsAlignedOnBillingPeriod的概念(不管那是什么意思)，它依赖于StartDayOfMonth属性的存在(或不存在)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9975779234eeb1f1ca8a022bb935e2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgDPdiB1WY1hebqD1GdZtQ.png"/></div></div></figure><p id="aa53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">CustomSubscriptionBundleBuilder</strong>类。当你看着这个生成器时，你很快意识到它为你做的唯一一件事就是应用一个不变量来知道如何将StartDayOfMonth(第27行)赋值给我在上一节课中展示的<strong class="ih hj"> ServicePeriod </strong>(第22行)。现在它解释了<strong class="ih hj"> ServicePeriod </strong>类的IsAlignedOnBillingPeriod属性(第20行)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jq"><img src="../Images/867efef3d3e32bc61df93038c4c9a512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rcz0h3nMzN83JoHiDTRqMw.png"/></div></div></figure><p id="f48a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，这是我犯的错误。在某些时候，我需要添加一个步骤来更新包的<strong class="ih hj"> ServicePeriod </strong>。问题是捆绑包更新方法(当您第一次需要创建它时，与<strong class="ih hj">CustomerSubscriptionBundlerBuilder</strong>负责构建的类相同)接受实例化新的<strong class="ih hj"> ServicePeriod </strong>所需的两个参数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jr"><img src="../Images/a942cb6c67f5933dc78307d385268790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQEjpGnou8SYTxyOEYOfbg.png"/></div></div></figure><p id="4441" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我犯了什么错误？我没有应用<strong class="ih hj">CustomerSubscriptionBundlerBuilder</strong>类的不变量(第27行)。为什么？因为代码中没有任何东西给我暗示存在这样的规则！即使对于创建过程，人们也可以通过直接调用<strong class="ih hj"> CustomSubscriptionBundle </strong>构造函数来轻松绕过构建器，因为构建器/工厂并不抽象创建复杂性，它只是业务规则应用程序的抽象！最后，代码中没有任何东西通过强制应用不变量来强制域总是有效的。</p><p id="af0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">找出问题花了我35分钟。<br/>修复漏洞和重构代码花了我15分钟。<br/>代码审查我的工作花了5分钟。在测试环境中部署和验证代码需要15分钟。<br/>总共70分钟。</p><p id="f73c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更好的结构化代码如何能够避免我的错误？这是我重新设计这一切的方式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es js"><img src="../Images/d05cb7c9f3b3f8cb26495882143a3c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NSjTwqE3sPOtLcNLYLhMA.png"/></div></div></figure><p id="6e20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我将<strong class="ih hj"> ServicePeriod </strong>构造函数设为私有(第11行)。<br/>然后我将builder类的不变量移到了<strong class="ih hj"> ServicePeriod </strong> value对象内部(第34行)。<br/>最后，我添加了一个静态工厂方法来帮助人们实例化一个<strong class="ih hj"> ServicePeriod </strong>(第20行)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jt"><img src="../Images/71123f45fe04d9dd980f92ec3b1ca6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wROgq33ZOqNCHOYQOG0cWQ.png"/></div></div></figure><p id="6dcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我做的另一个更改是修改UpdateServicePeriod方法，以直接接受一个<strong class="ih hj"> ServicePeriod </strong>。这个包对一个<strong class="ih hj"> ServicePeriod </strong>的内部细节以及如何实例化它完全没有兴趣。这是基本的封装。如果有一天一个<strong class="ih hj"> ServicePeriod </strong>的内部细节发生了变化，没有理由在bundle类中产生连锁反应。更重要的是，捆绑包不再负责构建<strong class="ih hj"> ServicePeriod </strong>。也不再有原始的痴迷！</p><p id="dfea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">老实说，我的重构非常简单。没有什么值得骄傲的。然而，这个小的重构现在可以防止整个系统以错误的方式实例化一个<strong class="ih hj"> ServicePeriod </strong>。这真的是一个巨大的进步。有时，构建始终有效的域是复杂的，因为根据聚合根边界的当前状态，业务规则可能很难应用。但在那种情况下，它可以像最初那样实施，而不需要额外的成本，我也不会损失70分钟。</p><p id="546d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多事情会减慢开发人员的速度，并影响团队的整体速度。作为一名开发人员，我一直在努力改进我们的工作方式，以加速我们的开发。总会有我们无法控制的外部因素和原因。但是作为专业人员，当涉及到代码库中的小细节时，在我们控制的事情中，我们必须保持警惕。为这样的事情浪费70分钟是一个很好的例子，说明了在我们学会如何系鞋带之前就存在的良好编程实践的重要性。我本可以节省14分钟，只需修复我的错误，而无需重构代码库来防止其他人陷入同样的陷阱。但是作为专业人员，这是我们的另一个责任，让代码保持比你发现时更好的状态。让这个世界变得更好。</p></div></div>    
</body>
</html>
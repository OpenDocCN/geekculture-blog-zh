<html>
<head>
<title>Javascript 101: Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 101:事件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-101-events-9c90fb7e2dce?source=collection_archive---------14-----------------------#2021-12-14">https://medium.com/geekculture/javascript-101-events-9c90fb7e2dce?source=collection_archive---------14-----------------------#2021-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/24ba3b240fda0840a699ce01c977a4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2UwS3xn5Q9sfaEx3.jpg"/></div></div></figure><p id="a4e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<em class="jo">事件</em>是一个信号，表明已经发生了一些事情，它是按照<strong class="is hj">观察者模式</strong>建模的，该模式允许页面的行为和外观之间的松散耦合。</p><p id="2037" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件发生后，会在整个DOM中传播，让它们的侦听器做出响应。这些事件在页面上的接收顺序被描述为<strong class="is hj">事件流。</strong></p><h1 id="5833" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">DOM事件流</h1><p id="27df" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">由<a class="ae ks" href="https://www.w3.org/TR/WD-DOM-Level-2/events.html#Events-Event" rel="noopener ugc nofollow" target="_blank"> DOM Level 2 Events </a>指定的事件流有三个阶段:目标处的<strong class="is hj">事件捕获</strong>阶段，以及<strong class="is hj">事件冒泡</strong>阶段。事件捕获首先发生，提供了在必要时拦截事件的机会。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/5a69327913611eb45d4f5eff61f58648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMV3rcv-imNcbVZMg7_EnQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx"><a class="ae ks" href="https://codepen.io/caleb-42/pen/ExwPbQM" rel="noopener ugc nofollow" target="_blank">Even capturing and bubbling flow after <strong class="bd jr">div</strong> is clicked</a></figcaption></figure><p id="dd67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在DOM Level 2 Events规范事件流中，实际的目标(<div>元素)在<strong class="is hj">捕获阶段</strong>不接收事件。上图描述了另外一种情况，因为<strong class="is hj"> Safari </strong>、<strong class="is hj"> Chrome、</strong>和<strong class="is hj"> Firefox </strong>在事件目标的捕获阶段触发了一个事件(这个例子是在Chrome中完成的)。</div></p><p id="4939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着在事件目标的下一个阶段开始(<strong class="is hj">冒泡阶段)</strong>之前，本应在事件目标的父级(元素)停止的捕获阶段会继续到事件目标(<div>元素)，这将触发&lt; div &gt;返回到文档。</div></p><blockquote class="lc ld le"><p id="ac3e" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">这种修改的最终结果是有两个机会来处理目标上的事件。</p></blockquote><h1 id="e319" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">事件捕获</h1><p id="8e77" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">事件捕获(又名<strong class="is hj">事件滴流</strong>)的理论是最不特定的节点应该首先接收事件，最特定的节点应该最后接收事件。要使用事件捕获，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank"> addEventListener </a>方法的第三个参数(<strong class="is hj"> useCapture </strong>)被赋予值<strong class="is hj"> true </strong>，如下所示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/3d3e8c16703c2b2cc54767738bdf1f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRtaKhYC_eHt0fDc6Bp38Q.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Event capturing flow after <strong class="bd jr">div</strong> is clicked</figcaption></figure><p id="bf56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用事件捕获，单击事件首先被文档接收，然后继续沿着DOM树向下到达事件的实际目标，即<div>元素。</div></p><blockquote class="lc ld le"><p id="92c0" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">事件捕获通常不被使用，因为在旧的浏览器中缺乏支持。一般的建议是自由使用事件冒泡，同时为特殊情况保留事件捕获。</p></blockquote><h1 id="cb96" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">事件冒泡</h1><p id="ef46" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">事件冒泡是指事件从最具体的元素(文档树中可能最深的点)开始，然后向上流向最不具体的节点(文档)。为了使用事件冒泡，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank"> addEventListener </a>方法的第三个参数(<strong class="is hj"> useCapture </strong>)被赋予值<strong class="is hj"> false </strong>。但是因为false是它的默认值，所以我们可以像这样忽略它。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/7e019945183abfee3bb3e4b9121ee3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMaEG7nFrkQUBP1y1yuY_A.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Event bubbling after <strong class="bd jr">div</strong> is clicked</figcaption></figure><p id="1d7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您单击div元素时，click事件按以下顺序发生:div — body — html — document。click事件沿着DOM树向上，一路上在每个节点上触发，直到到达文档对象。(火狐、chrome、safari一直延续到窗口对象)——疯狂吧？他们总是做额外的😂。</p><h1 id="76e5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">事件委托</h1><p id="4917" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">捕获和冒泡允许我们实现最强大的事件处理模式之一，称为事件<strong class="is hj">委托</strong>。也可以使用target属性为特定类型的事件广泛撒网。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/c5a9d8c63140495f33777ea052f91a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kv848AYtuBINKoDHi_FfQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx"><a class="ae ks" href="https://codepen.io/caleb-42/pen/RwLrzrb" rel="noopener ugc nofollow" target="_blank">Event delegation in practice</a></figcaption></figure><p id="7423" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果您有一个包含一长串按钮的节点，如上图所示，那么在外部节点上注册一个单击处理程序(在本例中为<strong class="is hj"> div </strong>)并让它使用target属性来判断一个按钮是否被单击，而不是在所有按钮上注册单独的处理程序，这样可能会更方便。</p><h1 id="de43" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">关于事件的更多信息</h1><h2 id="1d07" class="ll jq hi bd jr lm ln lo jv lp lq lr jz jb ls lt kd jf lu lv kh jj lw lx kl ly bi translated">停止事件传播</h2><p id="5d0b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在任何时候，事件处理程序都可以调用事件对象上的<strong class="is hj"> stopPropagation </strong>方法来阻止更高层的处理程序接收事件。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/bc0638f5993b9e8e695304e85001197a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2MwZ17PDw-agK1OiksWOA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx"><a class="ae ks" href="https://codepen.io/caleb-42/pen/mdBVZVd" rel="noopener ugc nofollow" target="_blank"><strong class="bd jr">stopPropagation</strong> method in action</a></figcaption></figure><p id="077a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，当您在另一个可点击的元素中有一个按钮，并且您不希望点击按钮激活外部元素的点击行为时，这可能是有用的。</p><h2 id="5144" class="ll jq hi bd jr lm ln lo jv lp lq lr jz jb ls lt kd jf lu lv kh jj lw lx kl ly bi translated">防止默认事件</h2><p id="a139" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">许多事件都有与之关联的默认操作。一个常见的例子是提交表单时发生的刷新操作。对于大多数类型的事件，JavaScript事件处理程序在默认行为发生之前被调用。如果处理程序不希望这种正常行为发生，通常是因为它已经处理了事件，它可以对事件对象调用preventDefault方法。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/5baff6ceb438d45423d1efa393ca476c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZluH7FmWOMgNgFLru6J_ig.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx"><a class="ae ks" href="https://codepen.io/caleb-42/pen/dyVGxxZ" rel="noopener ugc nofollow" target="_blank"><strong class="bd jr">preventDefault</strong> Event method in action</a></figcaption></figure><p id="d3d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可以用来实现您自己的键盘快捷键或上下文菜单。它还可以用来讨厌地干扰用户预期的行为。</p><h1 id="7e16" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="af60" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果没有事件和听众，我们的节目尽管漂亮，也不过是表达思想和情感，缺乏反馈。这使得事件成为Javascript中一个有趣的话题，因为它们使我们能够通过交互来了解世界对我们的应用程序的感觉。我希望你已经了解了它们是如何工作的，以及如何在你的应用中利用它们的传播。再见👋</p><h1 id="dac7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><ul class=""><li id="7eca" class="mb mc hi is b it kn ix ko jb md jf me jj mf jn mg mh mi mj bi translated"><a class="ae ks" href="https://www.amazon.ca/Eloquent-JavaScript-3rd-Introduction-Programming/dp/1593279507" rel="noopener ugc nofollow" target="_blank">雄辩的Javascript </a></li></ul></div></div>    
</body>
</html>
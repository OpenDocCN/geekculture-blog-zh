<html>
<head>
<title>RabbitMQ inside docker container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker容器内的RabbitMQ</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rabbitmq-inside-docker-container-8b8bfea22174?source=collection_archive---------2-----------------------#2020-12-31">https://medium.com/geekculture/rabbitmq-inside-docker-container-8b8bfea22174?source=collection_archive---------2-----------------------#2020-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fdd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" href="https://alex-ber.medium.com/installing-rabbitmq-on-windows-4411f5114a84" rel="noopener">故事中，我描述了如何在Windows上安装RabbitMQ。</a></p><p id="ba12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将描述如何通过管理UI获得RabbitMQ。</p><p id="069f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的方法就是使用docker image<em class="je">rabbit MQ:3 . 8 . 9-管理-alpine </em>(我更喜欢基于Alpine Linux的分发)<em class="je">。</em>Alpine Linux的源代码可以在这里找到<a class="ae jd" href="https://github.com/docker-library/rabbitmq/blob/888638927482f86af6e88bebb67423926cb1112f/3.8/alpine/management/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github . com/docker-library/rabbit MQ/blob/888638927482 f 86 af 6e 88 bebb 67423926 CB 1112 f/3.8/Alpine/management/docker file</a></p><p id="d56f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它不能将消息从一个队列移动到另一个队列(插件<em class="je">rabbit MQ _ slope</em>和<em class="je">rabbit MQ _ slope _ management</em>没有安装)。下面的代码解决了这个问题:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="6357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我只改变了第4行:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="9415" class="jr js hi jn b fi jt ju l jv jw">RUN rabbitmq-plugins enable --offline rabbitmq_management rabbitmq_shovel rabbitmq_shovel_management</span></pre><p id="4096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我加了<code class="du jx jy jz jn b">rabbitmq_shovel rabbitmq_shovel_management</code>。</p><p id="f03e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您已经构建了这个名为<code class="du jx jy jz jn b">rabbitmq-i</code>的docker映像。</p><p id="1c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您的代码通常会在另一个docker文件中运行。在两个docker容器之间建立网络连接的最佳实践是创建网络。详见<a class="ae jd" href="https://www.middlewareinventory.com/blog/docker-connect-containers-together/" rel="noopener ugc nofollow" target="_blank">https://www . middleware inventory . com/blog/docker-connect-containers-together/</a>。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="d9bc" class="jr js hi jn b fi jt ju l jv jw">docker network create rabbitnet</span></pre><p id="2af2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，通过以下方式启动基于<code class="du jx jy jz jn b">rabbitmq-i</code> docker映像的docker容器:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="1b2e" class="jr js hi jn b fi jt ju l jv jw">docker run -d --hostname rabbitmq --name rabbitmq -p 15672:15672 -p 5672:5672 --network rabbitnet  rabbitmq-i</span></pre><p id="2d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">-d </code> —以分离模式启动(在后台，不将控制台连接到进程的标准输入、标准输出和标准错误)。</p><p id="9580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">--hostname </code> —容器的主机名。它在RabbitMQ内部使用。例如，作为RabbitMQ集群名称的一部分</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ka"><img src="../Images/186cd2678b539e683e2868381ec53e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*LucQZ7anQT0SkWX76tlC3A.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">From the management UI</figcaption></figure><p id="11ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">--name </code> —码头集装箱的名称。它将用于从另一个docker容器与这个docker容器进行通信。最好和<code class="du jx jy jz jn b">hostname</code>一样。</p><p id="a631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">-p 15672:15672 -p 5672:5672 </code> — <code class="du jx jy jz jn b">5672</code>用于连接RabbitMQ，端口<code class="du jx jy jz jn b">15672</code>用于管理UI。我使用的是普通TCP，所以我公开了端口<code class="du jx jy jz jn b">15672</code>。如果你想使用TLS，你应该公开端口<code class="du jx jy jz jn b">15671</code>。引用自文档:</p><blockquote class="kh ki kj"><p id="824b" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><em class="hi">T</em>T28<em class="hi">LS同行验证:你说你是谁？</em> </p><p id="9498" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><em class="hi">正如在</em> <a class="ae jd" href="https://www.rabbitmq.com/ssl.html#certificates-and-keys" rel="noopener ugc nofollow" target="_blank"> <em class="hi">证书和密钥</em> </a> <em class="hi">一节中提到的，TLS有两个主要目的:加密连接流量和提供一种方法来验证对等体是否可信(例如，由可信的证书颁发机构签名)以缓解</em> <a class="ae jd" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank"> <em class="hi">中间人攻击</em> </a> <em class="hi">，这是一类攻击者冒充合法可信对等体(通常是服务器)的攻击。本节将重点讨论后者。</em></p></blockquote><p id="b3e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.rabbitmq.com/ssl.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/ssl.html</a></p><p id="cee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">--network rabbitnet</code> —这是定义的关键部分，我们将<code class="du jx jy jz jn b">rabbitmq-i</code>连接到内部网络(名称为<code class="du jx jy jz jn b">rabbitnet</code>)。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="e9fa" class="ku js hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">代码示例</h1><p id="d432" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">现在，假设您有另一个安装了<code class="du jx jy jz jn b">pika==1.1.0</code>的docker容器。那么您可以使用以下阻塞消息生成器:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="c02c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你运行这个docker容器<strong class="ih hj">时，你应该添加</strong> <code class="du jx jy jz jn b"><strong class="ih hj">--network rabbitnet</strong></code> <strong class="ih hj">到</strong> <code class="du jx jy jz jn b"><strong class="ih hj">docker run</strong></code>指令，以便能够与<code class="du jx jy jz jn b">rabbitmq</code> docker容器通信(也就是坐在<code class="du jx jy jz jn b">rabbitnet</code>上，见上文)。</p><p id="bfc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一下代码:</p><p id="ee2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">在第8行——教程中的<code class="du jx jy jz jn b">URLParameters</code>常用</em>。<code class="du jx jy jz jn b">URLParameters </code>和<code class="du jx jy jz jn b">ConnectionParameters</code>都扩展了<code class="du jx jy jz jn b">Parameters</code>类。<code class="du jx jy jz jn b">BlockingConnection </code>期望<code class="du jx jy jz jn b">Parameters</code>类被传递给它的<code class="du jx jy jz jn b">__init__</code>方法，所以你可以同时使用它们。我使用所有默认值，除了<code class="du jx jy jz jn b">host</code>。我用<code class="du jx jy jz jn b">rabbitmq</code>做主机。因为这个docker容器是基于名为<code class="du jx jy jz jn b">rabbitmq</code>的<code class="du jx jy jz jn b">rabbitmq-i</code>映像通过<code class="du jx jy jz jn b"><strong class="ih hj">rabbitnet</strong></code>连接到docker容器的，所以我们的TCP调用将到达带有RabbitMQ的docker容器。</p><blockquote class="kh ki kj"><p id="8066" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><em class="hi">注意:同样的代码也适用于安装在Windows </em>  <em class="hi">机器上的</em> <a class="ae jd" href="https://alex-ber.medium.com/installing-rabbitmq-on-windows-4411f5114a84" rel="noopener"> <em class="hi"> RabbitMQ。您应该只修改C:\ Windows \ System32 \ drivers \ etc \ hosts文件。添加以下一行:</em></a></p><p id="d0eb" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">127.0.0.1兔子质量</p><p id="c8b5" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><em class="hi">现在，您对“rabbitmq”主机名的调用将到达您的本地主机(您安装了RabbitMQ的地方)。</em></p></blockquote><p id="8107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">在第10行</em> —我们用上面的连接参数创建最简单的<code class="du jx jy jz jn b">BlockingConnection</code>。请参见<a class="ae jd" href="https://pika.readthedocs.io/en/stable/examples/comparing_publishing_sync_async.html" rel="noopener ugc nofollow" target="_blank">比较消息发布与阻塞连接和选择连接</a>、<a class="ae jd" href="https://pika.readthedocs.io/en/stable/examples/connecting_async.html" rel="noopener ugc nofollow" target="_blank">使用回调传递方式连接到RabbitMQ、</a><a class="ae jd" href="https://pika.readthedocs.io/en/stable/examples/asynchronous_publisher_example.html" rel="noopener ugc nofollow" target="_blank">异步发布者示例</a>了解替代方法(使用<code class="du jx jy jz jn b">Pika</code>)。我们使用上下文管理器在最后自动关闭连接。</p><p id="7af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">在第12行</em>——我们从上面的<code class="du jx jy jz jn b">connection </code>得到<code class="du jx jy jz jn b">channel</code>。</p><p id="5e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">第15行(未使用)——</em>我们可以通过编程来创建队列。就我个人而言，我更喜欢在管理UI中完成，但是你也可以在代码中完成。引用自docstring:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="9903" class="jr js hi jn b fi jt ju l jv jw"><em class="je">Declare queue, create if needed. This method creates or checks a<br/>queue. When creating a new queue the client can specify various<br/>properties that control the durability of the queue and its contents, and the level of sharing for the queue.<br/><br/>Use an empty string as the queue name for the broker to auto-generate one. Retrieve this auto-generated queue name from the returned `spec.Queue.DeclareOk` method frame.</em></span><span id="7212" class="jr js hi jn b fi lw ju l jv jw"><em class="je">:param str queue: The queue name; if empty string, the broker will<br/>    create a unique queue name<br/>:param bool passive: Only check to see if the queue exists and raise<br/>  `ChannelClosed` if it doesn't<br/>:param bool durable: Survive reboots of the broker<br/>:param bool exclusive: Only allow access by the current connection<br/>:param bool auto_delete: Delete after consumer cancels or disconnects<br/>:param dict arguments: Custom key/value arguments for the queue</em></span><span id="c9ad" class="jr js hi jn b fi lw ju l jv jw"><em class="je">:returns: Method frame from the Queue.Declare-ok response</em></span><span id="de34" class="jr js hi jn b fi lw ju l jv jw"><em class="je">:rtype: `pika.frame.Method` having `method` attribute of type<br/>    `spec.Queue.DeclareOk`</em></span></pre><p id="ca91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/pika/pika/blob/master/pika/adapters/blocking_connection.py" rel="noopener ugc nofollow" target="_blank">https://github . com/pika/pika/blob/master/pika/adapters/blocking _ connection . py</a></p><p id="b0f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">在第18行</em> —我们正在启动适当的机制来确保<em class="je">消息传递到RabbitMQ。</em>更多详情见<a class="ae jd" href="https://www.rabbitmq.com/confirms.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/confirms.html</a></p><p id="460a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">在第20–25行— </em>我们实际上是在向RabbitMQ发送消息。<code class="du jx jy jz jn b">basic_publish</code>方法将消息发布到特定的交换机。消息将被路由到exchange配置定义的队列，并在提交事务(如果有)时分发给任何活动的使用者。</p><p id="c97d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空的<em class="je">交换</em>名称意味着应该使用默认交换。</p><p id="f692" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je"> routing_key </em> —绑定的路由键。对于默认交换，可以提供<em class="je">队列</em>名称，因此消息将被发送到适当的队列。在这里，我们发送到<code class="du jx jy jz jn b">local</code>队列。</p><p id="b014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">正文</em> —消息正文。</p><p id="6a56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">属性(未使用)—消息的基本属性</em>。</p><ul class=""><li id="e49a" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated"><em class="je"> delivery_mode=1 </em>表示<em class="je">瞬态交货模式。</em>这意味着消息将不会存储在磁盘上，并将在代理重新启动后消失。</li><li id="070a" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><em class="je"> delivery_mode=0 </em>表示持续交付模式。您还应该将队列声明为<em class="je">持久的</em>(参见上面的<code class="du jx jy jz jn b">queue_declare</code>；您也可以在管理UI中执行此操作)。在这种情况下，消息将在代理重新启动后存储在磁盘上。</li></ul><blockquote class="kh ki kj"><p id="3f3c" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.rabbitmq.com/persistence-conf.html#how-it-works" rel="noopener ugc nofollow" target="_blank"> <em class="hi">坚持是如何工作的</em> </a></p><p id="07fe" class="if ig je ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><em class="hi">首先，介绍一些背景知识:持久消息和瞬时消息都可以写入磁盘。持久性消息将在到达队列后立即被写入磁盘，而暂时性消息将只被写入磁盘，以便在内存紧张时可以从内存中将其逐出。持久性消息也尽可能地保存在内存中，只有在内存压力下才会从内存中清除。“持久层”是指用于将两种类型的消息存储到磁盘的机制。</em></p></blockquote><p id="8f9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.rabbitmq.com/persistence-conf.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/persistence-conf.html</a></p><p id="3f6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">强制— </em>此标志告知服务器在消息无法路由到队列时如何反应。如果设置了此标志，服务器将使用返回方法返回不可路由的消息。如果该标志为零，服务器会自动丢弃该消息。</p><p id="25ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见<a class="ae jd" href="https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish" rel="noopener ugc nofollow" target="_blank">https://www . rabbit MQ . com/amqp-0-9-1-reference . html # basic . publish</a></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="2bb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这段代码使用<strong class="ih hj"> push </strong>模型:RabbitMQ在这段代码上“推送”消息——来自<code class="du jx jy jz jn b">local</code>队列的每个消息都将在<code class="du jx jy jz jn b">on_message()</code>回调中处理。</p><p id="5a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注意</em>:在PyCharm <code class="du jx jy jz jn b">Ctrl+C</code>对我不起作用的情况下，我无法发送<code class="du jx jy jz jn b">SIGINT </code>信号来中断<code class="du jx jy jz jn b">channel.start_consuming()</code>方法。终止进程会在RabbitMQ中打开连接/通道。请务必手动关闭它。从CLI运行这段代码更好。</p><p id="c49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">详见<a class="ae jd" href="https://pika.readthedocs.io/en/stable/examples/blocking_consume.html" rel="noopener ugc nofollow" target="_blank">https://pika . readthe docs . io/en/stable/examples/blocking _ consume . html</a>。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="8750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这段代码使用了<strong class="ih hj"> pull </strong>模型:它从RabbitMQ“拉”出消息。这段代码可以完全控制何时停止处理消息。它还能够知道队列何时为空。</p><p id="fc7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注:</em>我用的是<code class="du jx jy jz jn b">Twisted==20.3.0</code>。您需要安装一些额外的包来使这些代码工作。</p><p id="8b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见<a class="ae jd" href="https://pika.readthedocs.io/en/stable/examples/blocking_consumer_generator.html" rel="noopener ugc nofollow" target="_blank">https://pika . readthe docs . io/en/stable/examples/blocking _ consumer _ generator . html</a></p><p id="9d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会看完每一行，只看有趣的一行。</p><p id="8734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第74–76行，我们将至少2条消息放入队列中(以便它不为空)。</p><p id="bf86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第12–13行，我们有两个标志— <em class="je">完成</em>和<em class="je">完成_延期。</em>该变量用于不同线程之间的通信(细节将在下面提供)。</p><p id="b115" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注意:</em> Python将<em class="je">所有的对象</em>存储在主内存的一个堆上。所以在Python中不需要使用<code class="du jx jy jz jn b">volatile</code>。详见<a class="ae jd" href="https://stackoverflow.com/a/53780395/1137529" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/53780395/1137529</a>。</p><p id="20f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">已完成— </em>队列已完成填充—生产者将所有项目放入队列。</p><p id="5280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">已完成_延迟— </em>队列已完成处理—队列中的所有项目都已消耗。</p><p id="2758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第51–52行</p><p id="e5b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">#installSignalHandlers<br/> Thread(target=reactor.run, args=(False,)).start()</code></p><p id="ee67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在启动专用线程中的扭曲反应堆。</p><p id="2bb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，在Twisted应用程序中，反应器应该在主线程中启动。我们没有在主线程中这样做，我们不能安装信号处理器，所以我们通过了<code class="du jx jy jz jn b">False</code>。这不是一种标准的方法，因为我不想在这里编写Twisted应用程序，但是我想使用Twisted event-loop来使用队列中的项目。</p><p id="8bf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第60行:</p><p id="2fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">threads.deferToThread(defer_pika_queue_consume, channel)</code></p><p id="9eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码在运行Twisted event-loop的专用线程中运行<code class="du jx jy jz jn b">defer_pika_queue_consume(channel)</code>方法。</p><p id="abba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第62–63行(<code class="du jx jy jz jn b">main()</code>函数)，我们有</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="1ec0" class="jr js hi jn b fi jt ju l jv jw">global finished<br/>finished = True</span></pre><p id="636f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们模拟生产者已经完成填充队列。我们正在将此消息发送给<code class="du jx jy jz jn b">on_message</code>回调。现在，如果队列是空的，他应该停止队列消费。默认情况下，如果队列为空，它将等待新消息到达。</p><p id="bd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第65–66行(<code class="du jx jy jz jn b">main()</code>函数)中，我们有</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="036c" class="jr js hi jn b fi jt ju l jv jw">while not finished_defered:<br/>    times.sleep(20)</span></pre><p id="80db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz jn b">main()</code>函数将等待，直到<code class="du jx jy jz jn b">on_message()</code>回调将向我们发送信号，表明队列中的所有项目都已消耗，我们可以关闭到队列的连接/通道。</p><p id="95d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注:</em></p><ol class=""><li id="1a6a" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc ml md me mf bi translated">这里我们使用了<code class="du jx jy jz jn b">CountDownLatch.</code>的自旋锁实现</li><li id="e6c0" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc ml md me mf bi translated">这个实现不是基于互斥的(不是基于<code class="du jx jy jz jn b">Lock</code> / <code class="du jx jy jz jn b">RLock</code>)。详见<a class="ae jd" href="https://stackoverflow.com/q/10236947/1137529" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/q/10236947/1137529</a>。</li><li id="ed10" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc ml md me mf bi translated">我们不能在这里使用<code class="du jx jy jz jn b">connection.sleep()</code>，因为我们在不同的线程中有反应器事件循环。</li></ol></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="82d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jx jy jz jn b">on_message()</code>回调中:</p><p id="1e73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第32行</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="650e" class="jr js hi jn b fi jt ju l jv jw">for method_frame, properties, body in channel.consume(“local”, inactivity_timeout=10.0)</span></pre><p id="7b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们传递<em class="je"> inactivity_timeout </em>是为了在超时后退出对<code class="du jx jy jz jn b">consume()</code>方法的调用，以便检查<code class="du jx jy jz jn b">finished</code>标志。如果是<code class="du jx jy jz jn b">True</code>并且队列是空的，我们应该完成消费队列中的物品。</p><p id="2d1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第39–44行—在我们将<code class="du jx jy jz jn b">finished</code>标记为<code class="du jx jy jz jn b">True </code>之后，我们使用<code class="du jx jy jz jn b">channel.get_waiting_message_count()</code>调用来检查我们是否已经处理了队列中的最后一个项目。这避免了排队等候。以下代码也是正确的:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="ff31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这不是最佳的:这里我们必须至少有一个阻塞调用来打破循环。</p><p id="ccd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所提供的例子中，如果在最后一个项目被处理之前收到了<code class="du jx jy jz jn b">finished</code>消息，我们将永远无法阻止和中断循环。</p></div></div>    
</body>
</html>
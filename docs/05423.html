<html>
<head>
<title>The art of dynamic programming (pt. 2): classic algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程的艺术。2):经典算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-art-of-dynamic-programming-pt-2-classic-algorithms-3086fd47f03c?source=collection_archive---------33-----------------------#2021-07-20">https://medium.com/geekculture/the-art-of-dynamic-programming-pt-2-classic-algorithms-3086fd47f03c?source=collection_archive---------33-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fced" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你需要知道和理解的三个经典动态编程算法</h2></div><p id="ae81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是关于动态编程基础的文章的第二部分。在第一部分中，我们定义了动态规划并研究了三个简单的例子。这篇文章关注三个更高级的问题:切杆问题、计算最长增长子序列和找零问题。</p><p id="af7f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第1部分可以在这里找到:</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/@alouizakarie/the-art-of-dynamic-programming-pt-1-introduction-5d2ce0a6da24"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">动态编程的艺术。1):简介</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">学习如何运用动态编程的九个基本算法</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk kl jw"/></div></div></a></div><h1 id="9b1c" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">杆切割问题</h1><h2 id="da37" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">问题陈述</h2><p id="6df6" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">假设我们有一根长度为ℓ(其中ℓ是正整数)的杆，它由基数ℓ.的有限集表示我们可以任意多次地将它切割成具有正整数长度的子棒(由子集表示)，每次切割都不会产生任何成本。然后，我们将根据其长度<em class="lx">米</em>以价格P( <em class="lx">米</em>)出售每一根副杆。我们只知道价格是非负数:并不假设价格图是单调或同质的。<strong class="iz hj">我们的目标是计算出我们可以出售一根杆的隔板的最高价格。</strong></p><p id="916e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比如假设<em class="lx"> P </em>对于1到4之间的所有整数定义为P(1) = 4，P(2) = 6，P(3) = 2，P(4) = 1。长度为4的杆可以分割如下:</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es ly"><img src="../Images/d7859fdbd1ccc121479931f3d322ce45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRw9nZIb3BCO9BS_OSShgQ.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Price of every possible way of cutting a rod of length 4.</figcaption></figure><p id="d5dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最好的价格是16。</p><h2 id="c6f1" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">为什么我们应该使用动态编程来解决这个问题？</h2><p id="d77e" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">让我们想一个解决这个问题的递归方法。</p><p id="d937" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果杆的长度为1，那么我们就什么都不用做:最优切割是唯一的，价格为P(1)的{1}。因此，我们设置Opt(1) = P(1):它是尺寸为1的杆的最优价格(即最高价格)。</p><p id="e0b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果棒的长度ℓ ≥ 2，那么有两种可能性:保持棒原样(用P(ℓ价格的切割{ℓ}))或将其分成两个子棒。假设我们把它分成两个子棒，一个大小为k<em class="lx">k</em>一个大小为ℓ - <em class="lx"> k </em>对于某个整数k，使得1 ≤ <em class="lx"> k </em> ≤ ℓ - 1。我们将保留一个(大小为<em class="lx"> k </em>的那个)并将另一个拆分成所需数量的子子杆，以便获得最佳分区。换句话说，我们计算<strong class="iz hj">opt(ℓ)= max { p(k)+opt(ℓ-k)| 1≤k≤ℓ-1 }⋃p(ℓ)</strong>。</p><h2 id="ed27" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">编写解决方案</h2><p id="24a9" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">下面的动态规划解决方案维护一个一维数组，该数组包含长度为<em class="lx"> k </em>的最佳棒，对于每个整数<em class="lx"> k </em>使得1 ≤ <em class="lx"> k </em> ≤ <code class="du mn mo mp mq b">length</code>。</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mr"><img src="../Images/8e9c4192e2ebdc8730c4ebbc9ec747cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEZfEV_PWyv9nk0GI4NZSg.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Dynamic programming algorithm to calculate the optimal price at which we can sell a rod of a given length.</figcaption></figure><p id="606a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法在θ(ℓ)时间内运行，因为该函数被称为ℓ时间，并且内循环在θ(<em class="lx">k</em>)时间内运行，对于1和ℓ.之间的所有<em class="lx"> k </em></p><h1 id="f158" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">最长增长子序列</h1><h2 id="8046" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">问题陈述</h2><p id="093a" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">我们考虑长度为<em class="lx"> N </em> ≠ 0的有限序列<em class="lx"> S </em>(可以用数组或列表表示)。我们将S 的<em class="lx">索引定义为<em class="lx"> S </em>中所有元素的索引集——我们将在本节假设它是0和<em class="lx"> N — </em> 1之间所有整数的集合。<em class="lx"> S </em>的子序列是<em class="lx"> S </em>的索引的子集。如果<strong class="iz hj"> ( <em class="lx"> i </em>，<em class="lx">j</em>∈<em class="lx">s’</em>∧<em class="lx">I</em>≤<em class="lx">j)</em>⟹<em class="lx">s</em>[<em class="lx">I</em>]≤<em class="lx">s</em><em class="lx">的一个子序列<em class="lx">s’</em>被称为递增在本节的其余部分，LIS( <em class="lx"> k </em>)表示某个序列的最长递增子序列的长度，它在索引<em class="lx"> k </em>处结束。</em></strong></em></p><p id="ba45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的目标是计算一个序列<em class="lx"> S </em>的最长增长子序列，也就是基数最大的那个。</p><h2 id="021c" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">为什么我们要使用动态编程来解决这个问题？</h2><p id="55a7" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">我们首先需要证明这个问题可以递归地解决。如果<em class="lx"> N </em> = 1，那么只有一个索引，以及两个可能的子序列:空集和索引本身。两者都在增加(对于空集，定义中蕴涵的左边总是假的，因此蕴涵总是真的；对于基数为1的集合，对于任意一对<em class="lx"> i </em>，<em class="lx"> j </em>的单元素，我们有<em class="lx"> i </em> = <em class="lx"> j </em>，因此<em class="lx">S</em>[<em class="lx">I</em>]= S[<em class="lx">j</em>]，因此<em class="lx">S</em>[<em class="lx">I</em>≤<em class="lx">S因此，长度为1的序列的最长递增子序列是1:我们写LIS(0) = 1。</em></p><p id="7ed5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">归纳公式更加复杂。让我们考虑一个长度为<em class="lx"> N </em> ≥ 2的序列<em class="lx"> S </em>。包含<em class="lx"> N </em> — 1的<em class="lx"> S </em>的最长递增子序列或者是{ <em class="lx"> N </em> — 1}本身，如果<em class="lx"> S </em> [ <em class="lx"> N </em> — 1】是<em class="lx"> S </em>的最小元素，或者是结束于索引i ≤ <em class="lx"> N </em> — 2且其最大元素小于或等于【T88因此，<strong class="iz hj">LIS(<em class="lx">N</em>—1)= max { LIS(<em class="lx">k</em>)+1 |<em class="lx">k</em>∈[0..<em class="lx"> N </em> — 2】，<em class="lx">s</em>[<em class="lx">k</em>]≤<em class="lx">s</em>[<em class="lx">n</em>—1】}⋃{ 1 }</strong>。</p><p id="6c6f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们知道了对于每一个索引<em class="lx">k</em>S结束于索引<em class="lx"> k </em>的最长递增子序列的长度，我们只需要找到最大值，它对应于S的最长递增子序列，比如说<em class="lx"> S </em> = (1，4，2，3，5)。为了计算LIS(4)，我们需要计算LIS(0)、LIS(1)、LIS(2)和LIS(3)，因为索引0、1、2和3处的值都小于S[4]。计算LIS(0)没有成本，因为它是一个基础案例。计算LIS(1)需要计算LIS(0)，因为S[0] ≤ S[1]。计算LIS(2)需要计算LIS(0)。计算LIS(3)需要再次计算LIS(0)和LIS(2)，这又需要再次计算LIS(0):<strong class="iz hj">子问题重叠</strong>。</p><p id="c745" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用我们导出的递归关系，我们可以得到下面的自底向上实现。</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mr"><img src="../Images/3e594640d52c76a853a88cd5a714bf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COilU10tVz5xFLxM4o9eqA.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Dynamic programming algorithm to calculate the length of the longest increasing subsequence of a given sequence.</figcaption></figure><p id="e5fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了维护缓存，我们还使用了一个累加器变量<code class="du mn mo mp mq b">lisLength</code>，它包含了整个序列中最长的递增子序列的长度。当我们找到结束于索引<code class="du mn mo mp mq b">index</code>的最长递增子序列的长度时，我们检查它是否比<code class="du mn mo mp mq b">lisLength</code>长，如果需要的话就更新它。</p><p id="cf5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数的结构类似于杆切割问题的解决方案，并且它也在二次时间内运行。空间复杂度是线性的，因为我们维护了一个由N个元素组成的一维数组。</p><p id="639f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想要得到一个显式的最长递增子序列，我们可以维护一个变量<code class="du mn mo mp mq b">last</code>，它指示最长递增子序列的最后一个元素的索引，以及第二个数组，比如说<code class="du mn mo mp mq b">previous</code>，如果结束于索引<code class="du mn mo mp mq b">i</code>的最长递增子序列的长度为1，那么它包含索引<code class="du mn mo mp mq b">i</code>处的值<code class="du mn mo mp mq b">-1</code>，否则包含结束于索引<code class="du mn mo mp mq b">i</code>的最长递增子序列的前一个元素的索引。</p><p id="fcb8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们考虑序列(<em class="lx">1；3;2;6;5;4;9 </em>)那么<code class="du mn mo mp mq b">previous</code>就会是(-1；0;0;1;1;1;3)和<code class="du mn mo mp mq b">last</code>将是6。因此，最长的递增子序列包含索引<code class="du mn mo mp mq b">6</code>。<code class="du mn mo mp mq b">previous[6] = 3</code>，所以它也包含3。<code class="du mn mo mp mq b">previous[3] = 1</code>，所以它也包含1。这是最后一个元素，因为<code class="du mn mo mp mq b">previous[1] = -1</code>。</p><p id="5f41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该实现被作为一个练习。运行时间和空间复杂度不应该比我们在本节给出的版本差。</p><h1 id="07d8" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">计算变化</h1><h2 id="d3e8" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated">问题陈述</h2><p id="8851" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">这是我们在第2部分中讨论的最后一个算法。找零问题的目标是从由<em class="lx"> n </em>(不同的)元素组成的集合<em class="lx"> C </em>中计算出最少数量的硬币，其总和达到一定的数量<em class="lx"> x </em>。我们可以随心所欲地多次选择同一个硬币。例如，如果<em class="lx"> C </em> = {1，5，10，8，2}且<em class="lx"> x </em> = 10，则可能的子集包括(1，1，1，1，1，1，1，1，1)，(8，2)，(8，1，1)和(10)。问题的解是1，也就是{10}的基数。</p><h2 id="dc99" class="le kn hi bd ko lf lg lh ks li lj lk kw jg ll lm ky jk ln lo la jo lp lq lc lr bi translated"><strong class="ak">为什么我们要使用动态编程来解决这个问题？</strong></h2><p id="7f98" class="pw-post-body-paragraph ix iy hi iz b ja ls ij jc jd lt im jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">像往常一样，我们首先找到一个递归关系，它给出了问题的解，作为更小的子问题的解的函数。基本情况非常清楚:如果<em class="lx"> x </em> = 0，那么我们不需要花费任何硬币(这被称为空集和惯例:空集上的和是0)。所以最优解是Opt(0) = 0。</p><p id="b3b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<em class="lx"> x </em></p><p id="e926" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原来在最优解中，我们只需要加一个硬币。这意味着<strong class="iz hj">Opt(<em class="lx">x</em>)= min { Opt(<em class="lx">x</em>—<em class="lx">k</em>)+1 | k in<em class="lx">C</em>}</strong>。</p><p id="8a4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是显而易见的:为什么不能有一个更好的解决方案，我们增加两个硬币，或者用一个硬币换一些大于2的硬币呢？</p><p id="087d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将向您展示如何在特殊情况下证明这个陈述，当<em class="lx"> a </em> = 2:</p><blockquote class="ms mt mu"><p id="515c" class="ix iy lx iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated"><strong class="iz hj">证明大纲:</strong></p><p id="339e" class="ix iy lx iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">假设最优解实际上是Opt(x—<em class="hi">I</em>—<em class="hi">j</em>)+2，对于某些硬币<em class="hi"> i </em>和<em class="hi"> j </em>。这暗示了Opt(<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>)+2&lt;min { Opt(<em class="hi">x</em>—<em class="hi">I</em>)+1，Opt(<em class="hi">x</em>—<em class="hi">j</em>)+1 }(注意严格的不等式:我们不会介意两边是否相等)。</p><p id="566e" class="ix iy lx iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">让<em class="hi">u</em>:= Opt(<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>)。这是一个问题的解决方案，其中硬币必须加起来达到<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>。因此，存在一个<em class="hi"> u </em>硬币的集合，总计为<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>。我们可以在这个系列中加入硬币。这给出了一组<em class="hi"> u </em> + 1枚硬币，这是对硬币必须加起来达到<em class="hi"> x </em> — <em class="hi"> i </em>的问题的解决方案。因此，<em class="hi">u</em>+1≥Opt(<em class="hi">x</em>—<em class="hi">I</em>)，因为硬币不能少于最优解中的硬币。代入<em class="hi"> u </em>，得到Opt(<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>)+1≥Opt(<em class="hi">x</em>—<em class="hi">I</em>)。所以Opt(<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>)+2≥Opt(<em class="hi">x</em>—<em class="hi">I</em>)+1。同样的论点，我们加上coin <em class="hi"> i </em>而不是coin <em class="hi"> j </em>，说明Opt(<em class="hi">x</em>—<em class="hi">I</em>—<em class="hi">j</em>)+2≥Opt(<em class="hi">x</em>—<em class="hi">j</em>)+1。这就产生了矛盾。</p></blockquote><p id="c902" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">概括只是一个练习。</p><p id="bbea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在有一个递推关系，表明这个问题有最优子结构。不难找到一个输入，它将导致计算重叠子问题的结果。例如，对于硬币<strong class="iz hj"> {1，5，8，11} </strong>和<em class="lx"> x </em> = 22，循环树的顶部将如下所示:</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es my"><img src="../Images/c75115169b40a4bdc17dc88c15d62896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlK1BL7U2-L6pogYSv8lzQ.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">First three levels of the recurrence tree of a naïve recursive approach. Circles have the same colour when they correspond to identical sub-problems.</figcaption></figure><p id="9160" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">较小的优化将允许我们删除一些重复的计算，但是使用相同递归关系的非动态编程方法最终仍然会非常低效，因为当输入变得非常大时，子问题会重叠。</p><p id="be68" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用自底向上的动态编程方法，我们可以得到以下实现:</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mr"><img src="../Images/24969d880d477740857fcb8c6bd69b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wr1Q21Lmdtw4gAHG7sUJ8Q.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Dynamic programming algorithm to calculate change.</figcaption></figure></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="f674" class="km kn hi bd ko kp ng kr ks kt nh kv kw io ni ip ky ir nj is la iu nk iv lc ld bi translated">练习</h1><ol class=""><li id="d134" class="nl nm hi iz b ja ls jd lt jg nn jk no jo np js nq nr ns nt bi translated"><strong class="iz hj">(棒)</strong>【来自CLRS】如果切一根棒产生一个不变成本<em class="lx"> κ </em>怎么办，即卖分区<em class="lx"> A </em>给你A的每个元素的价格之和，减去κ卡(<em class="lx"> A </em>)？写一个动态规划算法，找出你出售一个长度为ℓ.的杆的一部分可以赚多少钱它必须具有O( <em class="lx"> N </em>)的时间复杂度和O( <em class="lx"> N </em>)的空间复杂度。</li><li id="97d8" class="nl nm hi iz b ja nu jd nv jg nw jk nx jo ny js nq nr ns nt bi translated"><strong class="iz hj"> (Rods) </strong>修改杆切割问题的自底向上解决方案，不仅计算最优价格，而且<em class="lx">打印一个价格最优的分区</em>。约束:你的解决方案必须在O( <em class="lx"> N </em>)时间内运行，并且具有O( <em class="lx"> N </em>)的空间复杂度。<br/> <strong class="iz hj"> <em class="lx">解决方案概述:</em> </strong> <em class="lx">给定一根长度为ℓ的杆，我们的算法找到将杆切割成两部分的最佳方式。这两个部分中的一个可以进一步分割，但另一个肯定会在杆的最佳分割中。因此，您可以使用一个数组，该数组将每个长度ℓ映射到最佳分区中一个杆的长度I。想办法处理这个数组获得最终解。</em></li><li id="f148" class="nl nm hi iz b ja nu jd nv jg nw jk nx jo ny js nq nr ns nt bi translated"><strong class="iz hj">(最长递增子序列)</strong>类似的问题还有最大子阵列问题。考虑一个由N个数字组成的数组。子数组是原始数组的连续部分。<em class="lx"> A </em>的最大子数组是子数组<em class="lx"> B </em>，使得<em class="lx"> B </em>的所有元素的总和最大化。<em class="lx">求算法，求</em> A <em class="lx">相对于数组</em>长度的线性时间内的最大子数组。</li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Introduction To Design Patterns: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式介绍:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-design-patterns-part-2-c01ef87ac74e?source=collection_archive---------11-----------------------#2022-10-17">https://medium.com/geekculture/introduction-to-design-patterns-part-2-c01ef87ac74e?source=collection_archive---------11-----------------------#2022-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2a5a016b00e2557f55e7923849df4304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EK0rRId4B7NIvdI3x8YjXQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@hero92?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">amin khorsand</a> on <a class="ae hv" href="https://unsplash.com/collections/335434/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="646f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个系列的这一部分，我们将看看创造性的设计模式。正如在<a class="ae hv" rel="noopener" href="/@myac.abhijit/introduction-to-design-patterns-part-1-de750d72051f">最后一部分</a>中提到的，我们知道有4个对象模式和1个类模式。让我们来看一看其中的每一个</p><h2 id="3ff6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">独生子女模式</strong></h2><h2 id="c952" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">问题</strong></h2><p id="21e3" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时我们只需要创建一个类的实例。例如，对于一个数据库连接对象，在整个解决方案中，我们需要一个用于所有用途的一致对象。</p><h2 id="4113" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="7996" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为解决这个问题而设计的类被称为单例类，它本质上利用了“静态”关键字属性。其思想是用一个类类型的静态对象作为类的数据成员、一个私有构造函数和一个返回类实例的静态方法。</p><p id="2e8c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在每次调用创建类的新实例时，我们调用静态方法，该方法有一个空检查，在实例化之前检查数据成员是否为空。在第一次调用时，成员值为null，因此创建了一个实例并将其分配给成员，我们返回成员值。从第二次调用开始，静态成员不为空(因为它是静态的，所以它不是任何对象的私有成员)，我们返回第一次调用时创建的相同值。</p><h2 id="a3a2" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9adc" class="jt ju hy ky b fi lc ld l le lf">public class SingletonDemo<br/>{<br/>      private static SingletyonDemo instance;<br/>      <br/>      private SingletonDemo() { };<br/><br/>      public static SingletonDemo GetInstance()<br/>      {<br/>            if( SingletonDemo.instance == Null)<br/>            {<br/>                  SingletonDemo.instance = new SingletonDemo();<br/>            }<br/>            return SingletonDemo.instance;<br/>       }<br/>}</span></pre><h2 id="e4a5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">构建器模式</strong></h2><h2 id="59fc" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="5458" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时我们必须构建具有多个属性的复杂对象，这些属性可能有不同的值。例如，如果我们必须建造一所房子，它将有墙壁，地板，屋顶，房间等。现在，根据房子的类型，别墅或小木屋，可能会有花园和游泳池。如果我们必须将所有这些变量放入类的构造函数中，它将变得庞大而笨拙，并且根本不可扩展。此外，有时只要改变执行的顺序或构造，结构就会改变，在这种情况下，我们将需要定义单独的构造函数，这将导致创建大量的构造函数。因此，构建器模式作为一种解决方案被引入。</p><h2 id="a6cb" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="b9f0" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Builder模式引入了两个独立的类，而不是我们需要创建其对象的复杂类，即builder类和director类。builder类有一个要构建的复杂类的实例和N个用于构建复杂类对象的各个属性的方法，最后还有一个返回所创建对象的GetResult()方法。</p><p id="05fa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于每个属性的创建都是用不同的函数来处理的，我们可以将各自的参数传递给单独的函数，这样会更简洁。此外，如果一个新的属性必须被添加，我们可以只添加一个新的函数，它可以被扩展，不需要一个单独的构造函数的变化。在某些情况下，所有的属性都不是必需的，在这种情况下，我们不会调用那个特定的函数，保持创建过程的模块化。</p><h2 id="4273" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="e1fb" class="jt ju hy ky b fi lc ld l le lf">public class House<br/>{<br/>    private int rooms;<br/>    private int floorSpace;<br/>    private string paint;<br/>    private bool HasGarden;<br/>    private bool hasPool;<br/>    <br/>    public void SetRooms(int rooms)<br/>    { this.rooms = rooms; }<br/>    <br/>    public void SetFloorSpace(int floorSpace)<br/>    { this.floorSpace = floorSpace; }<br/><br/>    public void SetPaint(string paint)<br/>    { this.paint = paint; }<br/><br/>    public void SetGarden(bool HasGarden)<br/>    { this.HasGarden = HasGarden; }<br/>   <br/>    public void SetPool(bool hasPool)<br/>    { this.hasPool = hasPool; }<br/><br/>}<br/><br/>public interface IBuilder<br/>{<br/>   void BuildRooms(int rooms);<br/>   void BuildFloor(int floorSpace);<br/>   void Paint(string paint);<br/>   void BuildGarden(bool HasGarden);<br/>   void BuildPool(bool hasPool);<br/>   House GetResults();<br/>}<br/><br/><br/>public class HouseBuilder : IBuilder<br/>{<br/>    private House instance;<br/>   <br/>    public HouseBuilder()<br/>    {    instance = new House();  }<br/>   <br/>    public void BuildRooms(int rooms)<br/>       =&gt; instance.SetRooms(rooms);<br/>    <br/>    public void BuildFloor(int floorSpace)<br/>       =&gt; instance.SetFloorSpace(floorSpace);<br/><br/>    public void Paint(string paint)<br/>       =&gt; instance.SetPaint(paint);<br/>  <br/>    public void BuildGarden(bool HasGarden)<br/>       =&gt; instance.SetGarden(HasGarden);<br/><br/>    public void BuildPool(bool hasPool)<br/>       =&gt; instance.SetPool(hasPool);<br/><br/>    public House GetResults()<br/>       =&gt; instance;<br/>}<br/><br/>public class main()<br/>{<br/>    HouseBuilder builder = new HouseBuilder();<br/>    builder.BuildRooms(2);<br/>    builder.BuildFloor(500);<br/>    builder.Paint("Blue");<br/>    builder.BuildGarden(true);<br/>    builder.BuildBool(true);<br/><br/>    House house = builder.GetResults();<br/><br/>}</span></pre><h2 id="da81" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">延长</h2><p id="47f2" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们已经看到了构建器模式是如何工作的，但是使用另一个名为Director的类可以进一步简化它。Director可能被认为是维护构建调用流和构建者创建的对象类型的构建者的领导者。</p><h2 id="6629" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">工厂模式</strong></h2><h2 id="59db" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="b935" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们考虑一个人有两辆自行车的情况，一辆运动型自行车和一辆标准的街道自行车。这两种自行车有不同的性能和骑指令取决于发动机和齿轮清单。这两种自行车具有相似的功能，因此它们可以从相同的抽象基类“Bike”扩展，或者可以实现相同的“IBike”接口。一个Person类实例可以有1个IBike实例来实现这两种类型，但是每次都使用new关键字会很麻烦，所以引入了工厂模式。</p><h2 id="5150" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="e601" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">工厂模式添加了一个工厂类函数，该函数只返回子类类型的对象。使用同一个函数我们可以实例化不同的类，并使用相应的行为和函数。</p><p id="dc5b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想添加一辆像cruiser这样的新自行车，使用这种模式将非常容易添加。</p><h2 id="9eec" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="728f" class="jt ju hy ky b fi lc ld l le lf">public interface IBike<br/>{<br/>     public void Accelerate();<br/>}<br/><br/>public class SportsBike: IBike<br/>{<br/>     private int Mileage;<br/>     private int MaxSpeed;<br/>     private int Gears;<br/><br/>     public SportsBike(int mileage, int speed, int gears)<br/>     {<br/>         Mileage = mileage;<br/>         Speed = speed;<br/>         Gears = gears;<br/>     }<br/>    <br/>     public static IBike Create()<br/>         =&gt; new SportsBike(20, 240, 6)<br/>     <br/>     public void Accelerate()<br/>     {<br/>           print($"0-20 -&gt; Gear 1");<br/>           print($"20-40 -&gt; Gear 2");<br/>           print($"40-60 -&gt; Gear 3");<br/>           print($"60-90 -&gt; Gear 4");<br/>           print($"90-130 -&gt; Gear 5");<br/>           print($"&gt;130 -&gt; Gear 6");<br/>     }<br/>}<br/><br/>public class StandardBike: IBike<br/>{<br/>     private int Mileage;<br/>     private int MaxSpeed;<br/>     private int Gears;<br/><br/>     public SportsBike(int mileage, int speed, int gears)<br/>     {<br/>         Mileage = mileage;<br/>         Speed = speed;<br/>         Gears = gears;<br/>     }<br/>    <br/>     public static IBike Create()<br/>         =&gt; new SportsBike(45, 140, 5)<br/>     <br/>     public void Accelerate()<br/>     {<br/>           print($"0-20 -&gt; Gear 1");<br/>           print($"20-40 -&gt; Gear 2");<br/>           print($"40-60 -&gt; Gear 3");<br/>           print($"60-80 -&gt; Gear 4");<br/>           print($"80-140 -&gt; Gear 5");<br/>     }<br/>}<br/><br/>public class BikeFactory<br/>{<br/>     private static IBike bike;<br/>   <br/>     public static IBike BikeFactory(string type)<br/>     {<br/>           switch(type)<br/>           {<br/>               case "Sports":<br/>                  bike = new SportsBike.Create();<br/>                  break;<br/>   <br/>               case "Standard":<br/>                  bike = new StandardBike.Create();<br/>                  break;<br/>               <br/>               default:<br/>                  break;<br/>          }<br/>     }<br/>}<br/>                   <br/>var bike = BikeFactory.BikeFactory("Sports");<br/>bike.accelerate();</span></pre><h2 id="7fc6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">原型图案</strong></h2><h2 id="7a94" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="0482" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">有时有一些类，其实例的属性变化有限。在这种情况下，我们需要相同对象的多个副本。让我们考虑汽车发动机，梅赛德斯为一系列汽车制造类似的发动机，这些发动机后来进行了改装。现在，为了创建精确的引擎副本，我们需要传递完全相同的参数，我们从我们克隆的对象中获取数据成员，但有时它们是私有的，不能从外部访问。同样，为了实例化一个复制对象，我们需要原始对象是其实例的类，所以我们变得依赖于该类，这引入了紧耦合。此外，有时对象是作为接口的实例传递的，在这种情况下，我们不能正确地实现类。</p><h2 id="4c6c" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="45b6" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了解决这个问题，我们向需要克隆自身的实际对象添加了克隆功能。作为成员方法的函数可以访问对象的私有成员。对于层次类，我们将一个抽象的clone()函数放在基类中，并在子类中覆盖。具有Clone()的类称为原型。因为这样的实例数量是固定的，所以它们被创建并存储在一个列表中，以加速克隆过程，而不是在以后创建。该数组称为原型注册表。</p><h2 id="7f02" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码片段</h2><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5d07" class="jt ju hy ky b fi lc ld l le lf">public interface IShape<br/>{<br/>      public int GetArea();<br/>      public IShape Clone();<br/>}<br/><br/>public class Square : IShape<br/>{<br/>      private int side;<br/><br/>      public Square( int side )<br/>      {<br/>            this.side = side;<br/>      }<br/><br/>      public int GetArea()<br/>         =&gt; side * side;<br/><br/>      public IShape Clone()<br/>         =&gt; new Square(side);<br/>}<br/><br/>public class Circle : IShape<br/>{<br/>      private int radius;<br/>      private const pi = 3.14;<br/><br/>      public Square( int radius )<br/>      {<br/>            this.radius = radius;<br/>      }<br/><br/>      public int GetArea()<br/>         =&gt; radius * radius * pi;<br/><br/>      public IShape Clone()<br/>         =&gt; new Circle(radius);<br/>}<br/><br/>var circle = new Circle(3);<br/>var circle2 = circle.Clone()</span></pre><h2 id="a1c4" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">抽象工厂模式</h2><h2 id="f745" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题</h2><p id="2b33" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们用一个例子来理解这一点，假设一家跨国公司正在建立生产汽车的工厂。所以，通常一家工厂生产掀背车、SUV和轿车。但是现在，每个国家都有一套关于汽车排放、引擎和驾驶座位排列的独立规则，例如:印度是右座驾驶，而美国是左座驾驶。如果我们在这里也使用子类和继承，这将导致类的爆炸式增长，以及冗余。</p><h2 id="d17d" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解决办法</h2><p id="c6b7" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">抽象工厂模式通过在我们旧的学校工厂模式上增加另一个抽象层来解决这个问题。它指出，我们应该有一个工厂接口，根据配置或需求返回工厂类的类型。比如说，接口车定义为:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4a99" class="jt ju hy ky b fi lc ld l le lf">public interface ICar<br/>{<br/>     public void Start();<br/>     public void Stop();<br/>     public void GetPerformanceDetails();<br/>     public void GetUsageDetails();<br/>     public ICar CreateCar();</span><span id="5deb" class="jt ju hy ky b fi lg ld l le lf">}</span></pre><p id="846c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，所有三类汽车，即轿车、SUV和掀背车都实现了这些接口，然后我们可以有一个工厂类来根据需要返回对象，这就是我们在工厂类中看到的。在这种情况下，我们将另外拥有另一个接口，它实际上被定义为</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ca92" class="jt ju hy ky b fi lc ld l le lf">public interface ICarFactory<br/>{<br/>    public ICarFactory CreateFactory(Location location);<br/>}</span></pre><p id="8c3a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该接口由每个工厂为特定区域实现，如IndiaCarFactory和USACarFactory类，它们依次返回对象。</p><h2 id="509f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="b8de" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在这篇文章中，我们已经看到了创造性的设计模式。在下一部分中，我们将了解一下结构设计模式。</p><p id="a0f0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐阅读！</p></div></div>    
</body>
</html>
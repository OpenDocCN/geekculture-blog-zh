<html>
<head>
<title>Dependency Injection in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dependency-injection-in-javascript-2d2e4ad9df49?source=collection_archive---------0-----------------------#2021-03-16">https://medium.com/geekculture/dependency-injection-in-javascript-2d2e4ad9df49?source=collection_archive---------0-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0fc15a01fe9a5877472298563f06b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAIokTMzWNaojBzMdrzQEQ.jpeg"/></div></div></figure><p id="dade" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a> (DI)是一种编程模式，其中使用参数传递依赖，而不是在函数或类中实例化它。DI支持在应用程序代码中创建独立的组件，并使将来随着需求的变化切换这些依赖关系变得容易。将参数作为依赖项传递还允许通过注入它们的模拟版本来轻松地对那些组件进行单元测试。</p><p id="35a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文使用<strong class="is hj">高阶函数</strong>探索Javascript中的依赖注入，并将其与类进行比较。这种模式适用于任何支持独立函数定义的语言。</p><p id="ff55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于本文的其余部分，让我们假设我们正在构建一个简单的假设应用程序，它有一个<code class="du jp jq jr js b">Course</code>实体，并且课程有<code class="du jp jq jr js b">Lesson</code>。<code class="du jp jq jr js b">AWS DynamoDB</code>存储课程，<code class="du jp jq jr js b">S3</code> bucket将课程存储为JSON对象。</p><p id="42c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，为了理解这种模式，让我们探索如何使用类实现依赖注入，然后我们将探索使用javascript函数的这种模式的一些例子。</p><h1 id="c311" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用类的依赖注入</h1><p id="296a" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">首先，让我们探索使用类的依赖注入，然后我们可以将它与使用高阶函数的依赖注入进行比较。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/24562df5b810957ba61cb53e03bbf7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtiC7mcJAynKrlbnc5Gr_w.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">DI using classes</figcaption></figure><p id="3bf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们定义了一个拥有两种方法的课程类。<code class="du jp jq jr js b">courseById</code>从DynamoDB获得课程<code class="du jp jq jr js b">addLesson</code>给S3增加了一堂课。我们还从<code class="du jp jq jr js b">aws-sdk</code>注入了<code class="du jp jq jr js b">documentClient</code>和<code class="du jp jq jr js b">S3</code>。</p><p id="438d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了这个类和一些方法，让我们看看如何使用它。为了在我们的应用程序中使用它，我们首先需要创建一个<code class="du jp jq jr js b">Course</code>的实例。除非我们使用依赖注入框架，否则我们通常使用<code class="du jp jq jr js b">Factory</code>类来实现。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/b66c0c8b854511fd4a987d13d7475010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QwKQnMlhdIb7GIgvnDuVMg.png"/></div></div></figure><p id="fb00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以在应用程序中使用<code class="du jp jq jr js b">Factory.createCourse</code>来创建一个实例，当然，然后调用适当的方法。我们可以扩展<code class="du jp jq jr js b">Factory</code>来包含其他静态方法，以创建类似<code class="du jp jq jr js b">Lesson</code>的其他实体的实例。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/bed1c922ad63745ee284b4a36958804f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dp0WbKu99fn1QsveNPCUoA.png"/></div></div></figure><p id="9ff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果将来需求发生变化，我们需要将<code class="du jp jq jr js b">Course</code>存储在其他商店中，那么我们可以更新<code class="du jp jq jr js b">Factory</code>或<code class="du jp jq jr js b">Course</code>此外，我们的业务逻辑将保持不变。</p><h1 id="c877" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用高阶函数的依赖注入</h1><p id="d840" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在使用类的例子中，注意我们总是需要有一个<code class="du jp jq jr js b">S3</code>和<code class="du jp jq jr js b">DocumentClient</code>的实例，然后才能有一个<code class="du jp jq jr js b">Course</code>的实例。</p><p id="eb48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一个场景，我们有一个网络钩子或<code class="du jp jq jr js b">AWS Lambda Function</code>，它的工作是<code class="du jp jq jr js b">getCourseById</code>。在这个场景中，我们将最终创建一个实例<code class="du jp jq jr js b">S3</code>，尽管我们不会在这个请求中使用它。</p><p id="01a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在实际的应用程序中，可能有更复杂的逻辑来设置和拆除每个依赖项，这可能会降低性能。</p><p id="17bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来探讨函数级的依赖注入。</p><p id="3e3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种模式的前提是基于一个函数返回另一个函数(<strong class="is hj">高阶函数</strong>)。高阶函数接受子函数执行其工作所需的所有依赖性。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/69a90858e18e30b90d544ab322542a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwoO7lYnfMcEXf6J7UaYOQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">DI with a higher-order function</figcaption></figure><p id="2182" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们创建了一个名为<code class="du jp jq jr js b">makeGetCourseById</code>的函数。它的工作是创建一个函数，我们可以用它通过id获取课程。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/f3e8f794c82d5678bb693bda4a6462e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgbhcV_i70mMBgGcgPJhqg.png"/></div></div></figure><p id="296f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以在应用程序代码中使用上面提到的高阶函数。对于<code class="du jp jq jr js b">addLesson</code>，我们可以遵循相同的模式。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/58d03e4fbb846c529b3d3290ce6815b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2C88j0KuuoCDKTeQJePXEQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">DI with a higher-order function</figcaption></figure><p id="0dc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">高阶函数的想法是，我们一次性创建像<code class="du jp jq jr js b">getCourseById</code>或<code class="du jp jq jr js b">addLesson</code>这样的独立函数，并在我们的应用程序中传递实例。如果我们不使用高阶组件，那么每次我们想通过id获取课程时，我们都需要传递一个<code class="du jp jq jr js b">documentClient</code>或<code class="du jp jq jr js b">s3</code>的实例。</p><p id="c1f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下代码示例演示了如何在<code class="du jp jq jr js b">AWS Lambda Handler</code>中使用高阶函数。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/902b02ceab4f3507ff005c6fadfd8037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkHDbBaARNN_WMNy_kld_A.png"/></div></div></figure><h1 id="81cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建具有高阶函数的服务</h1><p id="a312" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">有些情况下，我们可能需要创建一个方法集合来使用，而不需要初始化每个方法。例如，我们想在<code class="du jp jq jr js b">GraphQL</code>上下文中附加一个带有方法集合的服务，以便在GraphQL解析器中使用它们。</p><p id="e3ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，我们可以创建一个函数来返回一个包含函数集合的对象。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/d4c64231bf315d876432243610e6da21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amq_NAiDQesdQPOgswqnmg.png"/></div></div></figure><p id="8c3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以在应用程序代码中使用它，如下所示。请记住，如果可能的话，我们会在每次应用程序执行时创建一个<code class="du jp jq jr js b">courseService</code>的实例，甚至可以在必要时缓存它。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/7d4268983578729f1f33118ad7d233b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LArI4hor-wbI6K80P1mag.png"/></div></div></figure><h1 id="5c27" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">传递方法</h1><p id="91ee" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们经常会遇到这样的情况，我们可能想要在一个高阶函数中使用另一个高阶函数。例如，我们可能希望在添加课程之前检查该课程是否存在。我们可以通过在参数中接受<code class="du jp jq jr js b">getCourseById</code>和<code class="du jp jq jr js b">S3</code>来解决这个问题。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/e3bc80fd715a39b100e0e1a9a99cae48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjfAB-V8zo9BJGgHlIFR9A.png"/></div></div></figure><p id="72af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序代码将如下所示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/e9506c8b7da13d059445824dd04dbb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdsmyvCy1E1YUeKWDhYn-Q.png"/></div></div></figure><h1 id="7180" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="7618" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们探索了在Javascript中实现依赖注入的两种不同方法。在Javascript中实现依赖注入的一种方式是使用<code class="du jp jq jr js b">Class</code>和<code class="du jp jq jr js b">Factory</code>。另一种方法是使用高阶函数来实现函数级的粒度注入。根据不同的应用用例，最好选择一种方法并坚持下去。高阶函数使用起来相对简单，并且比Javascript类更灵活。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="5e66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ls">在</em> <a class="ae jo" href="https://twitter.com/adikari" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> Twitter </em> </a> <em class="ls">上关注我或者在</em><a class="ae jo" href="https://github.com/adikari" rel="noopener ugc nofollow" target="_blank"><em class="ls">Github</em></a><em class="ls">上查看我的项目。</em></p></div></div>    
</body>
</html>
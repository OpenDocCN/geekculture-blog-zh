<html>
<head>
<title>3 Things Every React Context Should Have</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个React上下文应该具备的3个要素</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/3-things-every-react-context-should-have-aae5ce92f1e6?source=collection_archive---------20-----------------------#2021-05-19">https://medium.com/geekculture/3-things-every-react-context-should-have-aae5ce92f1e6?source=collection_archive---------20-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2fc5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">结构、一个挂钩和一个高阶组件</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div><figcaption class="je jf et er es jg jh bd b be z dx"><a class="ae ji" href="https://youtu.be/cXYiVvgsYNk" rel="noopener ugc nofollow" target="_blank">Video version of this post</a></figcaption></figure><p id="582d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我一直在使用一种对我很有效的模式，我认为这是值得分享的东西。</p><h1 id="7270" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">文件夹结构</h1><p id="16af" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">创建一个新文件夹来存放项目的上下文变量。这样，项目中使用的所有上下文都可以从同一个文件夹中方便地访问。</p><p id="3293" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将为我的上下文创建一个文件夹，因为将来我会向其中添加更多的文件。我将创建的上下文是一个门面，用于与将在web worker上运行的未来代码运行程序进行通信。我将创建一个<code class="du kf kg kh ki b">~/src/contexts/code-runner/index.tsx</code>文件，但是如果你没有多个上下文专用的文件，没有必要创建一个单独的文件夹，只需将你的文件直接放在<code class="du kf kg kh ki b">~/src/contexts</code>文件夹中。</p><h1 id="a1fd" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">创造环境</h1><p id="f684" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">使用<code class="du kf kg kh ki b">React.createContext()</code>创建一个上下文。我把上下文的初始值给<code class="du kf kg kh ki b">{}</code>只是作为一个占位符。我也喜欢尽可能地添加<code class="du kf kg kh ki b">displayName</code>，因为当在浏览器中使用React Dev Tools扩展时，它会以这个名称显示。</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="d273" class="lk kk hi ki b fi ll lm l ln lo"><em class="lp">const </em>CodeRunnerContext = <em class="lp">createContext</em>({});<br/>CodeRunnerContext.displayName = "CodeRunner";</span></pre><p id="cd46" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，我没有导出代码运行环境，这是有原因的。我想控制如何使用这个上下文。所有使用上下文的组件应该以同样的方式使用它。</p><p id="32ce" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了实现这一点，我总是导出一个钩子来使用上下文，并导出一个高阶组件HOC来提供上下文。</p><h1 id="7ff8" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">自定义挂钩</h1><p id="1831" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">用<code class="du kf kg kh ki b">useContext</code>实现一个定制钩子是没有痛苦的。只需创建一个将返回一个<code class="du kf kg kh ki b">useContext.</code>的新函数</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="cb8d" class="lk kk hi ki b fi ll lm l ln lo"><em class="lp">export const useCodeRunner </em>= () =&gt; <em class="lp">useContext</em>(CodeRunnerContext);</span></pre><h1 id="5cef" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">定制高阶组件(HOC)</h1><p id="1cfd" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">就像钩子有一个以“使用”开头的约定。高阶组件有以“with”开头的约定。第一个函数接受一个React组件，返回的函数是另一个React函数组件，它将第一个组件包装在一个上下文提供者中。</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="5c96" class="lk kk hi ki b fi ll lm l ln lo"><em class="lp">export const withCodeRunner </em>= (Component) =&gt; (props) =&gt; {<br/>  <em class="lp">return </em>(<br/>    &lt;CodeRunnerContext.Provider <em class="lp">value</em>={{}}&gt;<br/>      &lt;Component {...props} /&gt;<br/>    &lt;/CodeRunnerContext.Provider&gt;<br/>  );<br/>};</span></pre><h1 id="d57e" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">用法示例</h1><p id="e39b" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">假设我们有一个组件<code class="du kf kg kh ki b">AppComponent</code>，它是一个返回空React片段的基本组件。我们需要做的就是在这个组件中添加我们的定制钩子<code class="du kf kg kh ki b">useCodeRunner</code>，然后用我们的定制钩子<code class="du kf kg kh ki b">withCodeRunner</code>包装这个组件。</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="aa9a" class="lk kk hi ki b fi ll lm l ln lo">const AppComponent = withCodeRunner(() =&gt; {<br/>  const codeRunner = useCodeRunner();<br/>  return &lt;&gt;&lt;/&gt;<br/>});</span></pre><p id="bbdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用这一对，您可以快速地向任何组件添加上下文。</p><p id="2752" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一种常见的模式是仅用HOC封装导出的组件。这样，代码变得更加清晰。</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="8d96" class="lk kk hi ki b fi ll lm l ln lo">const AppComponent = () =&gt; {<br/>  const codeRunner = useCodeRunner();<br/>  return &lt;&gt;&lt;/&gt;<br/>};</span><span id="f306" class="lk kk hi ki b fi lq lm l ln lo">export const App = withCodeRunner(AppComponent);</span></pre><p id="ff01" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这种情况下，需要注意的一点是，如果在同一个文件中使用,<code class="du kf kg kh ki b">AppComponent</code>将不会单独工作。您将总是需要使用<code class="du kf kg kh ki b">App</code>组件，因为它提供了上下文。</p><h1 id="5789" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">打字稿打字</h1><p id="2fa9" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">对于<code class="du kf kg kh ki b">useCodeRunner</code>钩子，它应该继承上下文的类型。</p><p id="1988" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于HOC，因为我包装了一个函数组件并返回了一个函数组件，所以需要做的就是将包装的组件期望的属性传递给返回的组件。</p><pre class="ix iy iz ja fd lg ki lh li aw lj bi"><span id="02c3" class="lk kk hi ki b fi ll lm l ln lo"><em class="lp">type WithCodeRunner </em>= &lt;T&gt;(<br/>  Component: <em class="lp">FunctionComponent</em>&lt;T&gt;<br/>) =&gt; <em class="lp">FunctionComponent</em>&lt;T&gt;;</span><span id="1e74" class="lk kk hi ki b fi lq lm l ln lo"><em class="lp">export const withCodeRunner: WithCodeRunner </em>= (Component) =&gt; (props) =&gt; { /* ... */ };</span></pre><h1 id="4529" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b9f7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">上下文应该在它们自己的文件中，并在上下文文件夹中组合在一起。上下文应该只导出两样东西，一个钩子来消费上下文，一个高阶组件来提供上下文。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="93e3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="lp">原籍:</em></p><div class="ly lz ez fb ma mb"><a href="https://www.bayanbennett.com/posts/3-things-every-react-context-should-have-devlog-008" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">每个React上下文都应该具备的3样东西| DevLog 008</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">我一直在用一种反应模式。对我来说效果很好的环境，我认为它值得…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.bayanbennett.com</p></div></div></div></a></div></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/0ed48381791af7ff4ed3b2870b0dda36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1KsvuevG4HaQSSB4nvZ5w.jpeg"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">just for the thumbnail</figcaption></figure></div></div>    
</body>
</html>
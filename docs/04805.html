<html>
<head>
<title>Cohort Analysis with PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PySpark队列分析</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cohort-analysis-with-pyspark-90b557685e72?source=collection_archive---------12-----------------------#2021-07-04">https://medium.com/geekculture/cohort-analysis-with-pyspark-90b557685e72?source=collection_archive---------12-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ab57e1afde9a261b36e0dc45a5304d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6CDgIAMt2l2vDoFqhwv6A.jpeg"/></div></div></figure><blockquote class="iq ir is"><p id="9f98" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">比以往任何时候都更接近您的客户。近到在他们自己意识到之前，你就告诉他们需要什么。<br/> —史蒂夫·乔布斯</p></blockquote></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="86c0" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="4e6a" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">客户分析对任何企业的生存都很重要。如果没有对客户的痴迷，苹果和亚马逊等成功的科技公司不可能走到今天这一步。今天，几乎所有的公司都在转向以客户为中心，并采取策略来留住客户。虽然有许多定量和定性的方法，但一种非常流行的评估客户保持率的方法是<em class="iv">群组分析</em>。</p><h2 id="a2a4" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">断代分析</h2><p id="a381" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">什么是队列？简单来说，就是一群有着共同特点的人。例如，一群出生于1998年3月2日的人。</p><p id="a215" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">那么什么是队列分析呢？根据维基百科:</p><blockquote class="iq ir is"><p id="7090" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Cohort_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">群组分析</strong> </a>是一种<a class="ae lt" href="https://en.wikipedia.org/wiki/Behavioral_analytics" rel="noopener ugc nofollow" target="_blank">行为分析</a>在分析之前将一个数据集中的数据分成相关的群组。</p></blockquote><p id="dcf3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">通常，它被用来研究客户保持力，因此被命名为<em class="iv">保持力分析</em>。假设你刚刚推出了一款新产品。自然，你会希望你的用户在第一次之后继续回来。群组分析是一种探索重复用户的流行方法。电子商务、游戏和医疗保健网站一直都在使用它。如果你用过谷歌分析，你一定很熟悉它。</p><h2 id="e981" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">PySpark API</h2><p id="b7db" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">像谷歌和亚马逊这样的公司从客户和他们的产品的互动中收集了数Pb的数据。虽然数据科学和分析领域流行的编程语言(如R和Python)能够很好地处理千兆字节，但当处理大数据时，它们的局限性就变得很明显了。</p><p id="11c5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">PySpark是为配合Spark框架使用Python而编写的API。前者提供了简单性，后者提供了速度。因此，PySpark使我们能够编写可伸缩的程序。理想情况下，程序在机器集群上执行，比如AWS EC2实例或Google Cloud虚拟机。AWS<strong class="iw hj">E</strong>lastic<strong class="iw hj">M</strong>AP<strong class="iw hj">R</strong>educe(EMR)是一个托管服务，有助于轻松运行PySpark脚本。数据是在一个集群上分发和处理的，而不是在一台可能不适合它的机器上。</p><p id="3131" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">值得注意的是，可伸缩性和性能是Pandas或其他基于Python的工具不适合生产工作负载的主要原因。</p><p id="cdfc" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">这篇博客介绍了一种使用PySpark进行队列分析的方法。以下是概要:</p><ul class=""><li id="7501" class="lu lv hi iw b ix iy jb jc kz lw lb lx ld ly jr lz ma mb mc bi translated"><strong class="iw hj">前提条件</strong> —需要了解的基本概念。</li><li id="5bad" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated"><strong class="iw hj">数据角力</strong> —分析在行动。</li><li id="db1e" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated"><strong class="iw hj">特殊情况</strong> —队列分析中的特殊情况。</li><li id="9698" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated"><strong class="iw hj">结论</strong> —客户分析和群组分析的总结。</li></ul><h1 id="943a" class="jz ka hi bd kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw bi translated">先决条件</h1><p id="d3f2" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">本节涵盖了分析前需要理解的先决条件。下面是PySpark的SQL模块提供的工具，您必须熟悉这些工具:</p><ol class=""><li id="ab1b" class="lu lv hi iw b ix iy jb jc kz lw lb lx ld ly jr mn ma mb mc bi translated"><strong class="iw hj"> GroupBy </strong>:对列进行分组并执行聚合。</li><li id="d9b7" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr mn ma mb mc bi translated"><strong class="iw hj"> Join </strong>:合并两个表。</li><li id="5434" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr mn ma mb mc bi translated"><strong class="iw hj">窗口功能</strong>:对数据进行分区并执行操作。</li><li id="9cd1" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr mn ma mb mc bi translated"><strong class="iw hj"> WithColumn </strong>:根据某种操作引入一个新列。</li><li id="8e3c" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr mn ma mb mc bi translated"><strong class="iw hj"> SQL函数</strong>:执行常用操作的工具。</li></ol><p id="3dd4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">别担心，你不必成为专家。随着你的阅读，你可能会更好地理解它们。</p><h1 id="856b" class="jz ka hi bd kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw bi translated">数据争论</h1><p id="a76a" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">好的，让我们看看我们的数据。同样的情况也可以在<a class="ae lt" href="https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo" rel="noopener ugc nofollow" target="_blank">卡勾</a>上找到。它被描述为:</p><blockquote class="iq ir is"><p id="507d" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个<!-- -->跨国数据集，包含2010年1月12日和2011年9月12日之间发生的英国注册无店铺在线零售的所有交易。</p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/91c023816df36eed3828305900ec1121.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*Kodon-7RGQyJZFqmoFaVtQ.png"/></div></figure><p id="8e60" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">总共有10列。然而，我们只对<em class="iv">发票日期</em>和<em class="iv">客户ID </em>感兴趣。</p><p id="5618" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">首先，使用PySpark读入数据集。然后只选择感兴趣的列。InvoiceDate和CustomerID分别是DateType和StringType。</p><p id="b9dd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">太好了！我们将每天、每周、每月、每季度和每年进行队列分析。</p><h2 id="e459" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">每日队列</h2><p id="c577" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">数据集跨度超过一年。为了简单起见，让我们考虑从2010年12月1日开始到2010年12月10日结束的前10天。</p><p id="8258" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated"><strong class="iw hj">第一步:</strong>找出每位顾客第一次购物的时间</p><p id="bf45" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">首先按客户对数据进行分区，并按交易的升序对每个客户分区进行排序。然后选择每个客户的第一个交易日期。我们把这个专栏叫做<em class="iv"> FirstPurchaseDate吧。</em></p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/5422db8bd2384e55b638afbebe9a4600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fV0K9fG7gb-wyd3UHLFzlQ.png"/></div></div></figure><p id="e9a9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated"><strong class="iw hj">第二步:</strong>寻找复发</p><p id="0019" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">重现告诉我们多少天后每个顾客被再次观察。这可以通过从InvoiceDate中减去FirstPurchaseDate得到。让我们把这个专栏叫做<em class="iv"> ReturnDays </em>。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/fb0bce992d1ecec0913fa9128bdef26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMTvk9q6p4orjCfXw1LoTQ.png"/></div></div></figure><p id="91ea" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">到目前为止，我们的数据集看起来像这样:</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/25e6984896802bcaa3fd602dcc524f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*7MhF15OTcJVBfUAlmrdafA.png"/></div></figure><p id="728f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated"><strong class="iw hj">第三步:</strong>统计第一次日期和重复周期相同的客户</p><p id="97b6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">具有相同首次购买日期和返回日期的客户组成一个群组。根据您的使用情况，您可能希望使用<em class="iv"> F.count </em>来统计所有(包括同一客户的多次出现)或<em class="iv"> F.countDistinct </em>来统计唯一用户。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/fb21c2865c823fd43193b89de79ab0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHclKFx53So470jjrgjS_g.png"/></div></div></figure><p id="c4e8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated"><strong class="iw hj">第四步:</strong>获取队列矩阵</p><p id="98e7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">上一步中的聚合数据集是长格式。我们希望它是<em class="iv">宽格式</em>，以便更好地观察随时间推移的队列。为此，请透视数据集。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/144f2537fbd294630562855f322a288a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-M-TfWvlXbUIjvqLpP7YYg.png"/></div></div></figure><p id="b33c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">因此，我们获得了一个队列矩阵，让我们探索客户随时间的重复。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/9614ea9b5d1233072daf4466fc9faa92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*jzNunX4vZb_9385rVhjZZQ.png"/></div><figcaption class="my mz et er es na nb bd b be z dx">Cohort matrix</figcaption></figure><p id="f878" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">每行代表所需范围内的一个日期，每列代表该日期之后的天数。让我们按照列从左到右的递增顺序来研究第一行。</p><ul class=""><li id="82cf" class="lu lv hi iw b ix iy jb jc kz lw lb lx ld ly jr lz ma mb mc bi translated">日期后0天(即2010年12月1日)，观察了1968名顾客。</li><li id="8078" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated">一天后(即2010年12月2日)，1968名顾客中的229名被观察到</li><li id="d374" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated">2天后(即2010年12月3日)，1968名顾客中的119名被观察到，以此类推。</li></ul><p id="e8dd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">类似地，我们可以研究每一行，以了解在给定日期来的客户中有多少人在随后的日期也来了。几个模式可能会变得明显。例如，我们可能会在每个周末或每5天发现一个高峰，并据此锁定目标客户或制定策略。</p><p id="375c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">很多时候，群组矩阵中的绝对值被替换为增长百分比。这可以通过将每列除以相应的0列值并乘以100来实现。例如，在2010年12月1日观察到的所有客户中，(229/1968)x100 = 11.63%也是在2010年12月2日观察到的。</p><p id="ede5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">这让我们对模式一目了然。</p><p id="e428" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">如果您的群组矩阵不太大，您可以将其转换为熊猫数据框架，并可视化热图。</p><h2 id="637e" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">每周一组</h2><p id="f215" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">如果我们想每周研究一次群体呢？在这种情况下，首先构建一个列，指示每个InvoiceDate属于哪一周。这里有一个使用PySpark的好方法。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/0464c1f6f67c51f954bb47a7165f01de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_jYNh9ENFy8tVzbsadV9A.png"/></div></div></figure><p id="d767" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">基本上就是找到下一个周一，减去7天。遗憾的是，我们无法直接找到最后一个星期一。称之为<em class="iv">周开始日期</em>。使用它代替InvoiceDate进行分析。</p><h2 id="a7b0" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">每月一组</h2><p id="ee08" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">类似地，对于每月分析，找出给定日期所在月份的第一天。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/36879b100d03500568b2d1f079b683d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1un53b9LhftKfXbR18FwGA.png"/></div></div></figure><h2 id="a7da" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">季度队列</h2><p id="015a" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">在这种情况下，这种方法有点冗长。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/4ea61c5e01f25d4f9d6e51bd196476cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4K_MO4WTUwrW-B2_jDapg.png"/></div></div></figure><h2 id="3dbf" class="lf ka hi bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls bi translated">年度队列</h2><p id="f27b" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">就像上面一样，通过将"<em class="iv"> Year" </em>"与"--<em class="iv">01–01 "</em>"连接起来，构造<em class="iv">years startdate</em>。</p><p id="4b7f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">通过适当分组，我们也可以分析2年队列。PySpark提供了一些漂亮的函数来完成其他困难的任务。</p><h1 id="bb2c" class="jz ka hi bd kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw bi translated">特殊情况</h1><ul class=""><li id="8971" class="lu lv hi iw b ix kx jb ky kz ne lb nf ld ng jr lz ma mb mc bi translated">例如，脸书想要分析在特定日期访问脸书并在随后几天访问Instagram的人群。在这种情况下，问题不是直接的。首先，我们必须只选择那些第一次访问脸书的用户，然后对他们进行分析，以了解后续的Instagram访问。</li><li id="7105" class="lu lv hi iw b ix md jb me kz mf lb mg ld mh jr lz ma mb mc bi translated">对于某些应用，我们可能不得不在分析中忽略周六和周日或公共假日。例如，其他都一样，在周五被观察的人中，有多少在周一又被观察了？在这种情况下，几乎总是可以简单地删除所有星期六和星期天。</li></ul><h1 id="7a3f" class="jz ka hi bd kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw bi translated">结论</h1><p id="ff7a" class="pw-post-body-paragraph it iu hi iw b ix kx iz ja jb ky jd je kz la jh ji lb lc jl jm ld le jp jq jr hb bi translated">客户分析是一个很好的方式来更好地了解你的客户。它回答了一些重要的问题——他们喜欢你的产品吗？他们最喜欢产品的哪一部分？你产品的哪些特性收到的负面反馈最多？你应该继续提供产品吗？你应该改变策略吗？许多这样的问题可以通过简单地建立一个群体矩阵来回答。通常情况下，数据很大，PySpark是您的朋友。</p><h1 id="5a99" class="jz ka hi bd kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw bi translated"><strong class="ak">参考文献</strong></h1><div class="nh ni ez fb nj nk"><a href="https://en.wikipedia.org/wiki/Cohort_analysis" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">群组分析-维基百科</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">群组分析是一种行为分析，它将数据集中的数据分成相关的组，然后…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">en.wikipedia.org</p></div></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://towardsdatascience.com/calculate-your-monthly-recurring-customer-by-cohort-analysis-3d39473482b7" rel="noopener follow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">通过群组分析计算你每月的回头客</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">解释如何使用python数据分析计算您企业的重复客户。</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny io nk"/></div></div></a></div></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="03da" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kz jg jh ji lb jk jl jm ld jo jp jq jr hb bi translated">我是Searce数据科学和机器学习团队的一名软件工程师，在那里我与AWS/GCP一起开发数据产品。我是TensorFlow粉丝，Kaggle专家，热爱篮球。在<a class="ae lt" href="https://www.linkedin.com/in/akshit-bhalla/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</p></div></div>    
</body>
</html>
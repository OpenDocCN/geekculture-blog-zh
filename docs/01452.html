<html>
<head>
<title>Defining Classes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中定义类</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/defining-classes-in-javascript-9678d677fc6b?source=collection_archive---------17-----------------------#2021-04-10">https://medium.com/geekculture/defining-classes-in-javascript-9678d677fc6b?source=collection_archive---------17-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ce54" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">对象继承</h1><p id="4a09" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对象继承意味着从一个类到另一个类继承属性和方法是可能的。在JavaScript中，类是对象原型的表示，而原型是对象属性定义的子集。</p><h1 id="fa2c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">JavaScript中的本机继承</h1><p id="dd66" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">自ECMAScript 2015规范以来，JavaScript引入了一个名为“class”(小写)的特殊关键字，它可以用作语法糖来描述表示类或对象类型的函数原型。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b946" class="kk ig hi kg b fi kl km l kn ko">'use strict';</span><span id="f9ce" class="kk ig hi kg b fi kp km l kn ko">class Polygon {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span><span id="1806" class="kk ig hi kg b fi kp km l kn ko">class Square extends Polygon {<br/>  constructor(sideLength) {<br/>    super(sideLength, sideLength);<br/>  }<br/>  get area() {<br/>    return this.height * this.width;<br/>  }<br/>  set sideLength(newLength) {<br/>    this.height = newLength;<br/>    this.width = newLength;<br/>  }<br/>}</span><span id="71fb" class="kk ig hi kg b fi kp km l kn ko">//this sample code was extracted from MDN: <a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#with_the_class_keyword" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#with_the_class_keyword</a></span></pre><p id="27e9" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">上面的代码描述了一个多边形类和一个正方形类，它们可以通过使用new运算符进行实例化，如下所示:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="8ac7" class="kk ig hi kg b fi kl km l kn ko">let polygon = new Polygon( 20, 30 );<br/> let square = new Square (30);</span></pre><p id="0033" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">一个类继承另一个类的方法。扩展类(多边形)通常称为父类或抽象类，扩展类(正方形)通常称为子类或子类。</p><h1 id="222d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">QCObjects使用类函数继承</h1><figure class="kb kc kd ke fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/d804554a47aaf8e9d301f64d9305d26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIVrkg6GBYJ3-8tSpe679A.png"/></div></div></figure><p id="0dfb" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">现在，一个类似的代码，但是使用QCObjects语法，将产生更高级的结果，看起来像这样:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f0df" class="kk ig hi kg b fi kl km l kn ko">// QCObjects v2.3 code</span><span id="3705" class="kk ig hi kg b fi kp km l kn ko">Class ("Polygon", {<br/>    height: 0,<br/>    width: 0<br/>})</span><span id="d0c8" class="kk ig hi kg b fi kp km l kn ko">Class ("Square", Polygon, {<br/>   slideLength: 0,<br/>   get area() {<br/>     return this.height * this.width;<br/>   }<br/>   set sideLength(newLength) {<br/>     this.height = newLength;<br/>     this.width = newLength;<br/>   }<br/>})</span><span id="b992" class="kk ig hi kg b fi kp km l kn ko">// To instantiate this classes<br/>let polygon = New(Polygon, {width: 20, height: 30})<br/>let square = New(Square, {sideLength: 20})</span></pre><p id="71b8" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">上述代码中最重要的区别之一是，我们不需要声明一个构造函数(在第一个原生JavaScript代码中我们需要这样做)，因为框架会自动为我们声明它。</p><p id="8918" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">另一件重要的事情是，为了实例化对象多边形和正方形，我们不使用new运算符。我们需要用一个新的函数来代替它(当心Class和New中的大写字母)。</p><p id="8410" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">这种语法的一个致命优点是，您将对象定义为对象，并且不使用任何函数语法来声明类定义(QCObjects框架在需要时会在内部为您完成)。</p><p id="ee6c" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">就像你看到的类和新特性一样简单，这些就是QCObjects强大的源泉，因为改变你可以声明你使用的对象的方式，你也可以用你想象不到的方式丰富它们。</p><h1 id="d430" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">重写方法</h1><p id="da60" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您还可以覆盖原生JavaScript中的方法。在下一个示例中，我们将创建一个名为whoami的方法，该方法返回一个字符串，表示“我是一个<em class="le"> x </em>的多边形”或“我是一个<em class="le"> x </em>的正方形”，分别显示消息中的with和height值。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f7db" class="kk ig hi kg b fi kl km l kn ko">class Polygon {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }</span><span id="7832" class="kk ig hi kg b fi kp km l kn ko">  whoami () {<br/>      return `I am a Polygon of ${this.width} x ${this.height}`;<br/>  }</span><span id="2d21" class="kk ig hi kg b fi kp km l kn ko">}</span><span id="c302" class="kk ig hi kg b fi kp km l kn ko">class Square extends Polygon {<br/>  constructor(sideLength) {<br/>    super(sideLength, sideLength);<br/>  }<br/>  get area() {<br/>    return this.height * this.width;<br/>  }<br/>  set sideLength(newLength) {<br/>    this.height = newLength;<br/>    this.width = newLength;<br/>  }</span><span id="9b7e" class="kk ig hi kg b fi kp km l kn ko"> // overridden method <br/>  whoami () {<br/>      return `I am a Square of ${this.width} x ${this.height}`;<br/>  }</span><span id="a716" class="kk ig hi kg b fi kp km l kn ko">}</span><span id="31fe" class="kk ig hi kg b fi kp km l kn ko">let polygon = new Polygon(20, 30);<br/>let square = new Square (20);</span><span id="c998" class="kk ig hi kg b fi kp km l kn ko">console.log ( polygon.whoami() );<br/>// "I am a Polygon of 30 x 20"</span><span id="60f3" class="kk ig hi kg b fi kp km l kn ko">console.log ( square.whoami() );<br/>// "I am a Square of 20 x 20"</span></pre><p id="e350" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">如您所见，根据方法定义的位置(子类或父类)，相同的方法名可以被覆盖以具有不同的行为。</p><h1 id="62c7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">重写QCObjects中的方法</h1><p id="5cfd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用QCObjects可以简化上述代码，如下所示:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="74c7" class="kk ig hi kg b fi kl km l kn ko">// QCObjects v2.3 code</span><span id="cf6e" class="kk ig hi kg b fi kp km l kn ko">Class ("Polygon", {<br/>    height: 0,<br/>    width: 0, <br/>    whoami () {<br/>      return `I am a Polygon of ${this.width} x ${this.height}`;<br/>    }<br/>})</span><span id="8f71" class="kk ig hi kg b fi kp km l kn ko">Class ("Square", Polygon, {<br/>   slideLength: 0,<br/>   get area() {<br/>     return this.height * this.width;<br/>   }<br/>   set sideLength(newLength) {<br/>     this.height = newLength;<br/>     this.width = newLength;<br/>   },<br/>  whoami () {<br/>     // overridden method <br/>      return `I am a Square of ${this.width} x ${this.height}`;<br/>  }</span><span id="9370" class="kk ig hi kg b fi kp km l kn ko">})</span><span id="0cb5" class="kk ig hi kg b fi kp km l kn ko">// To instantiate this classes<br/>let polygon = New(Polygon, {width: 20, height: 30})<br/>let square = New(Square, {sideLength: 20})</span></pre><p id="b349" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">我们会得到完全相同的结果</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ed3b" class="kk ig hi kg b fi kl km l kn ko">console.log ( polygon.whoami() );<br/>// "I am a Polygon of 30 x 20"</span><span id="e0f0" class="kk ig hi kg b fi kp km l kn ko">console.log ( square.whoami() );<br/>// "I am a Square of 20 x 20"</span></pre><h1 id="b377" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">混合语法(除非特别需要，否则不推荐)</h1><p id="4336" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">QCObjects的目的是在运行时扩展JavaScript语言，让您拥有现代软件开发的特性，而无需使用捆绑器或静态传输器。因此，您总是可以混合本地JavaScript的语法扩展定义。</p><p id="6ace" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">QCObjects的一个很酷的地方是，您还可以创建一个新的QCObjects类定义来扩展传统的JavaScript类定义，如下所示:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="38b2" class="kk ig hi kg b fi kl km l kn ko">// native language class definition</span><span id="fa0a" class="kk ig hi kg b fi kp km l kn ko">class Polygon {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }</span><span id="3c7e" class="kk ig hi kg b fi kp km l kn ko">  whoami () {<br/>      return `I am a Polygon of ${this.width} x ${this.height}`;<br/>  }</span><span id="de42" class="kk ig hi kg b fi kp km l kn ko">}</span><span id="2099" class="kk ig hi kg b fi kp km l kn ko">// QCObjects Class Definition Square can extend a Polygon </span><span id="5380" class="kk ig hi kg b fi kp km l kn ko">Class ("Square", Polygon, {<br/>   slideLength: 0,<br/>   get area() {<br/>     return this.height * this.width;<br/>   }<br/>   set sideLength(newLength) {<br/>     this.height = newLength;<br/>     this.width = newLength;<br/>   },<br/>  whoami () {<br/>     // overridden method <br/>      return `I am a Square of ${this.width} x ${this.height}`;<br/>  }</span><span id="0165" class="kk ig hi kg b fi kp km l kn ko">})</span><span id="5745" class="kk ig hi kg b fi kp km l kn ko">let polygon = new Polygon(20, 30);<br/>let square = New(Square, {sideLength: 20})</span><span id="79bf" class="kk ig hi kg b fi kp km l kn ko">console.log ( polygon.whoami() );<br/>// "I am a Polygon of 30 x 20"</span><span id="c529" class="kk ig hi kg b fi kp km l kn ko">console.log ( square.whoami() );<br/>// "I am a Square of 20 x 20"</span></pre><p id="7528" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">然而，虽然上面的代码很酷，有时也很强大，但除非您真的需要，否则不建议将其用于一般用途。</p><h1 id="4be9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="43c6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">QCObjects类函数的语法简单且功能强大，可以声明类定义。您还可以扩展JavaScript本地类来定义新对象。您可以重写方法并继承父类的行为。</p></div></div>    
</body>
</html>
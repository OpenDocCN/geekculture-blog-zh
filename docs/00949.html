<html>
<head>
<title>Complete End-to-end Guide for Developing Dockerized Lambda in Typescript, Terraform and SAM CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Typescript、Terraform和SAM CLI中开发Dockerized Lambda的完整端到端指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/complete-end-to-end-guide-for-developing-dockerized-lambda-in-typescript-terraform-and-sam-cli-ecdea1c6e72c?source=collection_archive---------7-----------------------#2021-03-21">https://medium.com/geekculture/complete-end-to-end-guide-for-developing-dockerized-lambda-in-typescript-terraform-and-sam-cli-ecdea1c6e72c?source=collection_archive---------7-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7c8a0d1218e2fd282956de5c149e14d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kf5kO7xWNg0mhRx-Wdx8zg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Docker + TS + Terraform + Lambda + ECR + SAM CLI = 💚</figcaption></figure><p id="655e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个完整的指南来设置，开发和部署一个后端应用程序与<a class="ae js" href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/" rel="noopener ugc nofollow" target="_blank">，一个最近在AWS </a>上为lambda发布的容器图像特性。</p><p id="d66b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不用说，如果你是Docker的超级粉丝，你就会知道它有多神奇。您在本地测试的就是您部署它时得到的，至少在容器级别是这样。</p><p id="dd6b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为这个功能很新，所以我掉进了<strong class="iw hj">很多兔子洞</strong>，我相信其他人也会掉进，所以我会把兔子洞的每一部分都打破，这样就不会有人被困在里面了。本指南从真正的基础开始，如创建用户或设置terraform，所以请随意跳到您需要的部分。</p><h1 id="863f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">同时使用Terraform和SAM CLI的原因</h1><p id="f3b6" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">嗯，看起来Terraform支持构建docker映像并将其部署到ECR，但是经过大量的挖掘，我发现如果我只是在另一个管道中构建Docker映像并使用几行shell脚本进行部署，事情会变得更简单。所以Terraform将用于定义资源，不包括构建和部署过程。这没有问题。</p><p id="c7c0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有，什么山姆CLI？Terraform不能取代SAM CLI，反之亦然。SAM cli在开发本地lambda时非常有用，因为它自动为每个lambda配置端点，并极大地消除了初始设置的障碍。因为lambda函数是“特殊的”,它们只有在被调用时才会被“启动和调用”(不像EC2或Fargate ),仅仅做<code class="du kw kx ky kz b">ts-node my-lambda.ts</code>不会让它工作。当然，还有许多其他解决方案(例如<code class="du kw kx ky kz b">sls</code>)，但在本指南中，我将只使用SAM CLI。但是由于许多原因，山姆让我想使用其他更好的解决方案，如果有的话...原因如下。</p><p id="b1bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="la">对于正在寻找如何'</em> <strong class="iw hj"> <em class="la">热重新加载</em> </strong> <em class="la"> ' docker容器用于基于lambda </em>的类型脚本或javascript的人，免责声明:到目前为止，它不会顺利工作。最好的办法是每次使用<code class="du kw kx ky kz b">nodemon</code>查看某个目录来触发<code class="du kw kx ky kz b">sam build</code>，并在另一个shell中启动<code class="du kw kx ky kz b">sam local start-api</code>。它像预期的那样工作，但我从这里看到的当前问题是，每次它<code class="du kw kx ky kz b">sam build</code> s时，它都会制作另一个Docker映像和另一个等等，所以会有许多无用的悬空映像堆积在您的驱动器中，您需要手动删除它们，因为SAM CLI不支持传入等效于<code class="du kw kx ky kz b">docker run --rm</code>的参数。不管怎样，这就是故事，所以这就是我想尝试其他解决方案的原因。<a class="ae js" href="https://github.com/aws/aws-sam-cli/issues/921" rel="noopener ugc nofollow" target="_blank">在Github </a>的相关问题上有更多关于这个的信息。请让我知道你们中是否有人对<code class="du kw kx ky kz b">sls</code>有好的体验，因为我还没怎么用过它。</p><p id="f275" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好的。现在让我们写一些代码。</p><h1 id="c430" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为Terraform设置AWS</h1><p id="36ef" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">首先，确保您已经在AWS CLI上安装并授权。安装AWS CLI超出了这里的范围，因此<a class="ae js" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html" rel="noopener ugc nofollow" target="_blank">请遵循AWS上的指南</a>。</p><p id="7010" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">成功安装后，运行:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="449e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将提示您输入访问密钥ID和秘密访问密钥。根据您的情况，有不同的方法来处理这个问题，但是为了简单起见，我们可以创建一个用户(从AWS控制台。您可能只会将它用于“编程访问”)，这将具有应用Terraform代码的这些策略。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/072e7909810a9e4e3a55ae9040e1b4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h7lS3_Pstwq-tauo5Dowg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Add user</figcaption></figure><p id="00c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个用于将S3桶设置为后端:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d8cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个用来锁定状态:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="98df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而下一个相当棘手；因为我们将临时启用与管理IAM相关的权限，因为我们将首先需要创建一个角色，每当我们尝试计划和应用IaC时，我们都可以从该角色中<code class="du kw kx ky kz b">assumeRole</code>。</p><p id="193f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们可以进入AWS控制台，制定以下策略:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="2552" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">确保在完成所有工作后，您需要缩小到特定的操作和资源(用于生产用途)。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/2e98e5c699eb1419dc09dbb0ed72eb63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnoOMdtXrMg1OIG0Lqj30A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Create policy</figcaption></figure><p id="b446" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，既然您已经制定了三个不同的策略(或者都在一个策略中，这取决于您的偏好)，将它们附加到您刚刚创建的用于运行<code class="du kw kx ky kz b">aws configure</code>的用户。</p><h1 id="23a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置地形</h1><p id="aa62" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">如果您还没有，<a class="ae js" href="https://learn.hashicorp.com/tutorials/terraform/install-cli" rel="noopener ugc nofollow" target="_blank">按照官方网站</a>的说明安装terraform。只需下载二进制文件并将其移动到<code class="du kw kx ky kz b">bin</code>文件夹。</p><p id="7f49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在验证terraform的版本</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="501f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后在你的项目目录中制作<code class="du kw kx ky kz b">main.tf</code>文件(我个人把它放在<code class="du kw kx ky kz b">IaC</code>文件夹中，因为后端会有另一个文件夹存放‘真实’的<code class="du kw kx ky kz b">.ts</code>代码):</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="a34d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，运行<code class="du kw kx ky kz b">terraform init</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="fa0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们将需要添加s3后端和状态锁定。但在此之前，在Dynamodb上创建一个表，在S3上创建一个桶，分别用于托管IaC后端和锁定状态。</p><p id="ec08" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要在我们创建的DynamoDB上添加更多的策略，因为我们想要创建一个表:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8998" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后你可以写这段代码(顺便说一下，把它放在IaC下面的一个不同的通用存储库中可能是个好主意，因为当前的存储库只用于lambda相关的资源。但是为了这篇文章，我就把它写在这里):</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4e31" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，还要添加S3后端(您也需要在这里添加相关的IAM策略，但是因为我们知道如何做，所以我将省略解释):</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4ea7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，运行<code class="du kw kx ky kz b">terraform apply</code>，验证更改，并进入<code class="du kw kx ky kz b">yes</code>。应该已经创建了DynamoDB表和S3桶。以下是目前为止的代码:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="402c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，添加s3后端和状态锁:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="5c1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还将使用Docker provider，所以也要加上:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="6d53" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，因为您已经添加了一个后端和另一个提供者，我们将需要再次运行<code class="du kw kx ky kz b">terraform init</code>，然后再运行<code class="du kw kx ky kz b">terraform apply</code>。运行它。</p><h1 id="bcb2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置lambda</h1><p id="465a" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">现在我们需要在本地机器上开发lambda。安装SAM CLI:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6711" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，过时的版本不支持运行Docker容器，所以请确保您的版本是最新的。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8aea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们不会运行<code class="du kw kx ky kz b">sam --init</code>，因为这样会很难把服务器做成monorepo结构。我们想把它做成一个monorepo的原因是，这样可以更容易地对每个lambda进行适当的分类，并使用每个lambda只需要拥有的依赖项来部署它。相反，我们将使用<em class="la"> lerna </em>来初始化服务器文件夹。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="788b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">和往常一样:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="ed28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后它会给你这个布局:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="97d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，添加您的第一个功能包。为了这个例子，我们假设我们要做一个REST API，由许多lambdass组成，每个lambda用不同的语言返回' hello '作为响应(这在现实中完全没用，但至少在这里有用)。我们的第一辆lambda将是英国的。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="bcfc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，目录结构将如下所示:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c3fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在<code class="du kw kx ky kz b">server</code>下，我们将需要添加一些实用程序来本地构建和调用该函数。如下添加并修改<code class="du kw kx ky kz b">server/package.json</code>，当然，再次运行<code class="du kw kx ky kz b">npm i</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">server/package.json</figcaption></figure><p id="9398" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对我们试图做的事情做一些解释:这些<code class="du kw kx ky kz b">devDependencies</code>将是包范围的依赖。这些并不特定于我们将要构建的任何一个函数；他们将帮助加工一般的东西。这就是我们把它们放在这里的原因。</p><p id="b72f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">依赖关系:</p><ul class=""><li id="c1ee" class="lj lk hi iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">@types/node</code>:我们将需要它来为<code class="du kw kx ky kz b">fs</code>或<code class="du kw kx ky kz b">path</code>这样的“内置节点”模块给出正确的类型定义。</li><li id="401c" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">concurrently</code>:只是一个脚本运行器。</li><li id="422a" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">lerna</code>:你懂的。</li><li id="ac19" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">nodemon</code>:这将帮助我们观察一个目录，并再次建立Docker映像。</li></ul><p id="9167" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">脚本:</p><p id="635e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您需要为SAM cli创建<code class="du kw kx ky kz b">template.yml</code>来消费和运行我们想要运行的内容。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">template.yml</figcaption></figure><p id="7fee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还不能运行<code class="du kw kx ky kz b">sam build</code>或<code class="du kw kx ky kz b">sam local start-api</code>，因为我们还需要设置<code class="du kw kx ky kz b">Dockerfile</code>和ECR库。</p><p id="67af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经添加了用于运行SAM CLI的<code class="du kw kx ky kz b">template.yml</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="96b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们将在<code class="du kw kx ky kz b">packages/hello/</code>中添加<code class="du kw kx ky kz b">Dockerfile</code>。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="fc19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将是Dockerfile的内容:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="30b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要一行一行地浏览它:</p><ul class=""><li id="46e7" class="lj lk hi iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">amazon/aws-lambda-nodejs:14</code>是lambda的亚马逊官方图片。nodejs的当前LTS是14，所以我们使用它。<code class="du kw kx ky kz b">AS builder</code>与Docker中的多阶段构建相关；它有助于减小最终Docker图像的大小。基本上在这个<code class="du kw kx ky kz b">builder</code>阶段，我们将只构建要包含在最终映像中的输出，并且在这个步骤中安装的任何依赖项都不会包含在最终输出映像中。</li><li id="9970" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">WORKDIR /usr/app</code>:在docker镜像中，设置工作目录为<code class="du kw kx ky kz b">/usr/app</code>。在一个普通的docker镜像中没有任何<code class="du kw kx ky kz b">app</code>文件夹，所以它会创建<code class="du kw kx ky kz b">app</code>目录。我们将把编译好的js代码放在那里。</li><li id="f897" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">我们需要这些文件来将typescript编译成javascriptt文件。</li><li id="9cb9" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">npm install</code>:会安装依赖关系。</li><li id="77b2" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">npm run build</code>:将typescript代码编译成js。</li><li id="d220" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">这只是为了调试。在建造的时候，docker会输出当时里面是什么，让你验证你是不是在做你打算做的事情。</li><li id="5892" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">FROM amazon/aws-lambda-nodejs:14</code>:这是Docker中的第二个构建阶段。前一阶段的所有输出将在此阶段被丢弃，除非明确指定要包括。</li><li id="1f97" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">RUN npm install --only=prod</code>:只安装<code class="du kw kx ky kz b">dependencies</code>，不安装<code class="du kw kx ky kz b">devDepdencies</code>。</li><li id="d97d" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">COPY --from=builder /usr/app/lib /usr/app/lib</code>:明确引用前一个<code class="du kw kx ky kz b">builder</code>阶段，将<code class="du kw kx ky kz b">/usr/app/lib</code>中的内容复制到当前的<code class="du kw kx ky kz b">/usr/app/lib</code>。在这种情况下，它将复制所有编译的javascript代码。</li><li id="2fe7" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><code class="du kw kx ky kz b">CMD [ "/usr/app/lib/index.handler" ]</code>:命令应该是<code class="du kw kx ky kz b">path-to-lambda-handler-without-extension.handler</code>。事情就是这样的。</li></ul><p id="c7de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们已经添加了一个Dockerfile文件。现在让我们为lambda设置基本环境:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5da3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您需要修改<code class="du kw kx ky kz b">tsconfig</code>来使用现代的javascript特性；最突出的是，添加以下内容。这将允许您使用<code class="du kw kx ky kz b">Promise</code> API。我建议也打开其他选项，尤其是那些与严格类型检查相关的选项:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">tsconfig.json</figcaption></figure><p id="99b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也修改<code class="du kw kx ky kz b">packages/hello/package.json</code>。请注意，您添加到最终编译输出代码(javascript)中的任何依赖项都需要添加到<code class="du kw kx ky kz b">dependencies</code>，而不是<code class="du kw kx ky kz b">devDependencies</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">server/packages/hello/package.json</figcaption></figure><p id="7fa2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，添加一个非常简单的lambda:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">packages/hello/lib/index.ts</figcaption></figure><p id="f8ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经创建了这些:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="573b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在<code class="du kw kx ky kz b">server/</code>下创建<code class="du kw kx ky kz b">nodemon.json</code>来观察和构建文件:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">server/nodemon.json</figcaption></figure><p id="95b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建<code class="du kw kx ky kz b">nodemon.json</code>后，可以开始运行<code class="du kw kx ky kz b">npm run watch</code>或<code class="du kw kx ky kz b">npm start</code>。它会做两件事:当你在<code class="du kw kx ky kz b">packages/</code>目录下做任何改变时构建Dockerfile，并为lambda托管一个本地端点。这将类似于热重装，虽然它看起来更像一个黑客；一旦做出更改，您无需取消并再次运行<code class="du kw kx ky kz b">sam local start-api</code>。如果不起作用，请先创建ECR，然后重试。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="7587" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">哦，你可以删除<code class="du kw kx ky kz b">__tests__</code>和<code class="du kw kx ky kz b">lib/hello.js</code>，因为我们不使用它们。不管怎样，现在我们已经准备好将这个函数构建到docker映像中了。让我们来试试:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c396" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一切都很酷，docker构建成功。您可以尝试运行映像并测试请求:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/b429f93ad78f45a850cc392450f9a7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lp7wPwEFJvjJ0s9PZ_y71w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Invoking lambda locally</figcaption></figure><p id="e548" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是SAM CLI应该开始发挥作用的地方。但在此之前，我们需要用terraform创建一个ECR存储库。让我们暂时回到terraform。</p><h1 id="1aad" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">回到地形:承担角色和ECR</h1><p id="b2e1" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">现在，我们将需要首先创建一个角色，因为我们将依赖该角色来获得创建我们想要的任何资源所需的权限。这被称为“承担角色”，之所以被认为是一个好的实践，是因为您不必创建多个凭证(可能是多个用户)来做某些需要权限的事情。相反，当你计划和应用资源的变化时，你<em class="la">借用</em>这段时间的许可。</p><p id="b203" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么我们该怎么做呢？首先，让我们创建<code class="du kw kx ky kz b">hello_role.tf</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">hello_role.tf</figcaption></figure><p id="dfb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于本文，我们不会深入研究具体的策略，所以我们将只允许几乎所有的资源，而不详细指定它们。对于真实世界的使用，您将必须定义精确的语句来给出正确的权限。</p><p id="79f1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们在这里所做的，本质上，是我们允许<code class="du kw kx ky kz b">localtf</code>用户承担<code class="du kw kx ky kz b">hello_role</code>的角色，拥有运行hello服务器栈的所有策略。这被称为“创建信任关系”(如果您在AWS上执行此过程，您将会看到这一点)。通过这种方式，<code class="du kw kx ky kz b">localtf</code>不必总是拥有它需要的所有权限。它仅在需要时(即部署时)才获取它们</p><p id="4f4a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦你写完<code class="du kw kx ky kz b">hello_role.tf</code>，运行<code class="du kw kx ky kz b">terraform apply</code>进行修改。</p><p id="45b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，回到<code class="du kw kx ky kz b">main.tf</code>并添加:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="a66c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦您添加了<code class="du kw kx ky kz b">assume_role</code>，现在您就可以使用该角色所赋予的权限来创建任何您想要的资源。现在让我们创建一个ECR存储库。制作<code class="du kw kx ky kz b">ecr.tf</code>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">ecr.tf</figcaption></figure><p id="dee7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行<code class="du kw kx ky kz b">apply</code>，terraform很快就会做出ECR。</p><h1 id="4688" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">构建映像并将其推送到ECR</h1><p id="6e46" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">现在我们已经创建了一个ECR，我们可以回到我们的服务器，编写一个小脚本来登录、构建和推送我们正在编写的lambda的映像。</p><p id="fd43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这非常简单。只需准备好您的AWS cli即可使用；并进行身份验证，以便能够从Docker CLI使用ECR:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">server/login-docker.sh</figcaption></figure><p id="ccdf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，将Docker映像标记为<code class="du kw kx ky kz b">latest</code>并在构建时分开时间戳，这样最新的标记将始终是最新构建的映像，然后另一个映像将保留下来用于记录，您可以稍后使用它来恢复或在某些情况下做其他事情。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">server/build-and-push-docker-image.sh</figcaption></figure><p id="2ec2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您可以自己测试一下:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5473" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此后，您将能够在AWS ECR上看到:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/3370386616af923da48c4720985eca79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvBqLXNxzOoQw-7t-UK9CQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Images on ECR</figcaption></figure><p id="6ef1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如您所见，这些图像将按时间戳进行标记，最新构建的图像将始终标记为<code class="du kw kx ky kz b">latest</code>，您将在Terraform中引用此标记，以将新构建的Docker图像应用于lambda。</p><p id="fec7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经做了如下更改:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="e8de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在大部分准备工作已经完成，所以我们可以继续创建实际的lambda和API网关了。</p><p id="2d2c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，最重要的部分:你想从Docker创建lambda本身。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">lambda.tf</figcaption></figure><p id="8b49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">已经有一个模块是专门为此制作的，所以用它来制作lambda。一旦你完成了，<code class="du kw kx ky kz b">apply</code>的变化。</p><p id="0f3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的关键是，您将引用ECR中标签为最新的图像URI。如果您之前已经构建并推送了一个新的docker映像，那么该映像的散列将会不同，从而导致lambda函数的重新部署。否则它不知道docker图像是否是新的。</p><p id="34f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，在运行更改后，您可以在AWS控制台上看到lambda:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/ba3932ccb159d412240d286295228d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1f0BKVIw2LqlpdjJr-jltw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Check lambda created on AWS console #0</figcaption></figure><p id="9043" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，与其他lambdas相比，它的包类型是“Image”，这意味着它不是来自Zip，而是Docker图像。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/1de16436d85941f70dd910ce02d97f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIzM6deuorH5G1rhLbkXPA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Check lambda created on AWS console #1</figcaption></figure><p id="c11c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你应该可以在lambda信息的底部看到图像的URI(包括哈希)。如果您点击图像URI，您将导航到ECR上您刚刚创建并推送的最新图像。</p><p id="fad3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，你将能够在AWS lambda控制台上测试Lambda，但我们最终想要的是像发送GET <code class="du kw kx ky kz b">/hello</code>到某个域并接收响应这样的事情。为了能够做到这一点，我们需要设置API网关。</p><p id="4024" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于这个例子，我们将在<code class="du kw kx ky kz b">api.hello.com</code>设置一个域。</p><p id="354d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">方法如下:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">api_gateway.tf</figcaption></figure><p id="03d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将逐一解释代码。</p><p id="d5c0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_rest_api</code>将创建一个REST api。它通常不包括单个端点；它通常包含多个，比如:<code class="du kw kx ky kz b">api.hello.co/hello</code>、<code class="du kw kx ky kz b">api.hello.co/bonjour</code>、<code class="du kw kx ky kz b">api.hello.co/nihao</code>等等。在AWS上，它相当于“API”选项卡中的一行:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/1d4d67ad99bb1695a3e14c0cb736e0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34jHww2ycJsPvy9W8gg2zg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">APIs tab</figcaption></figure><p id="ed59" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_resource</code>:简单来说，你可以把它想象成一个尚未部署的API端点。在这种情况下，我们创建一个以<code class="du kw kx ky kz b">/hello</code>结尾的端点。</p><p id="48ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的例子中，我们用<code class="du kw kx ky kz b">OPTIONS</code>和<code class="du kw kx ky kz b">POST</code>创建了两个不同的资源，到相同的路径(被黑色覆盖隐藏)。稍后我们将讨论创建选项资源来处理预检请求。现在，知道创建REST资源意味着创建某个端点就足够了。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/ab6d2624cef63072bb2947dffdf93a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGCw0WBC_zialnzEcGPDGA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">REST resource</figcaption></figure><p id="90d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_method</code>:现在，您想要为这个资源创建一个REST方法。我们的<code class="du kw kx ky kz b">/hello</code>端点不需要auth(超出了本文的范围)，并且是一个GET方法。</p><p id="ca28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_lambda_permission</code>:默认情况下，API gateway没有调用lambda函数的权限。因此，我们只是授予它一个权限，以便它可以被执行。</p><p id="8760" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_integration</code> : API网关支持转换(过滤，预处理，...)在它到达客户端之前的请求或者在它到达实际的λ之前来自客户端的响应。我们在这里没有为这个例子做任何特殊的事情，但是你可能想要在将来使用它。有关更多信息，<a class="ae js" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-integration-settings.html" rel="noopener ugc nofollow" target="_blank">请阅读相关AWS文档</a>。</p><p id="b164" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_stage</code> : API gateway支持开箱即用将API分成不同的阶段。您应该使用它来跨生产、登台和开发环境分离您的API。现在，我们将只为当前的terraform workspace制作一个stage，在本文的所有示例中假设为<code class="du kw kx ky kz b">dev</code>。应用更改后，您将能够在AWS控制台上看到以下内容:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/efe0b4f138e4cc783142d862044cd102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzvoUWbqYo1Ki5zEvY-PyQ.png"/></div></div></figure><p id="dcd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kw kx ky kz b">aws_api_gateway_deployment</code>:这相当于在AWS控制台上点击‘部署API’。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/1b89eecda2fc248f3386fd6d66221989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lD8jW0DHHbis24FcJHTMgw.png"/></div></div></figure><p id="0127" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦在API gateway中创建了资源，就必须<em class="la">部署它们</em>，以便外部客户端可以访问它们。一个小问题是<code class="du kw kx ky kz b">redeployment</code>；即使您对REST API资源进行了更改，如果<code class="du kw kx ky kz b">redeployment</code>参数没有更改，它也不会得到部署。主要有两种方法可以解决这个问题:</p><ol class=""><li id="f16e" class="lj lk hi iw b ix iy jb jc jf ll jj lm jn ln jr md lp lq lr bi translated">使用<code class="du kw kx ky kz b">timestamp()</code>触发每个<code class="du kw kx ky kz b">apply</code>的重新部署。使用这种方法，lambda在重新部署时可能会停机几秒钟。但是可以肯定的是，它总是可以部署的，所以如果我的服务不能处理很多用户，我会选择这个。</li><li id="6d57" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr md lp lq lr bi translated">每当文件改变时，使用<code class="du kw kx ky kz b">md5(file("api_gateway.tf"))</code>触发重新部署。但是您需要始终确保与API网关部署相关的所有内容都只存在于这个文件中。</li></ol><p id="7ad4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好的。到目前为止，我们已经设置了lambda和基本API网关配置。现在，您可以像这样在Postman上测试您的API:首先，转到AWS API网关控制台，找到部署到某个阶段的特定端点。应该有一个“调用网址”在页面的顶部。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/4a744c558a116dc536ef556e5b563165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtYBzOnfz544gVeHB_Bjcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Invoke URL</figcaption></figure><p id="e310" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，打开邮差，然后</p><ol class=""><li id="2dba" class="lj lk hi iw b ix iy jb jc jf ll jj lm jn ln jr md lp lq lr bi translated">插入您的调用URL</li><li id="664c" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr md lp lq lr bi translated">点击“授权”，选择“AWS签名”类型，输入<code class="du kw kx ky kz b">AccessKey</code>和<code class="du kw kx ky kz b">SecretKey</code>。这些密钥应该来自AWS IAM控制台的某个用户凭据。如果您没有一个专门用于从本地环境调用用lambda和API gateway设置的API的工具，请为其创建一个用户并获取密钥。</li><li id="20e6" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr md lp lq lr bi translated">插入您的AWS区域。</li><li id="a998" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr md lp lq lr bi translated">如果您的API请求更多的查询参数或查询体，请插入它们。</li><li id="1a25" class="lj lk hi iw b ix ls jb lt jf lu jj lv jn lw jr md lp lq lr bi translated">点击发送，应该可以了。</li></ol><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/67ae9bae8a7c7736a11d311423be85e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7modWjBW542zHw6hdlloA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Testing ‘Invoke URL’ on Postman</figcaption></figure><p id="92c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您在请求头中没有提供AWS凭证，它将不起作用，因为到目前为止，您的API只能由API网关已知的IAM用户使用，如果您只是从本地计算机发送请求，而没有提供任何访问和密钥，它不会知道是您。为了使它能够工作，甚至不需要为任何公开给客户端应用程序的公共API提供凭证，您现在应该配置<strong class="iw hj">定制域</strong>。</p><p id="82df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经对lambda和API网关资源进行了更改。我们现在应该拥有的文件列表如下。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="10a6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们将看到如何创建一个自定义域，并将该域与我们刚刚创建的REST API相关联。</p><h1 id="4295" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为自定义域创建地形资源</h1><p id="5dc9" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">现在，问题是我们有API，但它不能从任何外部客户端应用程序调用，这是许多项目的常见情况。所以我们想先注册一个域来代表我们的端点。</p><p id="9687" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在对定制域进行更改之前，我们需要设置另一个AWS提供者，因为我们需要使用<code class="du kw kx ky kz b">us-east-1</code>区域作为边缘优化定制域名(<a class="ae js" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-edge-optimized-custom-domain-name.html" rel="noopener ugc nofollow" target="_blank">这是唯一支持为边缘优化定制域名</a>创建ACM证书的区域)。</p><p id="5e4f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">API端点有两种选择:1。边缘；2.地区性的。如果您的端点应由全球客户访问，请使用edge如果您的端点被明确限制在世界上的一个特定地区使用，请使用区域。如果你不知道该做什么，现在使用edge是完全安全的。首先，添加另一个aws提供者:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">main.tf</figcaption></figure><p id="78dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，编写实际的代码来创建证书和自定义域。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">custom_domain.tf</figcaption></figure><p id="3980" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">确保从AWS Route53控制台获取现有的托管区域ID(或您打算使用的任何其他区域ID ):</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/dcaf0033fa4dd5b7b1a78efe429015de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuS6DvmywS3hGw6spdo-zg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Route53</figcaption></figure><p id="a50c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用该ID为自定义域名创建Route53记录。</p><p id="8247" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">应用更改后，您将能够在AWS证书管理器上看到正在创建的ACM证书:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/670c4579accf8d40c6bef3934dc11323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Jd6QfkrmZF5wBoqtwXang.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">AWS Certificate Manager</figcaption></figure><p id="c59b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只要确保您验证了状态为“已发布”且验证状态为“成功”即可。您可能需要等待几分钟才能完成。此外，如果您的证书没有出现，请确保您在<code class="du kw kx ky kz b">us-east-1</code>上，而不是在其他任何地方。</p><p id="dcb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成这些后，现在您可以再次返回API Gateway，并配置自定义域。现在您已经注册了一个域，您可以从API网关控制台看到它:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/e80c34563ebcc9f24db44f8388b08283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLfhXkNz458YvGyHK0bG8A.png"/></div></div></figure><p id="1202" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在证书下拉列表中，您应该能够看到您刚刚创建的域。不要在控制台上创建域名。现在回到terraform，让我们为它写等价的代码。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">custom_domain.tf</figcaption></figure><p id="c000" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您只需填写刚刚从API网关控制台看到的选项。只需填写有关证书、域名和端点配置的相关信息。</p><p id="26d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，这很重要:您需要创建另一个Route53记录来将您的定制域映射到cloudfront。创建自定义域后，AWS会创建“API网关域名”，在下图中用红色圈出:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/f863a1123e4bd8fbb82fa4611c9873ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccGAaXKZ-fae4eyTdYMvZQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">API Gateway domain name</figcaption></figure><p id="cbe3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您需要将到<code class="du kw kx ky kz b">api.hello.com</code>的流量路由到这个API网关域名(一个API网关域名的例子是<code class="du kw kx ky kz b">asdfasdfasdf.cloudfront.net</code>，只要您使用的是<code class="du kw kx ky kz b">EDGE</code>)。这就是我们正在用<code class="du kw kx ky kz b">aws_route53_record.custom_domain_to_cloudfront</code>做的事情。否则，对您的API的响应将一直显示一些奇怪的错误，这些错误的原因很难猜测。我发现AWS真的缺乏这方面的文档，所以请在这一点上提出建议。<strong class="iw hj">您需要创建另一个Route53记录</strong>。</p><p id="fb4d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以通过进入Route53控制台并寻找<code class="du kw kx ky kz b">api.hello.com</code>来验证。它应该如下所示:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/6e6632bd8754c5f91bb094fd416bb91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iunic1rx_HpDGyT8SrHp6A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Route53 record for api.hello.com to asfasdfasdf.cloudfront.net</figcaption></figure><p id="79ed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">之后，很多事情就不用做了；只需在<code class="du kw kx ky kz b">api_gateway.tf</code>中添加基本路径映射资源。即使您没有到端点的附加路径，您也必须<em class="la">创建一个基本路径映射。否则你的API不会公开。</em></p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">api_gateway.tf</figcaption></figure><p id="05c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">应用此更改后，验证您的API映射是否已创建:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/780b981c52b76ff8ff2edf5327ef9596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2TBy_LYWmMM5lmVSuu4IQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">API mapping on API Gateway</figcaption></figure><p id="c865" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您可以回到Postman，通过请求GET <code class="du kw kx ky kz b">api.hello.com/hello</code>来测试您的api。这里可能令人困惑的是，您没有在基本路径映射中添加任何<code class="du kw kx ky kz b">path</code>。如果你添加<code class="du kw kx ky kz b">hello</code>作为路径，你的API端点就会被配置成<code class="du kw kx ky kz b">api.hello.com/hello/hello</code>，这显然不是我们想要的。因此，如果您已经在<code class="du kw kx ky kz b">aws_api_gateway_resource</code>中配置了路径，就不要添加任何路径映射。不管怎样，如果到目前为止一切都设置正确的话，对API端点的请求和响应应该可以正常工作。</p><h1 id="3bb7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">启用选项(预检请求)</strong></h1><p id="6d82" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">现在，我们的客户端应用程序当然不是Postman，所以通常客户端会首先请求OPTIONS <code class="du kw kx ky kz b">api.hello.com/hello</code>，然后请求GET <code class="du kw kx ky kz b">api.hello.com/hello</code>，如果他们打算发送CORS请求，这是一个非常常见的情况(<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request" rel="noopener ugc nofollow" target="_blank">从MDN docs </a>中了解更多信息)</p><p id="2136" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您没有做任何与处理选项请求相关的事情，您的客户端应用程序很可能会出现如下错误:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/e787d53275d9b2067f9698b590f1eb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9gbEU3XKVJMXbfj4UOVUQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image from <a class="ae js" href="https://stackoverflow.com/questions/59909987/aws-api-gateway-403-forbidden-response-to-preflight-options-request" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/59909987/aws-api-gateway-403-forbidden-response-to-preflight-options-request</a></figcaption></figure><p id="6f5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以让我们开始吧！已经有一个由优秀开发人员编写的<a class="ae js" href="https://github.com/squidfunk/terraform-aws-api-gateway-enable-cors" rel="noopener ugc nofollow" target="_blank">便捷模块，所以我们将只使用它:</a></p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">api_gateway.tf</figcaption></figure><p id="61c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，如果您有任何自定义头，您必须在您的配置中定义它。接下来，验证控制台上现在允许选项请求:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/2e68c35a6478cd6050e98f7216bd097b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*9ygAvO4BAuio8wE89AsI-Q.png"/></div></figure><p id="3632" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，你还需要改变lambda的响应头。只需添加<code class="du kw kx ky kz b">Access-Control-Allow-Origin": "*"</code>即可:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="iq ir et er es is it bd b be z dx">packages/hello/lib/index.ts</figcaption></figure><p id="ce0c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，应用更改，返回到您的客户端应用程序并重试请求。应该有用。</p><h1 id="6aca" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">总结</h1><p id="d4c3" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">如果您遵循了所有步骤，您将会创建以下文件:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3fb1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经了解了如何使用Typescript、Terraform和SAM CLI设置、开发和部署dockerized lambda应用程序。lambda上有成吨的东西要覆盖..也许下一次，它将使用lambda在VPC的资源。我希望你喜欢这个，并找到一些有价值的见解。谢谢你。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="b6bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="la">最初发布于</em><a class="ae js" href="https://9oelm.github.io/2021-03-13-complete-end-to-end-guide-for-developing-dockerized-lambda-with-typescript-terraform-and-SAM-cli/" rel="noopener ugc nofollow" target="_blank"><em class="la">https://9 oelm . github . io/2021-03-13-complete-end-to-end-guide-for-developing-dockerized-lambda-with type script-terraform-and-SAM-CLI/</em></a></p></div></div>    
</body>
</html>
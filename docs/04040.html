<html>
<head>
<title>Microsoft Graph API for taxonomy (beta) + SPFx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于分类的Microsoft Graph API(测试版)+ SPFx</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/microsoft-graph-api-for-taxonomy-beta-spfx-c5c252b2f5da?source=collection_archive---------27-----------------------#2021-06-20">https://medium.com/geekculture/microsoft-graph-api-for-taxonomy-beta-spfx-c5c252b2f5da?source=collection_archive---------27-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6f43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇短文中，我们将看看如何在SPFx web部件中使用Microsoft Graph API进行分类。该端点目前处于测试阶段。</p><h2 id="2676" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">分类图形API</h2><p id="4795" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Microsoft Graph API for taxonomy帮助我们对Microsoft 365租户中的分类数据执行CRUD操作。更多细节可以在<a class="ae kd" href="https://docs.microsoft.com/en-us/graph/api/resources/termstore-store?view=graph-rest-beta" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c5b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在SharePoint网站中，分类数据可以在多个地方用于多种目的。它帮助我们对SharePoint内容进行分类，以便用户能够更快地找到他们需要的内容。由于分类法在SharePoint中起着重要的作用，了解如何在SPFx中与分类法进行交互对我们非常有帮助，这样我们就可以开发web部件/扩展来处理与分类法相关的各种场景。</p><h2 id="c89c" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">示例代码</h2><p id="78fd" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在这篇博客中，我们将看一个场景，在这个场景中，我们将使用Microsoft Graph从分类中读取数据。博客中解释的所有代码都可以在<a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/tree/main/samples/react-graph-cascading-managed-metadata" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="0d1b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">使用SPFx的级联分类下拉列表</h2><p id="9b63" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">为了解释分类法API的用法，我们假设如下:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/8d726dff4ab034318d407b365df2f99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ZA6RC4mxAADO6RkWd7cfjA.png"/></div></figure><ol class=""><li id="983e" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">名为“1个公司”的术语组</li><li id="111c" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">名为“我们的位置”的术语集</li><li id="9b2a" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">作为国家/地区的父术语—法国、德国、印度和英国</li><li id="9337" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">作为城市的第一级子术语-伦敦和曼彻斯特。</li></ol><p id="10f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看到如何从术语集中读取所有父术语(国家),然后如何读取父术语下的所有子术语(城市)。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es la"><img src="../Images/3ed043c998659c123bcced50f12167ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/0*FOWvWCfxRwScQD61.gif"/></div></figure><h2 id="aebc" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">使用分类法API</h2><p id="8c86" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">SPFx web部件是使用React钩子开发的，只接受一个属性作为输入，那就是术语集的ID(我们的位置)。</p><p id="6562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当web部件加载时，我们获得“我们的位置”(术语集)下的所有国家(父术语)。这一点可以从<code class="du lb lc ld le b"><a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/components/CascadingManagedMetadata.tsx#L42" rel="noopener ugc nofollow" target="_blank">getCountries</a></code>方法中看出。在该方法中，我们调用术语集分类API的<code class="du lb lc ld le b"><a class="ae kd" href="https://docs.microsoft.com/en-us/graph/api/termstore-term-list-children?view=graph-rest-beta&amp;tabs=http" rel="noopener ugc nofollow" target="_blank">List children</a></code>端点，它将列出术语集下的第一级子术语，在本例中是所有国家。然后，我们在国家下拉列表中填充这些国家。</p><p id="b0d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从下拉列表中选择一个国家时，我们获得所选国家的所有城市(子术语)—<code class="du lb lc ld le b"><a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/components/CascadingManagedMetadata.tsx#L61" rel="noopener ugc nofollow" target="_blank">_onCountryChange</a></code>方法。我们称之为术语分类API的<code class="du lb lc ld le b"><a class="ae kd" href="https://docs.microsoft.com/en-us/graph/api/termstore-term-list-children?view=graph-rest-beta&amp;tabs=http" rel="noopener ugc nofollow" target="_blank">List children</a></code>端点，它将列出一个术语下的第一级子术语——在本例中是所有城市。这些是城市中的人口下拉列表。</p><p id="aa17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，我们无法从分类API获取术语的自定义属性。然而我们可以得到一个术语的描述。因此，这可以是存储任何与术语相关联的数据的一种选择。在这个场景中，我们在描述中存储一个城市的坐标。我们使用<a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/components/CascadingManagedMetadata.tsx#L94" rel="noopener ugc nofollow" target="_blank">数据</a>来显示在<a class="ae kd" href="https://pnp.github.io/sp-dev-fx-controls-react/controls/Map/" rel="noopener ugc nofollow" target="_blank"> PnP SPFx地图控件</a>中的准确位置。</p><p id="eb6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了向Microsoft Graph发送请求，我们使用了一个<a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/services/MSGraph.ts" rel="noopener ugc nofollow" target="_blank">助手类</a>。这是由Mikael Svenson 创建的，可以在任何SPFx项目中使用。这个类有4个方法来使用Microsoft Graph执行CRUD操作。</p><h2 id="968c" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">贮藏</h2><p id="7bf3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在这里解释的场景中，当用户与web部件交互时，分类法中的数据不会改变。因此，为了提高性能，缓存数据而不是每次都调用分类法API是有意义的。当我们得到一个国家下的城市术语时，我们可以将它们存储在缓存中(本地存储)。为了做到这一点，我们使用了一个类，该类具有与<a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/services/MMDService.ts#L45" rel="noopener ugc nofollow" target="_blank">向本地存储器</a>添加数据和<a class="ae kd" href="https://github.com/pnp/sp-dev-fx-webparts/blob/main/samples/react-graph-cascading-managed-metadata/src/webparts/cascadingManagedMetadata/services/MMDService.ts#L58" rel="noopener ugc nofollow" target="_blank">在需要时从本地存储器</a>获取数据相关的方法。</p><h2 id="849d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">摘要</h2><p id="8b1e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">多亏了Microsoft Graph团队，我们现在能够与分类数据进行交互。在这篇博文中，我们看到了一种在SPFx web部件中读取数据的简单方法。这个web部件可以很容易地扩展到创建/更新/删除分类数据。在这个API提供的各种分类端点的帮助下，所有这些现在都很容易实现。</p></div></div>    
</body>
</html>
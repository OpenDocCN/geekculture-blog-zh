<html>
<head>
<title>Optimization with EXPLAIN ANALYZE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用解释分析进行优化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/optimization-with-explain-analyze-1f8e396b7131?source=collection_archive---------28-----------------------#2021-05-06">https://medium.com/geekculture/optimization-with-explain-analyze-1f8e396b7131?source=collection_archive---------28-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://jayprakashstar.medium.com/indexing-in-postgres-db-4cf502ce1b4e" rel="noopener">之前的</a>文章中，我们讨论了什么是索引，以及为什么它是我们数据库的重要部分。现在让我们看一个实际的例子，如何有效地创建索引可以帮助我们，以及我们如何找出相同的。</p><p id="95e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询Postgres数据库，如果操作得当，可以产生非常高效的结果，并提供强大的洞察力。然而，有时查询不是以最佳方式编写的，导致响应时间很慢。因此，能够分析查询如何执行并找到运行查询的最佳方式非常重要。</p><p id="1820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化查询的一种方法是检查查询计划以了解查询是如何执行的，并调整查询以使其更有效。使用查询计划可以深入了解查询运行效率低下的原因。</p><p id="3c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是查询计划</strong></p><p id="a13d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询计划是数据库为了对数据执行查询而需要遵循的指令列表。</p><h2 id="fc81" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">解释和解释分析</h2><p id="f6a6" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在PostgreSQL中，可以使用<strong class="ih hj"> <em class="ke">解释</em> </strong>命令来检查查询计划:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="59a1" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">EXPLAIN</strong> <strong class="kk hj">SELECT</strong> seqid <strong class="kk hj">FROM</strong> traffic <strong class="kk hj">WHERE</strong> serial_id<strong class="kk hj">&lt;</strong>21;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/39cf8a3f891bd4bef56c69e435dd4e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hfp5WJmMWEtYYtGm.png"/></div></div></figure><p id="af4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此命令显示生成的查询计划，但不运行查询。为了查看实际执行查询的结果，您可以使用<strong class="ih hj"> <em class="ke">解释分析</em> </strong>命令:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="8ed4" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">EXPLAIN</strong> <strong class="kk hj">ANALYZE</strong> <strong class="kk hj">SELECT</strong> seqid <strong class="kk hj">FROM</strong> traffic <strong class="kk hj">WHERE</strong> serial_id<strong class="kk hj">&lt;</strong>21;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es la"><img src="../Images/89613cdc3f0320d50f04c30d5ddaeb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NpG-dlOT2bBuo0Nw.png"/></div></div></figure><p id="0683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">警告:</strong>添加<strong class="ih hj"> <em class="ke">分析</em> </strong>到<strong class="ih hj"> <em class="ke">解释</em> </strong>将运行查询并提供统计数据。这意味着如果你使用<strong class="ih hj"> <em class="ke">解释</em> </strong>对一个<strong class="ih hj"> <em class="ke"> DROP </em> </strong>命令(比如解释分析DROP TABLE table)，指定的值将在查询执行后被删除。</p><h1 id="8008" class="lb jf hi bd jg lc ld le jk lf lg lh jo li lj lk jr ll lm ln ju lo lp lq jx lr bi translated">使用的数据</h1><p id="5c33" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">用于演示优化的数据是关于交通违规的数据表，可在<a class="ae jd" href="https://data.montgomerycountymd.gov/api/views/4mse-ku6q/rows.csv?accessType=DOWNLOAD" rel="noopener ugc nofollow" target="_blank">这里</a>找到。它是从可供下载的CSV文件中导入的，删除了几个值的几列，并修改为一个名为serial_id的串行行。该表的详细信息如下所示:</p><p id="9561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">\d+流量</p><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ls"><img src="../Images/9d19888686947b17d576f7bed0a07421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GDFR1WPA-kfEaW_G.png"/></div></div></figure><h1 id="68f8" class="lb jf hi bd jg lc ld le jk lf lg lh jo li lj lk jr ll lm ln ju lo lp lq jx lr bi translated">指数</h1><p id="c57a" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated"><a class="ae jd" href="https://jayprakashstar.medium.com/indexing-in-postgres-db-4cf502ce1b4e" rel="noopener">索引</a>对于SQL的效率至关重要。它们可以极大地提高查询速度，因为它将查询计划改为更快的搜索方法。将它们用于大量查询的列是很重要的。</p><p id="24ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，示例数据中serial_id列上的索引会对执行时间产生很大影响。在添加索引之前，执行以下查询最多需要13秒钟，如下所示:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="c8ce" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">EXPLAIN</strong> <strong class="kk hj">ANALYZE</strong> <strong class="kk hj">SELECT</strong> <strong class="kk hj">*</strong> <strong class="kk hj">FROM</strong> traffic <strong class="kk hj">WHERE</strong> serial_id <strong class="kk hj">=</strong> 1;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lt"><img src="../Images/7894e233474b0bbd1263e9b2ea835cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8VnoJKx6Qy_qhGEC.png"/></div></div></figure><p id="390a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种规模的数据库上，13秒返回一行绝对不是最佳结果。在查询计划中，我们可以看到该查询正在对整个表运行并行顺序扫描，这是低效的。此操作具有很高的启动时间(1000毫秒)和执行时间(13024毫秒)。</p><p id="2679" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过创建索引并对其进行分析，可以避免并行顺序扫描，如下所示:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="8d52" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">CREATE</strong> <strong class="kk hj">INDEX</strong> idx_serial_id <strong class="kk hj">ON</strong> traffic(serial_id);<br/><strong class="kk hj">ANALYZE</strong>;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lu"><img src="../Images/04302a91cfb1f63fa078e5160b500eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uWHGI3rCeQss0b9g.png"/></div></div></figure><p id="e04e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明当使用索引时，执行时间从13024.774毫秒减少到0.587毫秒(即减少了99.99549 <strong class="ih hj"> % </strong>)。这大大减少了执行时间。规划时间确实增加了3.72毫秒，因为查询规划器需要访问索引，并在开始执行之前决定使用索引是否有效。然而，与执行时间的变化相比，计划时间的增加可以忽略不计。</p><p id="9484" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并非所有索引对查询的影响都是一样的。在实施指数之前和之后，使用<strong class="ih hj">解释分析</strong>来查看影响是什么是很重要的。</p><p id="ba70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">索引并不总是答案。有时顺序扫描比索引扫描更好。对于小表、大数据类型或已经有足够的指定查询索引的表，情况就是如此。</p><h1 id="59b1" class="lb jf hi bd jg lc ld le jk lf lg lh jo li lj lk jr ll lm ln ju lo lp lq jx lr bi translated">部分索引</h1><p id="c555" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">有时最好使用部分索引，而不是完整索引。部分索引是存储查询结果的有序数据的索引，而不是存储列的索引。当您希望特定的筛选器快速运行时，部分索引是最佳选择。例如，在该表中，记录了多种类型的车辆:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="9b78" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">SELECT</strong> <strong class="kk hj">DISTINCT</strong> vehicletype <strong class="kk hj">FROM</strong> traffic<br/><strong class="kk hj">GROUP</strong> <strong class="kk hj">BY</strong> vehicletype;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lv"><img src="../Images/d74f2988888b6798170579e85fc0ab3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4ftLClpwZujRxw4O.png"/></div></div></figure><p id="fb69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多研究都是关于摩托车安全的。对于这些研究来说，明智的做法是只对摩托车使用部分指数，而不是包括其他车辆类型的不必要信息的指数。若要创建仅索引涉及摩托车的行的部分索引，可以运行以下查询:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="964f" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">CREATE</strong> <strong class="kk hj">INDEX</strong> idx_motorcycle <strong class="kk hj">ON</strong> traffic(vehicletype)<br/><strong class="kk hj">WHERE</strong> vehicle <strong class="kk hj">=</strong> '01 - Motorcycle';<br/><strong class="kk hj">ANALYZE</strong>;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lw"><img src="../Images/04614e913aac2189bbebdeb7b7f10cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P8HsfSMV4LmshQmp.png"/></div></div></figure><p id="0681" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该索引将只存储与摩托车违章相关的数据，这比搜索整个表要快得多。</p><p id="fb5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是关于索引的一些最终提示:</p><ol class=""><li id="8fe4" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">切记<strong class="ih hj"> <em class="ke">分析</em> </strong>:重要的是运行<strong class="ih hj"> <em class="ke">分析；</em> </strong>创建索引后为了更新索引上的统计数据。这使得查询规划器可以在何时使用索引方面做出最明智的决定)</li><li id="a57d" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">记住<strong class="ih hj"> <em class="ke">真空</em> </strong>:对工作台进行重大修改后，运行<strong class="ih hj"> <em class="ke">真空分析</em> </strong>是很重要的。该命令将清理索引的统计数据，丢弃旧值并添加新值。此命令将定期自动运行，但是在大量修改后运行此命令对于更快获得结果非常有用。</li><li id="75e1" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">确保您的查询可以使用索引:避免使用在开头带有通配符的<a class="ae jd" href="https://dataschool.com/learn/how-regex-in-sql-works" rel="noopener ugc nofollow" target="_blank">正则表达式模式</a>如<strong class="ih hj"> <em class="ke">像“%[模式]%' </em> </strong>这样会使查询规划器无法使用索引。您可以使用结尾带有通配符的正则表达式模式，如<strong class="ih hj"> <em class="ke">，就像“[pattern]%”</em></strong>。</li></ol><h1 id="46f9" class="lb jf hi bd jg lc ld le jk lf lg lh jo li lj lk jr ll lm ln ju lo lp lq jx lr bi translated">数据类型</h1><p id="5719" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">效率的另一个重要方面是所使用的数据类型。数据类型对性能有很大的影响。</p><p id="9b9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同的数据类型可以有完全不同的存储大小，如PostgreSQL文档中关于<strong class="ih hj">数字类型</strong>的表格所示:</p><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ml"><img src="../Images/e41093633ba0c067890ee4e42cbf64f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1N8smUOPhiCEpiqe.png"/></div></div></figure><p id="b48b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交通违规数据集包含1，521，919行(使用<strong class="ih hj">计数</strong> <a class="ae jd" href="https://chartio.com/learn/sql/aggregate/?__hstc=113363352.94e82591ed64b2e1586ce498b9a712d4.1620292938473.1620292938473.1620292938473.1&amp;__hssc=113363352.1.1620292938474&amp;__hsfp=1637581693" rel="noopener ugc nofollow" target="_blank">聚合</a>找到)。我们需要考虑需要最少空间来存储我们想要的数据的数据类型。我们向数据中添加了一个串行列，从0开始，每行递增1。由于数据长度为1，521，919行，我们需要一种至少可以存储该数据量的数据类型:</p><ul class=""><li id="3b9a" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mm md me mf bi translated"><strong class="ih hj">如果行数在32768行以下，smallserial </strong>是最佳选择。</li><li id="9062" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mm md me mf bi translated"><strong class="ih hj">如果行数大于小序列的最大值或小于大序列的最小值，则序列</strong>是最佳选择。</li><li id="0211" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mm md me mf bi translated">如果行数超过2，147，483，647，bigserial 是合适的选择。</li></ul><p id="a9a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1，521，919大于<strong class="ih hj">小序列</strong>极限(32，768)，小于<strong class="ih hj">序列</strong>极限(2，147，483，647)，所以应该使用<strong class="ih hj">序列</strong>。</p><p id="82fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们为该列选择<strong class="ih hj"> bigserial </strong>，它将使用两倍的内存来存储每个值，因为bigserial的每个值都存储为8个字节，而不是serial的4个字节。虽然这对于<em class="ke">流量</em>或更大的表上的非常小的表来说不是非常重要，但是这可以产生很大的不同。在流量数据集中，这将是额外的6，087，676字节(6MB)。虽然这不太重要，但它确实会影响扫描和插入的效率。同样的原则也适用于较大的数据类型，如char(n)、文本数据类型、日期/时间类型等。</p><p id="6c3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果创建了一个流量副本，其中用<strong class="ih hj"> bigserial </strong>替换了<strong class="ih hj"> serial </strong>，则扫描时间会增加。通过比较解释分析结果，我们可以看到这一点:</p><p id="94f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原始表的结果:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="121e" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">EXPLAIN</strong> <strong class="kk hj">ANALYZE</strong> <strong class="kk hj">SELECT</strong> <strong class="kk hj">COUNT</strong>(<strong class="kk hj">*</strong>) <strong class="kk hj">FROM</strong> traffic;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mn"><img src="../Images/1bfaf44bcacc1bc94703f7b69f0baf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FuzumTk9NHERFZuk.png"/></div></div></figure><p id="6bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制的结果:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="5142" class="je jf hi kk b fi ko kp l kq kr"><strong class="kk hj">EXPLAIN</strong> <strong class="kk hj">ANALYZE</strong> <strong class="kk hj">SELECT</strong> <strong class="kk hj">COUNT</strong>(<strong class="kk hj">*</strong>) <strong class="kk hj">FROM</strong> traffic2;</span></pre><figure class="kf kg kh ki fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mo"><img src="../Images/a29f58ad2e13322fe26eb768be0cf971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SS82f-YLo5MQ2Kbo.png"/></div></div></figure><p id="92cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的图片中我们可以看到，在原始表上聚合的时间是197毫秒，即0.2秒。低效拷贝的聚合时间为1139毫秒或1.1秒(慢5.5倍)。这个例子清楚地表明，数据类型对效率有很大的影响。</p></div></div>    
</body>
</html>
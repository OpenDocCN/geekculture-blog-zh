<html>
<head>
<title>Scrollable Single-Page Site Navigation with React Custom Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React自定义挂钩的可滚动单页站点导航</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/scrollable-single-page-site-navigation-with-react-custom-hooks-4e7af716f6b1?source=collection_archive---------3-----------------------#2021-05-06">https://medium.com/geekculture/scrollable-single-page-site-navigation-with-react-custom-hooks-4e7af716f6b1?source=collection_archive---------3-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7502665c14b35a2e40ce3a15b5446e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Swv8Zd5AgEscuYy-"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">the custom hook we’ll be building!</figcaption></figure><p id="3da5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">链接到我们将要编码的实例！</em></p><p id="14a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae jt" href="https://shapirodaniel.github.io/single-page-nav/" rel="noopener ugc nofollow" target="_blank">https://shapirodaniel.github.io/single-page-nav/</a></p><p id="c50b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">链接到GitHub repo和源文件</em></p><div class="ju jv ez fb jw jx"><a href="https://github.com/shapirodaniel/single-page-nav" rel="noopener  ugc nofollow" target="_blank"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Shapiro Daniel/单页导航</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">带有自定义挂钩的单页导航模板</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">github.com</p></div></div><div class="kg l"><div class="kh l ki kj kk kg kl io jx"/></div></div></a></div><p id="9970" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">静态单页可滚动网站呈现了一个有趣的，超级好玩的导航挑战！如果你已经用React构建了单页应用程序，那么你很有可能已经使用React Router在特定的URIs渲染了你的组件——如果你已经构建了一个单页可滚动站点，其中所有组件都在相同的URI渲染，那么你已经知道其中的诀窍了:也就是说，我们如何将用户指引到站点的一个特定的<em class="js">区域</em>,以及我们如何在导航栏中反映用户在我们站点<em class="js">中的当前位置？</em></p><p id="6c89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作为用户，</p><ol class=""><li id="70a4" class="km kn hi iw b ix iy jb jc jf ko jj kp jn kq jr kr ks kt ku bi translated">我想单击一个导航元素，并让该元素滚动到我的视窗中</li><li id="e2d4" class="km kn hi iw b ix kv jb kw jf kx jj ky jn kz jr kr ks kt ku bi translated">我想滚动并在导航栏中看到我在网站中的当前位置。</li></ol><p id="0198" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用户故事#1看起来很简单:我们可以在任何我们喜欢的元素上挂一个<code class="du la lb lc ld b">containerRef</code>,并使用<code class="du la lb lc ld b">Element</code>接口的<code class="du la lb lc ld b">scrollIntoView</code>方法在相应的导航元素被点击时将容器移动到视口中。用户故事#2有点棘手——我们的导航元素如何知道哪个容器当前在视口中，我们如何<strong class="iw hj">将这个信息传递到食物链上</strong>以便相应地渲染导航样式？</p><p id="cbc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们不需要监视用户的当前位置，我们可以简单地通过将<code class="du la lb lc ld b">navLinkId</code>存储在<code class="du la lb lc ld b">Nav</code>组件的本地状态中，在<code class="du la lb lc ld b">scrollIntoView</code>调用旁边应用一个<code class="du la lb lc ld b">activeClass</code>样式。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/nav-without-context" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/nav-without-context</a></figcaption></figure><p id="3230" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">万岁！我们已经完成了用户故事# 1——进入下一阶段。</p><p id="2868" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">哥们，我的用户呢？</p><p id="fbd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">监视用户的位置应该不会太难:我们已经为每个可导航的目标准备了一个命令句柄(<code class="du la lb lc ld b">containerRef</code>)，我们可以利用它来确定<code class="du la lb lc ld b">ref</code>的容器是否可见。这是<code class="du la lb lc ld b">IntersectionObserver</code> Web API的一个很好的用例，它将允许我们创建一个<em class="js">观察者</em>来通知我们什么时候——重要的是，它的可观察目标与我们的视野相交到什么程度。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/intersection-observer-template" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/intersection-observer-template</a></figcaption></figure><p id="7c98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个<code class="du la lb lc ld b">IntersectionObserver</code>实例接受一个回调函数和一个选项对象，该对象包含:</p><ol class=""><li id="86cc" class="km kn hi iw b ix iy jb jc jf ko jj kp jn kq jr kr ks kt ku bi translated">一个<code class="du la lb lc ld b">root</code>元素，允许我们将可能相交的<code class="du la lb lc ld b">containerRef</code>的位置与一个元素进行比较，或者如果没有指定，与浏览器视窗进行比较；</li><li id="fde0" class="km kn hi iw b ix kv jb kw jf kx jj ky jn kz jr kr ks kt ku bi translated">一个<code class="du la lb lc ld b">rootMargin</code>(写为一个字符串化的CSS边距属性)，允许我们在计算交集之前扩展或收缩<code class="du la lb lc ld b">root</code>元素的边界框；而且，</li><li id="2a0a" class="km kn hi iw b ix kv jb kw jf kx jj ky jn kz jr kr ks kt ku bi translated">一个介于0.0-1.0之间的<code class="du la lb lc ld b">threshold</code>值(或值的数组)，这将帮助我们通过设置断点来校准我们的观察者的灵敏度，断点作为被观察元素的总面积的与<code class="du la lb lc ld b">root</code>相交的<em class="js">的函数。</em></li></ol><p id="44b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我们只需要检测一个垂直堆叠的容器是否进入了用户的可视页面区域，所以我们不指定我们的<code class="du la lb lc ld b">root</code>，让它默认为我们的<strong class="iw hj">浏览器视窗。</strong>同样，<code class="du la lb lc ld b">rootMargin</code>的默认<strong class="iw hj"> 0px </strong>将完成这项工作——但是我们可能最终需要校准我们的<code class="du la lb lc ld b">threshold</code>(稍后会详细介绍)。</p><p id="a7b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的<code class="du la lb lc ld b">observer</code>实例接收一个回调，该回调需要两个参数——一个<code class="du la lb lc ld b">entries</code>数组和<code class="du la lb lc ld b">observer</code>实例本身。<code class="du la lb lc ld b">entries</code>数组是<code class="du la lb lc ld b">IntersectionObserverEntry</code>实例的集合，这些实例挂钩到相交元素和我们的<code class="du la lb lc ld b">root</code>之间关系的各种属性。我们将使用布尔值<code class="du la lb lc ld b">entry.isIntersecting</code>来跟踪每个进入和离开视口的<code class="du la lb lc ld b">containerRef</code>。</p><p id="a062" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">太好了！我们离实现用户故事#2更近了一步:当用户滚动时，我们将有办法找到他们在单页布局中的位置。让我们构建一个自定义钩子，它将允许我们提供一个<code class="du la lb lc ld b">containerRef</code>，附加一个<code class="du la lb lc ld b">observer</code>，并返回一个布尔值，指示元素是否在屏幕上。所有的功劳都归于StackOverflow用户<a class="ae jt" href="https://stackoverflow.com/a/64892655/14116370" rel="noopener ugc nofollow" target="_blank"> Creaforge </a>，他专门为此构建了一个定制钩子！</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Thanks <em class="lk">Creaforge</em>! Link to gist:<a class="ae jt" href="https://tinyurl.com/use-on-screen-hook" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/use-on-screen-hook</a></figcaption></figure><p id="b28d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们编写<code class="du la lb lc ld b">useOnScreen</code>来创建一个自定义钩子<code class="du la lb lc ld b">useNav</code>，这将允许我们生成并返回一个<em class="js">观察到的</em> <code class="du la lb lc ld b">containerRef</code>，它的<code class="du la lb lc ld b">ref.current.id</code>将被注册到一个通过<code class="du la lb lc ld b">useContext</code>访问的<code class="du la lb lc ld b">NavProvider</code>上！</p><blockquote class="ll lm ln"><p id="b571" class="iu iv js iw b ix iy iz ja jb jc jd je lo jg jh ji lp jk jl jm lq jo jp jq jr hb bi translated">题外话:如果您对React Context API的基础有点不确定，请查看我的文章<a class="ae jt" rel="noopener" href="/geekculture/rebuilding-an-imperatively-coded-game-from-scratch-in-react-9a082ad002c0">在React </a>中从头开始重建强制性编码的游戏，在这篇文章中，我提出了一个实现React的Context API的很好的通用策略Redux的轻量级替代方案，有助于划分和管理状态。</p></blockquote><p id="e04a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的<code class="du la lb lc ld b">NavContext</code>由一个<code class="du la lb lc ld b">React.createContext()</code>实例和一个<code class="du la lb lc ld b">NavProvider</code>组成，它们的提供者值<code class="du la lb lc ld b">activeNavLinkId</code>和<code class="du la lb lc ld b">setActiveNavLinkId</code>——之前由我们的<code class="du la lb lc ld b">Nav </code>组件处理的本地状态——将被我们的<code class="du la lb lc ld b">useNav</code>钩子访问并用于更新我们的nav UI。但是为什么要重新发明轮子呢？我们已经有了本地状态管理，我们需要做的就是修改我们的<code class="du la lb lc ld b">useNav</code>钩子来接受<code class="du la lb lc ld b">setActiveNavLinkId</code>，把它传递给我们想要注册观察的每个组件。</p><p id="40b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我选择使用<code class="du la lb lc ld b">NavProvider</code>，因为它将让我们<strong class="iw hj">将我们所有的上下文逻辑</strong>封装在<code class="du la lb lc ld b">useNav</code>中:一旦设置了钩子并且构建了我们的<code class="du la lb lc ld b">Nav</code>和<code class="du la lb lc ld b">NavLink</code>组件，将导航功能分配给可导航目标将只需要一个钩子声明和一个包含<code class="du la lb lc ld b">navLinkId</code>和<code class="du la lb lc ld b">scrollToId</code>的<code class="du la lb lc ld b">navLink</code>对象数组，每个对象指向一个<code class="du la lb lc ld b">NavLink</code>实例和<code class="du la lb lc ld b">containerRef</code>的id。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/nav-context-and-provider" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/nav-context-and-provider</a></figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/use-nav-custom-hook" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/use-nav-custom-hook</a></figcaption></figure><p id="fe27" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">将所有这些放在一起</strong></p><p id="0d57" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在推出我们的定制挂钩，做一些导航！让我们首先将顶层<code class="du la lb lc ld b">App</code>组件的内容包装在<code class="du la lb lc ld b">NavProvider</code>中。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/app-with-nav-provider" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/app-with-nav-provider</a></figcaption></figure><p id="5a67" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的<code class="du la lb lc ld b">Nav</code>组件变得更小了:因为我们已经将<code class="du la lb lc ld b">activeNavLinkId</code>的管理转移给了<code class="du la lb lc ld b">NavContext</code>，我们可以移除本地的<code class="du la lb lc ld b">useState</code>处理程序。让我们也将我们的<code class="du la lb lc ld b">NavLink</code>组件重构到一个单独的文件中，以实现更好的模块化。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/nav-link-with-context" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/nav-link-with-context</a></figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/nav-with-context" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/nav-with-context</a></figcaption></figure><p id="67be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们想用作可导航目标的任何组件只需导入<code class="du la lb lc ld b">useNav</code>钩子，给它一个<code class="du la lb lc ld b">scrollToId</code>，并将返回的<code class="du la lb lc ld b">containerRef</code>赋给组件的顶层元素，旁边还有一个等于<code class="du la lb lc ld b">scrollToId</code>的id。</p><p id="66a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du la lb lc ld b">useNav</code>对它的实现视而不见——通过将它的<code class="du la lb lc ld b">ref</code>挂在我们喜欢的任何元素上，我们能够创建一个可滚动的导航目标，它将:</p><ol class=""><li id="140e" class="km kn hi iw b ix iy jb jc jf ko jj kp jn kq jr kr ks kt ku bi translated">通过点击响应直接导航，</li><li id="c4fd" class="km kn hi iw b ix kv jb kw jf kx jj ky jn kz jr kr ks kt ku bi translated">每当用户滚动的目标出现在我们的浏览器视窗<em class="js">中并且</em>与我们的<code class="du la lb lc ld b">IntersectionObserver</code>实例的<code class="du la lb lc ld b">threshold</code>值同步时，注册被动导航，并且</li><li id="5870" class="km kn hi iw b ix kv jb kw jf kx jj ky jn kz jr kr ks kt ku bi translated">在我们的<code class="du la lb lc ld b">Nav</code>组件中反映用户的当前位置！</li></ol><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/component-with-use-nav-hook" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/component-with-use-nav-hook</a></figcaption></figure><p id="1667" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过将我们用来通知我们的<code class="du la lb lc ld b">Nav</code>组件的所有逻辑封装在<code class="du la lb lc ld b">useNav</code>中，我们已经实现了一个即插即用的单页面导航解决方案，它的<strong class="iw hj">界面</strong>具有最小的表面积，允许我们在我们的导航组件层次结构中轻松地添加、删除和打乱元素。而且，我们的<code class="du la lb lc ld b">NavContext</code>实际上只是一个更一般的<code class="du la lb lc ld b">IntersectionContext</code>的具体实现，可以用来满足其他与交叉点相关的用户故事需求，比如延迟加载内容。</p><p id="c657" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">消除错误导航提示</strong></p><p id="c9df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有一个更有趣的问题需要解决——当用户点击导航到一个遥控器(即不相邻)组件相对于它们当前位置的位置？</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/9872fadbf1941b6618603594ac75fded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*wPm5-UtjBj1vhd9D"/></div><figcaption class="iq ir et er es is it bd b be z dx">false navigation cues!</figcaption></figure><p id="1799" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CSS来救援了！我们将分配一个<code class="du la lb lc ld b">transition-delay</code>来屏蔽接收<code class="du la lb lc ld b">activeClass</code>的<code class="du la lb lc ld b">NavLink</code>实例，因为我们的<code class="du la lb lc ld b">scrollToSection</code>方法让用户在到达目的地的途中经过其他<em class="js"> </em>组件。这抵消了我们的<code class="du la lb lc ld b">useNav</code>钩子对所有接受<code class="du la lb lc ld b">activeClass</code>样式的链接的影响，允许我们提供一个更好的UX——毕竟，点击一个链接并看到<em class="js">其他</em>链接亮起是很不和谐的！</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/d28749a86b4dd169e0310392b688a9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*v5WZDFLfVDR0tILC"/></div><figcaption class="iq ir et er es is it bd b be z dx">false cues hidden with transition-delay!</figcaption></figure><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist:<a class="ae jt" href="https://tinyurl.com/nav-span-css" rel="noopener ugc nofollow" target="_blank"> https://tinyurl.com/nav-span-css</a></figcaption></figure><p id="7474" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">调整观察者阈值</strong></p><p id="3b8a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们发现当我们在元素中间改变方向时，nav元素没有响应滚动提示——例如，我们已经向上滚动了一部分元素，结果又翻回来并再次穿过——我们已经找到了调整我们的<code class="du la lb lc ld b">threshold</code>选项数组的好机会。通过在我们的<code class="du la lb lc ld b">useOnScreen</code>钩子中包含额外的断点值，我们可以提高对<em class="js">交集比率</em>的敏感度，或者相对于浏览器视窗来说有多少可导航目标在视图中。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Link to gist: <a class="ae jt" href="https://tinyurl.com/threshold-sensitivity" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/threshold-sensitivity</a></figcaption></figure><p id="0ca9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">搞定！</strong></p><p id="7806" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就是这样！我们已经有了一个可扩展的单页面导航系统，它由React、React Context和React自定义挂钩支持。记住——定制钩子只是一些函数，它们组成标准钩子来封装逻辑，并提供一个干净的、最小化的接口在我们的组件中工作。每当你发现自己在组件中编写重复的钩子序列时，看看你是否能抽象出细节，给你和你的团队一个类似<code class="du la lb lc ld b">useNav</code>的流线型API！</p><p id="72c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">链接到我们构建的实例！</em></p><p id="7b3d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae jt" href="https://shapirodaniel.github.io/single-page-nav/" rel="noopener ugc nofollow" target="_blank">https://shapirodaniel.github.io/single-page-nav/</a></p><p id="b9ec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">链接到GitHub repo和源文件</em></p><div class="ju jv ez fb jw jx"><a href="https://github.com/shapirodaniel/single-page-nav" rel="noopener  ugc nofollow" target="_blank"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Shapiro Daniel/单页导航</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">带有自定义挂钩的单页导航模板。</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">github.com</p></div></div><div class="kg l"><div class="kh l ki kj kk kg kl io jx"/></div></div></a></div><p id="3f2e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Daniel Shapiro是一名全栈软件工程师，毕业于全栈学院，目前是该学院的助教。当他不制作酷的东西时，你通常会发现他沉迷于他以前的职业生涯，在芝加哥的许多工匠面包店担任首席面包师，烘焙一批英式松饼，带着他的小猎犬百合在沙滩上跑步，或者在密歇根湖划船。联系shapirodanieladam@gmail.com的丹尼尔或者连接LinkedIn的<a class="ae jt" href="http://linkedin.com/in/shapirodanieladam" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">，并且一定要访问socket.io支持的</em><a class="ae jt" href="https://github.com/shapirodaniel/note-ary" rel="noopener ugc nofollow" target="_blank"><em class="js">Note-ary</em></a><em class="js">项目管理套件，它具有看板风格的板和实时通信！</em></p></div></div>    
</body>
</html>
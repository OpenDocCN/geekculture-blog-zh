<html>
<head>
<title>5 SQL Index and Query Optimisations you didn’t know you need</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个您不知道自己需要的SQL索引和查询优化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/5-sql-index-and-query-optimisations-you-didnt-know-you-need-5650d9c46f47?source=collection_archive---------11-----------------------#2021-06-09">https://medium.com/geekculture/5-sql-index-and-query-optimisations-you-didnt-know-you-need-5650d9c46f47?source=collection_archive---------11-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="36e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您是一名软件开发专业人员或学生，您很可能只是因为SQL的速度而喜欢或讨厌它，或多或少地熟悉它的技术复杂性，并在某处使用它来完成一项或另一项任务。</p><p id="c080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这篇文章不是关于我们对这个工具有多熟悉，这篇文章是关于对于一个开发人员来说，学习如何编写高效的SQL查询来减少数据库的工作负载并让您的客户满意是多么重要。</p><blockquote class="jd je jf"><p id="3e6e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">请注意:本文不是关于分区或分片的指南，这些是数据库分布的完全独立的过程，当然，它们会加快您的选择，但是当像策略索引和一些基本的表知识就足够了时，我们还不需要进入那个。</p></blockquote><h1 id="7760" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动机💪</h1><p id="02e4" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated"><strong class="ih hj">我为什么要写这个？<br/></strong></p><p id="808c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有人问我为什么要优化我写的SQL，而我可以在我当前的表中使用一些糟糕的快速语句？:P <br/>至少我是这样认为的，直到我糟糕的方法导致了一个1分钟长的SELECT语句被用在客户端，作为一个通用的经验法则，你的开发伙伴可能会等待，但你的客户端不会。</p><h2 id="3c7e" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">改进的开发实践🔧</h2><p id="fea5" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">总而言之，更快的查询不会有坏处，对吧？这是可以理解的，有时你在一个截止日期的紧要关头，需要尽快交付应用程序，并不能真正关心这个特定查询执行得好/坏，但请相信我，当你不必回头看这个现在需要优化的特定查询时，处理这个微小的事情将会有很大的帮助，也将有助于你在当前角色的职业生涯中成长</p><h2 id="2fce" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">谁不喜欢钱？💰</h2><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/6c7708f4ab8ea863e4e33eea78b5bb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6DEBd6RUFDjBT5T2"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Photo by <a class="ae kn" href="https://unsplash.com/@joshappel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Appel</a> on <a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从个人的行业经验来看，无论你的预算如何，你都不能在粗心大意上花费太多，如果你可以不费吹灰之力就做一些事情，你就应该做，尤其是如果它直接影响你的技术堆栈的整体运营成本。(Psst，公司的人可能不理解，但初创公司的人知道严格控制预算的重要性。)</p><h1 id="9995" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">1.了解您的数据库提供商🍵</h1><p id="8aa2" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">如果您正在使用本地SQL数据库，您可以在进程日志和<code class="du ls lt lu lv b">mysql.slow_log</code>表中记录您的慢速查询。一个这样的例子是:</p><p id="ddf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在使用像亚马逊RDS或谷歌云数据库这样的云数据库，请留意它们的数据库监控工具。Amazon RDS中的Performance insights同时也是一个救命稻草。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lw"><img src="../Images/80dffa0e000153d0a4862377d14cc2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YZocqEBzEWzrgQSAUAXzw.png"/></div></div></figure><h2 id="e6a0" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">性能见解的优点</h2><ul class=""><li id="e6a6" class="lx ly hi ih b ii ki im kj iq lz iu ma iy mb jc mc md me mf bi translated">显示锁时间、前10个SQL和其他数据库关键统计数据(如每秒处理的行数、每秒插入的行数)的基本思想使它在可视化数据库行为方面与众不同。</li><li id="4ce5" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">“按主机切片”功能是我个人喜欢这个工具的一点，因为它有助于跟踪这个IO密集型查询是从哪里来的！</li><li id="d922" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">他们的查询分组特性是我个人推荐的，他们用一个特定的框架将相似的查询组合在一起。例如，如果您有两个高调用/秒或高平均延迟的查询，该工具将跟踪它们并将它们压缩到一个结构中。太酷了。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/3a69af9cc5c53a06e4592dd4d0fff5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H861o7GowdcxBJjH3EJwHw.png"/></div></div></figure><p id="2d6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">绩效洞察力的缺点</strong></p><ul class=""><li id="072d" class="lx ly hi ih b ii ij im in iq mm iu mn iy mo jc mc md me mf bi translated">用户体验非常慢，重新加载中的边缘情况并不是他们真正考虑过如何正确处理的事情。</li><li id="1547" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">为什么仅仅停留在10个SQL查询上？我希望有一个CSV报告下载选项，其中包含所有的查询和日志时间，是的，它可以是一个收费的功能，没有问题。</li><li id="1448" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">说到账单，见解到底为什么要顺便计费:)？</li></ul><h1 id="1b66" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">2.索引是你最好的朋友💌</h1><p id="fb66" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">如果你在谷歌上搜索了以下问题中的任何一个</p><blockquote class="jd je jf"><p id="a68c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">如何优化我的SQL查询？<br/>如何让我的查询更快？<br/>快速SQL查询。</p></blockquote><p id="e096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么你一定会对“<strong class="ih hj">索引</strong>”这个词很熟悉。如果你不欢迎我的索引课，他们到底是什么，为什么他们是这样的生活救星。</p><h2 id="d4eb" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">索引101 🧑‍🏫</h2><p id="d128" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">简而言之，索引是一种很好的方式，可以将一个无序的表格按顺序排列，从而最大限度地提高查询效率。未索引的表没有任何决定性的方法来对表进行排序(除了已经被索引的主键之外),因此强制每个查询在表中执行完整的穷举查找，例如，在一个简单的查询中，如:<br/> <code class="du ls lt lu lv b">SELECT data1, data2 FROM table1 WHERE id BETWEEN 10 AND 20 LIMIT 5;</code></p><p id="c446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在检查后需要返回5行的地方，假设有500万行。听起来不切实际，对吗？</p><p id="fbac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这就是索引出现的地方</strong></p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mp"><img src="../Images/66914eab1e4d235d10e173412300295d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-_pJ5WUWiHRpiFo_qvRSw.png"/></div></figure><p id="05f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借用这个惊人来源的这段文字<a class="ae kn" href="https://chartio.com/learn/databases/how-does-indexing-work/" rel="noopener ugc nofollow" target="_blank">索引是如何工作的</a>【1】，</p><blockquote class="jd je jf"><p id="f739" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">实际上，索引会导致数据库创建一个数据结构。数据结构类型很可能是一棵<a class="ae kn" href="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/rec25.html" rel="noopener ugc nofollow" target="_blank"> B树</a>【2】。虽然B树的优点很多，但对于我们的目的来说，它的主要优点是可排序。当数据结构按顺序排序时，我们的搜索会更有效，原因显而易见，如上所述。</p></blockquote><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mq"><img src="../Images/29c22511a91ac66018850db58b6f5006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*vqU9M1oFGSsNrlT3seuMhQ.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">B-Tree</figcaption></figure><p id="0882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你上过数据结构课，B树对你来说一定很熟悉。B树专门用于减少获得磁盘级访问的时间。它是怎么做到的？对于在B树中的搜索，其时间复杂度是<code class="du ls lt lu lv b">O(log_m_(n+1))</code>，其中<code class="du ls lt lu lv b">m</code>是节点的大小，<code class="du ls lt lu lv b">n</code>是节点的数量。</p><p id="6fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:一旦创建了索引，插入和更新就会变慢，因为现在每个插入和更新操作都会产生额外的<code class="du ls lt lu lv b">O(Log n)</code>开销，而在以前，这只是一个简单的搜索和<code class="du ls lt lu lv b">O(1)</code>操作。</p><h2 id="0e7e" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">一些值得注意的例子🔍</h2><p id="6b0f" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">让我们来看看我在实习任务中遇到的一些现场制作的例子，这是其中最好的例子。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/239afebd412922e59bf88342a9188d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpM35vh5n7OVlac3_4758A.png"/></div></div></figure><p id="b693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们尝试更新一个数据科学实验表，我们希望在满足where条件的每一行中更新特定的一组值。<br/>现在，为了识别我们需要更新的行，当没有索引时，查询将对表进行全扫描，这就是我们的生产数据库对这个特定查询所做的。</p><p id="409c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初的查询时间长达51秒，对于一个只有不到5万行的表的简单更新来说太长了。</p><p id="2252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案？对<strong class="ih hj"> postId </strong>和<strong class="ih hj"> userId </strong>应用复合索引，瞧，更新运行时间下降到个位数秒！</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ms"><img src="../Images/12f92b2a940e214987e0a5105909aa42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9whcL-xdb2mZmd7vG_oqg.png"/></div></div></figure><p id="df84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您可以决定索引的排序方式，默认方式是升序，因此在这种情况下，两个查询将以相同的方式工作！</p><h1 id="2ddb" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">3.多列索引？仔细想想。💭</h1><p id="0928" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">在我们上面讨论的查询中，我们创建了一个复合索引，即，在两列的组合上创建索引，因为我们将非常频繁地组合该组合来标识特定的行并更新它。但这回避了一个问题:</p><h2 id="f9c3" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">Uddeshya，我们可以对postId和userId都使用索引，对吗？</h2><p id="9d66" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">这个问题的答案是非常非常主观的，在我回答这个问题之前，我建议你浏览一下<a class="ae kn" href="https://stackoverflow.com/a/179224" rel="noopener ugc nofollow" target="_blank">EVI homer</a>[3]的这个优秀的堆栈溢出答案，它通过一个类似的例子在<strong class="ih hj"> mysql </strong>的上下文中回答了这个问题(不能太肯定所有的sql提供者)。但是对于基本的覆盖范围，它是这样的:</p><p id="0f2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，索引<code class="du ls lt lu lv b">nsfwModel_idx1</code>是建立在<code class="du ls lt lu lv b">(postId, userId)</code>上的多列复合索引，这意味着，当我们通过以下方式进行查询时，我们希望该索引将对查询有用:</p><ul class=""><li id="3889" class="lx ly hi ih b ii ij im in iq mm iu mn iy mo jc mc md me mf bi translated">postid和userId</li><li id="6863" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">仅postid</li><li id="fcab" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">表中的一行由(postId，userId)组合唯一定义。</li></ul><p id="2b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当只使用userId时就不行了，因为SQL server不会认为这有什么帮助(顺便说一下，索引列是从左到右处理的)。</p><p id="bec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们的问题，如果我们要创建两个单独的索引，那么是的，SQL查询优化器引擎将一个接一个地寻找两个索引，并降低查询速度。但是:</p><ul class=""><li id="11cc" class="lx ly hi ih b ii ij im in iq mm iu mn iy mo jc mc md me mf bi translated">❌:这会占用更多的磁盘空间。</li><li id="566d" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">❌:这将进一步损害引擎的插入和更新速度，因为记住，更多的索引=更多的插入延迟。SQL特定函数文章</li><li id="7e01" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">✔️But:如果你的系统在不同的查询中分别使用两个列，那将会非常令人惊奇。</li></ul><p id="5cb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最终，这将取决于您的设计决策，以及您如何巧妙地利用现有的索引来优化您未来的查询。</strong></p><h1 id="ee51" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">4.服务器功能是好的，但不是在索引列🛑</h1><p id="b09e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">这实际上对我们来说是一件新鲜事，但却如此平常，我相信你也一定做过这样愚蠢的事。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/1e6b614163c2fa9e665b87707fb66fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPEwRrYwcO8mlbrrBG7pjA.png"/></div></div></figure><p id="0399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个简短的查询什么也不做，只是从一个follower用户表中获取follower id的总追随者计数，该表包含一些枚举数据类型、状态和不言自明的日期列。老实说，这个查询看起来没什么问题，对吗？在我给你答案之前，让我解释一下这个表中的指数是什么样子的。</p><ul class=""><li id="0e18" class="lx ly hi ih b ii ij im in iq mm iu mn iy mo jc mc md me mf bi translated">followerId列是主键，因此被索引。</li><li id="c04d" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">状态是枚举，因此也是索引的。</li><li id="0efb" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">日期列也被索引！</li></ul><p id="5916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，从理论上讲，我们的SELECT语句应该利用所有这三个单独的索引，对吗？<br/> <strong class="ih hj">错。</strong></p><p id="ede4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">罪魁祸首是那个看起来很简单的DATE() SQL函数，在这篇<a class="ae kn" href="https://www.mssqltips.com/sqlservertip/1236/avoid-sql-server-functions-in-the-where-clause-for-performance/" rel="noopener ugc nofollow" target="_blank"> SQL特定函数文章</a> [4]中引用了这个问题</p><blockquote class="jd je jf"><p id="485c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">…当在WHERE子句中使用这些相同的函数时，这会强制SQL Server执行表扫描或索引扫描以获得正确的结果，而不是在有索引可用的情况下执行索引搜索。<strong class="ih hj">这样做的原因是，必须对每行数据的函数值进行评估，以确定它是否符合您的标准。</strong></p></blockquote><p id="710c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了避免对索引进行全面评估，我们所做的只是利用我们的查询需要最新日期这一事实，并因此在查询的右侧应用date()函数，瞧，查询运行时间从平均56秒下降到几乎5秒！</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/8fb965ed27bae2220fd9710312e4fd6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aA7g-yvs8UA_3INxhOerzQ.png"/></div></div></figure><h1 id="8085" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">5.你的桌子需要你的注意，🥺</h1><h2 id="c2a1" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">🕵️‍♂️的不幸的订单好奇的情况</h2><p id="b0c7" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">很多时候，为了完成简单而琐碎的任务，比如说，你想找到10个最近的通知，其中包括19个类别。</p><p id="adba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但棘手的是，我们亲爱的表是由<strong class="ih hj"> categoryId </strong>和<strong class="ih hj"> createdAt </strong> time按升序索引的，因此，我们运行了一个额外的order by操作，它的方向也与应该执行的方向相反。巧妙使用索引可以让你的生活更轻松，不负责任的索引，嗯，它们可以让你的生活变成15分钟<strong class="ih hj">(我不是开玩笑，字面意思是15分钟运行时间)</strong>运行时间地狱。选择权在你。<br/>我们面临的问题是:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mt"><img src="../Images/97e1f47a793c25f8cfb496a02db52db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcIj9xG1Tor1Il1K1l2qwA.png"/></div></div></figure><p id="beae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">建议阅读</strong>来详细了解我们到底在谈什么:Markus Winad的文章<a class="ae kn" href="https://use-the-index-luke.com/sql/sorting-grouping/indexed-order-by" rel="noopener ugc nofollow" target="_blank">关于Indexing Order的文章</a>【5】。</p><p id="0912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们决定利用已经存在的索引，而不是在它上面再应用一个操作，而不是修改一个列上的索引，因为修改索引会花费几个小时的时间。</p><p id="2934" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们计算了总行数，并根据页面，我们改变了偏移量，结果得到了极大的改善(老实说，没有我们预期的那么好，它仍然是50秒长，但它比15分钟长，我猜。毕竟，我们处理的是一个有4.6亿行的表。</p><h2 id="e082" class="ko jl hi bd jm kp kq kr jq ks kt ku ju iq kv kw jy iu kx ky kc iy kz la kg lb bi translated">他们存档的那个👀</h2><p id="2e8d" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们遇到了一个非常繁重的查询，它只有一个任务，即每天存档当前的“爱情”状态，以便于将来检索和作为后备计划。对于某些上下文，这个查询运行在一个Cron作业实例上，并且必须一天运行5到6次。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/0abef2ed3a0c6929a33fbd6f618c8917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQSRa0QGF7l-jrLO4lfIFg.png"/></div></div></figure><p id="a914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的重要一点是，每次保存20，000个爱情的查询处理了大约7000万行，平均运行时间是多少？2-3分钟。</p><p id="4080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何解决这个问题？</p><p id="da88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们的loveSamples表既有updatedAt作为索引，又有“loveId”作为自动递增的主键(因此类似于按升序排列的索引)，我们决定在需要存档的最早的20，000个like中找到最大的loveId，然后使用这个最大的Id驱动插入，这确保了我们精确地获得20，000行，从而大大缩小了搜索范围。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/49ca063938dc9a441ba01ae3b17438ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSuymlv6npntsvMq3pVPDQ.png"/></div></div></figure><h1 id="4d68" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">资源！📚</h1><ul class=""><li id="6061" class="lx ly hi ih b ii ki im kj iq lz iu ma iy mb jc mc md me mf bi translated"><a class="ae kn" href="https://chartio.com/learn/databases/how-does-indexing-work/" rel="noopener ugc nofollow" target="_blank">索引是如何工作的</a> [1]</li><li id="8deb" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">什么是<a class="ae kn" href="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/rec25.html" rel="noopener ugc nofollow" target="_blank"> B树</a>s【2】</li><li id="930e" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae kn" href="https://stackoverflow.com/questions/179085/multiple-indexes-vs-multi-column-indexes/179224#179224" rel="noopener ugc nofollow" target="_blank">索引最佳实践</a> [3]</li><li id="4722" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae kn" href="https://www.mssqltips.com/sqlservertip/1236/avoid-sql-server-functions-in-the-where-clause-for-performance/" rel="noopener ugc nofollow" target="_blank">避免索引上的SQL函数</a> [4]</li><li id="6e7d" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><a class="ae kn" href="https://use-the-index-luke.com/sql/sorting-grouping/indexed-order-by" rel="noopener ugc nofollow" target="_blank">按资源的索引顺序</a>【5】</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>OOP in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的OOP</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/oop-in-javascript-6c4ff58ff48c?source=collection_archive---------10-----------------------#2021-12-02">https://medium.com/geekculture/oop-in-javascript-6c4ff58ff48c?source=collection_archive---------10-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/be399d4660c065a0faa932f26c9c1d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNsBLmsLrR7RKOVTojmoIA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@joshuaryanphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Reddekopp</a> on <a class="ae iu" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7864" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我在熨斗学校开始我的软件工程之旅时，我第一次了解了面向对象编程。我怀疑像我这样从起点开始的人，是否能够在深层次上理解它。训练营的本质就是你用指甲抓着不放！所以我决定回顾/复习一下，特别是考虑到<a class="ae iu" rel="noopener" href="/@sho.miyata.1/the-object-oriented-programming-vs-functional-programming-debate-in-a-beginner-friendly-nutshell-24fb6f8625cc">函数式编程与OOP讨论</a>可能不会很快“解决”。</p><p id="1900" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OOP当然是面向对象编程的简写，自<a class="ae iu" href="https://en.wikipedia.org/wiki/Object-oriented_programming#History" rel="noopener ugc nofollow" target="_blank">50年代末/60年代初</a>以来就一直存在。JavaScript方面，2015年<a class="ae iu" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank"> ES6 </a>推出了OOP。正因为如此，JavaScript被认为是多范型的——我们可以使用纯函数编写JavaScript，或者我们可以使用OOP原理来构建我们的代码，从而模仿真实世界的体验。</p><p id="7990" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，OOP是一种编程范式或一组概念，其中代码以这样一种方式组织，即它创建一个以实例化对象为中心的蓝图——通常通过类——包含状态和行为。即对象<em class="jt">所具有的</em>(特征/属性)和对象<em class="jt">所做的</em>(方法/功能)的事物。这个类的每个实例化是一个对象，它也将实例化它的单个状态，并且可以访问它的继承函数。所以我们可以创造一种动物。那种动物可以有名字，各种各样的特征和它所做的事情，比如说话。“喵。”</p><p id="bc13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OOP的四大支柱是封装、继承、抽象和多态。这些术语已经被描述了许多方式。这是我对他们的理解:</p><p id="ba58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1)封装:代码被组织到容器中以便更好地组织，这避免了代码重复的需要。这是OOP跳动的心脏。封装还允许我们隐藏一个方法或属性，这样它就不会被意外地改变或篡改。(注意verrrry new <code class="du ju jv jw jx b">#</code>在本例中不是用于社交媒体发布，而是用于在JavaScript的类中创建和利用私有变量和方法！您可以在下面的代码示例中看到它的使用。)</p><p id="4247" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2)继承:类的任何实例继承该类的变量和方法，以及可能从该类的超(或父)类继承的任何状态和/或行为。这额外的一点超能力(看到我做了什么吗？)需要使用<code class="du ju jv jw jx b">super()</code>关键字。</p><p id="e61c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3)抽象:那些可爱的小实例对象不需要担心他们漂亮的脑袋“如何”。他们可以直接调用方法，让类来处理细节。</p><p id="32ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4)多态性:一个方法可以被编程为根据调用它的人的不同而有不同的行为。(即，狗会叫，而猫会喵。)子类甚至可以覆盖其超类中声明的函数。这个新的和改进的功能被封装/保护在它自己的类中。如此强大的力量！</p><p id="a839" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有趣的是，如果我们使用函数式编程——也就是说，如果我们函数式地创建一个对象——我们确实可以访问<code class="du ju jv jw jx b">this</code>(在实例化对象的正确上下文中)，我们有JavaScript的内置构造函数，并且对象被自动返回。如果我们使用<code class="du ju jv jw jx b">new</code>关键字，所有这些都会提供给我们。这确实模仿了OOP，但它不是OOP。您甚至可以将函数嵌套在这些“与OOP相邻”的函数中，尽管不建议这样做，因为新对象的每次实例化都需要额外的内存空间。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">creating Doctor via functional programming</figcaption></figure><p id="fc66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用类(见下文)是我们编写JavaScript OOP风格的方式，至少在内存空间方面更好。当创建一个新实例时，它可以定位它有权访问的函数，但不需要为函数本身保留内存空间。</p><p id="4e52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">static</code>关键字是为类方法和属性保留的，而实例方法不使用<code class="du ju jv jw jx b">static</code>。当然，实例变量使用<code class="du ju jv jw jx b">this</code>。(方法也可以用<code class="du ju jv jw jx b">this</code>。)</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">OOP concepts used in JavaScript — welcome to Grey’s Anatomy</figcaption></figure><p id="15eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有趣的事实:JavaScript中的OOP类并不是真正的OOP。这实际上是句法糖(即魔术。不要看窗帘后面！)看起来和行为都像OOP，但实际上是简单的原型继承。例如，如果我们打开console.log <code class="du ju jv jw jx b">drMontgomery.__proto__</code>，我们会看到这样的内容:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/53d6755477df870d86b6ebb00e054fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*zY7LRImP6rDEi0QVmrtWow.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Doctor Class extends from Person Class via __proto__ property</figcaption></figure><p id="98ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这与我们创建一个新数组并检查它的__proto__属性没有太大区别:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/b69067a07d4477ffa29903e696d01148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*-4QCmBCuNJgoAWw5-R1gLg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">we know that a new Array comes with lots of functionality built in</figcaption></figure><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/39bd69fb3594f556b7db9b3538dd83af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*1ITGqKV3D13-YlmF_-ECbw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">array inherits from Object via Prototype. Feels like OOP!</figcaption></figure><p id="ed5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现我越了解OOP就越喜欢它。尽管函数式编程和钩子在React.js中风靡一时，但我现在对React中的OG类有了更深的敬意。与典型的OOP一样，当我们看一个从React扩展的类时，它继承了许多方法，最重要的是生命周期方法(<code class="du ju jv jw jx b">render()</code>本身就是一个生命周期方法。在过去，我倾向于忘记这一点。).注意<code class="du ju jv jw jx b">extends</code>关键字。呜！</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/ec161175d6d765e2a9de519b2c53dae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*WbxOTpSE7Eb2WPJUeWQELw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">This code is gratefully borrowed from <a class="ki kj ge" href="https://medium.com/u/37d87f15681e?source=post_page-----6c4ff58ff48c--------------------------------" rel="noopener" target="_blank">Brad Westfall</a></figcaption></figure><p id="dce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大家编码快乐！我很想知道你对OOP的看法，以及你对OOP和函数式编程的偏好。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="9763" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我非常，非常推荐安德烈·尼戈瓦:【https://www.udemy.com/course/advanced-javascript-concepts/】T2的这门课</p><div class="kr ks ez fb kt ku"><a href="https://www.freecodecamp.org/news/four-pillars-of-object-oriented-programming/" rel="noopener  ugc nofollow" target="_blank"><div class="kv ab dw"><div class="kw ab kx cl cj ky"><h2 class="bd hj fi z dy kz ea eb la ed ef hh bi translated">面向对象编程的四大支柱</h2><div class="lb l"><h3 class="bd b fi z dy kz ea eb la ed ef dx translated">JavaScript是一种多范式语言，可以按照不同的编程范式编写。一个编程…</h3></div><div class="lc l"><p class="bd b fp z dy kz ea eb la ed ef dx translated">www.freecodecamp.org</p></div></div><div class="ld l"><div class="le l lf lg lh ld li io ku"/></div></div></a></div><div class="kr ks ez fb kt ku"><a href="https://reacttraining.com/blog/useEffect-is-not-the-new-componentDidMount/" rel="noopener  ugc nofollow" target="_blank"><div class="kv ab dw"><div class="kw ab kx cl cj ky"><h2 class="bd hj fi z dy kz ea eb la ed ef hh bi translated">useEffect(fn，[])不是新的componentDidMount()</h2><div class="lb l"><h3 class="bd b fi z dy kz ea eb la ed ef dx translated">他们几乎是一样的。但实际上，这种差异足以让你陷入困境…</h3></div><div class="lc l"><p class="bd b fp z dy kz ea eb la ed ef dx translated">reacttraining.com</p></div></div><div class="ld l"><div class="lj l lf lg lh ld li io ku"/></div></div></a></div></div></div>    
</body>
</html>
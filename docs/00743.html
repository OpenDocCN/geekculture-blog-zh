<html>
<head>
<title>Hoisting in JavaScript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中提升。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hoisting-in-javascript-f0809921bbba?source=collection_archive---------3-----------------------#2021-03-12">https://medium.com/geekculture/hoisting-in-javascript-f0809921bbba?source=collection_archive---------3-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/008cffa556b65206de139b1f966143c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6aLiDuxb-DPGsKT7daI6A.png"/></div></div></figure><p id="1e7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript是另一个让我们热爱语言的美丽部分。</p><p id="406b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说到吊装，我们大部分时间都很困惑。这是面试官最喜欢问的问题之一。所以今天我们将试着用简单的通俗语言来理解起重。</p><p id="b5e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们先从一些JS代码来理解吊装。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7e58" class="jx jy hi jt b fi jz ka l kb kc">// JS Hoisting</span><span id="0ec0" class="jx jy hi jt b fi kd ka l kb kc">var m = 10;<br/>function miniScript() {<br/>  console.log(“miniScript is exploring JS”);<br/>}</span><span id="ca1f" class="jx jy hi jt b fi kd ka l kb kc">// Let's invoke the functions and variables <br/>miniScript();<br/>console.log(m);</span></pre><p id="a875" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个简单的JS代码，其中我们声明了简单的变量和函数。预期的输出</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/ceef4324a16a325ae2739d3c4c5716bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mygc8nXKWodliycXl7c9lQ.png"/></div></div></figure><p id="55de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们所知道的，但最大的问题是什么是吊装？</p><p id="1cbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解这一点，让我们修改上面写的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d625" class="jx jy hi jt b fi jz ka l kb kc">//Call the function and variables even before we declaring them.</span><span id="0c09" class="jx jy hi jt b fi kd ka l kb kc">console.log(m);<br/>miniScript();</span><span id="1c3e" class="jx jy hi jt b fi kd ka l kb kc">function miniScript() {<br/>  console.log(“miniScript is exploring JS”);<br/>}<br/>var m = 10;</span></pre><p id="6e22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你对这个的输出有什么看法？</p><p id="ad7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数编程语言都会在这里抛出这个错误，因为我们试图运行那时还不存在的函数。</p><p id="1ec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这正是JavaScript的美妙之处，当我们深入探索时，它让我们更加热爱它。</p><p id="2e8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是上面这段代码的输出。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/c6f113b8d3eb586024df27f758bff897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OWSGlXAYEf-QUt18CVd8w.png"/></div></div></figure><p id="e023" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出是var m = <strong class="is hj"> <em class="kg"> undefined </em> </strong>，我们得到miniScript()函数的正确值。这都是因为吊装。用通俗的语言来说，提升的定义应该是——<br/><strong class="is hj"><em class="kg">JavaScript中的提升是在声明或初始化变量和函数之前就访问它们，而没有任何错误</em>。</strong></p><p id="8aac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以最大的问题是JavaScript引擎是如何做到这一点的？<br/>让我们将调试器放在第一行代码上，并停止浏览器来执行代码并深入其中。<br/>我附上将调试器放入第一行代码的屏幕记录</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/b4c6ab4edd88ec6c77e1ac0cf2db0eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PjKj58xpQ4j8YBUBXgvwHA.gif"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">GIF Image</figcaption></figure><p id="1a6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以你可以在全局范围内看到，如果我们向下滚动一点，我们可以找到我们的变量和函数。<br/>变量未定义，这意味着JavaScript引擎给这个变量分配了一个内存，并给它一个占位符<strong class="is hj"> <em class="kg">未定义。</em>T15】</strong></p><p id="f93c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们console.log我们的完整函数，您将会看到一些有趣的事情发生。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cdee" class="jx jy hi jt b fi jz ka l kb kc">// Let's see how our function will look in Global scope before executing. </span><span id="306c" class="jx jy hi jt b fi kd ka l kb kc"><em class="kg">console</em>.log(miniScript);</span><span id="5b5d" class="jx jy hi jt b fi kd ka l kb kc"><em class="kg">function</em> miniScript() {<br/>   <em class="kg">console</em>.log("miniScript is exploring JS");<br/>}</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/c1f78caddb298fdb3c42925dd0cc699d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_l3c_zrnI8T9NFi4auyoPw.png"/></div></div></figure><p id="2233" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript甚至会在开始执行代码之前就给函数和变量分配内存。这叫吊装。</p><p id="5243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如果我们使用箭头函数，那么在全局堆栈中会发生什么。这将不会像传统函数那样运行。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8c84" class="jx jy hi jt b fi jz ka l kb kc">// Arrow function behave like variables. </span><span id="cbf9" class="jx jy hi jt b fi kd ka l kb kc"><em class="kg">console</em>.log(miniScript);</span><span id="1db8" class="jx jy hi jt b fi kd ka l kb kc"><em class="kg">var</em> miniScript = () <em class="kg">=&gt;</em> {<br/>   <em class="kg">console</em>.log("miniScript is exploring JS");<br/>}</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/8f4d830a9551c35e43d9933b3dd9b528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3N454La8lFoyQ4VYKPL7g.png"/></div></div></figure><p id="6e3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以看到arrow函数的行为就像变量一样，因为它的值是<strong class="is hj"> <em class="kg">未定义的。</em> </strong>这意味着函数在执行上下文中分配内存，而<strong class="is hj"> <em class="kg">未定义</em> </strong>是其占位符。</p><p id="9d27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提升是JavaScript的一个概念，其中JS在环境的顶部托管所有函数表达式和变量，正因为如此，我们可以在声明变量或函数之前使用它。</p><p id="7d5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一切都是因为吊装而发生的。下次如果有人问你提升——提升就是在初始化变量和函数之前就把内存分配给它们。</p><p id="33a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更深入一点，看看在<strong class="is hj"> <em class="kg">让</em> </strong>和<strong class="is hj"> <em class="kg"> const的情况下会发生什么？</em> </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="31d0" class="jx jy hi jt b fi jz ka l kb kc">// Use case for let or Const - I am using const <br/>console.log(m);</span><span id="df5c" class="jx jy hi jt b fi kd ka l kb kc">const m = 'miniScript';</span></pre><p id="b0d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你认为输出会是什么？它们的行为会和var或函数一样吗？让我看看……</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/062c29530b3f42e7684d0d0bc7b48ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HD-4FMdRhRNNedfKp1Xmhw.png"/></div></div></figure><p id="5fd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案有点复杂。您可以看到我们得到了错误“<strong class="is hj"> <em class="kg">”未捕获的引用错误:在初始化</em> </strong>之前无法访问“m”。这意味着我们不能在初始化之前访问变量，但是正如你所看到的<strong class="is hj">作用域</strong>我们有另一个名为<strong class="is hj"> <em class="kg">脚本</em> </strong>的局部作用域，其中我们的变量'<strong class="is hj"> m </strong>'及其值为<strong class="is hj">未定义</strong>。那么这意味着什么呢？<br/>这意味着<strong class="is hj"> let和</strong>const不属于全局作用域。他们在<strong class="is hj">全局作用域</strong>之上创建自己的<strong class="is hj"> <em class="kg">局部作用域</em> </strong>。</p><p id="f931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这被称为<strong class="is hj">时间死区</strong>。如果你试图从死区访问这些变量，你会得到<strong class="is hj">引用错误</strong>。但是在提升<strong class="is hj"> <em class="kg"> const和let方面有内存和占位符未定义。这意味着它们也被吊起。</em> </strong></p><p id="63cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以这都是关于JavaScript提升。我试图保持简单，并试图解释引擎盖下发生了什么。JavaScript引擎如何分配内存和提升变量？</p><p id="8ed1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，请给我一个大拇指👍。这将激励我用简单的通俗语言写另一篇文章。</p><p id="7172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由<a class="kp kq ge" href="https://medium.com/u/c675f5ddadb8?source=post_page-----f0809921bbba--------------------------------" rel="noopener" target="_blank"> &lt; miniScript/ &gt; </a>在我的桌子上写着爱❤️，同时用<a class="kp kq ge" href="https://medium.com/u/ef174edd651b?source=post_page-----f0809921bbba--------------------------------" rel="noopener" target="_blank"> Anatta </a>制作电子商务商店。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/52cd531451f030ff09a2e4bee981032f.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*AcgRfQrYRSG-9TE8YlW5VQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">anatta.io</figcaption></figure></div></div>    
</body>
</html>
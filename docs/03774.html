<html>
<head>
<title>What is a Higher Order Component?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是高阶分量？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-a-higher-order-component-204f0cd7bcfb?source=collection_archive---------23-----------------------#2021-06-15">https://medium.com/geekculture/what-is-a-higher-order-component-204f0cd7bcfb?source=collection_archive---------23-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="42c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React的组件逻辑复用系统详解</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/67668fe408624bfc6611f972e5a125c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aYNIzpcpn0Dkl3sNvo6SQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Bruce Wayne is enhanced by his Batsuit like a Higher Order Component enhances a normal component (Source: <a class="ae jt" href="https://chrisnolan.fandom.com/wiki/Bruce_Wayne" rel="noopener ugc nofollow" target="_blank">https://chrisnolan.fandom.com/wiki/Bruce_Wayne</a>)</figcaption></figure><p id="bffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否曾经在代码库中工作过，或者在线观看过教程，并且遇到过类似这样的事情:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="43b6" class="jz ka hi jv b fi kb kc l kd ke">export default withResponsive(Home)</span></pre><p id="2f09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不管你有没有意识到，你已经遇到了一个更高阶的成分。</p><p id="50f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高阶组件(简称HOC)是React的方式，它给多个组件一些重复的功能或行为，而不必在组件中一次又一次地重用相同的代码。这是遵循DRY(不要重复自己)格言和减少代码混乱的一个非常聪明的方法。</p><p id="0140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HOC是一个函数，它接受一个组件作为参数，并返回一个新的增强组件。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="80cf" class="jz ka hi jv b fi kb kc l kd ke">const EnhancedComponent = higherOrderComponent(OriginalComponent)</span></pre><p id="d32e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章的标题图片中，我使用了布鲁斯·韦恩对蝙蝠侠的例子。两者的主要区别在于，蝙蝠侠是布鲁斯的加强版，有着花哨的西装和无数用来打击犯罪的小工具。在这个例子中，布鲁斯是原始组件，蝙蝠侠是增强组件。他的套装(以及小配件和蝙蝠战车)是特制的。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a6e6" class="jz ka hi jv b fi kb kc l kd ke">const Batman = withBatSuit(BruceWayne)</span></pre><p id="1636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个特殊的蝙蝠装可以让布鲁斯接触到他的蝙蝠装物品，并把他变成哥谭市自己的黑暗骑士。</p><p id="e09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么它到底是如何工作的，什么时候使用合适呢？</p><h2 id="0cbb" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">何时使用特设</h2><p id="d84c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">假设您有一个项目，其中有多个不同的计数器对一些行为进行计数。在一个组件中，有一个按钮计算它被点击的次数，然后在另一个组件中有一个计数器跟踪鼠标经过某个div的次数，然后在另一个组件中计算某个页面被访问的次数。所有这些组件将具有相似的行为(在某个特定动作后将计数增加1)，但是由于它们都略有不同，因此很遗憾我们不能制作完全相同的组件。</p><p id="2b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在HOCs之前，您必须将incrementCounter行为写入每个对象，然后使用某种状态变量来跟踪计数。但是这需要大量的复制、粘贴和重复代码。如果我们给每个组件一个incrementCounter函数和一个state.count变量，然后只调整每个组件中触发incrementCounter函数的动作，会怎么样？</p><p id="2d73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是我们能做的！</p><p id="4620" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个用例是根据用户是否从笔记本电脑、手机或平板电脑访问页面来决定如何显示页面。如果你的网站是移动响应的，当你给组件传递一个名为isResponsive的对象时，有一个很常见的模式，它是一个布尔值，表示真或假。您可以使用一个名为withResponsive的HOC来呈现组件，而不是将它作为道具传递给每个需要访问的组件，它将为每个组件提供对isResponsive对象的访问，指示它应该如何向用户显示。</p><p id="ab40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是两种常见的用法，但是您可以在任何需要多个组件共享某种行为的地方使用它。</p><h1 id="ce2f" class="ld ka hi bd kf le lf lg kj lh li lj kn lk ll lm kq ln lo lp kt lq lr ls kw lt bi translated">在您的应用中实现特设</h1><p id="2a27" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">让我们回到我们的第一个例子，在应用程序中为多个组件添加一个计数器。</p><p id="c3ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将计数器行为硬编码到每个应用程序中，您最终会得到如下结果:</p><h2 id="d4ff" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated"><strong class="ak"> App.js </strong></h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d890" class="jz ka hi jv b fi kb kc l kd ke">function App() {</span><span id="51fd" class="jz ka hi jv b fi lu kc l kd ke">return (<br/>  &lt;div className="App"&gt;<br/>    &lt;ClickCounterWithoutHOC/&gt;<br/>    &lt;HoverCounterWithoutHOC/&gt;<br/>  &lt;/div&gt;<br/>  );<br/>}</span><span id="ac1b" class="jz ka hi jv b fi lu kc l kd ke">export default App;</span></pre><h2 id="d990" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated"><strong class="ak">点击没有声音的计数器</strong></h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="63bf" class="jz ka hi jv b fi kb kc l kd ke">import React, {useState} from 'react'</span><span id="6c40" class="jz ka hi jv b fi lu kc l kd ke">const ClickCounterWithoutHOC = () =&gt; {</span><span id="52e0" class="jz ka hi jv b fi lu kc l kd ke">  const [count, setCount] = useState(0)<br/>  const incrementCount = () =&gt; setCount(prevCount =&gt; prevCount + 1)</span><span id="dd2c" class="jz ka hi jv b fi lu kc l kd ke">  return (</span><span id="262f" class="jz ka hi jv b fi lu kc l kd ke">  &lt;button onClick ={incrementCount}&gt;<br/>    Clicked {count} times<br/>  &lt;/button&gt;<br/>  )<br/>}</span><span id="78f2" class="jz ka hi jv b fi lu kc l kd ke"><br/>export default ClickCounterWithoutHOC</span></pre><h2 id="7984" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">无tHOC的悬浮计数器</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6d02" class="jz ka hi jv b fi kb kc l kd ke">import React, {useState} from 'react'</span><span id="652e" class="jz ka hi jv b fi lu kc l kd ke">const HoverCounterWithoutHOC = () =&gt; {</span><span id="cfdd" class="jz ka hi jv b fi lu kc l kd ke">  const [count, setCount] = useState(0)<br/>  const incrementCount = () =&gt; setCount(prevCount =&gt; prevCount + 1)</span><span id="4377" class="jz ka hi jv b fi lu kc l kd ke">return (</span><span id="c14a" class="jz ka hi jv b fi lu kc l kd ke">&lt;button onMouseOver ={incrementCount}&gt;<br/>    Hovered {count} times<br/>  &lt;/button&gt;<br/>  )<br/>}</span><span id="0657" class="jz ka hi jv b fi lu kc l kd ke">export default HoverCounterWithoutHOC</span></pre><p id="d16c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见。这种模式很好，也很有效，但是我们在HoverCounter和ClickCounter之间重复了很多代码。现在想象一个场景，有5个甚至50个其他组件需要这个计数器行为，突然之间你有了一个非常低效的代码库。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/5d8f65da5fc34f9437ff2bd65343e15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Sd33aO4hLNxNGTakhY4_QA.gif"/></div><figcaption class="jp jq et er es jr js bd b be z dx">It works!</figcaption></figure><p id="afb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，让我们创建一个名为withCounter.js的高阶组件，它将为我们添加这个count和incrementCount行为。</p><h2 id="8619" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">带计数器</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d83e" class="jz ka hi jv b fi kb kc l kd ke">import React, {useState} from 'react'</span><span id="9d81" class="jz ka hi jv b fi lu kc l kd ke">const withCounter = OriginalComponent =&gt; {<br/>  const EnhancedComponent = () =&gt; {</span><span id="ed67" class="jz ka hi jv b fi lu kc l kd ke">   const [count, setCount] = useState(0)<br/>   const incrementCount = () =&gt; setCount(prevCount =&gt; prevCount + 1)</span><span id="3c5c" class="jz ka hi jv b fi lu kc l kd ke">    return (</span><span id="7d27" class="jz ka hi jv b fi lu kc l kd ke">      &lt;OriginalComponent<br/>        incrementCount ={incrementCount}<br/>        count={count}<br/>      /&gt;<br/>    )<br/>  }<br/>  return EnhancedComponent<br/>}</span><span id="64e3" class="jz ka hi jv b fi lu kc l kd ke">export default withCounter</span></pre><p id="d500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将看到该组件所做的是将count和incrementCount的声明移动到withCounter.js中，然后它返回一个EnhancedComponent，它只是原始组件，increment count和count作为props提供给它。</p><p id="ec8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你在实践中看到它，这是一个非常简单的概念。让我再重复一遍。</p><p id="53cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">高阶组件只是一个函数，它接受一个组件，并通过将一些行为作为道具传递给它来增强它。然后，高阶组件返回新的、增强的组件供您使用。</strong></p><p id="1f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看这是如何影响ClickCounter和HoverCounter的</p><h2 id="e240" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">点击计数器</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9ee2" class="jz ka hi jv b fi kb kc l kd ke">import React from 'react'<br/>import withCounter from './withCounter'</span><span id="2578" class="jz ka hi jv b fi lu kc l kd ke">const ClickCounter = ({count, incrementCount}) =&gt; {</span><span id="2d56" class="jz ka hi jv b fi lu kc l kd ke">  return (<br/>    &lt;button onClick ={incrementCount}&gt;<br/>      Clicked {count} times<br/>    &lt;/button&gt;<br/>  )<br/>}</span><span id="d49c" class="jz ka hi jv b fi lu kc l kd ke">export default withCounter(ClickCounter)</span></pre><h2 id="0ecc" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">悬浮计数器</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="abd6" class="jz ka hi jv b fi kb kc l kd ke">import React from 'react'<br/>import withCounter from './withCounter'</span><span id="d910" class="jz ka hi jv b fi lu kc l kd ke">const HoverCounter = ({count, incrementCount}) =&gt; {</span><span id="43a7" class="jz ka hi jv b fi lu kc l kd ke">return (<br/>    &lt;button onMouseOver ={incrementCount}&gt;<br/>      Hovered {count} times<br/>    &lt;/button&gt;<br/>  )<br/>}</span><span id="ccac" class="jz ka hi jv b fi lu kc l kd ke">export default withCounter(HoverCounter)</span></pre><p id="b1c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看与没有withCounter HOC的对应物相比，这要干净得多。</p><p id="7456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要做的就是将withCounter导入到每个组件中，并在底部用withCounter包装我们的导出。这将导出我们组件的增强版本。</p><p id="a2b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们所做的就是析构我们的道具，让我们在我们的JSX体中访问count和incrementCount，我们就完成了！</p><p id="d851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保您的App.js文件看起来像这样，以便您可以测试它:</p><h2 id="11c4" class="jz ka hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">App.js</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="41ad" class="jz ka hi jv b fi kb kc l kd ke">function App() {</span><span id="fb2b" class="jz ka hi jv b fi lu kc l kd ke">return (<br/>  &lt;div className="App"&gt;<br/>    &lt;ClickCounter/&gt;<br/>    &lt;HoverCounter/&gt;<br/>  &lt;/div&gt;<br/>  );<br/>}</span><span id="f648" class="jz ka hi jv b fi lu kc l kd ke">export default App;</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/5d8f65da5fc34f9437ff2bd65343e15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Sd33aO4hLNxNGTakhY4_QA.gif"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Works exactly the same as before but much cleaner.</figcaption></figure><p id="336d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你知道了！如果你想访问这篇文章中的任何代码来自己玩，这里是我的GitHub Repo 的链接。</p></div></div>    
</body>
</html>
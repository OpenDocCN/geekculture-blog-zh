<html>
<head>
<title>PyTorch Dataset, DataLoader, Sampler and the collate_fn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch数据集、数据加载器、采样器和collate_fn</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pytorch-datasets-dataloader-samplers-and-the-collat-fn-bbfc7c527cf1?source=collection_archive---------1-----------------------#2021-04-04">https://medium.com/geekculture/pytorch-datasets-dataloader-samplers-and-the-collat-fn-bbfc7c527cf1?source=collection_archive---------1-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="98bf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目的</h1><p id="4623" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有些情况下，我有一些数据集不是严格意义上的数字，也不一定适合张量，所以我一直在试图找到一种方法来管理我的数据加载，而不仅仅是将输入传递给PyTorch Dataloader对象，并让它自动为我对批处理进行采样，我已经这样做了多次，所以我想更深入地研究一下，并在这里分享它，作为我未来参考的记录。</p><h1 id="bfa9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">主要参考</h1><p id="64a9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">PyTorch官方参考:</p><div class="kb kc ez fb kd ke"><a href="https://pytorch.org/docs/stable/data.html" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">torch.utils.data - PyTorch 1.8.1文档</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">构造函数最重要的参数是，它指示要从中加载数据的数据集对象。PyTorch支持…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">pytorch.org</p></div></div></div></a></div><h1 id="402a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">主要类别/功能</h1><h2 id="6b11" class="kn ig hi bd ih ko kp kq il kr ks kt ip jo ku kv it js kw kx ix jw ky kz jb la bi translated">数据集(及其子类)</h2><p id="e8f5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这并不总是必要的，特别是我们的数据集通常是列表、Numpy数组和张量类对象的形式，这是因为数据加载器可以将你的数据包装在某种数据集中。</p><p id="aa5a" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj"> <em class="lg">数据集对象是做什么的？</em>T3】</strong></p><p id="9d9b" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">它被认为是封装数据源的对象以及如何访问数据源中的项目。</p><p id="11d4" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj"> <em class="lg">什么场合会创建自定义数据集？</em> </strong></p><p id="b55a" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">对于我的一些场景，数据来自多个来源，需要组合在一起(比如多个csv文件、数据库)，或者可以在数据加载器迭代之前静态应用数据转换。</p><p id="5a51" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj"> <em class="lg">文档中提到的2类数据集是什么？</em>T11】</strong></p><p id="0478" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">根据文档，有两种类型的数据集，一种是可迭代式的，另一种是地图式的。</p><p id="6627" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">在文档中，它说iterable样式的数据集将实现__iter__()而map样式的数据集将实现__getitem__()和__len__()。</p><p id="cb2f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">人们可以参考实现这两种类型数据集的一些官方示例:</p><div class="kb kc ez fb kd ke"><a href="https://pytorch.org/docs/stable/_modules/torch/utils/data/dataset.html#Dataset" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">torch . utils . data . dataset-py torch 1 . 8 . 1文档</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">docs]class Dataset(Generic[T _ co]):r " " "表示a :class:`Dataset '的抽象类。所有数据集…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">pytorch.org</p></div></div></div></a></div><p id="6237" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">另一方面，文档明确提到对于iterable风格的数据集，数据加载器如何采样数据取决于数据集的__iter__()的实现，并且不支持数据集中的混洗、自定义采样器或自定义批量采样器。</p><p id="d9fb" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">在我深入探讨这种差异之前，有必要了解一下数据加载器是如何对数据进行采样的。</p><p id="61d1" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">但是请注意，从文档中可以看出:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lh"><img src="../Images/b74316842db9bc006eaf4d0d87265dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCAWAN9B34Y5743AJuYkkw.png"/></div></div></figure><h2 id="53d6" class="kn ig hi bd ih ko kp kq il kr ks kt ip jo ku kv it js kw kx ix jw ky kz jb la bi translated">数据加载器</h2><p id="0c90" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是帮助我们从数据源中抽取数据的主要工具，以我有限的理解，这些是关键点:</p><ol class=""><li id="8e7d" class="lt lu hi jf b jg lb jk lc jo lv js lw jw lx ka ly lz ma mb bi translated">管理多进程获取</li><li id="d554" class="lt lu hi jf b jg mc jk md jo me js mf jw mg ka ly lz ma mb bi translated">以小批量方式从数据集中抽取数据</li><li id="499e" class="lt lu hi jf b jg mc jk md jo me js mf jw mg ka ly lz ma mb bi translated">用collate_fn()转换数据</li><li id="3793" class="lt lu hi jf b jg mc jk md jo me js mf jw mg ka ly lz ma mb bi translated">引脚内存(针对GPU内存性能)</li></ol><p id="3880" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj"><em class="lg">data loader如何采样数据？</em>T15】</strong></p><p id="7ff0" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">高层次的想法是，它检查数据集(迭代器/映射)的样式，并通过调用__iter__()(对于迭代器样式的数据集)或采样一组索引并查询__getitem__()(对于映射样式的数据集)进行迭代</p><h2 id="5465" class="kn ig hi bd ih ko kp kq il kr ks kt ip jo ku kv it js kw kx ix jw ky kz jb la bi translated">取样器</h2><p id="e573" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">定义数据加载器如何从数据集中提取样本，它仅用于地图样式的数据集(同样，如果是迭代样式的数据集，则由数据集的__iter__()对数据进行采样，并且不应使用采样器，否则数据加载器会抛出错误)</p><p id="3742" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj"> <em class="lg">采样器实际上做什么？</em>T3】</strong></p><p id="5e73" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">它将为整个数据集生成一系列索引，考虑数据源["a "、" b "、" c "、" d "、" e"]，采样器应生成与数据集长度相同的索引，例如[1，3，2，5，4]。</p><h2 id="696c" class="kn ig hi bd ih ko kp kq il kr ks kt ip jo ku kv it js kw kx ix jw ky kz jb la bi translated">批量取样器</h2><p id="b63f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">BatchSampler的目标是接受一个样本对象(其中有一个__iter__()返回索引序列)，并准备如何生成批量索引。</p><p id="c0c7" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">使用上面的同一个示例，如果采样器的__iter__()返回[1，3，2，5，4]，默认实现将把索引序列分解为batch_size，假设是2，那么它将返回[ [1，3]，[2，5]，[4] ](注意，假设数据加载器的“drop_last”参数为False，则返回最后一项[4])</p><p id="be2c" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">数据加载器将获取该批索引序列，并逐批抽取样本，这将产生["a "、" c"] | ["b "、" e"] | ["d"]</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/2ed13617e3c0f925a7e7253e5b121c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNHDlhNnAFTsQwxJHteqUA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Without discussing on collate_fn, the process is expected to be something like this</figcaption></figure><h2 id="64fb" class="kn ig hi bd ih ko kp kq il kr ks kt ip jo ku kv it js kw kx ix jw ky kz jb la bi translated">collate_fn()</h2><p id="1c3f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是数据转换发生地方，通常不需要为此费心，因为有一个默认的实现，它适用于像list这样的简单数据集。</p><p id="8488" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jf hj">T5】默认整理_ fnT7】</strong></p><p id="08b2" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">默认的collate_fn()做了什么，我们可以读取这个<a class="ae mm" href="https://github.com/pytorch/pytorch/blob/master/torch/utils/data/_utils/collate.py" rel="noopener ugc nofollow" target="_blank">源代码文件</a>的实现。</p><p id="7ca9" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">看几个例子有个感觉，注意collate_fn()的输入是一批样本:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mn"><img src="../Images/2b9ae0378d166ecce1dafd7ec574e3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oANYM_j72o9pmkRhEt-GGQ.png"/></div></div></figure><p id="b2f3" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">对于示例1，它所做的是将输入转换为张量</p><p id="5d7d" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">对于示例2，批处理是2个列表的元组，它返回一个张量列表，每个张量从原始元组的每个列表中获得1个项目</p><p id="4215" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">对于样本3和4，输入看起来像具有多个属性的典型数据形式。考虑情况4，如果每条记录的第3个元素是标签，前2个元素是输入数据属性，则张量的返回列表不能被模型直接使用，其中优选的返回可以是:</p><pre class="li lj lk ll fd mo mp mq mr aw ms bi"><span id="f4cc" class="kn ig hi mp b fi mt mu l mv mw">[tensor([[1,2], [3,4], [5,6], [7,8]]), tensor([3,5,7,9])]</span></pre><p id="43cd" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">站点说明:对于pandas DataFrame，dataloader会通过_MapDatasetFetcher类中的fetch函数将数据传递到一个列表中，因此我们也可以将其视为列表示例。</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mx"><img src="../Images/bbd2ae69029951a5c1539ac0dbacab5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPJVQFuih-sictoTmtBj-g.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">possiblely_batched_index is a list like [1, 3]</figcaption></figure><p id="8071" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">PyTorch文档给出了以下用例:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es my"><img src="../Images/cc7201956e2583b1d5bd569aecc4be69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na4bckS4aH_DSe7qjMhlSA.png"/></div></div></figure><p id="39b5" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">第一个例子是“沿着第一维之外的维度排序”，我的理解是，当你希望批处理数据被不同地分组时，与默认的collate函数相比。</p><pre class="li lj lk ll fd mo mp mq mr aw ms bi"><span id="5c02" class="kn ig hi mp b fi mt mu l mv mw">Preferred: <br/>[tensor([[1,2], [3,4], [5,6], [7,8]]), tensor([3,5,7,9])]</span><span id="fc60" class="kn ig hi mp b fi mz mu l mv mw">v.s.</span><span id="5643" class="kn ig hi mp b fi mz mu l mv mw">Default:<br/>[tensor([1,3,5,7]), tensor([2,4,6,8]), tensor([3,5,7,9])]</span></pre><p id="35a6" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">实现方式如下:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es na"><img src="../Images/f607b8168b4fc805deb6cdd7923f8d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl82I9Zs83iySimzzrxbSQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">the 1st use list and 2nd one use tensor slicing.</figcaption></figure><p id="923f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">我相信这是定义自定义collate_fn()最常见的用例</p><p id="e5de" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">对于填充序列的第二个示例，其中一个用例是NLP的RNN/LSTM模型。对于一批句子，当我们随机抽样时，我们会得到不同长度的一批句子，因为我们正在执行批处理操作，我们需要将较短的序列填充到最长的序列中。一种选择是填充到预定义的最大长度，这应该是变压器模型的情况，但在过去，当使用RNN/LSTM时，减少填充的数量将是首选，因为它节省了模型在无意义的填充令牌上运行的处理时间。</p><p id="7ef0" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">可能还有一个用例我会考虑将代码放入collate_fn中，如下例所示，我将文本句子转换为collate_fn中的Transformer预期的批处理输入。</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nb"><img src="../Images/e2d181aec1bbe9d1493ec09ac1120873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9K78LVGnFHidfjZgEQroOQ.png"/></div></div></figure><p id="42fc" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">这不是唯一的方法，可以将文本数据保存在数据集中，一旦数据加载器返回，就在传递给模型之前处理数据</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nc"><img src="../Images/9eef37ba564b191037fa8e087e0959d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MindEvdv8uCM58M5haKKcg.png"/></div></div></figure><p id="e1ae" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">这是一个选择的问题，但有一个潜在的影响，那就是性能。因为数据加载器通过多个工作线程支持多进程，这意味着collate_fn()中的代码可以自然地享受多工作线程的性能提升。</p><h1 id="3b33" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最后的话</h1><p id="c01e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">写这篇文章是令人满意的，但并不那么愉快，令人满意的部分是更深入地探索整个数据加载管道以及如何在代码的不同部分实现逻辑的思考过程。不那么令人愉快的部分是时间的延长和无法完成这篇文章，因为我一直看到更多的写作和探索。</p><p id="9e47" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">希望这能帮助我未来的自己以及其他一些人</p><p id="9ba7" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">如果内容有错误或者你有更好的建议，请随时告诉我。</p></div></div>    
</body>
</html>
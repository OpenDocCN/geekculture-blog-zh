<html>
<head>
<title>Concurrency in iOS: GCD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的并发性:GCD</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/concurrency-in-ios-gcd-c3a69acd7f31?source=collection_archive---------2-----------------------#2022-09-08">https://medium.com/geekculture/concurrency-in-ios-gcd-c3a69acd7f31?source=collection_archive---------2-----------------------#2022-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ca12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是我第一篇讨论iOS中并发性的文章</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5e3ae08c2c9663a9090572529d542b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qoYjVBhFX-FDW0HL"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@nick_brookenheimer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Messifet</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="a705" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">并发性介绍</h2><p id="25fc" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">并发是iOS开发人员需要了解的最重要的话题之一。我们可以使用并发来创建流畅、可靠且响应迅速的应用程序。当你程序运行良好时，你的用户很少会欣赏你。但当你的应用程序表现不佳时，你的用户会发出抱怨，甚至会对你在App Store上的应用程序评级产生不良影响。所以现在，即使对于初级水平来说，理解并发也是一项必备技能。</p><p id="b81f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从维基百科来看，并发性是<em class="ku">程序、算法或问题的不同部分或单元无序或部分有序执行而不影响最终结果的能力</em>。最简单的定义是计算机同时执行一个或多个任务的能力。</p><p id="a3a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在单核设备中，它使用一种称为时间切片的技术来执行并发。它在一个线程上运行，然后执行上下文切换到另一个线程，并且在某个时候会再次回到前一个线程。这种技术产生了两个线程同时执行的错觉。在多核设备中，它们可以实现所谓的并行性，可以同时执行多个任务。请看这个简单的插图:</p><div class="je jf jg jh fd ab cb"><figure class="kv ji kw kx ky kz la paragraph-image"><img src="../Images/394ea7ca920127d3731a45dd693e80a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*W1ecmKP06bJCfQqt8EFu1w.png"/></figure><figure class="kv ji kw kx ky kz la paragraph-image"><img src="../Images/789b676314db26acc474f32d408730a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*giFPrvPg2vTrPPEZ1CjRJw.png"/></figure></div><p id="9ef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们之间的关键区别是同时处理多个任务的并发性，而并行性是指同时执行多个任务。</p><h2 id="ec58" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">iOS中的并发性</h2><p id="8cc4" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">为了在iOS中实现并发，Apple实际上推荐我们使用两个低级库，它们是GCD和Operation Queue。那些是什么？我们如何挑选最好的库来实现并发？在本文中，我们将首先讨论GCD</p><h2 id="6320" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">中央调度中心</h2><p id="fe5b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">GCD或Grand Central Dispatch是Apple制作的用于管理并发操作的库。它使用队列概念，这意味着第一个到达队列的操作将在其他操作之前被首先执行。</p><p id="c2c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种类型的队列，串行队列和并发队列。串行队列确保队列中的所有任务将被逐一执行，等待当前任务完成，然后它将按连续顺序继续执行下一个任务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/223a5dc8940a544cf21d46d7b8a0e6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*BWgKkQ7bHf7j0IrRwPdrWw.png"/></div></figure><p id="be45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，并发队列将逐个执行所有任务，但不等待当前任务完成，它将继续直接执行下一个任务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/879af7dbb7dac8dbdaa30888f5cb7e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*CdyOnUlssMntXJRhGwa_sQ.png"/></div></figure><p id="3195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用并发队列将使我们的应用程序内部的进程比串行队列快得多。但是请记住，当使用并发队列时，我们不能控制任务完成的顺序。这完全取决于操作系统，有很多因素，如延迟、调度算法等。与并发队列相反，串行队列更容易预测输出，因为它保证等待当前任务完成后再继续执行下一个任务。</p><p id="feff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GCD中，我们可以自己创建一个调度队列对象，也可以使用系统已经提供主队列或全局队列。使用主队列分派的所有任务都将在主线程中执行，是的，它是串行队列，您必须确保您的所有UI活动都在主线程上运行。否则它会崩溃。全局队列是并发队列，由操作系统管理。当使用全局队列时，系统将使用服务质量(QoS)来决定任务的优先级。</p><p id="e92f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将任务分派到全局队列时，我们可以使用四种服务质量:</p><ol class=""><li id="434d" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">使用<code class="du ll lm ln lo b">.userInteractive</code>服务质量的用户交互<br/>任务需要一个需要立即完成的小负载任务，比如动画或UI更新。</li><li id="d6a0" class="lc ld hi ih b ii lp im lq iq lr iu ls iy lt jc lh li lj lk bi translated">用户发起的使用<code class="du ll lm ln lo b">.userInitiated</code>服务质量的<br/>任务是由用户发起的UI异步任务。当您需要等待异步任务的即时结果并需要继续UI交互时，请使用此服务质量类。系统将使其在全局队列中具有高优先级。例如，当您需要对图像应用复杂滤镜时，请使用此服务质量。</li><li id="97d4" class="lc ld hi ih b ii lp im lq iq lr iu ls iy lt jc lh li lj lk bi translated">使用<code class="du ll lm ln lo b">.utility</code>服务质量的实用程序<br/>任务通常需要在UI端提供一个活动指示器，比如联网，或者执行长时间的计算代码。系统将在全局队列中以低优先级执行该任务。</li><li id="434b" class="lc ld hi ih b ii lp im lq iq lr iu ls iy lt jc lh li lj lk bi translated">背景<br/>该服务质量用于执行用户不必知道进度或结果的任务，如执行维护、清理资源等。系统将在全局队列中以后台优先级执行此任务。</li></ol><p id="a824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以同步或异步地分派一个关于队列的函数或动作。同步意味着编译器将在当前任务完成后返回控制权。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="1fa0" class="ju jv hi lo b fi ly lz l ma mb">for i in 0...5 {<br/>    print(i)<br/>}</span><span id="7d70" class="ju jv hi lo b fi mc lz l ma mb">print("looping is finished")<br/>// Output<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>looping is finished</span></pre><p id="a754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是同步过程的例子，其中在循环结束后执行“循环结束”的打印语句。</p><p id="f083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异步进程将使编译器立即返回控制，而不等待当前任务完成。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="5263" class="ju jv hi lo b fi ly lz l ma mb">URLSession.shared.dataTask(url: url) { data, response, error in<br/>    print(response)<br/>}.resume()</span><span id="c7a0" class="ju jv hi lo b fi mc lz l ma mb">print("is fetching")</span></pre><p id="3ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码示例中，print语句“正在获取”将直接执行，而无需等待会话完全从服务器获取数据。</p><p id="e131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">串行队列和并发队列<strong class="ih hj">与同步和异步</strong>完全不同。请记住，当我们处理串行或并发等术语时，它实际上与系统将使用哪个线程来执行任务有关。而sync和async是在队列执行级别上决定我们是否应该等待当前任务完成。</p><h2 id="15fb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">调度队列</h2><p id="ca1a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当在您的应用程序中使用GCD时，您将使用DispatchQueue对象来管理操作。像前面的解释一样，我们可以使用主队列、全局队列，或者我们可以创建一个自定义队列。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="1d20" class="ju jv hi lo b fi ly lz l ma mb">// perform reload data on the main queue, will executed on the main thread</span><span id="ae36" class="ju jv hi lo b fi mc lz l ma mb">DispatchQueue.main.async {<br/>  self.tableView.reloadData()<br/>}</span></pre><p id="60c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您想要使用主队列时，可以直接从DispatchQueue调用静态属性，并且可以同步或异步地调度一个操作。从上面的示例代码中，我们希望在主队列上从表视图中执行重新加载数据，它将被异步调度，这意味着我们不需要等待重新加载数据首先完成。</p><p id="eaae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">永远记住，当你在主队列上工作时，不要同步调度一个动作。如果你这样做，你就阻塞了主线程，很可能会出现死锁的情况，你的应用就会崩溃。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="33ef" class="ju jv hi lo b fi ly lz l ma mb">func <strong class="lo hj">applyFilter</strong>(to inputImage: UIImage) {<br/>  DispatchQueue.global(qos: .userInitiated).async {<br/>    let finalImage = SomeFilter.<strong class="lo hj">apply</strong>(inputImage)<br/>    <br/>    DispatchQueue.main.async {<br/>      self.imageView.image = finalImage<br/>    }<br/>  }<br/>}</span></pre><p id="0d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与主队列类似，您可以从DispatchQueue调用全局静态属性，并同步或异步执行操作。在上面的代码示例中，我们使用<code class="du ll lm ln lo b">.userInitiated</code>服务质量在主线程之外执行过滤操作，通过这种方法，我们的应用程序将运行流畅且响应迅速。当最终图像准备好时，不要忘记通过使用DispatchQueue中的main queue将UI更新分派回主线程。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="4257" class="ju jv hi lo b fi ly lz l ma mb">// serial queue</span><span id="d920" class="ju jv hi lo b fi mc lz l ma mb">let serialQueue = DispatchQueue(label: "com.example-serialQueue")<br/>serialQueue.async {<br/>  print("1")<br/>}</span><span id="ce25" class="ju jv hi lo b fi mc lz l ma mb">serialQueue.async {<br/>  print("2")<br/>}</span><span id="015d" class="ju jv hi lo b fi mc lz l ma mb">// concurrent queue</span><span id="51cd" class="ju jv hi lo b fi mc lz l ma mb">let concurrentQueue = DispatchQueue(label: "com.example-concurrentQueue", attributes: .concurrent)</span><span id="74f5" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async {<br/>  print("3")<br/>}</span><span id="da17" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async {<br/>  print("4")<br/>}</span></pre><p id="3911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以创建自定义队列。默认情况下，您创建的队列将成为串行队列，除非您将<code class="du ll lm ln lo b">.concurrent</code>属性传递给初始化器。</p><h2 id="5ae8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">分派工作项</h2><p id="41c0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">正如您在前面的代码示例中看到的，在使用DispatchQueue时，它总是使用closure来包含我们创建的一些操作。还有另一种向DispatchQueue添加操作的方法，即使用DispatchWorkItem。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="c2db" class="ju jv hi lo b fi ly lz l ma mb"><strong class="lo hj">let</strong> workItem = DispatchWorkItem {<br/>   print("1")<br/>}</span><span id="431b" class="ju jv hi lo b fi mc lz l ma mb">DispatchQueue.main.<strong class="lo hj">async</strong>(execute: workItem)</span></pre><p id="33b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这非常简单，最后您将向DispatchWorkItem传递一个闭包。然后，您将把工作项作为DispatchQueue函数的一个参数。使用DispatchWorkItem的好处是可以取消操作。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="185a" class="ju jv hi lo b fi ly lz l ma mb"><strong class="lo hj">var</strong> searchWorkItem: DispatchWorkItem?</span><span id="1607" class="ju jv hi lo b fi mc lz l ma mb">func search(_ query: String) {<br/>    searchWorkItem?.cancel()<br/>    let workItem = DispatchWorkItem {<br/>        // perform search  <br/>    }<br/>    <br/>    searchWorkItem = workItem    </span><span id="18d5" class="ju jv hi lo b fi mc lz l ma mb">    DispatchQueue.main.asyncAfter(deadline: .now() + 0.35, execute: searchWorkItem)<br/>}</span></pre><h2 id="5eb6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">并发问题</h2><p id="71d5" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">虽然我们可以通过实现并发获得很多好处，但是并发有一个主要的敌人，是的，它是共享的可变状态。请记住，并发是指同时处理多个任务，因此我们无法预测并发操作的确切输出。看一下这个样本代码。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="3ff2" class="ju jv hi lo b fi ly lz l ma mb">var someValue: String = ""<br/>let concurrentQueue = DispatchQueue(label: "com.domain.concurrentQueue", attributes: .concurrent)</span><span id="da91" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async {<br/>    someValue = "A"<br/>}</span><span id="b673" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async {<br/>    someValue = "B"<br/>}</span><span id="7756" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async {<br/>    someValue = "C"<br/>}</span><span id="7c76" class="ju jv hi lo b fi mc lz l ma mb">print(someValue)</span></pre><p id="f34a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个名为<code class="du ll lm ln lo b">someValue</code>的共享可变状态来保存一个字符串值。然后，我们创建并发队列，并异步执行多个写值操作。当您看到输出时，很可能会打印“C”。但是，如果您运行多次，您可能会发现它将打印“B”而不是“C”。因为竞争条件，这里有不一致的数据。在现实世界中，由于竞争条件，很难再现崩溃问题，这是由于并发而发生的最大问题之一。</p><p id="e01b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程安全的定义，至少在我看来，是关于共享的可变状态从多线程中被安全访问的地方。因此，有几种方法可以让一个共享的可变状态变得线程安全。首先，我们可以使用同步操作来防止竞争情况，而不是异步调度操作。请记住，在同步操作中，我们将等待当前操作完成，然后才能进行下一个操作。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="8024" class="ju jv hi lo b fi ly lz l ma mb">var someValue: String = ""<br/>let concurrentQueue = DispatchQueue(label: "com.domain.concurrentQueue", attributes: .concurrent)</span><span id="8e18" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.sync {<br/>    someValue = "A"<br/>}</span><span id="df12" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.sync {<br/>    someValue = "B"<br/>}</span><span id="f6ce" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.sync {<br/>    someValue = "C"<br/>}</span><span id="f822" class="ju jv hi lo b fi mc lz l ma mb">print(someValue) // C</span></pre><p id="3dbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种防止竞争的方法是使用DispatchBarrier。在并发队列上执行时，DispatchBarrier会将一个操作作为屏障块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/a61b04e165f73580cf8f0648662cd8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*jHTjgE7qFMl2SAJ0nR7l_w.png"/></div></figure><p id="0156" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们将任务2分派到带有分派障碍标志的并发队列，它将阻塞另一个任务，直到任务2完成，然后继续执行下一个任务。你可以想象一下，如果使用dispatch barrier，会不会使并发队列有点类似于串行队列。</p><pre class="je jf jg jh fd lu lo lv lw aw lx bi"><span id="999e" class="ju jv hi lo b fi ly lz l ma mb">var someValue: String = ""<br/>let concurrentQueue = DispatchQueue(label: "com.domain.concurrentQueue", attributes: .concurrent)</span><span id="4241" class="ju jv hi lo b fi mc lz l ma mb">concurrentQueue.async(flags: .barrier) {<br/>    someValue = "A"<br/>    print("first write operation: \(someValue)")<br/>}</span></pre><h2 id="2bbb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">从这里去哪里</h2><p id="512c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">祝贺您关注这篇文章。我希望现在你已经掌握了基本的并发技能，特别是iOS中的GCD。当您需要对一些任务进行分组时，您可以探索更多关于DispatchGroup等未涉及的主题，或者当您需要限制执行线程时，您可能希望了解DispatchSemaphore。并发性是一个很大的话题，你需要一段时间来思考所有这些问题。谢谢您，下一篇文章再见——可能会谈到OperationQueue:】。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Cheat Sheet for JS methods to work with DOM, part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS方法使用DOM的备忘单，第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cheat-sheet-for-js-methods-to-work-with-dom-part-2-c0846167965c?source=collection_archive---------18-----------------------#2021-11-20">https://medium.com/geekculture/cheat-sheet-for-js-methods-to-work-with-dom-part-2-c0846167965c?source=collection_archive---------18-----------------------#2021-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/dd1c5c4d365b7779e4abb8040f5e8e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*cCRInQqN8keU0-4Z0hXwfw.png"/></div></figure><div class=""/><h1 id="4257" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Mixin ParentNode</code></h1><p id="d587" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这种混合旨在处理父元素(祖先)，即包含一个或多个后代(子元素)的元素。</p><ul class=""><li id="3594" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">children</code> —元素的后代</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="3016" class="lf in hp jn b fi lg lh l li lj">const { children } = list // list.children<br/>log(children)<br/>/*<br/>HTMLCollection(3)<br/>  0: li#item1.item<br/>  1: li#item2.item<br/>  2: li#item3.item<br/>  length: 3<br/>*/</span></pre><p id="af48" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">这样的结构称为HTML集合，是一个类似手臂的对象(伪数组)。还有另一种类似的结构——<code class="du jk jl jm jn b">list of Nodes<a class="ae ln" href="https://dom.spec.whatwg.org/#interface-nodelist" rel="noopener ugc nofollow" target="_blank">(NodeList</a></code><a class="ae ln" href="https://dom.spec.whatwg.org/#interface-nodelist" rel="noopener ugc nofollow" target="_blank">)</a>。</p><p id="6b70" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">类似数组的对象具有带有后代数量的<code class="du jk jl jm jn b">length</code>属性、<code class="du jk jl jm jn b">forEach() </code>方法、(<code class="du jk jl jm jn b">NodeList</code>)，这允许您移动节点(进行迭代)。这种对象允许通过索引、名称(<code class="du jk jl jm jn b">HTMLCollection</code>)等获取元素。但是，它们没有真正的数组方法，如<code class="du jk jl jm jn b">map()</code>、<code class="du jk jl jm jn b">filter()</code>、<code class="du jk jl jm jn b">reduce()</code>等。，这使得和他们一起工作不是很舒服。因此，建议使用<code class="du jk jl jm jn b">Array.from()</code>或扩展运算符方法将数组对象转换为数组:</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="19ee" class="lf in hp jn b fi lg lh l li lj">const children = Array.from(list.children)<br/>// or<br/>const children = [...list.children]<br/>log(children) <br/>// [li#item1.item, li#item2.item, li#item3.item] - <!-- -->Normal array</span></pre><ul class=""><li id="36ad" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">firstElementChild</code> —第一个后代—元素</li><li id="b9c4" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">lastElementChild</code> —最后一个后代—元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="c9a1" class="lf in hp jn b fi lg lh l li lj">log(list.firstElementChild) // li#item1.item<br/>log(list.lastElementChild) // li#item2.item</span></pre><p id="86fd" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">对于进一步的操作，我们将需要定期创建新元素，因此我们将创建另一个实用程序:</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="05b2" class="lf in hp jn b fi lg lh l li lj">const createEl = (id, text, tag = 'li', _class = 'item') =&gt; {<br/>  const el = document.createElement(tag)<br/>  el.id = id<br/>  el.className = _class<br/>  el.textContent = text<br/>  return el<br/>}</span></pre><p id="a786" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">我们的实用程序接受4个参数:标识符、文本、标签名和CSS类。2个参数(标记和类)有默认值。该函数返回一个准备好进行操作的元素。随后，我们实现了这个实用程序的一个更通用的版本。</p><ul class=""><li id="98d2" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">prepend(newNode)</code> —将项目添加到列表顶部</li><li id="a7bf" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">append(newNode)</code> —将元素添加到列表的末尾</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="eafb" class="lf in hp jn b fi lg lh l li lj">// <!-- -->Create a new element<br/>const newItem = createEl('item0', 0)<br/>// <!-- -->and add it to the top of the list<br/>list.prepend(newItem)</span><span id="ad7d" class="lf in hp jn b fi lt lh l li lj">// <!-- -->Create another item<br/>const newItem2 = createEl('item4', 4)<br/>// <!-- -->and add it to the end of the list<br/>list.append(newItem2)</span><span id="26bd" class="lf in hp jn b fi lt lh l li lj">log(children)<br/>/*<br/>HTMLCollection(5)<br/>  0: li#item0.item<br/>  1: li#item1.item<br/>  2: li#item2.item<br/>  3: li#item3.item<br/>  4: li#item4.item<br/>*/</span></pre><p id="aa00" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">其中一个有趣的特性<code class="du jk jl jm jn b">HTMLCollection</code>是它是“活的”，即通过引用返回的元素及其编号会自动更新。但是，此功能不能用于例如自动添加事件处理程序。</p><ul class=""><li id="0d88" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">replaceChildren(nodes)</code> —用新元素替换后代</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="eff1" class="lf in hp jn b fi lg lh l li lj">const newItems = [newItem, newItem2]<br/>// <!-- -->replace descendants with new elements<br/>list.replaceChildren(...newItems) // list.replaceChildren(newItem, newItem2)</span><span id="023a" class="lf in hp jn b fi lt lh l li lj">log(children) // 2</span></pre><p id="f56b" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">获取元素引用的最通用的方法是<code class="du jk jl jm jn b">querySelector(selector)</code>和<code class="du jk jl jm jn b">querySelectorAll(selector)</code>方法。此外，与<code class="du jk jl jm jn b">getElementById()</code>不同，它们可以在任何父元素上被调用，而不仅仅是在<code class="du jk jl jm jn b">document</code>上。任何有效的CSS选择器都作为参数传递给这些方法。(<code class="du jk jl jm jn b">id</code>、<code class="du jk jl jm jn b">class</code>、<code class="du jk jl jm jn b">tag</code>等):</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="4acb" class="lf in hp jn b fi lg lh l li lj">// get an element `li` with `id === item0`<br/>const itemWithId0 = list.querySelector('#item0')<br/>log(itemWithId0) // li#item0.item</span><span id="dfc0" class="lf in hp jn b fi lt lh l li lj">// get all elements `li` with `class === item`<br/>const allItems = list.querySelectorAll('.item')<br/>log(allItems) // array-like object<br/>/*<br/>NodeList(2)<br/>  0: li#item0.item<br/>  1: li#item4.item<br/>  length: 2<br/>*/</span></pre><p id="9166" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">创建接收物料的通用实用程序:</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="b9a9" class="lf in hp jn b fi lg lh l li lj">const getEl = (selector, parent = document, single = true) =&gt; single ? parent.querySelector(selector) : [...parent.querySelectorAll(selector)]</span></pre><p id="af4b" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">我们的实用程序有3个参数:CSS选择器、父元素和元素数量的指示器(一个或全部)。2个参数(祖先和指示器)有默认值。该函数返回与选择器一致的一个或所有项目(作为常规数组)，具体取决于指示器值:</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="d4d7" class="lf in hp jn b fi lg lh l li lj">const itemWithId0 = getEl('#item0', list)<br/>log(itemWithId0) // li#item0.item</span><span id="6adb" class="lf in hp jn b fi lt lh l li lj">const allItems = getEl('.item', list, false)<br/>log(allItems) // [li#item0.item, li#item4.item]</span></pre><h1 id="cd8f" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Mixin NonDocumentTypeChildNode</code></h1><p id="1401" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这种混合旨在处理不是文档的子文档，即除<code class="du jk jl jm jn b">document</code>之外的所有节点。</p><ul class=""><li id="86f5" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">previousElementSibling</code> —前一个元素</li><li id="df19" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">nextElementSibling</code>—下一个元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="cd67" class="lf in hp jn b fi lg lh l li lj">log(itemWithId0.previousElementSibling) // null<br/>log(itemWithId0.nextElementSibling) // #item4</span></pre><h1 id="b89a" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Mixin ChildNode</code></h1><p id="3823" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这种混合旨在处理附属元素，即其他元素的后代元素。</p><ul class=""><li id="ff1b" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">before(newNode)</code> —在当前元素之前插入新元素</li><li id="6b2c" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">after(newNode)</code> —在当前元素后插入新元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="c22b" class="lf in hp jn b fi lg lh l li lj">// get `li` with `id === item4`<br/>const itemWithId4 = getEl('#item4', list)<br/>// create new element<br/>const newItem3 = createEl('item3', 3)<br/>// and insert it before `itemWithId4`<br/>itemWithId4.before(newItem3)</span><span id="0713" class="lf in hp jn b fi lt lh l li lj">// create another one<br/>const newItem4 = createEl('item2', 2)<br/>// and insert it after `itemWithId0`<br/>itemWithId0.after(newItem4)</span></pre><ul class=""><li id="24a5" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">replaceWith(newNode)</code>—替换新的当前元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="9d11" class="lf in hp jn b fi lg lh l li lj">// создаем новый элемент<br/>const newItem5 = createEl('item1', 1)<br/>// и заменяем им `itemWithId0`<br/>itemWithId0.replaceWith(newItem5)</span></pre><ul class=""><li id="504e" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">remove()</code> —删除当前元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="21b3" class="lf in hp jn b fi lg lh l li lj">itemWithId4.remove()</span></pre><h1 id="a10c" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Node Interface</code></h1><p id="8ac6" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">该接口设计用于处理节点。</p><ul class=""><li id="96e4" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">nodeType</code> —节点类型</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="28a3" class="lf in hp jn b fi lg lh l li lj">log(list.nodeType) // 1</span><span id="eeb2" class="lf in hp jn b fi lt lh l li lj">// <!-- -->other options<br/>/*<br/> 1 -&gt; ELEMENT_NODE (element)<br/> 3 -&gt; TEXT_NODE (text)<br/> 8 -&gt; COMMENT_NODE (comment)<br/> 9 -&gt; DOCUMENT_NODE (document)<br/> 10 -&gt; DOCUMENT_TYPE_NODE (doctype)<br/> 11 -&gt; DOCUMENT_FRAGMENT_NODE (fragment) etc.<br/>*/</span></pre><ul class=""><li id="a6c8" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">nodeName</code> —节点名称</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="9998" class="lf in hp jn b fi lg lh l li lj">log(list.nodeName) // UL</span><span id="26ad" class="lf in hp jn b fi lt lh l li lj">// <!-- -->other options<br/>/*<br/>  - <!-- -->qualified name of the HTML element with capital (capital) letters<br/>  - <!-- -->qualified attribute name<br/>  - #text<br/>  - #comment<br/>  - #document<br/>  - doctype<br/>  - #document-fragment<br/>*/</span></pre><ul class=""><li id="160d" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">baseURI</code> —主要路径</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="8875" class="lf in hp jn b fi lg lh l li lj">log(list.baseURI) // .../dom/index.html</span></pre><ul class=""><li id="aa3d" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">parentNode</code> —父节点</li><li id="387a" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">parentElement</code>—父元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="db22" class="lf in hp jn b fi lg lh l li lj">const itemWithId1 = getEl('#item1', list)</span><span id="e526" class="lf in hp jn b fi lt lh l li lj">log(itemWithId1.parentNode) // #list<br/>log(itemWithId1.parentElement) // #list</span></pre><ul class=""><li id="4cd2" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">hasChildNodes()</code> —如果元素至少有一个后代，则返回<code class="du jk jl jm jn b">true</code></li><li id="61b6" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">childNodes</code> —子节点</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="81be" class="lf in hp jn b fi lg lh l li lj">log(list.hasChildNodes()) // true<br/>log(list.childNodes)<br/>/*<br/>NodeList(3)<br/>  0: li#item1.item<br/>  1: li#item2.item<br/>  2: li#item3.item<br/>*/</span></pre><ul class=""><li id="9cde" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">firstChild</code> —第一个节点-子节点</li><li id="1a43" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">lastChild</code>—最后一个子节点</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="e5ec" class="lf in hp jn b fi lg lh l li lj">log(list.firstChild) // #item1<br/>log(list.lastChild) // #item3</span></pre><ul class=""><li id="ad36" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">nextSibling</code> —下一个节点</li><li id="5761" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">previousSibling</code> —上一个节点</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="a7b1" class="lf in hp jn b fi lg lh l li lj">log(itemWithId1.nextSibling) // #item2<br/>log(itemWithId1.previousSibling) // null</span></pre><ul class=""><li id="e90c" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">textContent</code> —提取/记录文本的获取器/设置器</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="108f" class="lf in hp jn b fi lg lh l li lj">// get text<br/>log(itemWithId1.textContent) // 1<br/>// edit text<br/>itemWithId1.textContent = 'item1'<br/>log(itemWithId1.textContent) // item1</span><span id="ae9d" class="lf in hp jn b fi lt lh l li lj">// get text content from all children<br/>log(list.textContent) // item123</span></pre><p id="1481" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">为了提取/写入文本，还有另一个(过时的)getter / setter— <code class="du jk jl jm jn b">innerText</code>。</p><ul class=""><li id="5ba0" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">cloneNode(deep)</code> —复制节点。接受确定复制性质的逻辑值:浅表-仅复制节点本身，复制装配本身及其所有后代</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="b014" class="lf in hp jn b fi lg lh l li lj">// <!-- -->create a new list by copying the existing<br/>const newList = list.cloneNode(false)<br/>// <!-- -->remove the `ID` in the avoidance of collisions<br/>newList.removeAttribute('id')<br/>// <!-- -->change its text content<br/>newList.textContent = 'new list'<br/>// <!-- -->and insert it after an existing list<br/>list.after(newList)</span><span id="ae3b" class="lf in hp jn b fi lt lh l li lj">// <!-- -->create another list<br/>const newList2 = newList.cloneNode(true)<br/>newList.after(newList2)</span></pre><ul class=""><li id="08ce" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">isEqualNode(node)</code> —比较节点</li><li id="3b16" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">isSameNode(node)</code> —确定节点的身份</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="02b1" class="lf in hp jn b fi lg lh l li lj">log(newList.isEqualNode(newList2)) // true<br/>log(newList.isSameNode(newList2)) // false</span></pre><ul class=""><li id="adf5" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">contains(node)</code> —如果元素包含指定的节点，则返回<code class="du jk jl jm jn b">true</code></li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="fdde" class="lf in hp jn b fi lg lh l li lj">log(list.contains(itemWithId1)) // true</span></pre><ul class=""><li id="d70d" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">insertBefore(newNode, existingNode)</code> —在现有节点(<code class="du jk jl jm jn b">existingNode</code>)之前添加新节点(<code class="du jk jl jm jn b">newNode</code>)</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="5335" class="lf in hp jn b fi lg lh l li lj">// create new element<br/>const itemWithIdA = createEl('#item_a', 'a')<br/>// and insert it before `itemWithId1`<br/>list.insertBefore(itemWithIdA, itemWithId1)</span></pre><ul class=""><li id="f4e3" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">appendChild(node)</code> —将节点添加到列表的末尾</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="3ce2" class="lf in hp jn b fi lg lh l li lj">// создаем новый элемент<br/>const itemWithIdC = createEl('#item_c', 'c')<br/>// и добавляем его в конец списка<br/>list.appendChild(itemWithIdC)</span></pre><ul class=""><li id="0596" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">replaceChild(newNode, existingNode)</code> —用新节点(<code class="du jk jl jm jn b">newNode</code>)替换现有节点(<code class="du jk jl jm jn b">existingNode</code>):</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="df2e" class="lf in hp jn b fi lg lh l li lj">// создаем новый элемент<br/>const itemWithIdB = createEl('item_b', 'b')<br/>// и заменяем им `itemWithId1`<br/>list.replaceChild(itemWithIdB, itemWithId1)</span></pre><ul class=""><li id="4206" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">removeChild(node)</code> —删除指定的子节点</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="c4b9" class="lf in hp jn b fi lg lh l li lj">// получаем `li` с `id === item2`<br/>const itemWithId2 = getEl('#item2', list)<br/>// и удаляем его<br/>list.removeChild(itemWithId2)</span></pre><h1 id="3569" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Document interface</code></h1><p id="77ef" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">该接口用于处理<code class="du jk jl jm jn b">Document </code>对象。</p><ul class=""><li id="8387" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">URL</code>和<code class="du jk jl jm jn b">documentURI</code> —文件地址</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="e257" class="lf in hp jn b fi lg lh l li lj">log(document.URL) // .../dom/index.html<br/>log(document.documentURI) // ^</span></pre><ul class=""><li id="3674" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">documentElement</code>:</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="36d9" class="lf in hp jn b fi lg lh l li lj">log(document.documentElement) // html</span></pre><ul class=""><li id="b63b" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">getElementsByTagName(tag)</code> —返回带有指定标签的所有元素</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="2063" class="lf in hp jn b fi lg lh l li lj">const itemsByTagName = document.getElementsByTagName('li')<br/>log(itemsByTagName)<br/>/*<br/>HTMLCollection(4)<br/>  0: li##item_a.item<br/>  1: li#item_b.item<br/>  2: li#item3.item<br/>  3: li##item_c.item<br/>*/</span></pre><ul class=""><li id="7061" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">getElementsByClassName(className)</code> —返回具有指定CSS类的所有项目</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="a6f1" class="lf in hp jn b fi lg lh l li lj">const itemsByClassName = list.getElementsByClassName('item')<br/>log(itemsByClassName) // ^</span></pre><ul class=""><li id="a44c" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">createDocumentFragment()</code> —返回文档的一个片段:</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="7e6e" class="lf in hp jn b fi lg lh l li lj">// create a fragment<br/>const fragment = document.createDocumentFragment()<br/>// create a new element<br/>const itemWithIdD = createEl('item_d', 'd')<br/>// add element to fragment<br/>fragment.append(itemWithIdD)<br/>// add fragment to list<br/>list.append(fragment)</span></pre><p id="2b80" class="pw-post-body-paragraph jo jp hp jq b jr ko jt ju jv kp jx jy jz lk kb kc kd ll kf kg kh lm kj kk kl hb bi translated">片段允许你避免创建不必要的元素。它们经常在处理标记时使用，通过使用<code class="du jk jl jm jn b">template</code>标签对用户隐藏(方法<code class="du jk jl jm jn b">cloneNode()</code>返回<code class="du jk jl jm jn b">DocumentFragment</code>)。</p><ul class=""><li id="e553" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">createTextNode(data)</code>—创建文本</li><li id="9236" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">createComment(data)</code> —创建评论</li><li id="486a" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">importNode(existingNode, deep)</code> —基于现有节点创建新节点</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="de3f" class="lf in hp jn b fi lg lh l li lj">// <!-- -->Creates a new list based on existing<br/>const newList3 = document.importNode(list, true)<br/>// insert it before the existing list<br/>list.before(newList3)<br/>// <!-- -->and remove to avoid conflicts<br/>newList3.remove()</span></pre><ul class=""><li id="e384" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">createAttribute(attr)</code> —创建指定的属性</li></ul><h1 id="6051" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">NodeIterator</code>和<code class="du jk jl jm jn b">TreeWalker interfaces</code></h1><p id="db4e" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><code class="du jk jl jm jn b"><a class="ae ln" href="https://dom.spec.whatwg.org/#interface-nodeiterator" rel="noopener ugc nofollow" target="_blank">NodeIterator</a></code>和<code class="du jk jl jm jn b"><a class="ae ln" href="https://dom.spec.whatwg.org/#interface-treewalker" rel="noopener ugc nofollow" target="_blank">TreeWalker</a></code>接口被设计为绕过(遍历)节点树。我没有碰到它们实际使用的例子，所以我将限制这一对例子:</p><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="579d" class="lf in hp jn b fi lg lh l li lj">// createNodeIterator(root, referenceNode, pointerBeforeReferenceNode, whatToShow, filter)<br/>const iterator = document.createNodeIterator(list)<br/>log(iterator)<br/>log(iterator.nextNode()) // #list<br/>log(iterator.nextNode()) // #item_a<br/>log(iterator.previousNode()) // #item_a<br/>log(iterator.previousNode()) // #list<br/>log(iterator.previousNode()) // null</span><span id="8461" class="lf in hp jn b fi lt lh l li lj">// createTreeWalker(root, whatToShow, filter)<br/>// apply filters - https://dom.spec.whatwg.org/#interface-nodefilter<br/>const walker = document.createTreeWalker(list, '0x1', { acceptNode: () =&gt; 1 })<br/>log(walker)<br/>log(walker.parentNode()) // null<br/>log(walker.firstChild()) // #item_a<br/>log(walker.lastChild()) // null<br/>log(walker.previousSibling()) // null<br/>log(walker.nextSibling()) // #item_b<br/>log(walker.nextNode()) // #item3<br/>log(walker.previousNode()) // #item_b</span></pre><h1 id="e7e9" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><code class="du jk jl jm jn b">Element interface</code></h1><p id="527e" class="pw-post-body-paragraph jo jp hp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">该接口用于处理元素。</p><ul class=""><li id="2c87" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">localName</code>和<code class="du jk jl jm jn b">tagName</code>——一个标签名</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="4ee4" class="lf in hp jn b fi lg lh l li lj">log(list.localName) // ul<br/>log(list.tagName) // UL</span></pre><ul class=""><li id="230e" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">id</code> —标识符的获取器/设置器</li><li id="f2ba" class="km kn hp jq b jr lo jv lp jz lq kd lr kh ls kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">className</code>—CSS类的getter / setter</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="8667" class="lf in hp jn b fi lg lh l li lj">log(list.id) // list<br/>list.id = 'LIST'<br/>log(LIST.className) // list</span></pre><ul class=""><li id="595f" class="km kn hp jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du jk jl jm jn b">classList</code> —元素的所有CSS类(<code class="du jk jl jm jn b">DOMTokenList </code>对象)</li></ul><pre class="kx ky kz la fd lb jn lc ld aw le bi"><span id="785b" class="lf in hp jn b fi lg lh l li lj">const button = createEl('button', 'Click me', 'my_button', 'btn btn-primary')<br/>log(button.classList)<br/>/*<br/>DOMTokenList(2)<br/>  0: "btn"<br/>  1: "btn-primary"<br/>  length: 2<br/>  value: "btn btn-primary"<br/>*/</span></pre></div></div>    
</body>
</html>
<html>
<head>
<title>A Beginner’s Guide to Git and Git Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git和Git内部的初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-beginners-guide-to-git-and-git-internals-1e7dcd89d65e?source=collection_archive---------11-----------------------#2021-04-04">https://medium.com/geekculture/a-beginners-guide-to-git-and-git-internals-1e7dcd89d65e?source=collection_archive---------11-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我和Git纠结了很多！当我推进我的代码时，10次中有8次项目会中断。然后，我会花一整晚的时间试图让我的代码再次工作，但无济于事。早上，在半睡半醒中，我终于向我的朋友寻求帮助，他是一个饭桶神。令我惊讶的是，他会在几分钟内搞定这个项目。他总是说Git很简单，只要你理解了它的内部原理。一个周末，我对与Git的斗争感到沮丧，于是我决定花整个周末来研究Git的内部机制。从那以后，Git看起来从未如此简单而美丽。现在，Git中的每一个问题，在早期都是一场解决起来的噩梦，看起来是如此的明显和琐碎。</p><p id="3b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坦率地说，对于初学者来说，Git不是一个容易使用的工具。虽然它有一个漂亮的内部设计，但对于一个新手来说，即使是理解Git的基本功能也是一个难题。通过这篇文章，我想打开Git黑盒子，深入Git内部。在这一系列文章中，我们将了解Git的内部结构。<em class="jd">这是4篇系列文章中的第一篇。(关于Git分支的第二篇文章已经发表。你可以在这里找到</em><a class="ae je" rel="noopener" href="/geekculture/git-branching-made-easy-1cc894b9fd03"><em class="jd"/></a><em class="jd">)</em></p><p id="0367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是为完全的初学者写的。然而，对于那些对Git有所了解但对自己的Git技能没有信心的人，或者那些想要揭开Git底层内部秘密的人来说，它也是有用的。唯一的先决条件是熟悉cd、ls、cat等命令。</p><p id="d28f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始介绍Git之前，让我们先了解一下，什么是版本控制系统？</p><h2 id="0400" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">什么是版本控制系统？</h2><p id="278a" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">简单地说，版本控制系统(VCS)是一个帮助记录和管理项目变更的工具。</p><p id="d7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，让我们考虑一个例子。</p><p id="afbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一个没有版本控制系统的世界。假设你正在做一个项目。您正在将项目文件保存在google drive(或您的本地计算机)中。你在第一天开始你的项目，到第七天你已经完成了项目的一部分(比如说50%)。两天后(第9天)，你意识到项目现在变得更复杂了，你想回到第7天的项目状态。可悲！您无法恢复到项目的早期版本，因为您所做的更改已经覆盖了您计算机上的所有项目文件。唯一的方法可能是，您在某个地方保存了项目的副本(如第7天)。但是每次完成项目的一部分时保存项目的副本是很麻烦的。</p><p id="a5fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这样的问题，我们使用版本控制系统。版本控制系统会不时地在本地计算机上保存项目存储库(项目文件夹)的快照。每当您完成项目的一部分时，您向您的VCS发出一个命令，说— <em class="jd">拍摄我的当前项目存储库的快照(您的当前项目存储库或项目目录中的所有文件和文件夹的快照)并将其保存在您的历史记录中。</em>现在，如果您想要返回到项目的先前状态(您之前保存的快照)，您可以通过向您的VCS发出另一个命令来轻松地做到这一点，该命令说— <em class="jd">将我的项目的状态恢复到这个特定的快照</em>。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/d63c6b510bc50d3483caff54a54c7c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*LtsSZ8Mil8ES5zsxtmJJsg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">You can revert to any snapshot in your Project’s VCS’s history</figcaption></figure><p id="1225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个名字叫做版本控制，因为它保存了项目的<em class="jd">版本</em>(快照)。随着项目规模和复杂性的增加，版本控制系统的重要性也在增加。正如我们将看到的，VCS还提供了许多其他功能。他们帮助你以更好的方式管理你的项目。Git是一个版本控制系统。它是免费和开源的，也是最受欢迎的VCS之一。其他一些版本控制系统有Mercurial、SVN等。</p><h2 id="99a4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">Git —简介</h2><p id="e0a0" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">所以现在我们明白Git是什么了。但是在开始Git的数据模型之前，我想解决完全初学者的另一个困惑点。除了Git和版本控制系统，很多人肯定也听说过GitHub。所以，一个自然的问题是GitHub是什么？和Git有什么区别？(没听说过GitHub的，可以选择忽略文章的这一部分)你可以把GitHub看成是项目的Google Drive。它将你的项目存储在云上。不仅是您的项目，还有Git一直保存的所有项目快照。如果您想在不同的机器上访问您的项目，或者您不小心丢失了计算机上的所有数据，这将很有帮助。而且，GitHub不仅仅是作为你的项目的备份，它的USP还使项目的协作变得更加容易。一些刚刚开始学习Git的初学者有一个误解，认为GitHub和Git是混合在一起的，认为使用Git也需要使用GitHub。这不是真的。如果你不想把你的项目保存在云上，并且你的项目不需要和其他人协作，那么GitHub是不需要的。Git将在您的本地计算机上管理您的项目，而不需要GitHub。还要注意，除了GitHub，还有其他代码托管平台。<br/>现在让我们从Git的数据模型开始。</p><h2 id="4886" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">Git —数据模型</h2><p id="d8a8" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">所以，是时候开始Git的内部设计了。在内部，git将快照的内容存储在不同类型的对象中。让我们仔细看看这些物体。</p><p id="59f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提交对象<br/> </strong>我们谈到了我们项目存储库的快照。提交对象表示我们项目的快照。它帮助我们查看我们的项目存储库的特定快照(存在于我们的VCS保存的快照历史中)。提交对象包含指向其父提交对象(即之前保存的快照)的指针(引用)。这形成了提交对象的链表(链表是对象的列表，一个对象通过指针链接到下一个对象。下一个对象又指向另一个对象，依此类推)。唯一的例外是没有父级的初始提交。<br/> <em class="jd">注意</em>:在关于分支的文章中，我们会发现一个提交对象也可以有两个或更多的父对象，一个父提交对象也可以有两个或更多的子提交对象。<br/>提交对象还包含其他有用的信息，如提交的作者、提交消息等。我们将在本文后面讨论这些内容。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/c9fa43c67b994fbb13067d9d5b1b3ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4wWaizcN3d5NiMzh8jxTQ.jpeg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Commit Object-3 is the latest commit while Commit object-1 is the oldest commit ( which does not have a parent)</figcaption></figure><p id="b824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么这个提交对象如何帮助我们查看项目的快照呢？<br/>  Ans —它包含一个对树对象的引用。</p><p id="721b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">树对象<br/>T14】树对象用来表示目录(文件夹)。如果项目包含在名为— <em class="jd"> MyProject </em>的目录中，则提交对象包含对代表目录<em class="jd"> MyProject </em>的树对象的引用。我们将这个项目目录称为根目录。我们的根项目目录也存储为一个树对象。提交对象包含对此树对象的引用。树对象包含关于它所代表的目录的信息，即目录中存在的所有文件和子目录。子目录也将表示为树对象。所以一个树对象可以包含对另一个树对象的引用。</strong></p><p id="5be5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树对象指向的文件在git中称为blob对象。</p><p id="43bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">斑点物体</strong></p><p id="4b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">blob对象代表git中的一个文件。如果文件没有从提交-1变为提交-2，那么blob对象也不会改变。<br/>一个Blob对象包含文件的内容。</p><p id="2094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们仔细看看这些物体。我们会弄脏我们的手，并开始执行一些命令。首先，在您的系统上安装git。安装步骤可参考此<a class="ae je" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" rel="noopener ugc nofollow" target="_blank">文章</a>。我建议您在系统中执行相同的命令。</p><p id="b75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:为了避免混淆，<code class="du kw kx ky kz b">&gt;&gt;&gt;</code>是我的命令提示符。😅</p><p id="dc72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建一个空目录<code class="du kw kx ky kz b">gitDemo</code>，这将是我们的根项目目录。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="8aa6" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; mkdir gitDemo<br/>&gt;&gt;&gt; cd gitDemo</span></pre><p id="b956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将这个存储库初始化为一个<em class="jd"> git存储库。</em> <code class="du kw kx ky kz b">git init</code>将存储库初始化为一个<em class="jd"> git存储库</em>，并在我们的根项目目录中创建一个<code class="du kw kx ky kz b">.git</code>文件夹。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="6426" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git init<br/>Initialized empty Git repository in /home/prakarsh/MediumGitArticle1/gitDemo/.git/</span></pre><p id="dd8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列出我们的<em class="jd"> gitDemo </em>目录的内容，我们会注意到一个<em class="jd">。git </em>目录。<em class="jd">。git </em>目录负责存储使用git管理我们项目的所有重要信息。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="1fe2" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; ls -a<br/>.  ..  .git</span></pre><p id="e2b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看<em class="jd">的结构。使用<code class="du kw kx ky kz b">tree</code>命令获取</em>目录。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="1b41" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; tree .git<br/>.git<br/>├── branches<br/>├── config<br/>├── description<br/>├── HEAD<br/>├── hooks<br/>│   ├── applypatch-msg.sample<br/>│   ├── commit-msg.sample<br/>│   ├── fsmonitor-watchman.sample<br/>│   ├── post-update.sample<br/>│   ├── pre-applypatch.sample<br/>│   ├── pre-commit.sample<br/>│   ├── prepare-commit-msg.sample<br/>│   ├── pre-push.sample<br/>│   ├── pre-rebase.sample<br/>│   ├── pre-receive.sample<br/>│   └── update.sample<br/>├── info<br/>│   └── exclude<br/>├── objects<br/>│   ├── info<br/>│   └── pack<br/>└── refs<br/>    ├── heads<br/>    └── tags</span></pre><p id="5899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到有许多子目录，如branches、config、HEAD、info、refs、objects等。在本文中，我们将关注于<em class="jd">对象</em>目录。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="010d" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; tree .git/objects<br/>.git/objects<br/>├── info<br/>└── pack</span></pre><p id="c226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到在objects目录中只有两项。这是因为到目前为止，我们还没有创建一个对象。首先，让我们创建一些对象。我们将在我们的<em class="jd"> gitDemo </em>目录中创建一些文件和文件夹，并保存我们的第一个快照。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="5121" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; echo "I am file1" &gt; file1<br/>&gt;&gt;&gt; ls<br/>file1<br/>&gt;&gt;&gt; mkdir subDir1<br/>&gt;&gt;&gt; cd subDir1<br/>&gt;&gt;&gt; echo "I am file2" &gt; file2<br/>&gt;&gt;&gt; ls<br/>file2<br/>&gt;&gt;&gt; cd ..</span></pre><p id="90dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在你的<em class="jd"> gitDemo </em>目录中执行命令<em class="jd"> tree </em>来查看你的库的结构。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="dae8" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; tree<br/>.<br/>├── file1<br/>└── subDir1<br/>    └── file2</span><span id="39e9" class="jf jg hi kz b fi li lf l lg lh">1 directory, 2 files</span></pre><p id="c74b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经在项目存储库中创建了一些文件和文件夹。是时候保存我们存储库的第一个快照了😎。执行以下命令保存存储库的第一个快照。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="e962" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git add file1 subDir1/<br/>&gt;&gt;&gt; git commit -m "created file1, created subDir1 and created file2 in it"<br/>[master (root-commit) 155891c] created file1, created subDir1 and created file2 in it<br/> 2 files changed, 2 insertions(+)<br/> create mode 100644 file1<br/> create mode 100644 subDir1/file2</span></pre><p id="472c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁！我们已经保存了存储库的第一个快照。第一个提交对象已经创建。但是你一定想知道，这个<em class="jd"> git add </em>和<em class="jd"> git commit </em>命令是做什么的？</p><p id="d872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> git add <br/> </strong> <code class="du kw kx ky kz b">git add filename1 filename2 filename3</code>用于将变更暂存在您的存储库中以供提交(快照)。这就像快照前的预备步骤。请注意，如果您对某个文件进行了更改，但没有使用<em class="jd"> git add暂存该文件，</em>当您运行<em class="jd"> git commit时，不会考虑提交该文件。</em>即文件不会包含在快照中。我有意省略了一些关于暂存部分和暂存区域的细节，以便将重点放在Git数据模型上。我们将在另一篇文章中讨论这些细节。</p><p id="2245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> git commit <br/> </strong> <code class="du kw kx ky kz b">git commit -m “commit message” </code>在提交历史中保存您的库的当前状态的快照。提交消息用于描述存储库快照中的特定变化。提供良好的提交消息很重要。如果您想要查看项目的先前状态，其中有数千个提交，当您有一个好的提交消息时，找到提交会容易得多。</p><p id="caae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看提交后创建的所有对象。</p><p id="4d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向我们显示项目历史中所有提交的信息。因为我们现在只有一个提交，所以它将只输出关于单个提交的信息。执行命令<code class="du kw kx ky kz b">git log</code>并观察输出。我们可以看到，第一行包含一个40个字符长的字母数字字符串。它是提交对象内容的SHA-1散列。如果您不熟悉SHA-1散列，不要担心，只需将这个字母数字字符串视为提交对象的惟一标识符。所有类型的对象(提交、树、blob)都由这个SHA-1散列唯一标识。<br/>第二行提供了关于提交作者的信息(即在存储库中进行更改的作者)。当你和其他人在一个项目上合作时，有时知道提交的作者是有用的。第三行是提交的日期和时间。最后一行是作者在提交时添加的提交消息。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="c156" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git log<br/>commit 155891ca19d94f67159a992c77923818b57d74a5 (HEAD -&gt; master)<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Sun May 3 10:41:06 2020 +0530</span><span id="232b" class="jf jg hi kz b fi li lf l lg lh">created file1, created subDir1 and created file2 in it</span></pre><p id="277f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行这个命令<code class="du kw kx ky kz b">git cat-file commit &lt;commit-hash&gt;</code>来查看提交对象的内容。您可以从<code class="du kw kx ky kz b">git log</code>命令的输出中复制提交散列。在命令参数中，您不需要编写整个提交散列，甚至几个字符就足以在几乎所有时间识别提交。执行命令并观察输出。注意，输出中的第一行包含一个树对象的SHA-1散列。这个树对象代表根项目目录。</p><blockquote class="lj lk ll"><p id="c108" class="if ig jd ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated">提交散列是提交对象内容的函数。在这种情况下，作者、时间、日期等是不同的。因此，即使存储库快照的内容相同，提交哈希也会有所不同。(您会注意到我的提交散列和您的提交散列是不同的，即使存储库的内容完全相同)</p></blockquote><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="e15f" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git cat-file commit 155891c<br/>tree 4587af994fe34fed465b64b6ce8b8adb07a17aaf<br/>author pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1588482666 +0530<br/>committer pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1588482666 +0530</span><span id="6ec8" class="jf jg hi kz b fi li lf l lg lh">created file1, created subDir1 and created file2 in it</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lp"><img src="../Images/247c6b4f89a9a2d7a39083afbcfa5790.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*Aan5ldgWP5e-jhw72P0foQ.jpeg"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Commit object points to the Tree object corresponding to the root Project directory</figcaption></figure><p id="e8d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行命令<code class="du kw kx ky kz b">git ls-tree &lt;tree object hash&gt;</code>来查看这个树对象。再次从上面执行的<code class="du kw kx ky kz b">git cat-file commit &lt;commit-hash&gt;</code>命令的输出中复制树对象散列。我们观察到树对象包含对blob对象(文件1)的引用和对另一个树对象(subDir1)的引用。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="d598" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git ls-tree 4587af994fe34fed465b64b6ce8b8adb07a17aaF<br/>100644 blob a83c85bfc5f4f056b0932eb2e5cf767f167a67f2 file1<br/>040000 tree 8993f258581e2772c7a4c27ad07498caed668c57 subDir1</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lq"><img src="../Images/2d1cab593047813d71515ca4e75775a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*cBkeiMOwIeF7OWl_rjpcHg.jpeg"/></div></figure><p id="bcda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看blob对象(file1)和根树对象(subDir1)引用的树对象。执行命令<code class="du kw kx ky kz b">git cat-file blob &lt;blob-hash&gt;</code>为我们提供了blob对象的内容，即<em class="jd">文件1 </em>的内容。<br/>并且执行命令<code class="du kw kx ky kz b">git ls-tree &lt;tree hash&gt;</code>显示树对象(图中的散列8993f2)包含对另一个blob对象(文件2)的引用。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="b72a" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git cat-file blob a83c85bfc5f4f056b0932eb2e5cf767f167a67f2<br/>I am file1<br/>&gt;&gt;&gt; git ls-tree 8993f258581e2772c7a4c27ad07498caed668c57<br/>100644 blob 4e01f27ee757413022834dcb1bbf4c66fb01f05c file2</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lr"><img src="../Images/86971376812d28815563dbef1a4ebae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*9msUZF8KKjhCRu799b4TUg.jpeg"/></div></figure><p id="5815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，在进行第二次提交之前，我们将看一下树对象(表示子目录)引用的blob对象(图中的hash 4e01f27)。执行命令<code class="du kw kx ky kz b">git cat-file blob &lt;blob-hash&gt;</code>。输出是<em class="jd">子目录/文件2的内容。</em></p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="9bc3" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git cat-file blob 4e01f27ee757413022834dcb1bbf4c66fb01f05c<br/>I am file2</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ls"><img src="../Images/f57b8f4fd66441b9042cfb3ee58bab49.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*IbnVy2zd-8u_7U5wGj6xhw.jpeg"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Pictorial representation of all objects after the first commit</figcaption></figure><p id="5e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回过头来看看我们的<em class="jd">。git/objects </em>目录。我们看到我们列出了一些新项目。这些表示已经创建的对象——提交对象、树对象、blob对象。将上图中的对象散列与下面的输出进行匹配。所有对象的内容都存储在这里，在<em class="jd">中。git/对象。</em></p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="f405" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; tree .git/objects<br/>.git/objects<br/>├── 15<br/>│   └── 5891ca19d94f67159a992c77923818b57d74a5<br/>├── 45<br/>│   └── 87af994fe34fed465b64b6ce8b8adb07a17aaf<br/>├── 4e<br/>│   └── 01f27ee757413022834dcb1bbf4c66fb01f05c<br/>├── 89<br/>│   └── 93f258581e2772c7a4c27ad07498caed668c57<br/>├── a8<br/>│   └── 3c85bfc5f4f056b0932eb2e5cf767f167a67f2<br/>├── info<br/>└── pack</span></pre><p id="d5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们在我们的存储库中做一些更改，然后再次提交。执行以下命令，在file1中进行一些更改，并提交这些更改。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="127d" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; echo "Adding another line in file1" &gt;&gt; file1<br/>&gt;&gt;&gt; git add file1<br/>&gt;&gt;&gt; git commit -m "added another line in file1"<br/>[master 6642a0d] added another line in file1<br/> 1 file changed, 1 insertion(+)</span></pre><p id="a20f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行<code class="du kw kx ky kz b">git log</code>查看日志中添加的新提交。最新的提交在顶部。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="1d74" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git log<br/>commit 6642a0de776b52bbe993555a4bf14aed060afea2 (HEAD -&gt; master)<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Sun May 3 22:14:12 2020 +0530</span><span id="9713" class="jf jg hi kz b fi li lf l lg lh">added another line in file1</span><span id="bdb2" class="jf jg hi kz b fi li lf l lg lh">commit 155891ca19d94f67159a992c77923818b57d74a5<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Sun May 3 10:41:06 2020 +0530</span></pre><p id="ca54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">*忽略上面输出中的</em> <code class="du kw kx ky kz b">HEAD -&gt; master</code> <em class="jd">。我们将在分支文章中讨论这一点。</em></p><p id="11a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行<code class="du kw kx ky kz b">git cat-file commit &lt;commit-hash&gt;</code>来查看新创建的提交对象的内容。我们将观察到，在第一行中，由于<em class="jd">文件1 </em>中的变化，它所指向的树对象具有与之前提交的散列不同的散列。<em class="jd"> </em>从而提交-2个点到不同的树对象。<br/>还记得我们在文章开头谈到的提交对象的父对象<a class="ae je" href="#59f8" rel="noopener ugc nofollow">吗？我们可以看到一个<em class="jd">父</em>数据成员也被添加到新创建的提交对象中。对应于该父数据成员的散列等于前一提交对象的散列，因此它验证该<em class="jd">父</em>数据成员是对前一提交对象的引用。</a></p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="1cee" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git cat-file commit 6642a0d<br/>tree 60f96fcee961146cdcf8c4cfd0faf5a0e821cebf<br/>parent 155891ca19d94f67159a992c77923818b57d74a5<br/>author pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1588524252 +0530<br/>committer pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1588524252 +0530</span><span id="fae6" class="jf jg hi kz b fi li lf l lg lh">added another line in file1</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lt"><img src="../Images/b4bc350c1e186c12443ee7f6d2a54ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6B0UrRQGEQT1fEgbGNn-iw.jpeg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Commit-2 has been created. Notice the parent data member. It points to its parent (i.e. commit-1). Also, the new commit (i.e. commit-2) points to a different Tree object.</figcaption></figure><p id="0c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将探索树对象(60f96fce)。新创建的提交对象包含指向该树对象的指针。执行命令<code class="du kw kx ky kz b">git ls-tree &lt;tree hash&gt;<br/></code>树对象(60f96fce)包含一个指向blob对象的指针和一个指向对应于<em class="jd">子目录</em>的另一个树对象(hash 8993f2585)的指针。由于<em class="jd">子目录</em>在两次提交之间没有改变，所以这个树对象(8993f2585)的内容也没有改变。由于<em class="jd">文件1 </em>被更改，我们有一个新的blob对象对应于<em class="jd">文件1。</em>我们可以使用这个命令<code class="du kw kx ky kz b">git cat-file blob &lt;blob hash&gt;</code>查看新的blob对象的内容。<em class="jd"> blob hash </em>将从之前执行的<code class="du kw kx ky kz b">git ls-tree &lt;tree hash&gt;</code>命令的输出中获得。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="a328" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git ls-tree 60f96fcee961146cdcf8c4cfd0faf5a0e821cebf<br/>100644 blob 668be5e5d8709844c9e14efb34565cdbc475b57f file1<br/>040000 tree 8993f258581e2772c7a4c27ad07498caed668c57 subDir1</span><span id="88d6" class="jf jg hi kz b fi li lf l lg lh">&gt;&gt;&gt; git cat-file blob 668be5e5d8709844c9e14efb34565cdbc475b57f<br/>I am file1<br/>Adding another line in file1</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lu"><img src="../Images/ec9cee52b80f2d35308942d1cc1254fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*g2RcGESmjRofi3MaxiB-9w.jpeg"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Tree object corresponding to subDir1 remains the same, blob object for file1 changes.</figcaption></figure><p id="807e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提交时间-3。我们将在<em class="jd">子目录/文件2中做一些更改。</em>执行以下命令，对<em class="jd">子目录/文件2 </em>进行更改，并提交这些更改。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="74ed" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; echo "I have been changed" &gt;&gt; subDir1/file2<br/>&gt;&gt;&gt; git add subDir1/file2<br/>&gt;&gt;&gt; git commit -m "changed file2"<br/>[master e097d8d] changed file2<br/> 1 file changed, 1 insertion(+)</span></pre><p id="b9b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看新的提交。执行<code class="du kw kx ky kz b">git log</code>。新的提交对象可以在顶部找到。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="4ede" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git log<br/>commit e097d8da357fe97c36c7178f0b770ae44b1f1f3c (HEAD -&gt; master)<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Thu May 21 10:24:55 2020 +0530</span><span id="cf4c" class="jf jg hi kz b fi li lf l lg lh">changed file2</span><span id="fb4f" class="jf jg hi kz b fi li lf l lg lh">commit 6642a0de776b52bbe993555a4bf14aed060afea2<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Sun May 3 22:14:12 2020 +0530</span><span id="1627" class="jf jg hi kz b fi li lf l lg lh">added another line in file1</span><span id="2fda" class="jf jg hi kz b fi li lf l lg lh">commit 155891ca19d94f67159a992c77923818b57d74a5<br/>Author: pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt;<br/>Date:   Sun May 3 10:41:06 2020 +0530</span><span id="9487" class="jf jg hi kz b fi li lf l lg lh">created file1, created subDir1 and created file2 in it</span></pre><p id="5914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看新创建的提交对象的内容。执行命令<code class="du kw kx ky kz b">git cat-file &lt;commit-hash&gt;</code>。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="ff5e" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git cat-file commit e097d8d<br/>tree e1564dac72800b9ee123f05e882543c4b7db56d1<br/>parent 6642a0de776b52bbe993555a4bf14aed060afea2<br/>author pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1590036895 +0530<br/>committer pprakarsh &lt;<a class="ae je" href="mailto:prakarshparashar@gmail.com" rel="noopener ugc nofollow" target="_blank">prakarshparashar@gmail.com</a>&gt; 1590036895 +0530</span><span id="3f7d" class="jf jg hi kz b fi li lf l lg lh">changed file2</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lv"><img src="../Images/1965609d402f50d0d465cdb27525a65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plapuDLB-uyRbhx1GZKLjA.jpeg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">We see that commit-3 points to a different tree object (e1564dac)</figcaption></figure><p id="1df5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将查看新创建的树对象(e1564dac)和该树对象(e1564dac)指向的其他对象。这个树对象指向blob对象(668be5e)和一个新的树对象(ba6b84ec)对应于<em class="jd"> subDir。</em>为什么一个新的<em class="jd"> </em>树对象用于<em class="jd">子目录？</em>因为<em class="jd">子目录</em>的内容已经改变。对应于<em class="jd">文件1 </em>的blob对象(668be5e)不变，因为<em class="jd">文件1 </em>不变。</p><p id="5706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行以下命令来查看这些新创建的对象的内容。</p><pre class="kg kh ki kj fd la kz lb lc aw ld bi"><span id="c908" class="jf jg hi kz b fi le lf l lg lh">&gt;&gt;&gt; git ls-tree e1564dac72800b9ee123f05e882543c4b7db56d1<br/>100644 blob 668be5e5d8709844c9e14efb34565cdbc475b57f file1<br/>040000 tree ba6b84ec235a7cc5eeefba17dd744d270e2b258d subDir1</span><span id="abf3" class="jf jg hi kz b fi li lf l lg lh">&gt;&gt;&gt; git ls-tree ba6b84ec235a7cc5eeefba17dd744d270e2b258d<br/>100644 blob 38ec3b70732a6b5e219fea0edbf48b26c7bd2234 file2</span><span id="566e" class="jf jg hi kz b fi li lf l lg lh">&gt;&gt;&gt; git cat-file blob 38ec3b70732a6b5e219fea0edbf48b26c7bd2234<br/>I am file2<br/>I have been changed</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lv"><img src="../Images/4f92f83445da55105f0423ec9b47be11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIzvYjKwz40LJ9hjMyi_Mw.jpeg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Flow chart representation of git objects after Commit-3</figcaption></figure><p id="db7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望现在我们对Git的数据模型有了清晰的理解。我们了解Git如何存储不同类型的对象。在下一篇文章中，我们将了解Git最强大的特性之一——分支。第二篇文章可以在这里找到<a class="ae je" rel="noopener" href="/geekculture/git-branching-made-easy-1cc894b9fd03">。</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>LeetCode — Validate Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —验证二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-validate-binary-search-tree-88f911efd8b3?source=collection_archive---------18-----------------------#2021-11-21">https://medium.com/geekculture/leetcode-validate-binary-search-tree-88f911efd8b3?source=collection_archive---------18-----------------------#2021-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f80f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="fe11" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一棵二叉树的<em class="kb">根</em>，<em class="kb">确定它是否是有效的二叉查找树(BST) </em>。</p><p id="76c7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一个<strong class="jf hj">有效BST </strong>定义如下:</p><ul class=""><li id="7d17" class="kh ki hi jf b jg kc jk kd jo kj js kk jw kl ka km kn ko kp bi translated">节点的左子树只包含键<strong class="jf hj">小于节点键</strong>的节点。</li><li id="50b5" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">节点的右边子树只包含键<strong class="jf hj">大于节点键</strong>的节点。</li><li id="8c6b" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">左右子树也必须是二分搜索法树。</li></ul><p id="2821" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/708eff0591aba47f5d1f4120dc380bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*peTShoj9uhDv98S9.png"/></div></figure><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="7531" class="li ig hi le b fi lj lk l ll lm">Input: root = [2, 1, 3] <br/>Output: true</span></pre><p id="a254" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ln"><img src="../Images/6efd40a07014e1ef25b484bee6b25eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*hrg2o_Vmnv2tm6BY.png"/></div></figure><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="c64a" class="li ig hi le b fi lj lk l ll lm">Input: root = [5, 1, 4, null, null, 3, 6] <br/>Output: false <br/>Explanation: The root node's value is 5, but its right child's value is 4.</span></pre><p id="6717" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束</strong></p><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="56f1" class="li ig hi le b fi lj lk l ll lm">- The number of nodes in the tree is in the range [1, 10^4].<br/>- -2^31 &lt;= Node.val &lt;= 2^31 - 1</span></pre><h1 id="b972" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="9b39" class="li ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">不正确的方法</h2><p id="5246" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们大多数人会想到的第一个天真的方法是检查每个节点，左边的孩子应该较小，右边的孩子应该较大。</p><p id="5b92" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">但是下面的树不是有效的BST，因为值为4的节点位于值为3的节点的左子树中。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mb"><img src="../Images/a225dd66b5e903fb95ab218c7e6cdf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/0*rsBsvwVXYuTqdZ3M.gif"/></div></figure><h2 id="cf7b" class="li ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">正确的方法</h2><p id="b602" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">上面的方法暗示我们需要跟踪左右子树中任何节点的最大值和最小值。</p><p id="f008" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="ee23" class="li ig hi le b fi lj lk l ll lm">// isValidBST function<br/>- if root == NULL<br/>  - return true<br/><br/>- return checkValidBST(root, LONG_MIN, LONG_MAX)<br/><br/>// checkValidBST(root, min, max) function<br/>- if root == NULL<br/>  - return true<br/><br/>- if root-&gt;val &lt;= min || root-&gt;val &gt;= max<br/>  - return false<br/><br/>- return checkValidBST(root-&gt;left, min, root-&gt;val) &amp;&amp; checkValidBST(root-&gt;right, root-&gt;val, max)</span></pre><h2 id="be65" class="li ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">C++解决方案</h2><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="baf5" class="li ig hi le b fi lj lk l ll lm">class Solution {<br/>public:<br/>    bool isValidBST(TreeNode* root) {<br/>        if(root == NULL) {<br/>            return true;<br/>        }<br/><br/>        return checkValidBST(root, LONG_MIN, LONG_MAX);<br/>    }<br/><br/>    bool checkValidBST(TreeNode* root, long min, long max){<br/>        if(root == NULL) {<br/>            return true;<br/>        }<br/><br/>        if(root-&gt;val &lt;= min || root-&gt;val &gt;= max) {<br/>            return false;<br/>        }<br/><br/>        return checkValidBST(root-&gt;left, min, root-&gt;val) &amp;&amp; checkValidBST(root-&gt;right, root-&gt;val, max);<br/>    }<br/>};</span></pre><h2 id="55d1" class="li ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">戈朗溶液</h2><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="6dba" class="li ig hi le b fi lj lk l ll lm">func isValidBST(root *TreeNode) bool {<br/>    if root == nil {<br/>        return true<br/>    }<br/><br/>    return checkValidBST(root, math.MinInt32, math.MaxInt32)<br/>}<br/><br/>func checkValidBST(root *TreeNode, min, max int) bool {<br/>    if root == nil {<br/>        return true<br/>    }<br/><br/>    if root.Val &lt;= min || root.Val &gt;= max {<br/>        return false<br/>    }<br/><br/>    return checkValidBST(root.Left, min, root.Val) &amp;&amp; checkValidBST(root.Right, root.Val, max)<br/>}</span></pre><h2 id="36ed" class="li ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">Javascript解决方案</h2><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="3e7c" class="li ig hi le b fi lj lk l ll lm">var isValidBST = function(root) {<br/>    if( !root ) {<br/>        return true;<br/>    }<br/><br/>    return checkValidBST(root);<br/>};<br/><br/>var checkValidBST = function(root, min = -Infinity, max = +Infinity) {<br/>    if (!root) {<br/>        return true;<br/>    }<br/><br/>    if (root.val &lt;= min || root.val &gt;= max) {<br/>        return false;<br/>    }<br/><br/>    return checkValidBST(root.left, min, root.val) &amp;&amp; checkValidBST(root.right, root.val, max);<br/>}</span></pre><p id="112a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kw kx ky kz fd ld le lf lg aw lh bi"><span id="0ce3" class="li ig hi le b fi lj lk l ll lm">Input: root = [2, 1, 3]<br/><br/>// in isValidBST function<br/>Step 1: if root == NULL<br/>           false<br/><br/>Step 2: return checkValidBST(root, LONG_MIN, LONG_MAX)<br/><br/>// in checkValidBST function<br/>Step 3: if root == NULL<br/>           false<br/><br/>Step 4: if root-&gt;val &lt;= min || root-&gt;val &gt;= max<br/>           2 &lt;= LONG_MIN || 2 &gt;= LONG_MAX<br/>           false || false<br/>           false<br/><br/>Step 5: return checkValidBST(root-&gt;left, min, root-&gt;val) &amp;&amp; checkValidBST(root-&gt;right, root-&gt;val, max)<br/>        return checkValidBST(1, LONG_MIN, 2) &amp;&amp; checkValidBST(3, 2, LONG_MAX)<br/><br/>// checkValidBST(1, LONG_MIN, 2)<br/>Step 6: if root == NULL<br/>           false<br/><br/>Step 7: if root-&gt;val &lt;= min || root-&gt;val &gt;= max<br/>           1 &lt;= LONG_MIN || 1 &gt;= 2<br/>           false || false<br/>           false<br/><br/>Step 8: return checkValidBST(root-&gt;left, min, root-&gt;val) &amp;&amp; checkValidBST(root-&gt;right, root-&gt;val, max)<br/>        return checkValidBST(null, LONG_MIN, 1) &amp;&amp; checkValidBST(null, 1, LONG_MAX)<br/><br/>// checkValidBST(3, 2, LONG_MAX)<br/>Step 9: if root == NULL<br/>           false<br/><br/>Step 10: if root-&gt;val &lt;= min || root-&gt;val &gt;= max<br/>            2 &lt;= LONG_MIN || 2 &gt;= LONG_MAX<br/>            false || false<br/>            false<br/><br/>Step 11: return checkValidBST(root-&gt;left, min, root-&gt;val) &amp;&amp; checkValidBST(root-&gt;right, root-&gt;val, max)<br/>         return checkValidBST(null, LONG_MIN, 3) &amp;&amp; checkValidBST(null, 3, LONG_MAX)<br/><br/>Now for all the conditions<br/>Step 7: checkValidBST(null, LONG_MIN, 1) &amp;&amp; checkValidBST(null, 1, LONG_MAX)<br/>Step 11: checkValidBST(null, LONG_MIN, 3) &amp;&amp; checkValidBST(null, 3, LONG_MAX)<br/><br/>the first parameter root is null<br/><br/>So it returns true.<br/><br/>Hence the final answer we return is true.</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="5dad" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">最初发布于</em><a class="ae mj" href="https://alkeshghorpade.me/post/leetcode-validate-binary-search-tree" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
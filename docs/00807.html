<html>
<head>
<title>Designing a WebSocket Server in Golang | Reformers Golang Implementation Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中设计WebSocket服务器|改革者Golang实施策略</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-a-websocket-server-in-golang-reformers-golang-implementation-strategy-bcd2dc9e368e?source=collection_archive---------1-----------------------#2021-03-14">https://medium.com/geekculture/designing-a-websocket-server-in-golang-reformers-golang-implementation-strategy-bcd2dc9e368e?source=collection_archive---------1-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎来到Re-Formers项目的第二部分(使用WebSockets的协作表单编辑器)。这篇文章是关于WebSocket服务器的，它处理每个元素的整个表单同步。你可以在这里找到这个系列的其他文章:</p><ol class=""><li id="95a8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/heuristics/collaborative-form-editor-using-websockets-web-sockets-in-golang-and-react-20d123f40447">在Golang和React中使用WebSockets | Web Sockets的协作表单编辑器</a></li><li id="842b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">在Golang中设计WebSocket服务器|改革者后端实现策略</li><li id="e682" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/geekculture/designing-a-websocket-client-with-notifications-in-reactjs-reformers-reactjs-implementation-c669daf27d46">在ReactJS | Reformers前端实现策略中设计带通知的WebSocket客户端</a></li></ol><h2 id="c840" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="6b77" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">下面的GitHub存储库将带您进入服务器代码:<a class="ae jm" href="https://github.com/uds5501/re-formers-server" rel="noopener ugc nofollow" target="_blank">re formers-server</a>并在docker容器上运行，您可以使用</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c7be" class="js jt hi kx b fi lb lc l ld le">$ docker pull uddeshyasingh/re-formers-server<br/>$ docker run -p 1337:1337 uddeshyasingh/re-formers-server:latest</span></pre><h1 id="429c" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">文件夹描述概览🕵️</h1><p id="9b7b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">整个服务器模块由Dockerfile、Procfile、一些配置元素和两个模块server和Utils组成</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div class="er es lw"><img src="../Images/8face39079abe0bbd186d0af1ffee4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*icgu-_Jhw9a4VwPexMUrWA.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Program folder</figcaption></figure><p id="5871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> /server </strong>:它包括整个主服务器模块，稍后在main.go中调用。这是一个单独的包，因此可以很容易地伸缩。</p><p id="8c77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> /utils </strong>:它包含一个实用函数，用于处理一些工作，比如给客户端一个名称+颜色的组合，将入口标记映射到客户端，将它们分配给编辑钩子等等。</p><p id="0cf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> /tmp </strong>:这是由于使用<code class="du me mf mg kx b">air</code>实时调试器而创建的临时文件，您可以在生产容器中忽略它。</p><h1 id="a436" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">它都做些什么？📚</h1><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/e6eb324aac86e7cfe4d72fbe51e285dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyQ2FAbKOY5oeGOm8GK7UA.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Method Diagram for server</figcaption></figure><p id="54e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，我们的服务器提供3种不同的垂直服务，即表单处理程序、用户处理程序和锁处理程序</p><h2 id="dca7" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">用户处理程序</h2><ol class=""><li id="9a38" class="jd je hi ih b ii kn im ko iq mm iu mn iy mo jc ji jj jk jl bi translated">处理客户在编辑室的进出</li><li id="9273" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">分配和刷新传入客户端的入口令牌</li><li id="92a5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">跟踪当前房间中的用户，并帮助将其转发给连接的客户端。</li><li id="71e8" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">每6小时重置整个房间(参与的客户端和当前表单状态)。</li></ol><h2 id="8077" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">锁定处理程序</h2><ol class=""><li id="5623" class="jd je hi ih b ii kn im ko iq mm iu mn iy mo jc ji jj jk jl bi translated">它们有助于为某些表单问题分配锁定，以便多个用户可以编辑它们，而不用担心表单被另一个不知道的用户删除</li></ol><h2 id="c92f" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">表单处理程序</h2><ol class=""><li id="7564" class="jd je hi ih b ii kn im ko iq mm iu mn iy mo jc ji jj jk jl bi translated">这有助于添加新问题、删除旧问题和编辑现有问题。</li><li id="4245" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">服务器中产生了多个处理程序，以更快的速度帮助和执行请求。</li><li id="f672" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">本模块中的每个操作都有一个不同的工作流程，稍后将对其进行描述。</li></ol><h1 id="41c0" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">配置结构⚙️</h1><p id="31c6" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">总共使用了7个结构，我想详细说明其中的一些</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mp"><img src="../Images/09eb78fc4f21b536aeeb46282db4df30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVCO7sNmu2TotmDIt2Ek0Q.png"/></div></div></figure><p id="fbce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，<code class="du me mf mg kx b">FormVersionControl</code>帮助维护关于特定问题的版本控制元素的数据，<code class="du me mf mg kx b">ClientObject</code>顾名思义，存储客户信息。<code class="du me mf mg kx b">FormUpdateElement</code>是一个内部结构，用于传递特定问题所需的更新信息，最后，<code class="du me mf mg kx b">FormElement</code>在表单中存储特定问题的信息。</p><h2 id="5160" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">为什么我要使用sync.mutex？🧵</h2><p id="8e96" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">你可能已经注意到了，我在敏感的元素中使用了互斥锁来确保进程间的同步。下图是在没有使用互斥锁的情况下，它会给出一个错误。</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mq"><img src="../Images/aaa84d80b33ed86157e55dcfc01d4c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvFZP8_P4bt7_2sviduIXg.png"/></div></div></figure><p id="6ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在<code class="du me mf mg kx b">ClientObject</code>结构中，你不能通过WebSocket同时推送多个消息<strong class="ih hj">和</strong>。现在，为了确保多个线程不会同时使用WebSocket ( <code class="du me mf mg kx b">clientWebSocket</code>)。下图解释了修复方法。</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mr"><img src="../Images/d3c82955798d591553a6268d8403733d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEhUmZWVVf32xeU2-8fjZw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Synchronization using mutex locks</figcaption></figure><h2 id="95a5" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">关于服务器的一点点…💻</h2><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es ms"><img src="../Images/6944e03849b2ccf857643a6705d7542c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nX84j_AryXkhkX6JSC8pmA.png"/></div></div></figure><p id="ed7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的服务器基本上是一个结构，可以使用<code class="du me mf mg kx b">Init()</code>构造函数独立导出，并在<code class="du me mf mg kx b">main.go</code>中调用。它在<code class="du me mf mg kx b">/ws</code>绑定WebSocket处理程序，同时为<code class="du me mf mg kx b">roomUpdater</code>、<code class="du me mf mg kx b">pruneClients</code>和<code class="du me mf mg kx b">handleCustomMessages</code>各生成一个线程，同时为<code class="du me mf mg kx b">formRequestHandler</code>生成3个线程，以确保更快地处理问题请求。</p><p id="5abe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个结构都有一个将ClientObject结构存储为布尔值的映射<code class="du me mf mg kx b">clients</code>,一个用于映射条目标记的映射<code class="du me mf mg kx b">clientTokenMap</code>。<code class="du me mf mg kx b">clientRoomActivity</code>存储由<code class="du me mf mg kx b">handleCustomMessages</code>线程处理的用户加入/离开消息。存储在WebSockets中的一个<code class="du me mf mg kx b">requestUpgrader</code>。<code class="du me mf mg kx b">Util</code>对于Util模块，<code class="du me mf mg kx b">userTicker</code>推送频道中当前用户的更新。<code class="du me mf mg kx b">resetTicker</code>重置整个房间。</p><p id="2d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du me mf mg kx b">currFormId</code>为新问题分配新的表单Id，而<code class="du me mf mg kx b">formArray</code>存储所有问题。<code class="du me mf mg kx b">formMutex</code>如上所述，确保同步和无争用情况。</p><h1 id="c886" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">为了赚钱，我们的WebSocket处理程序！🥁</h1><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mt"><img src="../Images/38d7ad175904d130542478b19770a3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6X-HcYyRHyTymn5Tbh3HA.png"/></div></div></figure><p id="860e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们正在初始化一个源检查(在任何情况下我们都返回True ),然后<strong class="ih hj">将</strong>传入的<strong class="ih hj"> HTTP </strong>请求升级为一个持久的双工连接。我使用<a class="ae jm" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">gorilla</strong></a>WebSockets作为我们的web socket连接库。<br/>defer功能用于确保在启动连接出错的情况下删除注册的客户端。<br/>之后，无限for循环用于确保端点始终监听来自客户端的消息，我们将其解组为服务器可读格式，即<code class="du me mf mg kx b">clientRequestObject</code> struct，并将其发送到<code class="du me mf mg kx b">HandleClientMessage</code>方法进行进一步处理，如果这里也出现问题，我们将从映射的客户端连接中丢弃此连接。</p><h1 id="cd16" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">Dockerfile文件🐳</h1><p id="4e08" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我的项目档案很标准</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mu"><img src="../Images/92aaadaca327bb542c736f395a6378b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24Bp1W0nr_02tOUcvtKKxw.png"/></div></div></figure><p id="53d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有TLS证书来确保WSS协议连接的建立，而我没有，那么您可以将它部署在一个VM上(比如Azure ),它应该一切正常，所以我决定进行一次平稳的Heroku部署。</p><h1 id="f60a" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">Heroku部署🇭</h1><p id="a144" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Heroku dev center为Golang应用在他们的平台上的部署提供了优秀的资源。你可以按照这里给出的步骤:<a class="ae jm" href="https://devcenter.heroku.com/articles/getting-started-with-go?singlepage=true" rel="noopener ugc nofollow" target="_blank">使用Go开始使用Heroku</a>来部署你自己的版本。</p><p id="cf40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，你要做的就是:</p><ol class=""><li id="32c1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创建一个Procfile，它应该包含</li></ol><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6fca" class="js jt hi kx b fi lb lc l ld le">web: bin/re-formers-server</span></pre><p id="d292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.在你的主函数中，确保你的应用程序调用<code class="du me mf mg kx b">PORT</code>环境变量，并在它不存在的情况下自动设置它(因为Heroku需要它，不要问我为什么)</p><figure class="ks kt ku kv fd lx er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mv"><img src="../Images/a47224463003b1f90ccd8fa3aa348025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJ8zjWkQzFD72xYsnh9JZg.png"/></div></div></figure><p id="7765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在只需遵循经典的Heroku命令</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9a72" class="js jt hi kx b fi lb lc l ld le">$ heroku create<br/>$ <!-- -->git push heroku main<br/>$ heroku open</span></pre><p id="a66b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Tada！</p><h1 id="4a16" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">唷，终于得出结论了😅</h1><p id="975d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">所以在这篇文章中，你对这些特性有了一个基本的概述，它们是做什么的，以及一切是如何保持同步的。在下一篇文章中，你会看到客户端是如何工作的，以及如何在我们的服务器上添加、编辑或删除表单中的问题。抓紧了，你快到终点了；)</p><h1 id="a8bd" class="lf jt hi bd ju lg lh li jy lj lk ll kc lm ln lo kf lp lq lr ki ls lt lu kl lv bi translated">资源📎</h1><ul class=""><li id="fa97" class="jd je hi ih b ii kn im ko iq mm iu mn iy mo jc mw jj jk jl bi translated"><a class="ae jm" href="https://devcenter.heroku.com/articles/getting-started-with-go?singlepage=true" rel="noopener ugc nofollow" target="_blank">Heroku Go应用部署</a></li><li id="9ac7" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mw jj jk jl bi translated">服务器的Github存储库(<a class="ae jm" href="https://github.com/uds5501/re-formers-server" rel="noopener ugc nofollow" target="_blank">uds 5501/re-formers-server</a>)</li><li id="2d79" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mw jj jk jl bi translated">服务器的Dockerhub存储库(<a class="ae jm" href="https://hub.docker.com/repository/docker/uddeshyasingh/re-formers-server" rel="noopener ugc nofollow" target="_blank">uddeshyasingh/re-formers-server</a>)</li><li id="945a" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc mw jj jk jl bi translated">Gorilla WebSockets <a class="ae jm" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank"> Github存储库</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Testing in Android a Zero to Hero Tutorial-Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android测试从零到英雄教程-第3部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-3-b1a3b5504965?source=collection_archive---------21-----------------------#2021-06-08">https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-3-b1a3b5504965?source=collection_archive---------21-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="049d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试视图模型和存储库</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/cecba54ddfd7690ef35b1b7f67dd46e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLFz420ziOejxt5ImI0h6A.png"/></div></div></figure><blockquote class="jp jq jr"><p id="c7d4" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">在本教程中，我使用了来自https://pixabay.com/api/docs/的api来演示改进API调用的网络。</p></blockquote><p id="2629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将不会通过设置改造和匕首柄，下面我已经链接到所有的设置文件。</p><div class="jx jy ez fb jz ka"><a href="https://github.com/zaidzak9/AndroidTestingSample" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hj fi z dy kf ea eb kg ed ef hh bi translated">zaidzak 9/Android测试示例</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">用于学习和编写测试用例的购物清单应用程序，也在medium文章中用作解释测试的示例…</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">github.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko jn ka"/></div></div></a></div><p id="78aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您现在已经知道测试用例必须很快，但是网络调用绝不是这样。因此，为了编写网络调用的测试用例，我们需要测试替身的帮助，这意味着，我们将创建一个真正的存储库，我们的应用程序在其中访问API，并创建一个假的/模拟的存储库，用于我们的测试用例。</p><h2 id="19e4" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">让我们从实现购物存储库开始</h2><p id="dff5" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">为了创建一个test double，我们需要首先实现一个repository接口，其中声明了我们所有的suspend函数，简而言之就是我们的Room DB和Room调用所需的必要函数，以操纵/访问数据，然后这个接口将被我们的<strong class="ih hj">测试存储库</strong>和<strong class="ih hj">真实存储库(也称为默认存储库)继承。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="35a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们在本教程中使用<a class="ae jw" href="https://zaidzakir.medium.com/a-simple-android-app-using-mvvm-dagger-hilt-e9f45381f1bc" rel="noopener"> <strong class="ih hj">匕首柄进行依赖注入</strong> </a>，我将对我们之前实现的Room DB进行修改，并使用匕首柄更新它。购物存储库接口现在拥有应用程序访问数据所需的所有功能。</p><p id="4813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下面是默认存储库，实际应用程序将使用它来进行api调用和访问数据库。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="9859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在我们将在测试文件夹中创建模拟存储库，我们必须始终确保我们在androidTest文件夹和Test文件夹中的文件夹结构与我们的主文件夹结构相匹配。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="e9ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">mockshopping repository的分解</strong></p><p id="651b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> MockShoppingRepository </strong>的主要目的是稍后测试view model，我们只创建这个存储库来传递给我们的viewmodel以模拟我们的测试用例，因为我们不能使用<strong class="ih hj">默认存储库</strong>，我们将在视图模型的构造函数中传递购物存储库，允许我们的viewmodel在需要时继承真实和模拟存储库</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="295e" class="kp kq hi ls b fi lw lx l ly lz">private val shoppingItems = <em class="js">mutableListOf</em>&lt;ShoppingItem&gt;()</span></pre><p id="d31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们创建一个购物项目列表，我们将使用它来填充数据，这样我们就可以模拟我们的数据库购物项目的行为。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="8d15" class="kp kq hi ls b fi lw lx l ly lz">private val observableShoppingItems = MutableLiveData&lt;List&lt;ShoppingItem&gt;&gt;(shoppingItems)</span><span id="d3fd" class="kp kq hi ls b fi ma lx l ly lz">private val observableTotalPrice = MutableLiveData&lt;Float&gt;()</span></pre><p id="16cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，我们为observableShoppingItems和observableTotalPrice创建了可变数据，以便从我们的视图模型中观察，就像我们的真实回购一样。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="1906" class="kp kq hi ls b fi lw lx l ly lz">private var shouldReturnNetworkError = false<br/><br/>fun setShouldReturnNetworkError(value: Boolean) {<br/>    shouldReturnNetworkError = value<br/>}</span></pre><p id="e1fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们不使用网络调用，我们需要一个值来模拟我们的视图模型在网络可用和不可用时的工作方式，这允许我们检查我们的应用程序在两种环境下的工作方式。</p><p id="4c43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在我们的默认存储库中一样，我们将继续从购物存储库接口继承，并获取所有方法来完成我们的类。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="504c" class="kp kq hi ls b fi lw lx l ly lz">private fun refreshLiveData() {<br/>    observableShoppingItems.postValue(shoppingItems)<br/>    observableTotalPrice.postValue(getTotalPrice())<br/>}</span></pre><p id="b507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了正确地模拟动态数据对象的行为，我们需要在向列表中添加项目后提交新的值，这就是为什么我们需要如上所示的<strong class="ih hj"> refreshLiveData() </strong>函数。</p><h2 id="fee5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">准备用于测试的视图模型</h2><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="614c" class="kp kq hi ls b fi lw lx l ly lz">@HiltViewModel<br/>class ShoppingViewModel @Inject constructor(<br/>    private val repository: ShoppingRepository<br/>): ViewModel(){}</span></pre><p id="c87c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当准备用于测试的ShoppingViewModel时，我们必须确保在构造函数中传递接口ShoppingRepository，以便使它兼容我们的默认存储库和模拟存储库来访问它，在这种情况下，它将很容易为两者互换，因为这两个类都继承自shopping repository。</p><p id="723d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通用事件类</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="c873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要一个类的帮助来确保我们的livedata发出一次性事件，因为当我们向我们的服务器发出网络请求时，我们经常会遇到问题，使用资源类，我们会在live data对象中发出<strong class="ih hj">成功</strong>或<strong class="ih hj">错误</strong>。</p><p id="6c49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由此可能产生的问题是，如果在纵向模式下发生错误，用户旋转设备，实时数据将再次发出相同的数据，导致相同的消息显示两次。</p><p id="6097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> getContentIfNotHandled() </strong>该函数仅在第一次被调用时发出数据，第二次以后将返回null。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="b2e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于测试视图模型是单元测试的一部分，我们将只创建函数签名，并首先为它们编写关于TDD的测试用例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="8e45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的常量类中定义两个常量，用于检查<strong class="ih hj">ITEM _ NAME</strong>&amp;<strong class="ih hj">ITEM _ PRICE</strong>的长度</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b431" class="kp kq hi ls b fi lw lx l ly lz">const val MAX_ITEM_NAME_LENGTH = 20<br/>const val MAX_ITEM_PRICE_LENGTH = 10</span></pre><p id="1930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们没有为我们的视图模型提供默认的购物存储库注入，所以我们必须创建一个默认的购物存储库并将其转换为购物存储库</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="2a3b" class="kp kq hi ls b fi lw lx l ly lz">@Singleton<br/>@Provides<br/>fun provideDefaultShoppingRepository(<br/>    dao: ShoppingDao,<br/>    api: PixabayAPI<br/>) = DefaultShoppingRepository(dao, api) as ShoppingRepository</span></pre><p id="bf7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在匕首柄将知道我们的视图模型需要的注入。</p><p id="18dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们在所有片段中实例化我们的视图模型。</p><p id="7d4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="aba7" class="kp kq hi ls b fi lw lx l ly lz">lateinit var shoppingViewModel: ShoppingViewModel</span><span id="214c" class="kp kq hi ls b fi ma lx l ly lz">onViewcreated(){<br/>shoppingViewModel = ViewModelProvided(requireActivity()).<br/>get(ShoppingViewModel::class.<em class="js">java</em>)<br/>}</span></pre><p id="042f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> requireActivity() </strong>将我们的视图模型绑定到我们的活动。</p><h1 id="9f6b" class="mi kq hi bd kr mj mk ml kv mm mn mo kz mp mq mr lc ms mt mu lf mv mw mx li my bi translated">测试我们的视图模型</h1><blockquote class="jp jq jr"><p id="c364" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj"> ShoppingViewModel - &gt;右键点击- &gt;生成测试用例- &gt; Junit 4 - &gt;测试文件夹- &gt;创建名为ShoppingViewModelTest的文件</strong></p></blockquote><p id="02db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试视图模型不需要任何android组件，所以我们使用测试文件夹。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="a93d" class="kp kq hi ls b fi lw lx l ly lz">lateinit var viewModel: ShoppingViewModel</span></pre><p id="3cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们初始化我们的<strong class="ih hj"> ShoppingViewModel </strong>以便在整个测试视图模型类中使用</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="db90" class="kp kq hi ls b fi lw lx l ly lz">@Before<br/>fun setup(){<br/>    viewModel = ShoppingViewModel(MockShoppingRepository())<br/>}</span></pre><p id="d316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将它初始化为<strong class="ih hj"> ShoppingViewModel </strong>并传递<strong class="ih hj"> MockShoppingRepository() </strong>，现在我们只需要一个数据列表，而不是默认的存储库，在默认的存储库中我们必须传递api和dao类，如下图所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/6e5656c71606214b6856f9f8d99f7c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEHG4ZC_fyo61mPU7-Za4g.png"/></div></div><figcaption class="na nb et er es nc nd bd b be z dx">why we should not use the default repository for testing</figcaption></figure><h2 id="76c7" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">让我们编写一些ViewModel测试用例</h2><ol class=""><li id="dce0" class="ne nf hi ih b ii lk im ll iq ng iu nh iy ni jc nj nk nl nm bi translated">测试在数据库中插入一个条目的数据是否有任何缺失的字段，如果有，我们预期的响应应该是一个错误，如果一切按计划进行，我们的测试将通过</li></ol><p id="866e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">。getOrAwaitValueTest() </strong>来自类<strong class="ih hj"> LiveDataUtil </strong>，我们不能使用之前为androidTest创建的类，因此我们必须将它复制粘贴到我们的测试文件夹中，以使其可访问。</p><p id="4740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">assertThat() 将从我们的事件类中检索状态，并检查状态是否等于<strong class="ih hj">状态。错误</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="83a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.一个函数来测试输入的名称长度是否超过我们在常量文件中的值，如果是，返回错误，测试用例应该通过，否则失败，为了实现这一点，我们使用kotlin lambda函数buildString的帮助，它将为我们动态构建一个长度为常量大小的字符串。MAX_LENGTH +1，而不是我们必须静态地键入它。在这种情况下，我们不需要在每次做改变的时候更新我们的测试函数和类。</p><p id="6523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.同样在下面，我们将写一个完全相同的函数，但这次是为了测试我们的价格长度有多长。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="cccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.最后，我们通过编写最后两个casess来总结它，这两个case将检查输入的金额是否是无效的int，我们必须确保输入的数字不超过int值可以容纳的数字，并且我们编写一个测试来检查如果我们输入正确的项目细节，插入到db中是否成功。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="df7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在当我们运行这个程序时，你会发现一些错误，在解决之前需要一些解释</p><p id="0445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">错误1 </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nn"><img src="../Images/39be56666b822745c407ea28e4e61b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75-67rTiRWNKyWjUq_BS9Q.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es no"><img src="../Images/4604b201f8ce04ef9ad6cedb45154d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMdMBnuUG7FiS1J5m65PRA.png"/></div></div></figure><p id="3d1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您遇到这种情况，那么单击default并选择JAR manifest，然后按ok。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="e8a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">错误2 </strong></p><p id="9bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当你再次运行时，我们会得到另一个错误，但这一次是因为我们没有使用<strong class="ih hj">InstantTaskExecutorRule</strong>，就像在androidTest中一样，这将允许所有测试用例在同一线程中一个接一个地运行。</p><blockquote class="jp jq jr"><p id="a4c1" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">@ get:Rule<br/>var instantTaskExecutorRule = instantTaskExecutorRule()</strong></p></blockquote><p id="8cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">错误3 </strong></p><p id="45ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，由于我们的liveData没有发出测试用例所期望的值，因为我们还没有发布任何东西，因为我们的视图模型中的函数实现在我们遵循TDD之后从未完成，所以为了解决这个问题，我们必须在我们的真实视图模型类中完成我们的函数实现。</p><blockquote class="jp jq jr"><p id="a24d" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">Java . util . concurrent . time out异常:从未设置LiveData</strong></p></blockquote><p id="4e02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">完成视图模型类的实现</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es np"><img src="../Images/3df09e4feb52f8b88dfc419386cf2c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOukSfzB1o8PHOZGYB-wFw.png"/></div></div></figure><p id="0625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">错误4 </strong></p><p id="4b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们运行我们的测试类时，我们的测试用例运行并成功通过，但是我们以一个不寻常的错误结束</p><blockquote class="jp jq jr"><p id="2390" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">线程“Main”Java . lang . illegalstateexception中出现异常:具有主调度程序的模块无法初始化。对于测试，可以使用来自kotlinx-coroutines-test模块的Dispatchers.setMain】</strong></p></blockquote><p id="4dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">这是什么？</em></p><p id="1897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">失败的原因是，如果你看看我们的<strong class="ih hj"> ShoppingViewModel </strong>类，我们在我们的<strong class="ih hj">fun validateShoppingItem(name:String，amount: String，price: String){} </strong>函数中使用了一个协程，这个协程调用了我们的<strong class="ih hj"> insertItemsIntoDb() </strong>函数，这个函数使用了一个suspend函数，这个函数使用了依赖于主循环的主调度程序，这个主循环程序只在真实的应用程序场景中可用</p><p id="2bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们在我们的JVM中运行这个测试，所以我们不能像在androidTest文件夹中那样访问真正的应用程序环境，Android test文件夹可以访问主Dispatcher。</p><p id="20f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，要解决这个问题，我们需要创建自己的JUnit规则。</p><p id="6886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的测试文件夹的根目录下创建一个名为<strong class="ih hj"> MainCoroutineRule </strong>的类</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="9851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构造函数中，我们传递Dispatcher并默认将其设置为<strong class="ih hj">TestCoroutineDispatcher</strong>，这是测试用例的推荐dispatcher，它将从<strong class="ih hj">测试观察器</strong>继承，这将使这个类能够被<strong class="ih hj"> JUnit test </strong>识别为一个规则。</p><p id="4618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">超驰乐趣启动</strong>将允许我们的测试调度员在需要时替换主调度员，然后<strong class="ih hj">超驰乐趣完成</strong>将在工作完成后重置一切。</p><p id="e988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在我们的<strong class="ih hj"> ShoppingViewModelTest </strong>中，我们应用我们的新规则并重新运行我们的测试</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="9597" class="kp kq hi ls b fi lw lx l ly lz">@get:Rule<br/>var mainCoroutineRule = MainCoroutineRule()</span></pre><p id="df5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们重新运行，我们所有的测试都将通过，并且不会显示任何错误，因为我们的视图模型测试类现在已经完成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nq"><img src="../Images/9a6986df2250b1076d70b926efa8d6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LInc1LNPK2zOPF48xxfHLg.png"/></div></div></figure></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="bfb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://zaidzakir.medium.com/testing-in-android-a-zero-to-hero-tutorial-part-4-307417ea9abb" rel="noopener"> <strong class="ih hj">安卓测试一零到英雄教程——第四部</strong> </a></p></div></div>    
</body>
</html>
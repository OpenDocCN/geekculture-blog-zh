<html>
<head>
<title>Designing a Revolutionary Web App 👊 — Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计革命性的网络应用👊第三部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/designing-a-revolutionary-web-app-part-iii-bb228d550897?source=collection_archive---------6-----------------------#2022-05-30">https://medium.com/geekculture/designing-a-revolutionary-web-app-part-iii-bb228d550897?source=collection_archive---------6-----------------------#2022-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cdaba3da5a8f550387a3e3dbbe6bca86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unIRJjDdTgIzlDLGgyESIg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@conorsexton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Conor Sexton</a> on <a class="ae iu" href="https://unsplash.com/s/photos/ocean?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="7425" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第三部分——devo PS/数字海洋</h2><p id="bc50" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这是我的故事的第三部分，关于设计一个网络应用来支持苏丹人民抵抗政变。你可以在这里看到地点<a class="ae iu" href="https://sudan-art.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f435" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">你可以在这里看到第二部分<a class="ae iu" rel="noopener" href="/geekculture/designing-a-revolutionary-web-app-part-ii-a9b9356143a6"/>。</p><p id="874e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">首先，如果你想花100美元试用数字海洋60天，点击<a class="ae iu" href="https://m.do.co/c/914e910aa17b" rel="noopener ugc nofollow" target="_blank">这个</a>链接！</p><p id="c8e0" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在本文的最后一部分，我将讨论将一整套Django/React应用程序与docker compose一起部署到数字海洋水滴的一些难点。</p><p id="f275" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">我认为很多观点可能与其他项目相关😅</p><p id="2576" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">以下是我将关注的内容:</p><ol class=""><li id="401f" class="kt ku hi jv b jw ko ka kp jg kv jk kw jo kx kn ky kz la lb bi translated">如何使用docker compose为MVP部署到数字海洋；</li><li id="0056" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ky kz la lb bi translated">如何在使用反向代理服务器的安全生产部署中服务Django/React with NGINX；</li><li id="e0ea" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ky kz la lb bi translated">如何设置一个简单的Github actions工作流来自动化代码林挺、测试和部署的CI/CD管道。</li></ol><h2 id="11c5" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何使用docker compose为MVP部署到数字海洋</h2><p id="3456" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">所以，这一部分并不复杂。我决定使用docker compose，因为这个网站更多的是一个档案项目，我不希望有大量的流量。不需要kubernetes😰</p><p id="4d5a" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">您只需在数字海洋水滴上运行docker compose实例，就万事大吉了——这是一个linux盒子！这也使它成为一种非常简单的部署方法。</p><p id="501a" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这是我的生产docker合成文件的样子:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="18b6" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这就是这里发生的事情…我有三个服务:</p><ul class=""><li id="4267" class="kt ku hi jv b jw ko ka kp jg kv jk kw jo kx kn ln kz la lb bi translated">Django:构建后端Django应用程序，并使用gunicorn在端口8000上提供服务。在数字海洋中，我不允许通过防火墙上的8000端口进行连接，所以你只能在docker compose网络内部访问这个端口；</li><li id="5be8" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ln kz la lb bi translated">NGINX:这个Dockerfile实际上是一个多阶段的构建，首先构建react应用程序，从中提供静态文件，然后将api请求路由到后端；</li><li id="9e25" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ln kz la lb bi translated">Certbot这为我的站点更新了证书，所以它在HTTPS上工作。</li></ul><p id="cc3b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">我不打算转换certbot的部分，因为它可能值得自己的一块。但是你可以在这篇非常好的文章中读到更多关于如何做的内容。</p><p id="03a9" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">以下是Django应用程序的docker文件:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1a0f" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">它使用了一个像这样的小shell脚本:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="0a26" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">如果我在开发东西，它让我运行Django开发服务器，但是如果它在生产中，确保我使用gunicorn。</p><p id="0660" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">NGINX Dockerfile文件有点复杂，如下所示:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="2096" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这里的关键命令是第15行中的命令，您复制了构成第9行中的<code class="du lo lp lq lr b">npm run build</code>命令输出的所有捆绑文件，以便NGINX可以为它们服务。</p><p id="2925" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">现在开始真正棘手的部分💥</p><h2 id="be24" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何在使用反向代理服务器的安全生产部署中服务Django/React与NGINX</h2><p id="f3c5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">下面是<code class="du lo lp lq lr b">nginx.conf</code>文件，它做了大量繁重的工作将所有这些联系在一起:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f0b0" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这里有相当多的事情要做，以确保网站是安全的，并尽可能多地压缩文件，所以不要担心乍一看感觉有点压倒性。</p><p id="ca5e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">我认为理解这些文件的最简单的方法是弄清楚当用户的请求到达站点时会发生什么。如果他们访问HTTP上的端口80，第33行会将他们重定向到相同的url，但通过HTTPS。然后这将它们带到第54行，在那里服务器在端口443上监听HTTPS请求，并将这些请求带到React项目，该项目实际上将<code class="du lo lp lq lr b">index.html</code>作为入口点。</p><p id="8aed" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">第57、51和65行上的其他位置块都是我的Django应用程序中的路线。也就是说，只有当你能够访问8000端口时，你才能访问它们，而外部计算机则不能。这就是为什么他们都有这条线<code class="du lo lp lq lr b">try_files $uri @proxy_api;</code>，NGINX的意思是“去看看定义为<code class="du lo lp lq lr b">@proxy_api</code>的相同端点”。第58行是唯一包含一些查询字符串的行，因为这是唯一需要查询字符串的api端点。</p><p id="5f2f" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这将我们带到第69行，第70行中的<code class="du lo lp lq lr b">proxy_pass</code>块将到这个端点的请求路由到在端口8000上运行Django的Docker服务。NGINX <em class="ls">是</em>能够访问它，因为它是从同一个docker compose运行的，所以可以访问网络。</p><p id="e06b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在我进入devops之前，有一些安全提示…</p><ul class=""><li id="798f" class="kt ku hi jv b jw ko ka kp jg kv jk kw jo kx kn ln kz la lb bi translated">第4行很有帮助，因为它防止攻击者知道您使用的NGINX版本，而只是在googling上搜索该版本的漏洞。</li><li id="2fe9" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ln kz la lb bi translated">第47行确保您使用更高版本的TLS</li><li id="9000" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ln kz la lb bi translated">第48行确保您使用HSTS</li><li id="2f1d" class="kt ku hi jv b jw lc ka ld jg le jk lf jo lg kn ln kz la lb bi translated">第49行防止点击劫持攻击</li></ul><p id="359b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">最后但同样重要的是…</p><h2 id="db81" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何设置一个简单的Github actions工作流来自动化代码林挺、测试和部署的CI/CD管道</h2><p id="2bc0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">根据我的经验，Github actions工作流的设置可能有点复杂，但一旦它们启动并运行起来，一切都会变得有趣得多。自动化代码林挺、测试、docker构建和部署都意味着很难在生产中意外破坏你的应用(😱)并且您不必每次都手动进行部署。</p><p id="590a" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这就是我当时的感觉。我想对主分支中的任何pull请求运行一系列集成测试，这是我将新代码添加到代码库中的唯一方法，如果我合并了PR，那么就将新代码部署到我的droplet中。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="8862" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">因此，简单地说，第2–6行中的on块触发这个拉和推请求的工作流。但是第68行意味着部署作业只有在推送到main时才会运行😉第67行意味着它只有通过lint/test/build阶段才会运行，这将有助于防止bug进入生产环境。</p><p id="813e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">第12–23行确保我的依赖项在每次运行时都被缓存，这真的加快了速度。它们也在第37-50行重复出现。然后，您可以运行适合您的林挺/测试需求的任何节点或python命令。有时这可能有点复杂——请看第52行，了解如何在yaml语法中拆分一个带有多个标志的长命令。如果你使用pylint，获取所有的python文件可能有点麻烦，所以<code class="du lo lp lq lr b">git ls-files</code>是我的解决办法🙃</p><p id="0748" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">从第71行开始的部署部分有点复杂。你需要添加一些秘密到你的github库，这样你就可以SSH到Digital Ocean，你还需要确保你的droplet启用了这些。这里的是一个关于如何做到这一点的很好的教程。</p><p id="76c7" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">但是你走了！现在你只需要在你的pull请求上点击squash和merge，新的代码就部署好了,(希望)不会破坏你的应用😍</p></div></div>    
</body>
</html>
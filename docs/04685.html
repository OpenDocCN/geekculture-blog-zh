<html>
<head>
<title>Apache Kafka: Apprentice Cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡:学徒食谱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/apache-kafka-apprentice-cookbook-557439273cee?source=collection_archive---------25-----------------------#2021-07-01">https://medium.com/geekculture/apache-kafka-apprentice-cookbook-557439273cee?source=collection_archive---------25-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4a91ff14b7d72c3ffe909828e0663736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*FUt4b-H4mtmcFt9SP9kf7Q.png"/></div></figure><p id="5835" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Apache Kafka 是一个分布式事件流平台，强调可靠性、性能和定制。卡夫卡可以以<a class="ae jk" href="https://aws.amazon.com/pub-sub-messaging/" rel="noopener ugc nofollow" target="_blank">发布-订阅</a>的方式发送和接收信息。为了实现这一点，生态系统依赖于少数但强大的基本概念，这些概念使社区能够构建许多功能来解决<a class="ae jk" href="https://kafka.apache.org/uses" rel="noopener ugc nofollow" target="_blank">众多用例</a>，例如:</p><ul class=""><li id="cbdf" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">将消息作为<a class="ae jk" href="https://www.confluent.io/blog/apache-kafka-vs-enterprise-service-bus-esb-friends-enemies-or-frenemies/" rel="noopener ugc nofollow" target="_blank">企业服务总线</a>处理。</li><li id="cd1e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">跟踪活动、度量和遥测。</li><li id="4de9" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">处理流。</li><li id="22b0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">支持<a class="ae jk" href="https://www.confluent.io/blog/event-sourcing-cqrs-stream-processing-apache-kafka-whats-connection/" rel="noopener ugc nofollow" target="_blank">事件采购</a>。</li><li id="11cb" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">存储日志。</li></ul><p id="3cc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文将介绍支持Kafka的概念以及可用于处理数据流的不同工具。</p><h1 id="5230" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">体系结构</h1><p id="f41b" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Kafka的行为非常简单:<strong class="io hj">生产者</strong>将<em class="lc">消息</em>推送至特定的<em class="lc">主题</em>，而<strong class="io hj">消费者</strong>订阅该<em class="lc">主题</em>以获取并处理<em class="lc">消息。</em>让我们看看这项技术是如何实现的。</p><h2 id="4d0c" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">基础设施方面</h2><p id="536d" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">独立于使用，将部署以下组件:</p><ul class=""><li id="2bea" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个或多个<strong class="io hj">生产者</strong>向经纪人发送消息。</li><li id="dc3c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个或多个Kafka <strong class="io hj">代理</strong>，处理生产者和消费者之间通信的实际消息服务器。</li><li id="c8f2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个或多个<strong class="io hj">消费者</strong>在名为<strong class="io hj">消费者群体</strong>的集群中获取和处理消息。</li><li id="6f92" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">管理代理的一个或多个<a class="ae jk" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">动物园管理员</strong> </a>实例。</li><li id="0a10" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">(可选)一个或多个<strong class="io hj">注册表</strong>实例统一消息模式。</li></ul><p id="0e64" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作为一个可扩展的分布式系统，Kafka非常依赖于<em class="lc">集群</em>的概念。因此，在典型的生产部署中，每个组件可能会有多个实例。</p><p id="4485" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个<strong class="io hj">消费者组</strong>是同一个消费者应用程序的集群。卡夫卡大量使用这个概念来平衡事物应用方面的负荷。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lr"><img src="../Images/0e829981aeaf9a606ed6578ea48b7a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzcmBKL6zEw-z0tfIC0nrA.png"/></div></div></figure><p id="4a7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">注:对动物园管理员的依赖即将解除，参见</em> <a class="ae jk" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-500%3A+Replace+ZooKeeper+with+a+Self-Managed+Metadata+Quorum" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> KIP-500 </em> </a></p><blockquote class="ma mb mc"><p id="79d1" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://kafka.apache.org/documentation/#majordesignelements" rel="noopener ugc nofollow" target="_blank">设计&amp;实现文档</a> <br/> <a class="ae jk" href="https://hackernoon.com/kafka-basics-and-core-concepts-explained-dd1434dv" rel="noopener ugc nofollow" target="_blank">卡夫卡基础与核心概念:讲解— Aritra Das </a></p></blockquote><h2 id="c907" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">应用侧</h2><p id="0f38" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">卡夫卡中的<strong class="io hj">消息</strong>是<code class="du mg mh mi mj b">key-value</code>对。这些元素可以是从整数到<a class="ae jk" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf消息</a>的任何东西，只要提供正确的序列化器和反序列化器。</p><p id="bdbd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">消息被发送到<strong class="io hj">主题</strong>，主题会将其存储为<strong class="io hj">日志</strong>。主题应该是语义相关的日志的集合，但是没有强加特定的结构。一个主题可以将每条消息作为一个新的日志条目保存，也可以只保存每个键的最后一个值(又名<a class="ae jk" href="https://docs.confluent.io/platform/current/kafka/design.html#log-compaction" rel="noopener ugc nofollow" target="_blank">压缩日志</a>)。</p><p id="09d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了利用多个代理，默认情况下，主题被<a class="ae jk" href="https://en.wikipedia.org/wiki/Shard_(database_architecture)" rel="noopener ugc nofollow" target="_blank">分割</a>到<strong class="io hj">分区</strong>中。Kafka将根据其密钥将任何接收到的消息分配给一个分区，或者使用<a class="ae jk" href="https://www.confluent.io/blog/apache-kafka-producer-improvements-sticky-partitioner" rel="noopener ugc nofollow" target="_blank">一个分区算法</a>否则，从开发人员的角度来看，这将导致随机分配。每个分区都有一个负责所有I/O操作的<strong class="io hj">主分区</strong>，以及复制数据的<strong class="io hj">从分区</strong>。在当前角色出现问题的情况下，追随者将接管领导者的角色。</p><p id="6873" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">分区按顺序保存接收到的数据，为每个消息增加一个<strong class="io hj">偏移量</strong>整数。但是，两个分区之间没有顺序保证。因此，对于顺序相关的数据，必须通过使用相同的键来确保它们最终出现在相同的分区中。</p><p id="762b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个分区都被分配给使用者组中的一个特定使用者。该消费者是唯一从该分区获取消息的人。如果一个客户关闭，代理将<a class="ae jk" rel="noopener" href="/streamthoughts/understanding-kafka-partition-assignment-strategies-and-how-to-write-your-own-custom-assignor-ebeda1fc06f3">在客户之间重新分配分区</a>。</p><p id="ea5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作为一个异步系统，将每条消息准确地一次传递给消费者可能会很困难，并且会影响性能。为了减轻这一点，Kafka为<a class="ae jk" href="https://kafka.apache.org/documentation/#semantics" rel="noopener ugc nofollow" target="_blank">提供了不同级别的保证</a>，保证消息被处理的次数(<em class="lc">，即</em>，最多一次，至少一次，正好一次)。</p><blockquote class="ma mb mc"><p id="d838" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://towardsdatascience.com/log-compacted-topics-in-apache-kafka-b1aa1e4665a7" rel="noopener" target="_blank">日志压缩主题Apache Kafka—Seyed morte za mous avi</a><br/><a class="ae jk" href="https://www.youtube.com/watch?v=Vo6Mv5YPOJU&amp;list=PLa7VYi0yPIH0KbnJQcMv5N9iW8HkZHztH&amp;index=5" rel="noopener ugc nofollow" target="_blank">(Youtube)Apache Kafka 101:复制—汇合</a> <br/> <a class="ae jk" href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Replication" rel="noopener ugc nofollow" target="_blank">复制设计文档</a> <br/> <a class="ae jk" rel="noopener" href="/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e">处理细节保证— Andy Briant </a></p></blockquote><h2 id="6915" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">模式和注册表</h2><p id="ec9d" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">消息在退出生产者时被序列化，在由消费者处理时被反序列化。为了确保兼容性，两者必须使用相同的数据定义。考虑到应用程序的发展，确保这一点可能很难。因此，在处理生产系统时，建议使用模式来明确数据结构上的契约。</p><p id="3d72" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，Kafka提供了一个<strong class="io hj"> Registry </strong>服务器，用于存储和绑定主题的模式。历史上只有<a class="ae jk" href="https://avro.apache.org/docs/current/" rel="noopener ugc nofollow" target="_blank"> Avro </a>可用，但是注册表现在是模块化的，也可以开箱即用地处理<a class="ae jk" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>和<a class="ae jk" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>。</p><p id="c7e8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦生产者将描述由其主题处理的数据的模式发送到注册中心，其他方(<em class="lc">即</em>代理和消费者)将在注册中心获取该模式以验证和反序列化数据。</p><blockquote class="ma mb mc"><p id="81af" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/schema-registry/index.html" rel="noopener ugc nofollow" target="_blank">模式注册表文档</a> <br/> <a class="ae jk" href="https://aseigneurin.github.io/2018/08/02/kafka-tutorial-4-avro-and-schema-registry.html" rel="noopener ugc nofollow" target="_blank">卡夫卡教程# 4——Avro和模式注册表——Alexis Seigneurin</a><br/><a class="ae jk" href="https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#serializer-and-formatter" rel="noopener ugc nofollow" target="_blank">模式的串行化器——解串行化器</a></p></blockquote></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="d91a" class="jz ka hi bd kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw bi translated">集成</h1><p id="449c" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Kafka提供了多种连接代理的方式，根据需要，每种方式都可能比其他方式更有用。因此，即使一个库是另一个之上的抽象层，它也不一定对每个用例都更好。</p><h2 id="5a93" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">Kafka客户端库</h2><p id="a78d" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">有多种语言的客户端库可以帮助开发生产者和消费者。在下面的例子中，我们将使用Java，但是这个概念对于其他语言来说是相同的。</p><p id="2567" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">生产者的概念是随时发布消息，所以代码非常简单。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="46d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">消费者部分的代码稍微复杂一些，因为消费循环需要手动创建。另一方面，这给了它更多的行为控制。消费者状态由Kafka库自动处理。因此，重新启动工作线程将从他最近遇到的偏移量开始。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><blockquote class="ma mb mc"><p id="e29b" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/clients/index.html" rel="noopener ugc nofollow" target="_blank">可用库</a> <br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/installation/configuration/producer-configs.html" rel="noopener ugc nofollow" target="_blank">生产者配置</a> <br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/installation/configuration/consumer-configs.html" rel="noopener ugc nofollow" target="_blank">消费者配置</a></p></blockquote><h2 id="d95b" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">卡夫卡溪流</h2><p id="9cd8" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Kafka Streams建立在消费者图书馆之上。它不断地从一个主题中读取数据，并使用用功能性DSL声明的代码处理消息。</p><p id="6213" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在处理过程中，过渡数据可以保存在名为<a class="ae jk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KStream.html" rel="noopener ugc nofollow" target="_blank"> KStream </a>和<a class="ae jk" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KTable.html" rel="noopener ugc nofollow" target="_blank"> KTable </a>的结构中，存储在主题中。前者相当于一个标准主题，后者相当于一个压缩主题。使用这些数据存储将使Kafka能够自动跟踪工作状态，有助于在重启时回到正轨。</p><p id="0c6a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下代码示例摘自Apache 提供的<a class="ae jk" href="https://kafka.apache.org/28/documentation/streams/tutorial" rel="noopener ugc nofollow" target="_blank">教程。<br/>代码连接到一个名为<code class="du mg mh mi mj b">streams-plaintext-input</code>的包含字符串值的主题，不需要提供键。配置<code class="du mg mh mi mj b">StreamsBuilder</code>的几行代码将:</a></p><ol class=""><li id="3b76" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj my jr js jt bi translated">将每条消息转换成小写。</li><li id="8171" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated">使用空格作为分隔符分割结果。</li><li id="a3b1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated">按值对以前的令牌进行分组。</li><li id="9b80" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated">统计每组的令牌数，并将更改保存到名为<code class="du mg mh mi mj b">counts-store</code>的KTable中。</li><li id="dd26" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated">将这个Ktable中的更改流式传输到名为<code class="du mg mh mi mj b">streams-wordcount-output</code>的KStream中。</li></ol><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><blockquote class="ma mb mc"><p id="dd13" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/streams/concepts.html" rel="noopener ugc nofollow" target="_blank"> Kafka Streams概念</a> <br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/streams/developer-guide/write-streams.html" rel="noopener ugc nofollow" target="_blank">开发者指南<br/> </a> <a class="ae jk" rel="noopener" href="/@andy.bryant/kafka-streams-work-allocation-4f31c24753cc"> Kafka Stream作品分配— Andy Briant </a></p></blockquote><h2 id="a657" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">卡夫卡连接</h2><p id="6cf3" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Kafka Connect提供了一种使用<strong class="io hj">连接器</strong>在几乎任何技术之间转换和同步数据的方法。Confluent正在托管一个<a class="ae jk" href="https://www.confluent.io/hub/" rel="noopener ugc nofollow" target="_blank"> Hub </a>，用户可以在上面共享各种技术的连接器。这意味着集成Kafka Connect管道在大多数情况下只是一个配置问题，不需要代码。单个连接器甚至可以处理两个连接端:</p><ul class=""><li id="049f" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">用来自任何系统的数据填充主题:<em class="lc">即</em>一个<strong class="io hj">源</strong>。</li><li id="ff85" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将数据从一个主题发送到任何系统:<em class="lc">即</em>一个<strong class="io hj">接收器</strong>。</li></ul><p id="ce95" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">源将从以下模式的CSV文件中读取数据，然后将它们发布到主题中。同时，接收器将轮询主题并将消息插入到MongoDB数据库中。每个连接器可以在同一个或不同的worker中运行，并且为了可伸缩性，可以将worker分组到一个集群中。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mz"><img src="../Images/fa264f26189362ef2cdf2f4fde4c4c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pf-n2rZtVa3J7Cpg14L58Q.png"/></div></div><figcaption class="na nb et er es nc nd bd b be z dx">Kafka Connect pipeline example</figcaption></figure><p id="2e35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">连接器实例是通过特定于库的配置创建的。下面的文件是<a class="ae jk" href="https://www.confluent.io/hub/mongodb/kafka-connect-mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB连接器</a>的配置。它要求从主题<code class="du mg mh mi mj b">mongo-source</code>中获取所有消息，并将它们插入到名为<code class="du mg mh mi mj b">kafka-connect</code>的数据库的集合<code class="du mg mh mi mj b">sink</code>中。凭证由外部文件提供，这是Kafka Connect to<a class="ae jk" href="https://docs.confluent.io/platform/current/connect/security.html#externalizing-secrets" rel="noopener ugc nofollow" target="_blank">protect secrets</a>的一个特性。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="7331" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦配置完成，注册连接器就像在运行的<a class="ae jk" href="https://docs.confluent.io/home/connect/userguide.html#configuring-and-running-workers" rel="noopener ugc nofollow" target="_blank"> Kafka Connect实例</a>上进行HTTP调用一样简单。之后，该服务将自动观察数据，无需进一步的工作。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><blockquote class="ma mb mc"><p id="eab8" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/connect/userguide.html#connect-userguide" rel="noopener ugc nofollow" target="_blank">入门文档</a> <br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/connect/references/restapi.html" rel="noopener ugc nofollow" target="_blank">连接器实例API参考</a> <br/> <a class="ae jk" href="https://www.youtube.com/playlist?list=PLa7VYi0yPIH1MB2n2w8pMZguffCDu2L4Y" rel="noopener ugc nofollow" target="_blank"> (Youtube)教程播放列表—汇合</a></p></blockquote><h2 id="2d7c" class="ld ka hi bd kb le lf lg kf lh li lj kj ix lk ll kn jb lm ln kr jf lo lp kv lq bi translated">KSQL数据库</h2><p id="89d9" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Ksql在某种程度上相当于Kafka Streams，只是每个转换都是用类似sql的语言声明的。服务器连接到代理，可以根据主题创建<strong class="io hj">流</strong>或<strong class="io hj">表</strong>。这两个概念的行为方式与Kafka Streams中的KStream或KTable相同(<em class="lc">即</em>分别为主题和压缩主题)。</p><p id="2bcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">语言定义中有三种类型的查询:</p><ol class=""><li id="907a" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj my jr js jt bi translated"><strong class="io hj">持久查询</strong> ( <em class="lc">例如</em> <code class="du mg mh mi mj b">CREATE TABLE &lt;name&gt; WITH (...)</code>):创建一个新的流或表，它将被自动更新。</li><li id="31c6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated"><strong class="io hj">拉式查询</strong> ( <em class="lc">例如</em> <code class="du mg mh mi mj b">SELECT * FROM &lt;table|stream&gt; WHERE ID = 1</code>):行为类似于标准DBMS。获取数据作为即时快照并关闭连接。</li><li id="bb5a" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj my jr js jt bi translated"><strong class="io hj">推送查询</strong> ( <em class="lc">例如</em> <code class="du mg mh mi mj b"><em class="lc">SELECT * FROM &lt;table|stream&gt; EMIT CHANGES</em></code>):请求<em class="lc"> </em>到服务器的持久连接，异步推送更新的值。</li></ol><p id="3819" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该数据库可用于浏览经纪人的内容。可以通过命令<code class="du mg mh mi mj b">list topics</code>发现主题，并使用<code class="du mg mh mi mj b">print &lt;name&gt;</code>显示主题内容。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="75e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">创建和查询流或表的语法非常接近SQL。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="115b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Kafka推荐使用一个<a class="ae jk" href="https://www.confluent.io/blog/deep-dive-ksql-deployment-options/" rel="noopener ugc nofollow" target="_blank"> headless ksqlDB服务器</a>用于生产，用一个文件声明所有要创建的流和表。这避免了对定义的任何修改。</p><p id="9cac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">注意:ksqlDB服务器可以像任何其他消费者一样分组到一个集群中。</em></p><blockquote class="ma mb mc"><p id="0e33" class="im in lc io b ip iq ir is it iu iv iw md iy iz ja me jc jd je mf jg jh ji jj hb bi translated">延伸阅读:<br/> <a class="ae jk" href="https://docs.confluent.io/platform/current/streams-ksql.html" rel="noopener ugc nofollow" target="_blank">官方文档</a> <br/> <a class="ae jk" href="https://docs.ksqldb.io/en/latest/concepts/queries/" rel="noopener ugc nofollow" target="_blank"> KSQL详细查询类型</a> <br/> <a class="ae jk" href="https://www.youtube.com/playlist?list=PLa7VYi0yPIH2eX8q3mPpZAn3qCS1eDX8W" rel="noopener ugc nofollow" target="_blank"> (Youtube)教程播放列表—汇合</a></p></blockquote><h1 id="f7f4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="ffd5" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">这篇文章给出了卡夫卡生态系统和可能性的一个广阔的视野，这是众多的。这篇文章只是触及了每个主题的皮毛。但是不用担心，因为Apache、Confluent和其他开发人员都很好地记录了它们。这里有一些补充资料，可以让你更深入地了解卡夫卡:</p><ul class=""><li id="527c" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.youtube.com/playlist?list=PLa7VYi0yPIH0KbnJQcMv5N9iW8HkZHztH" rel="noopener ugc nofollow" target="_blank"> (Youtube)卡夫卡教程-<em class="lc"/></a></li><li id="93c2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://kafka-tutorials.confluent.io/" rel="noopener ugc nofollow" target="_blank">卡夫卡实践教程</a></li><li id="abb0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.confluent.io/blog/5-things-every-kafka-developer-should-know/" rel="noopener ugc nofollow" target="_blank">每个Apache Kafka开发人员都应该知道的5件事——Bill Bejeck</a></li><li id="820a" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://docs.confluent.io/platform/current/app-development/kafkacat-usage.html" rel="noopener ugc nofollow" target="_blank"> Kafkacat用户指南</a></li><li id="d23e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">【KSQL故障排除第2部分:幕后发生了什么？—罗宾·莫法特</li><li id="e4e8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://ssudan16.medium.com/kafka-internals-47e594e3f006" rel="noopener">阿帕奇卡夫卡内部——苏丹</a></li></ul><p id="8ca8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">完整的实验代码在我的</em> <a class="ae jk" href="https://github.com/aveuiller/frameworks-bootstrap/tree/master/Kafka" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> GitHub资源库</em> </a> <em class="lc">上有。</em></p><p id="df7e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">感谢Sarra Habchi和Dimitri Delabroye的评论</em></p></div></div>    
</body>
</html>
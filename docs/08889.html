<html>
<head>
<title>LeetCode — Binary Tree Level Order Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —二叉树层次顺序遍历</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-binary-tree-level-order-traversal-947321626da2?source=collection_archive---------5-----------------------#2021-11-18">https://medium.com/geekculture/leetcode-binary-tree-level-order-traversal-947321626da2?source=collection_archive---------5-----------------------#2021-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="cb1c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="4a30" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定二叉树的<em class="kb">根</em>，返回<em class="kb">其节点的</em>值的层次顺序遍历。(即从左到右，逐层)。</p><p id="88af" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/binary-tree-level-order-traversal" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/二叉树层次顺序遍历</a></p><p id="51ca" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/d31af91908fa4bd9258b09296f295df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*p_vrI29Dd-8BHKgCNrGpHw.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="d7cb" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [3, 9, 20, null, null, 15, 7]<br/>Output: [[3], [9, 20], [15, 7]]</span></pre><p id="5118" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="9246" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [1]<br/>Output: [[1]]</span></pre><p id="ea2c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例3: </strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="9202" class="kv ig hi kr b fi kw kx l ky kz">Input: root = []<br/>Output: []</span></pre><p id="298b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="8853" class="kv ig hi kr b fi kw kx l ky kz">- The number of nodes in the tree is in the range [0, 2000]<br/>- -1000 &lt;= Node.val &lt;= 1000</span></pre><h1 id="7cd3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="d3bd" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">递归函数</h2><p id="b082" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于树，递归是最广泛使用的方法，因为代码易于阅读。但是对于一些问题，递归增加了时间复杂度。对于大树，递归会导致堆栈溢出或由于<strong class="jf hj"> O(N^2) </strong>时间复杂性会花费大量时间。</p><p id="9101" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于这个问题，我们可以使用递归，但是需要计算树的高度。</p><p id="ea26" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的一小段C++代码如下所示:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="22d1" class="kv ig hi kr b fi kw kx l ky kz">void printLevelOrder(node* root){<br/>    int h = height(root);<br/>    for (int i = 0; i &lt; h; i++)<br/>        printCurrentLevel(root, i);<br/>}<br/><br/>void printLevel(node* root, int level){<br/>    if (root == NULL)<br/>        return;<br/><br/>    if (level == 0)<br/>        cout &lt;&lt; root-&gt;data &lt;&lt; " ";<br/>    else if (level &gt; 0) {<br/>        printLevel(root-&gt;left, level - 1);<br/>        printLevel(root-&gt;right, level - 1);<br/>    }<br/>}</span></pre><p id="8b8b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于倾斜树，上述方法的时间复杂度是<strong class="jf hj"> O(N^2) </strong>。最坏情况的空间复杂度是<strong class="jf hj"> O(N) </strong>。</p><h2 id="922f" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">迭代方法</h2><p id="a807" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过使用队列作为数据结构来改善时间复杂度。我们来检查一下算法。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="0a90" class="kv ig hi kr b fi kw kx l ky kz">- initialize 2D array as vector vector&lt;vector&lt;int&gt;&gt; result<br/>- initialize size and i</span><span id="3c88" class="kv ig hi kr b fi ln kx l ky kz">- return result if root == null</span><span id="3d6f" class="kv ig hi kr b fi ln kx l ky kz">- initialize queue&lt;TreeNode*&gt; q<br/>  - push root to queue : q.push(root)</span><span id="222c" class="kv ig hi kr b fi ln kx l ky kz">- initialize TreeNode* node for iterating on the tree</span><span id="4ecb" class="kv ig hi kr b fi ln kx l ky kz">- loop while( !q.empty() ) // queue is not empty<br/>  - initialize vector&lt;int&gt; tmp<br/>  - set size = q.size()</span><span id="5251" class="kv ig hi kr b fi ln kx l ky kz">  - loop for i = 0; i &lt; size; i++<br/>    - set node = q.front()</span><span id="fd70" class="kv ig hi kr b fi ln kx l ky kz">    - if node-&gt;left<br/>      - push in queue: q.push(node-&gt;left)</span><span id="f9b1" class="kv ig hi kr b fi ln kx l ky kz">    - if node-&gt;right<br/>      - push in queue: q.push(node-&gt;right)</span><span id="b096" class="kv ig hi kr b fi ln kx l ky kz">    - remove the front node: q.pop()</span><span id="7e79" class="kv ig hi kr b fi ln kx l ky kz">  - push the tmp to result: result.push_back(tmp)</span><span id="1f84" class="kv ig hi kr b fi ln kx l ky kz">- return result</span></pre><h2 id="f4c0" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">C++解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="b6f5" class="kv ig hi kr b fi kw kx l ky kz">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {<br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/>        int size, i;</span><span id="91cb" class="kv ig hi kr b fi ln kx l ky kz">        if(root == NULL)<br/>            return result;</span><span id="91b4" class="kv ig hi kr b fi ln kx l ky kz">        queue&lt;TreeNode*&gt; q;<br/>        q.push(root);</span><span id="69d0" class="kv ig hi kr b fi ln kx l ky kz">        TreeNode* node;</span><span id="64bb" class="kv ig hi kr b fi ln kx l ky kz">        while(!q.empty()){<br/>            vector&lt;int&gt; tmp;<br/>            size = q.size();</span><span id="1e8f" class="kv ig hi kr b fi ln kx l ky kz">            for(i = 0; i &lt; size; i++){<br/>                node = q.front();<br/>                if(node-&gt;left)<br/>                    q.push(node-&gt;left);</span><span id="28c2" class="kv ig hi kr b fi ln kx l ky kz">                if(node-&gt;right)<br/>                    q.push(node-&gt;right);</span><span id="afc5" class="kv ig hi kr b fi ln kx l ky kz">                q.pop();<br/>                tmp.push_back(node-&gt;val);<br/>            }</span><span id="c4a2" class="kv ig hi kr b fi ln kx l ky kz">            result.push_back(tmp);<br/>        }</span><span id="6ebc" class="kv ig hi kr b fi ln kx l ky kz">        return result;<br/>    }<br/>};</span></pre><h2 id="d81e" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">戈朗溶液</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="c39e" class="kv ig hi kr b fi kw kx l ky kz">func levelOrder(root *TreeNode) [][]int {<br/>    result := [][]int{}</span><span id="1e47" class="kv ig hi kr b fi ln kx l ky kz">    queue := []*TreeNode{root}</span><span id="c3a6" class="kv ig hi kr b fi ln kx l ky kz">    for len(queue) != 0 {<br/>        tmp := []int{}<br/>        size := len(queue)</span><span id="69e8" class="kv ig hi kr b fi ln kx l ky kz">        for i := 0; i &lt; size; i++ {<br/>            if queue[0] != nil {<br/>                tmp = append(tmp, queue[0].Val)<br/>                queue = append(queue, queue[0].Left)<br/>                queue = append(queue, queue[0].Right)<br/>            }</span><span id="51f0" class="kv ig hi kr b fi ln kx l ky kz">            queue = queue[1:]<br/>        }</span><span id="7619" class="kv ig hi kr b fi ln kx l ky kz">        result = append(result, tmp)<br/>    }</span><span id="302b" class="kv ig hi kr b fi ln kx l ky kz">    return result[:len(result)-1]<br/>}</span></pre><h2 id="e77b" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">Javascript解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="23a7" class="kv ig hi kr b fi kw kx l ky kz">var levelOrder = function(root) {<br/>    let result = [];<br/>    let queue = [];</span><span id="ed7e" class="kv ig hi kr b fi ln kx l ky kz">    if(root)<br/>        queue.push(root);</span><span id="3904" class="kv ig hi kr b fi ln kx l ky kz">    while(queue.length &gt; 0) {<br/>        tmp = [];<br/>        let len = queue.length;</span><span id="1b42" class="kv ig hi kr b fi ln kx l ky kz">        for (let i = 0; i&lt; len; i++) {<br/>            let node = queue.shift();<br/>            tmp.push(node.val);</span><span id="5f3e" class="kv ig hi kr b fi ln kx l ky kz">            if(node.left) {<br/>                queue.push(node.left);<br/>            }</span><span id="c001" class="kv ig hi kr b fi ln kx l ky kz">            if(node.right) {<br/>                queue.push(node.right);<br/>            }<br/>        }</span><span id="cc3e" class="kv ig hi kr b fi ln kx l ky kz">        result.push(tmp);<br/>    }</span><span id="d998" class="kv ig hi kr b fi ln kx l ky kz">    return result;<br/>};</span></pre><p id="c35e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="e43d" class="kv ig hi kr b fi kw kx l ky kz">Input: root = [3, 9, 20, null, null, 15, 7]</span><span id="08c4" class="kv ig hi kr b fi ln kx l ky kz">Step 1: vector&lt;vector&lt;int&gt;&gt; result;<br/>        int size, i;</span><span id="666c" class="kv ig hi kr b fi ln kx l ky kz">Step 2: root == null<br/>        [3, 9..] == null<br/>        false</span><span id="9483" class="kv ig hi kr b fi ln kx l ky kz">Step 3: queue&lt;TreeNode*&gt; q;<br/>        q.push(root);</span><span id="9d3d" class="kv ig hi kr b fi ln kx l ky kz">        q = [3]</span><span id="c371" class="kv ig hi kr b fi ln kx l ky kz">Step 4: loop !q.empty()<br/>        q = [3]<br/>        q.empty() = false<br/>        !false = true</span><span id="8ba9" class="kv ig hi kr b fi ln kx l ky kz">        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 1</span><span id="56b1" class="kv ig hi kr b fi ln kx l ky kz">        for(i = 0; i &lt; 1; i++)<br/>          - 0 &lt; 1<br/>          - true</span><span id="6bbb" class="kv ig hi kr b fi ln kx l ky kz">          node = q.front()<br/>          node = 3</span><span id="a104" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;left<br/>            - node-&gt;left = 9<br/>            - q.push(node-&gt;left)<br/>            - q = [3, 9]</span><span id="8e9e" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;right<br/>            - node-&gt;right = 20<br/>            - q.push(node-&gt;right)<br/>            - q = [3, 9, 20]<br/></span><span id="72f3" class="kv ig hi kr b fi ln kx l ky kz">          q.pop()<br/>          q = [9, 20]</span><span id="ddc3" class="kv ig hi kr b fi ln kx l ky kz">          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(3)</span><span id="7c85" class="kv ig hi kr b fi ln kx l ky kz">          i++<br/>          i = 1</span><span id="6d7f" class="kv ig hi kr b fi ln kx l ky kz">        for(i &lt; 1)<br/>        1 &lt; 1<br/>        false</span><span id="b497" class="kv ig hi kr b fi ln kx l ky kz">        result.push_back(tmp)<br/>        result = [[3]]</span><span id="3677" class="kv ig hi kr b fi ln kx l ky kz">Step 5: loop !q.empty()<br/>        q = [9, 20]<br/>        q.empty() = false<br/>        !false = true</span><span id="1441" class="kv ig hi kr b fi ln kx l ky kz">        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 2</span><span id="5569" class="kv ig hi kr b fi ln kx l ky kz">        for(i = 0; i &lt; 2; i++)<br/>          - 0 &lt; 2<br/>          - true</span><span id="81b2" class="kv ig hi kr b fi ln kx l ky kz">          node = q.front()<br/>          node = 9</span><span id="84dc" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false</span><span id="8ba3" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false</span><span id="bb01" class="kv ig hi kr b fi ln kx l ky kz">          q.pop()<br/>          q = [20]</span><span id="8db3" class="kv ig hi kr b fi ln kx l ky kz">          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(9)</span><span id="4e23" class="kv ig hi kr b fi ln kx l ky kz">          i++<br/>          i = 1</span><span id="7382" class="kv ig hi kr b fi ln kx l ky kz">        for(i &lt; 2)<br/>          - 1 &lt; 2<br/>          - true</span><span id="6240" class="kv ig hi kr b fi ln kx l ky kz">          node = q.front()<br/>          node = 20</span><span id="b37c" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;left<br/>            - node-&gt;left = 15<br/>            - q.push(node-&gt;left)<br/>            - q = [20, 15]</span><span id="f9cc" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;right<br/>            - node-&gt;left = 7<br/>            - q.push(node-&gt;right)<br/>            - q = [20, 15, 7]</span><span id="9056" class="kv ig hi kr b fi ln kx l ky kz">          q.pop()<br/>          q = [15, 7]</span><span id="6f6f" class="kv ig hi kr b fi ln kx l ky kz">          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(20)<br/>          tmp = [9, 20]</span><span id="759b" class="kv ig hi kr b fi ln kx l ky kz">          i++<br/>          i = 2</span><span id="e316" class="kv ig hi kr b fi ln kx l ky kz">        for(i &lt; 2)<br/>          - 2 &lt; 2<br/>          - false</span><span id="0c2a" class="kv ig hi kr b fi ln kx l ky kz">        result.push_back(tmp)<br/>        result = [[3], [9, 20]]</span><span id="2fab" class="kv ig hi kr b fi ln kx l ky kz">Step 6: loop !q.empty()<br/>        q = [15, 7]<br/>        q.empty() = false<br/>        !false = true</span><span id="bd5d" class="kv ig hi kr b fi ln kx l ky kz">        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 2</span><span id="d7bd" class="kv ig hi kr b fi ln kx l ky kz">        for(i = 0; i &lt; 2; i++)<br/>          - 0 &lt; 2<br/>          - true</span><span id="7d25" class="kv ig hi kr b fi ln kx l ky kz">          node = q.front()<br/>          node = 15</span><span id="8838" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false</span><span id="56fb" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false</span><span id="ff2e" class="kv ig hi kr b fi ln kx l ky kz">          q.pop()<br/>          q = [7]</span><span id="51bf" class="kv ig hi kr b fi ln kx l ky kz">          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(15)</span><span id="a608" class="kv ig hi kr b fi ln kx l ky kz">          i++<br/>          i = 1</span><span id="f701" class="kv ig hi kr b fi ln kx l ky kz">        for(i &lt; 2)<br/>          - 1 &lt; 2<br/>          - true</span><span id="c1f4" class="kv ig hi kr b fi ln kx l ky kz">          node = q.front()<br/>          node = 7</span><span id="0dcb" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false</span><span id="1d58" class="kv ig hi kr b fi ln kx l ky kz">          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false</span><span id="2f4a" class="kv ig hi kr b fi ln kx l ky kz">          q.pop()<br/>          q = []</span><span id="7ad0" class="kv ig hi kr b fi ln kx l ky kz">          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(7)<br/>          tmp = [15, 7]</span><span id="518e" class="kv ig hi kr b fi ln kx l ky kz">          i++<br/>          i = 2</span><span id="621f" class="kv ig hi kr b fi ln kx l ky kz">        for(i &lt; 2)<br/>          - 2 &lt; 2<br/>          - false</span><span id="8eeb" class="kv ig hi kr b fi ln kx l ky kz">        result.push_back(tmp)<br/>        result = [[3], [9, 20], [15, 7]]</span><span id="2cab" class="kv ig hi kr b fi ln kx l ky kz">Step 7: loop !q.empty()<br/>        q = []<br/>        q.empty() = true<br/>        !true = false</span><span id="ac07" class="kv ig hi kr b fi ln kx l ky kz">Step 8: return result</span><span id="5362" class="kv ig hi kr b fi ln kx l ky kz">So we return the result as [[3], [9, 20], [15, 7]].</span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="93b2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-binary-tree-level-order-traversal" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Feature Scopes with Dagger 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带匕首2的特征范围</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/feature-scopes-with-dagger-2-2b7a2ceb1c7d?source=collection_archive---------9-----------------------#2021-05-16">https://medium.com/geekculture/feature-scopes-with-dagger-2-2b7a2ceb1c7d?source=collection_archive---------9-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4d42" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">作用域机制以及我们如何构建任何类型的作用域</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/04a615fd014322f42dd965ebaa89eb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K5hkmPNj7msWKyAl"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">La-Rel Easter</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cbd0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">App，activity &amp;片段作用域是使用Dagger时熟悉的构造，但我们经常发现自己需要的作用域与这些不匹配。在这些情况下，我们需要创建自定义范围。它们的生命周期跨越多个片段和/或活动，并且通常映射到特性的生命周期。这就是为什么我们在本文中将它们称为特性范围。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="109b" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">所有范围都是一样的</h1><p id="42c3" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">所有Dagger作用域都使用相同的机制，在开始特性作用域之前，我们先来看看熟悉的app作用域(通常通过<code class="du lo lp lq lr b"><strong class="jq hj">AppComponent — @Singleton</strong></code>定义)。这让我们对scope的主要构造有了很好的了解，并让我们正确理解如何设置&amp;使用它们。首先，让我们修改三个重要的结构:</p><h1 id="eaee" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated"><strong class="ak"> 1。范围注释</strong></h1><p id="20b7" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">范围注释给出了范围的名称，是依赖项和组件之间的粘合剂。在Android社区中，<em class="lx">事实上的</em> <strong class="jq hj">应用范围</strong>注释为<code class="du lo lp lq lr b">@Singleton</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Singleton annotation definition</figcaption></figure><blockquote class="ma mb mc"><p id="dcfa" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated"><strong class="jq hj">让我们打破一个广为流传的神话:“</strong>只有通过用<code class="du lo lp lq lr b">@Singleton</code>注释类，它才会使注入的依赖关系在应用程序级别成为单例”<strong class="jq hj"> —错误。</strong></p></blockquote><p id="24ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b">@Singleton</code> <strong class="jq hj">是一个常规注释</strong>和<strong class="jq hj"> </strong> <em class="lx">本身</em>除了标记依赖项和组件之外，它什么也没做。基于这种标签，Dagger理解了它们之间的关系。它的广泛使用可以归因于它是唯一由<strong class="jq hj"> javax </strong>库提供的现成的作用域注释，并且在绝大多数Dagger示例中使用。因为它背后没有魔法，它可以很好地与任何其他注释交换，我个人更喜欢使用<code class="du lo lp lq lr b">@AppScope</code>，我觉得它更有表现力。</p><h1 id="47c1" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated"><strong class="ak"> 2。组件&amp;子组件定义</strong></h1><p id="65d4" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">组件和子组件是负责注入依赖关系的匕首结构。注入应用范围依赖性的组件通常被称为<strong class="jq hj"> AppComponent </strong>，它的基本实现如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">AppComponent definition</figcaption></figure><p id="708b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">需要注意的一个重要方面是<code class="du lo lp lq lr b">@Singleton</code>注释的使用。<strong class="jq hj">app component的</strong> <strong class="jq hj">实例只能注入有作用域的依赖项——单例(通过@Singleton)或无作用域的——非单例。</strong>这是理解范围的一个关键方面，为了更好地形象化，让我们看看下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/48bb42300da2098e8efb4998638b221f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSZK6EaVJkXp5csXlpwe0g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Scoped and unscoped dependencies</figcaption></figure><p id="7440" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的例子遵循了<code class="du lo lp lq lr b">AppComponent</code>的典型用法；在应用程序的生命周期中会创建一个<code class="du lo lp lq lr b">AppComponent@78d8e81</code>实例，并将其存储在应用程序实例中。这个组件实例负责将限定范围的<strong class="jq hj">文件存储库</strong>和未限定范围的<strong class="jq hj">地理位置存储库</strong>依赖项注入到三个视图模型构造函数中。结果，我们可以看到，限定了作用域的<strong class="jq hj">文件存储库</strong>是作为单例注入的(所有注入的依赖项都具有相同的@86c9c02引用)，对于未限定作用域的<strong class="jq hj">地理位置存储库</strong>，每次注入都会创建一个新实例。</p><blockquote class="ma mb mc"><p id="f8cf" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">组件/子组件实例可以注入组件/子组件范围的依赖项(单例)或未划分范围的依赖项(非单例)。</p></blockquote><h1 id="7e8b" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">3.<strong class="ak">组件/子组件实例创建的地点&amp;其寿命</strong></h1><p id="6deb" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">在app作用域的情况下，<code class="du lo lp lq lr b">AppComponent</code>在app类中初始化，只要app存在，它就存在。通过在组件实例生命周期的上下文中控制依赖关系为单例或非单例的组件实例生命周期，我们可以根据需要控制依赖关系的生命周期。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Initialise AppComponent in Android application object</figcaption></figure><blockquote class="ma mb mc"><p id="0cb6" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">通过控制组件/子组件的初始化，我们控制了范围。</p><p id="9bdd" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">快速回顾一下，范围设置所需的结构是:</p><p id="3950" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">-范围注释</p><p id="268a" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">-组件/子组件定义</p><p id="e021" class="jo jp lx jq b jr js ij jt ju jv im jw md jy jz ka me kc kd ke mf kg kh ki kj hb bi translated">-组件/子组件初始化的位置及其寿命</p></blockquote><p id="18af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在下一节中，我们将看看这三个构造如何应用于特性范围。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="1cec" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">功能范围</h1><p id="e309" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了说明特性范围的设置和使用，我们将使用一个具体的例子。</p><p id="4245" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> UX要求— </strong>对于火车票应用程序，我们希望实现一个订票功能。预订流程由四个屏幕组成:路线选择、填写个人数据、购买摘要和确认屏幕。用户可以在流中向后和向前导航，能够看到他填写的数据，并且当用户退出流时，收集的数据被丢弃。<code class="du lo lp lq lr b">BookingRepository</code>存储流程中收集的数据，代表计算流程状态的真实来源。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/b69a81d78ea184abe56a457c28bc696c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXPPXRiaddRAL4XdSr4Wsw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">High level class diagram for the booking flow</figcaption></figure><p id="7c6e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了实现具有上述需求的流程，我们需要一个Dagger设置，它允许我们在流程开始时注入一个新的<code class="du lo lp lq lr b">BookingRepository</code>实例，在流程中注入相同的<code class="du lo lp lq lr b">BookingRepository</code>实例，并在流程终止时丢弃<code class="du lo lp lq lr b">BookingRepository</code>实例。这些需求需要一个<strong class="jq hj">特征范围</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/1947c50090a637f53dc23f2e39744dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cO9mVH5RvSxBOMo6lMLYqQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Scopes overview</figcaption></figure><p id="d835" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的设置中，<code class="du lo lp lq lr b">AppComponent</code>注入应用程序级别的依赖项，<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>注入预订流程中的依赖项，<code class="du lo lp lq lr b">activity subcomponent</code>注入依赖项，这些依赖项的生命周期与活动的生命周期相关。</p><p id="4204" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里要考虑的一个重要方面是除了<code class="du lo lp lq lr b">AppComponent</code>之外的所有注入器都是作为子组件实现的。子组件可以访问其父组件和祖先组件公开的所有依赖项，直到根组件。</p><p id="27f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">组件图如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/c43f0693eb1dd6004f69a7448ac70df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*NZxha83vv0Mmnw_smkVpiw.png"/></div></figure><p id="2d38" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lx">提示:</em> </strong> <em class="lx">告诉Dagger为具有一定范围的活动创建子组件的一个简单方法是通过</em> <code class="du lo lp lq lr b"><em class="lx">@ContributesAndroidInjector</em></code> <em class="lx">和</em> <code class="du lo lp lq lr b"><em class="lx">scope</em></code> <em class="lx">注释。</em></p><p id="8d93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lx">下面的代码片段显示了如何创建</em> <code class="du lo lp lq lr b"><em class="lx">RouteActivitySubcomponent — @ActivityScope</em></code> <em class="lx"> : </em></p><pre class="iy iz ja jb fd mk lr ml mm aw mn bi"><span id="3786" class="mo ks hi lr b fi mp mq l mr ms">@ActivityScope <br/>@ContributesAndroidInjector(modules = RouteSelectionModule::class)<br/>abstract fun contributeRouteSelectionActivity(): RouteSelectionActivity</span></pre><p id="a2cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lx">注:</em> </strong> <em class="lx">其他活动的子组件也是以同样的方式创建的。</em></p><h1 id="d964" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">设置</h1><p id="2feb" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">所有的示波器都遵循相同的机制。我们之前已经看到了<code class="du lo lp lq lr b">AppComponent <strong class="jq hj">— </strong>@Singleton</code>中最重要的构造，现在让我们看看它们是如何应用于<strong class="jq hj">功能范围</strong>的。</p><p id="eaec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 1。范围注释</strong> —相同的实现，只是名称不同，<code class="du lo lp lq lr b">BookingFlowScope</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">BookingFlowScope annotation definition</figcaption></figure><p id="f7f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lx">作用域依赖</em> </strong> —要将<code class="du lo lp lq lr b">BookingRepository</code>作为singleton注入预订流作用域的上下文中，该类需要用<code class="du lo lp lq lr b">@BookingFlowScope</code>进行注释。</p><pre class="iy iz ja jb fd mk lr ml mm aw mn bi"><span id="840c" class="mo ks hi lr b fi mp mq l mr ms">@BookingFlowScope<br/>internal class BookingRepositoryImpl @Inject constructor(<br/>    private val apiInteractor: ApiInteractor,<br/>    private val paymentRepository: PaymentRepository<br/>)</span></pre><p id="f8ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"><strong class="jq hj"> <em class="lx">边注:</em> </strong> <em class="lx">对于视图模型，活动的视图模型存储负责在配置更改后重新创建活动时提供相同的实例。</em></strong></p><p id="fd5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。子组件— </strong>对于功能范围，我们将使用一个子组件来访问其父组件<code class="du lo lp lq lr b">AppComponent</code>公开的所有依赖项，并链接提供特定于该范围的依赖项的模块。子组件使用前面步骤中创建的<code class="du lo lp lq lr b">@BookingFlowScope</code>,并且能够注入流的所有活动。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">BookingFlowSubcomponent definition</figcaption></figure><p id="49cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。子组件实例创建的位置&amp;它的生命周期</strong></p><p id="f799" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">设置子组件时，与<code class="du lo lp lq lr b">AppComponent</code>(组件图的根)相比，还有一个额外的步骤。我们需要告诉Dagger这个组件是如何与图的其余部分连接的。在我们的例子中，<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>是<code class="du lo lp lq lr b">AppComponent</code>的孩子。为了表达这种关系，我们在<code class="du lo lp lq lr b"><strong class="jq hj">AppComponent.kt</strong></code>文件中添加以下几行:</p><pre class="iy iz ja jb fd mk lr ml mm aw mn bi"><span id="012c" class="mo ks hi lr b fi mp mq l mr ms"><em class="lx">/**<br/> * Get [BookingFlowSubcomponent].<br/> */<br/></em>fun bookingFlowSubcomponent(): BookingFlowSubcomponent</span></pre><p id="f80a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">附加步骤现在已经完成</strong>，我们可以专注于子组件实例的创建及其生命周期。操作<code class="du lo lp lq lr b">BookingFlowComponent</code>实例的逻辑驻留在方法<code class="du lo lp lq lr b"><strong class="jq hj">getOrCreateBookingFlowSubcomponent</strong></code>和<code class="du lo lp lq lr b"><strong class="jq hj">releaseBookingFlowSubcomponent</strong>.</code>中的<code class="du lo lp lq lr b">App</code>类中</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Methods for manipulating the bookingFlowComponent instance</figcaption></figure><p id="b53a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b"><strong class="jq hj">getOrCreateBookingComponent</strong></code>方法在流的所有屏幕中使用，以获得一个<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>实例的句柄。当在第一个屏幕中被调用时，它会创建一个新的<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>实例，并将其缓存在<code class="du lo lp lq lr b">bookingFlowSubcomponent</code>类变量中。对于在其他屏幕中执行的后续调用，该方法将返回缓存的实例。</p><p id="520d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lo lp lq lr b"><strong class="jq hj">releaseBookingFlowComponent</strong></code>退出预约流程时使用的方法是为了关闭范围。为了关闭范围，子组件被设置为<code class="du lo lp lq lr b">null</code>。在下一个垃圾收集周期中，子组件实例和注入的依赖项将被释放。当流程再次启动时，将创建一个新的子组件实例。</p><h1 id="ff0e" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">使用和注射</h1><p id="7f2c" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了突出<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>在活动中的用法，我们来看看<code class="du lo lp lq lr b">RouteSelectionActivity</code>(在其他活动中的用法是相同的):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Usage of BookingFlowSubcomponent in an activity</figcaption></figure><p id="f98c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码中有两行很有意思，<strong class="jq hj">第4行和第13行</strong>。</p><p id="3e9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<strong class="jq hj">第4行</strong>中，在调用基类的构造函数之前，会发生两件事:</p><ol class=""><li id="85a2" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated"><code class="du lo lp lq lr b">appInstance.getOrCreateBookingFlowSubcomponent()</code>返回<code class="du lo lp lq lr b">BookingFlowComponent</code>的新实例，因为<code class="du lo lp lq lr b">RouteSelectionActivity</code>是流程的第一个屏幕。在其他屏幕中或再次访问<code class="du lo lp lq lr b">RouteSelectionActivity</code>时，它将返回相同的实例。</li><li id="8b1a" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><code class="du lo lp lq lr b">bookingFlowSubcomponent.inject(this)</code>为这个活动注入依赖项。在流程中，依赖项的注入总是在同一个<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>实例的上下文中完成。</li></ol><p id="4afe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<strong class="jq hj">行13 </strong>中，当流程终止时，<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>被释放。<code class="du lo lp lq lr b">BookingFlowSubcomponent</code>实例将在下一个周期被垃圾收集；对于注入的依赖项也是如此，因为没有人再保留对它们的引用。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="3906" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就这些了，非常感谢你们的阅读！我希望它对你有所帮助，如果你有任何问题和反馈，请通过评论区告诉我。</p><p id="f95c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">保持积极和健康；下次再见！</p></div></div>    
</body>
</html>
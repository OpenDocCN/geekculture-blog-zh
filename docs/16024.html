<html>
<head>
<title>Target Encoding in Feature Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征工程中的目标编码</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/target-encoding-in-feature-engineering-bc7b738026ce?source=collection_archive---------12-----------------------#2022-12-06">https://medium.com/geekculture/target-encoding-in-feature-engineering-bc7b738026ce?source=collection_archive---------12-----------------------#2022-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ab384c15ff65a845ae2e73b8b7eba3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kzrtFo9L4rK_YIX4"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@tetrakiss?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arseny Togulev</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d273" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文将解释<strong class="ix hj">目标编码</strong>的概念，它在<strong class="ix hj">特征工程</strong>中的意义，以及代码实现。</p><p id="0ac7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我过去两周上传的<strong class="ix hj">特征工程</strong>系列的最后一部分。在<strong class="ix hj">目标编码</strong>的最后部分，我们将处理<strong class="ix hj">分类特征</strong>而不是<strong class="ix hj">数字特征</strong>。这是一种将类别编码为数字的技术，就像<strong class="ix hj"> one-hot或标签编码</strong>，它也使用<strong class="ix hj">目标</strong>来创建编码。这就是为什么它属于<strong class="ix hj">监督</strong> <strong class="ix hj">特征工程</strong>技术的范畴。</p><h2 id="22ed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">目标编码的用例</strong></h2><p id="bcdd" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">目标编码非常适合:</p><p id="643e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">高基数特性</strong>:具有<strong class="ix hj">大量类别的特性</strong>编码起来会很麻烦:一个<strong class="ix hj">单热编码</strong>会产生太多的特性和替代方案，比如标签编码，可能不适合那个特性。一个<strong class="ix hj">目标编码</strong>使用特性最重要的属性:它与目标的<strong class="ix hj">关系，为类别导出数字。</strong></p><p id="dcb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">领域驱动的特性</strong>:根据以前的经验，您可能会怀疑分类特性应该是重要的，即使它在特性度量中得分很低。目标编码有助于揭示一个特征真正的信息量。</p><h2 id="e694" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">目标编码的代码实现</strong></h2><p id="289a" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们将通过探索<a class="ae iu" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">Ames</strong></a><strong class="ix hj"/>房价数据集来了解目标编码的应用。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="1ceb" class="lc ju hi ky b be ld le l lf lg">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import pandas as pd<br/>import seaborn as sns<br/>import warnings<br/>from category_encoders import MEstimateEncoder<br/>from sklearn.model_selection import cross_val_score<br/>from xgboost import XGBRegressor<br/><br/># Set Matplotlib defaults<br/>plt.style.use("seaborn-whitegrid")<br/>plt.rc("figure", autolayout=True)<br/>plt.rc(<br/>    "axes",<br/>    labelweight="bold",<br/>    labelsize="large",<br/>    titleweight="bold",<br/>    titlesize=14,<br/>    titlepad=10,<br/>)<br/>warnings.filterwarnings('ignore')<br/><br/><br/># Model scoring<br/>def score_dataset(X, y, model=XGBRegressor()):<br/>    # Label encoding for categoricals<br/>    for colname in X.select_dtypes(["category", "object"]):<br/>        X[colname], _ = X[colname].factorize()<br/>    # Metric for Housing competition is RMSLE (Root Mean Squared Log Error)<br/>    score = cross_val_score(<br/>        model, X, y, cv=5, scoring="neg_mean_squared_log_error",<br/>    )<br/>    score = -1 * score.mean()<br/>    score = np.sqrt(score)<br/>    return score<br/><br/><br/>df = pd.read_csv("ames.csv")</span></pre><p id="7a5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码是我们在<a class="ae iu" rel="noopener" href="/geekculture/principal-component-analysis-pca-in-feature-engineering-472afa39c27d"> <strong class="ix hj"> PCA </strong> </a>上一部分的代码。模型评分完成，在这种情况下也使用<strong class="ix hj"> RMSLE </strong>。让我们选择<strong class="ix hj">目标编码</strong>可以应用到哪些特性。<strong class="ix hj">类别特征</strong>具有<strong class="ix hj">大量类别</strong> ( <strong class="ix hj">高基数</strong>)通常是很好的候选。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="b49d" class="lc ju hi ky b be ld le l lf lg">df.select_dtypes(["object"]).nunique()<br/><br/><br/>MSSubClass       16<br/>MSZoning          7<br/>Street            2<br/>Alley             3<br/>LotShape          4<br/>LandContour       4<br/>Utilities         3<br/>LotConfig         5<br/>LandSlope         3<br/>Neighborhood     28<br/>Condition1        9<br/>Condition2        8<br/>BldgType          5<br/>HouseStyle        8<br/>OverallQual      10<br/>OverallCond       9<br/>RoofStyle         6<br/>RoofMatl          8<br/>Exterior1st      16<br/>Exterior2nd      17<br/>MasVnrType        5<br/>ExterQual         4<br/>ExterCond         5<br/>Foundation        6<br/>BsmtQual          6<br/>BsmtCond          6<br/>BsmtExposure      5<br/>BsmtFinType1      7<br/>BsmtFinType2      7<br/>Heating           6<br/>HeatingQC         5<br/>CentralAir        2<br/>Electrical        6<br/>KitchenQual       5<br/>Functional        8<br/>FireplaceQu       6<br/>GarageType        7<br/>GarageFinish      4<br/>GarageQual        6<br/>GarageCond        6<br/>PavedDrive        3<br/>PoolQC            5<br/>Fence             5<br/>MiscFeature       6<br/>SaleType         10<br/>SaleCondition     6<br/>dtype: int64</span></pre><p id="0d89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，<strong class="ix hj">高基数</strong>的要素是<strong class="ix hj">邻域、ms子类、外部第二、外部第一和销售类型。</strong>现在检查其中一个特性的<strong class="ix hj">类别数量</strong>(假设<strong class="ix hj">销售类型</strong>)代码是。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="ff9a" class="lc ju hi ky b be ld le l lf lg">df["SaleType"].value_counts()<br/><br/>WD       2536<br/>New       239<br/>COD        87<br/>ConLD      26<br/>CWD        12<br/>ConLI       9<br/>ConLw       8<br/>Oth         7<br/>Con         5<br/>VWD         1<br/>Name: SaleType, dtype: int64</span></pre><p id="2b80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目标编码被应用于特征。现在为了<strong class="ix hj">避免过度拟合</strong>，我们需要将编码器拟合到训练集中的数据上。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="897d" class="lc ju hi ky b be ld le l lf lg"># Encoding split<br/>X_encode = df.sample(frac=0.20, random_state=0)<br/>y_encode = X_encode.pop("SalePrice")<br/><br/># Training split<br/>X_pretrain = df.drop(X_encode.index)<br/>y_train = X_pretrain.pop("SalePrice")</span></pre><p id="d4d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将目标编码应用于分类特征的选择。在这种情况下使用平滑参数<strong class="ix hj"> m=1 </strong>。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="c75d" class="lc ju hi ky b be ld le l lf lg"># Create the MEstimateEncoder<br/># Choose a set of features to encode and a value for m<br/>encoder = MEstimateEncoder(<br/>    cols=["Neighborhood"],<br/>    m=1.0,<br/>)<br/><br/><br/># Fit the encoder on the encoding split<br/>encoder.fit(X_encode, y_encode)<br/><br/><br/># Encode the training split<br/>X_train = encoder.transform(X_pretrain, y_train)</span></pre><pre class="lh kx ky kz bn la lb bi"><span id="d0ea" class="lc ju hi ky b be ld le l lf lg">feature = encoder.cols<br/><br/>plt.figure(dpi=90)<br/>ax = sns.distplot(y_train, kde=True, hist=False)<br/>ax = sns.distplot(X_train[feature], color='r', ax=ax, hist=True, kde=False, norm_hist=True)<br/>ax.set_xlabel("SalePrice");</span></pre><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/f506bc12b2ee356d4d0102da9e110bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHkH_u_v5rG8wzmhHYguww.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Distribution plot of encoding feature in comparison to the target(SalePrice) (image from Kaggle)</figcaption></figure><p id="8540" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.quora.com/What-is-the-difference-between-an-RMSE-and-RMSLE-logarithmic-error-and-does-a-high-RMSE-imply-low-RMSLE" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> RMSLE </strong> </a>编码数据集与基准数据集相比的得分。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="9d6c" class="lc ju hi ky b be ld le l lf lg">X = df.copy()<br/>y = X.pop("SalePrice")<br/>score_base = score_dataset(X, y)<br/>score_new = score_dataset(X_train, y_train)<br/><br/>print(f"Baseline Score: {score_base:.4f} RMSLE")<br/>print(f"Score with Encoding: {score_new:.4f} RMSLE")<br/><br/><br/>Baseline Score: 0.1428 RMSLE<br/>Score with Encoding: 0.1402 RMSLE </span></pre><p id="4d59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据选择的特征，分数比基准分数差<strong class="ix hj">。在这种情况下，通过编码获得的额外信息可能无法弥补编码所丢失的数据。</strong></p><p id="5329" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们将探讨目标编码的<strong class="ix hj">过拟合问题</strong>。这将说明<strong class="ix hj">训练适合目标编码器</strong>对<strong class="ix hj">训练集</strong>提供的数据的重要性。</p><p id="f49c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们看看当我们在<strong class="ix hj">相同的</strong>数据集上<strong class="ix hj">安装编码器和模型</strong>时会发生什么。为了强调过度拟合会有多戏剧性，我们将对一个与销售价格没有关系的特征进行编码。</p><pre class="kt ku kv kw fd kx ky kz bn la lb bi"><span id="1ba8" class="lc ju hi ky b be ld le l lf lg"># Try experimenting with the smoothing parameter m<br/># Try 0, 1, 5, 50<br/>m = 5<br/><br/>X = df.copy()<br/>y = X.pop('SalePrice')<br/><br/># Create an uninformative feature<br/>X["Count"] = range(len(X))<br/>X["Count"][1] = 0  # actually need one duplicate value to circumvent error-checking in MEstimateEncoder<br/><br/># fit and transform on the same dataset<br/>encoder = MEstimateEncoder(cols="Count", m=m)<br/>X = encoder.fit_transform(X, y)<br/><br/># Results<br/>score =  score_dataset(X, y)<br/>print(f"Score: {score:.4f} RMSLE")<br/><br/>Score: 0.0291 RMSLE</span></pre><pre class="lh kx ky kz bn la lb bi"><span id="d33d" class="lc ju hi ky b be ld le l lf lg">plt.figure(dpi=90)<br/>ax = sns.distplot(y, kde=True, hist=False)<br/>ax = sns.distplot(X["Count"], color='r', ax=ax, hist=True, kde=False, norm_hist=True)<br/>ax.set_xlabel("SalePrice");</span></pre><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/3ee7b213c543861ab46482c52eb8d8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6nfyCiQ5idozuVZot8tyw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Distribution plot of Count in comparison to SalePrice (Image from Kaggle)</figcaption></figure><p id="f806" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> RMSLE </strong>这次有所改进，并且<strong class="ix hj">分布图</strong>与之前的情况相比也非常吻合。</p><p id="3de6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于<strong class="ix hj">计数</strong>从不具有任何重复值，所以平均编码的<strong class="ix hj">计数</strong>本质上是目标的精确副本。换句话说，<strong class="ix hj">意味着编码</strong>把一个完全没有意义的特征变成了<strong class="ix hj">完美的特征</strong>。</p><p id="4d67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，这有效的唯一原因是我们<strong class="ix hj">在我们用来<strong class="ix hj">训练编码器</strong>的同一套设备上训练XGBoost </strong>。如果我们使用一个<strong class="ix hj">保持集</strong>来代替，这些“假”编码就不会转移到训练数据中。</p><p id="be1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，简而言之，当使用<strong class="ix hj">目标编码器</strong>时，使用<strong class="ix hj">单独的数据集</strong>用于<strong class="ix hj">训练编码器和训练模型</strong>非常重要。否则结果可能会很差！</p><p id="57de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是Kaggle整个<a class="ae iu" href="https://www.kaggle.com/learn/feature-engineering" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">特色工程</strong> </a>课程系列的结束。<strong class="ix hj">的目标编码</strong>部分是<a class="ae iu" href="https://www.kaggle.com/code/ryanholbrook/target-encoding" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">这里的</strong> </a>。</p><p id="df08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">务必通过<a class="ae iu" href="https://www.kaggle.com/code/ryanholbrook/feature-engineering-for-house-prices/notebook" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">这本笔记本</strong> </a>和实验来更多地了解特征工程。这将有助于尝试现实生活中最近的<a class="ae iu" href="https://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">数据集</strong> </a>。</p><p id="6b81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请查阅我的其他<a class="ae iu" rel="noopener" href="/@abhi2652254"> <strong class="ix hj">文章</strong> </a>，说<a class="ae iu" href="https://www.linkedin.com/in/obhinaba17/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">嗨</strong> </a> <strong class="ix hj">。</strong>还有，看看我的<a class="ae iu" href="https://github.com/abhigyan631" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> GitHub </strong> </a> <strong class="ix hj">。如果你喜欢我的作品，你可以给我捐赠几杯咖啡，这样我就可以在写作的道路上不断提高内容的质量。</strong></p></div></div>    
</body>
</html>
<html>
<head>
<title>Improve Performance of Web Application — React JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Web应用程序的性能— React JS</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/improve-performance-of-web-application-react-js-de5b5b0f5316?source=collection_archive---------20-----------------------#2021-06-20">https://medium.com/geekculture/improve-performance-of-web-application-react-js-de5b5b0f5316?source=collection_archive---------20-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b7991ef40804d94a9c88a61d51caf8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PInrah-AEk4kuJFkYqZLig.png"/></div></div></figure><p id="9469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">web应用程序中与性能相关的问题并不新鲜。开发人员几乎在他们从事的每个项目中都遇到过这些问题。React是这些语言中被认为在提供性能方面最好的一种。由于react的虚拟DOM在有效呈现组件方面很受欢迎，因此关注性能变得更加重要。</p><p id="cf34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这里有几个技巧，帮助我在提高lighthouse分数的同时提高了应用程序的性能</em>。</p><blockquote class="jp jq jr"><p id="59ec" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">删除所有内嵌功能</em> </strong></p></blockquote><p id="79ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React组件的render方法内部定义和传递的函数称为内联函数。</p><p id="cf31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过一个简单的例子来理解这一点，这个例子展示了一个内联函数在React应用程序中的样子。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="c070" class="ke kf hi ka b fi kg kh l ki kj">import { useState } from "react";</span><span id="e136" class="ke kf hi ka b fi kk kh l ki kj">export default function App() {<br/>    const [count, setCount] = useState(0);<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;<br/>            &lt;h1&gt;{count}&lt;/h1&gt;<br/>            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>                Increment<br/>            &lt;/button&gt;<br/>            &lt;button onClick={() =&gt; setCount(count -1)}&gt;<br/>                Decrement<br/>            &lt;/button&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="6fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，onClick属性作为调用setCount的内联函数被传递。该函数在render方法中定义，通常与JSX内嵌在一起。</p><p id="b26d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React应用程序的上下文中，我们经常看到这样的编码模式。这增加了应用程序的内存占用，即使道具没有改变，也总是会触发重新渲染。</p><p id="f057" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这主要是因为方法传递总是通过引用传递，因此它将创建一个新的函数并在每个渲染周期改变它的引用。</p><p id="bfba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解决方案:</strong></p><p id="080b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单的方法是将所有内联函数移到render方法之外，这样它就不会在每个渲染周期被重新定义。这将减少内存占用。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ae12" class="ke kf hi ka b fi kg kh l ki kj">import { useState } from "react";</span><span id="2b76" class="ke kf hi ka b fi kk kh l ki kj">export default function App() {<br/>    const [count, setCount] = useState(0);</span><span id="0ba3" class="ke kf hi ka b fi kk kh l ki kj">    const increment = () =&gt; {<br/>        setCount(count + 1);<br/>    }</span><span id="ff7c" class="ke kf hi ka b fi kk kh l ki kj">    const decrement = () =&gt; {<br/>        setCount(count -1);<br/>    }</span><span id="5f07" class="ke kf hi ka b fi kk kh l ki kj">    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;<br/>            &lt;h1&gt;{count}&lt;/h1&gt;<br/>            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>            &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><blockquote class="jp jq jr"><p id="bee6" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">使用Eslint-plugin-react </em> </strong></p></blockquote><p id="5d1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几乎所有的JavaScript项目都推荐使用ESLint插件，React也不例外。</p><p id="f3a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用eslint-plugin-react，我们将迫使自己适应react编程中的许多规则，这些规则从长远来看可以使我们的代码受益，并避免许多由于编写糟糕的代码而出现的常见问题。</p><blockquote class="jp jq jr"><p id="5ab7" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">依赖关系优化</em> </strong></p></blockquote><p id="7973" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在考虑优化应用程序包大小时，检查我们实际上从依赖项中利用了多少代码是值得的。</p><p id="848e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以开发人员广泛使用的lodash为例。它是一个JavaScript库，帮助程序员编写更简洁、更易维护的JavaScript。假设我们只使用了100多个可用方法中的20个，那么在最终的包中包含所有额外的方法并不是最佳的。</p><p id="dfac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，一种方法是只从组件的库中导入所需的方法。即</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="dbd9" class="ke kf hi ka b fi kg kh l ki kj">import orderBy from 'lodash/orderBy';<br/>import filter from 'lodash/filter';</span><span id="fa8a" class="ke kf hi ka b fi kk kh l ki kj">or</span><span id="6145" class="ke kf hi ka b fi kk kh l ki kj">import {filter, orderBy} from 'lodash';</span></pre><p id="ad74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong> -值得注意的是，混合这两种导入方式会导致净收益为负。基本上，这将导入整个lodash +单个实用程序两次。</p><p id="75f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种方法是使用lodash-webpack-plugin来删除库中未使用的方法。</p><blockquote class="jp jq jr"><p id="4d52" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">使用代码拆分移除未使用的JS——懒惰/悬念</em> </strong></p></blockquote><p id="9fd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大型react应用程序通常由许多组件、库、实用方法等组成。这里，我们需要付出一点努力，尝试只在需要的时候加载应用程序的不同部分。如果不为此付出努力，一旦用户加载第一页，就会有一个单独的JavaScript包输出给他们。</p><p id="9186" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们可以分开捆绑包，以确保这种情况永远不会发生。React.lazy方法使得使用动态导入在组件级别上拆分React应用程序中的代码变得容易。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="6bc7" class="ke kf hi ka b fi kg kh l ki kj">import React, { lazy, Suspense } from 'react';<br/>import LoadPage from './components/LoadPage';</span><span id="4372" class="ke kf hi ka b fi kk kh l ki kj">const GridComponent = lazy(() =&gt; import('./GridComponent'));</span><span id="efbd" class="ke kf hi ka b fi kk kh l ki kj">const HomeComponent = () =&gt; (<br/>    &lt;div&gt;<br/>        &lt;Suspense fallback={&lt;LoadPage /&gt;}&gt;<br/>            &lt;GridComponent /&gt;<br/>        &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>)</span><span id="add3" class="ke kf hi ka b fi kk kh l ki kj">export default HomeComponent;</span></pre><p id="4945" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React.lazy函数提供了一种内置的方法来分离应用程序中的组件。然后，分离的组件以分离的JavaScript块的形式出现，不费吹灰之力。然后，当我们将它与悬念组件耦合时，我们可以考虑加载状态。</p><blockquote class="jp jq jr"><p id="24bb" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">T5】启用压缩-GzipT7】</strong></p></blockquote><p id="91a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提高性能评分的最佳方法之一是在构建过程中进行压缩。使用这个，我们可以通过包<em class="jo"> gzipper </em> (npm install)压缩构建文件夹文件，并将其添加到package.json中。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="4445" class="ke kf hi ka b fi kg kh l ki kj">"scripts": {<br/>    ...<br/>    "build": "node scripts/build.js &amp;&amp; gzipper compress ./build",<br/>}</span></pre><p id="6348" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Gzip压缩模块可以将您的包大小从20%减少到25%。</p><p id="2b09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们还可以从服务器端进行压缩。如果我们使用node.js来服务构建文件夹，我们可以使用压缩包:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="447c" class="ke kf hi ka b fi kg kh l ki kj">const compression = require('compression');<br/>app.use(compression());</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="c246" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面提到的技术确实帮助我提高了应用程序的性能分数。还有很多方法可以优化React应用的性能。例如，使用服务工作者来缓存应用程序状态，使用useMemo，使用虚拟化长列表，避免不必要的渲染等等。</p><p id="e030" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读，希望这篇文章对你有所帮助。</p><p id="5029" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">原载于</em><a class="ae ks" href="https://codersread.com/improve-performance-of-web-application-react-js/" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://codersread.com</em></a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding React Higher Order Component (HOC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解反应高阶组件(HOC)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-react-higher-order-component-hoc-8e7a96820205?source=collection_archive---------2-----------------------#2022-05-09">https://medium.com/geekculture/understanding-react-higher-order-component-hoc-8e7a96820205?source=collection_archive---------2-----------------------#2022-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/84051f7dbdb490df52900360351976bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5neZqGE2i4C810idQQuc8Q.png"/></div></div></figure><p id="7120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几乎所有关于使用SPA库的事情都会影响您抽象业务逻辑和编写高质量的代码。React在过去的几年里一直在使用各种各样的<a class="ae jo" href="https://reactjs.org/docs/design-principles.html" rel="noopener ugc nofollow" target="_blank">惊人的设计模式</a>来实施这样的质量控制，我们对此并不陌生！</p><p id="50ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将讨论React使用更高阶组件的质量控制机制的一个附加部分。到本文结束时，您应该有信心并准备好在必要时通过使用这一原则来处理/改进代码库。</p><h1 id="a024" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是高阶分量？</h1><p id="7a01" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">高阶组件是一个很好的模式，已经被证明对几个React库非常有价值。根据<a class="ae jo" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>的反应——</p><blockquote class="ks"><p id="3533" class="kt ku hi bd kv kw kx ky kz la lb jn dx translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。本质上，hoc不是React API的一部分。它们是从React的组合性质中出现的一种模式。</p></blockquote><p id="2e69" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">JavaScript是一种非常适合函数式编程的语言，因为它可以接受高阶函数。高阶函数是可以将<strong class="is hj">另一个函数</strong>作为<strong class="is hj">参数</strong>和/或<strong class="is hj">返回函数</strong>作为结果的函数。</p><p id="bde4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">高阶函数允许我们抽象动作，而不仅仅是值。使用HOCs，我们可以包装我们的子组件，或者在其上添加业务逻辑，或者扩展子组件本身的功能。</p><h1 id="0512" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">HOCs能做什么？</h1><p id="b116" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在高级HOC中，您可以:</p><ul class=""><li id="644a" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">重用代码、重用逻辑和引导抽象</li><li id="552c" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">渲染劫持</li><li id="a3b9" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">状态抽象和操作</li><li id="cc8f" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">道具操作</li></ul><p id="74e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三方React库，如Redux或React路由器，经常使用hoc。我敢肯定，你已经使用了其中一些，甚至没有意识到这一点。</p><p id="ae61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React中，高阶组件的主要目的是在组件之间共享公共功能，而不必重复代码。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/f90587e8fed9bf876b55f613b5e704d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sr5uczdVV074XTxlnjYNVQ.png"/></div></div></figure><h1 id="37c7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">hoc的类型</h1><p id="3bbd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">React中实现hoc的两种主要方式是:</p><ul class=""><li id="609c" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><strong class="is hj">道具代理(PP) </strong></li><li id="c14b" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><strong class="is hj">遗传反转(二)</strong></li></ul><p id="9e62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两者都支持不同方式操作<em class="ma">包装组件</em>。两者都只是一个函数，它将一个组件作为参数，并生成一个包含<em class="ma"> WrappedComponent </em>的新组件。</p><h2 id="8c18" class="mb jq hi bd jr mc md me jv mf mg mh jz jb mi mj kd jf mk ml kh jj mm mn kl mo bi translated">道具代理</h2><p id="ed68" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Props代理，顾名思义，传递从高阶组件接收的属性。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="f99e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的关键元素是HOC的render方法返回WrappedComponent类型的React元素。特设接收我们通过道具传递的东西，因此命名为道具代理。HOC返回一个React元素，描述React应该在其协调过程中呈现什么。</p><p id="308b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以用其他JSX元素包装包装的组件，根据您的应用程序需求更改其UI。</p><p id="3852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Props代理hoc在以下情况下很有用:</p><ol class=""><li id="2038" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn mr ln lo lp bi translated">操纵道具</li><li id="0b90" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn mr ln lo lp bi translated">通过引用访问实例</li><li id="cb33" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn mr ln lo lp bi translated">抽象状态</li><li id="ee27" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn mr ln lo lp bi translated">用其他元素包装/组合包装组件</li></ol><h2 id="9071" class="mb jq hi bd jr mc md me jv mf mg mh jz jb mi mj kd jf mk ml kh jj mm mn kl mo bi translated"><strong class="ak">继承反转</strong></h2><p id="1e00" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">此特设可以访问WrappedComponents实例。这为我们提供了对状态、道具、组件生命周期挂钩和呈现方法的访问。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="1110" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，返回的HOC类(Enhancer)扩展了WrappedComponent。它被称为继承反转，因为不是WrappedComponent扩展某个增强器类，而是增强器被动地扩展它。这样，他们的关系就显得颠倒了。</p><p id="574f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">反转继承hoc适用于以下情况:</p><ol class=""><li id="8e9a" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn mr ln lo lp bi translated">渲染劫持</li><li id="5145" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn mr ln lo lp bi translated">操纵状态</li></ol><h1 id="e4fa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">让我们深入一些例子</h1><p id="d7e9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了牢固掌握我们所学的基础知识，让我们举一个应用程序的例子，这个应用程序只有一个输入，它接受一个名称并更改名称。</p><p id="6719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个场景，其中我们的业务应用程序需要大量的表单验证，并且不同的用例有不同的输入验证，在这种情况下，我们不需要重复代码并使用基于用例的组件制作多个输入表单，而是可以将它抽象成一个特设组件，它接受一个输入字段或更多的子组件，操纵状态以及操作(验证等)，并用每个用例所需的业务逻辑包装子组件。</p><p id="11aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑下面的例子-</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="1183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们将<code class="du ms mt mu mv b">Form</code>作为子组件，它被包装在<code class="du ms mt mu mv b">withHandlers</code> HOC的周围。它给了子组件自己的自由，不会用开销逻辑使基础组件过于复杂，并证明了关注点分离的合理性。</p><p id="6ca2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，开发人员可以控制添加/删除验证和任何认为合适的额外操作。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/2d15f6762080c6ed306ae660c964c339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRvkKF5ELoi09y67amneqw.png"/></div></div></figure><h1 id="06a5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="41d7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这是一个相对简单的例子，让您了解这些想法在实践中是如何工作的。习惯和适应这种类型的抽象需要一些时间，所以不要因为HOCs而失去动力或注意力。</p><p id="d332" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，一旦你觉得舒服并想要更深入和复杂的解释，我建议查看<a class="ae jo" rel="noopener" href="/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">这篇详细的博客</a>并探索其中的概念。</p><p id="73f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我错过了任何一点，或者你想讨论什么，请在下面留下评论，我会尽快加入。🌟</p><p id="0c3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，感谢您能深入到本文中，并对React表现出兴趣。你很了不起，每天都在做出积极的改变。再见。✌🏼</p></div></div>    
</body>
</html>
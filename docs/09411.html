<html>
<head>
<title>LeetCode — Best Time to Buy and Sell Stock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">leet code——买卖股票的最佳时机</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-best-time-to-buy-and-sell-stock-6bc3651ef78f?source=collection_archive---------18-----------------------#2021-12-09">https://medium.com/geekculture/leetcode-best-time-to-buy-and-sell-stock-6bc3651ef78f?source=collection_archive---------18-----------------------#2021-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8e27" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="7dfc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给你一个数组<em class="kb">价格</em>，其中<em class="kb">价格【I】</em>是给定股票在第天<em class="kb">的价格。</em></p><p id="02df" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你想通过选择一个<strong class="jf hj">单日</strong>买入一只股票，并选择未来的<strong class="jf hj">不同日</strong>卖出该股票，从而实现利润最大化。</p><p id="e8ba" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">返回<em class="kb">你从这笔交易</em>中可以获得的最大利润。如果你不能获得任何利润，返回<em class="kb"> 0 </em>。</p><p id="830c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/best-time-to-buy-and-sell-stock</a></p><p id="c647" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3c96" class="kr ig hi kn b fi ks kt l ku kv">Input: prices = [7, 1, 5, 3, 6, 4]<br/>Output: 5<br/>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br/>Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span></pre><p id="83a8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f4ab" class="kr ig hi kn b fi ks kt l ku kv">Input: prices = [7, 6, 4, 3, 1]<br/>Output: 0<br/>Explanation: In this case, no transactions are done and the max profit = 0.</span></pre><p id="21be" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b2e7" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= prices.length &lt;= 10^5 <br/>- 0 &lt;= prices[i] &lt;= 10^4</span></pre><h1 id="8b7d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="b936" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="b53c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的方法是使用两个嵌套的for循环，并获取两个数之间的最大差值。</p><p id="c47d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的一个C++片段如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ef87" class="kr ig hi kn b fi ks kt l ku kv">int maxProfit = 0;<br/><br/>for (int i = 0; i &lt; prices.length - 1; i++) {<br/>    for (int j = i + 1; j &lt; prices.length; j++) {<br/>        int profit = prices[j] - prices[i];<br/>        if (profit &gt; maxProfit)<br/>            maxProfit = profit;<br/>    }<br/>}<br/><br/>return maxProfit;</span></pre><p id="e648" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述程序的时间复杂度为<strong class="jf hj"> O(N ) </strong>。</p><h2 id="dad2" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">一次通过方法</h2><p id="76e8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们查看下图中几天的股票价值，我们需要考虑最大值和最小值。</p><figure class="ki kj kk kl fd lk er es paragraph-image"><div class="er es lj"><img src="../Images/fd699186bc8cc40b9ac8e58a072bdba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*vNc-JPteZ8WE_AU5.png"/></div></figure><p id="9404" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查下面的算法:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8b17" class="kr ig hi kn b fi ks kt l ku kv">- set maxP = 0<br/>      minP = INT_MAX<br/><br/>- loop for i = 0; i &lt; prices.size(); i++<br/>  - minP = min(minP, prices[i])<br/><br/>  - if prices[i] &gt; minP<br/>    - maxP = max(maxP, prices[i] - minP)<br/><br/>- return maxP</span></pre><p id="f3c3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的时间复杂度为<strong class="jf hj">O(log(N)】</strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="9c39" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9e9d" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int maxProfit(vector&lt;int&gt;&amp; prices) {<br/>        int maxP = 0;<br/>        int minP = INT_MAX;<br/><br/>        for(int i = 0; i &lt; prices.size(); i++){<br/>            minP = min(minP, prices[i]);<br/>            if(prices[i] &gt; minP){<br/>                maxP = max(maxP, prices[i] - minP);<br/>            }<br/>        }<br/><br/>        return maxP;<br/>    }<br/>};</span></pre><h2 id="e2ca" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="afc4" class="kr ig hi kn b fi ks kt l ku kv">const MaxUint = ^uint(0)<br/>const MaxInt = int(MaxUint &gt;&gt; 1)<br/><br/>func maxProfit(prices []int) int {<br/>    maxP := 0<br/>    minP := MaxInt<br/><br/>    for i := 0; i &lt; len(prices); i++ {<br/>        minP = int(math.Min(float64(minP), float64(prices[i])))<br/><br/>        if prices[i] &gt; minP {<br/>            maxP = int(math.Max(float64(maxP), float64(prices[i] - minP)))<br/>        }<br/>    }<br/><br/>    return maxP<br/>}</span></pre><h2 id="befa" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7c5a" class="kr ig hi kn b fi ks kt l ku kv">var maxProfit = function(prices) {<br/>    let maxP = 0;<br/>    let minP = Number.MAX_VALUE;<br/><br/>    for( let i = 0; i &lt; prices.length; i++ ) {<br/>        minP = Math.min(minP, prices[i]);<br/><br/>        if( prices[i] &gt; minP ) {<br/>           maxP = Math.max(maxP, prices[i] - minP);<br/>        }<br/>    }<br/><br/>    return maxP;<br/>};</span></pre><p id="7ba0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2b84" class="kr ig hi kn b fi ks kt l ku kv">Input: prices = [7, 1, 5, 3, 6, 4]<br/><br/>Step 1: maxP = 0<br/>        minP = INT_MAX<br/><br/>Step 2: loop for i = 0; i &lt; prices.size()<br/>        0 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(INT_MAX, prices[0])<br/>             = min(INT_MAX, 7)<br/>             = 7<br/><br/>        if prices[i] &gt; minP<br/>           prices[0] &gt; 7<br/>           7 &gt; 7<br/>           false<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: loop for i &lt; prices.size()<br/>        1 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(7, prices[1])<br/>             = min(7, 1)<br/>             = 1<br/><br/>        if prices[i] &gt; minP<br/>           prices[1] &gt; 1<br/>           1 &gt; 1<br/>           false<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: loop for i &lt; prices.size()<br/>        2 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(1, prices[2])<br/>             = min(1, 5)<br/>             = 1<br/><br/>        if prices[i] &gt; minP<br/>           prices[2] &gt; 1<br/>           5 &gt; 1<br/>           true<br/><br/>           maxP = max(maxP, prices[i] - minP)<br/>                = max(0, 5 - 1)<br/>                = max(0, 4)<br/>                = 4<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: loop for i &lt; prices.size()<br/>        3 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(1, prices[3])<br/>             = min(1, 3)<br/>             = 1<br/><br/>        if prices[i] &gt; minP<br/>           prices[3] &gt; 1<br/>           3 &gt; 1<br/>           true<br/><br/>           maxP = max(maxP, prices[i] - minP)<br/>                = max(4, 3 - 1)<br/>                = max(4, 2)<br/>                = 4<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: loop for i &lt; prices.size()<br/>        4 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(1, prices[4])<br/>             = min(1, 6)<br/>             = 1<br/><br/>        if prices[i] &gt; minP<br/>           prices[4] &gt; 1<br/>           6 &gt; 1<br/>           true<br/><br/>           maxP = max(maxP, prices[i] - minP)<br/>                = max(4, 6 - 1)<br/>                = max(4, 5)<br/>                = 5<br/><br/>        i++<br/>        i = 5<br/><br/>Step 7: loop for i &lt; prices.size()<br/>        5 &lt; 6<br/>        true<br/><br/>        minP = min(minP, prices[i]);<br/>             = min(1, prices[5])<br/>             = min(1, 4)<br/>             = 1<br/><br/>        if prices[i] &gt; minP<br/>           prices[5] &gt; 1<br/>           4 &gt; 1<br/>           true<br/><br/>           maxP = max(maxP, prices[i] - minP)<br/>                = max(5, 4 - 1)<br/>                = max(5, 3)<br/>                = 5<br/><br/>        i++<br/>        i = 6<br/><br/>Step 8: loop for i &lt; prices.size()<br/>        6 &lt; 6<br/>        false<br/><br/>Step 9: return maxP<br/><br/>So we return the answer as 5.</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="dc60" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-best-time-to-buy-and-sell-stock" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
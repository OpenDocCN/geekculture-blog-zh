# 类加载器来拯救我们了！

> 原文：<https://medium.com/geekculture/classloaders-to-the-rescue-7a3619e055dc?source=collection_archive---------5----------------------->

## 我如何使用 Java 的三个深奥、晦涩的特性来解决亚马逊的一个现实问题

![](img/e41400e6f00f4f3f71b9b375f112e165.png)

[[photo credit](https://alison.com/course/java-programming-for-complete-beginners)]

有时我读到 JVM 中一个怪异、深奥的特性，我认为没问题，没错，但是*这究竟是什么时候使用的***？回到 2013 年，我在亚马逊遇到了一个棘手的小问题，最终我使用了 JVM 中三个怪异、深奥的特性来解决它。**

*这一切都是在我需要对我的服务进行负载测试时开始的，所以我写了一堆负载生成代码。它负责以期望的速度执行事务(这样我就可以回答这样的问题，“当我的系统每秒接收 250，000 个事务时会发生什么？”).这听起来很容易，但在高吞吐量时就变得很棘手，需要小心的线程管理(提示: [ScheduledExecutorService](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html) 使用类固醇，但也分布在数百或数千台机器上)。它还允许混合事务类型:如果您想要对具有 3 个 APIs X、Y、Z 的 RPC 服务进行负载测试，您可以编写一段代码来模拟客户调用 X，一段代码来模拟客户调用 Y，另一段代码来模拟客户调用 Z。然后，您可以要求平台不仅以期望的速率执行您的代码，还以期望的操作混合来执行您的代码。 例如，以每秒 10，000 个事务的速度运行 30 分钟，70% X，20% Y，10% Z。最后，核心引擎汇总了运行的指标，如吞吐量、错误率和所有这些 RPC 调用随时间推移的百分比延迟等。 并创建了仪表板。*

*我意识到我为负载测试服务编写的大部分代码都是可重用的，因此其他人也可以利用它。我的框架是*通用的*，工程师可以编写他们的*特定于产品的代码*由它来执行。所以我决定清理它，重构它，并将它作为一个平台更广泛地提供给其他亚马逊人(我当时并不知道它，但这将[最终成为今天成千上万的服务使用的平台](https://carloarg02.medium.com/how-i-grew-an-engineering-productivity-tool-to-impact-thousands-of-engineers-at-amazon-and-how-28a990091207)以确保它们为峰值流量做好准备)。开放平台的愿望让我进入了向亚马逊的其他工程师出售我的软件的行业。*

*一些软件公司，比如谷歌，把他们的代码放在一个巨大的 monorepo 中。每个人都在同一个存储库中工作，拥有相同的依赖项，并构建相同的版本(head)。其他公司，如亚马逊，粒度更小，通常是每个团队。亚马逊称这些东西为*版本集*(“VS”)——它们是隔离的构建和运行时闭包(你的 Java [*类路径*](https://stackoverflow.com/questions/2396493/what-is-a-classpath-and-how-do-i-set-it) )。您为您的产品创建了一个 versionset，最初是空的。并且你添加 Java 包( [JARs](https://docs.oracle.com/javase/tutorial/deployment/jar/basicsindex.html) )到其中。这些 jar 将它们的依赖关系带入到您的 VS 中，因为它们需要它们来操作。这些依赖关系带来了它们的依赖关系，而依赖关系又带来了它们的依赖关系，以此类推。所以当你添加一个 JAR 到你的 VS 时，它会带来数百个可传递的 JAR。您的 VS 可能会很快变得臃肿(除非您定期清理未使用的包，否则它们将永远存在于其中)。为了保持稳定，VS 只接受特定版本的 Java 包。比如你把 *Log4j 2.14* 带进了你的 VS，如果有 Log4j 2.15 版本，你就得显式的带。这使得当依赖关系中有 API 变化时，你的 VS 不会中断。这就是" *versionset* "得名的原因:它是 Java JARs 和*版本*的一个独立*集合*，用作产品的构建和运行时闭包。*

*在单一回购的世界里，你只需要对你的客户说，“嘿！从存储库中的这个路径获取我的代码。”完成了。在 *versionset* 世界中，那些客户需要显式地将您的 Java 包导入到他们的 VS 中。这就是亚马逊销售软件的现状，只是说“嘿，把我的 Java 包 x.y 版带进你的 versionset，开始用吧！”*

*如果你想知道:我为什么不创建一个服务呢？那会解决这个问题。还有其他更复杂的原因，我当时不能将它作为服务出售。]*

*我不喜欢这种软件销售模式，原因有很多。*

*   *做一个好公民。我的依赖项被传递给客户的版本集。如果我有能力将数百个可传递的依赖项整合到亚马逊的数千个版本集中，那将是一个巨大的责任。有时，你会以依赖冲突结束(包 A 将 Foobar-2.1 带入我的 VS，但是包 B 将 Foobar-2.2 带入我的 versionset，我使用哪一个，如果它们不向后兼容会发生什么？Ahrhghghggghhhh！！！).你的 VS 被打破了，所以你需要放下你正在做的一切，在接下来的 5 个小时里依赖地狱，一个接一个地解决冲突。如果幸运的话，它会在编译时崩溃；如果你运气不好，在运行时。在亚马逊，这是一种通过仪式，包括哭泣、诅咒、牺牲你的第一个孩子，以及让你的同事同情你。*
*   ***创新的速度。**如果在我的 VS 中引入一个依赖项，当这个依赖项被添加到成千上万个客户版本集中时，它会被放大一千倍，这将使我对我引入的每个依赖项三思。这将扼杀创新和变革的交付速度。*
*   ***及时修复错误的能力。**一旦你的代码被导入到某人的 VS 中，它就不会再被刷新，直到他们明确地刷新它。大多数服务所有者定期刷新依赖项，有时是每晚一次，有时是每周一次，但有时是手动刷新，有时从不刷新。如果我推出了一个坏的 bug，就不可能确保 100%的有 bug 的 VSs 也得到修复。对于每一个紧急的 bug 修复，我都要给我所有的客户开罚单，让他们尽快更新他们的 VS，这对他们来说是一个巨大的不便。*
*   ***可预测的操作。**在为我的平台提供运营支持方面，我的平台有多个版本，这意味着该平台可能会因不同的客户而表现不同，因此这可能会成为一场运营噩梦，不得不询问您所帮助的人他们使用的是哪个版本的平台，然后不得不记住该特定版本的特点。*
*   ***客户体验&入职成本。入职体验非常辛苦:将我的 JAR 引入您的版本集，处理所有的依赖冲突，更改您的 ant 构建文件，将您自己的 main()导出并部署为独立的可执行文件。平均来说，需要几天时间。我想要它立即生效:输入一个命令，它就能工作了！***

*我不喜欢现状的一切。我需要跳出框框思考。*

# *类加载器来拯救我们了！*

*基本问题是，如果你有一段构建在一个 VS(我的框架)中的代码，而你试图使用一个不同 VS(客户的)中的 JAR，JVM 会不高兴，因为它们有不同的构建和运行时闭包。我和我的一位导师 [Cary](https://www.linkedin.com/in/cary-hall-3970a61/) (亚马逊的一位负责人)聊天，他不经意地提到了类加载器。我对类加载器一无所知，但我的朋友[特雷弗](https://www.linkedin.com/in/trevorpounds/)知道，他帮我启动了这个东西。*

> *什么是 [Java 类加载器](https://en.wikipedia.org/wiki/Java_Classloader)？Java 类加载器是 Java 运行时环境的一部分，它将 Java 类动态加载到 Java 虚拟机中。通常类是按需加载的。Java 运行时系统不需要了解文件和文件系统，因为这是委托给类加载器的。*

*通常，您很少考虑类装入器。当你需要的时候，类会被神奇地加载。怎么会？不是我的问题。大多数程序都有一个简单的类路径，所以事情很简单。您通常不会考虑这些类实际上是如何加载的。*

*原来，您可以让多个****类加载器*** 运行在同一个 JVM 中，这为您提供了类路径*隔离*。我也可以通过运行不同的进程并通过套接字进行通信来实现这一点，但这是针对每秒需要执行数十万次的代码，因此性能非常重要。我分析并验证了同一个 JVM 中的两个类装入器比两个 JVM 要快得多。**

**特雷弗是对的:这似乎是我这个小问题的一个潜在的好解决方案。这将允许我拥有同一个依赖项的多个版本，一个在负责平台代码的类加载器中，一个在负责客户代码的类加载器中，彼此愉快地共存。**

**我的平台在主要的默认类加载器中启动。然后创建一个子类加载器，并将客户 JAR(及其依赖项)加载到子类加载器中。成功了！**

**我确实遇到了一个小问题。Java 的默认类加载器行为是**父母优先策略**。这意味着每当需要加载一个类时，它将首先在父上下文中搜索，如果没有找到，它将在子上下文中搜索。这通常是有意义的，但在我的情况下，这意味着我的客户的代码可能最终会使用*我的*依赖项，而不是*他们的*，这导致了非常微妙的运行时故障，非常难以调试和理解。所以 [Daniel](https://www.linkedin.com/in/daniel-a-jeffery/) 和我最终编写了我们自己的类加载器，改用**子优先策略**(关于[父优先和子优先类加载器](/@isuru89/java-a-child-first-class-loader-cbd9c3d0305)委托的好文章)。偶尔会有一些奇怪的类有自己的类加载器逻辑(log4j，我在看着你……)，所以我们甚至必须在类加载器中有一些自定义逻辑来区别对待它们。**

**不过，我有个更大的问题。JVM 不认为从类加载器 A 加载的类可以*转换为从类加载器 b 加载的完全相同的类。但是如果它们生活在不同的类装入器中，JVM 认为它们是不同的。***

# **反思拯救！**

**我使用了 JVM 的一个晦涩难懂的特性来解决第一个问题(创建一个辅助类加载器来加载具有冲突依赖关系的客户代码)。所以我求助于 JVM 的另一个晦涩难懂的特性来解决我的第二个问题(从一个类加载器调用另一个类加载器中的代码):反射。**

> **什么是 Java 反射？从这里的[到](https://www.geeksforgeeks.org/reflection-in-java/)，“反射是一个 API，用于在运行时检查或修改方法、类、接口的行为。”**

**反射看起来很丑，但却无比强大。假设我想从我的二级类装入器调用一个对象 foo 中的方法 doSomething。不要这样做:**

```
**foo.doSomething();**
```

**我可以这样做:**

```
**Method method = foo.getClass().getMethod("doSomething", null);
method.invoke(foo, null);**
```

**这是一段可怕而冗长的代码，但是它在类加载器上运行得非常好！当这些方法调用中包含参数时，情况会变得更加糟糕。**

# **救援的注解！**

**我还有一个决定要做。传统上，要编写在框架内执行的代码，框架会公开一个 Java 接口，您必须创建一个实现该接口的 Java 类。这是一个很好的尝试过的方法，但是我不喜欢其中的一些东西。第一，有时客户已经有了行为类似于事务 X、Y 和 z 的测试代码，所以我不想强迫他们不得不重构它或者拥有它的多个副本。其次，我不能 100%确定我已经解决了确切的接口，我怀疑随着我的平台获得更多的客户，许多情况会浮出水面，所以我想加强 API，但为增长留有余地。我没有使用 Java 接口，而是转向了 JVM 的另一个有点深奥的特性:注释。**

> **什么是 Java 注释？从[到这里](https://docs.oracle.com/javase/tutorial/java/annotations/) : Java 注释用来为你的 Java 代码提供元数据。这些可以是运行时指令，告诉其他人如何处理你的代码。**

**注释被证明是一个优雅的解决方案，它解决了我如何发展我的平台，并保持它的灵活性，同时拥有一个相当坚固的 API 的问题。注释可以编码各种有趣的元数据，让我的客户告诉我的平台。您可以注释初始化代码、终止代码和事务。 [TestNG](https://www.tutorialspoint.com/testng/testng_basic_annotations.htm) 和 [jUnit](https://www.guru99.com/junit-annotations-api.html) 都在这方面做得很好，有@BeforeClass、@BeforeTest、@Test、@DataProviders 等等，所以我从 TestNG 那里获得了很多灵感。您可以在几分钟内注释预先存在的代码，并进行工作负载测试！**

# **奇迹般地，这一切都成功了！**

**在我最终的解决方案中，我通过一个包含注释的接口包出售我的软件。客户将接口包引入到他们的 VS 中。因为它只是一个接口，所以它没有将依赖项引入到他们的 VS 中，只是引入了它本身。而且因为界面被加固了，我不用担心客户会定期刷新界面。这个界面提供了一堆注释，所以它给了我将来扩展它的灵活性。最后，由于我将自己的闭包加载到了主类加载器中，将客户的闭包加载到了辅助类加载器中，不兼容的类可以愉快地共存。**

**说实话，让这一切发生所必需的代码可能是我写过的最丑的代码。用于处理类加载器、反射和注释的 API 非常强大，但它们并不特别优雅或漂亮，我的代码也是如此。但是它是有效的，而且它已经在生产中存活了十年，当你正在阅读这个故事的时候，每秒钟在生产中被执行数百万次。权衡对我来说是产品的复杂性，还是对我的客户来说是更复杂的入门故事，所以我选择了前者。客户体验永远是赢家。我认为这与亚马逊的产品使用量增长到成千上万的服务有很大关系，每天都在使用它来验证它们是否可以扩展。事实上，它今天还在运行，这证明了那些设计选择经得起时间的考验。**

**下次你看到一个深奥的特性时，就想一想:也许有一天它会成为你所需要的！**
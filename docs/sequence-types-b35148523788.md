# 序列类型

> 原文：<https://medium.com/geekculture/sequence-types-b35148523788?source=collection_archive---------5----------------------->

![](img/5ac8ca7f9c201cadba3a240c20a5a466.png)

ryan putra — unsplash

序列类型具有第一个元素、第二个元素等等的一般概念。基本上是使用自然数对序列项进行排序。在 Python(和许多其他语言)中，起始索引被设置为`0`，而不是`1`。

所以第一个条目有索引`0`，第二个条目有索引`1`，以此类推。

Python 有内置的可变和不可变序列类型。

字符串、元组是不可变的——我们可以访问但不能修改**序列**的**内容**:

在:

```
t **=** (1, 2, 3)t[0]
```

出局:

```
1
```

在:

```
t[0] **=** 100**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-3-155b9e8fb284>** in <module>**()**
**----> 1** t**[0]** **=** **100****TypeError**: 'tuple' object does not support item assignment
```

但是当然，如果序列包含可变对象，那么尽管我们不能修改元素序列(不能替换、删除或插入元素)，我们肯定**可以**改变可变对象的内容:

在:

```
t **=** ( [1, 2], 3, 4)
```

`t`是不可变的，但是它的第一个元素是一个可变对象:

在:

```
t[0][0] **=** 100t
```

出局:

```
([100, 2], 3, 4)
```

## 可重复的

一个**可迭代的**就是可以迭代的东西，例如使用一个`for`循环:

在:

```
t **=** (10, 'a', 1**+**3j)s **=** {10, 'a', 1**+**3j}**for** c **in** t:print(c)Out:10
a
(1+3j)
```

在:

```
**for** c **in** s:print(c)Out:a
10
(1+3j)
```

请注意我们是如何迭代元组和集合的。迭代元组保留了元组中元素的**顺序**，但不是集合的顺序。集合没有元素的顺序，它们是可迭代的，但不是序列。

大多数序列类型支持`in`和`not in`操作。范围也可以，但不如列表、元组、字符串等有效。

在:

```
'a' **in** ['a', 'b', 100]
```

出局:

```
True
```

在:

```
100 **in** range(200)
```

出局:

```
True
```

## 最小、最大和长度

序列通常还支持`len`方法来获取集合中的项目数。一些 iterables 可能也支持该方法。

在:

```
len('python'), len([1, 2, 3]), len({10, 20, 30}), len({'a': 1, 'b': 2})
```

出局:

```
(6, 3, 3, 2)
```

序列(甚至一些 iterables)可能支持`max`和`min`，只要集合中的数据类型在某种意义上可以**排序**(`<`或`>`)。

在:

```
a **=** [100, 300, 200]min(a), max(a)
```

出局:

```
(100, 300)
```

在:

```
s **=** 'python'min(s), max(s)
```

出局:

```
('h', 'y')
```

在:

```
s **=** {'p', 'y', 't', 'h', 'o', 'n'}min(s), max(s)
```

出局:

```
('h', 'y')
```

但是如果元素没有定义排序:

在:

```
a **=** [1**+**1j, 2**+**2j, 3**+**3j]min(a)**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-17-b0cd79e53377>** in <module>**()**
      1 a **=** **[1+1j,** **2+2j,** **3+3j]**
**----> 2** min**(**a**)****TypeError**: '<' not supported between instances of 'complex' and 'complex'
```

`min`和`max`将适用于异构类型，只要元素是成对可比较的(`<`或`>`已定义)。

例如:

在:

```
**from** decimal **import** Decimalt **=** 10, 20.5, Decimal('30.5')min(t), max(t)
```

出局:

```
(10, Decimal('30.5'))
```

在:

```
t **=** ['a', 10, 1000]min(t)**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-21-983eac063887>** in <module>**()**
      1 t **=** **['a',** **10,** **1000]**
**----> 2** min**(**t**)****TypeError**: '<' not supported between instances of 'int' and 'str'
```

甚至`range`对象支持`min`和`max`:

在:

```
r **=** range(10, 200)min(r), max(r)
```

出局:

```
(10, 199)
```

## 串联

我们可以使用`+`操作符**连接**序列:

在:

```
[1, 2, 3] **+** [4, 5, 6]
```

出局:

```
[1, 2, 3, 4, 5, 6]
```

在:

```
(1, 2, 3) **+** (4, 5, 6)
```

出局:

```
(1, 2, 3, 4, 5, 6)
```

请注意，串联结果的类型与被串联的序列的类型相同，因此串联不同类型的序列将不起作用:

在:

```
(1, 2, 3) **+** [4, 5, 6]**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-25-67a9e2ed8695>** in <module>**()**
**----> 1 (1,** **2,** **3)** **+** **[4,** **5,** **6]****TypeError**: can only concatenate tuple (not "list") to tuple
```

在:

```
'abc' **+** ['d', 'e', 'f']**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-26-8cbdd441adc1>** in <module>**()**
**----> 1 'abc'** **+** **['d',** **'e',** **'f']****TypeError**: must be str, not list
```

注意:如果你真的想连接不同的类型，你必须先把它们转换成一个通用类型:

在:

```
(1, 2, 3) **+** tuple([4, 5, 6])
```

出局:

```
(1, 2, 3, 4, 5, 6)
```

在:

```
tuple('abc') **+** ('d', 'e', 'f')
```

出局:

```
('a', 'b', 'c', 'd', 'e', 'f')
```

在:

```
''.join(tuple('abc') **+** ('d', 'e', 'f'))
```

出局:

```
'abcdef'
```

## 重复

大多数序列类型还支持**重复**，本质上是将相同的序列串联整数次:

在:

```
'abc' ***** 5
```

出局:

```
'abcabcabcabcabc'
```

在:

```
[1, 2, 3] ***** 5
```

出局:

```
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

我们一会儿将回到连接和重复的一些注意事项。

## 按顺序寻找事物

我们可以找到一个元素在序列中出现的索引:

在:

```
s **=** "gnu's not unix"s.index('n')
```

出局:

```
1
```

在:

```
s.index('n', 1), s.index('n', 2), s.index('n', 8)
```

出局:

```
(1, 6, 11)
```

如果找不到该元素，就会引发一个异常，所以如果不想让应用程序崩溃，就要捕捉它:

在:

```
s.index('n', 13)**---------------------------------------------------------------------------**
**ValueError**                                Traceback (most recent call last)
**<ipython-input-35-d038ca109973>** in <module>**()**
**----> 1** s**.**index**('n',** **13)****ValueError**: substring not found
```

在:

```
**try**:idx **=** s.index('n', 13)**except** ValueError:print('not found')Out:not found
```

请注意，这些在序列中查找对象的方法并不假设序列中的对象以任何方式排序。这些基本上是在序列中搜索迭代，直到找到(或找不到)所请求的元素。

如果您有一个排序的序列，那么其他搜索技术也是可用的，比如二进制搜索。我将在本课程的附加部分讲述其中的一些主题。

## 限幅

我们将在后面的讲座中回到切片，但是序列类型通常支持切片，甚至范围(从 Python 3.2 开始)。就像拼接一样，切片将返回与被切片的序列相同的类型:

在:

```
s **=** 'python'l **=** [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]s[0:3], s[4:6]
```

出局:

```
('pyt', 'on')
```

在:

```
l[0:3], l[4:6]
```

出局:

```
([1, 2, 3], [5, 6])
```

可以将范围扩展到序列界限之外:

在:

```
s[4:1000]
```

出局:

```
'on'
```

如果你的第一个参数是`0`，你甚至可以省略它。省略第二个参数意味着它将包括所有剩余的元素:

在:

```
s[0:3], s[:3]
```

出局:

```
('pyt', 'pyt')
```

在:

```
s[3:1000], s[3:], s[:]
```

出局:

```
('hon', 'hon', 'python')
```

我们甚至可以扩展切片，提供开始、停止和一个步骤:

在:

```
s, s[0:5], s[0:5:2]
```

出局:

```
('python', 'pytho', 'pto')
```

在:

```
s, s[::2]
```

出局:

```
('python', 'pto')
```

从技术上讲，我们也可以在切片中使用负值，包括扩展切片(稍后将详细介绍):

在:

```
s, s[**-**3:**-**1], s[::**-**1]
```

出局:

```
('python', 'ho', 'nohtyp')
```

在:

```
r **=** range(11)  *# numbers from 0 to 10 (inclusive)*print(r)print(list(r))Out:range(0, 11)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

在:

```
print(r[:5])Out:range(0, 5)
```

在:

```
print(list(r[:5]))[0, 1, 2, 3, 4]
```

正如您所看到的，对一个范围进行切片也会像预期的那样返回一个 range 对象。

## 散列法

不可变序列通常支持一个`hash`方法，我们将在映射类型一节中详细讨论这个方法:

在:

```
l **=** (1, 2, 3)hash(l)
```

出局:

```
2528502973977326415
```

在:

```
s **=** '123'hash(s)
```

出局:

```
-1892188276802162953
```

在:

```
r **=** range(10)hash(r)
```

出局:

```
-6299899980521991026
```

但是可变序列(以及一般的可变类型)不会:

在:

```
l **=** [1, 2, 3]hash(l)**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-54-22dd9c98a095>** in <module>**()**
**----> 1** hash**(**l**)****TypeError**: unhashable type: 'list'
```

另请注意，如果一个可哈希序列的一个(或多个)元素不可哈希，则该序列不再可哈希:

在:

```
t **=** (1, 2, [10, 20])hash(t)**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-55-30cac1c4a226>** in <module>**()**
      1 t **=** **(1,** **2,** **[10,** **20])**
**----> 2** hash**(**t**)****TypeError**: unhashable type: 'list'
```

但这是可行的:

在:

```
t **=** ('python', (1, 2, 3))hash(t)
```

出局:

```
-8790163410081325536
```

一般来说，不可变类型可能是可散列的，而不可变类型则不是。因此，数字、字符串、元组等是可散列的，但列表和集合不是:

在:

```
**from** decimal **import** Decimald **=** Decimal(10.5)hash(d)
```

出局:

```
1152921504606846986
```

集合不可散列:

在:

```
s **=** {1, 2, 3}hash(s)**---------------------------------------------------------------------------**
**TypeError**                                 Traceback (most recent call last)
**<ipython-input-58-2216931a6bc4>** in <module>**()**
      1 s **=** **{1,** **2,** **3}**
**----> 2** hash**(**s**)****TypeError**: unhashable type: 'set'
```

但是冻结集合，集合的不可变变体，是:

在:

```
s **=** frozenset({1, 2, 3})hash(s)
```

出局:

```
-7699079583225461316
```

## 连接和重复的注意事项

考虑一下这个:

在:

```
x **=** [2000]id(x[0])
```

出局:

```
2177520743920
```

在:

```
l **=** x **+** xl
```

出局:

```
[2000, 2000]
```

在:

```
id(l[0]), id(l[1])
```

出局:

```
(2177520743920, 2177520743920)
```

不出所料，`l[0]`和`l[1]`中的物体是一样的。

也可以使用:

在:

```
l[0] **is** l[1]
```

出局:

```
True
```

如果被连接的对象是不可变的，这没什么大不了。但是如果它们是可变的:

在:

```
x **=** [ [0, 0] ]l **=** x **+** xl
```

出局:

```
[[0, 0], [0, 0]]
```

在:

```
l[0] **is** l[1]
```

出局:

```
True
```

然后我们有了以下内容:

在:

```
l[0][0] **=** 100l[0]
```

出局:

```
[100, 0]
```

在:

```
l
```

出局:

```
[[100, 0], [100, 0]]
```

请注意，更改第一个元素的第一项也会更改第二个元素的第一项。

正如我们刚才所做的，当使用`+`操作符连接时，这看起来相当明显，同样的情况实际上发生在重复中，可能看起来不那么明显:

在:

```
x **=** [ [0, 0] ]m **=** x ***** 3m
```

出局:

```
[[0, 0], [0, 0], [0, 0]]
```

在:

```
m[0][0] **=** 100m
```

出局:

```
[[100, 0], [100, 0], [100, 0]]
```

而事实上，连`x`都变了:

在:

```
x
```

出局:

```
[[100, 0]]
```

如果你真的想让这些重复的对象成为不同的对象，你必须以某种方式复制它们。简单的列表理解在这里很有用:

在:

```
x **=** [ [0, 0] ]m **=** [e.copy() **for** e **in** x*****3]m
```

出局:

```
[[0, 0], [0, 0], [0, 0]]
```

在:

```
m[0][0] **=** 100m
```

出局:

```
[[100, 0], [0, 0], [0, 0]]
```

在:

```
x
```

出局:

```
[[0, 0]]
```
<html>
<head>
<title>How I Implement Hexagonal Architecture in AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在AWS Lambda中实现六边形架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-implement-hexagonal-architecture-in-aws-lambda-469dad23727a?source=collection_archive---------15-----------------------#2022-01-27">https://medium.com/geekculture/how-i-implement-hexagonal-architecture-in-aws-lambda-469dad23727a?source=collection_archive---------15-----------------------#2022-01-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/68350dd8d1d6b61741b64322d943a680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxQZIi3PkrwNMbp0"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@drmakete?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">drmakete lab</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e2b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在re:Invent 2021上，我了解到了六边形建筑。我是一个好奇的人，所以我开始深入调查。像大多数架构概念一样，我找不到很多六边形架构实现的例子。我又看到了我自己的关于六边形建筑的文章，或者一些复制粘贴的内容农场的文章，这些文章从阿利斯泰尔·考克伯恩最初的文章中提取了一些流行词汇，并把它变成了他们自己的。</p><p id="9e07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快进到本周，我在YouTube上偶然发现了一个名为<a class="ae iu" href="https://www.youtube.com/watch?v=qZEMSK6S0QM" rel="noopener ugc nofollow" target="_blank">六角形建筑实例</a>的视频。这是我最初寻找的，它激励我完成我对这个架构的理解。观看视频很有帮助，但他们提供的GitHub repo是我更好理解的捷径。对我来说，拥有相同代码的好版本和坏版本是一个关键。他们还使用了与我参加的re:Invent talk 中演示的<a class="ae iu" href="https://github.com/aws-samples/aws-Lambda-hexagonal-architecture" rel="noopener ugc nofollow" target="_blank">代码库略有不同的名称。</a></p><p id="0c03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我从未听说过<code class="du jt ju jv jw b">domains</code>、<code class="du jt ju jv jw b">ports</code>和<code class="du jt ju jv jw b">adapters</code>，但我确实知道这个新发现的回购协议中使用的<code class="du jt ju jv jw b">handlers</code>和<code class="du jt ju jv jw b">repositories</code>，这让我明白了我的第一点:命名大多是随意的，使用和上下文边界才是重要的。这两个代码库做了同样的事情，但是命名略有不同。想法是请求可以进入<code class="du jt ju jv jw b">adapter</code>，然后<code class="du jt ju jv jw b">adapter</code>通过<code class="du jt ju jv jw b">port</code>与业务逻辑<code class="du jt ju jv jw b">domain</code>通信。如果业务逻辑需要发起与其边界之外的任何东西的通信，那么它也将通过一个<code class="du jt ju jv jw b">port</code>与另一个<code class="du jt ju jv jw b">adapter</code>通信。</p><p id="d3a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我能够开始阅读和理解回购协议中的代码，并理解上下文边界所在，但我仍然有点困惑，为什么我们需要<code class="du jt ju jv jw b">port</code> s。两个回购的例子都表明<code class="du jt ju jv jw b">port</code> s仅仅是一个传递，那么为什么不让<code class="du jt ju jv jw b">adapter</code>调用业务逻辑，而业务逻辑调用<code class="du jt ju jv jw b">adapter</code> s呢？这个答案是我在软件工程界反复看到的。</p><p id="b972" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是一个常用的缩写词，它给了我们OOP的原则。<code class="du jt ju jv jw b">D</code>代表<a class="ae iu" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>，这意味着代码应该依赖抽象，而不是实现功能的代码。在六边形架构的上下文中，<code class="du jt ju jv jw b">port</code> s是抽象，<code class="du jt ju jv jw b">adapter</code> s和业务逻辑是实现功能的代码。一个<code class="du jt ju jv jw b">port</code>通常使用一个接口来实现，但是它在概念上是一个<code class="du jt ju jv jw b">adapter</code>和请求与响应的业务逻辑之间的契约，类似于一个<a class="ae iu" href="https://thomasstep.com/blog/api-gateway-models" rel="noopener ugc nofollow" target="_blank"> API模型</a>。</p><p id="81ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">带着我对六边形架构的新认识，我回顾了我过去的一些项目，想看看我离实现这个架构还有多远。事实证明，我差得不远。我们可以快速浏览一下较小的Lambda，了解一下我曾经拥有的东西，然后我将重构我的代码以适应六边形架构，并突出显示我在此过程中所做的更改。简单来说，这段代码是我编写的日历API的Lambda处理程序。这个特定的端点在路径<code class="du jt ju jv jw b">/calendars/{calendarId}/events</code>下为日历创建一个事件，其中<code class="du jt ju jv jw b">{calendarId}</code>被用户替换为他们想要修改的先前创建的日历的ID。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="4378" class="kf kg hi jw b fi kh ki l kj kk">/**<br/> * File: index.js<br/> */<br/><br/>const events = require('/opt/database/events');<br/>const { getDateRange } = require('/opt/getDateRange');<br/>const { logger } = require('/opt/logger');<br/><br/>exports.handler = async function (event, context, callback) {<br/>  try {<br/>    const calendarId = event.pathParameters.calendarId;<br/>    const body = JSON.parse(event.body);<br/><br/>    // Create Dates<br/>    let startTime;<br/>    let endTime;<br/>    try {<br/>      startTime = new Date(body.startTime);<br/>      endTime = new Date(body.endTime);<br/>    } catch (err) {<br/>      logger.error('startTime and endTime are not ISO 8601 format.');<br/>      const errorPayload = {<br/>        statusCode: 400,<br/>        body: JSON.stringify({<br/>          errorMessage: 'startTime and endTime must be ISO 8601 timestamps e.g. 1995-12-13T03:24:00Z.',<br/>        }),<br/>      };<br/>      return errorPayload;<br/>    }<br/><br/>    // Check start comes after end<br/>    if (!(startTime &lt; endTime)) {<br/>      logger.error('startTime is not earlier than endTime.');<br/>      const errorPayload = {<br/>        statusCode: 400,<br/>        body: JSON.stringify({<br/>          errorMessage: 'startTime must come before endTime.',<br/>        }),<br/>      };<br/>      return errorPayload;<br/>    }<br/><br/>    const dates = getDateRange(startTime, endTime);<br/>    const eventId = await events.create(calendarId, dates, body);<br/><br/>    const data = {<br/>      statusCode: 200,<br/>      body: JSON.stringify({<br/>        id: eventId,<br/>      }),<br/>    };<br/>    return data;<br/>  } catch (uncaughtError) {<br/>    logger.error(uncaughtError);<br/>    throw uncaughtError;<br/>  }<br/>}<br/><br/>/**<br/> * File: /opt/database/events.js<br/> */<br/><br/>const { documentClient } = require('./databaseSession');<br/>const { generateToken } = require('../generateToken');<br/><br/>async function create(calendarId, dates, event) {<br/>  const eventId = generateToken();<br/>  const batchWritePayload = {};<br/>  // Construct batchWritePayload<br/>  await documentClient.batchWrite(batchWritePayload);<br/><br/>  return eventId;<br/>}<br/><br/>module.exports = {<br/>  create,<br/>};</span></pre><p id="dbf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，由于过去的经验，我已经将数据库功能从业务逻辑中完全分离出来。然而，数据库调用是实现功能的代码，所以我的业务逻辑应该通过抽象(<code class="du jt ju jv jw b">port</code>)与它通信，而不是直接通信。我的Lambda的业务逻辑也知道我的数据模型，知道我正在使用DynamoDB，因为<code class="du jt ju jv jw b">getDateRange</code>调用只用于NoSQL数据库。(这是一个实现细节，我不认为这对理解重构是必要的。主要的一点是，我的业务逻辑知道特定于数据库的实现细节。)</p><p id="7db4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的传入<code class="du jt ju jv jw b">adapter</code>将会把特定于Lambda函数的调用转换成我的业务逻辑运行所需的参数，然后通过<code class="du jt ju jv jw b">port</code>与我的业务逻辑进行通信。目前，没有传入的<code class="du jt ju jv jw b">adapter</code>或<code class="du jt ju jv jw b">port</code>。</p><p id="b78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们处理即将到来的<code class="du jt ju jv jw b">adapter</code>和<code class="du jt ju jv jw b">port</code>。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="306d" class="kf kg hi jw b fi kh ki l kj kk">/**<br/> * File: index.js<br/> */<br/><br/>const { InputError } = require('/opt/errors');<br/>const {<br/>  GOOD_STATUS_CODE,<br/>  BAD_INPUT_STATUS_CODE,<br/>  SERVER_ERROR_STATUS_CODE,<br/>} = require('/opt/config');<br/>const { logger } = require('/opt/logger');<br/><br/>const { port } = require('./port');<br/><br/>exports.handler = async function (event, context, callback) {<br/>  try {<br/>    const calendarId = event.pathParameters.calendarId;<br/>    const body = JSON.parse(event.body);<br/><br/>    const eventId = await port(calendarId, body);<br/>    const data = {<br/>      statusCode: GOOD_STATUS_CODE,<br/>      body: JSON.stringify({<br/>        id: eventId,<br/>      }),<br/>    };<br/>    return data;<br/>  } catch (err) {<br/>    logger.error(err);<br/>    let statusCode = SERVER_ERROR_STATUS_CODE;<br/>    let message = 'Internal server error';<br/><br/>    if (err instanceof InputError) {<br/>      statusCode = BAD_INPUT_STATUS_CODE;<br/>      message = err.message;<br/>    }<br/><br/>    const errorPayload = {<br/>      statusCode,<br/>      body: JSON.stringify({<br/>        message,<br/>      }),<br/>    };<br/><br/>    return errorPayload;<br/>  }<br/>}<br/><br/>/**<br/> * File: port.js<br/> */<br/><br/>const { InputError } = require('/opt/errors');<br/><br/>const { logic } = require('./logic');<br/><br/>exports.port = async function (calendarId, payload) {<br/>  // Validate input format<br/>  try {<br/>    startTime = new Date(payload.startTime);<br/>    endTime = new Date(payload.endTime);<br/>  } catch (err) {<br/>    throw new InputError('startTime and endTime must be ISO 8601 timestamps e.g. 1995-12-13T03:24:00Z.');<br/>  }<br/><br/>  // Construct event based on contract<br/>  const event = {<br/>    title: payload.title,<br/>    startTime: payload.startTime,<br/>    endTime: payload.endTime,<br/>  };<br/><br/>  const eventId = await logic(calendarId, event);<br/>  return eventId;<br/>}</span></pre><p id="ec74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进行重构的时候，我决定保持Lambda配置完全不变，只移动代码，因此传入的<code class="du jt ju jv jw b">adapter</code>将保持为<code class="du jt ju jv jw b">index.handler</code>。因为这是传入的<code class="du jt ju jv jw b">adapter</code>，所以它需要做的就是解析出<code class="du jt ju jv jw b">port</code>所需的参数，调用<code class="du jt ju jv jw b">port</code>，然后返回给客户端。这就是它所做的一切。用于清理这段代码的其他附加内容是<code class="du jt ju jv jw b">InputError</code>和<code class="du jt ju jv jw b">*_STATUS_CODE</code>常量。我希望能够抛出和处理自定义错误，并摆脱“幻数”</p><p id="77cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">port</code>可能是一个简单的传递，但是我也想在将参数抛给我的业务逻辑之前添加一点验证。旧的处理程序中存在<code class="du jt ju jv jw b">Date</code>创建验证。基于我与<code class="du jt ju jv jw b">logic</code>函数的契约构建<code class="du jt ju jv jw b">event</code>可能有点大材小用，因为在我的API网关中我也为这个端点设置了一个模型，但我会追求可重用性和适当的抽象。完全验证和构建<code class="du jt ju jv jw b">logic</code>的<code class="du jt ju jv jw b">event</code>确保了无论什么调用我的<code class="du jt ju jv jw b">port</code>抽象都无关紧要。这个<code class="du jt ju jv jw b">port</code>应该照顾到任何细节，从而成为一个适当的抽象。</p><p id="975d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我看的下一段代码是业务逻辑本身。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="4c10" class="kf kg hi jw b fi kh ki l kj kk">/**<br/> * File: logic.js<br/> */<br/><br/>const { InputError } = require('/opt/errors');<br/>const { createEvent } = require('/opt/ports');<br/>const { logger } = require('/opt/logger');<br/><br/>/**<br/> * Business logic<br/> * @param {string} calendarId<br/> * @param {Object} event<br/> * @param {string} event.title<br/> * @param {string} event.startTime ISO-8601 format<br/> * @param {string} event.endTime ISO-8601 format<br/> * @returns {string}<br/> */<br/><br/>exports.logic = async function (calendarId, event) {<br/>  // Check that start comes before end<br/>  const startTime = new Date(event.startTime);<br/>  const endTime = new Date(event.endTime);<br/>  if (!(startTime &lt; endTime)) {<br/>    throw new InputError('startTime must come before endTime.');<br/>  }<br/><br/>  const eventId = await createEvent(calendarId, event);<br/><br/>  return eventId;<br/>}</span></pre><p id="47b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我可以将<code class="du jt ju jv jw b">Date</code>创建验证移出，因为<code class="du jt ju jv jw b">logic</code>现在知道它将被正确格式化的<code class="du jt ju jv jw b">event.startTime</code>和<code class="du jt ju jv jw b">event.endTime</code>调用。如果我使用Typescript，我会创建一个<code class="du jt ju jv jw b">interface</code>。使用Javascript意味着我需要对自己多负责一点，并在自己的代码中执行契约。<code class="du jt ju jv jw b">logic</code>只处理特定于值的验证，因为它可以知道契约已经满足，我们可以从开始和结束时间比较中看到这一点。它也不再处理数据库实现细节，而是传递相关信息并让数据库<code class="du jt ju jv jw b">adapter</code>处理数据模型的构建。</p><p id="eb0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我重构了我的输出/数据库<code class="du jt ju jv jw b">port</code>和<code class="du jt ju jv jw b">adapter</code>。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="a860" class="kf kg hi jw b fi kh ki l kj kk">/**<br/> * File: /opt/ports.js<br/> */<br/><br/>const events = require('/opt/database/events');<br/>const { getDateRange } = require('/opt/getDateRange');<br/><br/>async function createEvent(calendarId, event) {<br/>  const dates = getDateRange(startTime, endTime);<br/>  const eventId = await events.create(calendarId, dates, event);<br/>  return eventId;<br/>}<br/><br/>module.exports = {<br/>  createEvent,<br/>};<br/><br/>/**<br/> * File: /opt/database/events.js<br/> */<br/><br/>const { documentClient } = require('./databaseSession');<br/>const { generateToken } = require('../generateToken');<br/><br/>async function create(calendarId, dates, event) {<br/>  const eventId = generateToken();<br/>  const batchWritePayload = {};<br/>  // Construct batchWritePayload<br/>  await documentClient.batchWrite(batchWritePayload);<br/><br/>  return eventId;<br/>}<br/><br/>module.exports = {<br/>  create,<br/>};</span></pre><p id="5bab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意到什么了吗？<code class="du jt ju jv jw b">/opt/database/events.js</code>中的代码没有变化。正如我所说的，我幸运地正确抽象了数据库功能，问题是我的业务逻辑调用了数据库功能，而不是功能的抽象(数据库<code class="du jt ju jv jw b">port</code>)。这使得我的数据库<code class="du jt ju jv jw b">port</code>和<code class="du jt ju jv jw b">adapter</code>的重构变得简单。我需要做的就是将业务逻辑之外的<code class="du jt ju jv jw b">getDateRange</code>调用移到我的<code class="du jt ju jv jw b">port</code>中，并让我的<code class="du jt ju jv jw b">port</code>调用数据库<code class="du jt ju jv jw b">adapter</code>。</p><p id="b990" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，我们有了。自从几个月前我参加了re:Invent的演讲后，我就一直想实现一个六边形架构，尤其是在Lambda函数中。在找到另外几个关于实现的关键资源后，我现在更有信心理解细节和界限。正如我在很多其他帖子中说过的，我在生活的很多方面都在使用改善。这只是我第一次实现六边形架构，所以要有所保留。我已经尽我所知实现了所有的事情，但是我确信在将来我会学到新的更好的方法。现在，我希望这能帮助其他人更快地理解实现。快乐编码。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="0ea3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ks">原载于2022年1月27日</em><a class="ae iu" href="https://thomasstep.com/blog/how-i-implement-hexagonal-architecture-in-aws-lambda" rel="noopener ugc nofollow" target="_blank"><em class="ks">【https://thomasstep.com】</em></a><em class="ks">。</em></p></div></div>    
</body>
</html>
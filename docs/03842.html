<html>
<head>
<title>Understanding correctly that messy keyword ‘const’ in C++ (II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确理解C++ (II)中杂乱的关键字“const”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-ii-b0923a97b60a?source=collection_archive---------16-----------------------#2021-06-16">https://medium.com/geekculture/understanding-correctly-that-messy-keyword-const-in-c-ii-b0923a97b60a?source=collection_archive---------16-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/cde93c52ce7e64484dcccb90561711f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwa-8OuQsv2UczPo_GS3PQ.jpeg"/></div></div></figure><div class=""/><h1 id="bb19" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">第二部分:常数方法。</h1><h2 id="b293" class="jo ir ht bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">在C++中，限定符“const”指定了一个编译时约束，即对象或变量不能被修改。编译器验证对象或变量永远不会改变，并在您试图修改或重新分配它时阻止您。然而，编写“const”正确的代码比仅仅在一些行中使用关键字，然后让编译器找出什么有意义要有挑战性得多。在这个由三部分组成的指南中，你会得到一些如何正确使用它的提示。</h2><p id="9737" class="pw-post-body-paragraph kf kg ht kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated"><a class="ae la" href="https://correa-pablo.medium.com/understanding-correctly-that-messy-keyword-const-in-c-i-62f210291247" rel="noopener">在上一篇文章</a>中，我们看到了关键字'<em class="lb"> const </em>应用于类型的不同用法。我们还观察了这个标识符与指针的交互，并且有一些例子说明编译器允许哪些操作，哪些不允许。</p><p id="6e31" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">在第二部分中，我们将分析关键字'<em class="lb"> const </em>'是如何在一个类的方法中使用的。这次我们将定义一个类，然后我们将在需要的地方应用'<em class="lb"> const </em>'正确性。</p><p id="3359" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">这是我们相对简单的类。不要担心，我们将一步一步地剖析它:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3dad" class="jo ir ht lm b fi lq lr l ls lt">typedef int myInt;</span><span id="10bf" class="jo ir ht lm b fi lu lr l ls lt">class AnObject<br/>{ <br/>    public:</span><span id="30e9" class="jo ir ht lm b fi lu lr l ls lt">        AnObject(){};</span><span id="61e4" class="jo ir ht lm b fi lu lr l ls lt">        void printId () { std::cout&lt;&lt;id_&lt;&lt;std::endl;}<br/>        std::string getName () { return name_; }<br/>        int getNumber ()<br/>        {<br/>            if (number_ &lt; 0)<br/>            resetNumber();<br/>            return number_;    <br/>        }<br/>        <br/>        void resetNumber () { number_ = 0; }<br/>        void helperResetNumber () { resetNumber(); }<br/>        <br/>        void setNumber (int &amp;number) { number_= number; }<br/>        void setName (std::string &amp;name ) { name_= name; }<br/>        void setId (const myInt id) { id_ = id;}<br/>        //The Most Constant Method<br/>        const int *const TMCMethod (const int *const&amp; value) const</span><span id="370c" class="jo ir ht lm b fi lu lr l ls lt">    private:<br/>        <br/>        std::string name_{""};<br/>        myInt id_;<br/>        int number_;<br/>};</span></pre><p id="4bb4" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">我们要分析的前两行如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="9541" class="jo ir ht lm b fi lq lr l ls lt">void printId () { std::cout&lt;&lt;id_&lt;&lt;std::endl;}<br/>std::string getName () { return name_; }</span></pre><p id="2990" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">正如你所看到的，这些成员函数没有改变对象的内部状态，因此它们应该是常量。这是通过在括号后添加标识符'<em class="lb"> const </em>'来实现的:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c2bf" class="jo ir ht lm b fi lq lr l ls lt">void printId () const { std::cout&lt;&lt;id_&lt;&lt;std::endl;}<br/>std::string getName () const { return name_; }</span></pre><p id="77c2" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">一般来说，所有只检索和/或显示信息的函数(例如“getters”)最好定义为常量，以使它们的目的更加清晰易读。</p><p id="017e" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">下一个要检查的方法不仅仅是返回值:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="23e4" class="jo ir ht lm b fi lq lr l ls lt">int getNumber ()<br/>{<br/>   if (number_ &lt; 0)<br/>      resetNumber();<br/>   return number_;    <br/>}</span></pre><p id="85ff" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">这个方法总是返回信息，即使有时需要改变对象的内部状态。这是将它设为'<em class="lb"> const </em>'的充分理由。如果这种方法不改变物体的可观察状态，那就加强了它应该是常数的理由。然而，为了修改成员变量<em class="lb"> number_，</em>的内部状态，我们应该使用一个<em class="lb"> const_cast </em> ( <a class="ae la" href="https://correa-pablo.medium.com/understanding-correctly-that-messy-keyword-const-in-c-i-62f210291247" rel="noopener">参见本文的第1部分</a>)或者更好，将它的声明改为mutable:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f98e" class="jo ir ht lm b fi lq lr l ls lt">int getNumber () const<br/>{<br/>   if (number_ &lt; 0)<br/>      resetNumber();<br/>   return number_;      <br/>}</span><span id="e7f2" class="jo ir ht lm b fi lu lr l ls lt">...</span><span id="b645" class="jo ir ht lm b fi lu lr l ls lt">private:</span><span id="0b79" class="jo ir ht lm b fi lu lr l ls lt">...</span><span id="64c1" class="jo ir ht lm b fi lu lr l ls lt">  mutable int number_;</span></pre><p id="231d" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">但是我们上面所做的更改迫使我们将方法<em class="lb"> resetNumber() </em>改为只读，否则，我们将得到一个编译器错误。这是尽早开始使用“const”的另一个原因。我甚至最近听说，所有的东西都要定义为'<em class="lb"> const' </em>，然后你会把需要的'<em class="lb"> constness' </em>去掉。只要记住:任何成员函数在被另一个'<em class="lb"> const </em>'成员函数调用时都应该是'<em class="lb"> const' </em>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c0de" class="jo ir ht lm b fi lq lr l ls lt">void resetNumber () const  { number_ = 0; }</span></pre><p id="6653" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">现在我们知道<em class="lb">非常数</em>函数只能被其他<em class="lb">非常数</em>对象调用。这也意味着'<em class="lb"> const' </em>函数总是可以被调用，不管调用者是否是只读的。因此，即使<em class="lb"> resetNumber() </em>现在是'<em class="lb"> const' </em>，下面一行仍然有效:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c37e" class="jo ir ht lm b fi lq lr l ls lt">void helperResetNumber () { resetNumber(); }</span></pre><p id="5a26" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">但是出于风格的原因(它调用了一个'<em class="lb"> const </em>'函数),我们可能也应该把它设置为常量:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f6ba" class="jo ir ht lm b fi lq lr l ls lt">void helperResetNumber () const { resetNumber(); }</span></pre><p id="6133" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">接下来的几行包含两个方法，它们的参数是通过引用传递的，因此不会复制底层对象，这是一个非常有效的操作，对于大型和复合的用户定义变量类型尤其有用:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3555" class="jo ir ht lm b fi lq lr l ls lt">void setNumber (int &amp;number) { number_= number; }<br/>void setName (std::string &amp;name) { name_= name; }</span></pre><p id="346c" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">通过使参数'<em class="lb">为const </em>'将导致它们在不复制的情况下被传递，但将防止它们被修改(除非您使用强制方法):</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f3f2" class="jo ir ht lm b fi lq lr l ls lt">void setNumber (const int &amp;number) { number_= number; }<br/>void setName (const std::string &amp;name) { name_= name; }</span></pre><p id="0f96" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">出于同样的原因，将' myInt id '声明为'<em class="lb"> const </em>'几乎没有好处，因为它是通过值传递的:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="dc45" class="jo ir ht lm b fi lq lr l ls lt">void setId (const myInt id) { id_ = id;}</span></pre><p id="37a1" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">当然，一种选择是不使用'<em class="lb"> const </em>':</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3a11" class="jo ir ht lm b fi lq lr l ls lt">void setId (myInt id) { id_ = id;}</span></pre><p id="664d" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">但是遵循同样的风格，将它保持为'<em class="lb"> const </em>'更有意义，但是将值作为引用传递:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="bd78" class="jo ir ht lm b fi lq lr l ls lt">void setId (const &amp;myInt id) { id_ = id;}</span></pre><p id="298c" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">所以，我们几乎准备好了我们的小课堂。是时候履行我在文章第一部分中的承诺了，通过解释带有5 ' <em class="lb"> const </em>'限定符的方法的含义:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="45d3" class="jo ir ht lm b fi lq lr l ls lt">//The Most Constant Method<br/>const int *const TMCMethod (const int *const&amp; value) const</span></pre><p id="acd7" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">基本上，你有一个常量方法，它的参数是一个指向常量类型的常量指针，通过引用传递，返回一个指向常量类型的常量指针。但是这意味着什么呢？</p><p id="298f" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">这意味着由返回指针指向的变量和返回指针本身不能被改变，并且该方法不修改由给定指针指向的变量、给定指针本身以及它是其方法的对象。谜团解开了！</p><p id="cbd2" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">我们已经接近尾声，在这一点上，我们已经涵盖了使用'<em class="lb"> const </em>'的两个主要原因:</p><ul class=""><li id="6c6e" class="lv lw ht kh b ki lc km ld jv lx jy ly kb lz kz ma mb mc md bi translated">以防止无意中写入变量。</li><li id="a22c" class="lv lw ht kh b ki me km mf jv mg jy mh kb mi kz ma mb mc md bi translated">使代码更加自我记录和自我解释。</li></ul><p id="a668" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">这两种用法让程序员和编译器更容易发现错误。但是，有几件事情需要考虑:</p><ul class=""><li id="84e6" class="lv lw ht kh b ki lc km ld jv lx jy ly kb lz kz ma mb mc md bi translated">使用它可以让编译器执行更多的优化，使代码更紧凑和更有效，因为它确切地知道变量或函数在任何时候的状态。不过，围绕这一点有一些争论，认为'<em class="lb"> const </em>'在某个点之后对编译器优化没有任何帮助，因为优化器不能确定某个地方没有'<em class="lb">非常数</em>别名或'<em class="lb"> const cast' </em>。</li><li id="8fad" class="lv lw ht kh b ki me km mf jv mg jy mh kb mi kz ma mb mc md bi translated">对于嵌入式系统，这意味着变量可以存储在ROM中，节省宝贵的RAM空间。我经常听到沮丧的嵌入式开发人员抱怨在不同的库和API中缺少'<em class="lb">const-correction</em>'。</li></ul><p id="a72a" class="pw-post-body-paragraph kf kg ht kh b ki lc kk kl km ld ko kp jv le kr ks jy lf ku kv kb lg kx ky kz hb bi translated">使用'<em class="lb"> const </em>'符合Demeter定律，即如果一个值不需要改变，那么它就不应该被允许改变。此外，'<em class="lb"> const </em>'增加了编译时类型检查的级别，有助于错误的早期检测。我们将在本文的最后一部分讨论这个问题。我将向您展示'<em class="lb"> const </em>'如何与替代(比如说'老派')方法进行比较，以生成只读变量和函数。在那之前，编码快乐！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Testing in Android a Zero to Hero Tutorial-Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android测试从零到英雄教程-第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-2-577aeb79ae14?source=collection_archive---------31-----------------------#2021-06-08">https://medium.com/geekculture/testing-in-android-a-zero-to-hero-tutorial-part-2-577aeb79ae14?source=collection_archive---------31-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cecba54ddfd7690ef35b1b7f67dd46e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLFz420ziOejxt5ImI0h6A.png"/></div></div></figure><p id="49c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一部分，我们来看看测试android组件、@Before和@After的概念，以及我们如何<strong class="is hj">测试Room DB </strong>。</p><p id="c145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一个教程中，我们创建了一个函数和测试用例，它可以在test文件夹中使用JVM运行，现在让我们来看另一个例子，它需要一个上下文并检查来自资源文件的字符串是否与来自用户输入的字符串相匹配。</p><p id="23c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们开始吧</strong></p><p id="7030" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次我们将创建一个kotlin类，在这种情况下，我们将在测试用例中需要这个类的一个实例。所以继续创建<strong class="is hj"> CompareStrings.kt </strong>类，它接受上下文、资源字符串id和用户输入字符串。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="f43b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像在上一个教程中一样，我们通过</p><ul class=""><li id="d7f9" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">右键单击名称</li><li id="e2fa" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">选择junit 4和一个合适的名称</li><li id="1815" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">这次我们选择androidTest文件夹而不是Test文件夹</li></ul><p id="a794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们选择<strong class="is hj"> androidTest </strong>文件夹，因为我们需要获得上下文对象的引用，与上次不同，我们还需要我们的类CompareStrings.kt的实例</p><p id="7b9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先使用不良实践来做这个测试用例，我将解释为什么这是不良实践👎</p><p id="49da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，我们在test目录中使用的命名约定不适用于androidTest目录，许多关于为什么的答案可以在这个<a class="ae ki" href="https://stackoverflow.com/questions/46295418/cannot-use-kotlin-backticked-method-names-in-androidtest-bad-descriptor-except" rel="noopener ugc nofollow" target="_blank"> stackoverflow问题</a>中找到，希望当你阅读这篇文章时有一个解决方案，你可以选择在两个文件夹中使用相同的命名约定或不同的命名约定，这取决于你。然而，以下是一些不好的做法。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="b5be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的测试类，我们创建测试用例来检查两个字符串是否匹配，是否返回真，如果不匹配，则返回假，工作正常，但是为什么这是一个不好的做法呢？😕</p><p id="6ff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们所有的测试用例应该独立运行，但是在上面的例子中，它们依赖于类compare string的共享实例，这是不好的，因为让我们想象一下，如果我们有一个函数有一个counter成员变量。</p><p id="74a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们有2个测试用例，在这种情况下，A将计数器加1，B从1开始，因为我们没有测试用例首先运行的顺序，这可能会产生<a class="ae ki" href="https://engineering.atspotify.com/2019/11/18/test-flakiness-methods-for-identifying-and-dealing-with-flaky-tests/#:~:text=A%20flaky%20test%20is%20a,new%20builds%20to%20complete%20successfully." rel="noopener ugc nofollow" target="_blank">不稳定的测试</a>(有时失败，有时成功)。</p><p id="1145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最佳实践答案现在</strong></p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="4a29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对象引用问题可以通过在前使用注释<strong class="is hj">@和在<strong class="is hj">@后使用注释来解决。</strong></strong></p><p id="c5ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> @Before </strong> -使用它的函数将在任何测试用例运行之前运行，因此每次都会创建新的实例，并允许测试用例从头开始运行，因为您不希望在每个测试用例中为比较字符串类和上下文创建新的实例，这将创建大量冗余代码。</p><p id="44ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> @After </strong> -用于在所有测试用例运行完毕后进行清理，在这个例子中我们不需要它，因为我们不需要它，因为垃圾收集处理上下文。但这在我们接下来要讨论的测试室DB中非常常用。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h2 id="a05e" class="kq kr hi bd ks kt ku kv kw kx ky kz la jb lb lc ld jf le lf lg jj lh li lj lk bi translated"><strong class="ak">使用真实应用进行测试</strong></h2><p id="02b0" class="pw-post-body-paragraph iq ir hi is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hb bi translated">在开始之前，我假设你已经知道MVVM，LiveData，匕首柄，翻新，房间数据库和协同程序是如何工作的，因为本教程只集中在测试上。</p><p id="3d32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ki" href="https://zaidzakir.medium.com/coroutines-in-android-explained-8f00a37c8528" rel="noopener"> &gt; &gt; &gt;点击这里查看我的文章&lt; &lt; &lt; </a></p><p id="bf4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个关于测试的系列教程是基于我创建的一个简单的应用程序，用来管理购物清单项目，上传到我的github上，我们将使用它作为我们的例子，所有的实现都已经完成，我们将只看测试是否完成。</p><p id="6b1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能包括:</p><ul class=""><li id="4e9b" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">MVVM，实时数据，协同程序，匕首柄</li><li id="59dd" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将项目插入房间数据库</li><li id="ec6a" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">使用翻新和Pixabay API进行网络调用</li><li id="7027" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">回收器视图，滑动以删除</li></ul><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/632d9631dd73e07916db1bf29a51ce3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZYFMTN389YBvSXMbnwoBg.png"/></div></div></figure><div class="lr ls ez fb lt lu"><a href="https://github.com/zaidzak9/AndroidTestingSample" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">zaidzak 9/Android测试示例</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">用于学习和编写测试用例的购物清单应用程序，也在medium文章中用作解释测试的示例…</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi io lu"/></div></div></a></div><p id="0762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">测试时关闭动画</strong></p><p id="3d5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ki" href="https://developer.android.com/training/testing/espresso/setup#set-up-environment" rel="noopener ugc nofollow" target="_blank">这是谷歌推荐的最佳实践</a></p><blockquote class="mj mk ml"><p id="1da4" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">为了避免剥落，我们强烈建议您关闭用于测试的虚拟或物理设备上的系统动画。在您的设备上，在<strong class="is hj">设置&gt;开发者选项</strong>下，禁用以下3项设置:</p></blockquote><ul class=""><li id="cd2c" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">窗口动画比例</li><li id="395b" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">过渡动画比例</li><li id="956e" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">动画师持续时间量表</li></ul></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="4839" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来看看如何测试我们的房间数据库，测试房间数据库需要<strong class="is hj"> Android组件的帮助，如上下文和内存</strong>，所以我们必须在androidTest文件夹中创建一个测试类。</p><p id="2f49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">永远记住，我们在test或androidTest中的文件夹结构应该遵循与包含android代码的主结构相同的结构。</p><p id="a643" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们最初的shoppingDao是一个接口，所以我们不能像前面的例子那样通过右键单击来为接口创建测试类。</p><p id="66b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须在androidTest文件夹中手动创建一个测试类，<strong class="is hj">右键- &gt; kotlin文件/类- &gt;创建类</strong></p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="38d0" class="kq kr hi mr b fi mv mw l mx my">@RunWith(AndroidJUnit4::class)<br/>class ShoppingDaoTest {<br/><br/>}</span></pre><p id="2afb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，一旦我们像上面那样创建了类，我们就添加注释<strong class="is hj">@ run with(android JUnit 4::class)</strong>，一般来说，任何java或kotlin代码都需要JVM来运行，因为这默认包含在我们的测试文件夹中，这不包含在androidTest文件夹中，因为我们在Android环境中，所以要启用它，我们必须包含上面所示的注释。</p><h2 id="54eb" class="kq kr hi bd ks kt ku kv kw kx ky kz la jb lb lc ld jf le lf lg jj lh li lj lk bi translated">测试注释的类型</h2><blockquote class="mj mk ml"><p id="7e02" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">测试大小限定符是构建测试代码的一种很好的方式，用于将一个测试分配给一个运行时间相似的测试套件。</p></blockquote><p id="1dba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@ Small test</strong>-小型测试应该非常频繁地运行。关注代码单元以验证特定的逻辑条件。这些测试应该在隔离的环境中运行，并使用模拟对象作为外部依赖。不允许资源访问(如文件系统、网络或数据库)。与硬件交互、进行绑定调用或者促进android工具的测试不应该使用这个注释。</p><p id="dd56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@ Medium test</strong>——中型测试应该集中在非常有限的组件子集或者单个组件上。允许通过定义良好的接口(如数据库、内容提供者或上下文)对文件系统进行资源访问。应该限制网络访问，应该避免(长时间运行的)阻塞操作，而应该使用模拟对象。</p><p id="bc22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大型测试应该专注于测试所有应用程序组件的集成。这些测试完全参与到系统中，并且可以利用所有资源，例如数据库、文件系统和网络。根据经验，大多数功能性UI测试都是大型测试。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="6b8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个类，我们使用@ MediumTest </p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><ul class=""><li id="13e7" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><strong class="is hj">第5行&amp; 6- </strong>我们已经创建了对<strong class="is hj"> ShoppingItemDatabase </strong>和<strong class="is hj"> ShoppingDao </strong>类的引用。</li><li id="5643" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><strong class="is hj">第8行到第16行- </strong>现在，我们使用在注释前带有<strong class="is hj"> @的函数设置来确保每个测试用例都需要RoomDB和ShoppingDao的新实例，因此测试用例之间是完全独立的，不需要任何类型的数据操作来产生不稳定的测试。</strong></li><li id="4be6" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><strong class="is hj">第10行——room . inmemorydatabasebuilder</strong>用于指示系统使用ram中的内存而不是持久内存来存储数据，这样我们就可以为每个测试用例创建一个新的数据库</li><li id="645b" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">在正常情况下，我们允许网络调用和数据库调用等功能在后台线程中运行，这样用户界面就不会被中断，也不会导致ANR崩溃，但是在编写测试用例时，我们特别指示测试用例在主线程中运行，以禁止任何类型的操纵，您不希望测试A和测试B同时运行，并以不同的方式操纵数据库，这将导致不可靠的测试。</li><li id="a9e4" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><strong class="is hj">第18行到第21行- </strong>在前面的例子中，我们不能使用<strong class="is hj"> @ After </strong>注释，因为不需要，但是在数据库的情况下，这是非常必要的，因为我们需要在每次测试完成后关闭数据库。</li></ul><h2 id="a9cd" class="kq kr hi bd ks kt ku kv kw kx ky kz la jb lb lc ld jf le lf lg jj lh li lj lk bi translated">所以现在我们可以开始编写测试用例来测试购物项目是否被正确地插入到房间DB中。</h2><p id="6062" class="pw-post-body-paragraph iq ir hi is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hb bi translated">由于我们接口中的insert函数是一个<strong class="is hj"> suspend函数</strong>，我们需要<strong class="is hj">协程</strong>来运行它，但是回到我之前的观点，当涉及到测试用例时，我们不能使用任何形式的并发，所以为了满足这两个需求，我们可以使用一个协程lambda函数，叫做<code class="du mz na nb mr b">runBlockingTest { }</code> <strong class="is hj">，</strong>你可能听说过<strong class="is hj"> </strong> <code class="du mz na nb mr b">runBlocking { }</code>，它的目的是运行它的线程(主线程)得到<em class="mm">阻塞</em>runBlockingTest做了类似的事情，但被修改以适应测试用例，它将立即通过延迟，进入启动和异步块。您可以使用它来编写在存在延迟调用的情况下执行的测试，而不会导致您的测试花费额外的时间。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="ba2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第3行</strong>——我们使用我们的数据类创建一个购物项目。</p><p id="c30b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第4行</strong>——我们使用dao引用并在我们的接口中访问插入挂起功能。</p><p id="752b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第6行</strong>-插入后，我们需要确认我们插入的数据是否真的成功，为此我们使用observeAllShoppingItems()方法，但这会返回一个liveData，这将我们带回到并发问题/参数，我们的测试用例中不能有这个，所以我们可以使用google预先构建的名为<a class="ae ki" href="https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics#8" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">LiveDataUtilAndroidTest</strong></a>的类来解决这个问题</p><blockquote class="mj mk ml"><p id="f83a" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">你可以将这个类复制粘贴到你的项目androidTest根文件夹中，这个类所做的是观察一个LiveData，直到它接收到一个新值(通过<code class="du mz na nb mr b">onChanged</code>)，然后它移除观察者。如果LiveData已经有一个值，它会立即返回。此外，如果从未设置该值，它将在2秒钟后(或您设置的任何时间)抛出异常。这可以防止出现问题时测试无法完成。</p></blockquote><p id="dfa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上解释摘自下面链接的文章，阅读更多详细解释。</p><div class="lr ls ez fb lt lu"><a rel="noopener follow" target="_blank" href="/androiddevelopers/unit-testing-livedata-and-other-common-observability-problems-bb477262eb04"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">单元测试LiveData和其他常见的可观察性问题</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">下一次，当你抓耳挠腮地看着一个应该通过的带有LiveDatas的完美单元测试时，或者…</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">medium.com</p></div></div><div class="md l"><div class="nc l mf mg mh md mi io lu"/></div></div></a></div><p id="1dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第8行</strong> -现在我们使用来自google真理库的assertThat并检查数据库中是否存在插入的条目</p><p id="6ba4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当你按下播放并运行这个程序时，你可能会得到一个错误提示</p><blockquote class="mj mk ml"><p id="cf9c" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><strong class="is hj">Java . lang . illegalstateexception:该作业尚未完成</strong></p></blockquote><p id="aa78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这表示的是</strong></p><p id="e88e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个异常是由我们的实时数据引起的，因为它在默认情况下是异步的，即使我们使用runBlockTest{} JUnit也不允许这样做，为了解决这个问题，我们需要声明一个规则，明确地告诉JUnit在同一个线程上一个接一个地执行测试类中的所有代码</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="d3d4" class="kq kr hi mr b fi mv mw l mx my"><strong class="mr hj">@get:Rule<br/>var instantTaskExecutorRule = InstantTaskExecutorRule()</strong></span></pre><p id="0803" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当您重新运行它时，它会成功。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="4c20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们继续完成剩下的测试用例，非常类似于上面的一个，不言自明。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="cb0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不必担心数据不匹配，因为每次测试用例运行时，都会创建一个新的数据库实例</p><p id="9130" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述测试案例中唯一的区别是我们如何使用assertThat()来获得我们需要的结果。</p><blockquote class="mj mk ml"><p id="9d03" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">deleteShoppingItem():首先我们插入一个项目，这样我们就有一些东西要删除，插入后我们继续删除那个项目，然后检查数据库是否为空，以确认它已被删除。</p><p id="5b2d" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><strong class="is hj"> observeAllShoppingItem():我们插入一个条目，检查数据库的大小是否为1。</strong></p><p id="eb37" class="iq ir mm is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><strong class="is hj"> observeTotalPrice():我们输入3个商品，并在assert中计算我们的总数是否与我们输入的价格相匹配。</strong></p></blockquote><p id="2e69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对房间数据库测试的基本概述，在下一个教程中，让我们看看如何测试<strong class="is hj">带匕首刺</strong>的改型</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="cb2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ki" href="https://zaidzakir.medium.com/testing-in-android-a-zero-to-hero-tutorial-part-3-b1a3b5504965" rel="noopener"> <strong class="is hj">点击此处测试安卓一个零到英雄教程——第三部</strong> </a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Multithreading in iOS-Part 3/4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的多线程-第3/4部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/threads-in-ios-part-2-c4f44e885f5f?source=collection_archive---------11-----------------------#2021-06-01">https://medium.com/geekculture/threads-in-ios-part-2-c4f44e885f5f?source=collection_archive---------11-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="76ad" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">n操作，n操作的优点，操作</h2></div><p id="c3d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想知道什么是线程，多线程以及gcd是如何工作的，请参考我的第一个博客<a class="ae jt" href="https://manasaprema04.medium.com/threads-in-ios-gcd-nsoperation-part-1-64e460c0bdea" rel="noopener">这里</a>。</p><h1 id="86d8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">n操作队列:-</h1><p id="e294" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">另一种创建线程的方法是使用操作。创建操作实例后，将操作提交给OperationQueue。OperationQueue将管理线程，并负责运行您提供给它的操作。</p><p id="8d2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">什么是运营？</strong>表示与单个任务相关联的代码和数据的抽象类。</p><p id="979d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">操作状态:- </strong>操作对象在内部维护状态，以确定何时执行是安全的，并通过操作的生命周期通知外部客户端进度。</p><p id="9aa7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是操作状态</p><ol class=""><li id="466d" class="kr ks hi iz b ja jb jd je jg kt jk ku jo kv js kw kx ky kz bi translated"><code class="du la lb lc ld b"><strong class="iz hj">isReady</strong></code> <strong class="iz hj"> : </strong>当一个操作准备执行时，通知客户端。当操作准备好立即执行时，它返回<code class="du la lb lc ld b">true</code>,如果它所依赖的未完成的操作仍然存在，则返回<code class="du la lb lc ld b">false</code>。</li></ol><ul class=""><li id="2f8c" class="kr ks hi iz b ja jb jd je jg kt jk ku jo kv js le kx ky kz bi translated"><code class="du la lb lc ld b"><strong class="iz hj">isExecuting</strong></code> <strong class="iz hj"> : </strong>这告诉我们操作是否正在执行分配的任务。如果操作正在执行其任务，则<code class="du la lb lc ld b">isExecuting</code>返回<code class="du la lb lc ld b">true</code>，否则返回<code class="du la lb lc ld b">false</code>。</li><li id="3c86" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated"><code class="du la lb lc ld b"><strong class="iz hj">isFinished</strong></code> <strong class="iz hj"> : </strong>告知某项操作成功完成任务或被取消。在<code class="du la lb lc ld b">isFinished</code>值变为<code class="du la lb lc ld b">true</code>之前，操作队列不会将操作出队，或者操作对象不会被清除。</li><li id="dc9e" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated"><code class="du la lb lc ld b"><strong class="iz hj">isCancelled</strong></code> <strong class="iz hj"> : </strong>通知客户端请求取消操作。</li></ul><p id="d105" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如何取消操作？</p><p id="1753" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以如下使用<code class="du la lb lc ld b">cancel()</code>取消操作。我们可以通过<code class="du la lb lc ld b">isCancelled</code>检查操作是否被取消</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es lk"><img src="../Images/a79ca6f09d6abd1bb13da72290be7586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*6YnjiVpoqxQKPjDK4DnKMw.png"/></div></figure><p id="ad0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">对</strong>的影响<code class="du la lb lc ld b"><strong class="iz hj">cancel()</strong></code></p><ul class=""><li id="84a5" class="kr ks hi iz b ja jb jd je jg kt jk ku jo kv js le kx ky kz bi translated">你的行动已经结束了。在这种情况下，cancel方法不起作用。</li><li id="73ab" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated">您的操作已经在执行中。在这种情况下，系统不会强制停止您的操作代码，而是将cancelled属性设置为true。</li><li id="0a35" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated">您的操作仍在队列中等待执行。在这种情况下，您的操作将不会被执行。</li></ul><h2 id="82a6" class="ls jv hi bd jw lt lu lv ka lw lx ly ke jg lz ma kg jk mb mc ki jo md me kk mf bi translated">如何才能创造运营？</h2><p id="e8e9" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">开发者不需要直接使用它。Foundation提供了两个系统定义的子类<code class="du la lb lc ld b">InvocationOperation</code>和<code class="du la lb lc ld b">BlockOperation</code>来执行任务。</p><p id="2112" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建操作主要有三种方式:-</p><ol class=""><li id="c496" class="kr ks hi iz b ja jb jd je jg kt jk ku jo kv js kw kx ky kz bi translated">块操作</li><li id="cb87" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">InvocationOperation</li><li id="86cf" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">自定义操作</li></ol><p id="285a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">块操作:- </strong></p><p id="1cf2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">管理一个或多个块的并发执行的操作。</p><p id="7638" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du la lb lc ld b">BlockOperation</code>类从<code class="du la lb lc ld b">Operation</code>类延伸而来。您可以使用此对象一次执行几个块，而不必为每个块创建单独的操作对象。当执行一个以上的块时，只有当所有的块都完成执行时，操作本身才被认为完成。</p><p id="4b93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">利用系统定义的<code class="du la lb lc ld b">BlockOperation</code>看起来如下:</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/8bd75ffed913110e24a7b8bce6c98294.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*eUqATk9iNdRaHWPGafwthg.png"/></div></figure><figure class="mg lp mq mi mj mk ml paragraph-image"><img src="../Images/81718d0940058d9e05c71dedda4937c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*rie7f1FY38ccbiIcUZIKuQ.png"/></figure></div><blockquote class="mr ms mt"><p id="9a21" class="ix iy mu iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">在这里，块操作被添加到操作队列中。操作队列在某个后台线程上启动操作并执行它。</p></blockquote><p id="9ea3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以通过直接在队列中添加块来完成:</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es my"><img src="../Images/6804f7bf79c5ad3e93cc33bcf5794501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*76G2DWsFSOpF3fOMaw_4Ng.png"/></div></figure><p id="e49e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如何同时执行一个或多个块？</p><p id="1fb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用<code class="du la lb lc ld b">BlockOperation</code>一次执行一个或多个块，而不需要创建新操作，如下所示</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp mz mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/3e5ebf53f77b500e2d62f906b48cd610.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*SktIDXufRVvuF7jQ6cyyMQ.png"/></div></figure><figure class="mg lp na mi mj mk ml paragraph-image"><img src="../Images/46c1c07ea256509d7ae9b6c3133b3efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*-FFZx75J9cCikd_WlcYntg.png"/></figure></div><p id="f060" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，添加到块操作本身的任务/块同时执行，但是块运行<code class="du la lb lc ld b">synchronous manner</code>意味着它阻塞了调用start的线程，在我们的例子中它是主线程。</p><p id="42d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过在任何其他线程中调用<code class="du la lb lc ld b">start()</code>方法来解锁主线程，但这会阻塞调用<code class="du la lb lc ld b">start()</code>方法的线程。</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nb mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/a26f4a75f2d793c1052012483e37e63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*bgFVyFEr7UiAVKRdpijBLw.png"/></div></figure><figure class="mg lp nc mi mj mk ml paragraph-image"><img src="../Images/30ac00512c15ae5c721c70db55c624b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*_zI3OByZ4z9lryRn1swXRw.png"/></figure></div><p id="d56b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> InvocationOperation:- </strong></p><p id="4e80" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在objective C中，我们可以创建<code class="du la lb lc ld b">NSInvocationOperation</code>，而Swift中没有。</p><p id="690b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">自定义操作:- </strong></p><p id="7370" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子类化<code class="du la lb lc ld b">Operation </code>让你可以完全控制自己操作的实现，包括改变操作执行和报告状态的默认方式。</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nd mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/52df774106aaad3c930e2999d8326ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*l_71mGFZF51c0Ya5lJk2OQ.png"/></div></figure><figure class="mg lp ne mi mj mk ml paragraph-image"><img src="../Images/6689db35f8c09b3d01c9e249a4a46f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*Wbr5V7O5USQuLTr-Okc47w.png"/><figcaption class="nf ng et er es nh ni bd b be z dx nj di nk nl">This will block the main thread bcz here we are calling start() in main thread</figcaption></figure></div><p id="8450" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建自定义并发操作，如下所示:-</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nm mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/31b4570a966b43a1c404584cf1513cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*9Ee6lX0NSRQ1-OSA9fvQxQ.png"/></div></figure><figure class="mg lp nn mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/ad92715a82fa9dd484070619787fa4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*WUx75VH5CVSqbMcJqe6IxA.png"/></div></figure></div><p id="267e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对自定义操作调用<code class="du la lb lc ld b">cancel()</code>方法:</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es no"><img src="../Images/bc763940907574682840f97c50d2fdb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdFZGxm9OxymzP5xlw0gLQ.png"/></div></div></figure><h1 id="e279" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">操作队列:-</h1><p id="f8f6" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">操作队列是Cocoa对GCD的高级抽象。不是自己动手操作，而是交给操作队列。然后它处理调度和执行。</p><p id="f1f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">操作队列根据优先级和FIFO顺序执行其排队的<code class="du la lb lc ld b">Operation</code>对象。</p><p id="fa40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个操作队列通过在第二线程上运行操作来直接执行它的操作，或者间接地使用<code class="du la lb lc ld b">libdispatch</code>库(即中央调度)</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es np"><img src="../Images/601f4159c5d22bdd81396ea8cd85669d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*8T-TKdTBf88TkwPC2-mhgw.png"/></div></figure><blockquote class="mr ms mt"><p id="04db" class="ix iy mu iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">您可以添加任意多的操作，但它们不会同时执行。相反， <code class="du la lb lc ld b"><strong class="iz hj"><em class="hi">OperationQueue</em></strong></code> <em class="hi">根据系统条件限制操作次数</em></p></blockquote><p id="5a17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以取消操作队列</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es nq"><img src="../Images/48b9ab7642e514975af6c4e1b00e41aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*a2VNetl7HTOvIgzHTcQbyA.png"/></div></figure><blockquote class="mr ms mt"><p id="1900" class="ix iy mu iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated"><em class="hi">操作队列保留操作，直到它们完成。挂起具有未完成操作的操作队列会导致内存泄漏。</em></p></blockquote><p id="b88f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">如何在操作队列上设置最大并发操作？</strong></p><p id="6bc7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du la lb lc ld b">maxConcurrentOperationCount</code>帮我们设置最大并发操作，但建议不要设置。</p><blockquote class="mr ms mt"><p id="07d7" class="ix iy mu iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated"><code class="du la lb lc ld b"><em class="hi">maxConcurrentOperationCount</em></code>设置为<code class="du la lb lc ld b"><em class="hi">1</em></code>，允许操作一个接一个的结束。它充当串行队列</p></blockquote><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es nr"><img src="../Images/01ae224d8386e2ad8c430452544d85cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34DvSf9upQ8mvAjzexfn9Q.png"/></div></div></figure><blockquote class="mr ms mt"><p id="7eaf" class="ix iy mu iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">缺省值是-1，这意味着让系统决定</p></blockquote><p id="a493" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">队列如何决定一次可以运行多少个操作？</strong></p><p id="f5d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这取决于硬件。默认情况下，<code class="du la lb lc ld b">OperationQueue</code>会在后台进行一些计算，并根据它运行的平台决定最大可能的线程数量。</p><p id="9b7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">操作队列按照什么顺序执行任务？</strong></p><p id="f8c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">队列中的操作是根据它们的就绪性来组织的，即(<code class="du la lb lc ld b">isReady</code>属性返回<code class="du la lb lc ld b">true</code>)、优先级&amp;依赖性，并被相应地执行。</p><p id="e03f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果所有排队的操作都有相同的<code class="du la lb lc ld b">queuePriority</code>并在被放入队列时准备好执行，那么它们将按照提交到队列的顺序执行。否则，操作队列总是执行相对于其他就绪操作具有最高优先级的操作。</p><p id="32d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直到一个操作对象的所有相关操作都执行完毕，它才准备好执行。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es ns"><img src="../Images/d96381add7f02c18cec3055653cc0872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5Snri5d0bhks3i9NBAocw.png"/></div></div><figcaption class="nf ng et er es nh ni bd b be z dx"><strong class="bd jw">Adding operation to operation queue and set maxConcurrentOperationCount</strong></figcaption></figure><p id="57c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">如何在操作间添加依赖关系？</strong></p><p id="a306" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑这样一种情况，您需要调用两个api，在这些api完成之后，您需要解析一个响应，然后您需要使用依赖管理器来实现这一点</p><p id="c7ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">操作之间没有依赖关系</strong></p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nt mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/2bbb49465ebebdce9a6a6fd03c7874b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*t2SaYdemRyHmpOfEgJcHTQ.png"/></div></figure><figure class="mg lp nu mi mj mk ml paragraph-image"><img src="../Images/e9c4e00c7b7ff477591fbffd00b15b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*30kmSIihToaM6-1OMxjM1A.png"/></figure></div><p id="f064" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">与</strong>之间存在依赖关系的操作</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nv mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/a819d7b96b3311bb94f0fd690f995e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*t4aM8lKHCDaBJlT1o6WmzA.png"/></div></figure><figure class="mg lp nw mi mj mk ml paragraph-image"><img src="../Images/28423ac71216312d3b6b058533572d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*TH2K8rBIGyffhCnWYNz-pg.png"/></figure></div><h2 id="3d8c" class="ls jv hi bd jw lt lu lv ka lw lx ly ke jg lz ma kg jk mb mc ki jo md me kk mf bi translated">使用操作队列的调度组实施:-</h2><p id="4679" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我们使用GCD调度组特性来阻塞一个线程，直到一个或多个任务执行完毕。</p><p id="f13f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过依赖关系使用操作队列实现了相同的行为。当您在所有指定任务完成之前不能做任何事情时，这很有用。</p><p id="5681" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在某些情况下，你需要并发运行，当所有的任务完成时，我们需要调用一些方法来表明所有的任务已经完成。这可以通过使用<code class="du la lb lc ld b">waitUntilFinished</code>来实现</p><div class="ll lm ln lo fd ab cb"><figure class="mg lp nx mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/3811c376184cdcd50ed4b97e2e998cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*IWrnSEz5nk2wKxyLB4gb2A.png"/></div></figure><figure class="mg lp ny mi mj mk ml paragraph-image"><img src="../Images/eb40a912845e0b37df73b20023170b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*HXDDCFUr7cWHZlEwG8Lx_Q.png"/></figure></div><h2 id="92d1" class="ls jv hi bd jw lt lu lv ka lw lx ly ke jg lz ma kg jk mb mc ki jo md me kk mf bi translated">异步与同步操作:-</h2><p id="c246" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">如果您计划手动执行操作对象，而不是将其添加到队列中，那么您可以将操作设计为以同步或异步方式执行。</p><p id="a4d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">操作对象默认是同步的。当您直接从代码中调用同步操作的<code class="du la lb lc ld b">start()</code>方法时，该操作会在当前线程中立即执行。</p><p id="6bd5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您调用异步操作的<code class="du la lb lc ld b">start()</code>方法时，该方法可能会在相应的任务完成之前返回。异步操作对象负责在单独的线程上调度其任务。</p><h1 id="85fd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">操作队列优于GCD的优势:-</h1><ol class=""><li id="bdd6" class="kr ks hi iz b ja km jd kn jg nz jk oa jo ob js kw kx ky kz bi translated">操作队列是队列模型的高级抽象，是在GCD之上建立的。</li><li id="e283" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">操作API提供了对依赖关系的支持。您可以非常容易地在任务之间创建复杂的依赖关系，虽然在GCD中您可以实现它，但是您必须做大量的工作。</li><li id="50b3" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">NSOperation和NSOperationQueue类有许多可以使用KVO(键值观察)来观察的属性。</li><li id="b30d" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">您可以监视操作或操作队列的状态。</li><li id="458f" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">可以暂停、恢复和取消操作。一旦您使用Grand Central Dispatch分派任务，您就不再能够控制或洞察该任务的执行。它提供对操作生命周期的控制</li><li id="1c0d" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js kw kx ky kz bi translated">您可以指定可以同时运行的队列操作的最大数量。这使得控制同时运行多少操作或创建串行操作队列变得容易。</li></ol><p id="0736" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.与GCD不同，它们不符合先进先出的顺序。</p><h1 id="678c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">注意:</h1><ul class=""><li id="461a" class="kr ks hi iz b ja km jd kn jg nz jk oa jo ob js le kx ky kz bi translated"><strong class="iz hj">要了解更多关于GCD和线程的信息，请阅读第一部分</strong> <a class="ae jt" rel="noopener" href="/geekculture/threads-in-ios-gcd-nsoperation-part-1-64e460c0bdea"> <strong class="iz hj">这里的博客:</strong> </a></li><li id="373e" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated"><strong class="iz hj">有关DispatchWorkItem、DispatchGroup、DispatchBarrier、DispatchSemaphore、DispatchSources的更多信息，请阅读第2部分</strong> <a class="ae jt" href="https://manasaprema04.medium.com/multithreading-in-ios-part-2-3-fe0116ffee5" rel="noopener"> <strong class="iz hj">博客</strong></a></li><li id="ffe7" class="kr ks hi iz b ja lf jd lg jg lh jk li jo lj js le kx ky kz bi translated"><a class="ae jt" href="https://manasaprema04.medium.com/27632d180f39" rel="noopener"> <strong class="iz hj">参考博客了解面试问题，了解多线程问题</strong> </a></li></ul><p id="aa6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">享受你的编码。 <strong class="iz hj">我希望你能从这篇博客</strong>中学到一些东西。<strong class="iz hj">请</strong> <strong class="iz hj"> <em class="mu">点击下面的鼓掌按钮👏去帮助别人找到它！。跟我上</em> </strong> <a class="ae jt" rel="noopener" href="/@manasaprema04"> <strong class="iz hj"> <em class="mu">中</em> </strong> </a> <strong class="iz hj"> <em class="mu">。</em>T19】</strong></p></div></div>    
</body>
</html>
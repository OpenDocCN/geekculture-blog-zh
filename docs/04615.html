<html>
<head>
<title>Unveiling C++ lvalues and rvalues mysteries (I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开C++左值和右值之谜(一)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/unveiling-c-lvalues-and-rvalues-mysteries-i-a829ec5a4aad?source=collection_archive---------25-----------------------#2021-06-30">https://medium.com/geekculture/unveiling-c-lvalues-and-rvalues-mysteries-i-a829ec5a4aad?source=collection_archive---------25-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5ebb25926376275364c3a763bcbab424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4keM6v-CbuRYw4OinaWkfQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae hv" href="https://unsplash.com/s/photos/code-rvalue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><h1 id="f5e7" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第一部分:左值和右值基础。</h1><p id="347f" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">自从C++11出现以来，左值和右值的含义和重要性已经扩展了。它们是需要理解的重要概念，因为它们有很多用途，你会发现它们与很多概念都有联系，比如左值/右值引用、移动语义、完全转发和移动构造函数等等。在这个由两部分组成的系列中，我们将展开所有这些元素，为您即将到来的C++项目提供可理解和可操作的知识。</p><p id="ff27" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在C++的过去版本中，<strong class="jv hz">左值</strong>和<strong class="jv hz">右值</strong>的概念并没有那么重要。这仅仅是在陈述中指出价值立场的一种区别。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="35c0" class="lf iw hy lb b fi lg lh l li lj">int value = 7;</span></pre><p id="2e91" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在下面的示例中，<strong class="jv hz">左值</strong>是名为“<em class="lk">值”</em>的整数类型，而<strong class="jv hz">右值</strong>是“7”。所以基本上，<strong class="jv hz">左值</strong>位于语句的左边，<strong class="jv hz">右值</strong>位于右边。但是，这些概念被延伸了，在今天，它们的意义和作用更加重要。</p><p id="c822" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">左值是指向内存位置的任何东西，因此你可以得到它的地址。因此，<strong class="jv hz">左值</strong>作为存储在内存中的变量，寿命更长。相比之下，<strong class="jv hz">右值</strong>是你得不到它的地址，不指向任何地方，并且寿命很短的东西。</p><p id="da35" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">把它们放在一起考虑，因为它们就像一个泡菜坛子:左值就是坛子本身，充当一个容器。<strong class="jv hz">右值</strong>是罐子里的东西(这里是泡菜)。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ll"><img src="../Images/338d3a1df8077b790c1aec58af8f1370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNnZhoP_k6YgWSRle38__A.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@suckerpunchgourmet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">SuckerPunch Gourmet</a> on <a class="ae hv" href="https://unsplash.com/s/photos/pickle-jar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3808" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">所以，回到我们的例子，让我们扩展一下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="790b" class="lf iw hy lb b fi lg lh l li lj">int value = 7;</span></pre><p id="6fb4" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这种情况下，<em class="lk">值</em>是一个<strong class="jv hz">左值</strong>，因为它是一个将要存储在内存中的变量，而数字“7”是一个<strong class="jv hz">右值</strong>，因为它是一个<em class="lk">文字常量</em>，除了程序执行期间的一些临时寄存器之外，它没有显式的内存地址。所以'<em class="lk">值'</em>是我们的罐子'<em class="lk"> 7 </em>'是我们的泡菜。很简单！</p><p id="2874" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一个语句中可以有两个左值。让我们关注这段代码的第二行:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b5ec" class="lf iw hy lb b fi lg lh l li lj">int value = 7;<br/>int * pointerToValue = &amp;value;</span></pre><p id="6403" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们已经确定'<em class="lk">值'</em>是一个<strong class="jv hz">左值</strong>。更进一步，<em class="lk"> pointerToValue </em>是一个<strong class="jv hz">左值</strong>，因为它是一个指针变量，通过使用操作符<em class="lk"> ' &amp; ' </em>指向<em class="lk">值</em>的地址。</p><p id="305c" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然而，如果我们尝试这样做，会发生什么呢？</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d63f" class="lf iw hy lb b fi lg lh l li lj">int value;<br/>7 = value;</span></pre><p id="87f1" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">您将得到一个编译器错误，因为表达式是不可赋值的。<em class="lk"> 7 </em>是一个<strong class="jv hz">右值</strong>，所以它没有被分配一个特定的内存位置。您试图将'<em class="lk">值'</em>赋给数字中间状态，这就是为什么编译器需要一个<strong class="jv hz">左值</strong>作为左操作数。但是重要的是要注意，这不仅仅是一个关于<strong class="jv hz">右值</strong>左侧位置的问题。当您写时，使用右值<strong class="jv hz">作为右操作数会出现类似的问题:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c41f" class="lf iw hy lb b fi lg lh l li lj">int * pointerToValue = &amp;7;</span></pre><p id="983b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这种情况下，编译器会报错，因为一元运算符<em class="lk"> ' &amp; ' </em>无法获取int类型的<strong class="jv hz">右值</strong>的地址，需要一个<strong class="jv hz">左值</strong>。如果您试图获取一个<strong class="jv hz">左值</strong>和一个<strong class="jv hz">右值</strong>之间的操作的地址，也会发生类似的事情:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="80d0" class="lf iw hy lb b fi lg lh l li lj">int value;<br/>// This line will not compile<br/>int * pointerToValue = &amp;(7 + value);</span></pre><p id="dc42" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一个有趣的发现是，您甚至可以将前缀递增运算符与address-of运算符结合使用，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c66a" class="lf iw hy lb b fi lg lh l li lj">int value = 7;<br/>int * pointerToValue = &amp;++value;<br/>// Prints 8<br/>std::cout &lt;&lt; * pointerToValue &lt;&lt; std::endl;</span></pre><p id="3d58" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">但是，您不能将这种组合与后增量运算符一起使用。这背后的原因是postfix ++有一个伪参数来存储变量的当前值，该值将在之后立即递增。这个临时参数是后递增运算符返回的一个右值，因此编译器无法得到它的地址:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a89a" class="lf iw hy lb b fi lg lh l li lj">int value = 7;<br/>// This line will not compile<br/>int * pointerToValue = &amp;value++;</span></pre><p id="51c6" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hz">功能和对象。</strong></p><p id="449f" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在是时候检查<strong class="jv hz">左值</strong>和<strong class="jv hz">右值</strong>如何与函数一起工作了。考虑以下代码:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a861" class="lf iw hy lb b fi lg lh l li lj">#include  &lt;cstdlib&gt;</span><span id="0892" class="lf iw hy lb b fi lm lh l li lj">int globalValue = rand()%10;</span><span id="f6c4" class="lf iw hy lb b fi lm lh l li lj">int someValue()<br/>{<br/> return rand()%100;<br/>}</span><span id="c916" class="lf iw hy lb b fi lm lh l li lj">int&amp; returnGlobalValue()<br/>{<br/> return globalValue;<br/>}</span><span id="822b" class="lf iw hy lb b fi lm lh l li lj">int main ()<br/>{<br/> someValue() = rand()%1000;</span><span id="094b" class="lf iw hy lb b fi lm lh l li lj"> returnGlobalValue() = someValue();<br/> returnGlobalValue() = rand()%10000;<br/>  <br/> return 0;<br/>}</span></pre><p id="230b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">首先要考虑的是<em class="lk"> rand() </em>函数调用会返回一个<strong class="jv hz">右值</strong>。所以当我们试图给函数<em class="lk"> someValue()，</em>赋值的时候，编译器会大喊需要一个<strong class="jv hz">左值</strong>作为赋值的左操作数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="76f3" class="lf iw hy lb b fi lg lh l li lj">//This line will not compile<br/> someValue() = rand()%1000;</span></pre><p id="eeb2" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，在<em class="lk"> somevalue() </em>函数中不能有返回引用。您将得到一个无效的初始化，因为对整数类型的<strong class="jv hz">左值</strong>引用不能与由<em class="lk"> rand() </em>函数生成的<strong class="jv hz">右值</strong>绑定:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="29e0" class="lf iw hy lb b fi lg lh l li lj">//This line will not compile<br/>int&amp; someValue()<br/>{<br/> return rand()%10;<br/>}</span></pre><p id="5ebc" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然而，我们有一个函数返回对左值的引用。<em class="lk"> returnGlobalValue() </em>指向全局变量<em class="lk"> globalValue </em>的内存位置。因为它是可赋值的，所以下面几行代码是有效的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="40f1" class="lf iw hy lb b fi lg lh l li lj">returnGlobalValue() = someValue()<br/>returnGlobalValue() = rand()%10000;</span></pre><p id="a89d" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在来说说对象。我们将定义一个非常简单的类和一些对象，然后我们将逐步剖析它们:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="056f" class="lf iw hy lb b fi lg lh l li lj">class AnObject<br/>{<br/>//…<br/> public:</span><span id="b1e9" class="lf iw hy lb b fi lm lh l li lj">  AnObject(){}<br/>  AnObject(int param){}</span><span id="bbc0" class="lf iw hy lb b fi lm lh l li lj">};</span><span id="f30a" class="lf iw hy lb b fi lm lh l li lj">AnObject getAnObject()<br/>{<br/> return AnObject();<br/>}</span><span id="d0b1" class="lf iw hy lb b fi lm lh l li lj">int main ()<br/>{<br/> AnObject Object = getAnObject();<br/> AnObject *pointerToObject = &amp;Object1;<br/> AnObject *pointerToObject2 = &amp;getAnObject();<br/>}</span></pre><p id="bd07" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">你现在可以假设<em class="lk">对象</em>是一个<strong class="jv hz">左值，</strong>并且它被初始化没有问题，因为<em class="lk"> getAnObject() </em>函数返回一个<strong class="jv hz">右值</strong>然后分配给它。与我们的变量示例相似，<em class="lk"> pointerToObject </em>是一个<strong class="jv hz">左值，</strong>因为它是一个指针对象，指向“<em class="lk">对象”</em>的地址。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cba3" class="lf iw hy lb b fi lg lh l li lj">//This works fine<br/> AnObject Object = getAnObject();<br/> AnObject *pointerToObject = &amp;Object;</span></pre><p id="c8be" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，您也许能够理解定义<em class="lk">pointer tobject 2</em>的代码行不会编译，因为我们试图获取一个临时对象的地址。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0b0e" class="lf iw hy lb b fi lg lh l li lj">//This line will not compile<br/> AnObject *pointerToObject2 = &amp;getAnObject();</span></pre><p id="e258" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">干得好！现在你可以理解基本概念了。没那么难，对吧？在下一篇文章中，我们将进一步探索并讨论<strong class="jv hz">左值</strong>和<strong class="jv hz">右值</strong>之间的引用和转换。直到下一次，编码快乐！</p></div></div>    
</body>
</html>
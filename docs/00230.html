<html>
<head>
<title>First Steps with .NET Core Testing using NUnit and NSubstitute: A Clean Hexagonal Approach (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第一步是。使用NUnit和NSubstitute的NET Core测试:干净的六边形方法(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/net-core-testing-using-nunit-and-nsubstitute-a-clean-hexagonal-approach-part-1-5a2acec7f492?source=collection_archive---------2-----------------------#2020-11-22">https://medium.com/geekculture/net-core-testing-using-nunit-and-nsubstitute-a-clean-hexagonal-approach-part-1-5a2acec7f492?source=collection_archive---------2-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e63590137dfaf82eb1ec013e14fdf4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FUzdDQg00hwGscFc"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image credit: <a class="ae iu" href="https://unsplash.com/@mitchel3uo" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@mitchel3uo</a></figcaption></figure><blockquote class="iv"><p id="bbf7" class="iw ix hi bd iy iz ja jb jc jd je jf dx translated"><em class="jg">“可以在没有UI、数据库、Web服务器或任何其他外部元素的情况下测试业务规则”。</em></p></blockquote><p id="91b0" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd jf hb bi translated">上面的引语是罗伯特·c·马丁，也就是鲍勃大叔，在他亲切、令人惊讶、伟大的<a class="ae iu" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">博客Clean Coder </a>中写的。</p><p id="4a18" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">这是否意味着我们可以实现项目的所有业务规则，并在添加数据库、API或类似的东西之前测试所有规则？</p><p id="cd1d" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">当然有！</p><p id="6c85" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">我们的领域层(或者用例，或者业务，名称由您决定，取决于您在这一部分中的方法)应该实现系统上的所有业务规则，而不依赖于其他层。事实上，这一层必须是其他层所依赖的那一层。</p><p id="c94d" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">换句话说，包含业务规则的层必须不了解数据库以及任何其他外部端口，即外部服务或缓存服务。外层依赖于内层。而不是相反。</p><p id="5e7d" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">这就是<a class="ae iu" href="https://clean-code-developer.com/weitere-infos/solid/" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>，它允许我们在这种情况下做我们想做的事情:解耦我们软件的模块。</p><p id="e230" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">我在本文中的目标是展示如何实现一个带有数据库层接口的小型领域层。之后，我们将使用NUnit和Nsubstitute创建一个测试项目来模拟我们的数据库。这样，您甚至可以在选择数据库之前模拟返回数据，实现和测试业务规则。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="1804" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">在这篇文章中，我创建了一个名为Transactions的项目。域和名为TransactionsMs.sln的解决方案。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="872a" class="kz la hi kv b fi lb lc l ld le">dotnet new sln --name TransactionMs</span><span id="cd19" class="kz la hi kv b fi lf lc l ld le">dotnet new classlib --framework netstandard2.1 --name Transactions.Domain</span><span id="955b" class="kz la hi kv b fi lf lc l ld le">dotnet sln Transactions.sln add Transactions.Domain/</span></pre><p id="606f" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">让我们从创建我们的域层开始，它将包含我们所有的业务逻辑。我创建了一个AccountTransaction类，这是我在这里创建的用例的主要实体。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/3c55d74da600c19c36c652ba367bc72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfGWIVt1TZJ0GsxUtgP-JA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The AccountTransaction class</figcaption></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/3795115bd83a49c04f3e89e549bba028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LjDkrzchJGd-0VxQzdsjg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">BaseEntity class</figcaption></figure><p id="b581" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">在我们的领域层内部，我们有到存储库的接口。在<a class="ae iu" rel="noopener" href="/thecodefountain/a-quick-introduction-to-hexagonal-architecture-484358c038b8">六角形结构</a>术语中，它将是一个输出或辅助端口。领域层不能依赖于存储库层，存储库层是基础设施层的一部分。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es li"><img src="../Images/bf9fd8097be8fe0e90ebc5db8bec3f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*6cWFDFfRkZP044W9bGUG8A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Interface for the Repository, the domain port to the external (database) world</figcaption></figure><p id="a9a4" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">之后，AccountTransactionUseCases类用于与我们的存储库层通信。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/10b028b74d87aec1e2ea47a0f4287717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wajErAtLkwuo1CthaVyeWg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The service class</figcaption></figure><p id="821b" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">这个类具有业务逻辑。它可以包含验证、实体实例的创建、与输出端口的通信等。在这种情况下，我们有对接口的调用，这将是最近注入的。</p><p id="72b1" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">这是我们目前的结构:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/76051e848b2b6f6bd821c8f13d81288a.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*8Mu7VB0NBVERU5EHyd_1xg.png"/></div></figure><p id="96d9" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">正如您所看到的，域层不知道任何关于存储库实现层的事情。这就是我们的目标。</p><p id="4593" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">毕竟，寓意是:让实现细节远离您的业务逻辑！这包括数据库、API或控制台应用程序项目和测试套件，我们将在下一部分将它们包含到我们的解决方案中。</p><p id="07ee" class="pw-post-body-paragraph jh ji hi jj b jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka ki kc kd jf hb bi translated">第二集也是最后一集见。</p></div></div>    
</body>
</html>
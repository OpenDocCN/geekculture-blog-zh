<html>
<head>
<title>Generics in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的泛型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/generics-in-go-5a36b1f978bc?source=collection_archive---------4-----------------------#2021-04-27">https://medium.com/geekculture/generics-in-go-5a36b1f978bc?source=collection_archive---------4-----------------------#2021-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9690bf64d0550f9050e5d655f04c2084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*i9BUF_q6uir_cfQFh9ql8A.jpeg"/></div></figure><p id="126a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Go团队发布了一个类型参数的设计草案，通俗地说就是泛型。预计会包含在Go 1.18中。虽然最后可能还会有变化。</p><p id="1d14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated"><span class="l jl jm jn bm jo jp jq jr js di"> Go </span>是一种静态类型语言，这意味着在编译代码时会检查变量和参数的类型。内置类型(地图、切片、通道)和函数(如<code class="du jt ju jv jw b"><strong class="io hj">len</strong></code>、<code class="du jt ju jv jw b"><strong class="io hj">cap</strong></code>或<code class="du jt ju jv jw b"><strong class="io hj">make</strong></code>)可以接受并返回不同类型的值，但用户定义的Go类型和函数不能。如果您熟悉Java、C++或其他具有各种泛型的语言，那么Go类型系统的简单性可能会导致一些挫折。</p><p id="d3e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您熟悉动态类型语言，在这种语言中，直到代码运行时才计算类型，您可能不理解泛型有什么好大惊小怪的，并且您可能对它们是什么有点不清楚。如果您将它们视为“类型参数”会有所帮助我们习惯于编写接受参数的函数，这些参数的值是在调用函数时指定的。类似地，我们创建结构，其中字段的值在结构被实例化时被指定。<strong class="io hj">泛型是这样一个概念，即有时编写函数或结构是有用的，其中在使用时指定了参数或字段的特定<em class="jx">类型</em>。</strong></p><p id="8eb4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">自从Go第一次发布以来，就有人呼吁在语言中加入泛型。Go的开发负责人Russ Cox在2009年写了一篇博客来解释为什么最初没有包含泛型。Go强调快速的编译器、可读的代码和良好的执行时间，他们所知道的泛型实现都不允许他们包含这三者。经过十年对这个问题的研究，Go团队认为他们有了一个可行的方法，在<a class="ae jy" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md" rel="noopener ugc nofollow" target="_blank">类型参数-设计草案</a>中列出。</p><p id="fc22" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将通过查看一个简单的堆栈来了解泛型在Go中是如何工作的。如果你要实现一个没有泛型的任何类型的堆栈，你应该这样做:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="2f2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以这样使用它:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="5010" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可以工作并打印出30 true，但是您可以将任何类型的值插入到这个堆栈中，如果您想做的不仅仅是打印出由<code class="du jt ju jv jw b"><strong class="io hj">Pop</strong></code>返回的值，您需要使用一个类型断言将它转换成被插入的类型。让我们看看Go泛型是如何使这个堆栈类型安全的:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="e8ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有几件事需要注意。首先，我们在类型声明后有<code class="du jt ju jv jw b"><strong class="io hj">[T any]</strong></code>。类型参数放在括号内。它们就像变量参数一样，首先是类型名，其次是类型绑定。您可以为类型参数选择任何名称，但通常使用大写字母。Go使用接口来指定可以使用的类型。如果有任何类型可用，则用新的universe块标识符<code class="du jt ju jv jw b"><strong class="io hj">any</strong></code>来指定，这与<code class="du jt ju jv jw b"><strong class="io hj">interface{}</strong></code>完全等效，但只在类型约束内有效。在<code class="du jt ju jv jw b"><strong class="io hj">Stack</strong></code> <strong class="io hj"> </strong>声明中，我们将<code class="du jt ju jv jw b"><strong class="io hj">vals</strong></code> <strong class="io hj"> </strong>声明为<code class="du jt ju jv jw b"><strong class="io hj">[]T</strong></code>类型，而不是<code class="du jt ju jv jw b"><strong class="io hj">[]interface{}</strong></code>。<br/>接下来，我们看看我们的方法声明。就像我们在<code class="du jt ju jv jw b"><strong class="io hj">vars</strong></code> <strong class="io hj"> </strong>声明中用<code class="du jt ju jv jw b"><strong class="io hj">T</strong></code> <strong class="io hj"> </strong>替换<code class="du jt ju jv jw b"><strong class="io hj">interface{}</strong></code>一样，我们在这里也是这样做的。我们也用<code class="du jt ju jv jw b"><strong class="io hj">Stack[T]</strong></code>而不是<code class="du jt ju jv jw b"><strong class="io hj">Stack</strong></code>来指代接收器部分中的类型。最后，泛型让零值处理变得有点有趣。在<code class="du jt ju jv jw b"><strong class="io hj">Pop</strong></code>中，我们不能只返回<code class="du jt ju jv jw b"><strong class="io hj">nil</strong></code>，因为那不是值类型的有效值，就像<code class="du jt ju jv jw b"><strong class="io hj">int</strong></code>一样。为泛型获取零值的最简单方法是简单地用<code class="du jt ju jv jw b"><strong class="io hj">var</strong></code> <strong class="io hj"> </strong>声明一个变量并返回它，因为根据定义，如果没有指定其他值，<code class="du jt ju jv jw b"><strong class="io hj">var</strong></code> <strong class="io hj"> </strong>总是将其变量初始化为零值。</p><p id="0d8a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用泛型类型与使用非泛型类型非常相似:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="4f85" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">唯一的区别是，当我们声明变量时，我们包含了我们希望与我们的<code class="du jt ju jv jw b"><strong class="io hj">Stack</strong></code>一起使用的类型，在本例中是<code class="du jt ju jv jw b"><strong class="io hj">int</strong></code>。现在，<code class="du jt ju jv jw b"><strong class="io hj">v</strong></code> <strong class="io hj"> </strong>有类型<code class="du jt ju jv jw b"><strong class="io hj">int</strong></code> <strong class="io hj"> </strong>而没有<code class="du jt ju jv jw b"><strong class="io hj">interface{}</strong></code>，所以可以不用类型断言来使用。此外，如果您试图将一个字符串压入我们的堆栈，编译器会捕捉到它。添加该行:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="cdbd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">产生编译器错误:<br/> <strong class="io hj">无法将“nope”(无类型字符串常量)转换为int </strong></p><p id="52ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为泛型还没有正式发布，所以它们在Go游戏场上不被支持。然而，这里有一个临时的<a class="ae jy" href="https://go2goplay.golang.org/p/8ft3RtocNua" rel="noopener ugc nofollow" target="_blank">“Go2Go”游戏场</a>，你可以在那里试用通用堆栈。让我们添加另一个方法到我们的堆栈中，告诉我们堆栈是否包含一个值:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="f8e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不幸的是，这不能编译。它给出的错误:<br/> <strong class="io hj">不能比较v == val (operator ==没有为T定义)</strong></p><p id="276a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就像<code class="du jt ju jv jw b"><strong class="io hj">interface{}</strong></code>不说什么一样，<code class="du jt ju jv jw b"><strong class="io hj">any</strong></code>也不说什么。我们只能存储<code class="du jt ju jv jw b"><strong class="io hj">any</strong></code> <strong class="io hj"> </strong>类型的值并进行检索。要使用<code class="du jt ju jv jw b"><strong class="io hj">==</strong></code>，我们需要一个不同的类型。由于几乎所有的围棋类型都可以与<code class="du jt ju jv jw b"><strong class="io hj">==</strong></code>和<code class="du jt ju jv jw b"><strong class="io hj">!=</strong></code>进行比较，因此在universe block中定义了一个名为<code class="du jt ju jv jw b"><strong class="io hj">comparable</strong></code> <strong class="io hj"> </strong>的新内置接口。如果我们将<code class="du jt ju jv jw b"><strong class="io hj">Stack</strong></code>的定义改为使用<code class="du jt ju jv jw b"><strong class="io hj">comparable</strong></code>:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="b202" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们可以使用我们的新方法:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="392c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将打印出:</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="669a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以试试这个<a class="ae jy" href="https://go2goplay.golang.org/p/Ep2_6Zftl5r" rel="noopener ugc nofollow" target="_blank">更新的栈</a>。</p><p id="af7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章的参考资料中，你可以了解更多关于不同标题的Go Generic，例如:<em class="jx">使用类型列表指定操作符，泛型函数抽象算法，类型列表限制常量和实现</em></p><h1 id="c858" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="d94a" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">添加泛型显然改变了一些关于如何惯用地使用Go的建议。使用<code class="du jt ju jv jw b"><strong class="io hj">float64</strong></code> <strong class="io hj"> </strong>来代表任何数值类型的做法将会结束。我们将不再使用<code class="du jt ju jv jw b"><strong class="io hj">interface{}</strong></code>来表示数据结构或函数参数中任何可能的值。您可以用一个函数处理不同的切片类型。但是不要觉得有必要立即将所有代码切换到使用类型参数。随着新设计模式的发明和改进，旧代码仍然可以工作。</p><p id="ff56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为没有泛型的生产实现，所以很难说它们会如何影响性能。很可能在编译时和运行时都会有一些影响。一如既往，目标是编写可维护的程序，足够快以满足您的需求。</p><p id="69c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">我们展望了泛型，以及它们将如何改变我们使用Go解决问题的方式。实现还没有发布，所以仍然有额外变化的可能性，但它们可能是最小的。</strong></p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><ul class=""><li id="3066" class="lp lq hi io b ip iq it iu ix lr jb ls jf lt jj lu lv lw lx bi translated">资源:《学习围棋》最后一章的第二部分，作者Jon Bodner</li></ul><div class="ly lz ez fb ma mb"><a href="https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">学习围棋:现实世界围棋编程的惯用方法</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">亚马逊网站:学习围棋:现实世界围棋编程的惯用方法(9781492077213)</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.amazon.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ik mb"/></div></div></a></div><ul class=""><li id="a760" class="lp lq hi io b ip iq it iu ix lr jb ls jf lt jj lu lv lw lx bi translated">补充内容:<a class="ae jy" href="https://github.com/learning-go-book" rel="noopener ugc nofollow" target="_blank">https://github.com/learning-go-book</a></li></ul></div></div>    
</body>
</html>
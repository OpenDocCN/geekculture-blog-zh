<html>
<head>
<title>Sorting Algorithms: Merge Sort in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法:Golang中的合并排序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sorting-algorithms-merge-sort-in-golang-2ae73ff07906?source=collection_archive---------15-----------------------#2022-02-15">https://medium.com/geekculture/sorting-algorithms-merge-sort-in-golang-2ae73ff07906?source=collection_archive---------15-----------------------#2022-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5b07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并排序是一种非常流行的排序算法。它基于分而治之的方法，也就是说，在这个算法中，你把数组分成相等的两半，直到每一半只有一个元素。分割数组后，开始递归合并它们，直到得到一个排序后的数组。</p><p id="7ad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的示例展示了合并排序的工作方式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fbdbd277a1bd1d9a1168a5274c8896c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*_tBdh66087ggR6RIcJ-jOQ.jpeg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Working of Merge Sort</figcaption></figure><p id="ceee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Go中合并排序的实现:</strong></p><p id="e4cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用递归编写合并排序代码，我们称之为合并排序，直到每一半都包含一个元素。当每一半只有一个元素时，我们就调用merge操作来合并两个未排序的数组，直到我们得到完整排序的数组。在合并操作中，我们被给定两个未排序数组的开始、中间和最后的索引，我们创建两个数组命名为左和右子数组，并开始合并它们。合并操作的空间<strong class="ih hj">复杂度是O(n) </strong>因为我们需要用于左右子阵列的空间。当我们运行循环直到数组的长度时，合并操作的时间<strong class="ih hj">复杂度也是O(n) </strong>。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="9bb7" class="ju jv hi jq b fi jw jx l jy jz">package main<br/>import "fmt"<br/>func Merge_sort(A *[]int,start int,last int){<br/>    if start&lt;last{<br/>       mid :=(start+last)/2<br/>       fmt.Printf("mid is:%d",mid)<br/>       Merge_sort(A, start, mid)<br/>       Merge_sort(A,mid+1,last)<br/>       Merge(A,start,mid,last)<br/>       PrintArr(A)<br/>    }<br/>}<br/>func Merge(A *[]int,start,mid,last int){<br/>   n1:=mid-start+1<br/>   n2:=last-mid<br/>   l:=make([]int,n1 )<br/>   r:= make([]int, n2)<br/>   for i:=0;i&lt;n1;i++{<br/>     l[i] = (*A)[start+i]<br/>   }<br/>   for j:=0;j&lt;n2;j++{<br/>     r[j] = (*A)[mid+1+j]<br/>   }<br/>   i:=0<br/>   j:=0<br/>   k:=start<br/>   for i&lt;n1 &amp;&amp; j&lt;n2{<br/>     if l[i]&lt;r[j]{<br/>        (*A)[k] =l[i]<br/>        i++<br/>        k++<br/>     }else{<br/>        (*A)[k]=r[j]<br/>         j++<br/>         k++<br/>     }<br/>  }<br/>  for i==n1 &amp;&amp;j&lt;n2{<br/>     (*A)[k] = r[j]<br/>      j++<br/>      k++<br/>  }<br/>  for j==n2 &amp;&amp;i&lt;n1{<br/>     (*A)[k] = l[i]<br/>      i++<br/>      k++<br/>  }<br/>}<br/>func PrintArr(A *[] int){<br/>    for i:=0; i&lt;len(*A);i++{<br/>       fmt.Printf("A[%d]:%d\n", i ,(*A)[i])<br/>    }<br/>}<br/>func main(){<br/>    A:=[]int{38,27,43,3,9,82,10}<br/>    Merge_sort(&amp;A, 0,(len(A)-1))<br/>    fmt.Printf("Array after merge sort:\n")<br/>    PrintArr(&amp;A)<br/>}</span></pre><p id="ffb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">合并排序是一种非位置算法</strong>，因为它在合并操作中使用额外的内存空间来排序。<strong class="ih hj">它是一个内部排序</strong>算法，因为它不改变相似元素的顺序。<strong class="ih hj">归并排序算法的时间复杂度为O(n*log(n)) </strong>因为归并操作称为O(log(n))时间。<strong class="ih hj">归并排序的空间复杂度为O(n) </strong> [(O(n)(由于归并操作)+O(log(n))(由于用于递归的堆栈空间)= O(n)]。</p><p id="3fcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，那就鼓掌跟帖吧。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Synchronizing asynchronous networking calls using iOS 15 Group task API.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用iOS 15组任务API同步异步网络调用。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/synchronizing-asynchronous-networking-calls-using-ios-15-group-task-api-1f5b764c731d?source=collection_archive---------20-----------------------#2021-06-17">https://medium.com/geekculture/synchronizing-asynchronous-networking-calls-using-ios-15-group-task-api-1f5b764c731d?source=collection_archive---------20-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1a2efe1be78417380c11886b848c8a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4UAXh56MnCsFuM1ZpFibg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://github.com/jamesrochabrun/iOSConcurrency" rel="noopener ugc nofollow" target="_blank">https://github.com/jamesrochabrun/iOSConcurrency</a></figcaption></figure><p id="52bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我想展示我如何在一个示例项目<strong class="ix hj">、</strong>中使用新的<strong class="ix hj">组任务iOS 15 API </strong>来执行一组对Itunes API的网络调用。</p><p id="27f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该项目非常简单，看起来像这样…</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/13f7b2e095dc0db48c9195756e064337.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*mdmDO_0CVJKg4o-YOamrjA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Itunes feed resources</figcaption></figure><p id="1f08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它显示了您可以从Itunes API中找到的不同类别的提要。为了获得每个类别，我们需要执行一个独立的API调用，然后我们需要以某种方式混合每个类别的结果，这样我们就可以将它们加载到同一个提要中。</p><p id="9444" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们看看如何使用<a class="ae iu" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> DispatchGroup </strong> </a>，<strong class="ix hj"> </strong>来实现这一点，然后我们将看看如何使用组任务来实现相同的结果。</p><p id="73df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想跳过这篇文章的其余部分，你可以在这里找到这个教程的完整实现</p><p id="e917" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在回购协议上，你会发现…</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx">ItunesCategoryIdentifier.swift</figcaption></figure><p id="c228" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">itunes categoryidentifier</strong>代表我们将在应用程序中显示的类别。</p><ol class=""><li id="6615" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">类别。</li><li id="896f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">我们将为每个部分显示的标题。</li><li id="265f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">一个静态属性，表示我们将从每个API调用中检索的项数。(为简单起见，我们将要求4个项目)</li><li id="e5df" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">要获取的媒体类型，iTunes API端点将媒体类型作为参数，我们创建了一个enum来轻松访问媒体类型，要查看其实现，请访问repo内的<strong class="ix hj"> FeedGenerator.swift </strong>。</li></ol><p id="4c97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见<strong class="ix hj">itunes categoryidentifier</strong>使<strong class="ix hj"> </strong>符合<strong class="ix hj"> CaseIterable </strong>，这将允许我们遍历所有案例以获取每个类别<strong class="ix hj">、</strong>，它还有一个<strong class="ix hj">Int</strong>raw<strong class="ix hj"/>value<strong class="ix hj">、</strong>，这将帮助我们按照我们想要的顺序显示结果。</p><p id="886c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要探索一下ItunesRemote的类。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><ol class=""><li id="c077" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><strong class="ix hj"> ItunesRemote </strong>使<strong class="ix hj"> </strong>与<strong class="ix hj"> ObservableObject </strong>一致，将结果发布到我们的<strong class="ix hj"> SwiftUI </strong>视图<strong class="ix hj">中。(</strong>我们将在这里使用<strong class="ix hj"> SwiftUI </strong>，但是我们也可以在<strong class="ix hj"> UIKit </strong>应用<strong class="ix hj">中使用这个对象)。</strong></li><li id="8635" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj"> ItunesCategorySection </strong>是一个代表每个类别的节的结构，它有代表节标识符的<strong class="ix hj"> sectionID </strong>属性和代表该节内项目的<strong class="ix hj"> cellIDs </strong>属性。它符合<strong class="ix hj"> IdentifiableHashable </strong>(由<strong class="ix hj"> Hashable </strong>和<strong class="ix hj">identificate</strong>组成的协议，有助于避免样板代码，如果您希望它在repo的<strong class="ix hj">Identifiable has hable . swift</strong>文件中，请检查它🤓)，这种一致性是必需的，因此这个对象可以在一个<strong class="ix hj"> SwiftUI </strong>视图中使用。</li><li id="24e7" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">ItunesClient是一个使用通用网络层从服务器获取项目的客户端，如果您有兴趣了解更多关于使用combine实现网络层的信息，您可以访问<a class="ae iu" rel="noopener" href="/if-let-swift-programming/generic-networking-layer-using-combine-in-swift-ui-d23574c20368">此处</a>，或者如果您想了解如何使用async/await，您可以访问<a class="ae iu" href="https://jamesrochabrun.medium.com/create-a-generic-networking-layer-using-async-await-9168b6281721" rel="noopener">此处</a>。</li><li id="4531" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">发布结果所需的发布者和可取消对象。</li></ol><p id="33a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们要在<strong class="ix hj"> ItunesRemote </strong>中创建一个函数，使用<strong class="ix hj"> Dispatchgroup </strong>来执行我们的任务组…</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx">DispatchGroup implementation</figcaption></figure><ol class=""><li id="81de" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">调度组的实例。</li><li id="7a55" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">节的数组，我们将在这里存储我们的节。</li><li id="5d29" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">遍历作为参数传递的所有类别标识符数组。</li><li id="5ed9" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">我们从一个调度组调用enter方法，将请求引入该组。</li><li id="a980" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">我们为每个类别执行一个网络呼叫。</li><li id="781f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">通话结束后，我们离开小组。</li><li id="9db7" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">使用Combine，我们接收某个类别的提要，然后将它们转换成视图模型，然后创建section对象并将其添加到sections数组中。</li><li id="a78f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">使用一个通知闭包，该闭包将在循环中的所有网络任务完成后执行，我们用按<strong class="ix hj"> sectionID </strong> rawValue排序的部分数组来设置<strong class="ix hj"> Published </strong>属性<strong class="ix hj"> itunesSection </strong>。</li></ol><p id="9169" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ko">排序是必需的，因为当我们在一个调度组中执行不同的异步任务时，我们不能保证每个请求的响应顺序。解决这个问题的一个方法是使用一个带有整数原始值的枚举作为部分标识符，通过这样做，我们可以对部分进行排序，并根据我们的需要轻松地修改顺序。这是一种方法，我相信还有很多其他的方法，如果你想分享你的方法，请在评论中分享！。😉</em></p><p id="df8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始使用iOS 15组任务实现之前，让我们在<strong class="ix hj"> SwiftUI </strong>视图中使用它…</p><pre class="ju jv jw jx fd kp kq kr ks aw kt bi"><span id="067c" class="ku kv hi kq b fi kw kx l ky kz"><strong class="kq hj">@available</strong>(iOS 15, *)</span><span id="c6b7" class="ku kv hi kq b fi la kx l ky kz"><strong class="kq hj">struct</strong> ContentView: View {</span><span id="b104" class="ku kv hi kq b fi la kx l ky kz">@StateObject <strong class="kq hj">private</strong> <strong class="kq hj">var</strong> itunesRemote = ItunesRemote()<br/><strong class="kq hj">let</strong> columns = [GridItem(.flexible()), GridItem(.flexible())]</span><span id="9e4b" class="ku kv hi kq b fi la kx l ky kz"><strong class="kq hj">var</strong> body: <strong class="kq hj">some</strong> View {<br/>    ScrollView {<br/>           LazyVGrid(columns: columns, spacing: 0) {<br/>                ForEach(itunesRemote.itunesSections, id: \.self) { section <strong class="kq hj">in<br/>                   </strong>Section(header: Text("\(section.sectionID.title)").font(.title).bold().padding(15)) {<br/>ForEach(section.cellIDs) {<br/>                   FeedItemView(artwork: $0)<br/>                }<br/>           }<br/>       }<br/>    }<br/>}<br/>.task {<br/>     itunesRemote.dispatchGroups(from:ItunesCategoryIdentifier.allCases)<br/>  }<br/> }<br/>}</span></pre><p id="4e7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你在这里看到的，我们在一个<strong class="ix hj"> LazyGrid </strong>中用不同的部分显示我们的类别，每个部分上显示的项目都来自我们的<strong class="ix hj"> itunesSections </strong>数组属性。</p><p id="6374" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在让我们创建一个使用组任务的新函数…</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><ol class=""><li id="ec7c" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">可悲的是，需要将这个功能标记为iOS 15可用，因为这些新的API在以前的版本中不可用。😭(这已经不成立了！现在我们可以有一个使用异步API的变通方法，正如你在约翰·桑德尔的<a class="ae iu" href="https://www.swiftbysundell.com/articles/making-async-system-apis-backward-compatible/" rel="noopener ugc nofollow" target="_blank">帖子</a>中看到的。</li><li id="ca39" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">将逻辑封装在一个<strong class="ix hj">任务</strong>块中会在一个同步上下文中“桥接”一个异步调用，如果你想知道这意味着什么，你可以到<a class="ae iu" href="https://jamesrochabrun.medium.com/create-a-generic-networking-layer-using-async-await-9168b6281721" rel="noopener">这里</a>。</li><li id="4e71" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">一个数组，我们将在其中存储我们的部分类别。</li><li id="6882" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">一个组任务启动一个新的作用域，在这个作用域中可以产生动态数量的抛出任务。它将某个子任务的结果类型作为参数，并将一个组任务的值作为闭包，在本例中“categorySection”是一个抛出的任务组，如下所示…</li></ol><pre class="ju jv jw jx fd kp kq kr ks aw kt bi"><span id="395b" class="ku kv hi kq b fi kw kx l ky kz">ThrowingTaskGroup&lt;ItunesRemote.ItunesCategorySection, Error&gt;</span></pre><p id="074e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.我们遍历类别标识符数组，为每个类别执行一个子任务。</p><p id="9b70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.在add task块中，该组执行一个子任务，在本例中是一个执行网络请求的throwable异步调用。稍后，我们使用来自该请求的feed结果来创建视图模型，然后创建我们的<strong class="ix hj"> ItunesCategorySection </strong>对象。</p><p id="ee60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.这是一个<strong class="ix hj"> AsyncSequence </strong>实现，它基本上是我们如何在一个序列中执行异步函数，它们通过使用<strong class="ix hj"> await </strong>关键字挂起每个元素，并在底层迭代器产生一个值或抛出时恢复。关于<strong class="ix hj">异步序列</strong>的更多信息，请查看此<a class="ae iu" href="https://developer.apple.com/videos/play/wwdc2021/10058/?time=17" rel="noopener ugc nofollow" target="_blank"> WWDC 2021视频。</a></p><p id="3aa8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.在节数组中追加iTunes类别节。</p><blockquote class="lb lc ld"><p id="8492" class="iv iw ko ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">需要知道的一件很酷的事情是，通过使用AsyncSequence设计，我们还可以在编写可变值时避免竞争情况。关于这方面的更多内容，请进入 <a class="ae iu" href="https://developer.apple.com/videos/play/wwdc2021/10134/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="hi">探索Swift中的结构化并发来自WWDC 2021</em></strong></a><strong class="ix hj"><em class="hi">。</em> </strong></p></blockquote><p id="4283" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">9.与调度组实现相同，我们用按<strong class="ix hj"> sectionID </strong> rawValue排序的部分数组来设置<strong class="ix hj"> Published </strong>属性<strong class="ix hj"> itunesSection </strong>。</p><p id="2647" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在我们的<strong class="ix hj"> SwiftUI </strong>视图中，让我们使用这个新方法，移除调度组调用，并将这个调用添加到<strong class="ix hj"> ContentView </strong>结构中的<strong class="ix hj"> task </strong>闭包内…</p><pre class="ju jv jw jx fd kp kq kr ks aw kt bi"><span id="05c5" class="ku kv hi kq b fi kw kx l ky kz">.task {🎉itunesRemote.asyncGroups(from: ItunesCategoryIdentifier.allCases)   <br/>}</span></pre><p id="74c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果你运行应用程序，你会看到应用程序中的类别，但这一次使用的是小组任务！</p><p id="66ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有关Swift并发的更多信息，您可以在这里找到WWDC 2021的<a class="ae iu" href="https://jamesrochabrun.medium.com/create-a-generic-networking-layer-using-async-await-9168b6281721" rel="noopener">精选视频列表</a>。</p><p id="d28e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">帖子更新于2022年1月3日。</p><p id="c53e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ko">感谢</em>。🤖</p></div></div>    
</body>
</html>
<html>
<head>
<title>Building a Node.js CLI with TypeScript, packaged and distributed via Homebrew</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript构建Node.js CLI，通过自制软件打包和分发</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-node-js-cli-with-typescript-packaged-and-distributed-via-homebrew-15ba2fadcb81?source=collection_archive---------0-----------------------#2021-06-20">https://medium.com/geekculture/building-a-node-js-cli-with-typescript-packaged-and-distributed-via-homebrew-15ba2fadcb81?source=collection_archive---------0-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f9f7a8f1a151da09f088afbcfb3936af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6NZzNw7YDF_MIMRFf2PbQ.png"/></div></div></figure><p id="c7ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Sniptt，我们的大部分经验都是为Node编写TypeScript和JavaScript，所以我们决定使用相同的技术来构建最初几个版本的<a class="ae jo" href="https://github.com/sniptt-official/snip-cli" rel="noopener ugc nofollow" target="_blank"> Snip CLI </a>。然而，我们的初步测试表明，在npm上专门分发安全软件并不适合我们的许多用户。虽然我们的长期目标是将Snip CLI移植到Golang(见我们的第一次尝试<a class="ae jo" href="https://github.com/sniptt-official/ots" rel="noopener ugc nofollow" target="_blank">这里</a>)，但我们决定在此之前采取一种务实的方法，将我们的JavaScript代码打包成适用于macOS和Linux的独立可执行二进制文件。</p><p id="cafc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将向您展示如何使用TypeScript构建一个简单的Node.js CLI，然后通过Homebrew打包并分发它。</p><p id="103f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">TLDR；</strong>要查看包括工作流自动化在内的完整设置，请查看我们如何在<a class="ae jo" href="https://github.com/sniptt-official/snip-cli" rel="noopener ugc nofollow" target="_blank">https://github.com/sniptt-official/snip-cli</a>使用我们的官方CLI完成这项工作😎。</p><h2 id="523d" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">项目设置</h2><p id="45b5" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">让我们通过<code class="du kp kq kr ks b">npm init</code>初始化一个名为<code class="du kp kq kr ks b">hello</code>的新Node.js项目。这将创建一个<code class="du kp kq kr ks b">package.json</code>文件，我们将在其中跟踪我们的依赖项和脚本。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="0ebf" class="jp jq hi ks b fi lb lc l ld le">$ mkdir hello<br/>$ cd hello<br/>$ npm init -y</span></pre><p id="d9af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们安装TypeScript和所需的Node.js类型，然后用TypeScript编译器注册我们的项目。这将创建一个带有默认编译器选项的<code class="du kp kq kr ks b">tsconfig.json</code>。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="b294" class="jp jq hi ks b fi lb lc l ld le">$ npm i typescript @types/node -D<br/>$ npx tsc --init</span></pre><p id="1c0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更新<code class="du kp kq kr ks b">tsconfig.json</code>来满足我们的需求:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="3ba1" class="jp jq hi ks b fi lb lc l ld le">{<br/>  "compilerOptions": {<br/>-   "target": "es5",<br/>+   "target": "ES2020",<br/>    ...<br/>+   "outDir": "./build",<br/>+   "importHelpers": false,<strong class="ks hj"><br/></strong>    ...<br/>  }<br/>}</span></pre><p id="df05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>我们选择了<code class="du kp kq kr ks b">ES2020</code>作为目标，因为我们假设使用的是Node.js版本14或更高版本。</p><p id="cfcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，让我们向CLI添加一个入口点，并验证TypeScript编译是否按预期工作。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="fb67" class="jp jq hi ks b fi lb lc l ld le">$ mkdir src<br/>$ touch src/cli.ts<br/>$ npx tsc<br/>$ ls build<br/>cli.js</span></pre><h2 id="b0e3" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">处理命令</h2><p id="472b" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">假设我们想要实现一个简单的<code class="du kp kq kr ks b">greet</code>命令，它将<code class="du kp kq kr ks b">name</code>作为位置参数，以及一个可选的<code class="du kp kq kr ks b">--upper</code>标志。生成的CLI将如下所示:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="d188" class="jp jq hi ks b fi lb lc l ld le">$ hello greet Alice<br/>Hello, Alice!<br/>$ hello greet Alice --upper<br/>HELLO, ALICE!</span></pre><p id="5662" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用<a class="ae jo" href="https://github.com/yargs/yargs" rel="noopener ugc nofollow" target="_blank"> yargs </a>来帮助我们解析参数和标志，并搭建CLI命令处理程序。它还附带了许多有用的功能，可以提供更好的用户体验，例如自动生成的帮助菜单等等。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="9c84" class="jp jq hi ks b fi lb lc l ld le">$ npm i yargs<br/>$ <!-- -->npm i @types/yargs -D # for TypeScript</span></pre><p id="1ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建<code class="du kp kq kr ks b">greet</code>命令模块。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="5c56" class="jp jq hi ks b fi lb lc l ld le">$ mkdir src/commands<br/>$ touch src/commands/greet.ts</span></pre><p id="cf46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">greet.ts</code>文件将如下所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8cbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们更新<code class="du kp kq kr ks b">cli.ts</code>入口点。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="07fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong><code class="du kp kq kr ks b">#!/usr/bin/env node</code><a class="ae jo" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank">she bang字符序列</a>将JavaScript文件“转换”成Node.js命令行脚本。</p><p id="1d3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们再次用TypeScript编译我们的源代码，并试用这个脚本。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="641b" class="jp jq hi ks b fi lb lc l ld le">$ npx tsc<br/>$ ./build/cli.js greet Alice<br/>Hello, Alice!%<br/>$ ./build/cli.js greet Alice --upper<br/>HELLO, ALICE!%</span></pre><p id="7439" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">👏万岁！我们的CLI按预期工作。</p><h2 id="74ca" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">构建单个可执行文件</h2><p id="3207" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">假设您想将您的CLI打包用于商业用途(没有源代码)。在这种情况下，您可能不希望通过npm进行分发，而是希望在某个地方提供下载。</p><p id="7e1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了将我们的<code class="du kp kq kr ks b">hello</code> CLI打包成一个可执行文件，我们将使用来自Vercel的<a class="ae jo" href="https://github.com/vercel/pkg" rel="noopener ugc nofollow" target="_blank"> pkg </a>模块。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="f0e2" class="jp jq hi ks b fi lb lc l ld le">$ npm i pkg -D</span></pre><p id="f469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要更新<code class="du kp kq kr ks b">package.json</code>来添加一个使用<code class="du kp kq kr ks b">pkg</code>模块为macOS构建的脚本，以及一个配置来告诉<code class="du kp kq kr ks b">pkg</code>包含<code class="du kp kq kr ks b">build</code>文件夹中的所有<code class="du kp kq kr ks b">.js</code>文件:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="49f2" class="jp jq hi ks b fi lb lc l ld le">{<br/>  ...<br/>+ "bin": {<br/>+   "hello": "./build/cli.js"<br/>+ },<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>+   "package": "pkg . --targets node14-macos-x64 --output hello"<br/>  },<br/>  ...<br/>+ "pkg": {<br/>+   "scripts": "build/**/*.js"<br/>+ }<strong class="ks hj"><br/></strong>}</span></pre><p id="eb93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>我们需要添加<code class="du kp kq kr ks b">bin</code>条目，以便正确封装带有<code class="du kp kq kr ks b">pkg</code>的模块。这也允许用户通过<code class="du kp kq kr ks b">npm install -g hello</code>安装模块，只要它发布在npm上，或者通过<code class="du kp kq kr ks b">npm link</code>本地安装。</p><p id="342e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试试这是否像预期的那样工作。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="6ef7" class="jp jq hi ks b fi lb lc l ld le">$ npm run package<br/>$ ./hello greet Bob --upper<br/>HELLO, BOB!%</span></pre><p id="49fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">厉害！现在，让我们通过自制程序使<code class="du kp kq kr ks b">hello</code>可用。</p><h2 id="d819" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">通过自制程序分发</h2><p id="f891" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">最简单的方法是用正确配置的公式托管一个存储库。存储库的名称必须遵循<code class="du kp kq kr ks b">homebrew-[name]</code>约定，在我们的例子中是<code class="du kp kq kr ks b">homebrew-hello</code>，这将使它可以通过<code class="du kp kq kr ks b">brew install sniptt-official/hello/hello</code>安装。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/96e12612e56b11994e8e7abf413f9f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoNf-0o6RiYzix_07hct9g.png"/></div></div></figure><p id="df4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要在某个地方存放我们的二进制文件。我们发现最简单的方法是在GitHub上创建一个发布版本，并将压缩的归档文件作为附件添加进来。</p><p id="c37c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要创建归档文件，请运行:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="4dd0" class="jp jq hi ks b fi lb lc l ld le">$ tar -cvzf hello-macos-x64.tar.gz hello</span></pre><p id="033b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要计算其签名:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="82ae" class="jp jq hi ks b fi lb lc l ld le">$ sha256sum hello-macos-x64.tar.gz</span></pre><p id="b8b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要注意签名，因为自制公式需要签名，在我们的例子中，签名是<code class="du kp kq kr ks b">debe8f770becb128c666e64a415be0f6c62db90de4dfad853150e116164a6138</code>。</p><p id="a334" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将创建一个版本并上传人工制品。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/cf5ce7d6c5a57df3e92a5b287885f0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Hm2mn3Kt0JuVfue_6RcUg.png"/></div></div></figure><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/1f243f6143ab7bea17f8c28783cc391e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVd0WR36B1ixWG_fa3rAYA.png"/></div></div></figure><p id="8280" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确认后，应该会看到这样的东西。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/86368421a57ae43456a56df169ae13f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AJ0KKL25miwefoLRqc_BA.png"/></div></div></figure><p id="4208" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是在我们的新回购中创建自制公式。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="6ce6" class="jp jq hi ks b fi lb lc l ld le">$ git clone git@github.com:sniptt-official/homebrew-hello.git<br/>$ cd homebrew-hello<br/>$ mkdir Formula<br/>$ touch Formula/hello.rb</span></pre><p id="f6d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kp kq kr ks b">hello.rb</code>中:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="3756" class="jp jq hi ks b fi lb lc l ld le">class Hello &lt; Formula<br/>  desc "A simple greeter"<br/>  homepage "https://github.com/sniptt-official/hello"<br/>  url "https://github.com/sniptt-official/homebrew-hello/releases/download/v1.0.0/hello-macos-x64.tar.gz"<br/>  sha256 "debe8f770becb128c666e64a415be0f6c62db90de4dfad853150e116164a6138"<br/>  version "1.0.0"</span><span id="c2fb" class="jp jq hi ks b fi ll lc l ld le">  def install<br/>    bin.install "hello"<br/>  end<br/>end</span></pre><p id="867a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>URL可以在发布的新闻稿的资产部分获得，签名必须与之前获得的签名相匹配。</p><p id="b977" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将推动我们的变化，然后它最终是测试时间！</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="cc91" class="jp jq hi ks b fi lb lc l ld le">$ git add Formula<br/>$ git commit -m "feat(formula): add formula for hello"<br/>$ git push origin main</span></pre><p id="db05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦公式被推送到GitHub，我们就可以通过Homebrew安装hello CLI:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="233c" class="jp jq hi ks b fi lb lc l ld le">$ brew install sniptt-official/hello/hello</span></pre><p id="f1c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="9bed" class="jp jq hi ks b fi lb lc l ld le">$ hello greet "Homebrew user"<br/>Hello, Homebrew user!%</span></pre><p id="144d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🎉耶，你成功了！恭喜你！</p><h2 id="c062" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">后续步骤和高级使用示例</h2><p id="8795" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">想了解更多？请访问我们在GitHub 上的<a class="ae jo" href="https://github.com/sniptt-official/snip-cli" rel="noopener ugc nofollow" target="_blank"> Snip CLI项目，了解更多信息:</a></p><ul class=""><li id="b502" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">支持多命令的高级CLI配置</li><li id="c4ff" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">Linux的打包</li><li id="bee2" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">通过GitHub操作实现工作流自动化</li></ul><p id="08ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有更多。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="b18a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">厌倦了使用密码管理器与您的团队共享API密钥、数据库密码、配置文件和其他秘密吗？</p><p id="2540" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">试试</strong> <a class="ae jo" href="https://www.sniptt.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Sniptt </strong> </a> <strong class="is hj">，这是一款面向开发者的新型秘密管理器，可以让你直接从命令行分享端到端的加密秘密！</strong></p></div></div>    
</body>
</html>
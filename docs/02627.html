<html>
<head>
<title>Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中提升</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hoisting-in-javascript-fc41eabc5913?source=collection_archive---------18-----------------------#2021-05-22">https://medium.com/geekculture/hoisting-in-javascript-fc41eabc5913?source=collection_archive---------18-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们谈谈JavaScript中的提升，它是如何工作的，以及我们如何从中受益。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bcd9ccee120889fc36f38822bf789325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9k9YEXd66CS6LavH"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@spinaldog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrey Kremkov</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5b2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noopener ugc nofollow" target="_blank"> MDN Web Docs给出了吊装的如下定义</a></p><blockquote class="ju jv jw"><p id="ce4c" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">例如，从概念上讲，提升的严格定义表明变量和函数声明被物理地移到了代码的顶部，但事实上并不是这样。相反，变量和函数声明在编译阶段被放入内存中，但停留在您在代码中键入它们的位置。”</p></blockquote><p id="ca17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论变量和函数声明在代码中的什么位置定义，它们都在运行时或代码执行前被放入内存。</p><p id="6547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">变量吊装</strong></p><p id="97ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，这个写得很好的定义表明我们需要处理变量和函数声明，让我们先看看变量。为了定义一个变量名，我们可以考虑两个基本的选项来编写我们的代码，第一个也是最常见的，我们声明一个变量，然后使用赋值操作符(=)来给这个变量赋值。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="40d5" class="kg kh hi kc b fi ki kj l kk kl">var someGreeting = "Hi Bob!";<br/>// declaration &amp; assignment or initialization</span><span id="a9dd" class="kg kh hi kc b fi km kj l kk kl">someGreeting; // = &gt; Hi Bob!<br/>// referencing to a variable</span></pre><p id="7d9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据具体情况，我们可以现在声明一个变量，以后再给这个变量赋值。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="8572" class="kg kh hi kc b fi ki kj l kk kl">var someGreeting;<br/>// declaration</span><span id="02d5" class="kg kh hi kc b fi km kj l kk kl">someGreeting = "Hi Bob!";<br/>// assignment</span><span id="47b2" class="kg kh hi kc b fi km kj l kk kl">someGreeting; // = &gt; Hi Bob!<br/>// referencing to a variable</span></pre><p id="9ea4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如上面演示的那样，在初始化变量后引用它是一个好的做法；在这两种情况下，<em class="jx"> someGreeting </em>变量返回一个赋值/字符串“嗨，鲍勃！”</p><p id="9f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在初始化之前定义一个变量会发生什么？让我们在代码示例中将变量名<em class="jx"> someGreeting </em>上移，放在初始化之前。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="b5e0" class="kg kh hi kc b fi ki kj l kk kl">console.log(someGreeting); // = &gt; undefined<br/>// referencing to a variable</span><span id="79d6" class="kg kh hi kc b fi km kj l kk kl">var someGreeting = "Hi Bob!";<br/>// declaration &amp; assignment or initialization</span></pre><p id="aee6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="037f" class="kg kh hi kc b fi ki kj l kk kl">console.log(someGreeting); // = &gt; undefined<br/>// referencing to a variable</span><span id="d478" class="kg kh hi kc b fi km kj l kk kl">var someGreeting;<br/>// declaration</span><span id="5641" class="kg kh hi kc b fi km kj l kk kl">someGreeting = "Hi Bob!"; // = &gt; "Hi Bob!"<br/>// assignment</span></pre><p id="f5b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如这些例子所示，在初始化之前引用变量会导致返回“未定义”。未定义的属性表示变量没有赋值，或者根本没有声明。请记住这句话，我们以后会用到它。</p><p id="f1ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们引用一个在代码中不存在的不同变量，会发生什么？让我们引入一个名为<em class="jx"> sayBye </em>的全新变量，它在我们的代码中从未使用过。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="43d1" class="kg kh hi kc b fi ki kj l kk kl">console.log(someGreeting); // = &gt; undefined<br/>// referencing to a variable</span><span id="23c7" class="kg kh hi kc b fi km kj l kk kl">var someGreeting = "Hi Bob!";<br/>// declaration &amp; assignment or initialization</span><span id="46a4" class="kg kh hi kc b fi km kj l kk kl">someGreeting; // = &gt; Hi Bob!<br/>// referencing to a variable</span><span id="7d23" class="kg kh hi kc b fi km kj l kk kl">sayBye; // =&gt; ReferenceError: sayBye is not defined</span></pre><p id="67af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="fd5c" class="kg kh hi kc b fi ki kj l kk kl">console.log(someGreeting); // = &gt; undefined<br/>// referencing to a variable</span><span id="960f" class="kg kh hi kc b fi km kj l kk kl">var someGreeting;<br/>// declaration</span><span id="d7a4" class="kg kh hi kc b fi km kj l kk kl">someGreeting = "Hi Bob!"; // = &gt; "Hi Bob!"<br/>// assignment</span><span id="ed3c" class="kg kh hi kc b fi km kj l kk kl">sayBye; // =&gt; ReferenceError: sayBye is not defined</span></pre><p id="09d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯嗯……很有趣，不是吗？JavaScript抛出<em class="jx"> ReferenceError: sayBye未定义</em>(reference error对象表示引用不存在的变量时出错)。</p><p id="9b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">众所周知，JavaScript引擎是从左到右、从上到下读取代码的，如果是这样，那么为什么下面的代码会导致“未定义”而不是抛出这个<em class="jx"> ReferenceError </em>？为什么我们会有如此不同的行为？有什么区别？</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="067d" class="kg kh hi kc b fi ki kj l kk kl">1 console.log(someGreeting); // = &gt; undefined<br/>2 // referencing to a variable<br/>3<br/>4 var someGreeting = "Hi Bob!";<br/>5 // declaration &amp; assignment or initialization</span></pre><p id="cee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这都叫吊装！</p><p id="9431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来了解一下这种吊装是如何进行的。我们已经声明了一个<em class="jx"> var someGreeting = "Hi Bob！</em>”；现在让我们在运行时一行一行地检查我们的代码。首先会发生什么？在运行第一行代码(第1行)之前，JS engine识别代码中的所有变量(在我们的例子中是第4行),并将它们的名称存储在内存中，每个名称都有一个缺省值undefined。JS机器找到变量<em class="jx"> someGreeting </em>(第4行)，在内存中创建它的名字，并给这个名字附加一个undefined值，意思是<em class="jx"> someGreeting = undefined </em>，这就是我们在执行第一行代码之前在内存中的内容。</p><p id="c50a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么在初始化之前定义的变量<em class="jx"> someGreeting </em>返回“undefined”，而<em class="jx"> sayBye </em>抛出这个<em class="jx"> ReferenceError消息</em>。这个<em class="jx"> sayBye </em>在我们的代码中不存在，所以在代码执行之前，JavaScript内存中不会存储任何东西。回到我们的陈述“一个未定义的属性表示一个变量没有被赋值，或者根本没有被声明”这也是正确的，因为我们赋值了一个值<em class="jx">“嗨Bob！”</em>到<em class="jx"> someGreeting </em>变量只在第4行。</p><p id="0bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">功能提升</strong></p><p id="27b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义函数的常用方法有哪些？函数声明和函数表达式。</p><p id="6336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数声明包含函数名、返回关键字、参数和代码块。当一个函数被声明后，它可以在任何时候被调用。</p><p id="17fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数表达式与函数声明非常相似，语法几乎相同，它有一个return关键字、参数和一段代码，唯一的区别是它没有函数名。因为它没有这个名字，所以它可以被称为匿名函数，它的结果可以存储在一个变量名中，这样我们就可以调用这个函数。</p><p id="4147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对我们两个函数的正确和常见的调用，我们已经定义了函数声明或函数表达式，只有这样，我们才调用这些函数。没有区别，任何时候我们想要调用命名函数，我们使用下面演示的语法。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="b405" class="kg kh hi kc b fi ki kj l kk kl">// function declaration<br/>function funDeclaration (a, b) {<br/>return a + b;<br/>};</span><span id="f10b" class="kg kh hi kc b fi km kj l kk kl">// function expression<br/>var funExpression = function (a, b) {<br/>return a + b;<br/>};</span><span id="6f1e" class="kg kh hi kc b fi km kj l kk kl">funDeclaration (5, 10); // =&gt; 15<br/>// invocation</span><span id="62b8" class="kg kh hi kc b fi km kj l kk kl">funExpression (15, 20); // =&gt; 35<br/>// invocation</span></pre><p id="fcff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们像对待变量一样，在创建变量之前调用这些函数，会发生什么？让我们将函数声明的调用移到函数声明之上，并运行下面的代码。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="62d9" class="kg kh hi kc b fi ki kj l kk kl">1 funDeclaration (5, 10); // =&gt; 15<br/>2 // invocation<br/>3<br/>4 // function declaration<br/>5 function funDeclaration (a, b) {<br/>6   return a + b;<br/>7 };</span></pre><p id="4203" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码的结果是“15”，因为JavaScript中的函数声明被提升到封闭函数或全局范围的顶部。为什么会这样，背后的逻辑是什么？让我们在运行时一行一行地检查代码。如前所述，在运行第一行代码(第1行)之前，JavaScript引擎会识别代码中的所有变量，并将它们的名称存储在内存中，每个名称的默认值为undefined。其次，在执行第一行代码之前，JavaScript引擎识别代码中的所有函数声明，并将它们移入内存。函数体出现并被初始化以供立即使用。也就是说，我们不需要等到JavaScript引擎到达第5行来初始化函数，数据已经可用，函数也可以动态初始化，所以我们不需要按照先声明函数再调用函数的方式来构建代码，因为提升可以反过来进行。</p><p id="5f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数表达式呢？在下面的示例中，函数表达式的调用被上移至函数表达式之上。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="5cd9" class="kg kh hi kc b fi ki kj l kk kl">funExpression (15, 20); //TypeError: funExpression is not a function<br/>// invocation<br/>// function expression<br/>var funExpression = function (a, b) {<br/>return a + b;<br/>};</span></pre><p id="6f8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码导致<em class="jx"> TypeError: funExpression不是函数</em>，因为JavaScript中的函数表达式不像函数声明那样被提升。上述函数声明的逻辑不适用于函数表达式，因此在创建函数表达式之前不能使用它们。变量名呢？变量名不是像我们之前探索的那样被吊起来了吗？让我们运行下面的代码。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="deca" class="kg kh hi kc b fi ki kj l kk kl">console.log(funExpression); // =&gt;  undefined<br/>// function expression<br/>var funExpression = function (a, b) {<br/>return a + b;<br/>};</span></pre><p id="005b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使变量名被提升了，定义(函数体)却没有，所以这段代码返回“undefined”。</p><p id="2d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">箭头功能</strong></p><p id="4708" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们了解了函数声明和函数表达式，以及它们之间的区别，将这些知识应用于JavaScript中的其他类型的函数就变得相对容易了，例如，箭头函数。箭头函数只是传统函数表达式的一种简短而紧凑的替代形式。提醒一下，表达式是解析为值的任何有效代码，也就是说，我们可以说箭头函数实际上是一个箭头函数表达式，它的操作类似于函数表达式，所以就像函数表达式一样，箭头函数表达式是不提升的。</p><p id="1dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个箭头函数的例子。当使用箭头函数时，我们首先必须在调用函数之前定义一个函数。这是声明和调用箭头函数表达式的正确方法。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="3102" class="kg kh hi kc b fi ki kj l kk kl">// arrow function expression<br/>var arrowFuncExpression = () =&gt; {<br/>console.log("This is an arrow function expression");<br/>};</span><span id="24b9" class="kg kh hi kc b fi km kj l kk kl">arrowFuncExpression(); // =&gt; This is an arrow function expression<br/>// invocation</span></pre><p id="9eef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在代码中向上调用这个箭头函数表达式，并运行代码。</p><pre class="je jf jg jh fd kb kc kd ke aw kf bi"><span id="5125" class="kg kh hi kc b fi ki kj l kk kl">// invocation<br/>arrowFuncExpression(); // =&gt; TypeError: arrowFuncExpression is not a function</span><span id="19a9" class="kg kh hi kc b fi km kj l kk kl">// arrow function expression<br/>var arrowFuncExpression = () =&gt; {<br/>console.log("This is an arrow function expression");<br/>};</span></pre><p id="c859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码导致<em class="jx">type error:arrow func expression不是一个函数</em>，和我们之前观察到的函数表达式一样，箭头函数没有被提升。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kn"><img src="../Images/1e28607e1f51318c4d92d3150e3ac306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BODQWyZsrHikbaDO"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ad32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结:</strong></p><ul class=""><li id="acf3" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">变量名被提升到作用域的顶部，并返回值undefined。</li><li id="f849" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">函数表达式的变量名被提升到作用域的顶部，并返回值undefined。</li><li id="ea67" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">函数声明被提升到作用域的顶部，与它们的主体一起，您可以在声明它们之前调用函数声明。</li><li id="eb53" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">函数表达式不被提升，即使变量名被提升，定义(函数表达式体)不被提升，因此函数表达式应该在它们的声明/定义之后被调用。</li><li id="5639" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">例如，像箭头函数和/或箭头函数表达式这样的函数表达式的导数不被提升。</li></ul><p id="5205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这些信息有用，请随时关注我。希望你喜欢这篇关于JavaScript提升的简短指导，请保持关注！</p></div></div>    
</body>
</html>
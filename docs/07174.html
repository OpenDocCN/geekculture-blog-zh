<html>
<head>
<title>A Gentle Introduction to CI/CD Pipeline with Github Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Github动作对CI/CD管道的简单介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-gentle-introduction-to-ci-cd-pipeline-with-github-actions-86115c4a6310?source=collection_archive---------6-----------------------#2021-09-10">https://medium.com/geekculture/a-gentle-introduction-to-ci-cd-pipeline-with-github-actions-86115c4a6310?source=collection_archive---------6-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0ad3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过摆脱枯燥和耗时的代码部署来提高您的生产力</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f19fa1b90db4daecf4a79cc25712c95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ezKxjlSBzx-9IQHS.jpg"/></div></div></figure><p id="964c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你好。希望你一切都好。在最近的<a class="ae kf" href="https://insights.stackoverflow.com/survey/2021" rel="noopener ugc nofollow" target="_blank"> 2021栈溢出开发者调查中</a>证实Docker是除Git之外第二受欢迎的工具，并成为开发者的基本工具。按照传统的方式，开发人员必须编写代码，然后在本地环境中基于Docker文件构建Docker映像，然后再推送到Docker Hub。大多数人同意我的观点，认为这花费了大量的时间和精力，因为每当源代码改变时，整个过程都要重复(也称为“集成地狱”)。但是别担心，CI/CD来拯救我们的生命了。</p><h1 id="78a0" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated"><strong class="ak">那么，什么是CI/CD呢？</strong></h1><p id="7357" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">CI和CD是现代开发实践和DevOps中经常使用的两个缩写词。CI代表持续集成，这是一个基本的DevOps最佳实践，开发人员经常将代码更改合并到一个中央存储库中，在那里运行自动化构建和测试。但是CD既可以指持续交付，也可以指持续部署。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/5ab8f1fe4e7611345a0913004d7062e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hOpxDBzwqzAsM6lH"/></div></div></figure><p id="dc37" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们将这两者结合在一起时，我们将拥有对付“集成地狱”的最强大的武器，这就是CI/CD管道。如今，有许多工具可以帮助我们在您的软件开发生命周期内实现任务自动化，如TravisCI、CircleCI、Jenkins、Buddy、final builder……如果您熟悉Github，它们也提供Github操作，您无需为您的CI/CD管道使用第三方工具。</p><blockquote class="le lf lg"><p id="e5ac" class="jj jk lh jl b jm jn ij jo jp jq im jr li jt ju jv lj jx jy jz lk kb kc kd ke hb bi translated">GitHub动作帮助您在存储代码和协作处理拉取请求和问题的同一位置自动化您的软件开发工作流程。您可以编写称为操作的单个任务，并将它们组合起来创建自定义工作流。工作流是定制的自动化过程，您可以在存储库中设置它，以便在GitHub上构建、测试、打包、发布或部署任何代码项目。</p></blockquote><p id="c723" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将向您展示如何设置一个完整的Github Actions CI/CD管道来构建映像并推送到Docker Hub，最后在<code class="du ll lm ln lo b">ssh</code>之前部署到服务器。但在此之前，我们需要了解Github Actions的组件是什么，以及它们是如何工作的。</p><h1 id="c1eb" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">Github操作的组件</h1><p id="333a" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">我们将详细介绍Github Actions工作流中的组件。Github动作使用<code class="du ll lm ln lo b">YAML</code>文件来定义这些组件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl lp"><img src="../Images/a7f09f516bbf0b618fdfe82b677e8673.png" data-original-src="https://miro.medium.com/v2/format:webp/0*1SQVROqAotkdVIve.png"/></div></figure><h2 id="4a29" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated"><strong class="ak">工作流程</strong></h2><p id="abd5" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">工作流是一个定制的自动化过程，我们可以将它包含在我们的存储库中，以构建、测试和部署我们的源代码。我们可以有一个以上的工作流，它必须存储在源代码的根目录下的<code class="du ll lm ln lo b">.github/workflows</code>文件夹中，并且可以被调度或由事件触发。</p><h2 id="51d7" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">事件</h2><p id="4d84" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">事件是触发工作流的特定活动。例如，当有人将提交推送到存储库时，或者当一个问题或拉请求被创建时，活动可以源自GitHub。当外部事件发生时，您还可以使用<a class="ae kf" href="https://docs.github.com/en/rest/reference/repos#create-a-repository-dispatch-event" rel="noopener ugc nofollow" target="_blank">存储库调度webhook </a>来触发工作流。有关可用于触发工作流的事件的完整列表，请参见<a class="ae kf" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">触发工作流的事件</a>。</p><h2 id="d262" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">乔布斯</h2><p id="f4d3" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">作业是在同一个流道上执行的一组步骤。默认情况下，包含多个作业的工作流将并行运行这些作业。您还可以将工作流配置为按顺序运行作业。例如，一个工作流可以有两个生成和测试代码的连续作业，其中测试作业依赖于生成作业的状态。如果构建作业失败，测试作业将不会运行。</p><h2 id="ebac" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">步伐</h2><p id="7297" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">步骤是可以在作业中运行命令的单个任务。一个步骤可以是一个<em class="lh">动作</em>或者一个shell命令。作业中的每一步都在同一个运行器上执行，允许该作业中的操作彼此共享数据。</p><h2 id="e901" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">行动</h2><p id="4014" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated"><em class="lh">动作</em>是独立的命令，组合成<em class="lh">步骤</em>以创建<em class="lh">作业</em>。动作是工作流最小的可移植构件。您可以创建自己的动作，或者使用由<a class="ae kf" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> GitHub社区</a>创建的动作。要在工作流中使用操作，您必须将其作为一个步骤包括在内。</p><h2 id="5338" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">滑行装置</h2><p id="b67b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">runner是安装了GitHub Actions runner应用程序的服务器。你可以用GitHub托管的runner，也可以自己托管。运行程序监听可用的作业，一次运行一个作业，并向GitHub报告进度、日志和结果。GitHub托管的运行程序基于Ubuntu Linux、Windows和macOS，工作流中的每个作业都在一个全新的虚拟环境中运行。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/8f0c2895b653dc29b1ae02b29d838053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zr7P-AjGncFtKu1tfVO8fg.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx">Create a self-hosted runner in Github Actions.</figcaption></figure><h1 id="d993" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">我们开始吧</h1><h2 id="59b4" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated"><strong class="ak">写Dockerfile </strong></h2><p id="ea25" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">我们使用docker构建由Golang编写的简单hello-world RESTful服务。Dockerfile是一个逐步建立图像的指令。我们使用多阶段构建，以保持图像大小尽可能小。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="362b" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">将环境添加到报告机密</h2><p id="723f" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">加密机密允许您将敏感信息存储在您的组织、存储库或存储库环境中。要使机密可用于操作，您必须将机密设置为工作流文件中的输入或环境变量。在这个项目中，我们需要在下面添加一些秘密</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/d84ea87e0f81a86481f1265a181a90a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBwtstaPuCgzOsTVzTJOHg.png"/></div></div></figure><ul class=""><li id="c33f" class="mm mn hi jl b jm jn jp jq js mo jw mp ka mq ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">DOCKER_HUB_USERNAME</code> - Docker Hub用户名</li><li id="6c4a" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">DOCKER_HUB_ACCESS_TOKEN</code> -您可以创建一个访问令牌或直接使用Docker Hub密码登录以推送图像。</li><li id="94a2" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">HOST</code> - ssh主机</li><li id="5107" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">PORT</code> - ssh端口，默认为<code class="du ll lm ln lo b">22</code></li><li id="cdb6" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">USERNAME</code> - ssh用户名</li><li id="a0ec" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">KEY</code>-ssh私钥的内容。ex ~/的原始含量。ssh/id_rsa</li><li id="475d" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du ll lm ln lo b">SLACK_WEBHOOK_URL</code> - Slack webhook url，用于在运行后发送关于CI/CD管道状态的通知。</li></ul><h2 id="b727" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">创建工作流并配置要触发的事件</h2><p id="794c" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">首先，创建一个yaml文件，存储在源代码根目录下的<code class="du ll lm ln lo b">.github/workflows</code>文件夹中。该示例工作流将在分支“主”、“暂存”和“开发”上的推送和拉取请求时被触发。此外，工作流也可以根据时间表触发。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="9ea4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将我们的工作流分成两个主要的工作:“构建”和“部署”。类似于CI渠道的“构建”和类似于CD渠道的“部署”。所有作业都将在您选择的特定运行程序上运行。所以在这个例子中，我将使用<code class="du ll lm ln lo b">ubuntu-latest</code> runner。</p><h2 id="93ae" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">“构建”工作</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="8eab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了简化构建和推送Docker图像，我们只使用现有的动作<code class="du ll lm ln lo b">docker/build-push-action@v2</code>。它是基于BuildKit构建的，build kit是一个新的Docker图像生成器。它带来了许多改进和更好的性能。令我印象深刻的最有趣的事情之一是<a class="ae kf" href="https://github.com/docker/build-push-action/blob/master/docs/advanced/cache.md" rel="noopener ugc nofollow" target="_blank"> <em class="lh">使用远程存储库作为缓存</em> </a>。这对于您的CI构建特别有用，因为缓存文件夹可能不可用，并且您将对每个管道进行冷构建。</p><p id="4478" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用BuildKit，除了本地构建缓存之外，构建器还可以使用指向注册表中图像的<code class="du ll lm ln lo b">--cache-from</code>标志重用从以前的构建中生成的缓存。这也支持很多类型缓存导出器，在这里我只是为了我们的简单需要而使用了<code class="du ll lm ln lo b">type=inline</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/d02bcbda45bfd1e042b35c5ec84d2835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzQxYbsyKY5P7Vwtjy9XcA.png"/></div></div></figure><h2 id="e0d9" class="lq kh hi bd ki lr ls lt km lu lv lw kq js lx ly ks jw lz ma ku ka mb mc kw md bi translated">“部署”作业</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="5673" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了将我们的代码部署到服务器，我们需要执行远程ssh并运行docker命令。动作<code class="du ll lm ln lo b"><a class="ae kf" href="https://github.com/appleboy/ssh-action" rel="noopener ugc nofollow" target="_blank">appleboy/ssh-action</a></code>可以帮助我们完成这项工作，你不需要担心安全威胁，因为它还提供了许多参数来保护你的连接和防止中间人攻击。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/7bf82041a9291ab4e258dbeb490e3417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kofgpASgwpYCll9q2MYzHw.png"/></div></div></figure><p id="c1fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后但同样重要的是，在运行之后，您需要知道CI/CD管道是否成功。我们将设置一个简单的Slack Webhook，使用这个动作<code class="du ll lm ln lo b"><a class="ae kf" href="https://github.com/8398a7/action-slack" rel="noopener ugc nofollow" target="_blank">8398a7/action-slack@v3</a></code>来提醒构建的状态</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/6cfa6bfb101c8f6ebb8f866f21c04f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-w1RJzq_oJSY1XTRENpxcQ.png"/></div></div></figure><p id="8b2d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">瞧啊。一切都像魔咒一样管用。我们刚刚完成了Github Actions CI/CD管道的设置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/42eb84ad062544eb619765ec9002d6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsa5ERpn3C_ez9uXycntvA.png"/></div></div></figure></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="dd63" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下是Github操作工作流程的完整配置:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h1 id="aeb5" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">太好了！不是吗？</h1><p id="6434" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">只需几个简单的设置，我们就有了基于不同事件触发作业的自动化流程。这种解决方案可以帮助您摆脱枯燥、耗时的代码部署，并且更专注于业务和代码逻辑。这个示例项目的源代码可以在下面找到:</p><div class="nl nm ez fb nn no"><a href="https://github.com/toannhu96/go-github-actions.git" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">GitHub-toanhu96/go-GitHub-actions:简单的go rest服务，带有GitHub动作，可将图像推送到…</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">简单的go rest服务，github动作将图像推送到docker hub并部署到服务器- GitHub …</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jh no"/></div></div></a></div><h1 id="1411" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated"><strong class="ak">资源</strong></h1><p id="1f37" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">docker:<a class="ae kf" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/overview/</a>T5】Gihub Actions:<a class="ae kf" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank">https://docs.github.com/en/actions</a></p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="44d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感谢阅读这篇文章，我希望它是有用的，随时讨论更多。</p></div></div>    
</body>
</html>
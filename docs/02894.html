<html>
<head>
<title>Android: View Binding v/s Data Binding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:视图绑定v/s数据绑定</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/android-view-binding-v-s-data-binding-5862a27524e9?source=collection_archive---------20-----------------------#2021-05-27">https://medium.com/geekculture/android-view-binding-v-s-data-binding-5862a27524e9?source=collection_archive---------20-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b26e127c771268fe86c24e9ebb9a42ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nXXuJlGZeO5BxgcO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@bamin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pierre Bamin</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f806" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇文章中，我谈到了在findViewById()上使用视图绑定的好处。我强烈建议你在阅读这篇文章之前先阅读一下<a class="ae iu" rel="noopener" href="/geekculture/android-viewbinding-over-findviewbyid-389401b41706"><strong class="ix hj"/></a>。</p><p id="fb8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将讨论数据绑定，视图绑定和数据绑定之间的主要区别，以及何时应该在项目中使用它们。</p><p id="8495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您已经学习了视图绑定，我将直接跳到数据绑定，它的实现，然后讨论视图绑定和数据绑定之间的区别。</p><p id="638b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据绑定</strong></p><blockquote class="jt"><p id="493a" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">数据绑定库是一个支持库，允许您使用声明性格式而非编程方式将布局中的UI组件绑定到应用程序中的数据源。</p></blockquote><p id="8f83" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">若要启用数据绑定，请在模块级build.gradle文件中添加以下代码段:</p><p id="280c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">启用数据绑定</strong>:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e35c" class="kr ks hi kn b fi kt ku l kv kw">android <strong class="kn hj">{ <br/>    ...</strong></span><span id="b18e" class="kr ks hi kn b fi kx ku l kv kw">    buildFeatures <strong class="kn hj">{<br/>        </strong>dataBinding true<br/>    <strong class="kn hj">}<br/>}</strong></span></pre><p id="8bab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">生成绑定类</strong></p><p id="967f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与视图绑定不同，在视图绑定中，一旦启用了视图绑定，就会为项目中的所有布局文件自动生成绑定类，而使用数据绑定，您必须显式地将每个布局转换为数据绑定布局才能生成数据绑定类。</p><p id="e946" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要将布局转换为数据绑定布局，请转到父布局并按下<em class="ky"> Option + return </em>按钮，同时将打开一个菜单。从出现的菜单中选择<em class="ky">转换为数据绑定布局</em>和<em class="ky"> </em>您的视图将被转换为数据绑定布局。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5303" class="kr ks hi kn b fi kt ku l kv kw">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;data&gt;<br/>        &lt;variable<br/>            name="mainViewModel"<br/>            type="com.anubhav.data.ViewModel" /&gt;<br/>    &lt;/data&gt;<br/>    &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;<br/>&lt;/layout&gt;</span></pre><p id="6817" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以在表达式中使用的绑定变量是在一个数据元素中定义的，该数据元素是UI布局的根元素的同级。这两个元素都包装在布局标记中。之后，您可以使用已定义的变量，通过声明性格式为UI元素设置值。</p><p id="d460" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">绑定数据</strong></p><p id="0e41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为每个布局文件生成一个绑定类。默认情况下，类的名称基于布局文件的名称，将其转换为Pascal大小写并添加后缀<em class="ky">绑定</em>。比方说，上面的布局文件的名称是activity_main.xml，因此相应的生成类是ActivityMainBinding。该类保存从布局属性到布局视图的所有绑定，并知道如何为绑定表达式赋值。创建绑定的推荐方法是在展开布局的同时进行，如下例所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b231" class="kr ks hi kn b fi kt ku l kv kw">class MainActivity : AppCompatActivity() {</span><span id="411b" class="kr ks hi kn b fi kx ku l kv kw">    private val mainViewModel by <em class="ky">viewModels</em>&lt;MainViewModel&gt;()</span><span id="3b12" class="kr ks hi kn b fi kx ku l kv kw">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.<em class="ky">activity_main</em>)<br/><br/>        binding.mainViewModel = mainViewModel<br/>    }<br/><br/>}</span></pre><p id="b76c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在在布局文件中，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="09b0" class="kr ks hi kn b fi kt ku l kv kw">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;data&gt;<br/>        &lt;variable<br/>            name="mainViewModel"<br/>            type="com.anubhav.data.ViewModel" /&gt;<br/>    &lt;/data&gt;<br/>    &lt;ConstraintLayout... &gt; </span><span id="a50e" class="kr ks hi kn b fi kx ku l kv kw">        <!-- -->&lt;TextView<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            <strong class="kn hj">android:text="@{mainViewModel.name}"</strong>/&gt;</span><span id="248d" class="kr ks hi kn b fi kx ku l kv kw">    &lt;/ConstraintLayout&gt;<br/>&lt;/layout&gt;</span></pre><p id="1636" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果在Fragment、ListView或RecyclerView适配器中使用数据绑定项，则应使用BindingUtil类或DataBindingUtil类的inflate方法，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d5a8" class="kr ks hi kn b fi kt ku l kv kw">val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)</span><span id="22ef" class="kr ks hi kn b fi kx ku l kv kw">// or</span><span id="86f7" class="kr ks hi kn b fi kx ku l kv kw">val listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)</span></pre><p id="6db1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在可能存在这样的情况，您不能使用声明格式直接为视图设置属性，例如，您可能想通过url将图像加载到ImageView中，或者根据特定结果设置视图的颜色。数据绑定为我们提供了绑定适配器来适应这样的场景。</p><p id="39f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">绑定适配器</strong></p><p id="d732" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">绑定适配器负责进行适当的框架调用来设置值。每当绑定值改变时，生成的绑定类必须用绑定表达式调用视图上的setter方法。您可以允许数据绑定库自动确定方法、显式声明方法或提供自定义逻辑来选择方法。通常的绑定适配器方法只是一个静态方法，为布局文件中的特定自定义属性执行数据转换和注入。一个常见的绑定适配器类看起来像这样，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="062a" class="kr ks hi kn b fi kt ku l kv kw">class DataRowBinding {<br/><br/>    companion object {<br/><br/>        @JvmStatic<br/>        @BindingAdapter("loadImageFromUrl")<br/>        fun <strong class="kn hj">loadImageFromUrl</strong>(view: ImageView, imageUrl: String) {<br/>            view.<em class="ky">load</em>(imageUrl) <strong class="kn hj">{<br/>                </strong>placeholder(R.drawable.<em class="ky">ic_error_image</em>)<br/>                crossfade(600)<br/>                error(R.drawable.<em class="ky">ic_error_image</em>)<br/>            <strong class="kn hj">}<br/>        </strong>}<br/>    }</span></pre><p id="e42c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自定义属性的名称定义如下:</p><blockquote class="kz la lb"><p id="d56d" class="iv iw ky ix b iy iz ja jb jc jd je jf lc jh ji jj ld jl jm jn le jp jq jr js hb bi translated"><strong class="ix hj">@ binding adapter(" loadImageFromUrl ")</strong></p><p id="7c41" class="iv iw ky ix b iy iz ja jb jc jd je jf lc jh ji jj ld jl jm jn le jp jq jr js hb bi translated"><em class="hi">现在您可以在</em><strong class="ix hj"/><em class="hi">@ binding adapter(" loadImageFromUrl ")</em><em class="hi">内使用这个属性</em>，<strong class="ix hj">loadImageFromUrl<em class="hi"/></strong><em class="hi">来设置布局元素内的值。我喜欢将方法的名称与我定义的自定义属性的名称保持一致。</em></p><p id="e418" class="iv iw ky ix b iy iz ja jb jc jd je jf lc jh ji jj ld jl jm jn le jp jq jr js hb bi translated"><strong class="ix hj"> @JvmStatic </strong></p><p id="35d3" class="iv iw ky ix b iy iz ja jb jc jd je jf lc jh ji jj ld jl jm jn le jp jq jr js hb bi translated"><em class="hi">指定如果它是一个函数，那么需要从这个元素生成一个额外的静态方法。如果这个元素是一个属性，应该生成额外的静态getter/setter方法。</em></p></blockquote><p id="489f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您可以使用绑定适配器中定义的自定义属性，</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cc63" class="kr ks hi kn b fi kt ku l kv kw">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;data&gt;<br/>        &lt;variable<br/>            name="mainViewModel"<br/>            type="com.anubhav.data.ViewModel" /&gt;<br/>    &lt;/data&gt;<br/>    &lt;ConstraintLayout... &gt;</span><span id="d3bc" class="kr ks hi kn b fi kx ku l kv kw">&lt;ImageView<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            <strong class="kn hj">loadImageFromUrl="@{mainViewModel.imageUrl}"</strong>/&gt;</span><span id="a16e" class="kr ks hi kn b fi kx ku l kv kw">&lt;/ConstraintLayout&gt;<br/>&lt;/layout&gt;</span></pre><p id="bbe1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在绑定类中使用一个<strong class="ix hj"> LiveData </strong>对象，您需要指定一个生命周期所有者来定义LiveData对象的范围。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ed0d" class="kr ks hi kn b fi kt ku l kv kw">val <em class="ky">binding</em>: ActivityMainBinding =   DataBindingUtil.setContentView(this, R.layout.main)</span><span id="0476" class="kr ks hi kn b fi kx ku l kv kw">// Specify the current activity as the lifecycle owner.</span><span id="19f6" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">binding.setLifecycleOwner(this)</strong></span></pre><p id="da59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以走了。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="994c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"/><strong class="ix hj">视图绑定</strong> <strong class="ix hj">和</strong> <strong class="ix hj">数据绑定</strong>的区别 <strong class="ix hj"/></p><ul class=""><li id="ce3d" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">视图绑定库比数据绑定库<strong class="ix hj">快</strong>，因为它没有利用底层的注释处理器，而且就编译时速度而言，视图绑定更加<strong class="ix hj">高效</strong>。</li><li id="79f3" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">视图绑定的唯一功能是绑定代码中的视图，而数据绑定提供了更多选项，如<strong class="ix hj">绑定表达式</strong>，它允许我们编写表达式，将变量连接到布局中的视图。</li><li id="6d90" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">数据绑定库与<strong class="ix hj">可观察数据</strong>对象一起工作，你不必担心当底层数据改变时刷新用户界面。</li><li id="94a6" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">数据绑定库为我们提供了<strong class="ix hj">绑定适配器</strong>。</li><li id="dabd" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">数据绑定库为我们提供了<strong class="ix hj">双向数据绑定，</strong>这是一种将对象绑定到xml布局的技术，这样对象和布局就可以相互发送数据。</li></ul><blockquote class="jt"><p id="1891" class="ju jv hi bd jw jx ma mb mc md me js dx translated">简而言之，没有什么是视图绑定能做的，也没有什么是数据绑定做不到的，(尽管代价是更长的构建时间)，而且有很多是视图绑定做不到的。</p></blockquote><p id="0d65" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">事实上，您可以在同一个项目中使用这两个库，高级用例使用数据绑定，普通用例使用视图绑定。</p><p id="0670" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是所有的人，希望你今天学到了一些东西！</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to Publish a JS and CSS Library to NPM Using Rollup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Rollup将JS和CSS库发布到NPM</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-publish-a-js-and-css-library-to-npm-using-rollup-5406dbee51fa?source=collection_archive---------1-----------------------#2021-04-03">https://medium.com/geekculture/how-to-publish-a-js-and-css-library-to-npm-using-rollup-5406dbee51fa?source=collection_archive---------1-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e9ead2fa8e6ce11ea3a0dd856cc4e246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f-esfxHEURcTs5iW.png"/></div></div></figure><p id="ebcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本指南中，我们将讨论如何创建javascript库并将其发布到npm。在前一篇<a class="ae jo" href="https://suryasankar.medium.com/a-simple-nested-tree-menu-with-vanilla-js-and-css-d30159f14096" rel="noopener">文章</a>中，我们已经构建了一个小脚本来创建一个嵌套的树形菜单。我们将在这里将其转换为npm包。</p><h1 id="6a85" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤1:初始化目录和repo。</h1><p id="cb2b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们为库创建一个文件夹，并在那里添加一个README.md文件。这是执行git init并创建一个远程github repo来跟踪它的好时机。(如果你是这方面的新手，你可以查看github howto <a class="ae jo" href="https://docs.github.com/en/github/importing-your-projects-to-github/adding-an-existing-project-to-github-using-the-command-line" rel="noopener ugc nofollow" target="_blank">这里</a></p><h1 id="b15c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤2:在src文件夹中添加脚本和样式表</h1><p id="c5b1" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本指南中，我们打算构建这个包，然后在一个示例项目中使用它。我们将创建两个独立的文件夹。一个用于包，一个用于示例。</p><p id="315d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在包目录中，我们将为源文件和构建文件创建单独的文件夹。在现代javascript工作流中，很少直接分发手工编码的源文件。源文件通过捆绑器传递，捆绑器执行各种转换和优化，并提供可以在浏览器或其他环境中使用的输出文件。因此，我们将继续创建两个名为<code class="du ks kt ku kv b">src</code>的文件夹，一个用于源文件，另一个用于输出文件。这个<code class="du ks kt ku kv b">dist</code>文件夹不需要我们去碰。它将由bundler填充。</p><p id="0f53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在src文件夹中，我们创建两个子文件夹— <code class="du ks kt ku kv b">js</code>和<code class="du ks kt ku kv b">styles</code>，分别存放javascript文件和样式表。</p><p id="2479" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件夹结构现在应该是这样的</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="67ec" class="le jq hi kv b fi lf lg l lh li">├── README.md<br/>├── examples<br/>│   ├── dist<br/>│   ├── src<br/>└── package<br/>    ├── dist<br/>    └── src<br/>        ├── js<br/>        └── styles</span></pre><p id="9299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将把我们的<a class="ae jo" href="https://techonometrics.com/posts/a-simple-nested-tree-menu-with-vanilla-js-and-css" rel="noopener ugc nofollow" target="_blank">嵌套树形菜单示例</a>中的样式标签的内容复制到package/src/styles/main.scss。我们正在使用scss扩展，以便我们将来可以使用sass特定的特性。但是现在，我们的样式表实际上只是纯css而已。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，我们也将样式标记的内容复制到package/src/js/index.js中。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ecfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们对从脚本标签复制的内容做了两处修改。</p><ol class=""><li id="9cfb" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">我们在顶部导入main.scss。这将告诉我们的bundler如何定位样式表，以便它们可以被缩小。</li><li id="05b7" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">我们在底部添加了一个<code class="du ks kt ku kv b">export default listree</code>语句，让我们将函数导出为ES模块。</li></ol><h1 id="9f50" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤3:初始化npm包</h1><p id="ab5b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在让我们从包文件夹中调用npm init。这将创建一个package.json，我们将对其进行编辑以修改<code class="du ks kt ku kv b">main</code>键并添加另外两个键- <code class="du ks kt ku kv b">module</code>和<code class="du ks kt ku kv b">browser</code>。我们还将设置files属性，把要添加到包中的dist文件夹列入白名单。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="45bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ks kt ku kv b">main</code>键代表包的入口点。如果我们使用NodeJS构建一个在服务器端使用的库，我们会将其指向CommonJS输出格式。但是我们在这里构建的是一个纯粹的前端库，它在浏览器上下文之外没有任何用处。所以我们将它设置为指向<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank"> ES模块</a>格式输出——这将使它可以通过import语句访问。因此该值被设置为<code class="du ks kt ku kv b">dist/listree.esm.min.js</code>。该文件尚不存在，我们将在后续步骤中使用bundler生成它。</p><p id="8c83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ks kt ku kv b">module</code>入口点专门用于指向ES模块输出。这在main被设置为指向CommonJS输出的情况下很有用。在我们的例子中，我们已经将main指向了an。esm文件。但是无论如何我们将设置模块属性也指向<code class="du ks kt ku kv b">dist/listree.esm.min.js</code>。</p><p id="3cfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ks kt ku kv b">browser</code>条目应该指向可以在浏览器脚本标签中直接加载的脚本文件。我们将把它设置为<code class="du ks kt ku kv b">dist/listree.umd.min.js</code>，其中umd代表通用模块定义。</p><p id="47d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">入口点文件——ESM和umd将使用如下捆绑器生成</p><h1 id="1282" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤4:安装汇总</h1><p id="9bda" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将使用rollup作为bundler来生成我们的包分发文件。有各种各样的捆绑系统可供选择——web pack是目前最流行的。但是rollup更适合生成可再发行的库。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="c083" class="le jq hi kv b fi lf lg l lh li">npm install --save-dev rollup rollup-plugin-scss rollup-plugin-terser</span></pre><p id="7aad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了rollup，我们还在这里安装了另外两个插件——一个用于将scss转换为css，另一个是terser插件，用于最小化生成的文件</p><h1 id="8b3f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤5:创建汇总配置js文件</h1><p id="48ef" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们使用rollup.config.js文件来指示rollup bundler</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d386" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的配置中，我们将输入指定为我们在src/js中创建的index.js。我们不必为css指定单独的输入，因为我们已经在index.js本身中导入了样式。</p><p id="7f0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还配置了两个不同的输出，每个输出对应于package.json中指定的一个入口点。</p><p id="4f0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要缩小生成的输出文件以便分发，这是由<code class="du ks kt ku kv b">terser</code>插件完成的。最后，我们使用scss插件生成一个缩小的输出css。</p><h1 id="d36e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤6:构建输出文件</h1><p id="910e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在所有的配置都完成了，我们可以使用各种选项调用rollup命令行脚本。调用<code class="du ks kt ku kv b">rollup -c</code>将构建这个包。但是我们不是直接调用它，而是通过指定一个脚本数组来设置与package.json本身中的各种脚本相对应的命令，如下所示</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="e14f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们只需调用<code class="du ks kt ku kv b">npm run build</code>，它将在<code class="du ks kt ku kv b">dist/</code>文件夹中生成所有的输出文件。我们现在需要验证它是否有效</p><h1 id="b48c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">步骤7:通过使用npm链接使用一个示例html测试包的umd版本</strong></h1><p id="9d16" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了检查这个包在被另一个应用程序导入时是如何工作的，我们可以创建一个样例应用程序并导入这个包。</p><p id="66c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在<code class="du ks kt ku kv b">examples</code>文件夹中创建一个文件<code class="du ks kt ku kv b">umd.html</code>。让我们复制文件中的以下html内容</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d929" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，上面的文件引用了来自<code class="du ks kt ku kv b">node_modules</code>的js和css文件。但是我们还没有向npm发布我们的包。那么我们如何确保<code class="du ks kt ku kv b">examples</code>中的node_modules文件夹包含listree包呢？</p><p id="7612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NPM为此提供了命令<code class="du ks kt ku kv b">npm link</code>。如果您熟悉python的包环境，这与从包文件夹中运行<code class="du ks kt ku kv b">python setup.py develop</code>有相同的效果。它实际上是将包安装在您想测试它的任何地方——在开发模式中。因此，如果对包代码进行了任何更改，调用应用程序也可以立即进行测试。这确保了我们不必在每次想要测试我们所做的小改变时都发布。因此，我们要做的是在本地链接软件包。</p><p id="4b4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以首先我们将在我们的<code class="du ks kt ku kv b">package</code>文件夹中运行<code class="du ks kt ku kv b">npm link</code>。一旦这个命令成功，这个包就链接到开发机器中的全局节点模块文件夹。</p><p id="bb6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了在我们正在开发的另一个包中使用我们的包，我们将进入examples文件夹并在那里运行<code class="du ks kt ku kv b">npm link listree</code>。这将在examples文件夹中创建一个包含<code class="du ks kt ku kv b">listree</code>包的<code class="du ks kt ku kv b">node_modules</code>文件夹。在浏览器中打开<code class="du ks kt ku kv b">examples/umd.html</code>文件时，我们可以看到功能按预期运行。</p><h1 id="a9ff" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤8:使用webpack测试包作为ES6模块的导入</h1><p id="e876" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了检查包作为ES6模块的行为，我们将在examples文件夹中创建一个src/index.js文件，其内容如下</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="61e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使这个脚本可以通过脚本标签加载，我们将使用webpack来转换和捆绑它。我们在这里使用webpack而不是rollup，因为webpack更适合于现成的应用程序捆绑(而rollup更适合于库捆绑)，并且更适合于测试我们的包在通过webpack捆绑时的行为，因为webpack是web开发人员最常用的包捆绑器。</p><p id="e681" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先必须通过运行<code class="du ks kt ku kv b">npm install -g webpack webpack-cli</code>来安装webpack和webpack-cli</p><p id="36a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们像这样加上一个<code class="du ks kt ku kv b">webpack.config.js</code></p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="11ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们运行<code class="du ks kt ku kv b">webpack</code>，它将创建一个<code class="du ks kt ku kv b">dist/mylistree.js</code>文件。我们现在将把我们的umd.html复制到<code class="du ks kt ku kv b">examples/es.html</code>，并用引用这个<code class="du ks kt ku kv b">dist/mylistree.js</code>文件的脚本标签替换底部引用listree.umd.min.js的脚本标签。也就是说，我们将替换它</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="3379" class="le jq hi kv b fi lf lg l lh li">&lt;script src="./node_modules/listree/dist/listree.umd.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>   listree();<br/>&lt;/script&gt;</span></pre><p id="f137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个-</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="2b67" class="le jq hi kv b fi lf lg l lh li">&lt;script src="dist/mylistree.js"&gt;&lt;/script&gt;</span></pre><p id="32c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第二种情况下，我们不需要调用<code class="du ks kt ku kv b">listree()</code>函数，因为我们已经在index.js中调用了它，index . js被打包为<code class="du ks kt ku kv b">mylistree.js</code>。现在，如果我们在浏览器中打开<code class="du ks kt ku kv b">examples/es.html</code>，我们可以看到功能按预期运行。</p><p id="1aa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们已经通过使用<code class="du ks kt ku kv b">file://</code>协议直接加载两个html文件来检查它们。如果我们想在通过web服务器提供服务的环境中测试它们，我们可以使用webpack的html和devserver插件来做同样的事情。但是为了简洁起见，让我们把这个任务留到以后的文章中。</p><h1 id="f782" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">第九步:推送至github repo</h1><p id="f7a8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们已经完成了包的创建，让我们也做一个到github的推送。我们还需要编辑。gitignore排除dist和node_modules文件夹。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="48e7" class="le jq hi kv b fi lf lg l lh li">node_modules/<br/>dist/</span></pre><p id="4122" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过，对package-lock.json文件进行版本提交是可以的。</p><h1 id="90b0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤10:将包发布到npm</h1><p id="e806" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为此，我们将首先在<a class="ae jo" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/</a>上创建一个账户(如果我们还没有的话)。然后在本地开发机器上，我们执行命令<code class="du ks kt ku kv b">npm login</code>。这将要求我们输入用户名、密码和电子邮件。一旦进入，我们就可以发布这个包了。</p><p id="9ffa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需在包文件夹中调用<code class="du ks kt ku kv b">npm publish</code>，我们就可以看到包被发布到npm存储库中。</p><h1 id="947e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤11:在html中使用发布的包</h1><p id="f0bb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">关于发布到npm的一个很棒的事情是我们的包获得了现成的CDN支持。将一个包发布到npm使得它可以通过各种内容交付网络自动获得，比如<a class="ae jo" href="https://unpkg.com/" rel="noopener ugc nofollow" target="_blank"> Unpkg </a>、<a class="ae jo" href="https://cdnjs.com/" rel="noopener ugc nofollow" target="_blank"> CDNJS </a>和<a class="ae jo" href="https://www.jsdelivr.com/" rel="noopener ugc nofollow" target="_blank"> JSDelivr </a>。我们可以选择这些中的任何一个。例如，如果我们决定使用unpkg，我们可以像这样访问我们包的umd js版本<a class="ae jo" href="https://unpkg.com/listree/dist/listree.umd.min.js" rel="noopener ugc nofollow" target="_blank">https://unpkg.com/listree/dist/listree.umd.min.js</a>。我们可以通过修改示例html文件中的css和js标签URL来测试这一点，使其指向这个CDN链接，而不是本地文件，我们将看到功能仍然按预期工作。</p><p id="5d51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们创建并发布了一个包到NPM仓库，并成功地在一个应用程序中使用了它。本教程到此结束。为这个教程创建的包的代码可以在https://github.com/SuryaSankar/listree<a class="ae jo" href="https://github.com/SuryaSankar/listree" rel="noopener ugc nofollow" target="_blank">获得。如果你觉得这个包或这个教程有用，请考虑主演回购。这个包本身可以在npm中使用，名称是<code class="du ks kt ku kv b">listree</code> </a><a class="ae jo" href="https://www.npmjs.com/package/listree" rel="noopener ugc nofollow" target="_blank">这里是</a>。你可以在你的项目中调用<code class="du ks kt ku kv b">npm install listree</code>来安装和使用它。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="3c9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mg">原载于</em><a class="ae jo" href="https://techonometrics.com/posts/how-to-publish-a-js-and-css-library-to-npm-using-rollup/" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://techonometrics.com</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>
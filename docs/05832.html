<html>
<head>
<title>Java Typesafe enum history</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java类型安全枚举历史</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-typesafe-enum-history-20053e8d0ea6?source=collection_archive---------11-----------------------#2021-07-31">https://medium.com/geekculture/java-typesafe-enum-history-20053e8d0ea6?source=collection_archive---------11-----------------------#2021-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4891cae86ee5197a56d4bfbbc9922fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*aWHW-yWO7IG3tqQemxkW2Q.png"/></div></figure><p id="470e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个故事中，我将概述Java中<code class="du jk jl jm jn b">enum</code>的演变。</p><p id="b70f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jo">可以跳过这一段</em> </strong> <em class="jo">。这里我会给你一些什么是enum的理论定义。面向对象视图:enum是Singelton </em> <strong class="io hj"> <em class="jo">设计模式</em> </strong> <em class="jo">的概括。Singelton意味着我们最多可以有1个实例，enum意味着我们正好有n个实例，其中n是编译时常数。这种观点在爪哇占主导地位，直到JDK 14/15。功能视图:枚举是</em> <strong class="io hj"> <em class="jo">不相交并集</em> </strong> <em class="jo">的(差)实现。“真正的”Java实现将</em> <strong class="io hj"> <em class="jo">密封类</em> </strong> <em class="jo">。密封类型是关于“有限数量的可能类型”</em> <em class="jo">而枚举是关于“有限数量的可能实例”。关于这一点的更多内容将在不同的故事中讲述，现在让我们来回顾一下历史。</em></p><blockquote class="jp jq jr"><p id="0795" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">枚举类型指定一组相关常数作为其值。示例包括一周的天数、标准的北/南/东/西罗盘方向、货币的硬币面额以及词法分析器的令牌类型。</em></p><p id="899b" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">传统上，枚举类型被实现为整数常量序列，这由下面的方向常量集来演示:</em></p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="4fa4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://www.infoworld.com/article/3543350/how-to-use-typesafe-enums-in-java.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3543350/how-to-use-types safe-enums-in-Java . html</a></p><h1 id="900d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">最初在JDK 1.0 <code class="du jk jl jm jn b">enum</code>构造没有被采用。</h1><p id="549b" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">上面描述的方法是Java语言设计者最初建议Java程序员处理Java缺少枚举特性的方法。</p><blockquote class="jp jq jr"><p id="b13f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">这种方法有几个问题</p><p id="922f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> * </em> <strong class="io hj"> <em class="hi">缺乏类型安全</em> </strong> : <em class="hi">因为枚举的类型常量只是一个整数，所以在需要常量的地方可以指定任何整数。此外，可以对这些常数执行加法、减法和其他数学运算；例如</em> <code class="du jk jl jm jn b"><em class="hi">(DIR_NORTH + DIR_EAST) / DIR_SOUTH</em></code> <em class="hi">)，这是没有意义的。</em></p><p id="9569" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> * </em> <strong class="io hj"> <em class="hi">命名空间不存在</em> </strong> : <em class="hi">枚举类型的常数必须以某种(最好是)唯一标识符为前缀(例如</em> <code class="du jk jl jm jn b"><em class="hi">DIR_</em></code> <em class="hi">)，以防止与另一个枚举类型的常数冲突。</em></p><p id="e569" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> * </em> <strong class="io hj"> <em class="hi">脆性</em> </strong> <em class="hi">:因为枚举类型常量被编译成类文件，它们的文字值存储在类文件中(在常量池中)[参见下面我的旁注]，改变常量的值需要重新构建这些类文件和依赖它们的应用程序类文件。否则，运行时将出现未定义的行为。</em></p><p id="c365" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">* <strong class="io hj"> <em class="hi">缺少信息:</em> </strong> <em class="hi">打印常量时，其整数值输出。这个输出没有告诉您整数值代表什么。它甚至不能识别常量所属的枚举类型。</em></p><p id="fc95" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">使用</em> <code class="du jk jl jm jn b"><em class="hi">java.lang.String</em></code> <em class="hi">常量可以避免“缺少类型安全”和“缺少信息”的问题。例如，您可以指定</em> <code class="du jk jl jm jn b"><em class="hi">static final String DIR_NORTH = "NORTH";</em></code> <em class="hi">。..与整数比较不同，不能用</em> <code class="du jk jl jm jn b"><em class="hi">==</em></code> <em class="hi">和</em> <code class="du jk jl jm jn b"><em class="hi">!=</em></code> <em class="hi">运算符比较字符串值(这些运算符只比较引用)。</em></p></blockquote><p id="f5dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://www.infoworld.com/article/3543350/how-to-use-typesafe-enums-in-java.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3543350/how-to-use-types safe-enums-in-Java . html</a></p><p id="e39f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另请参见<a class="ae kb" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/enums . html</a></p><p id="4671" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jo">旁注</em> : <em class="jo">“改变一个常量的值需要重新构建这些类文件和那些依赖于它们的应用程序类文件”。这种情况在我身上确实发生过几次。我正在源代码中更改<em class="jo">常量的值</em>，依靠IDE的<em class="jo">自动构建</em>功能，但是代码没有得到应该做的事情。经过几个小时的调试，我发现<em class="jo">常量的值</em>在运行时不会改变。我断定在类之间有一些奇怪的<em class="jo">链接</em>错误(这在我的C++代码中早几年就发生了)。所以我只是让<em class="jo">干净</em>和<em class="jo">重修</em>。几个小时后，它再次发生。再一次。经过一番研究我已经弄清楚这是因为<strong class="io hj"> <em class="jo">恒池</em> </strong>。我决定禁用<em class="jo">自动建</em>功能<em class="jo">。</em>从那以后我再也没有重新启用过它。随着<em class="jo">自动构建</em>特性被禁用<strong class="io hj">，我意识到我在改变一些常量，所以我应该重新构建我的所有代码，包括我的客户端代码</strong>。当我不改变任何常量时(大多数时候)，我只是使用一些额外的快捷方式来保存和重建。因为一些怪异的行为，我需要清理和重建是非常罕见的。</em></p><p id="d2e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">引用:</p><blockquote class="jp jq jr"><p id="c85f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">这些问题导致开发人员发明了一种基于类的替代品，称为</em> <code class="du jk jl jm jn b"><em class="hi">Typesafe Enum</em></code> <em class="hi">。</em></p><p id="82bb" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><a class="ae kb" href="https://www.infoworld.com/article/3543350/how-to-use-typesafe-enums-in-java.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3543350/how-to-use-types safe-enums-in-Java . html</a></p></blockquote><p id="359b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从其他来源引用:</p><blockquote class="jp jq jr"><p id="245c" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">在他的优秀著作《有效的Java编程语言指南》中，Joshua Bloch展示了如何在Java中使用类型安全枚举来定义一组命名值(参见第21项:用类替换枚举构造)。比如:</em></p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><blockquote class="jp jq jr"><p id="016c" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">现在如果创建一个</em> <code class="du jk jl jm jn b"><em class="hi">currentState </em></code> <em class="hi">类型的</em> <code class="du jk jl jm jn b"><em class="hi">MachineStates </em></code> <em class="hi">对象，它只能取值{ </em> <code class="du jk jl jm jn b"><em class="hi">WAIT</em></code> <em class="hi">、</em> <code class="du jk jl jm jn b"><em class="hi">NICKLE</em></code> <em class="hi">、</em> <code class="du jk jl jm jn b"><em class="hi">DIME</em></code> <em class="hi">、</em> <code class="du jk jl jm jn b"><em class="hi">QUARTER</em></code> <em class="hi"> }。超出范围的值将在编译时被捕获。</em></p><p id="e4f6" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">有一个封装了类型安全枚举功能的基类会很好。然后基类可以用来定义各种类型安全枚举子类:</p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="2db4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><blockquote class="jp jq jr"><p id="a142" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">TypeSafeEnum基类可以在这个<a class="ae kb" href="http://www.bearcave.com/software/java/misl/enum/TypeSafeEnum.html" rel="noopener ugc nofollow" target="_blank">网页</a>上找到或者在这里下载<a class="ae kb" href="http://www.bearcave.com/software/java/misl/enum/TypeSafeEnum.java" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="4697" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="http://bearcave.com/software/java/misl/enum/type_safe_enum.html" rel="noopener ugc nofollow" target="_blank">http://bear cave . com/software/Java/misl/enum/type _ safe _ enum . html</a></p><p id="383e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了方便起见，我提供了<em class="jo">类型安全枚举</em>的源代码:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="b669" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jo">注:</em></p><ul class=""><li id="2d8c" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">这本书的第一次添加是在2001年，所以我怀疑它是在JDK 1.3上写的。它看起来仍然很奇怪，因为集合API在JDK 1.2中可用，但是使用了<code class="du jk jl jm jn b">java.util.Vector</code>(而不是<code class="du jk jl jm jn b">java.util.List</code>的一些实现，例如<code class="du jk jl jm jn b">ArrayList</code>)。注意，那个<code class="du jk jl jm jn b">java.util.Enumeration </code>是<code class="du jk jl jm jn b">java.util.Iterator</code>的“旧式”。所需的修复很简单。</li><li id="4d1a" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">因为，这是Java 5.0之前的代码，所以它使用了<code class="du jk jl jm jn b">raw </code>类(<code class="du jk jl jm jn b">java.lang.Class</code>在JDK 5.0中被通用化)。所需的修复是微不足道的。</li><li id="ae1a" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">命名约定:为什么是<code class="du jk jl jm jn b">getName()</code>和<code class="du jk jl jm jn b">getValue()</code>？有点有趣的是，<code class="du jk jl jm jn b">enumInfo</code>并不遵循JavaBean约定，但是<code class="du jk jl jm jn b">TypeSafeEnum </code> API将自己暴露为JavaBean。在<code class="du jk jl jm jn b">Java 5.0</code> <code class="du jk jl jm jn b">enum </code>中对应的方法(有意地)没有遵循JavaBean约定。无论哪种方式，所需的修复都是微不足道的。</li><li id="8274" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated"><code class="du jk jl jm jn b">getName()</code>和<code class="du jk jl jm jn b">getValue()</code>应做成<code class="du jk jl jm jn b">final</code>的样子。这是在<code class="du jk jl jm jn b">Java 5.0</code>枚举中完成的。我个人认为这不是一个大问题。如果有人想射进他的腿，没人能阻止他。<code class="du jk jl jm jn b">TypeSafeEnum</code>本身不依赖<code class="du jk jl jm jn b">getName()</code>和<code class="du jk jl jm jn b">getValue()</code>方法。无论哪种方式，所需的修复都是微不足道的。</li><li id="2851" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">在<code class="du jk jl jm jn b">Java 5.0</code> <code class="du jk jl jm jn b">enum</code> <code class="du jk jl jm jn b">hashCode()</code>作出<code class="du jk jl jm jn b">final</code>和<code class="du jk jl jm jn b">equals()</code>作出<code class="du jk jl jm jn b"> ==</code>的比较:</li></ul><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="1051" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这确保了<code class="du jk jl jm jn b">java.lang.Object's hashCode()</code>和<code class="du jk jl jm jn b">equals()</code>用于<code class="du jk jl jm jn b">Enum</code>的比较。这是一个非常有效的方法，它也可以和多个类装入器一起工作(下面会详细介绍)。从正确性的角度来看，这样做也是正确的。如果我们有两个具有相同数据成员的<code class="du jk jl jm jn b">enum</code>常量，我们希望将它们视为不同的实例。在<code class="du jk jl jm jn b">java.lang.Enum</code>中<code class="du jk jl jm jn b">"value" </code>(它被称为<code class="du jk jl jm jn b">ordinal </code> their)是由客户端代码提供的，所以我们不能依赖它。在这个实现中,<code class="du jk jl jm jn b">“value”</code>是在内部计算的，客户端代码无法破解它，所以我们可以用它来做比较。所以，<em class="jo">可以是ok的，不提供任何实现的</em> <code class="du jk jl jm jn b"><em class="jo">hashCode()</em></code> <em class="jo">和</em> <code class="du jk jl jm jn b"><em class="jo">equals(),</em></code> <em class="jo">可以提供上述实现或者基于</em> <code class="du jk jl jm jn b"><em class="jo">“value”</em></code> <em class="jo">的比较。做出设计决策后，这种变更应该易于实现。</em></p><ul class=""><li id="0464" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">在<code class="du jk jl jm jn b">Java 5.0</code>中<code class="du jk jl jm jn b">enum finalize()</code>方法被做成了空的和最终的。再说一次，如果有人想射进他的腿，它可能会这样做。我个人认为这是不需要的。无论哪种方式，所需的修复都是微不足道的。</li><li id="6ac8" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">在<code class="du jk jl jm jn b">Java 5.0</code>中<code class="du jk jl jm jn b">enum</code>是实现了<code class="du jk jl jm jn b">java.lang.Comparable</code>。从设计的角度来看，我们可以认为在每一个枚举中，我们都可以根据<code class="du jk jl jm jn b"><em class="jo">“value” </em></code> <em class="jo">(在<code class="du jk jl jm jn b">Java 5.0</code> <code class="du jk jl jm jn b">enum</code>的术语<em class="jo">中的</em> <code class="du jk jl jm jn b"><em class="jo">ordinal</em></code> <em class="jo"> </em>)来定义<em class="jo">总顺序</em>。另一个人可能会说，这样的顺序并不总是有意义的。<em class="jo">无论哪种方式，所需的修复都很简单。</em></em></li><li id="04f8" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">在第25行<code class="du jk jl jm jn b">infoVec</code>应该声明为<code class="du jk jl jm jn b">final</code>。在Java 8+中，这个变量将会是<code class="du jk jl jm jn b"><em class="jo">effectively final</em></code>，所以它还不错(我仍然认为把它改成<code class="du jk jl jm jn b">final</code>只是为了可读性——为了清楚地表明意图),但是支持它们可以潜在地防止错误。<em class="jo">所需的修复是微不足道的。</em></li><li id="4db2" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">有趣的是，<code class="du jk jl jm jn b">enumInfo</code>并不是作为JavaBean创建的。首先，它的名字是小写，最好是大写。在这种特殊的情况下，我实际上可以不把这个类定义为JavaBean，我不会坚持这个修正。<em class="jo">无论哪种方式，所需的修复都是微不足道的。</em></li><li id="c2e6" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">不是很明显，但其实这个类是(<em class="jo">差不多</em> ) <code class="du jk jl jm jn b">Thread-safe</code>。代码执行离开构造函数后，类就是<code class="du jk jl jm jn b">immutable</code>。唯一需要修改的地方是在第45行，我们将常量<code class="du jk jl jm jn b">Enum </code>发送给客户端。最简单的修复将是<strong class="io hj">制作返回</strong>的防御副本<code class="du jk jl jm jn b"><strong class="io hj">Enumeation</strong></code>。<em class="jo">所需的修复很简单。</em></li><li id="2fc6" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated"><em class="jo">注意，</em>尽管我们在构造函数内部改变了<code class="du jk jl jm jn b">static infoVec</code>变量，但这种改变实际上是线程安全的。<code class="du jk jl jm jn b">infoVec</code>仅在构造函数之外读取。在构造函数内部，在该类的类加载器中强加了<code class="du jk jl jm jn b">TypeSafeEnum.class</code>上的<code class="du jk jl jm jn b">implicit lock </code>。这种锁是JLS要求的。引用:</li></ul><blockquote class="jp jq jr"><p id="48c3" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">对于每个类或接口C，都有一个唯一的初始化锁LC。</p><p id="1df9" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> …。</em></p><p id="98a5" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">对于每个类或接口C，都有一个唯一的初始化锁LC。从C到LC的映射由Java虚拟机实现决定。初始化C的过程如下:</p><p id="3c48" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">在c的初始化锁LC上同步。这包括等待，直到当前线程可以获取LC。</em></p><p id="501d" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> … </em></p></blockquote><p id="bd37" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4.2" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/jls/se8/html/jls-12 . html # jls-12 . 4 . 2</a></p><ul class=""><li id="abea" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">围绕<code class="du jk jl jm jn b">enumInfo.hashCode.</code> <br/>有一个非常微妙的问题，这个字段用枚举的类的<em class="jo"> hashCode填充。可以认为是<code class="du jk jl jm jn b">getClass().hashCode()</code>。由于<code class="du jk jl jm jn b">infoVec</code>变量是<code class="du jk jl jm jn b">static</code>，所以我们的<code class="du jk jl jm jn b"><strong class="io hj">infoVec </strong></code> <strong class="io hj">将应用程序的所有类型安全枚举保存在一个大的</strong> <code class="du jk jl jm jn b"><strong class="io hj">Vector </strong></code> <strong class="io hj">(列表)</strong>中，其中<em class="jo">枚举的类的hashCode </em>作为<em class="jo">区分的</em>字段(见上图)。<br/>你应该在这里看到代码气味。<br/>这里有一些<em class="jo">性能</em>问题，例如，可能导致<code class="du jk jl jm jn b">OutOfMemoryError.</code> <br/>在mutli类加载器环境中也有一些<em class="jo">内存泄漏</em>相关问题。<br/> <em class="jo">所需的修复并不难，但很难考虑到所有问题。</em>下面我会回到这一点<em class="jo">(见下面关于缓存)</em>。</em></li><li id="7c8a" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">缺少两个方法。<code class="du jk jl jm jn b">findEnumByValue()</code>和<code class="du jk jl jm jn b">findEnumByName().</code>客户端代码可以获得<code class="du jk jl jm jn b">Enumeration </code>(这将花费与应用程序中类型安全枚举的数量成比例的时间，这实际上可能很长，尤其是如果我们使用多个类加载器，见下文)，然后它应该使用比较(并依赖于<code class="du jk jl jm jn b">getName()</code>和<code class="du jk jl jm jn b">getValue()</code>)找到正确的一个！).这与<code class="du jk jl jm jn b">Enum</code>中的常数数量成比例。<em class="jo">这个任务很难，但是可行(见下面关于缓存的内容)。<a class="ae kb" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=5058132" rel="noopener ugc nofollow" target="_blank">见【https://bugs.java.com/bugdatabase/view_bug.do? T42】bug_id=5058132 </a></em></li><li id="a24c" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">在<code class="du jk jl jm jn b">Java 5.0</code>中<code class="du jk jl jm jn b">enum </code>覆盖<code class="du jk jl jm jn b">java.lang.Object’</code>的<code class="du jk jl jm jn b">clone()</code>方法为<code class="du jk jl jm jn b">throw new CloneNotSupportedException()</code>。上面的实现没有做到这一点。这实际上是强制性的修复，否则我们就为创建新的常量提供了漏洞。<em class="jo">所需的修复很简单。</em></li><li id="7345" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">在<code class="du jk jl jm jn b">Java 5.0</code>中<code class="du jk jl jm jn b">enum</code>提供了<code class="du jk jl jm jn b">readObject()</code>和<code class="du jk jl jm jn b">readObjectNoData() </code>的方法即<code class="du jk jl jm jn b">throw new InvalidObjectException()</code>的方法。这样做是为了阻止使用序列化机制创建新的<code class="du jk jl jm jn b">enum</code>实例的能力。也可以用另一种方式实现，用现有的枚举替换序列化的枚举(基于它的<code class="du jk jl jm jn b">getName()</code>和<code class="du jk jl jm jn b">getValue()</code>)。重点是阻止创建新实例的能力。<em class="jo">所需的修复很简单。</em></li><li id="111a" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">还有一个微妙的问题是这些代码是否正确地<strong class="io hj">同步</strong>。我认为是这样的，但原因并不明显。首先，根据Java语言规范，<em class="jo">类初始化是自顶向下进行的，静态初始化应该在非静态</em>之前完成。</li></ul><p id="3d0b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jo">注:这部分比较复杂，可以跳过，从“上表看一看”开始继续阅读。</em> </strong></p><p id="d2a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管如此，代码仍然是非常脆弱的<strong class="io hj"><em class="jo"/></strong><em class="jo">，</em>如果你稍微改变变量声明的顺序，它就可能变得不正确(<em class="jo">边注</em>:这实际上也发生在我身上，花了很多时间来理解为什么我的代码突然停止正常工作)，并且不容易推理。让我们考虑一些基于<a class="ae kb" href="https://stackoverflow.com/questions/2547713/why-static-fields-are-not-initialized-in-time" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2547713/why-static-fields-is-not-initialized-in-time</a>的更简单的例子</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="8599" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们运行这段代码，屏幕上会显示什么？如果您已经猜到输出是:</p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="5a3a" class="lx kd hi jn b fi ly lz l ma mb">null</span><span id="e022" class="lx kd hi jn b fi mc lz l ma mb">null</span><span id="92c0" class="lx kd hi jn b fi mc lz l ma mb">MyClass@15db9742</span><span id="94c0" class="lx kd hi jn b fi mc lz l ma mb">null</span></pre><p id="8f4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请接受我的祝贺。</p><p id="6d10" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简化解释如下:为了运行main，应该先初始化<code class="du jk jl jm jn b">MyClass </code>。初始化是自顶向下的，静态初始化应该在非静态初始化之前完成，所以第3行中的第一个初始化将会发生。第一部分是对构造函数的调用，所以我们跳到第7行。我们仍然在静态初始化块中，但是现在我们在非静态上下文中运行(<em class="jo">旁注</em>:这就是为什么不推荐从构造函数调用方法的原因——它们可能对应未初始化的非静态字段)。因为它们还没有被初始化，所以它们有<code class="du jk jl jm jn b">null</code>值(它可能包含垃圾，就像C；这个其实是JVM保证的)。所以，我们会看到2 <code class="du jk jl jm jn b">null</code>印在控制台上。然后我们将退出构造函数，回到第3行，用object初始化<code class="du jk jl jm jn b">myClass</code>字段(尽管<code class="du jk jl jm jn b">myclass2 </code>仍然是<code class="du jk jl jm jn b">null</code>)。那我们就去4号线。同样，将调用构造函数。在构造函数中，我们引用静态字段— <code class="du jk jl jm jn b">myClass </code>被初始化，所以我们看到它的非空值，但是<code class="du jk jl jm jn b">myclass2</code>仍然是<code class="du jk jl jm jn b">null,</code>，所以我们看到<code class="du jk jl jm jn b">null</code>被打印出来。然后我们将退出构造函数，没有什么(有趣的)事情可做了。</p><p id="f1bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">详细解释如下:</p><blockquote class="jp jq jr"><p id="862d" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">这是当你第一次引用类</em> <code class="du jk jl jm jn b"><em class="hi">MyClass</em></code> <em class="hi">时JVM经历的顺序。</em></p><p id="0b08" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> *将字节码载入内存。</em></p><p id="67da" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> *静态存储的内存被清除(二进制零)。</em></p><p id="2908" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> *初始化类:</em></p><p id="229e" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 1。按照出现的顺序执行每个静态初始化器，这包括静态变量和</em> <code class="du jk jl jm jn b"><em class="hi">static { ... }</em></code> <em class="hi">块。</em></p><p id="209b" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 2。JVM然后初始化【JVM持有</em>初始化锁LC，见上面<em class="hi">你的</em> <code class="du jk jl jm jn b"><em class="hi">myClass</em></code> <em class="hi">静态变量到</em> <code class="du jk jl jm jn b"><em class="hi">MyClass</em></code> <em class="hi">的新实例。</em></p><p id="29ea" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 3。当这种情况发生时，JVM注意到</em> <code class="du jk jl jm jn b"><em class="hi">MyClass</em></code> <em class="hi">已经被加载(字节码)</em> <strong class="io hj"> <em class="hi">并且正在被初始化</em> </strong> <em class="hi">的过程中，所以它跳过【静态】初始化。</em></p><p id="5a92" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 4。在堆上为对象分配内存。</em></p><p id="67bc" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 5。执行构造函数。</em></p><p id="124f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 6。打印出</em> <code class="du jk jl jm jn b"><em class="hi">obj</em></code> <em class="hi">的值，它仍然是</em> <code class="du jk jl jm jn b"><em class="hi">null</em></code> <em class="hi">(因为它不是堆和构造函数初始化变量的一部分)。</em></p><p id="1a69" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi"> 6。当构造函数完成时，执行下一个静态初始化器，将</em> <code class="du jk jl jm jn b"><em class="hi">obj</em></code> <em class="hi">设置为</em> <code class="du jk jl jm jn b"><em class="hi">Object</em></code> <em class="hi">的新实例。</em></p><p id="7fe6" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">* <em class="hi">类初始化完成。从这一点来看，所有的构造函数调用都将如你所想的那样运行——也就是说</em> <code class="du jk jl jm jn b"><em class="hi">obj</em></code> <em class="hi">将不是</em> <code class="du jk jl jm jn b"><em class="hi">null</em></code> <em class="hi">而是对一个</em> <code class="du jk jl jm jn b"><em class="hi">Object</em></code> <em class="hi">实例的引用。</em></p><p id="f502" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi">…</p><p id="8239" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">还要注意，这都发生在第一次引用该类的同一个线程上。其次，</em> <strong class="io hj"> JVM保证在任何其他线程被允许使用这个类</strong> [ <em class="hi"> JVM持有</em>初始化锁LC，见上】<em class="hi">。</em></p></blockquote><p id="ebaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://stackoverflow.com/a/2557613/1137529" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/2557613/1137529</a></p><p id="c78c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将重复:<strong class="io hj"> JVM保证初始化将在任何其他线程被允许使用这个类之前完成。</strong>实际上，JVM在初始化过程中持有<em class="jo">初始化锁LC </em>。因为这个这个<strong class="io hj">锁，</strong> <code class="du jk jl jm jn b"><strong class="io hj">TypeSafeEnum</strong></code> <strong class="io hj">的代码是线程安全的</strong>；<code class="du jk jl jm jn b">infoVec</code>在任何<code class="du jk jl jm jn b">TypeSafeEnum </code>实例之前被初始化；<code class="du jk jl jm jn b">infoVec</code>只改变<strong class="io hj">在<code class="du jk jl jm jn b">TypeSafeEnum </code>的构造函数内</strong>(即在初始化锁LC下；<code class="du jk jl jm jn b">findInfo()</code>也在初始化锁LC) <strong class="io hj">下执行。这不是微不足道的陈述，而是真实的。</strong></p><p id="2e57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">复杂零件结束</strong></p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="0928" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看看上面的列表。虽然上面的大部分都很简单(我一会儿会回到难的那一点)，但有很多并不明显。事实是，有许多提议的<em class="jo">类型安全枚举的“标准”实现，</em>包括Joshua Bloch的一个，遗漏了其中一些。</p><p id="9e64" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里要告诉你的是，2006年在JDK 1.4的某个地方，我做了自己的实现。当5出来的时候，我做的第一件事就是看Sun(Oracle后来收购了Sun)对<code class="du jk jl jm jn b">enum</code>的实现。</p><p id="253d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实现并不完全相同，但涵盖了所有问题。例如，我的实现考虑到了<code class="du jk jl jm jn b">Serialization</code>漏洞，虽然不是通过完全阻止它，而是通过实例替换。例如，我也没有实现<code class="du jk jl jm jn b">java.lang.Comparable</code>接口。</p><p id="a5ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有4个问题实际上很难解决:<em class="jo">缓存</em>、<em class="jo"> GC </em>、<em class="jo">类加载器</em>、<em class="jo">扩展性。</em></p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="0947" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的缓存实现与Sun的完全不同。我不能增加<code class="du jk jl jm jn b">java.lang.Class</code>来在其中存储<code class="du jk jl jm jn b">enum constants</code>(这样一些垃圾收集(GC)相关的问题就解决了，下面会详细介绍)并且改变<code class="du jk jl jm jn b">javac </code>——Java编译器不是我考虑的选项之一。:-) )</p><p id="ed5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的缓存实现如下:<em class="jo"> TypeSafeEnum </em>有<code class="du jk jl jm jn b">private</code> <code class="du jk jl jm jn b"><strong class="io hj">static </strong>HashMap </code>，键为<code class="du jk jl jm jn b">String</code>(是<code class="du jk jl jm jn b">YourEnum.class.getName()</code>)，值为<code class="du jk jl jm jn b">HashMap </code>，键为<code class="du jk jl jm jn b">String</code>(是<code class="du jk jl jm jn b">getName()</code>)，值为<em class="jo"> enum常量</em>。在<em class="jo">typesafenum</em>中有<code class="du jk jl jm jn b">public static TypeSafeEnum</code> <em class="jo"> </em> <code class="du jk jl jm jn b">valueOf(Class enumClass, String name</code>)函数有明显的实现。还有一个在构造函数中调用的<code class="du jk jl jm jn b">protected addEnum()</code>方法，用于将<code class="du jk jl jm jn b">enum</code>常量放入缓存。</p><p id="ea76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基本思想是<em class="jo"> TypeSafeEnum </em>包含从他那里继承的所有枚举的缓存——每个枚举的常量按照它们的类名(作为字符串)分组。在<code class="du jk jl jm jn b">enum</code>构建完成后，你应该只能通过<code class="du jk jl jm jn b">valueOf() </code>函数来访问这个缓存。您可能可以访问其他人的枚举，但是您应该提供该访问的<code class="du jk jl jm jn b">Class</code>对象。如果您可以访问<code class="du jk jl jm jn b">Class </code>对象，那么向您提供对这个<code class="du jk jl jm jn b">Class</code>的实例的访问是可以的。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="12b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，你可能有以下问题:</p><ol class=""><li id="b28d" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj mk ll lm ln bi translated">为什么缓存是<code class="du jk jl jm jn b">static</code>？</li><li id="76c3" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj mk ll lm ln bi translated">为什么外键是<code class="du jk jl jm jn b">String</code>而不是<code class="du jk jl jm jn b">Class</code>？</li><li id="6331" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj mk ll lm ln bi translated">为什么内部缓存是<code class="du jk jl jm jn b">HashMap </code>而不是<code class="du jk jl jm jn b">ArrayList</code>？</li></ol><p id="8b0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们开始逐一回答这些问题。</p><ol class=""><li id="dcf1" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj mk ll lm ln bi translated">你可能认为缓存是<code class="du jk jl jm jn b">static </code>为了能够被<code class="du jk jl jm jn b">public static TypeSafeEnum</code> <em class="jo"> </em> <code class="du jk jl jm jn b">valueOf(Class enumClass, String name</code>)函数访问。这只是原因之一。在<code class="du jk jl jm jn b"><em class="jo">initialization order</em></code> <em class="jo"> </em>的enum中还有更微妙的原因。为了演示我所说的，我将提供一些来自<em class="jo"> Java语言规范</em>的例子。</li></ol><blockquote class="jp jq jr"><p id="e479" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><strong class="io hj">例8 . 9 . 2–2。对枚举常量自引用的限制</strong></p><p id="2a3e" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">如果没有关于<code class="du jk jl jm jn b"><em class="hi">static</em></code>字段访问的规则，显然合理的代码会在运行时失败…下面是一个会失败的代码的例子:</p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><blockquote class="jp jq jr"><p id="edc8" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">这个枚举的静态初始化会抛出一个<code class="du jk jl jm jn b"><em class="hi">NullPointerException</em></code>，因为当枚举常量的构造函数运行时<code class="du jk jl jm jn b"><em class="hi">static</em></code>变量<code class="du jk jl jm jn b"><em class="hi">colorMap</em></code>未初始化。代码可以很容易地重构以正常工作:</p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><blockquote class="jp jq jr"><p id="1b27" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">重构后的版本显然是正确的，因为</em> <strong class="io hj"> <em class="hi">静态初始化自顶向下发生。</em>T25】</strong></p></blockquote><p id="a893" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/jls/se8/html/jls-8 . html # jls-8.9</a></p><p id="8ada" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是的，我在实践中遇到过这种情况。这是如此糟糕，以至于Sun增加了具体的规则，在编译时拒绝上述代码。</p><p id="23d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<code class="du jk jl jm jn b">static</code>字段，只需按照描述进行简单的代码重新排序和重构就足够了。对于<code class="du jk jl jm jn b">non-static</code>字段，无论<code class="du jk jl jm jn b"><em class="jo">TypeSafeEnum</em></code>如何扩展，都很难有工作代码(因为<code class="du jk jl jm jn b">static</code>字段首先被自顶向下初始化，而<code class="du jk jl jm jn b">non-static</code>字段被初始化，但是在<code class="du jk jl jm jn b">enum </code>类的构造函数中，我们调用了<code class="du jk jl jm jn b">addEnum</code>类，这可能会导致尚未初始化的字段的意外初始化(<em class="jo">更多详细信息，请参见上面的</em> <code class="du jk jl jm jn b"><em class="jo">MyClass</em></code> <em class="jo">复杂示例</em> ) …这真是一团糟，为了避免这种情况，最好将缓存声明为<code class="du jk jl jm jn b">static,</code></p><p id="96dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<em class="jo">为什么外键是</em> <code class="du jk jl jm jn b"><em class="jo">String</em></code> <em class="jo">而不是</em> <code class="du jk jl jm jn b"><em class="jo">Class</em></code> <em class="jo">？</em></p><p id="fda8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有两个原因:<em class="jo">类加载</em>相关和<em class="jo"> GC </em>相关。</p><h2 id="a62f" class="lx kd hi bd ke ml mm mn ki mo mp mq km ix mr ms kq jb mt mu ku jf mv mw ky mx bi translated">让我们从类加载问题开始。</h2><p id="1705" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated"><strong class="io hj"> <em class="jo">这一节比较复杂，你可以放心地跳过它，继续阅读与GC相关的问题。</em>T41】</strong></p><p id="02cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我的设置中<code class="du jk jl jm jn b"><em class="jo">TypeSafeEnum</em></code> <em class="jo"> </em>属于某个infra项目，所以它被打包在某个<code class="du jk jl jm jn b">jar</code>中。<code class="du jk jl jm jn b">Tomcat</code> web服务器托管多个应用程序，这些应用程序被打包在单独的<code class="du jk jl jm jn b">war</code>文件中(您应该记得，那是2006年，支持它们)在同一个<code class="du jk jl jm jn b">web server</code>上托管多个应用程序是正常的做法；更不用说，手动安装和配置<code class="du jk jl jm jn b">Tomcat</code>并为其部署应用程序是正常的做法。所以，我有多个<code class="du jk jl jm jn b">war</code>文件，其中有<code class="du jk jl jm jn b">jar</code>的副本，而<code class="du jk jl jm jn b">jar</code>中有<code class="du jk jl jm jn b"><em class="jo">TypeSafeEnum</em></code><em class="jo"/><em class="jo">。</em></p><p id="72ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在JVM中，我们为每个war文件提供了<em class="jo">类加载器，并且为</em> <code class="du jk jl jm jn b"><em class="jo">jar</em></code> <em class="jo">文件</em>提供了<em class="jo">单独的类加载器。所以，每个<code class="du jk jl jm jn b">war</code>级装载器都有它自己的<strong class="io hj"/><code class="du jk jl jm jn b">jar</code>级装载器。你可以在这里阅读<a class="ae kb" href="http://tomcat.apache.org/tomcat-6.0-doc/class-loader-howto.html" rel="noopener ugc nofollow" target="_blank">http://Tomcat . Apache . org/Tomcat-6.0-doc/class-loader-how to . html</a>以及更多细节。</em></p><blockquote class="jp jq jr"><p id="92dc" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">注意:<em class="hi">虽然可以将</em> <code class="du jk jl jm jn b"><em class="hi">jar</em></code> <em class="hi">放到</em> <code class="du jk jl jm jn b"><em class="hi">shared</em></code> <em class="hi"> lib中，并且使用这种方式我们可以拥有</em> <code class="du jk jl jm jn b"><em class="hi">shared jar</em></code> <em class="hi">类加载器，这将导致在内存中只有1个</em> <code class="du jk jl jm jn b"><em class="hi">TypeSafeEnum </em></code> <em class="hi">，这样的尝试实际上是非常有价值的。你可以在这里阅读</em><a class="ae kb" href="https://stackoverflow.com/questions/267953/does-tomcat-load-the-same-library-file-into-memory-twice-if-they-are-in-two-web" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://stack overflow . com/questions/267953/does-Tomcat-load-the-same-library-file-into-memory-two-if-they-is-in-two-web</em></a><em class="hi">仅引用此链接中的一句话:</em></p><p id="19bb" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">将库放在commons目录中可能是危险的，只有在您可以控制部署哪些webapp，以及每个web app使用的库的<strong class="io hj">版本是什么的情况下，才必须使用它…</strong></p><p id="62ae" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">因此，你不能拥有不同版本的共享jar。但还有更多】。</p><p id="db74" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">在这种情况下，您将有1个</em> <code class="du jk jl jm jn b"><em class="hi">TypeSafeEnum</em></code> <em class="hi">，其中1个缓存保存从不同的</em> <code class="du jk jl jm jn b"><em class="hi">war</em></code> <em class="hi">类加载器加载的</em> <code class="du jk jl jm jn b"><em class="hi">enum</em></code> <em class="hi">。这会导致</em>应用程序重新部署<em class="hi">的问题。如果我想重新加载某个应用程序</em><code class="du jk jl jm jn b"><em class="hi">A.war </em></code><em class="hi">Tomcat在幕后做的事情，它抛出应用程序类加载器，加载</em> <code class="du jk jl jm jn b"><em class="hi">A.war</em></code> <em class="hi">的所有类。这将导致GC收集所有这样的类，这样它们可以被新创建的专用</em> <code class="du jk jl jm jn b"><em class="hi">war</em></code> <em class="hi">类加载器重新加载。但是现在，我有了位于</em> <code class="du jk jl jm jn b"><em class="hi">shared jar</em></code> <em class="hi">类加载器中的缓存，它间接保存了对已加载类的强引用，所以重载会失败。这种情况的可能解决方案是使用</em> <code class="du jk jl jm jn b"><em class="hi">WeakHashMap</em></code>。</p><p id="d97d" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">注意:<em class="hi">这需要小心:我们不希望</em> <code class="du jk jl jm jn b"><em class="hi">enum</em></code> <em class="hi">常量在应用程序运行过程中消失。这确实发生在我身上，所以我把原来使用的</em> <code class="du jk jl jm jn b"><em class="hi">WeakHashMap</em></code> <em class="hi">换成了</em> <code class="du jk jl jm jn b"><em class="hi">HashMap</em></code> <em class="hi">。</em></p><p id="8517" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">下面我再回到这一点。</em></p></blockquote><p id="3254" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们最终得到了多份<code class="du jk jl jm jn b"><em class="jo">TypeSafeEnum</em></code> <em class="jo"> </em>坐在记忆中。但是它们存在于完全独立的类装入器层次结构中(从应用程序A.war类装入器装入的用户定义类不能访问从应用程序B.war类装入器装入的用户定义类)。因此，虽然我们确实有一些浪费，磁盘上的<em class="jo">—</em>相同的<code class="du jk jl jm jn b">jar</code>和内存中的<em class="jo">的多个副本— </em> <strong class="io hj">我们实际上有多个</strong> <code class="du jk jl jm jn b"><strong class="io hj"><em class="jo">TypeSafeEnum.class</em></strong></code> <em class="jo"> </em>的实例，将<strong class="io hj">留在内存</strong>中，但是它们不能相互交互，因为Tomcat提供了类加载器隔离。所以，它并没有消除任何<strong class="io hj"> <em class="jo">实际的</em> </strong>问题，事实上，我们可以使用<code class="du jk jl jm jn b">Class</code>作为地图中的一个键。然而，还有一个与GC相关的问题，我将在下面讨论。</p><blockquote class="jp jq jr"><p id="65e4" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">附注:<em class="hi">在我的下一份工作中，我们已经将应用程序从Tomcat转移到JBoss。最初JBoss配置错误(这样做是为了解决与类路径相关的问题；JBoss使用logger和我们使用相同的</em> <code class="du jk jl jm jn b"><em class="hi">jar</em></code> <em class="hi">进行日志记录，但是版本不同，我们要使用我们的</em> <code class="du jk jl jm jn b"><em class="hi">jar</em></code> <em class="hi">进行日志记录里面的</em> <code class="du jk jl jm jn b"><em class="hi">war</em></code> <em class="hi">和JBoss的logger for JBoss——这样的问题最终导致了</em> <a class="ae kb" rel="noopener" href="/swlh/java-platform-module-system-953cc88658fb"> <em class="hi"> Java平台模块系统</em> </a> <em class="hi"> at JDK 9)。观察到的行为是，在第一次用户请求时，我们在Logger类上获得了</em> <code class="du jk jl jm jn b"><em class="hi">ClassClassException</em></code> <em class="hi">。应用程序正常启动，并用日志程序初始化，但是在第一次用户请求时，我们有奇怪的</em> <code class="du jk jl jm jn b"><em class="hi">ClassClassException</em></code> <em class="hi">说</em> <code class="du jk jl jm jn b"><em class="hi">org.apache.log4j.Logger</em></code> <em class="hi">不能转换为</em> <code class="du jk jl jm jn b"><em class="hi">org.apache.log4j.Logger</em></code> <em class="hi">。当向我显示这个异常时，我立即想起了上面描述的场景，实际上我可以用两个不同的类装入器装入同一个类。这有助于我们追踪问题，初始化代码是用不同的类加载器运行的，不是用</em> <code class="du jk jl jm jn b"><em class="hi">war</em></code> <em class="hi">类加载器，而是用它的父类加载器。再次，它发生了，因为JBoss的错误配置，这是固定的。我们以不改变类加载器用法的方式解决了JBoss中不同版本的</em> <code class="du jk jl jm jn b"><em class="hi">logger</em></code> <em class="hi">。</em></p></blockquote><h1 id="7ab4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="du jk jl jm jn b">String</code>而不是<code class="du jk jl jm jn b">Class</code>作为缓存中的外部关键字时出现与GC相关的问题</h1><p id="2135" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">如果你使用<code class="du jk jl jm jn b">HashMap</code>作为缓存，使用<code class="du jk jl jm jn b">Class</code>作为键，你<em class="jo">可以</em>阻止<code class="du jk jl jm jn b">enum</code>被垃圾收集。</p><p id="58a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">引用:</p><blockquote class="jp jq jr"><p id="e0df" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">…应该注意确保值对象不会直接或间接地强烈引用它们自己的键，因为这将防止键被丢弃。</em></p></blockquote><p id="d283" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/weakhashmap . html</a></p><p id="80d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，使用<code class="du jk jl jm jn b">String</code>而不是<code class="du jk jl jm jn b">Class</code>可以防止GC无法丢弃<code class="du jk jl jm jn b">enum</code>的可能性，因为我们将它的<code class="du jk jl jm jn b">Class</code>作为键。</p><p id="c5c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果我们的<code class="du jk jl jm jn b">enum</code>正在使用<code class="du jk jl jm jn b">war</code>类加载器加载，并且我们想要重新部署我们的应用程序，Tomcat将通过当前的<code class="du jk jl jm jn b">war</code>类加载器，GC应该丢弃所有加载的类。如果<code class="du jk jl jm jn b"><strong class="io hj"><em class="jo">TypeSafeEnum</em></strong></code> <strong class="io hj"> <em class="jo"> </em> </strong>是使用某个不同的不可丢弃类加载器加载的，这将防止此类<code class="du jk jl jm jn b">enum</code>被丢弃。所以，使用<code class="du jk jl jm jn b">String</code>和<code class="du jk jl jm jn b">Class</code>可以提前避免这样的陷阱。</p><blockquote class="jp jq jr"><p id="483e" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">注:<em class="hi">有一个极端案例是我认识到的，而</em>被设计<em class="hi">忽略了。我们可以把</em> <code class="du jk jl jm jn b"><em class="hi">enum</em></code> <em class="hi">说成</em> <code class="du jk jl jm jn b"><em class="hi">com.company.entities.MyEnum</em></code> <em class="hi">那是在</em><code class="du jk jl jm jn b"><em class="hi">jar</em></code><em class="hi">-文件里面定义的和在</em><code class="du jk jl jm jn b"><em class="hi">war</em></code><em class="hi">-文件里面重新定义的</em> <code class="du jk jl jm jn b"><em class="hi">com.company.entities.MyEnum</em></code> <em class="hi">。这样做是为了“覆盖”某些类定义。在常规的类加载机制下，这工作得很好，将只有1个</em> <code class="du jk jl jm jn b"><em class="hi">java.lang.Class</em></code> <em class="hi">表示</em> <code class="du jk jl jm jn b"><em class="hi">com.company.entities.MyEnum.</em></code> <em class="hi">但是我可以编写代码，这也将从</em> <code class="du jk jl jm jn b"><em class="hi">jar</em></code> <em class="hi">文件中加载</em> <code class="du jk jl jm jn b"><em class="hi">com.company.entities.MyEnum</em></code> <em class="hi">(通过显式指定</em> <code class="du jk jl jm jn b"><em class="hi">jar's</em></code> <em class="hi">类加载器；而且我可以相当容易地得到</em> <code class="du jk jl jm jn b"><em class="hi">jar's</em></code> <em class="hi">类加载器的参考)。在这种极端情况下，我将有两个</em> <strong class="io hj"> <em class="hi">分布图</em> </strong> <code class="du jk jl jm jn b"><em class="hi">java.lang.Class</em></code> <em class="hi">，它们都代表</em> <code class="du jk jl jm jn b"><em class="hi">com.company.entities.MyEnum</em></code> <em class="hi">，但是如果我使用</em> <code class="du jk jl jm jn b"><em class="hi">String</em></code> <em class="hi">而不是</em> <code class="du jk jl jm jn b"><em class="hi">Class</em></code> <em class="hi">，我就不能同时存储它们。我只是忽略了这个问题，我不认为这是实践中会发生的事情。</em></p></blockquote></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="3454" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看看<code class="du jk jl jm jn b">java.lang.Enum</code>的缓存的JDK 5.0实现是有启发性的。这样的缓存不保存在<code class="du jk jl jm jn b">java.lang.Enum</code>对象内，而是保存在<code class="du jk jl jm jn b">enum</code>的<code class="du jk jl jm jn b">java.lang.Class</code>对象上。</p><p id="7011" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将缓存存储为<code class="du jk jl jm jn b">java.lang.Enum</code>内的<code class="du jk jl jm jn b">HashMap</code>将是错误的。<code class="du jk jl jm jn b">java.lang.Enum</code>由系统类加载器加载，直到JDK 9，理论上甚至不可能丢弃由它加载的类(JDK的模块化确实提供了这样的理论可能性，参见<a class="ae kb" rel="noopener" href="/swlh/java-platform-module-system-953cc88658fb"> <em class="jo"> Java平台模块系统</em> </a> <em class="jo">)。因此，如果某个应用程序<code class="du jk jl jm jn b">A.war</code>已经定义了某个<code class="du jk jl jm jn b">enum</code>，并且它的实例存储在由系统类加载器加载的<code class="du jk jl jm jn b">java.lang.Enum</code>对象中，我将始终拥有对该<code class="du jk jl jm jn b">enum</code>的强引用，并且它不能被丢弃。</em></p><p id="0e83" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，Sun选择了下面的方法:不将所有<code class="du jk jl jm jn b">enum</code>的缓存存储在<code class="du jk jl jm jn b">java.lang.Enum</code>对象中，而是将它们存储在……<code class="du jk jl jm jn b">java.lang.Class</code>中。<strong class="io hj">孙的修改实际上</strong> <code class="du jk jl jm jn b"><strong class="io hj">java.lang.Class. </strong>java.lang.Enum.valueOf(Class&lt;T&gt; enumType, String name)</code>实际上是从<code class="du jk jl jm jn b">Class&lt;T&gt; enumType</code>取回缓存。为了实现这一点，JDK 5' <code class="du jk jl jm jn b">enum</code> s被做成<em class="jo">实际上是不可扩展的——你只能在直接继承<code class="du jk jl jm jn b">java.lang.Enum</code>的类中定义<code class="du jk jl jm jn b">enum’s contant</code>。我将在下面回到这一点。</em></p><p id="d9b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当缓存存储在代表<code class="du jk jl jm jn b">enum</code>的<code class="du jk jl jm jn b"><strong class="io hj">java.lang.Class</strong></code> <strong class="io hj"> </strong>中，而不是存储在<code class="du jk jl jm jn b">java.lang.Enum,</code>中的一个位置时，这实际上使GC变得容易。因为<code class="du jk jl jm jn b">enum </code>实例和它的<code class="du jk jl jm jn b">java.lang.Class</code> <strong class="io hj"> </strong>保证由同一个类装入器装入，我们实际上是将<code class="du jk jl jm jn b">enum</code>的缓存存储在由同一个类装入器装入的对象中。所以，如果GC想要丢弃这个<code class="du jk jl jm jn b">enum </code>对象，它的<code class="du jk jl jm jn b">java.lang.Class </code> <strong class="io hj">里面的缓存<code class="du jk jl jm jn b">cache</code>的存在不会阻止垃圾收集。</strong></p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="5567" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">为什么内部缓存是</strong> <code class="du jk jl jm jn b"><strong class="io hj">HashMap </strong></code> <strong class="io hj">而不是</strong> <code class="du jk jl jm jn b"><strong class="io hj">ArrayList</strong></code> <strong class="io hj">？</strong></p><p id="5557" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是个有趣的问题。我选择<code class="du jk jl jm jn b"><strong class="io hj">HashMap</strong></code> <strong class="io hj"> </strong>而不是<code class="du jk jl jm jn b"><strong class="io hj">ArrayList</strong></code> <strong class="io hj"> </strong>的主要原因是性能考虑。我以为从<em class="jo">理论</em>的角度来看，查询<code class="du jk jl jm jn b"><strong class="io hj">HashMap</strong></code> <strong class="io hj"> </strong>，不迭代<code class="du jk jl jm jn b"><strong class="io hj">ArrayList</strong></code> <strong class="io hj">，会快很多。</strong></p><p id="f586" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">后来我做了一些测量，我发现<em class="jo">直到某个阈值，实际上迭代整个</em> <code class="du jk jl jm jn b"><em class="jo">ArrayList</em></code> <em class="jo"> / </em> <code class="du jk jl jm jn b"><em class="jo">array</em></code>比使用<code class="du jk jl jm jn b"><strong class="io hj">HashMap</strong></code> <strong class="io hj">花费的时间要少。</strong>非常有趣的是<code class="du jk jl jm jn b">java.util.EnumSet</code>使用阈值64来确定是否足够具有“常规”大小或“大”大小，因此将使用替代实现。</p><p id="a561" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jk jl jm jn b">java.lang.Enum.valueOf(Class&lt;T&gt; enumType, String name)</code>用途<code class="du jk jl jm jn b">HashMap</code>。</p><p id="ce62" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有趣的是<code class="du jk jl jm jn b">java.lang.Class</code>有3种不同风格的缓存:</p><ul class=""><li id="603d" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated"><em class="jo">包-私有</em>返回<code class="du jk jl jm jn b">HashMap</code>的<code class="du jk jl jm jn b">enumConstantDirectory()</code>。专门用于<code class="du jk jl jm jn b">java.lang.Enum.valueOf(Class&lt;T&gt; enumType, String name)</code>内部。它在第一次使用时被初始化<code class="du jk jl jm jn b">HashMap</code>(注意:它也是<code class="du jk jl jm jn b">volatile </code>(和<code class="du jk jl jm jn b">transient</code>——这个没那么有趣)。</li><li id="e0fd" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated"><em class="jo">包-私</em> <code class="du jk jl jm jn b">getEnumConstantsShared()</code>即返回<code class="du jk jl jm jn b">array</code>。这个方法使用一些巧妙的技巧来调用编译生成的<code class="du jk jl jm jn b">values()</code>方法，该方法原样返回enum常量的<code class="du jk jl jm jn b">array</code>。它在JDK被广泛使用。比如里面的<code class="du jk jl jm jn b">java.util.EnumMap</code>和<code class="du jk jl jm jn b">java.util.EnumSet</code>。(它使用一些助手类，允许另一个包中的类访问包私有方法)。它在第一次使用时被初始化<code class="du jk jl jm jn b">HashMap</code>(注意:它也是<code class="du jk jl jm jn b">volatile </code>(还有<code class="du jk jl jm jn b">transient</code>——这个没那么有趣)。</li><li id="8f9a" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated"><strong class="io hj"> <em class="jo">公有</em> </strong> <code class="du jk jl jm jn b">getEnumConstants() </code>的方法，对每一个叫<strong class="io hj">克隆体的</strong> <code class="du jk jl jm jn b">getEnumConstantsShared()</code>阵列。</li></ul><p id="a66f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们可以看到3种不同的使用模式。内部<code class="du jk jl jm jn b">java.lang.Enum.valueOf(Class&lt;T&gt; enumType, String name)</code>在第一次使用<code class="du jk jl jm jn b">HashMap.</code>时初始化，用于<strong class="io hj">公共</strong>使用，它返回<strong class="io hj">防御性复制</strong> <code class="du jk jl jm jn b">array,</code>，因此如果JDK之外的人想要实现缓存，预期的使用是<code class="du jk jl jm jn b">array</code>而不是<code class="du jk jl jm jn b">HashMap</code>(但同样，JDK本身更喜欢<code class="du jk jl jm jn b">HashMap</code>)。对于JDK <strong class="io hj">内部</strong>的使用，而不是<code class="du jk jl jm jn b">java.lang.Enum.valueOf(Class&lt;T&gt; enumType, String name)</code> JDK更喜欢使用<code class="du jk jl jm jn b">array</code>进行缓存。它绕过了制作防御性副本(我猜是因为性能原因)，但它仍然使用了<code class="du jk jl jm jn b">array</code>表示。</p><p id="0de4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，这里有一些歧义。我认为这真的取决于你如何使用缓存。如果你只需要找到正确的枚举常量(例如，通过名字)，那么使用<code class="du jk jl jm jn b">HashMap</code> <em class="jo">可能</em>是有意义的(同样，这实际上取决于你拥有的枚举常量的数量，如果你有，比方说，3个常量，那么使用<code class="du jk jl jm jn b">array</code>将会更快<em class="jo"/>)。但是如果你需要遍历所有的enum常量，例如在<code class="du jk jl jm jn b">EnumSet</code>的情况下，那么使用<code class="du jk jl jm jn b">array</code>作为缓存肯定更好。你会想要绕过防御副本。一种方法是对<code class="du jk jl jm jn b">java.lang.Class</code>的<strong class="io hj"> <em class="jo">公共</em> </strong> <code class="du jk jl jm jn b">getEnumConstants()</code>方法进行一次“昂贵的”调用，并将调用结果存储在某个数据字段中。当然，您应该考虑适当的<strong class="io hj">同步</strong>(至少，您应该将您的数据字段定义为<code class="du jk jl jm jn b">violatile</code>)。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="8a1e" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">展开性</h1><p id="167c" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">这其实很难。我先从实际的角度来描述这个问题。</p><p id="f9ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在一些基于SQL的数据库中有主表。它有一些属性，比如保存id的<em class="jo">Color</em>和指向至少有属性id和名称的颜色表(我称之为<em class="jo">查找</em>表)。因此，在我的表中，我的属性具有<em class="jo">颜色</em>，例如，值1，在颜色查找表中有id=1、name=white的行。</p><p id="9e78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我想在Java代码中表示<em class="jo">主</em>表。我可以使用一些ORM框架，或者依靠Spring Repository，或者实现我自己的DAL，这与本文的目的无关。我有哪些选项来建模<em class="jo">颜色</em>属性？</p><p id="146d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它可以是integer、java.lang.String或Enum。现在，你可以回到文章的开头来说服自己，通常情况下你会喜欢使用Enum。</p><blockquote class="jp jq jr"><p id="4ff4" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">旁注:<em class="hi">在我目前从事的项目中，我实际上选择了字符串。首先，我目前的项目是Python上的，不是Java上的。第二，我用的是Postgress。选择Postgress的原因之一是它支持数据库级别的Enum。在我的例子中，我根本没有</em>查找<em class="hi"> </em>颜色<em class="hi">表。相反，我有</em> maintable_colour <strong class="io hj">枚举类型。</strong> <em class="hi">我的主表有类型为</em> maintable_colour的属性 colour <em class="hi">。<em class="hi">当我对</em> colour <em class="hi">属性进行插入/更新或选择时，我只看到字符串(有时，我需要进行一些显式转换，例如，如果我想要枚举<em class="hi">的</em>数组的类型)。然而，在内部，每个枚举常量由4个字节表示(如Java中的</em> <code class="du jk jl jm jn b"><em class="hi">int </em></code> <em class="hi">)，这就好像postgresse使用了来自</em>typesafenum<em class="hi">的</em> <code class="du jk jl jm jn b"><em class="hi">value</em></code> <em class="hi">或来自</em> java.lang.Enum <em class="hi">的</em> <code class="du jk jl jm jn b"><em class="hi">ordinal </em></code> <em class="hi">以及从</em> <code class="du jk jl jm jn b"><em class="hi">int</em></code> <em class="hi">到特定于postgresse的字符串的一些转换逻辑，但在概念上与在</em>typesafenum<em class="hi">或</em>中相同</em></p><p id="f0c9" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">我使用String的原因:</em>在后端，我没有使用enum<em class="hi">的任何操作。实际上，我正在获取数据(解析为java.lang.String ),并将enum constrant原样传输到DB。它保持不变，成为我用来与数据库交互的库(它实际上理解数据库级别的Enum，并对它进行一些操作，如添加显式强制转换；在大多数情况下，这些操作对代码是完全透明的)。因此，从后端的角度来看，它接收字符串并将字符串发送到数据库。一切都是可读可贬的。主表和</em>查询<em class="hi">表之间没有额外的查询调用或连接。在DB存储级别，该字符串被转换为4个字节，因此是高效的。</em></p><p id="1685" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">当然，如果将要存储在数据库中的字符串不代表某个枚举常量，将抛出验证异常以保持数据的一致性。</em></p><p id="caba" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">有关更多信息，请参见</em>您会在SQL中使用ENUM做什么？<a class="ae kb" href="https://dba.stackexchange.com/questions/231795/what-would-you-use-enum-for-in-sql" rel="noopener ugc nofollow" target="_blank">https://DBA . stack exchange . com/questions/231795/what-you-use-enum-for-in-SQL</a><em class="hi">和</em>枚举类型<a class="ae kb" href="https://www.postgresql.org/docs/13/datatype-enum.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/13/datatype-enum.html</a></p></blockquote><p id="e516" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，如果您想用Java对主表的c <em class="jo"> olour </em>属性建模，选择java.lang.Enum是很自然的(如果您的DAL支持Enum，这在很长一段时间内都不是问题)。标准的做法是在编译时创建enum并复制lookup <em class="jo"> Colour </em>表的内容。</p><p id="542f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果数据是静态的，这是足够好的解决方案。但是如果表<em class="jo">的内容是动态的</em>或者在编写代码的时候是未知的呢？</p><p id="0da3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我说的<em class="jo">动态</em>内容是什么意思？如果我们回到我们的例子，如果我们的系统支持的<em class="jo">颜色</em>可能会随着时间而改变。在这种情况下，最好用不同的表来建模。</p><p id="8e24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我说的内容不明是什么意思？嗯，我的意思是，我们有一些通用代码，可以用于不同的特定表格。它不是任何表，它应该是满足某些特定约束的表。<em class="jo">颜色</em>本身可以有不同的支持值集，但它可以因实例而异。在这种情况下，对于每个特定的<em class="jo">实例</em>，我们有<em class="jo">静态</em>内容，但是与特定的<em class="jo">实例一起工作的(通用)代码(</em>特定的main+查找表)不知道内容。</p><p id="34b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面描述的场景不是理论上的，因为它，我实际上实现了我自己的enum实现。</p><p id="b7e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在这种情况下，我不能在编译时“仅仅”创建enum。我想做的是在代码级别有一些类型安全的类型，它们将被转换成DB级别的<code class="du jk jl jm jn b">int</code>。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="8925" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">关注<code class="du jk jl jm jn b">java.lang.Enum,</code>很有趣，它支持这样的用例吗？</h1><p id="a669" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">引用:</p><blockquote class="jp jq jr"><p id="7b1f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">枚举声明是隐式的</em> <code class="du jk jl jm jn b"><em class="hi">final</em></code> <em class="hi">，除非它包含至少一个具有类体的枚举常量……</em></p><p id="c8da" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">枚举类型E的直接超类是</em><code class="du jk jl jm jn b"><em class="hi">Enum&lt;</em></code><em class="hi">E</em><code class="du jk jl jm jn b"><em class="hi">&gt;</em></code><em class="hi">…</em></p><p id="d31f" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">除了由枚举常量定义的实例之外，枚举类型没有其他实例...</em></p></blockquote><p id="1a32" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/jls/se8/html/jls-8 . html # jls-8.9</a></p><p id="b72b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所见，<code class="du jk jl jm jn b">java.lang.Enum</code>是<em class="jo">几乎是</em>最终。你可以声明<code class="du jk jl jm jn b">YourEnum </code>来扩展<code class="du jk jl jm jn b">java.lang.Enum.</code><em class="jo">枚举常量</em>可以有类体，但是<strong class="io hj">明确禁止添加新的<em class="jo">枚举常量</em>，除了那些在<code class="du jk jl jm jn b">YourEnum</code>中编译时</strong>定义的。</p><p id="f5b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">什么是具有类体的<em class="jo">枚举常量，总之<em class="jo">？</em>让我们看看代码示例:</em></p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="7419" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/enums . html</a></p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="b309" class="lx kd hi jn b fi ly lz l ma mb">{ double eval(double x, double y) { return x + y; } },</span></pre><p id="41da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是具有类体的<em class="jo">枚举常量、</em>即PLUS的示例(见上文)。</p><p id="3fe4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从概念上讲，它等效于以下代码:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="3e40" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/enums . html</a></p><p id="b569" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jo">注:</em> </strong></p><ul class=""><li id="e7c9" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">你可以认为对于每个常数，我们都可以重写一些方法。另一种思考方式是，这个“扩展枚举”有一些带有内部<em class="jo">分派</em>机制的方法，如上所述。如果它类似于<em class="jo">密封类</em>用法(分离联合)，这是正确的，但我们现在不会朝这个方向走。</li><li id="be52" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">引用上面的链接:</li></ul><blockquote class="jp jq jr"><p id="0e5e" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated">这工作得很好，但是如果没有throw语句就无法编译，这不是很好。更糟糕的是，每次向Operation添加一个新的常量时，都必须记住向switch语句添加一个新的case。如果您忘记了，eval方法会失败，执行前面提到的throw语句。</p></blockquote><p id="87c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于<code class="du jk jl jm jn b">AssertionError </code>为什么被抛出，参见<a class="ae kb" href="https://alex-ber.medium.com/java-exception-hierarchy-f6aef08ab9b" rel="noopener">https://Alex-ber . medium . com/Java-exception-hierarchy-f 6 AEF 08 ab 9b</a>。</p><ul class=""><li id="9237" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">有趣的是，在JDK 5.0中添加enum时，为了避免使用“打开enum”，添加了具有类主体的Enum常量<em class="jo">。如果你仔细看这个，这个<strong class="io hj"> <em class="jo">模式匹配</em> </strong>的例子。足够有趣的是，JDK 14引入了一种有限形式的<a class="ae kb" href="https://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank">模式匹配</a>，所以，本质上现在承认使用开关是首选方式，而整个<em class="jo">枚举常数有一个类体</em>是错误的。</em></li><li id="73f9" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">我想再重复一遍，当JDK 5.0发布时，使用了具有类主体的<em class="jo">枚举常量</em>优先于我们的枚举切换(这是<a class="ae kb" href="https://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank">模式匹配</a>的形式)。从JDK 14开始，Java开始支持<em class="jo"> Sum和product类型</em>(这些是函数式编程中的概念，我将单独写一篇关于它们的大文章)。这里我只想提一下，这个拥有类体的<em class="jo">枚举常量是一个abundon。同样，它向您展示了使用<em class="jo">继承</em>机制来实现<em class="jo"> disjouint联合</em>是一条错误道路。</em></li></ul></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="e74e" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated"><em class="nd">具有类体的枚举常量</em></h1><p id="17bc" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">我还想提一下，拥有类主体的<em class="jo">枚举常量是对<em class="jo">枚举可以拥有数据和行为</em>这一概念的某种概括。</em></p><blockquote class="jp jq jr"><p id="56cc" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">例如考虑太阳系的行星。每个行星都知道它的质量和半径，可以计算出它的表面重力和行星上一个物体的重量。下面是它的样子:</em></p></blockquote><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="b7cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/enums . html</a></p><blockquote class="jp jq jr"><p id="4c9b" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">枚举类型</em></p></blockquote></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="b05c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">策略和访客模式</strong></p><p id="0ffb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以放心地跳过这一步。</p><p id="0121" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果为了计算<em class="jo"> surfaceGravity() </em>或<em class="jo"> surfaceWeight() </em>你没有一个通用的公式，你需要做一些不同的<em class="jo">计算</em>，这取决于你使用的是什么类型的平面。如果，你有<em class="jo">黑洞</em>作为行星，那么对于黑洞的表面引力对于(C=299_792_458米每秒——真空中的光速)质量M的史瓦西解是C * C * C * C/4 * G *质量。如何为每个枚举常量重写<em class="jo"> surfaceGravity() </em>方法？</p><p id="b212" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，这是<em class="jo">枚举常量的例子，</em>即有类体的，见上面<em class="jo">枚举操作</em>的例子。在这种情况下，定义如下:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="422b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其中地球黑洞是一个假想的天体，质量相当于地球的黑洞。</p><p id="5b26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果在编写枚举时，我们不知道所提供的枚举方法(如<em class="jo"> surfaceGravity() </em>)的确切<em class="jo">行为</em>该怎么办？如果我们想<em class="jo">从我们提供的操作中分离出</em>我们的枚举，该怎么办？在上面的例子中，如果enum表示操作的<em class="jo">节点(</em>加、减等)，我们可能希望在不同的类中提供<em class="jo">评估</em>逻辑。</p><p id="9c25" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我们想让我们的枚举保持原样，我们想将<em class="jo">行为</em>提取到不同的类中。这就是所谓的<strong class="io hj">策略</strong>设计模式。</p><p id="3cac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jo">下面的代码是基于</em><a class="ae kb" href="https://www.baeldung.com/a-guide-to-java-enums" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://www.baeldung.com/a-guide-to-java-enums</em></a></p><p id="a397" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设我们有一些披萨类，看起来像这样:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="952e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以有单独的<strong class="io hj"> <em class="jo">披萨配送策略</em> </strong>:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="7520" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">客户端代码可能看起来像这样:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="b194" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本质的过去是<strong class="io hj"> <em class="jo">交付策略。</em> </strong>本质上，它是<a class="ae kb" href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" rel="noopener ugc nofollow" target="_blank">function intefrace</a>——它只有一个非抽象方法(用OO术语定义了<em class="jo">行为</em>)。我们有一些“概念”，它“知道”如何交付东西(在我们的例子中，它是Pizza，它实际上是由Pizza参数化的)，我们有2个实现实现了这个“概念”，它们的<em class="jo">类型</em>是enum<em class="jo">PizzaDeliveryStrategy</em><em class="jo">的一些<strong class="io hj">扩展，</strong></em>第一个实现存储在<em class="jo"> PizzaDeliveryStrategy中。普通</em>和<em class="jo">披萨配送策略。快递</em>。我想重新迭代一下，我们有<em class="jo"> enum常量PizzaDeliveryStrategy。NORMAL有一个类体，</em>我们有<em class="jo">枚举常量PizzaDeliveryStrategy。EXPRESS有一个类体，</em>两个类实际上都实现了<em class="jo">delivery strategy&lt;Pizza&gt;。</em></p><p id="6691" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，如果你想也能提供可口可乐，你应该创造</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="9e37" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，如果你真的有多个产品要交付，你会注意到很多代码实际上是重复的。您可能还会注意到，您实际上有两种不同的、但是非常接近的方法<em class="jo">delivery(可交付)</em>和<em class="jo">delivery()。</em></p><p id="0359" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以使用<strong class="io hj"> Visitor </strong>设计模式来解决这个问题。你可以想你想实现的<em class="jo">双调度</em>方法</p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="e547" class="lx kd hi jn b fi ly lz l ma mb"><em class="jo">public &lt;T extends Deliverable&gt; deliver(T, DeliveryStrategy&lt;T&gt;)</em></span></pre><p id="b346" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当<em class="jo"> DeliveryStrategy </em>实现是具有类体的<em class="jo">枚举常量时。</em></p><p id="d25a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jo">边注:</em>实际上，在我的一个项目中，我已经用enum原型化了<strong class="io hj"> Visitor </strong>设计模式的这种用法，但是它太复杂了，所以它首先被简化为<strong class="io hj">策略</strong>，当新的“Pizza”被添加时，它被完全从原型中移除，我只是在enum上有一些开关，作为私有方法，在需要时被调用。我对此感觉很糟糕(嘿，我打破了封装)，但我对自己说，我真的试图用正确的方式来做，但它太复杂了。<strong class="io hj"> <em class="jo">密封类</em> </strong>(在JDK 15) <em class="jo"> </em>就是为了感受这种差距而设计的。我会就此写单独的文章。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="780c" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">我的类型安全可扩展枚举实现</h1><p id="a30e" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">让我们回到我自己的enum实现。我提醒你我在不支持枚举的JDK 1.4上做的，所以我用<code class="du jk jl jm jn b">public static final</code>变量代替枚举常量。我的实现也是类型安全的。它非常接近JDK 1.5 enum，有两个显著的区别。我没有改变编译器或<code class="du jk jl jm jn b">java.lang.Class</code>，所以“枚举缓存”保存在我的基本枚举类中，我用<code class="du jk jl jm jn b">public static final</code>变量代替枚举常量，我的枚举是<strong class="io hj"> <em class="jo">可扩展的</em> </strong>。</p><p id="00b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们看到的，我们不能使用标准的<code class="du jk jl jm jn b">java.lang.Enum</code>在代码级别拥有一些类型安全的类型，这些类型将被转换成DB级别的<code class="du jk jl jm jn b">int</code>。虽然它可以被扩展(以非常有限的方式),但是你不能在运行时动态地添加枚举常量<em class="jo">。有趣的是，在JDK，15个“密封类”是和现有的enum一起添加的，因为它太有限了。不采取的方法实际上是将enum转换为“密封类”。当enum在JDK 1.5中被添加时，没有人认为enum是“和类型”(在范畴理论的意义上)，“密封类”是这种“和类型”的Java受限版本。正如我上面所说的，我会写一个单独的故事。</em></p><p id="3caa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，我是如何设法在代码级别拥有一些类型安全的类型，并在DB级别转换成<code class="du jk jl jm jn b">int</code>的呢？</p><p id="6893" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想更精确一点。在我的用例中，我有一些<em class="jo">枚举常量</em>，它们应该是每种用法通用的。每个(代码)用户可以根据自己的意愿添加一些新的<em class="jo">枚举常量</em>。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="f053" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我有一些<em class="jo"> BaseEnum </em>，它是我的<em class="jo"> TypeSafeEnum的变体。它有一些编译时的枚举常量。</em>它还有<code class="du jk jl jm jn b">protected addEnum()</code>的方法。</p><p id="8eec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个(代码)用户都定义了自己的enum，它扩展了<em class="jo"> BaseEnum。</em>在我的例子中，每个war类加载器有一个用户的enum——也就是说，我有不同的<code class="du jk jl jm jn b">war </code>应用程序，每个应用程序都有自己的enum版本，所以它在用户的enum之间提供了很好的隔离。根据Web服务器的配置，隔离可能会有所不同。</p><p id="1ebf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实际上，我最初的架构是多个<code class="du jk jl jm jn b">war</code>，每个都有自己的“枚举”(扩展<em class="jo"> BaseEnum </em>的类)。<code class="du jk jl jm jn b">BaseEnum</code>本身在<code class="du jk jl jm jn b">jar</code>文件中，已经被<strong class="io hj">复制</strong>到各个<code class="du jk jl jm jn b">war</code>文件中。因此，我有多个由不同的(<code class="du jk jl jm jn b">war</code>)类加载器加载的<code class="du jk jl jm jn b">BaseEnum </code>类。因此，每个实际的枚举都存储在不同的<code class="du jk jl jm jn b">BaseEnum</code>副本中。隔离是完美的，但是我们的内存利用率很低。</p><p id="5677" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们改变了生产中的架构，使1个<code class="du jk jl jm jn b">war</code>文件与不同的应用程序兼容，因为<code class="du jk jl jm jn b">jar,</code>和<code class="du jk jl jm jn b">BaseEnum</code>也打包在不同的<code class="du jk jl jm jn b">jar</code>文件中。现在，我们只有1个<code class="du jk jl jm jn b">BaseEnum</code>副本，所以内存利用率好很多。让事情运转起来要困难得多，因为现在隔离非常糟糕，一个“应用程序”看到另一个“应用程序”的代码。应注意配置文件，如<code class="du jk jl jm jn b">log4j.xml, </code>等。与我们相关的是，现在来自不同应用程序的所有枚举都存储在对每个“应用程序”可见的同一个类<code class="du jk jl jm jn b">BaseEnum</code>(<code class="du jk jl jm jn b">jar</code>class loader)中。回想一下，枚举缓存是以这样一种方式组织的，即枚举常量按它们的定义类分组在一起。然而，从理论上讲，访问另一个“应用程序”的枚举是可能的(因为，我们使用<code class="du jk jl jm jn b">jar</code>而不是<code class="du jk jl jm jn b">war</code> classloader)，所以从理论上讲，我可以从另一个应用程序加载类，并从缓存中访问它的枚举常量。</p><p id="64dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，每个“实际枚举”都扩展了<em class="jo"> BaseEnum </em>并具有<code class="du jk jl jm jn b">public static final</code>变量而不是枚举常量。每个枚举常量都有代表DB中的<code class="du jk jl jm jn b">int</code>值的<code class="du jk jl jm jn b">int</code>数据成员(我没有依赖我已经明确定义的<code class="du jk jl jm jn b">ordinal,</code>值)。在代码本身中，我可以写类似于<em class="jo"> MyEnum的东西。FIRST.db_value </em>将枚举转换为db中的<code class="du jk jl jm jn b">int </code>值。我还有一些静态方法<code class="du jk jl jm jn b"><em class="jo">getEnumByDBValue()</em></code>，它将DB中的<code class="du jk jl jm jn b">int</code>值转换为<code class="du jk jl jm jn b">enum </code>(我最初的实现为此使用了额外的<code class="du jk jl jm jn b">HashMap </code>，后来我发布了这样的消息:只需检查最初的缓存<code class="du jk jl jm jn b">HashMap </code>并找到这样的枚举，效率会更高)。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="3119" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">可能根本没有定义枚举常量。</strong>你可以调用数据库中的一些表来保存你所有的枚举常量，它们的名字，序号和数据库值。现在，你可以用从数据库中获取的数据用<code class="du jk jl jm jn b">YourEnum</code>来扩展<em class="jo"> BaseEnum </em>和<em class="jo"> </em>来调用<code class="du jk jl jm jn b">addEnum()</code>方法。你只需要知道<em class="jo">你的应用程序的初始化顺序，</em>你不应该使用<code class="du jk jl jm jn b">YourEnum</code>直到调用<code class="du jk jl jm jn b">addEnum()</code>完成。令我惊讶的是，这实际上没有任何问题。</p><p id="c00a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在使用enum的代码中，我不能使用switch。回想一下，这些开关不仅使用编译时常量，而且我枚举不是编译时常量，实际上我有意动态添加了枚举常量。所以，我必须使用<code class="du jk jl jm jn b">if-else</code>构造。假如没有内置支持<code class="du jk jl jm jn b">enum</code> back than，完全没问题。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="fd0e" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">开关和枚举</h1><p id="692b" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">在JDK 1.4中，当定义switch语句的情况时，我们需要遵守Java语言规范中定义的规则:</p><ul class=""><li id="1c86" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">switch语句要求值的case标签是<em class="jo">常量表达式。</em></li><li id="1a5f" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">与switch语句关联的case常量表达式中不能有两个具有相同的值。</li></ul><p id="f01b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">举个例子，</p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="f1f5" class="lx kd hi jn b fi ly lz l ma mb">public static final int MAXIMUM_NUMBER_OF_USERS = 10;</span></pre><p id="345f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">原始类型的所有类常量也是编译时常量。<em class="jo">字符串</em>是一个特例，将在下面讨论。Java编译器能够在代码编译期间<strong class="io hj"> <em class="jo"> </em> </strong> <em class="jo">计算包含常量变量和某些运算符的表达式:</em></p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="a629" class="lx kd hi jn b fi ly lz l ma mb">public static final int MAXIMUM_NUMBER_OF_GUESTS = MAXIMUM_NUMBER_OF_USERS * 10;<br/>//public String errorMessage = ClassConstants.DEFAULT_USERNAME + " not allowed here.";</span></pre><p id="db6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像这样的表达式被称为<em class="jo">常量表达式</em>，因为编译器会计算它们并生成一个编译时常量。</p><p id="486f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果Java变量是基元类型的<em class="jo">,声明为final，在其声明中初始化，并带有常量表达式，那么它就是编译时常量。字符串</em>是一个特例，将在下面讨论。</p><p id="fdc4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">术语<em class="jo">编译时常量</em>包括类常量，但也包括使用常量表达式定义的实例和局部变量。</p><p id="f549" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并非所有的<em class="jo">静态</em>和<em class="jo">最终</em>变量都是常量。如果一个物体的状态可以改变，它就不是一个常数:</p><pre class="jv jw jx jy fd lt jn lu lv aw lw bi"><span id="6ebb" class="lx kd hi jn b fi ly lz l ma mb">public static final Logger log = LoggerFactory.getLogger(ClassConstants.class);<br/>public static final List&lt;String&gt; contributorGroups = Arrays.asList("contributor", "author");</span></pre><p id="e6c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然这些是常量引用，但它们引用的是可变对象。</p><p id="0aeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我的enum实现，像上面的<em class="jo"> TypeSafeEnum </em>不是编译时常量，因此至少在JDK 1.4中不能在switch中使用。</p><p id="43b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，Java的JDK 5.0 enum怎么样呢？它是否适合在交换机中使用？</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="d7c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了支持这一点，switch语句的要求被更改了。此外，对<code class="du jk jl jm jn b">java.lang.Enum</code>施加了限制。引用:</p><blockquote class="jp jq jr"><p id="8425" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">枚举声明是隐式的</em> <code class="du jk jl jm jn b"><em class="hi">final</em></code> <em class="hi">，除非它包含至少一个具有类体的枚举常量(</em><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.1" rel="noopener ugc nofollow" target="_blank"><em class="hi">8 . 9 . 1</em></a><em class="hi">)。</em></p><p id="6509" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><em class="hi">如果同一个关键字作为枚举声明的修饰符</em>  <em class="hi">出现不止一次，则为</em> <strong class="io hj"> <em class="hi">编译时错误… </em></strong></p><p id="28a4" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><strong class="io hj"> <em class="hi">除了由枚举常量定义的实例之外，枚举类型没有其他实例。</em> </strong> <em class="hi">试图显式实例化枚举类型是一个编译时错误(</em><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.9.1" rel="noopener ugc nofollow" target="_blank"><em class="hi">15 . 9 . 1</em></a><em class="hi">)。</em></p></blockquote><p id="8910" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/jls/se8/html/jls-8 . html # jls-8.9</a></p><p id="5afc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这使得对开关的要求可以更改如下:</p><p id="de93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在定义switch语句的情况时，我们需要遵守Java语言规范中定义的规则:</p><ul class=""><li id="759e" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated"><em class="jo">switch语句的case标签需要常量表达式</em>或<strong class="io hj"> <em class="jo">枚举常量</em> </strong>的值。</li><li id="eb32" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">与switch语句关联的case常量表达式中不能有两个具有相同的值。</li></ul><p id="9bfa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在JDK实现端，一些<em class="jo">去串行化</em>过程由编译器完成，用它的<em class="jo">序号</em>替换枚举常量，然后打开<code class="du jk jl jm jn b">int. </code>开关，因此，Java编译器再次被更改为支持打开枚举。示例:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="82ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://alvinalexander.com/java/using-java-enum-switch-tutorial/" rel="noopener ugc nofollow" target="_blank">https://alvinalexander . com/Java/using-Java-enum-switch-tutorial/</a></p><p id="b5ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为，由于<code class="du jk jl jm jn b">java.lang.Enum </code>(见上)的限制，编译器可以用<code class="du jk jl jm jn b">case 1</code>代替<code class="du jk jl jm jn b">case MONDAY</code>，用<code class="du jk jl jm jn b">case 2</code>代替<code class="du jk jl jm jn b">case TUESDAY </code>，...、<code class="du jk jl jm jn b">case SUNDAY </code>与<code class="du jk jl jm jn b">case 7. </code>一起还可以“破坏”<code class="du jk jl jm jn b">swith(theDay)</code>到<code class="du jk jl jm jn b">switch(theDay.ordinal)</code>，因此将执行<code class="du jk jl jm jn b">int</code>上的实际开关。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="b8a0" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">打开绳子怎么样？</h1><p id="887a" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">好吧，在这里我们可以在我们的故事中有些转折。从技术上讲，常量表达式可以包含字符串。<strong class="io hj"> <em class="jo">字符串</em> </strong>是原始类型之上的一个特例，因为它们<strong class="io hj">是不可变的，并且存在于<em class="jo">字符串</em>池中。</strong>因此，应用程序中运行的所有类都可以共享<em class="jo">字符串</em>值。</p><p id="13e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管如此，在JDK 1.7版本之前，打开琴弦是被禁止的。实际上，如果我们有enum的“去糖化”过程，在JDK内部实现这个特性的努力是非常小的。需要一种新的“脱糖”，但基本上就是这样。</p><p id="77d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">许多人想拥有switch on String，并等待这一特性，但当它真正发布时，大部分都没有被注意到。为什么？嗯，因为你可以用<em class="jo">打开枚举</em>来模仿<em class="jo">打开串</em>。</p><p id="55cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，假设你想打开字母“A”，“B”，“C”，而你用的是JDK 6.0。所以，你可以这样写:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="0ddf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jo">旁注:</em>我写过很多这样的代码。更有甚者，我只写了几个开关。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="839c" class="kc kd hi bd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz bi translated">java.lang.Enum动态枚举？</h1><p id="d51b" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">2014年，我有一些小项目要做。那是在微服务时代之前，所以我有1个共享数据库和一堆web服务。我想实现一些锁定机制来防止同时运行一些Web服务。所以，本质上我在数据库中有一些锁表，本质上有Web服务列表。你可以在这里阅读详情<a class="ae kb" href="https://alex-ber.medium.com/lock-high-level-design-3e02bbb8eb7f" rel="noopener">锁高层设计</a>。</p><p id="8f38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，我可以在代码中将Lock表示为enum吗？</p><p id="d1d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，网络服务列表是<em class="jo">半静态</em>。它不是完全静态的，它可能会随着时间的推移而变化，但这种变化发生得非常缓慢——您不会每周都添加Web服务(再次强调，它不是微服务，它是完整的Web服务)。</p><p id="0a0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">引用:</p><blockquote class="jp jq jr"><p id="6655" class="im in jo io b ip iq ir is it iu iv iw js iy iz ja jt jc jd je ju jg jh ji jj hb bi translated"><strong class="io hj">注2021: <em class="hi"> </em> </strong> <em class="hi">我们希望能够动态地向系统添加web服务和锁。所以，Lock可以是Java的包含所有锁的</em> <code class="du jk jl jm jn b"><em class="hi">enum</em></code> <em class="hi">类。<br/>我做了</em> <a class="ae kb" href="https://gist.github.com/alex-ber/ee6cc2ba941771c01235d644a52e7a4c" rel="noopener ugc nofollow" target="_blank"> <em class="hi">原型</em> </a> <em class="hi">一些动态添加实例到</em> <code class="du jk jl jm jn b"><em class="hi">enum,</em></code> <em class="hi">的解决方案，但它只是一个大的黑客，可以在小的JDK更新上收支平衡。</em> <a class="ae kb" href="https://mreinhold.org/blog/jigsaw-phase-two" rel="noopener ugc nofollow" target="_blank"> <em class="hi">项目拼图</em> </a> <em class="hi">是</em> <a class="ae kb" href="http://openjdk.java.net/projects/jigsaw/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">即将在JDK上市9 </em> </a> <em class="hi">，所以我很清楚，这种黑客行为造成了重大的技术债务。</em></p></blockquote><p id="bd53" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kb" href="https://alex-ber.medium.com/lock-high-level-design-3e02bbb8eb7f" rel="noopener">https://Alex-ber . medium . com/lock-high-level-design-3e 02 BBB 8 EB 7 f</a></p><p id="680c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，虽然从技术上讲我们可以打破Java的枚举不可扩展性(同样，这是在<strong class="io hj">和</strong>中完成的，见上文)，但我宁愿避免这种情况。</p><p id="67c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jo">密封类</em> </strong>(在JDK 15)将是最后一个用例更好的解决方案。</p></div></div>    
</body>
</html>
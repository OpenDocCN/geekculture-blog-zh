<html>
<head>
<title>What is the distinction between TLSv1.2 and TLSv1.3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TLSv1.2和TLSv1.3有什么区别？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-the-distinction-between-tlsv1-2-and-tlsv1-3-fcc5c00f635b?source=collection_archive---------10-----------------------#2022-04-03">https://medium.com/geekculture/what-is-the-distinction-between-tlsv1-2-and-tlsv1-3-fcc5c00f635b?source=collection_archive---------10-----------------------#2022-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6d41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在浏览网站时，我们都见过浏览器中URL前面的填充锁图标。你有没有想过它为什么会在那里？这是什么意思？我们知道，通过web发送的数据是加密的，因此它可以提供数据的机密性(只有目标方可以读取数据，任何窥探方都不能看到数据)和完整性(接收方收到的数据应该与发送方发送的数据相同)。在上一篇文章中，我讨论了RSA和Diffie-hellman密钥交换算法，该算法描述了发送方和接收方如何共享密钥来执行加密和解密。但是这一切是如何在网络上与传输协议协同工作的呢？</p><p id="7b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将讨论什么是TLS，它是如何工作的，TLSv1.2和TLSv1.3有什么区别？在传输层，我们需要确保数据的机密性、身份验证和完整性。为了确保这些目标，TLS于1999年问世。TLS代表传输层安全，因此它工作在TCP协议之上。TCP连接建立后，发生TLS握手，基本上，TLS握手是一个<strong class="ih hj"> <em class="jd">选择密码组</em> </strong>(加密算法)<strong class="ih hj"> <em class="jd">密钥交换算法、</em> </strong>在发送方和接收方之间共享密钥，以及<strong class="ih hj"> <em class="jd">认证预期发送方和接收方</em> </strong>的过程。这里我们将讨论TLSv1.2和TLSv1.3。这些是目前使用的TLS协议，由于其缺点，TLSv1.3很快将取代TLSv1.2。</p><p id="b56a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">T13】tlsv 1.2T15】</strong></p><p id="08a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TLSv1.2握手中，客户端首先与服务器建立TCP连接，该客户端向服务器发送hello数据包以及密码套件(客户端浏览器支持的加密算法)，然后服务器向客户端发送hello数据包及其证书，该证书有助于服务器的身份验证，并同意客户端支持的任何一个密码套件(这需要1 RTT)。从服务器收到这个hello数据包后，客户端使用RSA或Diffie-Hellman密钥交换算法来共享密钥(这需要1RTT)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/aaccf16fb3e661c6bdca215d5cd038ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*pHvOCaSEg0AWvURB-YhjIw.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">TLSv1.2 handshake( <a class="ae jq" href="https://www.paolotagliaferri.com/cdn-cgi/image/format=auto,metadata=copyright,quality=85,scale-down,width=1000/https://www.paolotagliaferri.com/content/images/2020/03/Full_TLS_1.2_Handshake.svg.png" rel="noopener ugc nofollow" target="_blank">picture source</a>)</figcaption></figure><p id="20b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TLSv1.2中，握手需要2 RTT。以下是TLSv1.2用于以下任务的算法:</p><ul class=""><li id="690f" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><strong class="ih hj">对于密钥交换:使用ECDHE( </strong>短暂椭圆曲线Diffie Hellman算法)，也使用RSA。</li><li id="3bc8" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj">认证:ECDSA( </strong>椭圆曲线数字签名算法)</li><li id="8bff" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj">数据加密</strong>:伽罗瓦计数器模式下的高级加密标准，使用128位密钥。</li><li id="b5fa" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj">对于</strong> ( <em class="jd"> PRF </em> / <em class="jd">数据完整性</em> ): <strong class="ih hj"> SHA256，</strong>安全哈希算法，256位摘要。</li></ul><p id="6a7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> TLSv1.2缺点:</em> </strong></p><p id="6f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">握手需要2 RTT时间。它支持数十种可用的密码套件组合，这可能导致服务器和客户端可能不同意相同的密码套件，从而导致几个RTT的浪费。TLSv1.2配置包括4种不同的算法(一种用于密钥交换，第二种用于认证，第三种用于加密，最后一种用于完整性检查)，这使得其配置很复杂。在TLSv1.2中，某些算法(如Diffie-hellman密钥交换算法)的参数选择留给了客户端，这可能会导致弱密钥设置，从而导致安全问题。</p><p id="7f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> TLSv1.3 </strong></p><p id="3710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决TLSv1.2的缺点，TLSv1.3于2018年问世。I <strong class="ih hj"> <em class="jd"> n TLSv1.3握手只需要1RTT。</em> </strong>在TLSv1.3中，删除了围绕认证和密钥交换算法的选择。也不再选择RSA作为密钥交换算法。在握手中，当客户端发送hello数据包时，它也发送了密钥交换算法的密钥共享参数，因为现在客户端可以乐观地猜测哪个密码适合服务器将要同意的密码，因为可能的密码套件的可变性较小。作为响应，服务器发送hello数据包及其证书、选择的密码套件和密钥共享参数。从服务器收到hello数据包及其密钥共享部分后，客户端生成密钥并开始传输数据。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kf"><img src="../Images/6098efad18e4c9129e035947c3f112a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*zfHMG8kWwk6G2CuvXeDF0g.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">TLSv1.3 Handshake <a class="ae jq" href="https://www.paolotagliaferri.com/cdn-cgi/image/format=auto,metadata=copyright,quality=85,scale-down,width=1000/https://www.paolotagliaferri.com/content/images/2020/03/Full_TLS_1.3_Handshake.svg.png" rel="noopener ugc nofollow" target="_blank">(picture source</a>)</figcaption></figure><p id="b1f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TLS v1.3中，为了简化和避免错误配置，密码套件仅指定了两种算法:</p><ul class=""><li id="5429" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><strong class="ih hj">用于数据加密</strong>:伽罗瓦计数器模式下的高级加密标准，使用256位密钥。</li><li id="9528" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj"> For ( <em class="jd"> PRF </em> / <em class="jd">数据完整性</em> ) </strong> : SHA384 <strong class="ih hj">，</strong>安全哈希算法，384位摘要。</li></ul><p id="3ae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在TLS 1.3中，有三个认证选项:</strong></p><ul class=""><li id="fab3" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><strong class="ih hj"> RSA: </strong>仅用于签名，不用于密钥交换。</li><li id="e9a3" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj"> ECDSA: </strong>椭圆曲线数字签名算法</li><li id="0bb2" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><strong class="ih hj"> EdDSA </strong>:爱德华兹曲线数字签名算法</li></ul><p id="e964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为根据设计，服务器可以在TLS 1.3握手中更早地开始加密数据，所以它可以对整个握手序列进行签名(使用其私钥)，并将其包含在发送给客户端的响应中。然后，客户端可以使用服务器的公钥验证签名是否有效，这证明它拥有私钥。</p><h2 id="bc7e" class="kg kh hi bd ki kj kk kl km kn ko kp kq iq kr ks kt iu ku kv kw iy kx ky kz la bi translated">TLS 1.3密钥交换</h2><p id="99c9" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">正如我们上面所讨论的，客户机“猜测”服务器支持什么，并在初始消息中将它的一半和Diffie-Hellman参数发送给服务器。</p></div></div>    
</body>
</html>
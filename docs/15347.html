<html>
<head>
<title>The Only Univariate Prediction Function You’ll Ever Need?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要的唯一一个单变量预测函数？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-only-prediction-function-youll-ever-need-fe2ae42eaff0?source=collection_archive---------3-----------------------#2022-10-27">https://medium.com/geekculture/the-only-prediction-function-youll-ever-need-fe2ae42eaff0?source=collection_archive---------3-----------------------#2022-10-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="174f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果采用性能最好的开源单变量时间序列预测算法，并通过运行性能对它们进行加权，会发生什么？如果这个列表是在运行时构建的，并且随着新方法在Python生态系统中的发布，候选方法变得越来越强，那么您可能永远不需要修改代码。</p><p id="6236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个<a class="ae jd" href="https://github.com/microprediction/timeseries-notebooks/blob/main/forever_hello.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>说明使用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/58e1916541233ca8811ddee866244506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_XxgT_szD973V-gGXkwsA.png"/></div></div></figure><p id="0ee5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将预测函数永远称为<strong class="ih hj"/>，因为它会随着时间的推移自动变得更好。在这里，我将快速浏览一下用法，然后讨论未来可能的方向。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jq"><img src="../Images/42bae40da6f57007b941ad5bdf97354e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCtGH-C3ZxxpqUZ2-srWcg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx">Importing the “forever” function from the timemachines package</figcaption></figure><p id="27fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们预测:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/af76dbd93fc0906ba297bd7f1c0ce8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pit7pDMR7ejBykK9b13IYg.png"/></div></div></figure><p id="b0d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种简单的风格在<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/docs/skaters.md" rel="noopener ugc nofollow" target="_blank">滑手</a>文档中有描述。像所有其他溜冰者一样,“永远”功能发出预测和后验状态。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/9e50a78d90c8af49f5183a325ac62009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MR_YFx37dQa709O9puEmEA.png"/></div></div></figure><p id="9890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不介意计算或时间，你现在可以停止阅读。</p><h1 id="2eb3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">forever函数将使用哪些方法？</h1><p id="3475" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">随着时间的推移，随着Elo评级的变化，这种情况也会发生变化。在一个姐妹库中有<a class="ae jd" href="https://github.com/microprediction/timeseries-elo-ratings/tree/main/ratings" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">机器可读排行榜</strong> </a> <strong class="ih hj"> </strong>指导选择要包含在合奏中的模型。参见所谓的Elo合奏溜冰者的<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skaters/elo" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">代码</strong> </a>，特别是<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/elo/eloensemblefactory.py" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">eloensemblefactory . py</strong></a><strong class="ih hj"/>和<strong class="ih hj"/><a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skatertools/recommendations/suggestions.py" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">top _ rated</strong></a><strong class="ih hj"/>实用程序。</p><p id="6040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，只有当模型可以加载到您当前的环境中时，才会包含它。因此，您至少需要statsmodels、sktime、pmdarima，可能还需要更多，这取决于您。在<a class="ae jd" href="https://github.com/microprediction/timeseries-notebooks/blob/main/forever_hello.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中，我做了以下事情。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/3c45dea723bb016000a9095c1f1bb67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZ5efeDzzvtzppriA3EL8w.png"/></div></div></figure><p id="c0f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/INSTALL.md" rel="noopener ugc nofollow" target="_blank">安装说明</a>。也许这不需要说，但不同型号之间的性能存在巨大差异，因此Elo套装有一个CPU参数。见<a class="ae jd" href="https://www.microprediction.com/blog/fast" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">快速Python时间序列预测</strong> </a>讨论。这并不排除使用像<a class="ae jd" href="https://pypi.org/project/statsmodels/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> statsmodels </strong> </a>，<a class="ae jd" href="https://pypi.org/project/pmdarima/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> pmdarima </strong> </a>，<a class="ae jd" href="https://pypi.org/project/pydlm/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> pydlm </strong> </a>或<a class="ae jd" href="https://pypi.org/project/sktime/#description" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> sktime </strong> </a>这样的库。大概确实排除了<a class="ae jd" href="https://pypi.org/project/neuralprophet/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">neural propht</strong></a>或者<a class="ae jd" href="https://pypi.org/project/tbats/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> tbats </strong> </a>。</p><h1 id="480e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">组合时间序列模型的动机</h1><p id="3855" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">也许你会发现forever函数很有用。然而，在这篇文章的剩余部分，我将详细阐述一些工具，这些工具可能会帮助你创建你自己的主题。</p><p id="dda2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为，在时间序列文献中，以及更广泛的统计文献中，组合模型是有利可图的，这一点是很好理解的。专家文献的混合提供了许多建议，用于根据模型的功效组合模型的输出。在机器学习中，这有时被称为门控和池化。这也与投资组合理论有关，这是我的文章<a class="ae jd" rel="noopener" href="/geekculture/optimizing-a-portfolio-of-models-f1ed432d728b">优化模型组合</a>的主题。</p><p id="69bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">统计学习中的各种方法，如回归和决策树，也会产生模型组合。计量经济学模型总是混合的(例如高斯混合模型由<a class="ae jd" href="https://www.researchgate.net/publication/264273597_Gaussian_Mixture_Models_for_Time_Series_Modelling_Forecasting_and_Interpolation" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Eirola和Lendasse </strong> </a>推荐，GARCH模型的混合由<a class="ae jd" href="https://www.sciencedirect.com/science/article/abs/pii/S1062940813000399" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Hass等人</strong> </a>推荐)。不用说，boosting还被用于时序预测，在<a class="ae jd" href="https://arxiv.org/abs/2104.04781" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">卡琳古拉等人</strong> </a>提供的主题上旋转一次。</p><p id="4857" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习竞赛排行榜经常充斥着bagging条目，其中训练数据集被引导，并采用预测的平均值。参见<a class="ae jd" href="https://microprediction.medium.com/smooth-move-does-wiggling-make-time-series-models-less-accurate-8544e675873" rel="noopener">平滑移动——对于我的热拍和代码，摆动会使时间序列更规则吗</a>。</p><p id="2251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个想法是混合使用在线模型的不同管道。我以前写过时间序列模型的增量<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools/composition" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">组合</strong></a>——参见文章<a class="ae jd" href="https://www.microprediction.com/blog/timemachines" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">预测，快与慢</strong> </a>。</p><p id="a5f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里还有很多要补充的。姚、Pirs、Vehtari和gel man(<a class="ae jd" href="https://arxiv.org/abs/2101.08954" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">arXiv</strong></a>)在最近的一篇论文中对这个话题有一些启发——这里只举一个例子。修改“完全池堆叠”(参见<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skatertools/ensembling/precisionweightedskater.py" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">precision _ weighted _ skater</strong></a>)来执行部分池堆叠应该很简单。</p><h1 id="f0aa" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">成分</h1><p id="9f79" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">forever函数是运行精度加权系综的一个例子。因此，您可以跟踪集成实用程序，看看它是如何执行的。</p><p id="49bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，在这个包中有两种类型的合奏。一种是“信任”合奏，在这种情况下，孩子提供了一定程度的不准确性。另一种是由父母(合奏者)决定的风格。</p><p id="a611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论哪种方式，我都提供了一个名为<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skatertools/components/parade.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">游行</strong> </a>的函数，它在这方面非常方便，因为它跟踪k步预测以及它们对输入数据的准确性。</p><p id="0be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要一些小的便利来跟踪偏差、平方误差和更高阶矩的运行估计。为此，我编写了<a class="ae jd" href="https://github.com/microprediction/momentum/blob/main/momentum/functions.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">动量函数</strong> </a>，因为我找不到实现它们的极简包。(有些读者可能更喜欢同一个东西<a class="ae jd" href="https://github.com/microprediction/momentum/blob/main/momentum/objects.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a>)的更面向对象的版本。</p><p id="c4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此基础上，<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools/ensembling" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">skater tools/ensembling</strong></a>模块中提供了一些用于组合skater函数的工具，这些工具应该可以很容易地创建预测函数的集合。</p><p id="3ad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(这里要小心。还是那句话，我给你参考一下<a class="ae jd" href="https://github.com/microprediction/timemachines" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> README.md </strong> </a>或者<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/examples/basic_usage" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">基本用法</strong> </a> <strong class="ih hj"> </strong>或者……我的天啊居然有描述<a class="ae jd" href="https://microprediction.github.io/timemachines/skaters.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">滑手</strong> </a>和他们的<a class="ae jd" href="https://microprediction.github.io/timemachines/interface.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">接口</strong> </a>的文档。或者只是参考简单的例子。如果你观察移动平均系综的构造方式(可能是最简单的例子)，你会在<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/simple/movingaverage.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">代码</strong> </a>中看到这一点:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/08da416abaac6082a342789099a5ec86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SGHPkj84EA1OkBpf.png"/></div></div></figure><p id="2403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是更基本的移动平均预测函数的单行集合。它使用在这里找到的<a class="ae jd" href="https://github.com/microprediction/timemachines/tree/main/timemachines/skatertools/ensembling" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>组合滑板，你可以随心所欲。</p><h1 id="e936" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">同质系综</h1><p id="09b0" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">最后一个话题是同质系综。</p><p id="986a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于效率的原因，同质系综和异质系综之间存在工程上的区别。作为前者的一个例子，我认为ARMA模型的群体受到一些进化的推动，你可以在<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/smdk/smdkarma.py" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">skaters . smdk . SMD karma</strong></a>中找到它</p><p id="8973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包含各种ARMA合奏。为了展开命名，预测函数<strong class="ih hj">smdk _ P5 _ d0 _ Q3 _ n 1000 _ aggressive</strong>维护1000个不同的ARMA模型，AR度最多为5，MA度最多为3。当数据点到达时，集合中的所有模型同时更新。</p><p id="c0f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python的人对同质集成感兴趣，因为维护一个大的集合不会有很大的影响。我们受益于numpy高效的多维数组操作(我也受益于Otto Sieskari提供的simdkalman包提供的模板)。</p><p id="ccbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一些非常随意的选择，例如一个差分进化步骤来修剪表现不佳的模型的种群，并创建与表现最佳的十分之一相似的新模型(不要引用我的话，请阅读<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/timemachines/skaters/smdk/smdkarmafactory.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">代码</strong> </a>)。在撰写本文时，根据AR、MA、测量误差或过程方差是否被修改，交叉采用四种风格之一。</p><p id="8f13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(一旦创建了新的ARMA模型，它将在一段固定的时间内受到保护，以便预热。在此之后，提示大卫·爱登堡画外音作为兽群的恶性淘汰开始进行。)</p><p id="ee7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是集成速度相当快的一个例子——比如说，与在每个时间步拟合auto-arima相比。事实上，它肯定足够快，可以在更大的合奏中使用——这就是关键。它不需要一直工作来增加价值。也许它可以作为你想出的东西的补充。</p><p id="3266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我还没有尝试过，但是也可以将这些模型视为比简单的精确加权更复杂的下游组合的特征。作为进一步的评论，我注意到如果您希望硬连接组件模型以避免HTTP延迟，这很好，我会提醒您有一个<a class="ae jd" href="https://github.com/microprediction/timeseries-elo-ratings/blob/main/time_series_recommendations.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> colab笔记本</strong> </a>用于推荐。</p><h1 id="a9cc" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">有用吗？</h1><p id="d977" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">以下是刚刚出炉的结果，我可能还没有把它们推送到<a class="ae jd" href="https://github.com/microprediction/timeseries-elo-ratings" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">时间序列-电子-收视率</strong> </a>库。下面是5步预测排行榜。你会注意到Elo集合在超高速算法中占据了第一、第二和第四位(运行50次预测不到1秒)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/f55234ea918d263507814a6e986841cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*etnB3pbVCN7uCcfB.png"/></div></div></figure><p id="91b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们优于sk-time对theta方法的实现，这绝不是一个糟糕的基准。类似地，如果我们提前21步考虑预测，我们也可以再次看到Elo系综的行进。这些如何组合似乎并不太重要。下表中“平衡”和“精确”集合之间的唯一区别是应用于经验方差倒数的指数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/9504c3638478bec5009fd8faedd73c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*boTCEs6IVB4VELL8.png"/></div></div></figure><p id="4e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，虽然我们预测的是“正常”的时间序列(与模型残差相比)，但表现最好的模型残差预测器的Elo组合(称为<strong class="ih hj">Elo _ fast _ residual _ balanced _ ensemble</strong>)表现最好。我总是很快补充说，Elo评级是相当嘈杂的，但这仍然是一个有希望的初步发现，并不完全令人惊讶。</p><h1 id="fa62" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">贡献的</h1><p id="4772" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">如果你对现有算法的巧妙组合感兴趣，或者对增加时间机器包中提供的溜冰者的数量感兴趣，请阅读<a class="ae jd" href="https://github.com/microprediction/timemachines/blob/main/CONTRIBUTE.md" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> CONTRIBUTING.md </strong> </a>。</p><p id="9c7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想贡献更好的分配权重的方法，而不是更好的模型，那么也许可以看看<a class="ae jd" href="https://github.com/microprediction/precise" rel="noopener ugc nofollow" target="_blank"> precise </a>包中的在线方法。</p><p id="c44d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我忘记提到的一个方面是(直到Kevin的一个评论提醒我，不，谢谢),用于计算Elo评级的<em class="le">数据</em>是实时的，可以改进。时间序列从Microprediction.Org出发。因此，如果您想添加数据，请参见<a class="ae jd" href="https://microprediction.github.io/microprediction/publish.html" rel="noopener ugc nofollow" target="_blank">发布文档。</a>Ping me on<a class="ae jd" href="https://microprediction.github.io/microprediction/slack.html" rel="noopener ugc nofollow" target="_blank">slack</a>一个足够强大的密钥来创建数据流，如果你不介意自己烧一个的话。</p><h1 id="cf8b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我就说这些</h1><p id="86e2" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我的新书<a class="ae jd" href="https://www.amazon.com/Microprediction-Building-Open-AI-Network/dp/0262047322" rel="noopener ugc nofollow" target="_blank">micro prediction:Building a Open AI Network</a>最近由麻省理工学院出版社出版，可能有助于阐明我从事自主预测的一些非金融市场动机(你会喜欢的)。我在<a class="ae jd" href="https://www.intechinvestments.com/" rel="noopener ugc nofollow" target="_blank">英达投资公司</a>工作。</p></div></div>    
</body>
</html>
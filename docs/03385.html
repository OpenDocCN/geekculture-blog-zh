<html>
<head>
<title>Raspberry Pico and CMake: Advanced Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raspberry Pico和CMake:高级设置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/raspberry-pico-and-cmake-advanced-setup-81ce47613076?source=collection_archive---------37-----------------------#2021-06-07">https://medium.com/geekculture/raspberry-pico-and-cmake-advanced-setup-81ce47613076?source=collection_archive---------37-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/816e5e7526ca827a952910f56d517e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prr7GCHSd2KEJ_Pasl5f7A.png"/></div></div></figure><p id="abec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CMake是树莓微微生态系统的构建系统。在上一篇文章中，我从一个不熟悉c的开发人员的角度解释了CMake的基本原理。如果您已经理解了，现在您应该可以轻松地用CMake构建您的程序了。</p><p id="db72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此基础上，本文涵盖了额外的技术:条件配置、预处理器符号，包括第三方库，以及如何添加测试。</p><p id="f28c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em> <a class="ae jp" href="https://admantium.com/blog/pico07_advanced_cmake/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的博客</em> </a>。</p><h1 id="838c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例:Pico DHT11库</h1><p id="4f54" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">这篇文章解释了我在库中使用的设置。一个很好且不太复杂的例子是我从DHT11传感器读取温度数据的库:<a class="ae jp" href="https://github.com:admantium-sg/pico-dht11-lib" rel="noopener ugc nofollow" target="_blank"> pico-dht11-lib </a>。</p><p id="77cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个项目有下面的目录结构，我将在文章中提到。此外，查看回购，了解本文中解释的所有技术。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4fb8" class="lc jr hi ky b fi ld le l lf lg">├── CMakeLists.txt<br/>├── cmake<br/>│   └── cmocka.cmake<br/>├── include<br/>│   └── admantium<br/>│       └── pico-dht11.h<br/>├── src<br/>│   ├── CMakeLists.txt<br/>│   └── pico-dht11.c<br/>└── test<br/>    ├── CMakeLists.txt<br/>    ├── mocks.h<br/>    └── test.c</span></pre><h1 id="b98d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">条件配置</h1><p id="779c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在某些项目中，您需要构建一个具有特定案例的项目:仅库、示例代码或测试。这些情况也有不同的需求，比如它们将使用项目的哪些部分，链接到哪些其他库，甚至使用特定的编译器或编译器选项。</p><p id="004b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用CMake选项可以实现条件配置:在根配置文件中定义，它们将您的项目分解到其他配置文件和源代码。</p><p id="25dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在pico-dht11-lib中，条件配置<code class="du lh li lj ky b">BUILD_EXAMPLES</code>和<code class="du lh li lj ky b">BUILD_TESTS</code>表示如下:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="128e" class="lc jr hi ky b fi ld le l lf lg">OPTION(BUILD_EXAMPLES "Build all examples" OFF)</span><span id="9346" class="lc jr hi ky b fi lk le l lf lg">if(BUILD_EXAMPLES)<br/>  include($ENV{PICO_SDK_PATH}/pico_sdk_init.cmake)<br/>  pico_sdk_init()<br/>  enable_language(C CXX)<br/>  add_subdirectory(./examples)<br/>  add_subdirectory(./src)<br/>endif()</span><span id="d8b6" class="lc jr hi ky b fi lk le l lf lg">OPTION(BUILD_TESTS "Build the test binary" OFF)<br/>if(BUILD_TESTS)<br/>  enable_language(C CXX)<br/>  add_subdirectory(./src)<br/>  add_subdirectory(./test)<br/>endif()</span></pre><p id="b0b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关键字<code class="du lh li lj ky b">OPTIONS</code>后跟一个符号、一个描述性字符串和一个布尔值。然后，在其他CMake文件中的任何地方，您都可以引用这个选项名，并使用像<code class="du lh li lj ky b">if</code>和<code class="du lh li lj ky b">elseif</code>这样的表达式来分支构建选项。</p><p id="29e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何调用选项？从根目录调用<code class="du lh li lj ky b">cmake</code>时，添加选项及其布尔值:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3892" class="lc jr hi ky b fi ld le l lf lg">cmake -B build -S . -DBUILD_TESTS=ON</span></pre><h1 id="9ab6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">定义预处理器符号</h1><p id="8839" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">选项还有助于将预处理符号传递给源代码文件:简单地使用完全相同的名称。</p><p id="2259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在pico-dht11-lib中，<code class="du lh li lj ky b">BUILD_TESTS</code>或<code class="du lh li lj ky b">BUILD_EXAMPLES</code>的存在将决定是否包含Raspberry Pico SDK或模拟文件。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7770" class="lc jr hi ky b fi ld le l lf lg">// src/pico-dht11.c<br/>#include &lt;admantium/pico-dht11.h&gt;<br/>#ifndef BUILD_TESTS<br/>#include &lt;pico/stdlib.h&gt;<br/>#endif</span><span id="5c2e" class="lc jr hi ky b fi lk le l lf lg">#ifdef BUILD_TESTS<br/>#include &lt;../test/mocks.h&gt;<br/>#endif</span></pre><p id="2c48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将选项传递给源代码文件，您需要通过添加指令<code class="du lh li lj ky b">target_compile_definitions</code>来修改同一文件夹中的可执行文件/库配置文件。检查CMake选项是否处于活动状态，如果是，将它传递给库或可执行文件。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="465c" class="lc jr hi ky b fi ld le l lf lg"># src/CMakeLists.txt</span><span id="6829" class="lc jr hi ky b fi lk le l lf lg">if(TEST_BUILD)<br/>  # pass -D TEST_BUILD when compiling<br/>  target_compile_definitions(pico-dht11 PUBLIC -D TEST_BUILD)<br/>  target_link_libraries(pico-dht11 test)<br/>else()<br/>  # normal build, link with pico_stdlib<br/>  target_link_libraries(pico-dht11 pico_stdlib)<br/>endif(TEST_BUILD)</span></pre><h1 id="69fd" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">包括第三方库</h1><p id="8357" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">CMake有着悠久的历史，因此它有一个很长的命令列表，您可以使用它来包含其他库。Pico SDK使用git子模块。最近的一个选择，也是对我来说开箱即用的一个，是<code class="du lh li lj ky b">FetchContent</code>。使用CMake文件，您可以指向Github上的任何其他CMake项目，添加选项，然后可以在您的其他CMake文件中使用它。</p><p id="ae19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">pico-dht11-lib使用了<a class="ae jp" href="https://cmocka.org/" rel="noopener ugc nofollow" target="_blank">的cmocka测试框架</a>。为了将它包含在项目中，使用了以下文件。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8803" class="lc jr hi ky b fi ld le l lf lg"># cmake/cmocka.cmake</span><span id="f981" class="lc jr hi ky b fi lk le l lf lg">include(FetchContent)</span><span id="7502" class="lc jr hi ky b fi lk le l lf lg">FetchContent_Declare(<br/>  cmocka<br/>  GIT_REPOSITORY https://gitlab.com/cmocka/cmocka.git<br/>  GIT_TAG        cmocka-1.1.5<br/>  GIT_SHALLOW    1<br/>)</span><span id="8167" class="lc jr hi ky b fi lk le l lf lg">set(BUILD_SHARED_LIBS ON)<br/>set(WITH_STATIC_LIB ON)<br/>set(WITH_EXAMPLES OFF)</span><span id="3a7a" class="lc jr hi ky b fi lk le l lf lg">FetchContent_MakeAvailable(cmocka)</span></pre><p id="7d55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，测试可执行文件可以与cmocka符号链接。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="015f" class="lc jr hi ky b fi ld le l lf lg"># test/CMakeLists.txt</span><span id="c823" class="lc jr hi ky b fi lk le l lf lg">file(GLOB FILES *.c *.h)<br/>add_executable(test ${FILES})</span><span id="b6e8" class="lc jr hi ky b fi lk le l lf lg">include(../cmake/cmocka.cmake)<br/>target_link_libraries(test PRIVATE cmocka-static pico-dht11)</span></pre><h1 id="ef03" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">包括测试</h1><p id="26c9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">测试的包含是以上所有步骤的总和:定义一个CMake选项来有条件地配置和构建您的项目，使用选项名称作为预处理程序符号，并将您的测试代码链接到测试库。</p><p id="066a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">pico-dh11-lib中的一个简单测试用例是DHT11结构的配置。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="97b7" class="lc jr hi ky b fi ld le l lf lg">#include &lt;stdarg.h&gt;<br/>#include &lt;stddef.h&gt;<br/>#include &lt;setjmp.h&gt;<br/>#include &lt;stdint.h&gt;<br/>#include &lt;stdio.h&gt;</span><span id="882f" class="lc jr hi ky b fi lk le l lf lg">#include &lt;cmocka.h&gt;</span><span id="f816" class="lc jr hi ky b fi lk le l lf lg">#include &lt;admantium/pico-dht11.h&gt;</span><span id="5b0f" class="lc jr hi ky b fi lk le l lf lg">DHT11 *dht;</span><span id="9c45" class="lc jr hi ky b fi lk le l lf lg">void test_dht_config(void **state)<br/>{<br/>  dht = dht11_new((PinConfig){<br/>      .DATA_PIN = 16<br/>  });</span><span id="922c" class="lc jr hi ky b fi lk le l lf lg">  assert_int_equal(dht-&gt;DATA_PIN, 16);<br/>}</span><span id="ac03" class="lc jr hi ky b fi lk le l lf lg">int main(int argc, char *argv[])<br/>{<br/>  printf("Runing Tests\n");</span><span id="71f7" class="lc jr hi ky b fi lk le l lf lg">  void *state;</span><span id="a5bb" class="lc jr hi ky b fi lk le l lf lg">  const struct CMUnitTest tests[] = {<br/>      cmocka_unit_test(test_dht_config),<br/>  };</span><span id="117d" class="lc jr hi ky b fi lk le l lf lg">  return cmocka_run_group_tests(tests, NULL, NULL);<br/>}</span></pre><p id="84b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参见我的<a class="ae jp" href="https://admantium.com/blog/pico03_testing_with_cmocka/" rel="noopener ugc nofollow" target="_blank"> cmocka文章</a>了解更多关于测试的知识。</p><h1 id="872d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="9a70" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">本文向您展示了高级的CMake技术。首先，我们学习了如何在根CMake文件中定义CMake选项，以及如何使用它们进行条件配置和构建。其次，我们看到了用<code class="du lh li lj ky b">cmake</code>命令调用的CMake选项是如何作为预处理器符号传递给源文件的。第三，我们看到了如何使用<code class="du lh li lj ky b">FetchContent</code>命令来包含任何其他的CMake项目。最后，我们看到了所有这些技术是如何结合在一起来包含和构建测试的。</p></div></div>    
</body>
</html>
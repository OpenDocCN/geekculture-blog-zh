<html>
<head>
<title>My top 6 ‘Similar, but different’ RxJS operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的前6名“相似但不同”的RxJS操作员</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/my-top-6-similar-but-different-rxjs-operators-52241096ef96?source=collection_archive---------6-----------------------#2021-10-09">https://medium.com/geekculture/my-top-6-similar-but-different-rxjs-operators-52241096ef96?source=collection_archive---------6-----------------------#2021-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cf08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分享我的六大“相似但不同”的RxJS操作员</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d48ff49faeddd0a7da5abed9a1808ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EF6kZUcfhpijAxqIph_CJw.jpeg"/></div></div></figure><h1 id="6323" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="c0fb" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">RxJS提供了许多运算符来处理数据。毫无疑问，这是一件好事，但是，在特定情况下选择正确的操作符可能会令人困惑。因此，如果您不熟悉RxJS，这可能会导致您使用错误的操作符。</p><p id="4171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将分享我的6个常见的“相似但不同”的RxJS运算符，通过避免它们来帮助你节省时间。</p><h1 id="775a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">单()，取(1)和第()</h1><p id="4f5a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> first(): </strong>只发出源可观察对象发出的第一个值(或满足某些条件的第一个值)，如果上游为空，则发出一个错误。</p><p id="d506" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> take(1): </strong>将上游项目的数量限制为1，如果上游为空，则不会发出错误。</p><p id="d61f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> single(): </strong>确保上游不为空。</p><p id="ca78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，我们可以说<code class="du ks kt ku kv b">first == take(1).single()</code>其中<code class="du ks kt ku kv b">take(1)</code>将上游项目的数量限制为1，<code class="du ks kt ku kv b">single()</code>确保上游不为空。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="8d9c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">map()与switchAll()与switchMap()</h1><p id="104c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> map(): </strong>对每个值应用一个投影，并在输出可观测值中发出该投影。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="f75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> switchAll(): </strong>取一个<strong class="ih hj">高阶可观测值</strong>，订阅最近提供的内部可观测值，退订之前订阅的。</p><p id="e974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> switchMap(): </strong>是<code class="du ks kt ku kv b">map()</code>和<code class="du ks kt ku kv b">switchAll()</code>的组合。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="f43b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">zip()vs combineLatest()vs fork join()</h1><p id="17df" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> zip(): </strong>取一组可观测量，等到所有可观测量都发出一个值，然后将所有可观测量作为一个数组发出。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="61d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> combineLatest(): </strong>和<code class="du ks kt ku kv b">zip()</code>一样，<code class="du ks kt ku kv b">combineLatest()</code>会一直等待，直到所有的观察值都以数组的形式发出一个值。从那里，每当一个可观察值发出一个值时，它将发出一个数组。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="2282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> forkJoin(): </strong>取一组可观测量，等待它们完成发射，将每个可观测量的最终值作为数组发射出去。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="acad" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">merge() vs mergeAll() vs mergeMap()</h1><p id="e732" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> merge():</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="f118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> mergeAll(): </strong>将一组<strong class="ih hj">高阶可观测量</strong>发出的内部可观测量合并，展平为一个一阶输出可观测量。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="38fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> mergeMap(): </strong>是<code class="du ks kt ku kv b">map()</code>和<code class="du ks kt ku kv b">mergeAll()</code>的组合。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="8027" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">concat()vs concat all()vs concat map()</h1><p id="7fdf" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">与<code class="du ks kt ku kv b">merge()</code>、<code class="du ks kt ku kv b">mergeAll()</code>和<code class="du ks kt ku kv b">mergeMap()</code>相同，除了concat的可观察对象必须在下一个开始发送值之前完成。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="af40" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">窗口()与缓冲区()</h1><p id="d43b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj"> buffer(): </strong>缓存可观察对象发出的值，并在<code class="du ks kt ku kv b">notifier</code>发出时将它们作为数组发出。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="e088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> window(): </strong>当<code class="du ks kt ku kv b">windowBoundaries</code>发出时，将一个可观测项细分为嵌套的可观测项。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="9ef8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="840e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">最后，Rx是一个巨大的库，可以帮助您处理应用程序复杂的异步方面。在这篇文章中，我试图阐明常用的运算符，并根据相似性对它们进行分组。</p></div></div>    
</body>
</html>
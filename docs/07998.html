<html>
<head>
<title>Software design pattern #6: Singleton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式#6:单一模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-design-pattern-6-singleton-580f50415bdc?source=collection_archive---------17-----------------------#2021-10-09">https://medium.com/geekculture/software-design-pattern-6-singleton-580f50415bdc?source=collection_archive---------17-----------------------#2021-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="acf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式是可重用的模板，帮助我们使用最佳实践解决软件设计问题。通过这种方式，它们帮助我们使用更易于维护、理解、重用和测试的代码来构建应用程序。</p><h1 id="67da" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">逃离速度实验室</h1><p id="b11b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以在我们的网站上找到我们所有的文章、课程和教程:<br/><a class="ae kg" href="https://www.evlabs.io/" rel="noopener ugc nofollow" target="_blank">https://www . ev labs . io</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/70ea5d4ff5179d20a564e435ccba7265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APMmAlasRRgCQmuQlB5LCg.png"/></div></div></figure><h1 id="5f89" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这个图案是干什么用的？</h1><blockquote class="kt ku kv"><p id="a86d" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated">这种模式将一个类的对象的创建限制在一个实例中。</p></blockquote><p id="f803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续我们的社交网络应用程序的例子，在这篇文章中，我们将实现一个类，负责在外部文件中记录应用程序的操作，这样当用户有错误时，我们可以调试它。</p><p id="03dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个名为<em class="kw"> Logger </em>的类将记录我们应用程序中发生的所有事情，所以它必须可以从所有的类中访问。这给我们带来了一个问题。为了在应用程序的每个类中创建Logger类的实例，我们必须将<em class="kw"> Logger </em>的依赖项作为参数传递给所有其他类。</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="e440" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class SQLiteDatabase</strong>:</span><span id="fc55" class="lf je hi lb b fi lk lh l li lj"><strong class="lb hj">    def</strong> <strong class="lb hj">__init__</strong>(self, dep_a, dep_b):<br/>        self.logger = Logger(dep_a, dep_b)<br/>        ...</span></pre><p id="7cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的类中所看到的，我们必须将日志依赖项传递给数据库，尽管它们与数据库本身没有任何关系。另一种可能性是将记录器实例直接注入数据库:</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="bac2" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class SQLiteDatabase</strong>:</span><span id="c9e0" class="lf je hi lb b fi lk lh l li lj">    <strong class="lb hj">def</strong> <strong class="lb hj">__init__</strong>(self, logger):<br/>        self.logger = logger<br/>        ...</span></pre><p id="887a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，正如我们所说的，Logger将出现在应用程序的几乎每个类中，所以我们的代码仍然是不必要的复杂。</p><p id="4b7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案:创建Logger类的单个实例，并从将要使用它的类内部调用它。</p><h1 id="ad8f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的？</h1><p id="85ec" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">第一次调用Logger类时，我们将创建这个类的唯一实例。后续调用将简单地返回该实例:</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="d461" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class Logger</strong>:<br/>    __instance = <strong class="lb hj">None</strong>    </span><span id="710f" class="lf je hi lb b fi lk lh l li lj"><strong class="lb hj">    def</strong> __new__(cls, *args):<br/>        if cls.__instance is <strong class="lb hj">None</strong>:<br/>            cls.__instance = object.__new__(cls)<br/>        <strong class="lb hj">return</strong> cls.__instance</span></pre><p id="e251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，Logger类将存储一个名为<em class="kw"> __instance </em>的隐藏变量，一旦实例被创建，我们将在其中存储该实例。<em class="kw"> __new__ </em>方法负责检查该实例是否存在，如果不存在，它将创建它。</p><p id="1d28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们使用Logger的所有类中，我们将简单地获得唯一的实例并正常使用它，而不必将该类暴露给<em class="kw"> Logger的</em>依赖项:</p><pre class="ki kj kk kl fd la lb lc ld aw le bi"><span id="53b3" class="lf je hi lb b fi lg lh l li lj"><strong class="lb hj">class Database</strong>:    <br/>    <br/>    <strong class="lb hj">def</strong> __init__(self):<br/>        self.logger = Logger()</span><span id="6c64" class="lf je hi lb b fi lk lh l li lj">    <strong class="lb hj">def</strong> insert(self, row):<br/>        self.logger.log('Starting insertion of a row.')</span></pre><h1 id="43b2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">利益</h1><ul class=""><li id="65bd" class="ll lm hi ih b ii kb im kc iq ln iu lo iy lp jc lq lr ls lt bi translated">我们确保只有一个可能包含敏感资源的类实例。</li><li id="d4c3" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">允许从应用程序中的任何位置访问。</li><li id="7985" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">延迟对象的创建，直到需要使用时(见<a class="ae kg" rel="noopener" href="/geekculture/software-design-pattern-4-lazy-initialization-35f606f1ddf3">模式#4:延迟初始化</a>)。</li></ul><h1 id="2671" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">不足之处</h1><ul class=""><li id="3b31" class="ll lm hi ih b ii kb im kc iq ln iu lo iy lp jc lq lr ls lt bi translated">这使得对应用程序不同部分的单元测试变得困难，因为需要创建模拟对象来替换所使用的单例。</li><li id="56d5" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">我们将应用程序的所有类绑定到Logger类的使用。如果以后我们引入另一个名为<em class="kw"> Logger2 </em>的类，我们将不得不替换应用程序中使用Logger的所有点。</li></ul><p id="80a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，这种模式由于其缺点而备受争议。因此，不鼓励使用它，除非它的状态不影响应用程序的功能(如日志工具)。</p></div></div>    
</body>
</html>
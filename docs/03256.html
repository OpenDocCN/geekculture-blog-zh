<html>
<head>
<title>Performance of Hash Implementations on Various Workloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不同工作负载下哈希实现的性能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/performance-of-hash-implementations-on-various-workloads-fedac579a39b?source=collection_archive---------19-----------------------#2021-06-04">https://medium.com/geekculture/performance-of-hash-implementations-on-various-workloads-fedac579a39b?source=collection_archive---------19-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2666b871ec33f8a6153bf4798b25371a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65cRiuka9BleJwuslP2Tmw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="88f0" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">目录</h1><ol class=""><li id="9cd3" class="ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><a class="ae iu" href="#99a2" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">概述</em> </strong> </a></li><li id="f592" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#f71c" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">什么是哈希表？</em> </strong> </a></li><li id="37d6" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#fa54" rel="noopener ugc nofollow">开放寻址</a></li><li id="4bd3" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#8747" rel="noopener ugc nofollow">单独链接</a></li><li id="cdfc" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#5dec" rel="noopener ugc nofollow">布谷鸟磕磕碰碰</a></li><li id="d9ef" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#0f34" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">分析</em> </strong> </a></li><li id="d5ca" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#0fc7" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">摘要</em> </strong> </a></li><li id="ae8f" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#030e" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">测试方法论</em> </strong> </a></li><li id="d4af" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#4de3" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">预期结果</em> </strong> </a></li><li id="8298" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#f31c" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">结果</em> </strong> </a></li><li id="1683" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#dfd5" rel="noopener ugc nofollow">平均包含点击量</a></li><li id="6084" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#25da" rel="noopener ugc nofollow">平均相加</a></li><li id="cfad" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#7549" rel="noopener ugc nofollow">平均驱逐</a></li><li id="6f1b" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#9277" rel="noopener ugc nofollow">平均包含错过</a></li><li id="96d7" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#8e30" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">结论</em> </strong> </a></li><li id="f669" class="ka kb hi kc b kd kt kf ku kh kv kj kw kl kx kn ko kp kq kr bi translated"><a class="ae iu" href="#baac" rel="noopener ugc nofollow"> <strong class="kc hj"> <em class="ks">未来工作</em> </strong> </a></li></ol></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="99a2" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">概观</h1><p id="d6f0" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">这篇博客比较了处理哈希表中哈希冲突的几种不同方法。实现和基准测试都是用Java完成的，图形和分析是通过Pandas和Python中的Seaborn+Matplotlib完成的。实现本身包括线性探测实现、二次探测实现、基于链表的散列，以及最后的Cuckoo散列。我检查了四个测试:一个contains找到它的目标所用的平均时间，一个add函数，一个从hash中移除的evict函数，最后一个contains函数没有找到它的目标。但是，因为我没有实现二次探测驱逐方法，所以二次探测缺少avgEvict和avgContainsMiss数据点(在我编写这段代码时，它对我来说太复杂了)。在我们看比较各种散列实现的性能的实际分析之前，让我们理解什么是散列以及这些实现中的每一个是什么。</p><p id="03a0" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">下一节将简要解释哈希表和冲突处理，所以如果你已经理解了这些概念，请随意跳到<a class="ae iu" href="#0f34" rel="noopener ugc nofollow">分析</a>一节。</p><p id="f54e" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">注意:这篇博文写得很像一篇研究论文，但不要被愚弄了:为此所做的研究不够有力，不足以证明其格式，我只是想改变一下。</p><h1 id="f71c" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">什么是哈希表？</h1><p id="d756" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">哈希表也称为哈希映射，是将一些键映射到一些值的数据结构。它们使用散列函数将某种类型的一个键映射到某种类型的一个值。哈希表的常见实现是保存值的数组和将键映射到数组的整数索引的函数。一个好的哈希表有一个好的哈希函数和一个好的大小，有一个几乎恒定的插入、删除和查询时间，但这并不总是可能的。通常散列函数中有重叠，这意味着两个唯一的键可能经常有相同的散列值，从而导致冲突。冲突的数量随着加载因子的增加而增加，加载因子是占用表的条目数量除以表的总大小。冲突数量的增加使得查找时间增加，通常会丢失所需的常量时间。这种影响可以通过各种方法来减轻，我们将研究其中的四种方法。让我们看看这些方法是如何工作的，然后我们可以看看它们的性能。(你可以在<a class="ae iu" rel="noopener" href="/omarelgabrys-blog/hash-tables-2fec6870207f">这篇</a>很棒的文章中找到更多信息)。</p><h2 id="fa54" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">散列地址</h2><p id="374d" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">在开放式寻址中，处理冲突的方法是将冲突值放在下一个可用空间中，与表中的原始空间相隔一段时间。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/69f96053f6fb4deb175f99f4b878b471.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/0*W7Eq4SzP623rlgYj"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="6458" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">例如，在这张散列表中，您可以看到间隔为1的冲突是如何处理的。John Smith试图将关键字放置在索引001处，但是它与Lisa Smith发生冲突。因此，John Smith被放置在下一个可用位置，该位置恰好是152，因为位置002到151被其他值占用。现在，约翰·史密斯已经被放置在散列表中，桑德拉·狄试图被放置，但是与约翰·史密斯的新位置冲突。所以桑德拉被安排在下一个空位置，正好是153号。然后，Ted Baker试图被安排在153号位置，但该位置已被占用，因此他被移到154号位置。</p><p id="3503" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">这个具体的例子使用了间隔1，这意味着冲突值被放置在紧接的下一个空位置(1个空间之外)，并且被称为线性探测。还有另一种称为二次探测的方法，每当与给定键发生冲突时，该方法会将间隔增加某个多项式值。</p><h2 id="8747" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">单独链接</h2><p id="5160" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">解决冲突的另一种方法是对链表使用单独的链接。这种方法的工作原理是用空的链表填充整个哈希表，当添加键时，它们被追加到与它们的哈希值对应的链表中。这意味着具有相同哈希值的键只是被追加到相同的列表中。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/e3235c940a3c060f68919832d0cce023.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*_ZoLG0CYbCpjOaPT"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="41f6" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">正如在这张照片中看到的，冲突很容易处理，但需要注意的是，随着冲突数量的增加，访问链表的恒定时间被访问链表中元素的O(n)时间所压倒。</p><h2 id="5dec" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">布谷鸟哈希</h2><p id="fe88" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">最后，还有一种以布谷鸟命名的哈希技术，这种鸟在孵化后将其他蛋从窝中推出。这个算法使用了大量的哈希表(在我的实现中是2个)，一个主要的，二级的，三级的，等等。，以及每个表的唯一散列函数。主表的功能就像普通的哈希表一样，但是当发生冲突时，新的键会占据旧键的位置，从而占用旧键的空间。然后旧的键被推入辅助表，在那里根据这个表的散列函数找到它的新散列值(因此得名)。如果在这里发生冲突，那么重复这个过程，旧的密钥现在变成新的密钥，冲突的密钥被推入下一个表。如果这种情况持续到最后一个表，那么最终的值就会绕回主表。如果这里也有碰撞，那么过程重复。如果检测到一个循环，那么所有表的大小都加倍，这迫使一个新的哈希值尝试解决该循环。更详细的解释<a class="ae iu" href="https://en.wikipedia.org/wiki/Cuckoo_hashing" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="0f34" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">分析</h1><p id="90f6" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">好了，现在你对哈希表有了一个基本的了解，也有了一些处理冲突的方法。我们来分析一下他们每一个人的表现。</p><h1 id="0fc7" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">摘要</h1><p id="e76f" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">当使用散列时，有许多不同的实现可以改变散列处理冲突的方式，每种实现都有自己的优点和缺点。实现线性探测、二次探测、链表散列和Cuckoo散列的散列都经过了测试，以确定它们各自的优点。通过分析这些差异，可以为特定的任务选择最佳的实现，从而为任何需要使用散列的给定问题提供最有效的解决方案。</p><h1 id="030e" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">测试方法</h1><p id="8d3c" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">测试测量了四个测试所花费的时间:包含保证命中的地方、驱逐、包含保证未命中的地方以及添加新元素。这些测试中的每一个都在每个实现上执行了10，000次(除了下面提到的例外),以获得尽可能准确的数据。对于二次探测，不进行带有未命中的驱逐和包含，并且二次探测的添加总是试图添加已经存在的元素，而不是像所有其他实现的添加测试那样添加新元素。由于缺少数据，这将使任何关于二次探测的结论难以证明，包含命中是唯一可靠的数据。</p><p id="e260" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">Cuckoo哈希的加载因子是手动计算的，因为它有增长的趋势来解决哈希冲突，所以向它添加了恒定数量的元素。这不影响结果，但应该注意。</p><p id="cda1" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">测试数据被分成两个不同的数据集，数据集B和数据集d。这两个数据集都包含0到100，000之间的整数，但是它们的分布不同。数据集B在其范围内具有相对相等的分布，而数据集B具有对称的双峰正态分布。这可以在下图中看到，该图绘制了数据集的分布，数据集B为蓝色，数据集D为绿色。这些不同分布的影响将在结果部分讨论。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/2f66a601a67e8ed828da9d5c1feaebb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ALfuOl0KwpqHoHcz"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><h1 id="4de3" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">预期结果</h1><p id="b230" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">随着负载系数根据实施和测试方法的不同而变化，可以预期性能会有所下降和提高。</p><p id="763b" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">对于线性探测，随着负载因子的增加，由于所形成的集群的顺序性质，散列的性能趋向于O(n)。这将导致add、evict和contains未命中测试的性能下降，尽管contains命中测试不一定如此。在包含命中测试中，哈希找到接近原始哈希位置的命中的可能性很高，因为命中是有保证的，这与包含未命中不同，即使在加载因子增加的情况下，也是如此，这意味着在此测试中，性能不会受到高负载的严重影响。</p><p id="feb0" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">对于二次探测，contains hit所用的时间不应受到增加的负载因子的太大影响，因为二次探测会分解集群，从而使性能不会趋于O(n)。它的添加性能应该是相似的，并没有太多要说的驱逐或包含错过，因为他们没有经过测试。</p><p id="b027" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">对于链表实现，可以预期随着加载因子的增加，contains会变慢，但是add会保持很快。逐出也会变慢，但是由于Java中链表的大量优化，与线性或二次探测相比，包含和逐出的速度降低几乎不明显。</p><p id="4f91" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">最后，Cuckoo实现应该有接近常数的包含和驱逐时间。Add应该是唯一一个Cuckoo可能会变慢的地方，因为随着负载系数的增加和散列的被迫增长(由于自然循环)，从一个数组到另一个数组的数据复制会由于更大的数组而花费更多的时间。</p><h1 id="f31c" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">结果</h1><p id="de87" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">首先，在考虑数据集的影响之前，将考虑实现对性能的影响。下图按实现和数据集检查了每个测试所用的各种平均时间(以微秒计)。</p><h2 id="dfd5" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">平均包含命中</h2><p id="c30b" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">在第一张图中，我们看到了对散列进行一次肯定的contains调用所花费的平均时间。线性探测，缩写为LP，随着两个数据集中负载因子的增加，性能很差，尽管它在较低的负载因子下性能一般。这是意料之中的，因为LP形成的簇导致接近O(n)的复杂度。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/830b9f075a5b2072565d6a883c7fb728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9m-EeeRJzqkrQjpN"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="bb27" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">二次探测，简称QP，随着负载系数的增加，性能最差，讽刺的是几乎形成了一条二次曲线。它在低负载系数下的性能仅次于最佳，但它会迅速提高，这是意料之中的。然而，令人惊讶的是，考虑到QP分解集群的预期，QP比LP表现得更快。可能的解释是，QP在低负载因子下分解集群，导致低于O(n)的性能，这优于LP，但当负载因子增加到超过0.5时，QP需要比线性探测更多的检查，因为有更少、更大的集群，这意味着线性搜索在这一点上更有效。</p><p id="5c0e" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">链表实现LL在加载因子和平均包含时间之间具有近乎线性的相关性。对于真正的O(n)性能来说，这是意料之中的，尽管Java的本机优化在大约0.23以上的任何负载系数下都没有击败LP，这有点令人惊讶。</p><p id="b34c" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">最后是布谷鸟实现，缩写为C，在所有场景下性能最好。由于其类似数组的性质，这种实现保持了几乎恒定的检查容器到期时间。不过，奇怪的是，对于低于0.3的负载系数，在大约55 μs建立之前，平均所需时间更长。</p><p id="8e1c" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">很明显，如果检查一个正包含所花费的时间很重要，那么为任何负载因子选择的最佳实现就是Cuckoo。在某些负载因素下，它比其他实现快两倍以上，并且实现起来并不复杂。</p><p id="5154" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">至于数据集的差异，似乎很少。然而，似乎QP在数据集D上在除了0.1之外的所有加载因子上都表现得更好。这可能是由于数据集D的分布导致其自然聚类，这使得QP实现更加有效。LP在两个数据集上具有相似的性能，除了在负载因子为0.9的数据集B上花费的时间要多得多。L1和C在两个数据集上都有几乎相同的性能，差异归因于测量误差。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/4c482b5ad90902ff3302b128737e6ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEi-9iFwp0DyPt0F"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="5707" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">从这个分布图中可以看出，C实现始终是最低的，而QP的变化很大，LL和LP的变化都很一般。因此，Cuckoo哈希是contains hit的最佳哈希，具有一贯的较低时间。</p><h2 id="25da" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">平均添加</h2><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/2b23730a8bfcf3393070bcd1144089e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oMSK_5VIxShCUqHv"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="4e01" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">LP在负载系数为0.1到0.7之间有相当好的性能，尽管在这之后它的性能变得很糟糕。这个大峰值是意料之外的，尽管较小的峰值并非完全不合理。在这里，数据集之间存在明显的差异，数据集B的执行速度几乎比数据集D慢三倍。这可能是因为D中更紧密分组的数字将具有不同的键，而B中更大的分布将由于哈希函数的环绕性质而导致更多的重叠。</p><p id="107f" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">在负载系数小于0.3时，QP的性能名列前茅，但在此之后，它充其量只能算一般。应该注意的是，这个针对QP的特定测试从不插入元素，因为它已经存在了，这可能会导致这种平庸的性能。</p><p id="82b8" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">LL性能接近最差，但与LP不同，它是可预测的。同样，由于向链表添加元素的必要性，这是一个预期的结果。</p><p id="7727" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">Cuckoo hash在较高的负载系数下再次拥有令人难以置信的性能，但在0.1的负载系数下确实落后了。这种性能损失只发生在数据集B中，这可能是因为在该数据集中形成了额外的“循环”,需要通过增加散列来打破这些循环，这是一个代价高昂的过程。然后，在较高的负载系数下，这就不是问题了，因为净哈希表越大，冲突的可能性就越大。</p><p id="b9df" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">对于主要增加的工作负载来说，最好的实现在所有情况下都是愚蠢的，除非哈希的增长永远不会超过0.2的负载系数。它的一致性令人难以置信，如果工作负载增加，它实际上需要查询，这也是Cuckoo擅长的。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/11636bf4bb0148656abe2e54c6e89398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*__V6NgGAV_yoEaWG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="dbe8" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">最后，分布图显示，布谷鸟哈希与LL一样一致，QP始终紧随其后。由于LP糟糕的一致性和性能，C是这种工作负载的明显赢家。</p><h2 id="7549" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">平均驱逐</h2><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/a0d063f3c5074c5b33d2dc929b4126db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s0-J4elfTLhvZP4q"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="207d" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">LP的性能显然是这里测试的三个实现中最差的。它增长到似乎是一个指数曲线，这并不奇怪，因为在高负荷因素下驱逐物品的复杂性。</p><p id="dec2" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">对于LL，性能几乎是恒定的，这在某种程度上是因为从链表中移除一个元素所花费的时间似乎会随着链表的变长而变长。然而，在这种情况下，Java的优化似乎可以帮助LL。</p><p id="eac0" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">最后，C再次具有接近恒定的性能，在负载系数为0.1时花费的时间略高。这是因为阵列的近瞬时响应。</p><p id="ebc6" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">数据集D的LP性能更好，数据集之间的差异很小。总体来说，表现最好的是布谷鸟，虽然ll也不甘落后。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/db39ef9d52eef9942d48caa6e59be589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JBZpk5FBiDWxZGgC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/65023aca827451cf30924cc339ef4431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RgP8XDqqBW_dDTQZ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="ded2" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">在evict的分布图中，C hash是如此一致，以至于我们需要放大才能看到竞争。C hash之所以如此一致，是因为它仅仅改变了几个数组元素的值，仅此而已。LL也不可怕，因为它经过了很好的优化，只需要移动一些指针。然而，LP由于其复杂的驱逐过程而非常不一致。再一次，Cuckoo hash因其一致性和出色的性能而胜出。</p><h2 id="9277" class="lx jd hi bd je ly lz ma ji mb mc md jm kh me mf jq kj mg mh ju kl mi mj jy mk bi translated">平均包含缺失</h2><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/8f1b023b0e5167b01b157f09c6ccb4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qxNVFil5cgUJ9Svo"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="579c" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">LP实现在这次测试中再次令人失望。当负载系数超过0.7时，它的性能非常糟糕，在所有其他负载系数下，它的性能仍然最差。这是意料之中的，contains miss测试要求对散列进行几乎完全的搜索。在数据集B中花费了明显更长的时间，这可以用与过去LP测试中相同的原因来解释。</p><p id="d086" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">LL在负载系数小于约0.45时具有最佳性能，之后仍具有可观的性能。很可能是由于Java的优化，在一个小链表上检查一个contains比在两个独立的数组上检查两次要快。然而，随着列表变得越来越长，这种情况会被打破。数据集之间的差异非常小，由于存在误差，可以忽略不计。</p><p id="1861" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">正如预期的那样，C hash具有很好的整体性能。如果负载系数大于0.45，则此工作负载的最佳选择是C，如果负载系数小于0.45，则选择LL实现。</p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/c4d3c5c4857d1fa9587466254fa7afc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pOcKs7-O9l0eqlaI"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/eafa5f8f54a325b38d310b27fcfc12b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5EXf4nRruRMmBZ1A"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image courtesy of <a class="ae iu" href="https://aniaggarwal.medium.com/" rel="noopener">Ani Aggarwal</a></figcaption></figure><p id="a3c7" class="pw-post-body-paragraph ky kz hi kc b kd ln la lb kf lo lc ld kh lp lf lg kj lq li lj kl lr ll lm kn hb bi translated">同样，我们需要放大，因为基于前面讨论的原因，C非常一致。这个分布图描绘了与平均驱逐次数相同的画面:Cuckoo非常一致，LL紧随其后，LP到处都是。布谷鸟也是这里的赢家，尽管这是一场势均力敌的战斗。</p><h1 id="8e30" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">结论</h1><p id="ef6a" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">Cuckoo hash在许多不同的工作负载、数据集和负载因素中具有最佳的性能和一致性。不管数据集的分布如何，Cuckoo的执行时间几乎是恒定的，只是偶尔可以与之匹敌。尽管如此，在足够多的测试中，Cuckoo以太大的优势击败了竞争对手，这并不重要。如果某个工作负载是所需要的全部，那么请参考该部分以获得最佳实现，尽管Cuckoo总体上是最好的。与QP不同，它的实施也不太复杂。</p><h1 id="baac" class="jc jd hi bd je jf ls jh ji jj lt jl jm jn lu jp jq jr lv jt ju jv lw jx jy jz bi translated">未来的工作</h1><p id="1ee4" class="pw-post-body-paragraph ky kz hi kc b kd ke la lb kf kg lc ld kh le lf lg kj lh li lj kl lk ll lm kn hb bi translated">非常有趣的是，Cuckoo hash几乎在每个方面都主宰了所有其他实现。与QP不同，它的概念非常简单，但也非常聪明，容易实现。QP和LP对于他们平庸的表现来说都太复杂了，尽管LP表现如此之差令人惊讶。LP的概念非常简单(尽管evict函数的实现并不简单)。这表明复杂性并不能保证良好的性能，但简单性也不能。探索更多关于LL实现的信息是非常有趣的，因为它有一些令人印象深刻的性能提升，深入探究Java对链表的优化可能会提供一些答案。探索Java和其他语言使用哪些实现，以及它们的实现是否根据给定的条件而变化，也是很有趣的。</p></div></div>    
</body>
</html>
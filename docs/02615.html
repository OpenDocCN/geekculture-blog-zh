<html>
<head>
<title>How to Show Incoming Call Popup Like Truecaller in React Native.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React Native中像Truecaller一样显示来电弹出窗口？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-show-incoming-call-popup-like-truecaller-in-react-native-c037daf76ba2?source=collection_archive---------6-----------------------#2021-05-22">https://medium.com/geekculture/how-to-show-incoming-call-popup-like-truecaller-in-react-native-c037daf76ba2?source=collection_archive---------6-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4da1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">嘿伙计们！在这篇博客中，我们将研究如何在React Native中显示来电弹出窗口。</h2></div><p id="b210" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在为虚拟赛伯龙私人有限公司<br/>做一个项目。在开发过程中，我被分配了一个与Truecaller功能相同的任务，在接到电话时显示弹出窗口。最初，我不得不在互联网上进行数小时的研究和搜索，这有点困难，因为在react native中没有太多的支持或社区帮助。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/356ec3d206b32bc517640f45398f102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PCT_mKximZtH05NY.png"/></div></div></figure><p id="a4cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我按照以下步骤完成了它。</p><ol class=""><li id="8b47" class="kg kh hi iz b ja jb jd je jg ki jk kj jo kk js kl km kn ko bi translated">在android部分创建一个无头任务来了解Phone _ State(extra _ State _ ringing | extra _ State _ off hook | extra _ State _ idle)。</li><li id="c5ba" class="kg kh hi iz b ja kp jd kq jg kr jk ks jo kt js kl km kn ko bi translated">通过注册Headless task在react-native中实现这一点。</li><li id="a2db" class="kg kh hi iz b ja kp jd kq jg kr jk ks jo kt js kl km kn ko bi translated">将应用程序注册为前台服务，以便在前台运行应用程序。</li><li id="8297" class="kg kh hi iz b ja kp jd kq jg kr jk ks jo kt js kl km kn ko bi translated">使用react-native-invoke-app打开接收来电的应用程序。</li><li id="080b" class="kg kh hi iz b ja kp jd kq jg kr jk ks jo kt js kl km kn ko bi translated">导航用户至呼叫弹出屏幕并显示用户详细信息。</li><li id="e0dd" class="kg kh hi iz b ja kp jd kq jg kr jk ks jo kt js kl km kn ko bi translated"><strong class="iz hj">在android部分创建一个了解Phone _ State(extra _ State _ ringing | extra _ State _ off hook | extra _ State _ idle)的无头任务。</strong></li></ol><p id="15af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始之前，我们需要对无头任务有一个正确的理解</p><p id="f80c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Headless Task:</strong>Headless Task是React Native中的一种方式，当我们的应用程序在后台运行任务时。</p><p id="e281" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查应用程序状态</p><blockquote class="ku kv kw"><p id="1691" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">从“react-native”导入{ AppState}</em></p><p id="3876" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">use effect(()=&gt;console . log(appstate . currentstate))；<br/>//输出为backround或active，表示App </em></p></blockquote><p id="7fd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="kx">如何创建无头任务？</em> </strong></p><p id="86dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建无头任务，首先我们必须创建一个服务来定义我们的任务。</p><p id="7830" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们想要检查电话状态，所以我们必须在AndroidManifest.xml中给READ_PHONE_STATE权限</p><blockquote class="ku kv kw"><p id="467d" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi"> &lt;用途-权限Android:name = " Android . permission . read _ PHONE _ STATE "/&gt;</em></p></blockquote><p id="b9d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，由于我正在处理一个来电弹出窗口，所以我将服务命名为<strong class="iz hj"> CallService。</strong></p><blockquote class="ku kv kw"><p id="7a28" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">打包com . myapp . service；<br/>导入Android . content . intent；<br/>导入Android . OS . bundle；<br/>导入com . Facebook . react . headlessjstaskservice；<br/>导入com . Facebook . react . bridge . arguments；<br/>导入com . Facebook . react . jstasks . headlessjstaskconfig；<br/>导入javax . annotation . nullable；</em></p><p id="ff76" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">公共类CallService扩展HeadlessJsTaskService { </em></p><p id="c213" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><a class="ae jt" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank"><em class="hi">@ Override</em></a><em class="hi"><br/>protected</em><a class="ae jt" href="http://twitter.com/Nullable" rel="noopener ugc nofollow" target="_blank"><em class="hi">@ Nullable</em></a><em class="hi">HeadlessJsTaskConfig getTaskConfig(Intent Intent){<br/>Bundle extras = Intent . get extras()；<br/>如果(群众演员！= null){<br/>return new HeadlessJsTaskConfig(<br/>" Call "，<br/>arguments . from bundle(extras)，<br/> 5000，//任务超时<br/> false //可选:定义任务是否允许在前台运行。默认为假<br/>)；<br/> } <br/>返回null<br/> } <br/> } </em></p></blockquote><p id="4b1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要在AndroidManifest.xml中声明该服务</p><blockquote class="ku kv kw"><p id="760e" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi"> &lt;服务Android:name = " com . myapp . service . call service "/&gt;</em></p></blockquote><p id="8805" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<application/>标记结束前添加此行。</p><p id="2889" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们最终创建了服务，下一步是创建接收者。</p><p id="6ccc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">呼叫接收器</strong></p><blockquote class="ku kv kw"><p id="360c" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">包com . myapp . receiver；<br/>导入Android . content . broadcast receiver；<br/>导入Android . content . context；<br/>导入Android . content . intent；<br/>导入Android . telephony . telephony manager；<br/>导入Android . app . activity manager；<br/>导入Java . io . file；<br/>导入Java . util . *；<br/>导入com . myapp . service . call service；<br/>导入com . Facebook . react . headlessjstaskservice；</em></p><p id="48b1" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">公共最终类CallReceiver扩展BroadcastReceiver { </em></p><p id="761b" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">public final void on receive(Context Context，Intent Intent)<br/>{<br/>if(isAppOnForeground((Context))= = 0){<br/>Boolean incoming call = false；<br/>Intent rec Intent = new Intent(context，call service . class)；<br/> if (intent.getAction()。equals(" Android . intent . action . phone _ STATE "){<br/>reci ntent . putextra(" action "，" phone _ STATE ")；<br/>String phoneState = intent . getstring extra(" state ")；<br/>if(phonestate . equals(TelephonyManager。EXTRA _ STATE _ RINGING)){<br/>String phone number = intent . getstring EXTRA(" incoming _ number ")；<br/>incoming call = true；<br/> recIntent.putExtra("state "，" extra _ state _ ringing ")；<br/>reci ntent . putextra(" incoming _ call "，真)；<br/> recIntent.putExtra("number "，phone number)；<br/>} else if(phonestate . equals(TelephonyManager。EXTRA _ STATE _ off hook)){<br/>if(incoming call){<br/>incoming call = false；<br/>}<br/>reci ntent . putextra(" state "，" extra _ state _ off hook ")；<br/>reci ntent . putextra(" incoming _ call "，false)；<br/>} else if(phonestate . equals(TelephonyManager。EXTRA _ STATE _ IDLE)){<br/>if(incoming call){<br/>incoming call = false；<br/>}<br/>reci ntent . putextra(" state "，" extra _ state _ idle ")；<br/>reci ntent . putextra(" incoming _ call "，false)；<br/>}<br/>} else {<br/>reci ntent . putextra(" action "，" new _ outgoing _ call ")；<br/>}<br/>context . start service(rec intent)；<br/>headlessjstaskservice . acquire wakelocknow(上下文)；<br/> } <br/> } </em></p><p id="522c" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">//检查应用程序是否在前台，如果在前台，将会崩溃。</em></p><p id="c9ec" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">private int isapponforegroud(Context Context){<br/>activity manager activity manager =(activity manager)Context . getsystem service(Context。ACTIVITY _ SERVICE)；<br/>列表&lt; ActivityManager。RunningAppProcessInfo&gt;app processes =<br/>activity manager . getrunningappprocesses()；<br/> if (appProcesses == null) { <br/>返回0；<br/> } <br/>最终字符串package name = context . get package name()；<br/> for (ActivityManager。RunningAppProcessInfo appProcess:app processes){<br/>if(app process . importance = =<br/>activity manager。runningapprocessinfo . IMPORTANCE _ FOREGROUND&amp;&amp;<br/>app process . process name . equals(package name)){<br/>return 1；<br/> } <br/> } <br/>返回0；<br/> } </em></p><p id="3fa2" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi"> recIntent.putExtra("action "，" new _ outgoing _ call ")；<br/>}<br/>context . start service(reci ntent)；<br/>headlessjstaskservice . acquire wakelocknow(上下文)；<br/> } <br/> } </em></p></blockquote><p id="9ecb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使用这个接收器，我们必须在AndroidManifest.xml中声明它</p><p id="081c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们已经声明的服务声明之后添加以下代码行。</p><blockquote class="ku kv kw"><p id="73eb" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi"> &lt;接收方Android:name = " com . myapp . receiver . CALL receiver "&gt;<br/>&lt;意向过滤Android:priority = " 0 "&gt;<br/>&lt;动作Android:name = " Android . intent . action . phone _ STATE "/&gt;<br/>&lt;动作Android:name = " Android . intent . action . new _ OUTGOING _ CALL "/&gt;&lt;/意向过滤&gt;<br/>&lt;</em></p></blockquote><p id="4458" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们结束了创建一个无头任务的第一步。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="21d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 2。通过注册Headless task </strong>在react-native中实现这一点。</p><p id="cc09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们在上一步中创建了一个无头任务来了解调用的状态，为了在js代码中使用它，我们将把它注册为一个无头任务。</p><p id="b0eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开index.js并添加以下代码。</p><blockquote class="ku kv kw"><p id="1e61" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">const Call = async(data)=&gt;{<br/>if(data . state = = = ' extra _ state _ Ringing '){<br/>Toast . show with gravity(" Ringing "，Toast。龙，干杯。BOTTOM)<br/>}<br/>else if(data . state = = = ' extra _ state _ off hook '){<br/>Toast . showwithgrality(" Call Started "，Toast。龙，干杯。BOTTOM)<br/>}<br/>else if(data . state = = = ' extra _ state _ idle '){<br/>Toast . showwithgrality("通话结束"，Toast。龙，干杯。下)<br/>}<br/>}<br/>appregistry . registerheadlesstask(' Call '，()= &gt; Call ) </em></p></blockquote><p id="ca13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以测试应用程序，它会显示适当的通话祝酒词。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="7587" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 3。将应用程序注册为前台服务，以便在前台运行应用程序。</strong></p><p id="c8c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了保持我们的应用程序处于活动状态，我们可以使用这个包，这使它变得非常简单。<br/><a class="ae jt" href="https://www.npmjs.com/package/@supersami/rn-foreground-service" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ super Sami/rn-foreground-service</a>。</p><p id="5ddd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以在应用程序栏中看到我们的应用程序运行状态。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es li"><img src="../Images/6cc0e4442e07239ad0796c550fbdb39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*AN2LMIPXXCgQ5U7o.jpeg"/></div></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="0065" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 4。使用react-native-invoke-app打开接收来电的应用程序。</strong></p><p id="f00f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，我们只想在接到电话时打开应用程序。</p><p id="23c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你需要它来接听和拨出电话，这将需要一些调整</p><p id="245e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，请安装以下软件包，并将以下代码添加到index.js中</p><p id="d335" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"><em class="kx">react-native-invoke-app</em></strong></p><blockquote class="ku kv kw"><p id="19eb" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">从‘react-native-invoke-app’导入invokeApp</em></p><p id="0c97" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">const Call = async(data)=&gt;{<br/>if(data . state = = = ' extra _ state _ Ringing '){<br/>Toast . showwithgrality(" Ringing "，Toast。龙，干杯。BOTTOM)<br/>invoke app({ data:{ number:data . number })；<br/>}<br/>else if(data . state = = = ' extra _ state _ off hook '){<br/>Toast . showwithgrality(" Call Started "，Toast。龙，干杯。BOTTOM)<br/>}<br/>else if(data . state = = = ' extra _ state _ idle '){<br/>Toast . showwithgrality("通话结束"，Toast。龙，干杯。下)<br/> } <br/> } </em></p></blockquote><p id="6c25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它会为每个来电调用应用程序。</p><p id="00ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于MI手机，我们必须给予一些额外的权限。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es li"><img src="../Images/e93cbd14b314105dbfc2d8e1954ce9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*Ie_QtuZA4mNP5vbW.jpeg"/></div></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="0d21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 5。导航用户至呼叫弹出屏幕并显示用户详细信息。</strong></p><p id="7c34" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，这是最后一步，在这一步中，当我们收到来电时，我们会将应用程序导航到特定的屏幕。</p><p id="c382" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们将添加一个侦听器，它将在应用程序被调用时触发。<br/>我们可以通过在App.js中编写以下代码来做到这一点</p><pre class="jv jw jx jy fd lj lk ll lm aw ln bi"><span id="45a4" class="lo lp hi lk b fi lq lr l ls lt">componentWillMount() {<br/>        DeviceEventEmitter.addListener('appInvoked', (data) =&gt; {<br/>	    const { number} = data;<br/>	    this.props.navigation.navigate("NumberPopupScreen",{number:number});<br/>	});</span></pre><p id="9dbb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经完成了大部分任务，只需要创建一个屏幕来显示数字。</p><p id="14d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，我创建了一个模态弹出窗口。</p><blockquote class="ku kv kw"><p id="323c" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">从‘React’导入React，{ use state }；<br/>从‘react-native’导入{Text，TouchableOpacity，View，Linking }；<br/>从' react-native-modal '导入Modal；<br/>从' react-native-vector-icons/font awesome '导入图标；<br/>从'导入联系人卡片。/Card/contact Card '；<br/>从“react-native-contacts”导入联系人；<br/>从‘react-native-minimize’导入RNMinimizeApp<br/>从‘react-native-simple-Toast’导入Toast</em></p><p id="9a96" class="ix iy kx iz b ja jb ij jc jd je im jf ky jh ji jj kz jl jm jn la jp jq jr js hb bi translated"><em class="hi">函数modal tester({ number }){<br/>const[isModalVisible，setModalVisible]= use state(true)；<br/>return(<br/>&lt;Modal is visible = { isModalVisible }&gt;<br/>&lt;View<br/>style = { {<br/>flex:0.25，<br/> backgroundColor: '#6b0195 '，<br/> borderRadius: 5，<br/> padding: 20，<br/>} }&gt;<br/>&lt;touchable opacity<br/>on press = {()=&gt;{<br/>setmodalvulv<br/>rnminimizeapp . minimize app()；<br/>} }&gt;}<br/>&lt;Icon<br/>name = " times "<br/>style = { { align self:' flex-end ' } }<br/>color = " white "&gt;&lt;/Icon&gt;<br/>&lt;/touchable opacity&gt;<br/>&lt;contact card<br/>it = { {<br/>givenName:' Test Test '，<br/>phone numbers:[{ number:number margin top:20 } }&gt;<br/>&lt;View style = { { align items:' center ' } }&gt;<br/>&lt;touchable opacity on press = { Call Support }&gt;<br/>&lt;Icon name = " phone " size = { 40 } color = " white "&gt;&lt;/Icon&gt;<br/>&lt;/touchable opacity<br/>&lt;Text style = { { font weight:' color: 'lightgray'}} &gt; <br/>保存联系人<br/>&lt;/Text&gt;<br/>&lt;/View&gt;<br/>&lt;/View&gt;<br/>&lt;/View&gt;<br/>&lt;/Modal&gt;<br/>)； <br/> } <br/>导出默认的ModalTester</em></p></blockquote><p id="ce9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，你可以看到弹出的接收电话。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es li"><img src="../Images/b00fcf9f277b7bc2c80cc7348f28d403.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*chRApOmrG5NwdMsC.jpeg"/></div></figure><p id="f241" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">结论:</strong>在这篇博客中，我们学习了创建Headless任务，用Js代码实现它们，添加一个app作为前台服务，在特定事件上调用app，以及处理app Invoke事件。</p><p id="d59d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢，请分享你对此的想法。</p></div></div>    
</body>
</html>
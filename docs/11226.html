<html>
<head>
<title>Java Reflections Basics Through Myth About Beautiful Narcissus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过美丽水仙的神话反思Java基础知识</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-reflections-basics-through-myth-about-beautiful-narcissus-33873c253c7d?source=collection_archive---------12-----------------------#2022-03-11">https://medium.com/geekculture/java-reflections-basics-through-myth-about-beautiful-narcissus-33873c253c7d?source=collection_archive---------12-----------------------#2022-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ad78" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Java反射API网关简介</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ef0679ef21ad01eaf35c52cd8bbcc1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j70cJRhQfLMPm_iQeR273w.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Narcissus, 1599 by Caravaggio</figcaption></figure><p id="4208" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是Java反思系列的第一篇文章。“倒影”这个词激发了我的想象力，画出了坐在溪边的水仙。长话短说，那西塞斯是一个非常美丽的年轻人。然而，他拒绝了所有浪漫的追求，尽管他受到男人和女人的钦佩。最终，他爱上了自己在溪水中的倒影，并在余生一直凝视着它。</p><p id="4336" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，亲爱的，你最好喜欢希腊神话，因为我将通过水仙神话向你介绍Java反射。我将向您展示如何获取表示Java类型的给定类的基本数据。特别是关于它包含的方法和字段、它扩展的类以及它实现的接口的信息。</p><p id="1df9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们走吧！</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="ece8" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">Java反射简介</h1><p id="2361" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">一般来说，Java反射是一个JVM特性，它让我们可以在运行时访问关于应用程序的类和对象的信息。这是俗话所说的特征之一:</p><blockquote class="ln"><p id="41ce" class="lo lp hi bd lq lr ls lt lu lv lw ki dx translated">“权力越大，责任越大”——这是一句古老的格言</p></blockquote><p id="28b9" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh ki hb bi translated">换句话说，除非万不得已，否则不要使用它(很好的开端！).使用反射的风险主要来自于使代码难以维护和降低执行速度。但是，嘿，每个倒影都有两张脸，对吧？有一些广泛使用的框架利用了Java反射，比如Junit、Spring的beans和不同的ORM解析器。约束这些框架的是它们都处理“未知”类的事实。我的意思是，框架不知道它将要处理的类。</p><p id="4b8c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我在想，也许“未知”是让那西塞斯的死如此戏剧化的原因(在一个版本中，他自杀了，在另一个版本中，他试图亲吻自己的倒影时淹死了)。根据神话，那西塞斯被预言了许多年的生命，只要他没有看到自己。我是说，他不知道自己长什么样，直到他来到小溪边解渴。很奇怪，但关键是他一看到自己，就暗恋自己的倒影。不久之后，那西塞斯因单恋而死去…</p><p id="c964" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">无论如何，反射是一个非常酷的特性，所以让我们看看它的一些基本可能性。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="d307" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">反射API网关</h1><p id="796a" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">在Java中,<code class="du mc md me mf b">Class&lt;?&gt;</code>是反映应用程序代码的入口点。该对象包含关于其运行时类型的所有信息。</p><p id="db2b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有几种方法可以获得<code class="du mc md me mf b">Class&lt;?&gt;</code>对象。第一种方法是使用对象实例的<code class="du mc md me mf b">.getClass()</code>方法。</p><p id="7d49" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以下是三个不同具体对象的示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0bec" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以对它们中的每一个调用<code class="du mc md me mf b">.getClass()</code>方法，并获得由<code class="du mc md me mf b">Class&lt;?&gt;</code>对象表示的各自的运行时类型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="fe89" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意，在map对象的情况下，调用将返回<code class="du mc md me mf b">HashMap</code>类，而不是它的<code class="du mc md me mf b">Map</code>接口。</p><p id="1576" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">顺便说一下，原始类，如<code class="du mc md me mf b">boolean</code>、<code class="du mc md me mf b">int</code>和<code class="du mc md me mf b">double</code>，不是对象，也不是<code class="du mc md me mf b">Object</code>类的继承。因此，将<code class="du mc md me mf b">.getClass()</code>应用到原语类会引起编译错误🤭。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="0118" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">另一种获得<code class="du mc md me mf b">Class&lt;?&gt;</code>对象的方法是在类型名后面附加一个<code class="du mc md me mf b">.class</code>。当我们没有实例，但无论如何需要特定类型的信息时，这种方法很有用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="cd04" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这种方式最本质的一点是，它是获取原始类型 <code class="du mc md me mf b">Class&lt;?&gt;</code>对象的<strong class="jp hj">唯一方式</strong> <strong class="jp hj">。</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5842" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们开始检查类成员的方法参数，例如，它肯定可以是一个原始类型，我们必须能够获得Java中所有类型的完整信息，而不仅仅是类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="344d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">获得<code class="du mc md me mf b">Class&lt;?&gt;</code>的另一种方法是使用静态<code class="du mc md me mf b">Class.forName(…)</code>。通过这种方法，我们可以使用类路径的完全限定名动态地查找任何类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="8964" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">看一看被截取的最后一行代码。我们可以通过在外部和内部类之间使用<code class="du mc md me mf b">$</code>来访问内部类。</p><p id="f1f0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，这种获取<code class="du mc md me mf b">Class&lt;?&gt;</code>的方法是所讨论的三种方法中最不安全的。因为您更有可能打错字或提供不存在的类名。如果采取这些动作中的任何一个<code class="du mc md me mf b">ClassNotFoundException</code>将被抛出(nu shoin…)。然而，在一些用例中，寻找类型的<code class="du mc md me mf b">Class&lt;?&gt;</code>对象的<code class="du mc md me mf b">Class.forName(…)</code>方法是我们唯一的选择。</p><p id="4c66" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一个这样的用例是当我们想要在运行时检查的类型从用户定义的配置文件中传递过来时。使用这种方法，用户可以简单地通过改变外部文本文件来改变应用程序的行为。源代码被提醒没有变化，不应该重新编译。</p><p id="9479" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">方法的另外一个用例是当我们想要反映的类甚至不是我们项目的一部分时。换句话说，当我们编译代码时，这个类并不存在。但是，它会在运行时添加到应用程序的类路径中。如果我们在构建一个独立于将要导入和使用它的应用程序的库，这种情况是很有用的。</p><p id="375a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于不存在的东西，我以反思的心态回到了水仙。很奇怪，一个到了恋爱年龄的男人竟然认不出自己的影子🤨。一个合理的解释是，那西塞斯爱上的是他的同卵双胞胎姐姐，而不是他自己(事实上这很正常)。她死后，那西塞斯非常哀悼她，以至于他会去河边看自己的倒影。尽管他认出了那个人是他自己，他仍然能够瞥见他所爱的人的形象。好吧，我可以买。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="f162" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在来说一个问号<code class="du mc md me mf b">&lt;?&gt;</code>。</p><h1 id="85d7" class="kq kr hi bd ks kt mi kv kw kx mj kz la io mk ip lc ir ml is le iu mm iv lg lh bi translated">Java通配符</h1><p id="eec4" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">复习一下Java泛型，尽管类<code class="du mc md me mf b">Integer</code>扩展了<code class="du mc md me mf b">Number</code>，但<code class="du mc md me mf b">List&lt;Number&gt;</code>不是<code class="du mc md me mf b">List&lt;Integer&gt;</code>的超类。同理，虽然类<code class="du mc md me mf b">String</code>实现了<code class="du mc md me mf b">CharSequence</code>，但是<code class="du mc md me mf b">List&lt;CharSequence&gt;</code>并不是<code class="du mc md me mf b">List&lt;String&gt;</code>的超类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/7658eda060339f41f05ef28cfecbc631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9futT2YUnUgBtyYqtRz9Xw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Java Generics</figcaption></figure><p id="c01c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们很酷？现在，<code class="du mc md me mf b">List&lt;?&gt;</code>是任何泛型类型的<code class="du mc md me mf b">List</code>的超类型。我的意思是，<code class="du mc md me mf b">List&lt;?&gt;</code>是<code class="du mc md me mf b">List&lt;T&gt;</code>的超类，对于任何泛型参数t。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/81794c7f6acf15f7f62e5aaeb82892cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6hCzAS2_ZCtqAlq3LO1epg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Java Wildcard</figcaption></figure><p id="8442" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这种关系对于任何泛型类型都是成立的，包括<code class="du mc md me mf b">Class</code>，它也是泛型。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/5d707da7a3521a16dfe8ca6ec9b4dca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*Od2ya7ejHJon2jiLGsP1ZQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Class Wildcard</figcaption></figure><p id="9a62" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当编译器不知道确切的泛型类型时，定义通配符的能力非常有用，比如在<code class="du mc md me mf b">Class.forName(com.genezeiniss.Narcissus.java)</code> return的情况下。通配符的另一个用途是当<code class="du mc md me mf b">Class</code>的通用参数是通用类型本身时:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="e1e0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们从理论转向实践。</p><h1 id="573c" class="kq kr hi bd ks kt mi kv kw kx mj kz la io mk ip lc ir ml is le iu mm iv lg lh bi translated">实践中的Java反思</h1><p id="f0c4" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">在这一部分，我将向您展示<code class="du mc md me mf b">Class&lt;?&gt;</code>对象可以为我们提供什么样的数据。为此，让我们用一个方法<code class="du mc md me mf b">destiny()</code>定义我们自己的接口<code class="du mc md me mf b">NarcissusAdmirer</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="e6cc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">水仙神话有几个从古代流传下来的版本。其中一个版本讲述了艾可和那西塞斯的故事。爱蔻深深地爱着那西塞斯，有一天她试图拥抱他。那西塞斯拒绝了她的求爱，彻底摧毁了她的心。被蔑视的回声在孤独的幽谷中度过了她的余生，直到她只剩下回声的声音。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="19b7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">另一个版本告诉我们一个名叫阿梅尼亚斯的年轻人爱上了那西塞斯。那西塞斯有拒绝男性求婚者的习惯，他也拒绝了阿梅尼亚斯。此外，他给了他一把剑(可能是为了引导他采取一些行动)。阿梅尼亚斯在那西塞斯的门口自杀了(我猜是用剑)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="699b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，让我们创建一个<code class="du mc md me mf b">printClassInfo()</code>方法，它聚集了<code class="du mc md me mf b">Class&lt;?&gt;</code>对象的基本能力。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="1858" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">嗯，正如您可能看到的，您可以获得一些关于您的<code class="du mc md me mf b">Class&lt;?&gt;</code>对象的信息，比如简单名称、包和超类。此外，您可以确定您的类是否是数组、原语、接口、匿名类等等。</p><p id="055b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，尝试在<code class="du mc md me mf b">Echo.class</code>上运行该方法，您将收到以下信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="cb25" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们很酷？现在，试着为不同类型的类运行这个方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="3dc4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意，基本类型不属于任何包。因此，对于<code class="du mc md me mf b">boolean.class</code>和<code class="du mc md me mf b">int[][].class</code>，包装名称将被打印为“无名称”。</p><p id="74c3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，让我们创造一些匿名的仰慕者(我害怕去想他的命运。让我们说这是积极的事情，改变一下)，并检查我们可以接收到什么信息。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="d4ca" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个测试的输入中，您将看到类名将是<code class="du mc md me mf b">null</code>并且<code class="du mc md me mf b">.isAnonymousClass()</code>将返回true。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="3059" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">待续🤓</p><p id="8608" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我的<a class="ae mq" href="https://github.com/genezeiniss/java-reflection" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中查看这个故事的源代码。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="27b5" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">附言</h1><p id="f923" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">水仙尾也有不同的版本。在一个故事中，他从内心燃烧的激情之火中融化，在另一个故事中，他自杀了。然而，在所有版本中，他的身体消失了，留下的只是一朵水仙花🌼。</p></div></div>    
</body>
</html>
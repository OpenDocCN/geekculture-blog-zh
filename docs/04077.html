<html>
<head>
<title>Numerical methods in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的数值方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/numerical-methods-in-c-1c8ef1160c2b?source=collection_archive---------18-----------------------#2021-06-21">https://medium.com/geekculture/numerical-methods-in-c-1c8ef1160c2b?source=collection_archive---------18-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/322f4147bff60f2dc8cf72bd27e8eb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rze5a5jVlJ2Q_AvgXYfDdw.png"/></div></div></figure><div class=""/></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="3558" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">数值方法通常用于求解自然和物理现象的数学模型。每个问题都能精确解决。在这种情况下，我们可以说我们解析地解决了问题，或者我们的解决方案是近似的。以前，数值方法用于求解非常简单的数学模型，然而，计算能力(如FPGA、CPU、GPU或TPU)的增加影响了数值计算的利用的增加，以求解复杂的模型，有时由高维非线性方程描述。当计算机被用来为一个特定的数学模型(可以用数学方程建模的问题)寻找解决方案时，我们可以说使用了数值方法。C++中的数值方法将在两篇独立的文章中讨论。接下来的部分将涵盖基础知识。另一部分将涵盖数值计算领域更高级的方面。</p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="2ed4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在下面的文章中，我使用了c++ (克隆报告)的<a class="ae jv" href="https://github.com/lava/matplotlib-cpp" rel="noopener ugc nofollow" target="_blank"> matplotlib库。这是一个非常简单的库，允许你绘制数据。该库是非常著名的</a><a class="ae jv" href="https://matplotlib.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Python库</a>的API。不需要安装，只需要一个头文件。为了使用这个库，你需要首先检查你的Python版本和路径。您还需要为您拥有的Python版本安装matplotlib(例如使用pip)。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="a587" class="kf kg ht kb b fi kh ki l kj kk">#on terminal type</span><span id="072c" class="kf kg ht kb b fi kl ki l kj kk">:~$ whereis python   //you receive version of Python and paths</span><span id="860e" class="kf kg ht kb b fi kl ki l kj kk">:~$ pip3 install matplotlib //Python 3</span><span id="5aec" class="kf kg ht kb b fi kl ki l kj kk">:~$ pip install matplotlib //Python 2</span></pre><p id="8f24" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">你很容易编译每个程序，但是记住(在这里)头文件必须和你的cpp在同一个文件夹中。您也可以修改标题路径。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="9fd4" class="kf kg ht kb b fi kh ki l kj kk">//compile<br/>g++ my_prog.cpp -o my_prog -I/usr/include/python3.8 -lpython3.8</span><span id="58fa" class="kf kg ht kb b fi kl ki l kj kk">// run<br/>./my_prog</span><span id="68ab" class="kf kg ht kb b fi kl ki l kj kk">//folder tree</span><span id="315b" class="kf kg ht kb b fi kl ki l kj kk">.<br/>├── my_prog<br/>├── my_prog.cpp<br/>├── matplotlibcpp.h</span></pre></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="7ddc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hu">迭代</strong></p><p id="f432" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">数值计算中最常用的运算之一是迭代。你确切知道的迭代，可以表示为一组重复的相同操作，直到满足终止条件。通常我们设定的条件是通过定义期望解的精度(误差)来给出的。</p><p id="2e3b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">迭代法是求方程根的常用方法。这里我将介绍常用的<a class="ae jv" href="https://en.wikipedia.org/wiki/Newton%27s_method#Square_root" rel="noopener ugc nofollow" target="_blank">牛顿法</a>。所提出的方法的基本版本可以定义如下(在下一篇文章中提出的所有方程的乳胶版本，你将在<a class="ae jv" href="https://gist.github.com/markusbuchholz/b72af57f726a569a4c98675fe1d9a204" rel="noopener ugc nofollow" target="_blank">我的要点</a>中找到)。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div class="er es km"><img src="../Images/f7224152eb445ad05e41d07a04532de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*YboARC-5XVXF-fKKWMuDBw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq1 by author</figcaption></figure><p id="2c8a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如你所见，我们找到了函数的导数<em class="kr">f′</em>的下一个值，以及<em class="kr"> f </em>的前一个根。当终止条件(精度)满足时，我们运行迭代过程。</p><p id="4cd6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下面的例子让您有机会熟悉讨论方法。这个例子解了一元二次方程。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div class="er es ks"><img src="../Images/3ee5328cb32e2b53d54dc35e27f12c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*NCSW9MORd-kH5Thk6XqCUw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq2 by author</figcaption></figure><p id="b83a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">请参考示例并适应您的条件。</p><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="a9d0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们也可以画出程序如何接近解决方案。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/e214390d04a488db86ceae5175a2f296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwJxJgNfvsiQwNz-gMNBZw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="685c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们还可以应用于更复杂方程，如高阶多项式(这里是三阶):</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kw"><img src="../Images/d5c675a38ed8008df94b05c3d5b9fd55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Erb6_1BfoD3RdGmUxfzrA.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq3 by author</figcaption></figure><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="71cf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们也可以画出程序如何接近解决方案。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kx"><img src="../Images/7278652ed10363034dbccd19479b6b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GraB36TceftHMekRawAwfw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="7605" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hu">插值</strong></p><p id="22c0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">大多数以数字形式存储的函数(例如存储在你的个人电脑上的计算结果)对于相关函数的特定域具有离散值。这意味着我们只在特定的x(n)和x(n+1)点上有函数值，而在这两点之间没有值(例如x(0.5n))。<br/>计算这个数值的数学方法叫做<strong class="iz hu"> </strong> <a class="ae jv" href="https://en.wikipedia.org/wiki/Interpolation" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu">插值</strong> </a>。还有<a class="ae jv" href="https://en.wikipedia.org/wiki/Extrapolation" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu">外推</strong> </a>，可以解释为一种估计——在已有值的基础上寻找新值。</p><p id="df6e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在下图中，你可以看到离散正弦(x)函数。函数只在某一点上确定(有值)。我们将对另一个函数进行插值，并找出其间的值。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ky"><img src="../Images/e6d64d434b0c9ea438af37d0ae510f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPVhwwQTj8jBu3chDFzBMQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><p id="c866" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hu">对于插值我们主要可以采用四种不同的方法:</strong> <a class="ae jv" href="https://en.wikipedia.org/wiki/Newton_polynomial" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu">牛顿</strong></a><strong class="iz hu"/><a class="ae jv" href="https://en.wikipedia.org/wiki/Polynomial_interpolation" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">拉格朗日</strong></a><strong class="iz hu"/><a class="ae jv" href="https://en.wikipedia.org/wiki/Chebyshev_nodes" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">切比雪夫</strong> </a> <strong class="iz hu">和</strong> <a class="ae jv" href="https://en.wikipedia.org/wiki/Interpolation#Spline_interpolation" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu">样条插值</strong> </a>。下面的例子描述了拉格朗日方法。</p><p id="c7fa" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">根据维基百科，我们可以找到基于已知节点值的多项式。我们使用下面的公式计算n阶多项式。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kz"><img src="../Images/790c4ddd50e8fe92832219ce36f52d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgHMX4OIIgKVNdNLsNBV9Q.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq4 by author</figcaption></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="460e" class="kf kg ht kb b fi kh ki l kj kk">|i | x_i |f(x_i)|<br/>|---------------|<br/>|0 |  1  |  1   |<br/>|1 |  2  |  3   |<br/>|2 |  4  |  7   |<br/>|3 |  8  |  11  |</span></pre><p id="e5d1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">对于这些特定的(已知的)节点值<em class="kr"> f(x_i) </em>我们可以计算(使用上述拉格朗日方法)插值。让我们假设，我们想知道x = 6的值。我们使用如下算法:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="7c6c" class="kf kg ht kb b fi kh ki l kj kk">f(6) = f(1)*[(6-2)(6-4)(6-8)]/[(1-2)(1-4)(1-8)]+<br/>       f(2)*[(6-1)(6-4)(6-8)]/[(2-1)(2-4)(2-8)]+<br/>       f(4)*[(6-1)(6-2)(6-8)]/[(4-1)(4-2)(4-8)]+<br/>       f(8)*[(6-1)(6-2)(6-4)]/[(6-1)(6-2)(6-4)] = 10.0476</span><span id="5eae" class="kf kg ht kb b fi kl ki l kj kk">// you can check computed value by running below code (values for different node will be computed and displayed)</span></pre><p id="36a2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">讨论方法的源代码如下所示。请对特定函数的部分进行注释和取消注释(上述示例中的一个函数，正弦函数和二次函数)。</p><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="kt ku l"/></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="de76" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下面的曲线是通过运行最后一个源cpp代码创建的。请注意，蓝色曲线代表已知节点，但是红色曲线是使用拉格朗日插值方法计算的。某些曲线的结果不能令人满意，特别是在插值结束时。该问题与应用插值多项式的高阶插值有关。关于这种现象的更多讨论在这里<a class="ae jv" href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon#:~:text=In%20the%20mathematical%20field%20of,set%20of%20equispaced%20interpolation%20points." rel="noopener ugc nofollow" target="_blank">龙格现象</a>中进行。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/75bb91b9eeaa3be3a19612243e9e1ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhysoWIPubRHaVeHPqdYfw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/b546794e6322611e5153725a5a314f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8azFsevV4bwZc-fbNkYefw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/2b85fd7a8b4ffb4da0ca6c1242ff7edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOaO9nCPii04UyJzEiNWkg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><p id="7fc6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hu">数值积分</strong></p><p id="0a64" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><a class="ae jv" href="https://en.wikipedia.org/wiki/Numerical_integration" rel="noopener ugc nofollow" target="_blank">数值积分</a>是一套计算定积分数值的方法。有了一个函数<em class="kr"> f(x) </em>我们就能够估计这个函数在给定区间内的值。<br/>用于数值计算积分值的大多数算法使用函数的加法特性，可写成如下:</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/c05e39f017a62babfae0a82cb3dc0216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0LWZCseCpkolOkBYshlwQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq5 by author</figcaption></figure><p id="4a45" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如你所见，我们可以将定义的函数区间分割成小的区间，计算积分(较短的区间)，最后求和。<br/>如果下面的文章我们将使用到不同的算法:<strong class="iz hu">矩形法</strong>和<strong class="iz hu">梯形法。</strong></p><p id="0685" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在矩形法中，函数的区间由小矩形划分。我们的工作是计算矩形的面积，最后对所有计算出的矩形面积求和。所讨论的方法使用下面的公式来计算特定函数和区间的积分。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/668e57b1d1354bef5836712ee4185ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbBI_72PQ2MDFm-CTO9rDg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq6 by author</figcaption></figure><p id="18f7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">更精确的方法不是应用矩形而是梯形。在该罐中，必须应用以下数值公式。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es le"><img src="../Images/7a946f3074545e35dfa99f3779f96c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOnRXrqVIdFzPSBLtuIvzg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq7 by author</figcaption></figure><p id="86d9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">上述等式已应用于以下代码中。该程序使用半径等于1的圆的面积公式来计算圆周率的值。我描述了两种讨论过的方法，可以一个接一个地绘制出来。如果是这样，请在下面的文件中注释和取消注释代码的某些部分。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/5c7e5773334fa59de77dff431c0f3b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ei_2T60F2hshfhoSpP443Q.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq8 by author</figcaption></figure><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="485d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下图描述了算法如何以逗号后9个数字的精度逼近解。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/b8d1415fc4169772b6a1d967cd83451a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iuzcQDgvQqIrensasemAvQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/1a9406614052488a84ca88dc0d87de1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZAuTRHK3MqEpgFOIaDXDA.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><p id="bb0b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hu">数值微分</strong></p><p id="aa39" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><a class="ae jv" href="https://en.wikipedia.org/wiki/Numerical_differentiation" rel="noopener ugc nofollow" target="_blank">数值微分</a>是一套计算定义点的导数数值的方法。在这种情况下，数值计算是愿意使用的，因为计算某些函数的导数存在一定的困难。我们也使用数值方法，其中我们只知道函数值域的离散值。<br/>计算导数的最简单方法是牛顿法，可表示如下(在我们的例子中，我们可以通过计算中心差商来近似计算导数，h是一个小的差商):</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es li"><img src="../Images/b2ec39fcef15ac3da897d87a46d98d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SI_2L_q2R0fMWJrITZY5vA.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">eq9 by author</figcaption></figure><p id="658f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下面的代码实现了讨论的牛顿法，并计算多项式三阶导数。请随意修改您选择的功能。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/13e01d64593a3984d0a6784a973afec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNr2hp-qPFyyd6fLkUe2Kg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">by author</figcaption></figure><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="edb6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
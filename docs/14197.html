<html>
<head>
<title>Composition vs. Inheritance: Pros and Cons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合成与继承:利弊</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/composition-vs-inheritance-pros-and-cons-ff1797d72f68?source=collection_archive---------7-----------------------#2022-08-20">https://medium.com/geekculture/composition-vs-inheritance-pros-and-cons-ff1797d72f68?source=collection_archive---------7-----------------------#2022-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3d6c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">组合和继承在面向对象编程中的位置？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ffde06ddba5940625a61633a56a1ed1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLGv0H4_EdCV5iG868vQJQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@grstocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">GR Stocks</a> on <a class="ae jn" href="https://unsplash.com/s/photos/battle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cd90" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本教程将查看<code class="du kk kl km kn b">inheritance </code>和<code class="du kk kl km kn b">composition</code>，这是正确的用例。示例代码是用Java编写的，但是基本原理对于所有支持面向对象编程(OOP)的编程语言都是一样的。在开始之前，我们首先要理解这些术语。先说继承。</p><h2 id="11ad" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">定义</h2><blockquote class="lj lk ll"><p id="4f7e" class="jo jp lm jq b jr js ij jt ju jv im jw ln jy jz ka lo kc kd ke lp kg kh ki kj hb bi translated">在面向对象编程中，<strong class="jq hj">继承</strong>是将一个对象或类基于另一个对象(基于原型的继承)或类(基于类的继承)的机制，保留了类似的实现。— <a class="ae jn" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="3b2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有大量的英语在进行，但就其简单的意义而言，继承使得一个类将其功能扩展到其他类成为可能。它模仿了我们在现实世界中所称的遗传，即孩子从父母那里获得特征。</p><p id="3840" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不出所料，扩展另一个类的类被称为<em class="lm">子类</em>或<em class="lm">子类</em>，被扩展的类是<em class="lm">父类</em>或<em class="lm">超类</em>(都是双关语)。继承有一个<em class="lm">“is-a”</em>关系。</p><p id="6b83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，狮子来自猫科动物，所以狮子是一只猫。鬣狗也一样。它们都有爪子，并继承了捕食的本能。然而，每一种都有区别于其他产品的独特特征。它是OOP中的典型子类，有不同的方法专门针对它们。</p><p id="55f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">构图包括组成整体的部分。没有方向盘、引擎或座椅的汽车是不完整的。为此，我们说一辆汽车<em class="lm">“有——一个”</em>方向盘。继承和组合之间第一个值得注意的区别是“is-a”和“has-a”的关系。</p><p id="584b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们创建三个类，看看它们是如何通过继承相互关联的。</p><h2 id="d8af" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">诉讼继承</h2><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="9313" class="ko kp hi kn b fi lu lv l lw lx">public abstract class Employee {<br/>    private String firstName;<br/>    private String lastName;<br/>    private String accountNumber;<br/>    private Double salary;<br/>    private Date hireDate;</span><span id="7d2c" class="ko kp hi kn b fi ly lv l lw lx">    // constructor<br/>    public Employee (<br/>        String firstName,<br/>        String lastName, <br/>        String accountNumber,<br/>        Double salary, <br/>        Date birthDate,<br/>        Date hireDate<br/>    ) {<br/>      this.firstName = firstName;<br/>      this.lastName = lastName;<br/>      this.accountNumber = accountNumber;<br/>      this.salary = salary;<br/>      this.hireDate = hireDate;<br/>  }<br/>  // setters and getter are omitted for brevity<br/>   abstract Double earnings();<br/>}</span></pre><p id="b4fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码是一个简单的抽象Plain Old Java Object (POJO ),有五个实例变量、一个初始化所有变量的构造函数和一个抽象的收益方法。Java要求子类有一个构造函数，以便在对象实例化期间调用它。我们显式地创建了构造函数来传递所有的实例变量作为参数。</p><p id="3462" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请密切注意我们在这里使用的私有访问修饰符以及它们对应的setters和getters。我们选择private作为OOP最佳实践的一部分，以避免破坏封装。</p><p id="44e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注意</strong>:这不是关于OOP的教程，所以我将把详细的解释推迟到后面的博客。</p><p id="3d24" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们创建两个子类，FullTimeEmployee和ContractEmployee。</p><h2 id="bb67" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">全职员工类别</h2><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="37e3" class="ko kp hi kn b fi lu lv l lw lx">class FullTimeEmployee extends Employee {<br/>    private Double overtimeAllowance;</span><span id="628d" class="ko kp hi kn b fi ly lv l lw lx">    public FullTimeEmployee(<br/>        String firstName,<br/>        String lastName,<br/>        String accountNumber,<br/>        Double salary,<br/>        Date hireDate<br/>    ) {<br/>        super(<br/>            firstName, <br/>            lastName,<br/>            accountNumber,<br/>            salary, <br/>            birthDate, <br/>            hireDate<br/>        );<br/>        this.overtimeAllowance = overtimeAllowance;<br/>  }</span><span id="be93" class="ko kp hi kn b fi ly lv l lw lx">    @Override<br/>    public Double earnings() {<br/>        return getSalary() + getOvertimeAllowance();<br/>   }<br/>}</span></pre><p id="c10d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码片段是一个子类，它扩展了Employee类并覆盖了code方法，这里没什么特别的。它还有一个额外的实例变量，<em class="lm">“overtime allow ance”，</em>，它使用这个变量的getter来计算收益。</p><p id="1d2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们看看另一个子类。</p><h2 id="8e95" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">合同雇员类</h2><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="b150" class="ko kp hi kn b fi lu lv l lw lx">class ContractEmployee extends Employee {<br/>    public ContractEmployee(<br/>        String firstName,<br/>        String lastName,<br/>        String accountNumber,<br/>        Double salary) {<br/>        super(<br/>            firstName,<br/>            lastName,<br/>            accountNumber,<br/>            salary<br/>        );<br/>  }</span><span id="ff80" class="ko kp hi kn b fi ly lv l lw lx">    @Override<br/>    public Double earnings() {<br/>        return getSalary();<br/>    }<br/>}</span></pre><p id="b971" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这段代码看起来与<em class="lm">全职雇员</em>类几乎相同。唯一的区别是，它没有额外的领域和计算收入的方法不同。</p><h2 id="3fdd" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">抽象类中一个简单变化的连锁反应</h2><p id="bbe6" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">让我们假设在一次例行的财务审计后，审计人员发现公司因为虚名而亏损，所以他们决定补救这种情况。软件架构师想出了一个绝妙的策略，通过引入另一个实例变量<em class="lm">“is account expired”</em>来防止向已经离开公司的员工持续支付工资，从而帮助解决这个问题。</p><p id="de2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个单一的变化需要修改超类及其所有伴随的子类。让我们根据新要求进行如下更改:</p><p id="1d44" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注意</strong>:这段代码中只有类定义、方法签名和新的变化。各处的省略号<em class="lm">“…”</em>表示代码延续。</p><p id="09cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">新<em class="lm">员工</em>班</p><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="db79" class="ko kp hi kn b fi lu lv l lw lx">// superclass<br/>public class Employee {<br/>    ...<br/>    private Boolean isAccountExpired; // new instance variable here</span><span id="76a0" class="ko kp hi kn b fi ly lv l lw lx">    // constructor<br/>    public Employee (<br/>        ... // ellipse denote continuation<br/>        Boolean isAccountExpired // change here<br/>    ) {<br/>        ... <br/>        this.isAccountExpired = isAccountExpired; // change here<br/>}</span></pre><p id="8182" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">新的<em class="lm">全职员工类别</em></p><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="ba4d" class="ko kp hi kn b fi lu lv l lw lx">// subclass 1<br/>public class FullTimeEmployee extends Employee {<br/>      // constructor<br/>    public FullTimeEmployee (<br/>        ...<br/>        Boolean isAccountExpired // change here</span><span id="f483" class="ko kp hi kn b fi ly lv l lw lx">        super(<br/>            firstName,<br/>            lastName,<br/>            accountNumber,<br/>            salary,<br/>            birthDate,<br/>            hireDate,<br/>           isAccountExpired<br/>        );<br/>}</span></pre><p id="8df9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">新的<em class="lm"> ContractEmployee </em>子类</p><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="4aed" class="ko kp hi kn b fi lu lv l lw lx">// subclass 2<br/>public class ContractEmployee extends Employee {<br/>      // constructor<br/>    public FullTimeEmployee (<br/>        ...<br/>        Boolean isAccountExpired // change here</span><span id="686a" class="ko kp hi kn b fi ly lv l lw lx">        super(<br/>             firstName,<br/>             lastName,<br/>             accountNumber,<br/>             salary,<br/>             birthDate,<br/>             hireDate,<br/>             isAccountExpired<br/>           ); // change here<br/>}</span></pre><p id="4970" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你明白意思了吗？超类中的一个简单变化会影响层次链中的所有子类。我们的用例只有两个子类，所以没什么大不了的。想象一下，从Employee类继承的大型代码库中有数百个子类。你的猜测和我的一样好。</p><p id="7117" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们以不同的方式做事。我们将accountNumber提取到它的类中，并将其传递给Employee类。有了这个变化，我们就可以深入到<em class="lm">“has-a”</em>关系的领域了。</p><h2 id="b2ee" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">动作合成</h2><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="e70c" class="ko kp hi kn b fi lu lv l lw lx">class Account {<br/>    private final String id;<br/>    private Double balance;<br/>    private Boolean isExpired;</span><span id="b580" class="ko kp hi kn b fi ly lv l lw lx">    public Account(<br/>        String id,<br/>        Double balance,<br/>        Boolean isExpired<br/>    ) {<br/>       this.id = id;<br/>       this.balance = balance;<br/>       this.isExpired = isExpired;<br/>    }<br/>    // setters and getters left for brevity<br/>}</span></pre><p id="debd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码是一个简单的account类，有三个实例变量和一个构造函数。</p><p id="5387" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们相应地修改雇员类。在下面查找具有最新更改的源代码:</p><pre class="iy iz ja jb fd lq kn lr ls aw lt bi"><span id="6935" class="ko kp hi kn b fi lu lv l lw lx">public abstract class Employee {<br/>    private String firstName;<br/>    private String lastName;<br/>    private Double salary;<br/>    private Date hireDate;<br/>    private Account account;</span><span id="1822" class="ko kp hi kn b fi ly lv l lw lx">    public Employee (<br/>        String firstName,<br/>        String lastName,<br/>        Double salary,<br/>        Date hireDate,<br/>        Account account<br/>    ) {<br/>        this.firstName = firstName;<br/>        this.lastName = lastName;<br/>        this.salary = salary;<br/>        this.hireDate = hireDate;<br/>        this.account = account;<br/>    }<br/>  // setters and getter are omitted for brevity<br/>  abstract Double earnings();<br/>}</span></pre><p id="dc4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事后看来，我们写的代码比我们已经有的要多。那么有什么问题呢？为什么我们试图通过引入整个<em class="lm"> Account </em>类来解决继承问题？</p><p id="c506" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你沿着这些思路思考，你的担心是有道理的。您最初编写了相当多的代码，但是随着需求的不断变化，这就是组合的闪光点。</p><p id="3f8e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们上次的Sprint规划中，产品负责人告诉我们，用户希望在他们的<em class="lm"> Account </em>类中有一个<em class="lm"> name </em>字段。我们只修改account类，其他类保持不变。</p><h2 id="809f" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">继承的优势</h2><p id="be11" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">假设你能保证你设置数据的唯一地方是从一个对应的<em class="lm"> set </em>方法和get方法获取数据。在这种情况下，您可以减少调试代码所花费的时间，因为您知道只有那些方法负责操作这样的数据。</p><p id="aeaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当您决定修改方法的实现细节时，这也很方便。你只需要改变方法，而不是对代码库的超类和子类中的许多不同地方进行修改。</p><p id="c1bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后但同样重要的是，如果你确定你永远不会修改你的超类，继承可能是正确的选择。它减少了写作所需的额外课程的数量。</p><h2 id="6f74" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">继承的缺点</h2><blockquote class="lj lk ll"><p id="a221" class="jo jp lm jq b jr js ij jt ju jv im jw ln jy jz ka lo kc kd ke lp kg kh ki kj hb bi translated">“继承是实现代码重用的一种强有力的方法，但它并不总是这项工作的最佳工具。使用不当，会导致软件脆弱。”——《有效的Java 》,作者约书亚·布洛克。</p></blockquote><p id="283b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上面的例子中，很明显子类与超类紧密耦合，这违反了<em class="lm">中的<em class="lm"> O </em>固体</em>原则。超类中的更改会中断更改，直到它的所有后代都被相应地修改。避免不必要的紧耦合的最好方法是尽可能引入组合。</p><p id="0e8f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，组合极大地增强了代码重用。任何想要使用Account类的类都可以自由地这样做，因为它具有松耦合的特性。将它作为引用传递，我们可以调用account的所有公共方法，这些方法以前是不存在的。</p><p id="cf22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个支持组合胜过继承的好理由是单元测试。如果一个<em class="lm"> Account类的实例是未知的，我们可以用一些假数据模拟它，然后继续我们的测试。这种方法比继承方法更容易。</em></p><h2 id="eb9c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">结论</h2><p id="bc00" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">这个教程告诉我们什么是继承和合成，以及它们的区别。总之，尽可能使用复合，只保守地使用继承。合成的主要缺点是你要写的代码行数。然而，从长远来看，代码的松散耦合和灵活性弥补了这一点。</p><p id="1e95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这篇文章，请关注我的handle <a class="ae jn" rel="noopener" href="/@jessebrite"> Bright </a>了解更多关于软件开发和一般技术的故事。</p></div></div>    
</body>
</html>
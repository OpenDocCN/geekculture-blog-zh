<html>
<head>
<title>Building a SaaS Project Week Five: Processing Payments With Stripe and Webhooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SaaS项目第五周:用Stripe和Webhooks处理支付</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-saas-project-week-five-processing-payments-with-stripe-and-webhooks-89078bbd8d4f?source=collection_archive---------19-----------------------#2021-04-29">https://medium.com/geekculture/building-a-saas-project-week-five-processing-payments-with-stripe-and-webhooks-89078bbd8d4f?source=collection_archive---------19-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="301a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本周的主题是用Stripe处理信用卡支付。我们着眼于创建一个会话并订阅webhooks，以便了解用户何时购买了一门课程。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5afdf8085ed8baf29f39e99af2d698c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_p3rn_tdyPR0C0NCNQwCEg.png"/></div></div></figure><p id="bd3b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://github.com/dijonmusters/courses" rel="noopener ugc nofollow" target="_blank">项目回购</a></p><p id="3650" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本周的主题是用Stripe支付。我们将实现一个无服务器的功能来收费卡，并实现webhooks来更新Prisma用户购买的课程。</p><h2 id="deb2" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">扩展用户模式</h2><p id="7b4b" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">为了跟踪用户购买了哪些课程，我们需要扩展我们的用户模式，以包含“stripeId”字段。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="dd26" class="kg kh hi lh b fi ll lm l ln lo">// prisma/schema.prisma<br/><br/>model User {<br/>  id           Int           @id @default(autoincrement())<br/>  email        String        @unique<br/>  courses      Course[]<br/>  stripeId     String        @unique<br/>  createdAt    DateTime      @default(now())<br/>}</span></pre><p id="b8ee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将用于将Prisma用户映射到Stripe客户。</p><blockquote class="lp lq lr"><p id="bc20" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">这一修改将暂时中断我们的应用程序，因为“stripeId”现在是必填字段，当我们在应用程序中创建用户时，我们不会设置它。</p></blockquote><p id="88f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创建一个迁移，将这些更改应用到我们的数据库。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="68fa" class="kg kh hi lh b fi ll lm l ln lo">npx prisma migrate dev --name add-stripe-id-to-user --preview-feature</span></pre><h2 id="a67d" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">设置条带</h2><p id="712a" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">你需要做的第一件事是<a class="ae kf" href="https://dashboard.stripe.com/register" rel="noopener ugc nofollow" target="_blank">创建一个条纹账户</a>。</p><p id="4489" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦您创建了一个帐户并登录到您的Stripe仪表盘，您将需要输入您的企业详细信息以激活您的帐户。这将使您能够访问生产API密钥，并允许您处理实际支付。您不需要激活您的帐户来完成这个系列，但如果您想在现实世界中使用它，您可能需要这样做！</p><p id="bde4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要在应用程序中安装两个条带库。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="b3e7" class="kg kh hi lh b fi ll lm l ln lo">npm i stripe @stripe/stripe-js</span></pre><blockquote class="lp lq lr"><p id="42ef" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">“stripe”是一个后端库，我们将使用它来处理支付，而“@stripe/stripe-js”是一个前端库，我们的客户将使用它来启动支付会话。</p></blockquote><p id="5d9c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们需要修改我们的。env文件来添加我们的新API密钥—这些可以在“Get your API keys”面板下的Stripe仪表板中找到。确保您使用“测试”键进行本地开发。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="6315" class="kg kh hi lh b fi ll lm l ln lo">// .env<br/><br/>// other secrets<br/>STRIPE_SECRET_KEY=your-secret-key<br/>NEXT_PUBLIC_STRIPE_PUBLIC_KEY=your-publishable-key</span></pre><blockquote class="lp lq lr"><p id="d151" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">我们必须在前端环境变量前加上“NEXT_PUBLIC_”。不包含它的变量将只对我们的无服务器功能可用。</p></blockquote><p id="0a8d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">遵循相同的逻辑从<a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/hosting-on-vercel-automatic-deploys-with-github-and-configuring-custom-domains" rel="noopener ugc nofollow" target="_blank">托管在Vercel上，自动部署与GitHub和配置自定义域</a>添加秘密在Vercel中——没有这个我们的托管应用将无法工作。</p><p id="a29c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了！现在我们应该有条纹线了！</p><h2 id="6032" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">创建条带客户</h2><p id="6346" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们需要创建一个Stripe客户来跟踪购买情况以及订阅是否有效。我们可以在用户第一次购买时这样做，但是，我们不知道他们是否会购买特定的课程或激活他们的订阅。这将需要我们在每个支付场景中添加一些逻辑，以便在向他们的账户收费之前首先检查是否存在stripe用户。我们可以极大地简化这个逻辑，只需在Prisma用户的同时创建一个Stripe客户，这是新用户首次登录我们的应用程序。</p><p id="cd23" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在Prisma中创建用户之前，让我们修改我们的auth hook来创建一个stripe客户。这样，我们可以使用新创建的条带ID来创建我们的用户。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="707e" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/auth/hooks.js<br/><br/>// other imports<br/>import initStripe from 'stripe'<br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = async (req, res) =&gt; {<br/>  // other auth code<br/>  const customer = await stripe.customers.create({<br/>    email,<br/>  })<br/>  const user = await prisma.user.create({<br/>    data: { email, stripeId: customer.id },<br/>  })<br/>}</span></pre><p id="b52b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">整个文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="6da0" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/auth/hooks.js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>import initStripe from 'stripe'<br/><br/>const prisma = new PrismaClient()<br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = async (req, res) =&gt; {<br/>  try {<br/>    const { email, secret } = JSON.parse(req.body)<br/>    if (secret === process.env.AUTH0_HOOK_SECRET) {<br/>      const customer = await stripe.customers.create({<br/>        email,<br/>      })<br/>      const user = await prisma.user.create({<br/>        data: { email, stripeId: customer.id },<br/>      })<br/>      console.log('created user')<br/>    } else {<br/>      console.log('You forgot to send me your secret!')<br/>    }<br/>  } catch (err) {<br/>    console.log(err)<br/>  } finally {<br/>    await prisma.$disconnect()<br/>    res.send({ received: true })<br/>  }<br/>}</span></pre><p id="60bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">很好，现在每当有新用户登录时，我们都应该创建一个Stripe客户，然后创建一个Prisma用户，该用户引用该客户的ID。</p><h2 id="b955" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">用条纹卡充电</h2><p id="f21b" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">现在，我们希望构建一个无服务器的函数，可以处理特定课程的付款。我们需要告诉这个函数用户正在购买哪个课程，所以将使用一个动态API Route 来传递课程ID。让我们在“/ pages/API/charge-card/[courseId]. js”处创建一个新的无服务器函数。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="e4f7" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>module.exports = async (req, res) =&gt; {<br/>  const { courseId } = req.query<br/>  res.send(`charging card for course ${courseId}`)<br/>}</span></pre><blockquote class="lp lq lr"><p id="b093" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">您可以通过访问“http://localhost:3000/API/charge-card/any-value-you-want”来触发此无服务器功能。在这种情况下，它应该打印出“当然，任何值你想要的充值卡。</p></blockquote><p id="3190" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下一步将是算出这门课我们需要收多少钱。我们可以把它和来自前端的请求一起传递，但是，这很容易被用户修改。</p><p id="c923" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">我们不能相信客户的任何东西！</strong></p><p id="d40d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们给我们的Prisma DB打个电话，了解一下真实的价格。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="5abb" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/><br/>module.exports = async (req, res) =&gt; {<br/>  const { courseId } = req.query<br/>  <br/>  const course = prisma.course.findUnique({<br/>    where: {<br/>      id: parseInt(courseId),<br/>    },<br/>  })<br/><br/>  await prisma.$disconnect()<br/><br/>  res.send(`charging ${course.price} cents for ${courseId}`)<br/>}</span></pre><blockquote class="lp lq lr"><p id="5842" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">我们在这里使用parseInt()将从req的查询中得到的字符串转换成一个整数，这是Prisma所期望的ID。</p></blockquote><p id="ea17" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们想知道购买本课程的用户是谁。这意味着我们希望API路由只能被登录的用户访问。让我们用“withApiAuthRequired”来包装它，并通过他们的会话电子邮件来确定谁是用户。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="f270" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>import { PrismaClient } from '@prisma/client'<br/>import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';<br/><br/>const prisma = new PrismaClient()<br/><br/>module.exports = withApiAuthRequired(async (req, res) =&gt; {<br/>  const { courseId } = req.query<br/>  const { user: { email } } = getSession(req, res)<br/>  <br/>  const course = prisma.course.findUnique({<br/>    where: {<br/>      id: parseInt(courseId),<br/>    },<br/>  })<br/>  <br/>  const user = await prisma.user.findUnique({<br/>    where: {<br/>      email,<br/>    },<br/>  })<br/><br/>  await prisma.$disconnect()<br/><br/>  res.send(`charging ${user.email} ${course.price} cents for ${courseId}`)<br/>})</span></pre><p id="5e50" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们要告诉Stripe我们实际向客户收取的费用。我们通过创建一个行项目列表和一个支付会话来实现这一点。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="29aa" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>//other imports<br/>import initStripe from 'stripe'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = async (req, res) =&gt; {<br/>  // course and user stuff<br/>  <br/>  const lineItems = [<br/>    {<br/>      price_data: {<br/>        currency: 'aud', // swap this out for your currency<br/>        product_data: {<br/>          name: course.title,<br/>        },<br/>        unit_amount: course.price,<br/>      },<br/>      quantity: 1,<br/>    },<br/>  ]<br/><br/>  const session = await stripe.checkout.sessions.create({<br/>    customer: user.stripeId,<br/>    payment_method_types: ['card'],<br/>    line_items: lineItems,<br/>    mode: 'payment',<br/>    success_url: `${process.env.CLIENT_URL}/success`,<br/>    cancel_url: `${process.env.CLIENT_URL}/cancelled`,<br/>  })<br/><br/>  res.json({ id: session.id })<br/>})</span></pre><p id="f9de" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要为stripe提供一个成功和取消url来转发用户。这些需要在“pages/success.js”和“pages/cancelled.js”中创建。此外，我们需要为CLIENT_URL创建一个环境变量。按照前面的步骤将其添加到。env的值为“http://localhost:3000 ”, Vercel中的新secret的值为您托管的URL我的是“https://courses-SaaS . Vercel . app”。</p><p id="b42e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们希望将所有这些封装在一个try/catch块中，以防出错。整个文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="0b6d" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';<br/>import { PrismaClient } from '@prisma/client'<br/>import initStripe from 'stripe'<br/><br/>const prisma = new PrismaClient()<br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = withApiAuthRequired(async (req, res) =&gt; {<br/>  try {<br/>    const { courseId } = req.query<br/>    const { user: { email } } = getSession(req, res)<br/>    <br/>    const course = prisma.course.findUnique({<br/>      where: {<br/>        id: parseInt(courseId),<br/>      },<br/>    })<br/>    <br/>    const user = await prisma.user.findUnique({<br/>      where: {<br/>        email,<br/>      },<br/>    })<br/>  <br/>    const lineItems = [<br/>      {<br/>        price_data: {<br/>          currency: 'aud', // swap this out for your currency<br/>          product_data: {<br/>            name: course.title,<br/>          },<br/>          unit_amount: course.price,<br/>        },<br/>        quantity: 1,<br/>      },<br/>    ]<br/>  <br/>    const session = await stripe.checkout.sessions.create({<br/>      customer: user.stripeId,<br/>      payment_method_types: ['card'],<br/>      line_items: lineItems,<br/>      mode: 'payment',<br/>      success_url: `${process.env.CLIENT_URL}/success`,<br/>      cancel_url: `${process.env.CLIENT_URL}/cancelled`,<br/>    })<br/>  <br/>    res.json({ id: session.id })<br/>  } catch (err) {<br/>    res.send(err)<br/>  } finally {<br/>    await prisma.$disconnect()<br/>  }<br/>})</span></pre><p id="5459" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要在我们的前端添加一个功能来触发这种支付。这个模块可以通过点击应用程序中的任何一个按钮来触发，只需要传递一个课程ID来启动Stripe支付。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="2810" class="kg kh hi lh b fi ll lm l ln lo">import { loadStripe } from "@stripe/stripe-js";<br/>import axios from 'axios'<br/><br/>const processPayment = async (courseId) =&gt; {<br/>  const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY);<br/>  const { data } = await axios.get(`/api/charge-card/${courseId}`);<br/>  await stripe.redirectToCheckout({ sessionId: data.id });<br/>}</span></pre><p id="c43a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们想知道课程何时被购买，以便我们可以在Prisma中更新我们的用户。这是由Stripe的webhooks实现的。与我们的Auth0挂钩类似，我们可以订阅特定的事件，当事件发生时，Stripe将调用我们的无服务器函数，并告诉我们哪个用户购买了特定的课程。</p><p id="07e7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们从Stripe获得了很多关于交易本身的数据，但不是哪个课程或Prisma用户。让我们修改我们的收费卡函数，将它作为元数据传递给会话。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="1152" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>const session = await stripe.checkout.sessions.create({<br/>  // other session stuff<br/>  <br/>  payment_intent_data: {<br/>    metadata: {<br/>      userId: user.id,<br/>      courseId,<br/>    },<br/>  },<br/>})</span></pre><p id="740b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">整个文件应该是这样的。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="7825" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/charge-card/[courseId].js<br/><br/>import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';<br/>import { PrismaClient } from '@prisma/client'<br/>import initStripe from 'stripe'<br/><br/>const prisma = new PrismaClient()<br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>module.exports = withApiAuthRequired(async (req, res) =&gt; {<br/>  try {<br/>    const { courseId } = req.query<br/>    const { user: { email } } = getSession(req, res)<br/>    <br/>    const course = prisma.course.findUnique({<br/>      where: {<br/>        id: parseInt(courseId),<br/>      },<br/>    })<br/>    <br/>    const user = await prisma.user.findUnique({<br/>      where: {<br/>        email,<br/>      },<br/>    })<br/>  <br/>    const lineItems = [<br/>      {<br/>        price_data: {<br/>          currency: 'aud', // swap this out for your currency<br/>          product_data: {<br/>            name: course.title,<br/>          },<br/>          unit_amount: course.price,<br/>        },<br/>        quantity: 1,<br/>      },<br/>    ]<br/>  <br/>    const session = await stripe.checkout.sessions.create({<br/>      customer: user.stripeId,<br/>      payment_method_types: ['card'],<br/>      line_items: lineItems,<br/>      mode: 'payment',<br/>      success_url: `${process.env.CLIENT_URL}/success`,<br/>      cancel_url: `${process.env.CLIENT_URL}/cancelled`,<br/>      payment_intent_data: {<br/>        metadata: {<br/>          userId: user.id,<br/>          courseId,<br/>        },<br/>      },<br/>    })<br/>  <br/>    res.json({ id: session.id })<br/>  } catch (err) {<br/>    res.send(err)<br/>  } finally {<br/>    await prisma.$disconnect()<br/>  }<br/>})</span></pre><p id="b53a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们可以从Stripe创建一个API路由来处理这些事件。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="8740" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>export default async (req, res) =&gt; {<br/>  // check what kind of event stripe has sent us<br/>  res.send({ received: true })<br/>}</span></pre><p id="2c6f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了不陷入与Auth0挂钩相同的问题，让我们实现一个签名秘密来确认请求来自Stripe。</p><p id="a5b0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们首先<a class="ae kf" href="https://stripe.com/docs/stripe-cli#install" rel="noopener ugc nofollow" target="_blank">安装Stripe CLI </a>来模拟webhook事件。如果你安装了macOS和homebrew，我们可以运行这个命令。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="ff9f" class="kg kh hi lh b fi ll lm l ln lo">brew install stripe/stripe-cli/stripe</span></pre><p id="982b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在运行以下命令，使用Stripe对CLI进行身份验证。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="82a0" class="kg kh hi lh b fi ll lm l ln lo">stripe login</span></pre><p id="9121" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们应该能够运行以下代码来将webhook事件转发到我们的本地主机。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="cc7f" class="kg kh hi lh b fi ll lm l ln lo">stripe listen --forward-to localhost:3000/api/stripe-hooks</span></pre><p id="ae78" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将在终端上打印出一个签名密码。把这个复制到你的。名为“条带签名秘密”的env文件。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="86e8" class="kg kh hi lh b fi ll lm l ln lo">// .env<br/><br/>// other secrets<br/>STRIPE_SIGNING_SECRET=your-webhook-signing-secret</span></pre><p id="c03d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Stripe提供了一个方便的助手函数，称为“constructEvent ”,可以确认这个请求是否是他们发出的。不幸的是，在Next.js中我们需要做一点修补工作。<a class="ae kf" href="https://codedaily.io/tutorials/Stripe-Webhook-Verification-with-NextJS" rel="noopener ugc nofollow" target="_blank">这里有一个非常好的指南</a>来逐步完成这个过程。</p><p id="28ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们从安装“微”开始。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="90c9" class="kg kh hi lh b fi ll lm l ln lo">npm i micro</span></pre><p id="431b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们可以更新我们的stripe-hooks API路由来验证请求是否来自stripe。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="19e5" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>import initStripe from 'stripe'<br/>import { buffer } from 'micro'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/><br/>export const config = { api: { bodyParser: false } }<br/><br/>export default async (req, res) =&gt; {<br/>  const reqBuffer = await buffer(req)<br/>  const signature = req.headers['stripe-signature']<br/>  const signingSecret = process.env.STRIPE_SIGNING_SECRET<br/>  <br/>  let event<br/>  <br/>  try {<br/>    event = stripe.webhooks.constructEvent(reqBuffer, signature, signingSecret)<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(400).send(`Webhook Error: ${err.message}`)<br/>  }<br/>  <br/>  // check what kind of event stripe has sent us<br/><br/>  res.send({ received: true })<br/>}</span></pre><p id="909a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">来自Vercel的“req”对象没有按照Stripe期望的方式构造，所以除非我们做一些工作，否则不能正确验证。</p><blockquote class="lp lq lr"><p id="6e06" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">stripe.webhooks.constructEvent()是stripe建议使用的一个函数，用于确认他们已经发送了这个请求。如果它可以验证这一点，那么它将返回条带事件，否则它将抛出一个异常，我们将返回一个400状态代码。在这里阅读更多<a class="ae kf" href="https://stripe.com/docs/webhooks/signatures" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="5727" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，现在我们可以忘记所有的验证，专注于处理从Stripe接收的事件。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="2397" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>export default async (req, res) =&gt; {<br/>  // signing logic<br/>  <br/>  switch (event.type) {<br/>    case 'charge.succeeded':<br/>      // update user in prisma<br/>      console.log('charge succeeded')<br/>      break<br/>    default:<br/>      console.log(`Unhandled event type ${event.type}`)<br/>  }<br/>}</span></pre><blockquote class="lp lq lr"><p id="1711" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">event.type将包含已触发事件的字符串。我们将在以后对订阅进行扩展，所以我们使用case语句来保持清晰。</p></blockquote><p id="d2c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过在新的终端窗口中运行以下命令来测试这一点，这需要运行“stripe listen”和“npm run dev”命令。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="660e" class="kg kh hi lh b fi ll lm l ln lo">stripe trigger charge.succeeded</span></pre><p id="ec36" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这应该会在控制台上打印出“充电成功”。</p><p id="00df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要从元数据中提取用户和课程ID，并更新用户在Prisma中购买的课程。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="1e76" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = new PrismaClient()<br/><br/>export default async (req, res) =&gt; {<br/>  // signing logic<br/>  <br/>  const { metadata } = event.data.object<br/>  <br/>  switch (event.type) {<br/>    case 'charge.succeeded':<br/>      // update user in prisma<br/>      if (metadata?.userId &amp;&amp; metadata?.courseId) {<br/>        const user = await prisma.user.update({<br/>          where: {<br/>            id: parseInt(metadata.userId)<br/>          },<br/>          data: {<br/>            courses: {<br/>              connect: {<br/>                id: parseInt(metadata.courseId)<br/>              }<br/>            }<br/>          },<br/>        })<br/>      }<br/>      break<br/>    default:<br/>      console.log(`Unhandled event type ${event.type}`)<br/>  }<br/>}</span></pre><blockquote class="lp lq lr"><p id="2294" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">“连接”用于为用户将现有课程ID插入课程数组。如果我们想创建此课程，那么我们将使用“创建”。</p></blockquote><p id="93b1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的文件应该如下所示。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="dbb8" class="kg kh hi lh b fi ll lm l ln lo">// pages/api/stripe-hooks<br/><br/>import initStripe from 'stripe'<br/>import { buffer } from 'micro'<br/>import { PrismaClient } from '@prisma/client'<br/><br/>const stripe = initStripe(process.env.STRIPE_SECRET_KEY)<br/>const prisma = new PrismaClient()<br/><br/>export const config = { api: { bodyParser: false } }<br/><br/>export default async (req, res) =&gt; {<br/>  const reqBuffer = await buffer(req)<br/>  const signature = req.headers['stripe-signature']<br/>  const signingSecret = process.env.STRIPE_SIGNING_SECRET<br/>  <br/>  let event<br/>  <br/>  try {<br/>    event = stripe.webhooks.constructEvent(reqBuffer, signature, signingSecret)<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(400).send(`Webhook Error: ${err.message}`)<br/>  }<br/>  <br/>  const { metadata } = event.data.object<br/>  <br/>  switch (event.type) {<br/>    case 'charge.succeeded':<br/>      // update user in prisma<br/>      if (metadata?.userId &amp;&amp; metadata?.courseId) {<br/>        const user = await prisma.user.update({<br/>          where: {<br/>            id: parseInt(metadata.userId)<br/>          },<br/>          data: {<br/>            courses: {<br/>              connect: {<br/>                id: parseInt(metadata.courseId)<br/>              }<br/>            }<br/>          },<br/>        })<br/>      }<br/>      break<br/>    default:<br/>      console.log(`Unhandled event type ${event.type}`)<br/>  }<br/><br/>  res.send({ received: true })<br/>}</span></pre><p id="99ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们应该有一个完整的解决方案，我们可以在我们的应用程序中触发特定课程的支付-我们需要从应用程序中完成，而不是CLI，以便它包括我们的元数据。这将请求我们的收费卡无服务器功能为该课程创建一个支付会话。然后，用户应该被带到Stripe的用户界面，在那里他们可以输入他们的信用卡信息，然后在他们被收费后被重定向到我们的成功页面。在后台Stripe将调用我们的webhook serverless函数，该函数将用新购买的课程更新我们的Prisma用户！</p><p id="9451" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太神奇了！而且我们的app不需要知道任何用户的信用卡详细信息！</p><blockquote class="lp lq lr"><p id="fbe9" class="jj jk ls jl b jm jn ij jo jp jq im jr lt jt ju jv lu jx jy jz lv kb kc kd ke hb bi translated">Stripe文档非常棒，我强烈推荐你看看除了我们在这个系列中介绍的之外，你还能做些什么！</p></blockquote><h2 id="524a" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">跟我来</h2><p id="dae7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/" rel="noopener ugc nofollow" target="_blank">网站</a></p><p id="5e8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://twitter.com/_dijonmusters" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="0fc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://www.youtube.com/channel/UCPitAIwktfCfcMR4kDWebDQ" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h2 id="2af3" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">下星期</h2><p id="5f0e" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae kf" href="https://jonmeyers.io/blog/build-a-saas-platform-with-stripe/implementing-subscriptions-with-stripe" rel="noopener ugc nofollow" target="_blank">实施带条带的订阅</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Practical Middle Tier Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用中间层设计</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/practical-middle-tier-design-519e290644bf?source=collection_archive---------12-----------------------#2022-10-09">https://medium.com/geekculture/practical-middle-tier-design-519e290644bf?source=collection_archive---------12-----------------------#2022-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d880" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">以下是方法</h2><div class=""/><div class=""><h2 id="b6b0" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">分享一个真实的集成项目</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/6de6cae02487e5620f8ebed4678164d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVXyz3Tub-7nE9P4RHaxPg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">source: microsoft.com</figcaption></figure><p id="cc39" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">设置场景:</p><p id="db55" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">对于最近一个将后端服务器迁移到另一个供应商的客户项目，它启发我写了一篇文章来重温中间层设计。</p><p id="7a4c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">来自微软的N层架构风格给出了背景，这里我将集中讨论中间层。它还解释了层和层之间的区别，N层的优缺点和挑战等。</p><p id="e57a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里我将借用文章<a class="ae ks" href="https://www.freecodecamp.org/news/what-is-middleware-with-example-use-cases/" rel="noopener ugc nofollow" target="_blank">中的</a>，获取一些定义和用例。</p><p id="8b42" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">首先为<strong class="jy hs">翻译器</strong>:在我的例子中，我们为下面的实现<strong class="jy hs">翻译</strong></p><ol class=""><li id="6a66" class="kt ku hi jy b jz ka kc kd kf kv kj kw kn kx kr ky kz la lb bi translated">从传入的xml请求和传出的json请求(到后端远程服务)，</li><li id="b361" class="kt ku hi jy b jz lc kc ld kf le kj lf kn lg kr ky kz la lb bi translated">从产品错误代码中翻译项目/企业特定的错误代码/描述。例如，后端服务器响应HTTP错误代码(404、500等)，而客户端期望特定于企业的错误代码(例如，1000表示找不到文件，3000表示内部服务器错误等)</li></ol><p id="e8b5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">第二个用于<strong class="jy hs">累积</strong>:当接收到1个传入请求时，我们需要对下游后端服务进行多个传出请求，例如，当对包含4个后端请求的新文档/照片进行上传时:必须首先发送元数据创建请求，然后是请求上传url的上传URL请求，接着是对有效载荷的一个或多个多方上传请求，最后是完成请求。</p><p id="65b1" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">第三个用于<strong class="jy hs">复制</strong>:有时我们可以将数据存储在中间层以便快速检索，而无需查询后端服务器。在我的例子中，由于范围和复杂性，我们还没有实现它。</p><p id="f47d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">第四个关于<strong class="jy hs"> API安全性</strong>:有许多选项可以实现API的安全性，特别是为我们的API提供认证和授权。应该使用短期的基于令牌的方法来验证客户端请求。此外，由于使用了中间件，这提供了灵活性，因为它可以使用中间件支持的任何身份验证方法。在我的例子中，我的中间件可以适应并保持客户端的令牌认证不变，同时中间件使用后端支持的一些API密钥与后端进行通信。</p><p id="2865" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">解决方案面临的挑战和问题:</strong></p><ol class=""><li id="3871" class="kt ku hi jy b jz ka kc kd kf kv kj kw kn kx kr ky kz la lb bi translated">耦合到后端正常运行时间</li></ol><p id="c9ff" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">由于后端经历了一些停机时间，我们需要考虑一些在中间层复制数据的解决方案，以尽量减少对客户端的服务中断。</p><p id="ce66" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">2.中间层重试和缓存</p><p id="f574" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">由于间歇性的停机时间，也由于我们无法更改遗留前端逻辑的一些限制，结果是在中间层实现了额外的应用程序<strong class="jy hs">重试</strong>逻辑和<strong class="jy hs">缓存</strong>机制，以满足功能和性能需求。</p><p id="b7b7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">结论:</strong></p><p id="7f5f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我希望我的文章能帮助你更多地思考中间件设计。如果你喜欢这篇文章，请订阅并关注我的媒体，因为它将有助于扩大受众范围。谢了。</p></div></div>    
</body>
</html>
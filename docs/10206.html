<html>
<head>
<title>Display a quadrillion rows of data in your browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在浏览器中显示千万亿行数据</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/display-a-quadrillion-rows-of-data-in-your-browser-4e8159e3426a?source=collection_archive---------1-----------------------#2022-01-18">https://medium.com/geekculture/display-a-quadrillion-rows-of-data-in-your-browser-4e8159e3426a?source=collection_archive---------1-----------------------#2022-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6921" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用canvas避开基于DOM的数据网格的限制</h2></div><h2 id="1726" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">迈克·本德</h2><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es jv"><img src="../Images/05027aaf2efa6d946cc6431cf1d85864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3sWND8U1VhcE6FS6"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Photo by <a class="ae kl" href="https://unsplash.com/@julczed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julia Sabiniarz</a> on <a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4fcf" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">今天的数据集比以往任何时候都大，经常达到超过<a class="ae kl" href="https://github.com/toddwschneider/nyc-taxi-data" rel="noopener ugc nofollow" target="_blank">十亿行数据</a>。在浏览器中显示它们使得许多用户可以检查大型数据集，而无需安装应用程序。浏览器非常强大，但不幸的是，我们不能在浏览器文档对象模型(DOM)中放入十亿行数据，否则<a class="ae kl" href="https://web.dev/dom-size/" rel="noopener ugc nofollow" target="_blank">浏览器性能会受到严重影响</a>。</p><p id="3fe2" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">理想情况下，用户可以探索和处理任何大小的数据，随意转换数据，并在需要时返回。当在Jupyter等熟悉的工具中使用较小的数据框时，这是可能的，但是一旦数据超过几百万行，这种体验在典型的数据网格渲染解决方案中就开始出错了。在这篇文章中，我们重点关注渲染数据的挑战——在另一篇文章中，我们将关注从服务器传输数据的管道。</p><p id="9bf5" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">我们确定了开发人员在试图呈现大型数据集时面临的三个挑战:</p><ol class=""><li id="0fe8" class="lf lg hi ko b kp kq ks kt ji lh jm li jq lj le lk ll lm ln bi translated">在滚动动作和DOM更新之间观察到的滞后是破坏性的。</li><li id="1b03" class="lf lg hi ko b kp lo ks lp ji lq jm lr jq ls le lk ll lm ln bi translated">最大大小限制防止用户看到表格的底部。</li><li id="e0bb" class="lf lg hi ko b kp lo ks lp ji lq jm lr jq ls le lk ll lm ln bi translated">技术限制导致光标跳到错误的位置。</li></ol><p id="0538" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">那么，我们如何克服这些问题呢？有可能在浏览器中高效地显示十亿行数据并与之交互吗？我们能否瞄准更高的目标，显示千万亿行数据？让我们探讨一下基于DOM的数据网格所观察到的一些问题，以及我们如何使用基于画布的解决方案来解决这些问题，比如npm上可用的<a class="ae kl" href="https://www.npmjs.com/package/@deephaven/grid" rel="noopener ugc nofollow" target="_blank"> @deephaven/grid </a>包。</p><h1 id="f8d3" class="lt iy hi bd iz lu lv lw jd lx ly lz jh io ma ip jl ir mb is jp iu mc iv jt md bi translated">问题1:在滚动动作和DOM更新之间观察到滞后<a class="ae kl" href="https://docs-staging.deephaven.io/deploy-preview/9243af50d5cd8089c21167a95a7c06014f2168cf/blog/2022/01/14/displaying-a-quadrillion-rows/#problem-1-lag-observed-between-scroll-actions-and-dom-updates" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="9696" class="pw-post-body-paragraph km kn hi ko b kp me ij kr ks mf im ku ji mg kw kx jm mh kz la jq mi lc ld le hb bi translated">首先，让我们通过只显示当前视口中的数据来减少DOM。如果在您的视口中只能看到20行数据，那么您只需要向DOM添加20行。这很简单，有一个大的可滚动元素，它的大小相当于您所拥有的数据表的大小，然后只显示/定位当前视窗中可见的单元格。这当然提高了性能，但是您需要在用户滚动时更新哪些单元格是可见的。为此，您需要添加一个scroll监听器，它必须是一个<a class="ae kl" href="https://developers.google.com/web/updates/2016/06/passive-event-listeners" rel="noopener ugc nofollow" target="_blank">被动监听器</a>以防止scroll jank。</p><p id="9176" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">对于被动侦听器，浏览器将更新元素的滚动位置，而不需要<a class="ae kl" href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#solution-the-passive-option" rel="noopener ugc nofollow" target="_blank">等待我们的侦听器完成</a>。在浏览器呈现滚动位置之前，我们无法更新元素的位置。这导致当浏览器“追赶”到新的滚动位置时，一些东西突然出现在视图中。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mj"><img src="../Images/4c3fa9fd2baf76dd947caf2c75a3a792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*lUkrtGgoYybHM29FAND3rA.gif"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Problem 1 — pop-ins! Source: Image by the author.</figcaption></figure><h1 id="7e30" class="lt iy hi bd iz lu lv lw jd lx ly lz jh io ma ip jl ir mb is jp iu mc iv jt md bi translated">问题2:大小限制阻止滚动到表格底部<a class="ae kl" href="https://docs-staging.deephaven.io/deploy-preview/9243af50d5cd8089c21167a95a7c06014f2168cf/blog/2022/01/14/displaying-a-quadrillion-rows/#problem-2-size-restrictions-prevent-scrolling-to-the-bottom-of-the-table" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="d70a" class="pw-post-body-paragraph km kn hi ko b kp me ij kr ks mf im ku ji mg kw kx jm mh kz la jq mi lc ld le hb bi translated">即使我们愿意接受在滚动动作发生之后，数据被正确定位之前有一段时间，但当我们开始进入数百万行时，事情就会变得一团糟。根据浏览器的不同，<a class="ae kl" href="https://stackoverflow.com/questions/16637530/whats-the-maximum-pixel-value-of-css-width-and-height-properties" rel="noopener ugc nofollow" target="_blank">元素</a>的最大尺寸限制在33，554，400像素左右。因此，如果我们尝试处理十亿行，当我们试图滚动到底部时，就会停止。我们甚至看不到四百万行:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mj"><img src="../Images/c75d9d6060232a600bfa4054a126860a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*m6rj40NzNc3VHLm_006DiA.gif"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Problem 2 — getting stuck! Source: Image by the author.</figcaption></figure><h1 id="70b2" class="lt iy hi bd iz lu lv lw jd lx ly lz jh io ma ip jl ir mb is jp iu mc iv jt md bi translated">问题3:光标跳到错误的位置<a class="ae kl" href="https://docs-staging.deephaven.io/deploy-preview/9243af50d5cd8089c21167a95a7c06014f2168cf/blog/2022/01/14/displaying-a-quadrillion-rows/#problem-3-cursor-jumps-to-the-wrong-location" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="54d0" class="pw-post-body-paragraph km kn hi ko b kp me ij kr ks mf im ku ji mg kw kx jm mh kz la jq mi lc ld le hb bi translated">也许我们可以解决这个限制——如果我们将自己限制在浏览器限制范围内的最大尺寸，并以某种方式虚拟化滚动，会怎么样？我们需要跟踪用户是否正在使用鼠标滚轮/触摸板手势平滑地滚动视窗，或者他们是否正在拖动滚动条以将视窗跳转到桌子的另一部分。</p><p id="9d0f" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">除了无法以编程方式确定滚动操作是由鼠标滚轮触发还是由拖动滚动条触发的技术限制之外，使用这种启发式方法还会出现偏差——如果使用滚轮足够长的时间来平滑向下滚动，那么滚动条的滚动位置将出现在错误的位置，而不是它在列表中实际应该出现的位置。然后，如果您尝试拖动该条，您将跳转到数据中的其他位置:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mj"><img src="../Images/a7c91edce2943f94be11a176ef4e7e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*dQS8XsI_dVXG9PwqE-O-1g.gif"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Problem 3 — jumping around! Source: Image by the author.</figcaption></figure><p id="139d" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">现在，如果我们拖动滚动条，它会跳过数万亿行；如果我们回到顶端，它会卡住。我们可以花很多时间来尝试改进这种启发式，但它永远不会让人感觉自然。我们仍然没有解决DOM滞后问题。这些问题在<a class="ae kl" href="https://github.com/jpmorganchase/regular-table/issues/15" rel="noopener ugc nofollow" target="_blank">许多</a> <a class="ae kl" href="https://github.com/bvaughn/react-virtualized/issues/73" rel="noopener ugc nofollow" target="_blank">其他</a> <a class="ae kl" href="https://plnkr.co/edit/bTmy924FwcUPnihJXPiA?p=preview&amp;preview" rel="noopener ugc nofollow" target="_blank">网格</a> <a class="ae kl" href="https://datatables.net/forums/discussion/15860/scroller-broken-for-huge-ajax-data-sets-on-ff-and-ie" rel="noopener ugc nofollow" target="_blank">库</a>声称与“大数据”一起工作中显而易见。如果我们采取完全不同的方法呢？</p><h1 id="5ae9" class="lt iy hi bd iz lu lv lw jd lx ly lz jh io ma ip jl ir mb is jp iu mc iv jt md bi translated">帆布救援！<a class="ae kl" href="https://docs-staging.deephaven.io/deploy-preview/9243af50d5cd8089c21167a95a7c06014f2168cf/blog/2022/01/14/displaying-a-quadrillion-rows/#canvas-to-the-rescue" rel="noopener ugc nofollow" target="_blank">T9】</a></h1><p id="859d" class="pw-post-body-paragraph km kn hi ko b kp me ij kr ks mf im ku ji mg kw kx jm mh kz la jq mi lc ld le hb bi translated">如果我们完全避免浏览器DOM的限制，而是使用画布来呈现网格，会怎么样？跟踪每件事需要更多的工作，但是我们可以立即提供更好的数据呈现交互性(没有DOM延迟)，并且我们只有一个与我们的视口大小相同的画布元素。让我们用一千万亿行来试试:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mj"><img src="../Images/c1851a746105f95355f6f8b8f6d952aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*_SgBvAclyjj7SBfxqT2zgQ.gif"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Success! Thanks, <a class="ae kl" href="https://www.npmjs.com/package/@deephaven/grid" rel="noopener ugc nofollow" target="_blank">@deephaven/grid</a> Source: Image by the author.</figcaption></figure><p id="5ef4" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">成功！滚动时数据立即可见，拖动滚动条可以像预期的那样工作，我们可以很容易地查看第千万亿行数据。通过避免浏览器DOM的限制，我们能够不折不扣地显示超大数据集并与之交互。一千万亿行对任何人来说都足够了！</p><p id="66e9" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">使用canvas来呈现大型数据网格并不是一个独特的想法——最值得注意的是，<a class="ae kl" href="https://github.com/fin-hypergrid/core" rel="noopener ugc nofollow" target="_blank"> fin-hypergrid </a>也是一个基于canvas的解决方案，但它不再被维护。</p><p id="a2ad" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku ji kv kw kx jm ky kz la jq lb lc ld le hb bi translated">试试下面的网格。这个基于画布的网格可以在npm上以包名<a class="ae kl" href="https://www.npmjs.com/package/@deephaven/grid" rel="noopener ugc nofollow" target="_blank"> @deephaven/grid </a>获得(Apache-2.0许可，更多文档即将发布)。我们在我们的Deephaven web控制台中扩展了这个包的过滤、排序、分组等功能。你可以<a class="ae kl" href="https://demo.deephaven.app/" rel="noopener ugc nofollow" target="_blank">在线试用深海天堂的演示应用</a>。将它与您的数据集联系起来，开始探索吧！</p></div></div>    
</body>
</html>
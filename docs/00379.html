<html>
<head>
<title>Props Drilling v/s Context API Which One Is the Best</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">道具演练v/s上下文API哪个最好</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/props-drilling-v-s-context-api-which-one-is-the-best-75c503d21a65?source=collection_archive---------1-----------------------#2021-01-27">https://medium.com/geekculture/props-drilling-v-s-context-api-which-one-is-the-best-75c503d21a65?source=collection_archive---------1-----------------------#2021-01-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="725a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">快捷方式即上下文API是最好的吗？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e9efb0f1f02c51c69fe67be6018f530e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ha2vNB0ILaYKPXk6oyTZSQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Prop drilling vs Context API, How the data is passed</figcaption></figure><p id="d19f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi kj translated">eact最初于2013年发布，到目前为止没有改变的一点是在嵌套层中使用道具传递数据的方式。但好消息是，数据可以通过其他方式从父母传递给孩子。当您有多层嵌套子元素时，上下文API尤其有用。</p><p id="9d58" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们从基础开始，以获得更多的想法。</p><h1 id="e449" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">什么是道具？</h1><p id="b1a1" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">React是一个库，它帮助我们将UI分成小的可重用部分，我们称之为组件。为了在组件之间传递数据，我们使用了Props。在props的帮助下，数据被传递给组件。<br/>因此，道具帮助我们将数据从一个组件传递到另一个组件。</p><p id="e678" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，props中的数据是只读的，这意味着使用这些数据的孩子不能更改这些数据。因此，这是一个单向流动。(从父母到孩子的单向)。然而，我们可以利用props传递数据的函数将数据从孩子传递给父母。</p><h1 id="2d62" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">什么是道具钻？</h1><p id="7f6e" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">Prop drilling是指将数据从父节点传递到React树中所有嵌套的子节点。让我们看看上面的图表，看看数据是如何从父母传递给孩子的。</p><h1 id="d96a" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">什么时候支柱钻孔会引起问题？</h1><p id="9f9a" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated"><strong class="jp hj"> 1。更新数据格式</strong></p><pre class="iy iz ja jb fd lp lq lr ls aw lt bi"><span id="72e5" class="lu kt hi lq b fi lv lw l lx ly">&lt;Profile user="Harsh"&gt;</span></pre><p id="b133" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们假设我们现在需要传递一个对象，因为我们还需要传递配置文件状态，无论它是否过期。这是组件的样子</p><pre class="iy iz ja jb fd lp lq lr ls aw lt bi"><span id="0360" class="lu kt hi lq b fi lv lw l lx ly">&lt;Profile user={"name": "Harsh", "status": "Expired"}</span></pre><p id="db44" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种情况下，您必须更改它们各自访问的数据格式。</p><p id="1b21" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 2。重命名属性<br/> </strong>假设在应用程序的后期，当你删除一些数据或传递更多数据时，需要重命名属性。它必须在层级结构中的所有位置进行更改。</p><p id="163c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看看如何利用React上下文来解决这个问题。</p><h1 id="16fc" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">反应上下文</h1><p id="f505" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">上下文为通过组件树传递数据提供了一种极好的方式，而不必在应用程序的每一层手动传递属性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/9c975e001c98dd65db4513630e06c3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXBo9ZyvSjtr_y3uvYlVeg.png"/></div></div></figure><h1 id="bf5c" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">上下文有3个主要部分:</h1><h2 id="fc3e" class="lu kt hi bd ku ma mb mc ky md me mf lc jw mg mh le ka mi mj lg ke mk ml li mm bi translated">上下文对象</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="7edd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果愿意，可以在单独的文件中定义上下文对象，或者在组件文件中紧挨着组件定义。组件中有多个上下文也是可能的。因此，您可以在上下文对象中存储任何您想要的数据，这些数据将在您的应用程序中被全局访问。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="7988" class="lu kt hi bd ku ma mb mc ky md me mf lc jw mg mh le ka mi mj lg ke mk ml li mm bi translated">上下文提供者</h2><p id="f54d" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">提供者提供应用程序中需要访问该上下文对象的所有组件的值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="faad" class="lu kt hi bd ku ma mb mc ky md me mf lc jw mg mh le ka mi mj lg ke mk ml li mm bi translated">上下文消费者</h2><p id="7718" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在下面的例子中，<strong class="jp hj"> <em class="mp">上下文</em> </strong>只不过是上下文对象的值。我们在创建上下文对象期间定义的所有值都可以在这里轻松访问。是啊，就这么简单！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h1 id="5560" class="ks kt hi bd ku kv kw kx ky kz la lb lc io ld ip le ir lf is lg iu lh iv li lj bi translated">上下文API什么时候会导致问题？</h1><p id="14cb" class="pw-post-body-paragraph jn jo hi jp b jq lk ij js jt ll im jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">应用程序中不必要的重新渲染</p><blockquote class="mq mr ms"><p id="4427" class="jn jo mp jp b jq jr ij js jt ju im jv mt jx jy jz mu kb kc kd mv kf kg kh ki hb bi translated">每次上下文状态改变时，所有消耗上下文的东西都会重新呈现。</p></blockquote><p id="4dfe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">尽管context API看起来是一个令人惊奇的特性，但过度使用它可能会导致应用程序中不必要的重新呈现，无论提供者的状态何时改变，它都会重新呈现所有它的子元素，不管他们是否自定义了提供者的数据。</p><p id="0b64" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">结论</strong></p><ul class=""><li id="f7a8" class="mw mx hi jp b jq jr jt ju jw my ka mz ke na ki nb nc nd ne bi translated">当存储的数据没有像暗/亮模式(主题)、个人资料图片细节、账户细节等频繁更新时，Context API总是一个不错的选择。</li><li id="64d4" class="mw mx hi jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated">React已经很快了，不需要很多优化，大多数情况下prop drilling也是一个不错的选择，因为从实现的角度来看它很容易</li><li id="e753" class="mw mx hi jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated">尽量保持应用程序的状态接近渲染组件。</li><li id="59ee" class="mw mx hi jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated">对于是否应该使用适当的钻探或上下文API，没有适当的指导，只是根据必要性验证您的代码，无论是否需要这样做，然后继续进行。</li></ul><p id="9b0f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">快乐学习。</p></div></div>    
</body>
</html>
<html>
<head>
<title>3 Examples of How Mathematics Can Help in Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数学如何帮助编程的3个例子</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/3-examples-of-how-mathematics-can-help-in-programming-c9c4f3267dde?source=collection_archive---------22-----------------------#2021-08-31">https://medium.com/geekculture/3-examples-of-how-mathematics-can-help-in-programming-c9c4f3267dde?source=collection_archive---------22-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e349" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">数学似乎经常与编程密切相关——你需要了解其中一个才能擅长另一个。这是真的吗？嗯，这很大程度上取决于你工作的领域——如果你从事图形和游戏开发，你可能需要矩阵乘法、向量空间、投影和代数；如果你是数据科学家，你可能需要良好的统计学知识；ML问题的代数等等。</p><p id="f246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是一般来说(至少从我有限的经验来看),一般的程序员使用一点算术和一些基本的代数。</p><p id="09a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这并不意味着懂数学对你的日常工作没有帮助，我将用三个简单的例子来证明这一点。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="3e2e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.布尔代数</h1><p id="19ab" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">作为一名程序员，你应该熟悉<em class="kw">布尔值</em>和<em class="kw"> if语句</em>。显然，知道几个简单的规则叫做<a class="ae kx" href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" rel="noopener ugc nofollow" target="_blank"> <em class="kw">德摩根定律</em> </a>可能会在写作、重构或试图理解更复杂的情况时节省你的时间。</p><p id="697d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说个例子。想象你看到了这样的表达:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2029" class="lh ju hi ld b fi li lj l lk ll">not(not A or not B) <strong class="ld hj">and</strong> not C and not D and not E</span></pre><p id="2ee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而你需要理解它，或者更好——重写。我相信你可以在不知道任何逻辑规则的情况下做到这一点，但我也相信这需要一些时间。但是如果你知道德摩根定律，重写这个表达式是相当容易的:</p><ul class=""><li id="1dae" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">析取的否定是否定的合取。</li><li id="481d" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">连词的否定是否定的析取。</li></ul><p id="7090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者在编程中:</p><ul class=""><li id="b239" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">not (A或B) =(非A)和(非B)</li><li id="d0a1" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">not (A和B) =(非A)或(非B)</li></ul><p id="e7be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们的表达方式可以快速而自信地改写为:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="e092" class="lh ju hi ld b fi li lj l lk ll">A and B <strong class="ld hj">and</strong> not(C or D or E)</span></pre><p id="57b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用德摩根定律的另一个好处是，除了让代码看起来更干净、可读性更强之外，还可以绕过短路(对于<code class="du ma mb mc ld b">!A || !B</code>，大多数语言会停止计算<code class="du ma mb mc ld b">!A</code>是否为真，因为这样一来<code class="du ma mb mc ld b">!B</code>值是多少就无关紧要了，如果<code class="du ma mb mc ld b">A</code>和<code class="du ma mb mc ld b">B</code>是函数的话，这一点可能很重要)，如果反转一个值而不是两个值(例如<code class="du ma mb mc ld b">!(A or B)</code>而不是<code class="du ma mb mc ld b">!A and !B</code>，还可以节省一个或几个CPU周期。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="e95a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.图论</h1><p id="d7f5" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">正如史蒂夫·耶格在他的博客文章<a class="ae kx" href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" rel="noopener ugc nofollow" target="_blank">“在谷歌得到那份工作”</a>中所说:</p><blockquote class="md me mf"><p id="7ce4" class="if ig kw ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">每当有人给你出难题时，想想图表。它们是表示任何一种关系的最基本和最灵活的方式，所以任何有趣的设计问题都有一半的机会涉及到图。在转移到其他解决方案类型之前，一定要确保你想不出用图表来解决它的方法。</p></blockquote><p id="b8fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这可能有点夸张，但是确实有很多问题可以，并且已经用<a class="ae kx" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>解决了。几乎每次你用谷歌搜索一些东西，在脸书跟踪人们，或者使用地图应用程序寻找最快或最短的路线时，<a class="ae kx" href="https://www.mdpi.com/2411-5134/5/1/10/htm" rel="noopener ugc nofollow" target="_blank">图论都在发挥作用</a>。</p><p id="34c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会深入图论本身，因为那里有很多精彩的资源(例如<a class="ae kx" href="https://www.youtube.com/watch?v=LFKZLXVO-Dg" rel="noopener ugc nofollow" target="_blank"> <em class="kw">图论简介:计算机科学视角</em> </a> by Reducible ),而是从实际例子开始。</p><p id="3121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，你需要实现<em class="kw">石头剪刀布蜥蜴斯波克</em>来和计算机对战(因为那确实是程序员日常处理的那种问题)。规则是:</p><blockquote class="md me mf"><p id="29d8" class="if ig kw ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">“剪刀剪纸，纸盖石头，石头压死蜥蜴，蜥蜴毒死斯波克，斯波克砸碎剪刀，剪刀砍头蜥蜴，蜥蜴吃纸，纸反驳斯波克，斯波克蒸发石头，一如既往，石头压死剪刀。”</p></blockquote><p id="8a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初的本能可能是写类似这样的东西，用大量的<em class="kw"> if </em>:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="77f7" class="lh ju hi ld b fi li lj l lk ll">if <!-- -->computer_action == "scissors" &amp; user_action<!-- --> == "paper":<br/>    print("You loose")<br/>elif <!-- -->computer_action == "rock" &amp; user_action<!-- --> == "paper":<br/>    print("You win")<br/>elif <!-- -->computer_action == "rock" &amp; user_action<!-- --> == "lizard":<br/>    print("You loose")<br/>...</span></pre><p id="6f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将需要21个条件<em class="kw"> </em> (20个用于输赢情况，1个用于5个平局情况)。当然，您可以通过嵌套一些案例来优化它:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="634c" class="lh ju hi ld b fi li lj l lk ll">if <!-- -->computer_action == "scissors":<br/>    if user_action<!-- --> == "paper" or <!-- -->user_action<!-- --> == "lizard":<br/>        print("You loose")<br/>    else:<br/>        print("You win")<br/>if <!-- -->computer_action == "paper":<br/>    if ...<br/>...</span></pre><p id="7a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这样看起来好一点，但是如果你需要模拟一个7，51，或者<a class="ae kx" href="https://www.umop.com/rps101.htm" rel="noopener ugc nofollow" target="_blank"> 101个角色</a>的游戏呢？</p><p id="c0fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是“<em class="kw">思维图</em>”(并了解一些模运算)可以发挥作用的地方(*):</p><p id="7388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们把游戏想象成一个<a class="ae kx" href="https://en.wikipedia.org/wiki/Directed_graph" rel="noopener ugc nofollow" target="_blank">有向图</a>，其中边是角色，连接它们的顶点是有向的，因此比赛的获胜者由一个指向它的箭头表示。</p><figure class="ky kz la lb fd mk er es paragraph-image"><div class="er es mj"><img src="../Images/0fe200b33d44b22bc912566846d72cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*rNPdG32JIVm3X3eAyCDn5Q.png"/></div></figure><p id="b35d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这种表示看起来没有简单英语中的规则或一堆if语句复杂，但它仍然不是非常数学化。因此，我们将用数字替换字符，即rock-0、lizard-1、Spock-2、scissors-3和paper-4。</p><figure class="ky kz la lb fd mk er es paragraph-image"><div class="er es mn"><img src="../Images/4f9f03d4d9be735b5c1e3f6378d969a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*l_CvGH46TisTsnDr-2TTSQ.png"/></div></figure><p id="f23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要一种表示匹配的方式。这可以通过减法来完成——例如，如果你的对手(在这种情况下是计算机)选择了斯波克(<em class="kw"> 2 </em>)，而你选择了纸(<em class="kw"> 4 </em>)，我们将这场比赛表示为<em class="kw">2–4 =-2</em>。请注意，这种表示法确保了玩家选择之间的区别，即如果计算机选择纸(<em class="kw"> 4 </em>)而您选择斯波克(<em class="kw"> 2 </em>)，比赛将由相反的数字<em class="kw">4–2 = 2</em>表示。</p><p id="545e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在仔细观察代表比赛的数字，我们会注意到每场比赛的<a class="ae kx" href="https://en.wikipedia.org/wiki/Modular_arithmetic#Examples" rel="noopener ugc nofollow" target="_blank">模</a> 5 ( <em class="kw"> mod5 </em>)会产生一些有趣的结果——你赢得的每场比赛的结果都是奇数，而计算机赢得的每场比赛的结果都是偶数。</p><figure class="ky kz la lb fd mk er es paragraph-image"><div class="er es mo"><img src="../Images/c5d9b8263064ff1bf9cd3d0ac782e95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*ZgDEfqy7jfn0McIfVes-Iw.png"/></div><figcaption class="mp mq et er es mr ms bd b be z dx"><code class="du ma mb mc ld b">(computer - you) mod5</code></figcaption></figure><p id="9336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在将游戏表示为图形并使用一些模运算后，我们可以只用几行代码重写我们的解决方案:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="46e5" class="lh ju hi ld b fi li lj l lk ll">result = <!-- -->computer_action - user_action<br/>result_mod = <!-- -->result % 5</span><span id="f20a" class="lh ju hi ld b fi mt lj l lk ll">if <!-- -->result_mod<!-- --> == 0: print("It's a tie")<br/>elif (<!-- -->result_mod<!-- -->)%2 == 0: print("You lost")<br/>elif (<!-- -->result_mod<!-- -->)%2 == 1: print("You won")</span></pre><p id="a726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*这种方法仅在下面的<a class="ae kx" href="https://en.wikipedia.org/wiki/Tournament_(graph_theory)" rel="noopener ugc nofollow" target="_blank">锦标赛图形</a>不均匀且<a class="ae kx" href="https://en.wikipedia.org/wiki/Complete_graph" rel="noopener ugc nofollow" target="_blank"> k-complete </a>时有效。</p><h1 id="b869" class="jt ju hi bd jv jw mu jy jz ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq bi translated">3.数学归纳</h1><p id="9003" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">数学通常与一种思维方式联系在一起——也就是说，拥有数学知识(或者，我认为，拥有任何科学背景)的人被期望以一种更有条理、更具分析性的方式思考，因此成为优秀的问题解决者。但是这种技能如何量化呢？有什么具体的东西可以学着应用在日常工作中吗？</p><p id="c8c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数学归纳法是一种数学证明技术，用来证明一个陈述<em class="kw"> P </em> ( <em class="kw"> n </em>)对每一个自然数<em class="kw"> n </em> = 0，1，2，3，.。。</p><p id="6130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用数学归纳法证明某事的过程相当简单，包括三个主要步骤:</p><ol class=""><li id="a5a5" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mz ls lt lu bi translated">定义一个<strong class="ih hj">基例</strong>，使得<strong class="ih hj"> </strong>证明<strong class="ih hj">首字母n </strong> <em class="kw"> </em>的语句，而不需要假设任何其他情况的知识。</li><li id="3815" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mz ls lt lu bi translated">假设语句对<strong class="ih hj"> n=k </strong>成立。</li><li id="55ec" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mz ls lt lu bi translated">表明它也适用于随后的<strong class="ih hj">步骤</strong> <strong class="ih hj"> n=k+1 </strong>(使用步骤2中的假设)。</li></ol><p id="b037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过一个简单的例子来证明<em class="kw"> 1+3+5+⋯+(2n−1)=n </em>对于每个n∈ℤ+(即对于每个正整数)都成立。</p><p id="aa90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤:</p><ol class=""><li id="d6bd" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mz ls lt lu bi translated"><strong class="ih hj">基本情况:</strong> <em class="kw"> n=1(因为我们为n∈ℤ+证明了这一点)确实是真的:</em></li></ol><p id="39be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw">2 ⋅1–1 = 1</em></p><p id="f16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.假设语句对<strong class="ih hj"> n=k </strong> : <em class="kw">成立，让结果对n=k为真，即</em></p><p id="a4b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw"> 1+3+5+⋯+(2𝑘−1)=𝑘 </em></p><p id="2de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.表明它也适用于<strong class="ih hj"> n=k+1 </strong>:</p><p id="37e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw">1+3+5+⋯+(2𝑘−1)+(2(</em><strong class="ih hj"><em class="kw">𝑘+1</em></strong><em class="kw">)-1)=1+3+5+⋯+(2𝑘−1)+(2𝑘+1)=(</em><strong class="ih hj"><em class="kw">𝑘+1</em></strong><em class="kw">)</em></p><p id="e51e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw">因为根据我们的假设1+3+5+⋯+(2𝑘−1)=𝑘(见第2步),我们可以将其重写为</em></p><p id="5eda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw">k</em><strong class="ih hj"><em class="kw"/></strong><em class="kw">+(2𝑘+1)=(𝑘+1)哪个确实是真的。</em></p><p id="b2cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这证明了该等式适用于任何正自然数，因为它适用于<em class="kw"> 1 </em>，并且由于它适用于每个<em class="kw"> k+1 </em>，因此，它适用于<em class="kw"> 1+1=2 </em>，然后<em class="kw"> 3 (2+1) </em>、<em class="kw"> 4 </em>，以此类推，适用于所有正整数。</p><p id="6b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特里斯汀·克利夫兰完美地表达了我们在这里所做的事情:</p><blockquote class="md me mf"><p id="77e6" class="if ig kw ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">数学归纳法证明了我们可以在梯子上爬到我们喜欢的高度，通过证明我们可以爬到最低的梯级(基础<strong class="ih hj"/>)并且从每个梯级我们可以爬到下一个梯级(步骤<strong class="ih hj"/>)。</p></blockquote><p id="a4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与编程有什么关系？嗯，正如罗伯特·哈珀在《<a class="ae kx" href="https://www.cs.cmu.edu/~rwh/introsml/techniques/indrec.htm" rel="noopener ugc nofollow" target="_blank"> <em class="kw">标准ML中的编程</em> </a>》中所说:</p><blockquote class="md me mf"><p id="d855" class="if ig kw ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">递归编程时，归纳思考</p></blockquote><p id="a083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一下递归的例子——求m的和</p><figure class="ky kz la lb fd mk er es paragraph-image"><div class="er es na"><img src="../Images/ca31b4fba6e8a775af74194d602255f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*961xlqSQvu8KczhB9v6U-Q.png"/></div></figure><p id="f14b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个可能的解决方案(出于解释原因，代码非常冗长):</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="e112" class="lh ju hi ld b fi li lj l lk ll">def recursive_sum(m):<br/>    if m == 0: <br/>        return 0<br/>    else: <br/>        k = m*(m+1)/2 <br/>        k_minus_one = recursive_sum(m-1)<br/>        return k + k_minus_one</span></pre><p id="a347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以分为三个步骤:</p><ol class=""><li id="00e8" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mz ls lt lu bi translated">建立一个<strong class="ih hj">基础案例</strong>(本例为0)。</li><li id="bdee" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mz ls lt lu bi translated">寻找<strong class="ih hj"> m=k </strong>的值。</li><li id="76e1" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mz ls lt lu bi translated">使用来自步骤<em class="kw"> </em> 2的值<strong class="ih hj"> k </strong>和等式的连续成员<strong class="ih hj"> k-1 </strong>(它是k-1而不是k+1，因为我们是按降序移动的)来得到最终答案。</li></ol><p id="ae9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这是一个相当简单的例子，数学归纳法在这里似乎没有什么帮助。但用“思维归纳法”实现递归，可以帮助组织思路，解决更复杂的情况。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><p id="c8c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以说到底——程序员需要数学吗？虽然这取决于领域，但我认为在大多数情况下答案是否定的。然而，正如我们之前所展示的，知道它可能会让你的生活更轻松。</p><p id="2243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以看Youtube上不断推荐的数学视频吧，因为你永远不知道它什么时候会有帮助。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><p id="284a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw">我在研究这篇文章时发现的其他阅读材料，但不包括:</em></p><ul class=""><li id="b8b3" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated"><a class="ae kx" href="https://projecteuler.net/about" rel="noopener ugc nofollow" target="_blank"> Project Euler </a> —为对数学和计算机编程感兴趣的人设计的一组计算问题。</li><li id="1f42" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">计算机科学中的数学。</li></ul></div></div>    
</body>
</html>
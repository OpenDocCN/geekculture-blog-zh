<html>
<head>
<title>A Crash Course in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯的速成班</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-crash-course-in-kubernetes-1ccb70125ebf?source=collection_archive---------3-----------------------#2021-04-23">https://medium.com/geekculture/a-crash-course-in-kubernetes-1ccb70125ebf?source=collection_archive---------3-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f568" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">自动化容器部署、扩展和管理</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2047329db7d25dc93c31e880ccf18f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wR2HZwAlifJtZU_P"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Containers for the masses</figcaption></figure><h1 id="bc5c" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">观众</h1><p id="3ff7" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">这篇文章的目标读者是具有Java和Docker基础知识的开发人员，他们希望了解T2如何适应当代软件开发。</p><p id="7af4" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们的目标是涵盖集装箱化、集装箱管理和Kubernetes的基础知识。我们将以一个使用AWS的<a class="ae lb" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank">弹性Kubernetes服务</a> (EKS)的工作示例来结束。</p><h1 id="bcae" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">争吵</h1><p id="e495" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在软件工程中，我们有代码，我们需要运行它的地方。这可以是我们的本地机器、服务器或其他地方。然而，我们需要确保无论我们在哪里运行它，它都以相同的方式运行。这可能意味着在一台机器上安装相同的语言版本、相同的操作系统、相同的依赖项，等等。</p><p id="94cb" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">容器旨在解决这个问题。它们允许我们在一个<em class="lh">映像</em>中声明所有这些方面，包括应用程序。我们传递<em class="lh">映像</em>的概念，无论它在哪里运行，都提供一致的环境。</p><p id="9ad9" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们现在不再担心运行应用程序，而是担心运行映像。</p><p id="cd64" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们选择的解决这个问题的容器框架是Docker。我们期望你对它的工作原理有一个基本的了解，但是即使你不了解，希望你仍然能够了解Kubernetes的工作原理。</p><p id="58bd" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">为了阐明容器的用途，让我们来看看下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/c1cd4e690848e14e7a379f6ad410e468.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*t1DNVJVzw8jbBSrbnfmDyw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Traditional Deployment vs Virtualised Deployment vs Container Deployment</figcaption></figure><p id="a16c" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">以上对比了传统、虚拟化和基于容器的部署。在传统情况下，我们手动维护操作系统，以便为在其上运行的所有应用程序提供运行时间。每个应用都会在同一台服务器上竞争资源。</p><p id="e2f0" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在虚拟化部署中，我们使用虚拟机隔离应用程序。但是，它们都需要维护自己的操作系统和虚拟机管理程序层(创建和运行虚拟机的软件，负责与虚拟机共享和分配物理机的资源)。</p><p id="9fd8" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">容器以比虚拟机更轻量级的方式部署，因为它们具有更宽松的隔离属性(不绑定到特定的虚拟机)，并且是可移植的、高效的和一致的。</p><p id="34d3" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">现在我们已经建立了容器的使用，什么是容器管理？</p><p id="3543" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">集装箱管理是我们创建、部署、组织和扩展集装箱的方式。假设我们想要托管一个网站，并决定使用容器。</p><p id="7fc0" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们用我们的站点定义了一个容器，并希望将它部署在云上。我们希望运行不止一个容器实例，并且希望在这些实例之间分配流量，以及在出现问题时让它们退出循环。这都是通过容器管理完成的。</p><p id="0a1a" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们已经介绍了相关的概念，现在让我们来考察Kubernetes本身。Kubernetes是Google开发的开源容器管理系统。</p><p id="a2a9" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">让我们把系统分解成它的组成部分，一路上解释它们的目的。</p><h2 id="65a6" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">库伯内特星团</h2><p id="58e5" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">这些收集并协调一组高度可用的计算机(称为<strong class="kh hj">节点</strong>)。我们将一个容器部署到集群，集群决定如何最好地将该容器放置在任何给定的节点上。组织集群的逻辑由<strong class="kh hj">控制平面</strong>负责，它通过运行在节点上的API和<strong class="kh hj"> Kubelet </strong>服务与节点通信。此外，将有一个容器服务运行在节点上(如Docker ),以便管理容器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/6f04e542a86c48a69b4f897046d3d819.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*VqFAYAy83FpP2qWgSf0bSw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A Kubernetes Cluster</figcaption></figure><h2 id="fdd6" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">Kubernetes部署</h2><p id="ac31" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">如果我们有一个集群组织，我们会想把一些东西放在上面。这是我们进行<strong class="kh hj">部署配置</strong>的地方。这包含您的容器的图像和您想要运行的实例的数量。控制平面使用它在节点上更新或创建这些实例。它还监视已部署的容器，如果它们有问题，就替换它们。</p><p id="a9c8" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们可以使用<strong class="kh hj"> kubectl、【Kubernetes的命令行过程来组织这一切。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/fb23344ebd4908c64edeb11b7d0ac511.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*pB5DKVkf8APiKrKGdyoITA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A Kubernetes Deployment</figcaption></figure><h2 id="b189" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">单元和节点</h2><p id="5ec2" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">当我们部署容器时，它们在<strong class="kh hj">容器</strong>中运行。pod用于对容器和资源进行分组，其中容器共享一个公共的IP地址和端口号。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/7f480c4365bc87ca433bed31434884bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Ph1ASl9CC1pD1Dgqz9-mlA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Introducing Pods</figcaption></figure><p id="571b" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">默认情况下，窗格仅对其他服务可见。如果我们想从群集外部联系他们，我们需要使用代理。</p><h2 id="caed" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">服务</h2><p id="e6e4" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">pod被逻辑分组，它们的访问策略由YAML文件中构建的<strong class="kh hj">服务</strong>定义。一个服务所指向的pod集通常由一个<strong class="kh hj">标签选择器</strong>定义。我们可以使用服务来做一些事情，比如创建一个负载均衡器，但是它们也负责让pod死去，然后在必要的时候复制它们。</p><p id="b58b" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">服务使用标签和选择器来处理pod。标签可用于添加版本标签或对对象进行分类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/e5ae674c2cd45325d6549b6383f17996.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*sEU-ncuXb-wRn5EDULPPnw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Kubernetes Services and Selectors</figcaption></figure><p id="5c70" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们已经引入了<strong class="kh hj">副本集的概念。</strong>这些用于保持稳定数量的Pod同时运行，并包含一个<strong class="kh hj"> Pod模板</strong>用于在必要时创建新的Pod。</p><p id="2e58" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">让我们引入更多的概念，并在一个使用AWS EKS的例子中阐明以上所有内容。</p><h2 id="0ecb" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">AWS EKS的工作示例</h2><p id="3a53" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这个简短的示例中，我们将向EKS部署一个示例React应用程序。大多数必要的代码可以在这里的库<a class="ae lb" href="https://github.com/JamesCollerton/Docker-React-App" rel="noopener ugc nofollow" target="_blank">中找到</a>。</p><p id="4746" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">EKS很有用，因为它允许我们在AWS中托管节点，并处理补丁、节点供应和更新。我们可以跨可用性区域分布节点以获得更高的可靠性，AWS提供了托管组节点和Fargate等服务，这将有助于资源扩展。</p><p id="53e4" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们需要做的第一件事是创建React应用程序，并为它构建一个Docker映像。Docker映像然后用于创建容器，我们将在EKS上运行这些容器。</p><p id="10da" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们使用以下方式创建应用程序:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="f4dc" class="lj jo hi lz b fi md me l mf mg">npx create-react-app my-app</span></pre><p id="8a34" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">让我们浏览一下<code class="du mh mi mj lz b">src/App.js</code>文件并做一些修改。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="5a0b" class="lj jo hi lz b fi md me l mf mg">function App() {</span><span id="16a0" class="lj jo hi lz b fi mk me l mf mg">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>          &lt;p&gt;<br/>            This is our example AWS EKS application!<br/>          &lt;/p&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );</span><span id="37f6" class="lj jo hi lz b fi mk me l mf mg">}</span></pre><p id="0c91" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">用<code class="du mh mi mj lz b">npm start</code>运行React应用程序，我们得到下面的屏幕。这就是我们试图让我们的应用程序在EKS上运行时所希望的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/6e400f80582a8ff8eced9d0f8a5489c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0Qz6ZXaQoY0MQDd4jM4mg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Let’s host this on EKS!</figcaption></figure><p id="59fa" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">现在我们需要建立一个Docker图像。回到我们引入容器的最初原因，我们的映像定义了我们需要什么样的环境来运行我们的代码。</p><p id="d291" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们还可以利用Docker进行多阶段构建。除了需要一致的环境来运行我们的代码，我们还需要一致的环境来构建我们的代码。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="499a" class="lj jo hi lz b fi md me l mf mg">########################################<br/># An environment to build our code</span><span id="8e05" class="lj jo hi lz b fi mk me l mf mg"># This is the base image. We want to build our own<br/># image on top of this.<br/>FROM node:15.14.0-alpine3.10 as build</span><span id="eec4" class="lj jo hi lz b fi mk me l mf mg"># We set the container working directory to my-app<br/>WORKDIR /my-app</span><span id="7b0a" class="lj jo hi lz b fi mk me l mf mg"># Next we add the node modules to the path on the image<br/>ENV PATH /my-app/node_modules/.bin:$PATH</span><span id="0206" class="lj jo hi lz b fi mk me l mf mg"># We copy over our package.json and package-lock.json<br/>COPY my-app/package.json ./<br/>COPY my-app/package-lock.json ./</span><span id="22cd" class="lj jo hi lz b fi mk me l mf mg"># We install our dependencies<br/>RUN npm ci</span><span id="6254" class="lj jo hi lz b fi mk me l mf mg"># Copy over all of the files from our local machine and<br/># run the build command</span><span id="cbce" class="lj jo hi lz b fi mk me l mf mg">COPY my-app/. ./<br/>RUN npm run build</span><span id="0679" class="lj jo hi lz b fi mk me l mf mg">########################################<br/># An environment to run our code</span><span id="fa88" class="lj jo hi lz b fi mk me l mf mg"># This is the base image we want to use for our production<br/># build<br/>FROM nginx:stable-alpine</span><span id="8736" class="lj jo hi lz b fi mk me l mf mg"># Copy the built files onto our image<br/>COPY --from=build /my-app/build /usr/share/nginx/html</span><span id="a161" class="lj jo hi lz b fi mk me l mf mg"># Expose port 80 to be accessed via HTTP<br/>EXPOSE 80</span><span id="79c3" class="lj jo hi lz b fi mk me l mf mg"># Start up the NGINX server<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="af62" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">这是我们将用来构建图像的docker文件，我们可以将它包装在一个<code class="du mh mi mj lz b">docker-compose</code>中，以便于运行它。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="ecc2" class="lj jo hi lz b fi md me l mf mg">version: '3.7'</span><span id="c8f5" class="lj jo hi lz b fi mk me l mf mg">services:<br/>  react-eks-app:<br/>    container_name: react-eks-app<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile<br/>    ports:<br/>      - '80:80'</span></pre><p id="0c75" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">一旦完成，我们就可以使用<code class="du mh mi mj lz b">docker-compose up --build</code>调出并构建容器。</p><p id="a3cf" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">接下来的阶段假设您已经安装了AWS CLI并且是最新的，<code class="du mh mi mj lz b">kubectl</code>已经安装，并且有一个拥有必要权限的AWS帐户。我们将按照这里的说明<a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html" rel="noopener ugc nofollow" target="_blank">进行操作</a>，以防您需要任何帮助来设置这些。</p><p id="9bdd" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们也将在一个合理的高水平上检查这些步骤。深入细节超出了中等文章的范围。关于创建集群的文章<a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html" rel="noopener ugc nofollow" target="_blank">将更完整地介绍接下来的几个部分。</a></p><h2 id="fb27" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">创建VPC和IAM角色</h2><p id="c844" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们首先需要一个VPC来部署我们的集群，这里我们使用AWS提供的堆栈。我们还需要一个IAM角色，我们可以将它分配给我们的集群，为它提供必要的EKS权限。</p><h2 id="18a8" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">创建EKS集群</h2><p id="6872" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">这是通过AWS控制台完成的。我们给它一个名字，即先前定义的角色，并将它链接到刚刚创建的VPC。</p><p id="a04c" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">一旦这一步完成，我们应该能够在控制台中看到它</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/6e701c03c6ed7c0ad080cb535e20bf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEmYt84URzJyuVCEfsTR1g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Our React EKS Cluster is now available!</figcaption></figure><h2 id="d2a6" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">配置我们的计算机以连接到群集</h2><p id="66c6" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们还需要本地机器能够连接到集群，这需要一个<code class="du mh mi mj lz b">kubeconfig</code>文件(一个用于使用<code class="du mh mi mj lz b">kubectl</code>工具配置Kubernetes访问的文件)。</p><p id="597c" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">完成后，我们可以运行<code class="du mh mi mj lz b">kubectl get svc</code>命令，并收到类似如下的响应:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/525adea04423263f4d92e09e451c329a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG7vO5lTRlm-ePd0MVct8w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">An example service response</figcaption></figure><h2 id="71e8" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">创建IAM OIDC提供程序</h2><p id="0799" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">这用于让我们的Kubernetes服务帐户访问AWS资源，完整的说明在上一篇文章中提供。</p><h2 id="7223" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">创建节点</h2><p id="6caa" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在我们有了一个集群和放置节点的地方(VPC ),我们可以开始将它们添加到我们的架构中了！我们将使用AWS Fargate，它是为EKS和ECS设计的。它使我们不再需要担心服务器，而是可以专注于应用程序。</p><p id="73aa" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们创建一个具有必要权限的Fargate配置文件，这允许我们根据容器的需要旋转资源。<strong class="kh hj"> <em class="lh">然而，</em> </strong>在这一步值得注意的是，如果我们想只使用Fargate(包括为集群的自动设置组件，如核心DNS，以及后来为我们的负载平衡器)，我们需要做一些额外的设置<a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-getting-started.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="c9c4" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">深呼吸，回顾一下</h2><p id="50b9" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">到目前为止，我们已经设置了用于部署节点的VPC、集群和必要的权限。但是，我们没有在集群中部署任何东西，也没有提供访问运行在集群中的服务的方法。在接下来的步骤中，我们将完成上述两项工作，更多详细信息请参见本文关于部署AWS负载平衡器控制器的<a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html" rel="noopener ugc nofollow" target="_blank">和本文关于部署应用程序负载平衡器的</a>和<a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="f928" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">安装AWS负载平衡器控制器</h2><p id="ca94" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">它为Kubernetes集群管理AWS弹性负载平衡器。我们将使用它来创建一个应用程序负载平衡器，将流量路由到我们的React应用程序。</p><p id="87d3" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">一旦完成这些步骤，我们应该能够运行命令<code class="du mh mi mj lz b">kubectl get deployment -n kube-system aws-load-balancer-controller</code>并看到如下所示的内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/991473c525a0befaadfbde4ac260f953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uoyv8D24kDHkonl5wEJlyA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">AWS Load Balancer Controller service</figcaption></figure><h2 id="d47f" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">创建图像存储库并添加图像</h2><p id="94fb" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在，我们希望将在上一步中创建的图像添加到一个图像存储库中，这样它就可以被拉下来并作为一个容器运行。为此，我们将使用<a class="ae lb" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> ECR </a>，即AWS图像库。图像存储库是存储图像的方式，这些图像可以作为容器在其他地方运行。</p><p id="62eb" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">创建ECR存储库非常简单。在AWS控制台中，导航到<code class="du mh mi mj lz b">us-west-2</code>区域，转到ECR并找到创建按钮。我们需要做的就是输入我们想要使用的存储库的名称。</p><p id="7826" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">完成后，我们需要标记之前构建的映像，以便将其连接到新的存储库:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="f0b7" class="lj jo hi lz b fi md me l mf mg">docker tag &lt;image-id&gt; &lt;aws_account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/react-eks-app</span></pre><p id="c5cc" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们现在需要<a class="ae lb" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html" rel="noopener ugc nofollow" target="_blank">向我们的私有存储库</a>认证docker。通过认证后，我们现在可以推送我们的映像。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="fca0" class="lj jo hi lz b fi md me l mf mg">docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/react-eks-app</span></pre><p id="f11c" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们应该可以在ECR中看到</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/da60dcf77595eeadb07c709ebe7337b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZBLR_lMHnHsfaxNVA_XXQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Viewing our image in ECR</figcaption></figure><h2 id="61dc" class="lj jo hi bd jp lk ll lm jt ln lo lp jx ko lq lr jz ks ls lt kb kw lu lv kd lw bi translated">将映像部署到我们的EKS集群</h2><p id="cf2e" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">最后，我们需要在集群上将映像作为容器运行。首先，我们需要创建一个Fargate概要文件，它允许我们为应用程序部署节点。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="cd90" class="lj jo hi lz b fi md me l mf mg">eksctl create fargateprofile --cluster &lt;my-cluster&gt; --region &lt;region-code&gt; --name &lt;alb-sample-app&gt; --namespace &lt;namespace&gt;</span></pre><p id="347a" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">下一步是创建一个引用我们图像的<code class="du mh mi mj lz b">yaml</code>文件。整个文件可以在这里看到<a class="ae lb" href="https://github.com/JamesCollerton/Docker-React-App/blob/main/eks-service-definition/services.yaml" rel="noopener ugc nofollow" target="_blank">，但是核心组件是:</a></p><ol class=""><li id="e6a6" class="mq mr hi kh b ki lc kl ld ko ms ks mt kw mu la mv mw mx my bi translated">一次部署运行我们的应用程序。这是获取我们之前推送到我们的存储库的映像并将其部署在一个节点上。</li><li id="7798" class="mq mr hi kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">一个节点端口服务，用于在集群的每个节点上打开一个端口。我们通过<code class="du mh mi mj lz b">http</code>运行我们的应用程序，所以我们使用端口80。Kubernetes然后将<code class="du mh mi mj lz b">NodePort</code>上的传入流量路由到我们的应用程序，而不考虑它的节点。</li><li id="ac60" class="mq mr hi kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">一个应用程序负载平衡器入口。这就是从外部世界获取请求并将它们定向到我们的容器的原因。</li></ol><p id="c729" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们可以使用这个文件，通过下面的命令来更新我们的集群:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="e9bc" class="lj jo hi lz b fi md me l mf mg">kubectl apply -f &lt;file name&gt;.yaml</span></pre><p id="6df8" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">完成后，我们可以运行下面的。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="31fd" class="lj jo hi lz b fi md me l mf mg">kubectl get ingress/ingress-react-eks -n react-eks</span></pre><p id="b577" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">这将给我们一个类似于这个图像的响应，但是有一个填充的地址。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/3b8c8c6517f44f02b35e4d56ce99f6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyfyurjRyIBwtKbNIpKN-g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">An example of an ingress response</figcaption></figure><p id="9f14" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">将网址复制到我们的工具栏中，我们可以看到我们的应用程序被提供给我们！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/6e400f80582a8ff8eced9d0f8a5489c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0Qz6ZXaQoY0MQDd4jM4mg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The same site on EKS!</figcaption></figure><h1 id="7916" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">结论</h1><p id="fd9c" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">总之，我们已经讨论了集装箱化和集装箱管理的动机和实现，并以一个使用AWS EKS的实例达到高潮。</p></div></div>    
</body>
</html>
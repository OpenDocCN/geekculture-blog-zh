<html>
<head>
<title>Ultimate Guide to make Widgets in iOS development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS开发中制作小工具的终极指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/ultimate-guide-to-make-widgets-in-ios-development-ff883a9d4c35?source=collection_archive---------2-----------------------#2021-07-11">https://medium.com/geekculture/ultimate-guide-to-make-widgets-in-ios-development-ff883a9d4c35?source=collection_archive---------2-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="e9a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将为iOS应用程序制作一个小部件。首先，我们需要回答自己几个问题:</p><ol class=""><li id="10f3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">我们将在Widget中显示什么信息？</li><li id="ea9c" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">我们需要多久更新一次小部件中的数据？</li><li id="77ee" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">用户可以配置我们的小部件吗？</li></ol><p id="dd45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦你准备好了答案，开始用下面的步骤做一个。即使你对以上问题不确定，也要马上开始。你可以在这篇文章结束前回答。</p><h2 id="1064" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">向项目中添加新目标</h2><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/f59f0c7200c764145d83c454fb146661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qruiTYKNICe6NGCXKd9TLQ.png"/></div></div></figure><p id="a3c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像任何其他扩展一样，Widget也是我们应用程序的一个扩展。它从主应用程序获取数据的方式与其他扩展相同。</p><h2 id="8327" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">向目标添加文件和功能</h2><p id="81bd" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">共享数据的一些常见步骤是选择所需的文件并添加到小部件目标。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lk"><img src="../Images/ec53f5431713768caf74bd85a7c95329.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*OiOGmwAehVJ9ONNcJ-LEvg.png"/></div></figure><p id="675f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并添加必要的功能，如应用程序组、云工具包容器等..</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ll"><img src="../Images/7c0da0d193e66586456f5ebeb0a8736c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AA8tiyUvlfNxS7JuRX2ZHA.png"/></div></div></figure><h2 id="2e11" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">代码的更改</h2><p id="317d" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">对代码进行必要的更改，以便可以在扩展中使用数据。例如，如果您的应用程序使用核心数据，那么我们可以使用应用程序组来共享数据，如下所示:</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="3615" class="jy jz hi ln b fi lr ls l lt lu">class CustomPersistantContainer : NSPersistentContainer {<br/>static let url =   FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.maheshsai.******")!</span><span id="799f" class="jy jz hi ln b fi lv ls l lt lu">let storeDescription = NSPersistentStoreDescription(url: url)</span><span id="c773" class="jy jz hi ln b fi lv ls l lt lu">override class func defaultDirectoryURL() -&gt; URL {</span><span id="027c" class="jy jz hi ln b fi lv ls l lt lu">   return url</span><span id="7cd4" class="jy jz hi ln b fi lv ls l lt lu">}</span><span id="9947" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><p id="c69b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们可以使用CustomPersistentContainer来代替NSPersistentContainer。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="9343" class="jy jz hi ln b fi lr ls l lt lu">container = CustomPersistantContainer(name: "tracker")</span></pre><p id="2aba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以使用CoreData框架存储的数据进行扩展。</p><p id="1fd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:不要忘记将所有必需的文件添加到小部件目标中。</p><p id="3ac1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述步骤对于任何使用主应用程序数据的扩展都是通用的。但是以下是特定于小部件的。</p><h2 id="e62e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">SwiftUI视图</h2><p id="5ae2" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">小部件使用声明性框架SwiftUI向用户显示信息。下面是一个显示一些信息的小例子。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="e327" class="jy jz hi ln b fi lr ls l lt lu">struct viewbox: View {</span><span id="96cc" class="jy jz hi ln b fi lv ls l lt lu"> var int: Int</span><span id="f0a0" class="jy jz hi ln b fi lv ls l lt lu"> var colorForBackground: Color</span><span id="64ed" class="jy jz hi ln b fi lv ls l lt lu"> var name: String</span><span id="f00c" class="jy jz hi ln b fi lv ls l lt lu"> var extra: String</span><span id="9bf3" class="jy jz hi ln b fi lv ls l lt lu"> var body: some View {</span><span id="025d" class="jy jz hi ln b fi lv ls l lt lu">   VStack(alignment: .center) {</span><span id="68b9" class="jy jz hi ln b fi lv ls l lt lu">    HStack(alignment: .center, spacing: 12) {</span><span id="d892" class="jy jz hi ln b fi lv ls l lt lu">    Image(systemName: name)</span><span id="8a93" class="jy jz hi ln b fi lv ls l lt lu">     .resizable()</span><span id="d5de" class="jy jz hi ln b fi lv ls l lt lu">     .frame(width: 20, height: 20)</span><span id="85fc" class="jy jz hi ln b fi lv ls l lt lu">     .foregroundColor(colorForBackground)</span><span id="7ebd" class="jy jz hi ln b fi lv ls l lt lu">    Text("\(int)")</span><span id="90b6" class="jy jz hi ln b fi lv ls l lt lu">     .bold()</span><span id="01cf" class="jy jz hi ln b fi lv ls l lt lu">     .foregroundColor(.black)</span><span id="6073" class="jy jz hi ln b fi lv ls l lt lu">  }</span><span id="7577" class="jy jz hi ln b fi lv ls l lt lu">  Text(extra)</span><span id="903e" class="jy jz hi ln b fi lv ls l lt lu">    .foregroundColor(.black)</span><span id="d95c" class="jy jz hi ln b fi lv ls l lt lu">  }</span><span id="4c46" class="jy jz hi ln b fi lv ls l lt lu"> }</span><span id="eec8" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><p id="ac52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，我们需要构建一些显示数据的SwiftUI视图。</p><h1 id="4548" class="lw jz hi bd ka lx ly lz ke ma mb mc ki md me mf kl mg mh mi ko mj mk ml kr mm bi translated">小部件的配置和一致性</h1><p id="a66f" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">添加配置是制作小部件的关键步骤。</p><p id="fd16" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">配置可以是静态的或动态的。</p><h2 id="32aa" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">静态配置</h2><p id="7391" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">顾名思义，这个小部件显示一些没有用户可配置选项的信息。例如显示未决和关键任务总数的小部件。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="7a75" class="jy jz hi ln b fi lr ls l lt lu">struct trackerWidget: Widget {</span><span id="f698" class="jy jz hi ln b fi lv ls l lt lu"> let kind: String = "com.maheshsai.trackerWidget"</span><span id="e7c3" class="jy jz hi ln b fi lv ls l lt lu"> var body: some WidgetConfiguration {</span><span id="504c" class="jy jz hi ln b fi lv ls l lt lu"> StaticConfiguration(kind: kind, provider: Provider()) { entry in</span><span id="d5ed" class="jy jz hi ln b fi lv ls l lt lu">   trackerWidgetEntryView(entry: entry)</span><span id="ec0c" class="jy jz hi ln b fi lv ls l lt lu"> }</span><span id="add2" class="jy jz hi ln b fi lv ls l lt lu"> .supportedFamilies([.systemSmall])</span><span id="87a3" class="jy jz hi ln b fi lv ls l lt lu"> .configurationDisplayName("Tracker Widget")</span><span id="9e1d" class="jy jz hi ln b fi lv ls l lt lu"> .description("Track the count of pending and completed projects")</span><span id="70e7" class="jy jz hi ln b fi lv ls l lt lu"> }</span><span id="eb49" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><h2 id="57ec" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">意图配置</h2><p id="9581" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">与静态配置不同，意向配置为用户提供了选项。例如，显示特定项目中未完成任务总数的小部件。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="5ea3" class="jy jz hi ln b fi lr ls l lt lu">struct taskWidget: Widget {</span><span id="5930" class="jy jz hi ln b fi lv ls l lt lu"> private let kind: String = "com.maheshsai.TaskWidget"</span><span id="2ab1" class="jy jz hi ln b fi lv ls l lt lu"> public var body: some WidgetConfiguration {</span><span id="2eae" class="jy jz hi ln b fi lv ls l lt lu"> IntentConfiguration(kind: kind, intent: DynamicProjectsIntent.self,  <br/> provider: taskProvider()) { entry in</span><span id="10c7" class="jy jz hi ln b fi lv ls l lt lu">   TaskWidgetView(entry: entry)</span><span id="2e64" class="jy jz hi ln b fi lv ls l lt lu"> }</span><span id="9a79" class="jy jz hi ln b fi lv ls l lt lu"> .configurationDisplayName("Task Widget") </span><span id="49e5" class="jy jz hi ln b fi lv ls l lt lu"> .description("See some of the tasks from selected project.")</span><span id="2490" class="jy jz hi ln b fi lv ls l lt lu"> .supportedFamilies([.systemMedium])</span><span id="e781" class="jy jz hi ln b fi lv ls l lt lu"> }</span><span id="d2de" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><p id="ef60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些选项来自意图参数。</p><p id="8a43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像Siri快捷方式意图一样，我们需要定义一个意图，在运行时向用户提供值。为此，请遵循以下步骤。</p><ol class=""><li id="21e2" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">在小部件目标内创建意图定义文件，并添加意图和响应。</li></ol><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mn"><img src="../Images/5dcd40e62cf3a502f22659458e242a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08dlhfAyvnVEPYz-pyLd2w.png"/></div></div></figure><p id="3262" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.使意图符合微件的条件。</p><p id="ebdb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.添加参数并自定义它们。</p><p id="64e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.添加意图扩展目标并确认该类为创建的意图。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mo"><img src="../Images/67634e875e650f3e05d1e635407b0369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DhDcIqQR-3QxbkBDKl_Yw.png"/></div></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mp"><img src="../Images/80dc777bb588d1694d6f9e10dfc2e902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0_1ZY024H3z3KygtcFItQ.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">Intents.sift inside IntentExtension</figcaption></figure><p id="9742" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述代码为用户提供了项目选项。当用户编辑小工具时，可以选择上面提供的选项。</p><p id="42df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了名称，我们可以在创建类型时提供字幕和图像，如下所示</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="ad0c" class="jy jz hi ln b fi lr ls l lt lu">let imag = UIImage(systemName: $0.image ?? <br/>                   "")?.withTintColor(.label)</span><span id="f0f5" class="jy jz hi ln b fi lv ls l lt lu">return Type(identifier: $0.name, display: $0.name ?? "", subtitle: <br/>     nil, image: INImage(imageData: imag?.pngData() ?? Data()))</span></pre><p id="5568" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了配置之外，小部件还接受种类和提供者参数。</p><p id="4532" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">kind是小部件的唯一标识符。我们将在下一节看到条目和时间轴提供者。</p><p id="c09a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">主体也使用修饰符来提供显示名称和描述。受支持的家庭目前有3个选项，可以是小型、中型和大型。根据支持的系列选项，小工具会占用屏幕空间。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mu"><img src="../Images/61f5fc0caa3624a6518e68f3a938f409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kboh16t5b0BN-QQqsSeq0Q.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">Medium and Large Calendar Widgets</figcaption></figure><h1 id="1528" class="lw jz hi bd ka lx ly lz ke ma mb mc ki md me mf kl mg mh mi ko mj mk ml kr mm bi translated">时间轴提供程序和条目</h1><p id="4f5b" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">时间轴提供程序取决于小部件的配置。如果小部件使用动态配置，则它采用IntentTimeLine提供程序，否则它采用TimeLine提供程序。</p><p id="d568" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">无论时间轴提供者的类型是什么，如果我们观察静态和动态配置的示例代码，两者都使用条目。</p><p id="481f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">条目是符合时间线条目协议的结构。它包含SwiftUI视图使用的日期(何时显示内容)和其他信息。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="a74e" class="jy jz hi ln b fi lr ls l lt lu">struct SimpleEntry: TimelineEntry {</span><span id="b787" class="jy jz hi ln b fi lv ls l lt lu"> let date: Date</span><span id="099d" class="jy jz hi ln b fi lv ls l lt lu"> var completed: Int</span><span id="2208" class="jy jz hi ln b fi lv ls l lt lu"> var noncompleted: Int</span><span id="5a8b" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><p id="5802" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该条目由TimelineProvider提供给Configuration，然后SwiftUI视图使用它来显示内容。</p><p id="45b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看时间轴提供者是如何向配置提供条目的。</p><h2 id="2be8" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">符合时间线提供者/意向时间线提供者</h2><p id="35b6" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">我们将首先创建一个向TimeLineProvider或IntentTimeLineProvider确认的结构。</p><p id="32cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于协议的确认，该结构需要有3个功能，提供一个占位符，快照和时间轴。</p><p id="e7f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">占位符功能为用户提供没有内容的通用占位符视图的入口。</p><p id="0b3e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">快照功能提供瞬时情况下的视图入口，如小部件图库中的小部件。</p><p id="83f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Timeline函数为当前和未来时间提供了一个条目数组来更新一个小部件。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mv"><img src="../Images/fd3e03e7e6304596884b7b742980e08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPfjeSBQiJS8ElIKxPLjfw.png"/></div></div></figure><p id="514d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的函数中，它提供了五个条目，每隔一小时显示一次。同样，您可以提供对应于当前日期和时间的单个条目。</p><p id="353f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们观察最后一行，它包含一个更新时间表的策略。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="f06e" class="jy jz hi ln b fi lr ls l lt lu">let timeline = Timeline(entries: entries, policy: .atEnd)</span></pre><p id="2730" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的策略决定了您的小部件需要更新的频率。该策略可以在()之后使用，也可以从不使用。</p><p id="1537" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">顾名思义，atEnd策略在现有时间线结束后刷新时间线，即在上述示例中完成五个条目后创建新的时间线。</p><p id="d5c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">之后(日期: )仅在指定的日期和时间之后刷新时间线。</p><p id="e237" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除非明确重新加载时间线，否则不会刷新时间线。我们可以使用下面的函数从主应用程序中显式地重新加载特定窗口小部件或所有窗口小部件的时间线。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="ffa1" class="jy jz hi ln b fi lr ls l lt lu">WidgetCenter.shared.reloadTimelines(ofKind: "com.maheshsai.TaskWidget")</span><span id="e3c5" class="jy jz hi ln b fi lv ls l lt lu">WidgetCenter.shared.reloadAllTimelines()</span></pre><p id="64bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如前所述，种类唯一地标识每个部件。</p><p id="9ddf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只有当用户在应用程序中进行更改时，像Notes这样的应用程序的小部件才需要更改内容。因此，他们使用从不策略，并在应用程序内完成更改时重新加载。</p><p id="04f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:小部件的智能在于配置和时间线的设计。</p><h2 id="b569" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">WidgetURL</h2><p id="4d72" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">如果你想在点击你的小工具时登陆应用程序的特定部分，而不是你的应用程序的登陆页面，那么你需要添加。SwiftUI视图的widgetURL(url)。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="4322" class="jy jz hi ln b fi lr ls l lt lu">struct WidgetDisplayView: View {<br/>  var body: some View {<br/>     VStack {<br/>     ...<br/>     }.widgetURL(URL("page2"))<br/>  }<br/>}</span></pre><p id="f9d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后进入主应用程序验证，并使用onOpenURL函数定义要做什么。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="a7fa" class="jy jz hi ln b fi lr ls l lt lu">struct MainDisplayView: View {</span><span id="2c38" class="jy jz hi ln b fi lv ls l lt lu"> ...</span><span id="1f24" class="jy jz hi ln b fi lv ls l lt lu"> var body: some View {</span><span id="de57" class="jy jz hi ln b fi lv ls l lt lu">   VStack {</span><span id="a265" class="jy jz hi ln b fi lv ls l lt lu">    ...</span><span id="a5dd" class="jy jz hi ln b fi lv ls l lt lu">    NavigationLink(destination:..,active: $isActive,label:...)</span><span id="4582" class="jy jz hi ln b fi lv ls l lt lu">   }.onOpenURL { url in</span><span id="0390" class="jy jz hi ln b fi lv ls l lt lu">     if url == URL("page2") {</span><span id="8b16" class="jy jz hi ln b fi lv ls l lt lu">       isActive = true</span><span id="6270" class="jy jz hi ln b fi lv ls l lt lu">     }</span><span id="ef12" class="jy jz hi ln b fi lv ls l lt lu">   }</span><span id="08d9" class="jy jz hi ln b fi lv ls l lt lu">}</span></pre><h1 id="6927" class="lw jz hi bd ka lx ly lz ke ma mb mc ki md me mf kl mg mh mi ko mj mk ml kr mm bi translated">iOS15中的新功能</h1><p id="b001" class="pw-post-body-paragraph im in hi io b ip lf ir is it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj hb bi translated">从iOS 15开始，我们可以通过捐赠意图来扩展我们的小工具的智能，就像任何其他siri意图和快捷方式的捐赠一样。</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="07a2" class="jy jz hi ln b fi lr ls l lt lu">// Donate INIntent from the app</span><span id="1ab7" class="jy jz hi ln b fi lv ls l lt lu">.onAppear {<br/>    let intent = ViewRecentIntent()<br/>    intent.project = Project(identifier: project.id.uuidString, displayString: project.name)</span><span id="b454" class="jy jz hi ln b fi lv ls l lt lu">let interaction = INInteraction(intent: intent, response: nil)<br/>    interaction.donate { error in<br/>        if let error = error {<br/>            print(error.localizedDescription)<br/>        }<br/>    }<br/>}</span></pre><p id="26c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一种方法是提供相关性</p><pre class="ku kv kw kx fd lm ln lo lp aw lq bi"><span id="79d2" class="jy jz hi ln b fi lr ls l lt lu">var relevantShortcuts: [INRelevantShortcut] = []</span><span id="d82b" class="jy jz hi ln b fi lv ls l lt lu">if let shortcut = INShortcut(intent: intent) {<br/>    let relevantShortcut = INRelevantShortcut(shortcut: shortcut)<br/>    relevantShortcut.shortcutRole = .information<br/>    relevantShortcut.widgetKind = “com.maheshsai.suggestionsWidget”</span><span id="7256" class="jy jz hi ln b fi lv ls l lt lu"> let dateProvider = INDateRelevanceProvider(start: Date(), <br/>                                               end:  <br/> Date(timeIntervalSinceNow: 1800))<br/>    relevantShortcut.relevanceProviders = [dateProvider]</span><span id="7671" class="jy jz hi ln b fi lv ls l lt lu"> relevantShortcuts.append(relevantShortcut)<br/>}</span><span id="0a95" class="jy jz hi ln b fi lv ls l lt lu">INRelevantShortcutStore.default.setRelevantShortcuts(relevantShortcuts) { (error) in<br/>    if let error = error {<br/>        print("Failed to set relevant shortcuts. \(error))")<br/>    } else {<br/>        print("Relevant shortcuts set.")<br/>    }<br/>}</span></pre><p id="9834" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将提供从开始日期和时间到结束日期和时间的相关性。因此，如果这个小部件隐藏在一个堆栈中，那么关联系统会将它放在那个时间段的顶部。</p><p id="2b61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是这样！！</p><p id="6401" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您仍有问题，请按照<a class="ae mw" href="https://developer.apple.com/news/?id=yv6so7ie" rel="noopener ugc nofollow" target="_blank"> WWDC20 </a>中的代码进行操作</p><p id="cba4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读:)</p></div></div>    
</body>
</html>
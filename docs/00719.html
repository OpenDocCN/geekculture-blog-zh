<html>
<head>
<title>Using Native, Unbundled ES6 Modules With a Simple Build Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过简单的构建管道使用本机、非捆绑的ES6模块</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-native-unbundled-ecmascript-modules-with-a-simple-build-pipeline-351574a32815?source=collection_archive---------10-----------------------#2021-03-11">https://medium.com/geekculture/using-native-unbundled-ecmascript-modules-with-a-simple-build-pipeline-351574a32815?source=collection_archive---------10-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/81ea936bef1b81c335b4c5d646c6a63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_yFu1PcNZQNfXcIiEopOQ.png"/></div></div></figure><p id="1e17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的旅程开始于大约七年前，当时YUI3被雅虎砍掉。</p><p id="296d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的应用程序在从开发到生产的每一个环境中都使用了ECMAScript模块(也称为ES6模块或ESM)。没有捆绑，代码分块/分裂，或其他复杂的构建设置。</p><h1 id="1b43" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="4ef7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的应用程序是一个服务器端渲染的多页面应用程序。它有大约50-100个不同的页面，取决于你如何计数。许多这样的页面都有专门的JS控制器。大多数还为UI组件(例如下拉菜单、标签视图)、实用程序(例如事件委托)和其他东西使用共享模块。</p><p id="4026" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些模块中的大多数(控制器、组件、实用程序等)都依赖于其他模块，并且这些依赖关系可能会重叠。</p><p id="613d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="894c" class="lb jq hi kx b fi lc ld l le lf">// controller.js<br/>import Stateful from '../util/stateful.js';<br/><br/>import('../components/panel.js').then(mod =&gt; new mod.default());<br/><br/>// panel.js<br/>import Stateful from '../util/stateful.js';</span></pre><p id="4147" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺便说一句，您可能已经注意到模块名称以<code class="du lg lh li kx b">../</code>开头！你可能已经习惯在<a class="ae jo" href="https://v8.dev/features/modules" rel="noopener ugc nofollow" target="_blank">里看到<code class="du lg lh li kx b">import mod from 'name';</code>你的</a> <a class="ae jo" href="https://exploringjs.com/es6/ch_modules.html#sec_overview-modules" rel="noopener ugc nofollow" target="_blank">最喜欢的</a> <a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">学习</a> <a class="ae jo" href="https://www.geeksforgeeks.org/how-to-use-an-es6-import-in-node-js/" rel="noopener ugc nofollow" target="_blank">资源</a>。但是在浏览器中，模块名<em class="lj">必须</em>是绝对或相对路径，所以<em class="lj">必须以</em>、<code class="du lg lh li kx b">../ </code>或<code class="du lg lh li kx b">/</code>开头。(继续在你的控制台中键入<code class="du lg lh li kx b">import('foo');</code>，看看会发生什么。我会在这里等。)</p><h2 id="1f9a" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">本机模块加载</h2><p id="783a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的应用直到最近还在使用<a class="ae jo" href="https://clarle.github.io/yui3/yui/docs/yui/#dynamic-loading-with-use" rel="noopener ugc nofollow" target="_blank"> YUI3的模块加载器</a>，我想找一个好的替代品。</p><p id="6015" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么ES6模块加载在浏览器中是如何工作的呢？</p><p id="5b5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，看看<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#syntax" rel="noopener ugc nofollow" target="_blank">文档的状态</a>，<a class="ae jo" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1656248" rel="noopener ugc nofollow" target="_blank">我在火狐</a>发现的这个bug(很快得到修复)以及缺乏教程和工具，你会认为这根本不可行，或者至少是最前沿的。根据谷歌Chrome的平台状态，<a class="ae jo" href="https://www.chromestatus.com/metrics/feature/timeline/popularity/2062" rel="noopener ugc nofollow" target="_blank">不到4%的页面负载使用它</a>！</p><p id="6f69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现的大多数<a class="ae jo" href="https://engineering.velocityapp.com/webpack-vs-browersify-vs-systemjs-for-spas-95b349a41fa0" rel="noopener ugc nofollow" target="_blank">资源都使用捆绑器</a>，比如<a class="ae jo" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> Webpack </a>，将你所有的代码捆绑到一个文件中，传输到ES5，并在此过程中加入任何需要的polyfills。</p><p id="c313" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我也试过<a class="ae jo" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank"> SystemJS </a>，它是/应该是一个用于导入的polyfill。我发现与一起工作非常困难，即使是琐碎的例子。</p><p id="dee8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，这些都没有必要，至少不再需要了！<a class="ae jo" href="https://caniuse.com/es6" rel="noopener ugc nofollow" target="_blank"> ES6 </a>和<a class="ae jo" href="https://caniuse.com/mdn-javascript_statements_import" rel="noopener ugc nofollow" target="_blank">导入</a>在所有浏览器上都得到<a class="ae jo" href="https://v8.dev/features/modules" rel="noopener ugc nofollow" target="_blank">支持(除了IE，很明显——很好的摆脱)。</a></p><h2 id="1ad9" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">捆扎机和单页应用程序</h2><p id="6174" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如今，大多数应用似乎都是SPAs，可用的库(React、Vue等)和构建工具(Webpack、Rollup等)反映了这种优势。</p><p id="ffd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对我来说，将所有的复杂性都转移到客户端是没有意义的，即使我们可以从头开始。大本营的<a class="ae jo" href="https://turbo.hotwire.dev/handbook/introduction" rel="noopener ugc nofollow" target="_blank">开发者同意</a>。</p><p id="2bfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将我们所有的Javascript代码捆绑到一个巨大的<code class="du lg lh li kx b">app.js</code>中也没有意义。对任何代码的任何更改都意味着需要完整的构建。</p><p id="722b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从技术上来说，web pack<a class="ae jo" href="https://webpack.js.org/concepts/entry-points/#multi-page-application" rel="noopener ugc nofollow" target="_blank">支持多页面应用</a>，但是看看他们对这项技术的描述有多少。创造50个以上的入口点似乎是一个绝对的噩梦。不要介意添加一个页面，忘记添加一个入口点，只是在生产中才发现。</p><h1 id="a69e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">挑战</h1><p id="8f71" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我想在ES6模块中编写代码，让事情变得简单。</p><p id="24f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有捆绑或分块，没有构建代理在后台持续传输文件，没有为开发和生产创建和维护复杂的构建架构。请不要这样！</p><p id="f4f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理想情况下，我们应该在IDE中编写ESM，并在开发中一字不差地使用这些文件。为了制作，我们显然会缩小。</p><h1 id="4f57" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决方案:本机ESM已准备好投入生产</h1><p id="05fa" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">幸运的是，在开发中使用原生ESM是微不足道的！</p><p id="0095" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以一字不差地把它交付生产，它也能正常工作。显然，你至少应该缩减代码。但是我们这么做已经很多年了，所以设置起来也很琐碎。</p><p id="e358" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看，这个解决方案非常简单，但是非常有效。</p><p id="7e6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么没人推荐这个？</p><h1 id="814d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">性能怎么样</h1><p id="0784" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">嗯，有一个重要的问题，那就是生产中的性能。(谷歌的V8团队在这个话题上有一本<a class="ae jo" href="https://v8.dev/features/modules#performance" rel="noopener ugc nofollow" target="_blank">非常好的入门</a>。去读吧。)</p><p id="f81e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，考虑这个依赖链</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c375" class="lb jq hi kx b fi lc ld l le lf">controller  -&gt; tabview<br/>  tabview     -&gt; buttongroup, widget<br/>    buttongroup -&gt; button, widget<br/>      button      -&gt; widget<br/>    widget      -&gt; stateful<br/>    stateful    -&gt; attribute, eventTarget</span></pre><p id="c58d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">浏览器需要依次下载这些文件<em class="lj"/>。例如，直到它已经加载了<code class="du lg lh li kx b">controller</code>，它才知道它需要<code class="du lg lh li kx b">tabview</code>。(糟糕的是,<code class="du lg lh li kx b">rel="modulepreload”</code>的支持<a class="ae jo" href="https://caniuse.com/?search=modulepreload" rel="noopener ugc nofollow" target="_blank">很差,</a>HTTP/2 push的配置<a class="ae jo" href="https://v8.dev/features/modules#http2" rel="noopener ugc nofollow" target="_blank">很难,</a>,因为这些可能会有所帮助。)</p><p id="4d8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">YUI的模块加载器通过向客户端发送完整的依赖图解决了这个问题。然后，它可以计算出需要哪些模块，并通过一个请求获取所有模块。整洁！</p><p id="49f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现代的<code class="du lg lh li kx b">import</code>不可能做到这一点，因为模块名必须是静态的——解析不能依赖于任何正在运行的代码。你连<code class="du lg lh li kx b">import foo from 'foo' + '.js';</code>都做不到！</p><p id="f705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(实际上，前面的语句只适用于<code class="du lg lh li kx b">import</code> <em class="lj">语句</em>。你可以用这种方式改进<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports" rel="noopener ugc nofollow" target="_blank"> <em class="lj">动态</em>导入</a>，但是不值得。你很快就会明白为什么。)</p><p id="efa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">HTTP/2和缓存在这里帮了很大的忙，但是浏览器仍然必须请求每个模块<em class="lj">，然后</em>才能开始下载它的依赖项。</p><h2 id="3698" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">内容哈希缓存-崩溃</h2><p id="70d2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">缓存破坏是提高资产下载性能的最常见的方式。通过给每个资产版本一个永久的URL，我们可以让浏览器(代理、cdn等)知道他们可以暂时(甚至无限期地)使用该资源的缓存版本，甚至不需要请求URL。</p><p id="41a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所需要的是类似于</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="095e" class="lb jq hi kx b fi lc ld l le lf">&lt;FilesMatch "\.\w{8}\.js$"&gt;<br/>  Header set Cache-Control "public, max-age=3133337, immutable"<br/>&lt;/FilesMatch&gt;</span></pre><p id="3cab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这完全解决了性能问题，因为浏览器从磁盘加载整个依赖链。</p><p id="1713" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法非常依赖热缓存。如果你的应用有很多使用冷缓存的用户，这种方法可能不适合你。</p><h2 id="fc2f" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">履行</h2><p id="fb13" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们能动态地将模块名改为<code class="du lg lh li kx b">import foo from './foo.r2d2.js'</code>，我们所有的问题都将迎刃而解。</p><p id="9e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我很惊讶我找不到任何解释如何做到这一点的博客、谈话或插件。</p><p id="1ab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我决定自己试一试。</p><p id="99c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实证明，编写一个向模块名添加内容哈希的<a class="ae jo" href="https://www.npmjs.com/package/babel-plugin-add-contenthash-to-imports" rel="noopener ugc nofollow" target="_blank"> Babel插件非常简单(多亏了</a><a class="ae jo" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" rel="noopener ugc nofollow" target="_blank">精彩的文档</a>):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="db55" class="lb jq hi kx b fi lc ld l le lf">// from<br/>import foo from './foo.js';<br/>import('../bar.js');</span><span id="b9b4" class="lb jq hi kx b fi lx ld l le lf">// to<br/>import foo from './foo.r2d2.js';<br/>import('../bar.c3p0.js');</span></pre><p id="606f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你甚至不需要重命名文件。只需将您的web服务器配置为忽略内容哈希:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="bdf8" class="lb jq hi kx b fi lc ld l le lf">RewriteRule ^(.+)\.\w{8}\.js$   $1.js  [last]</span></pre><h1 id="95f5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="80d4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如今在开发中使用ESM真的很容易。你不需要transpilers，bundlers，polyfills，什么都不需要！(如果你真的还需要支持IE，可以考虑另谋高就。我们正在招聘！)</p><p id="89e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，生产环境中的ESM同样简单，但我们确实需要做些事情来提高性能。</p><p id="e2a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，Babel插件非常容易实现，并在生产中产生非常快的性能。</p><p id="6b3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果也是非常缓存友好的，因为我们只使实际上已经改变的文件无效。(如果您捆绑文件，如果任何文件的<em class="lj">发生变化，您需要重新创建整个捆绑包。真是浪费！)</em></p><p id="586b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们的l10n设置，我们的应用程序确实有点复杂，但这是另一个故事了。</p><p id="67f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我真的希望这能帮助一些人。如果那个人是你，请和我分享你的经历！</p></div></div>    
</body>
</html>
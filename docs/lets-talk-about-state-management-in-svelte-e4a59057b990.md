# 让我们以苗条的身材谈论状态管理

> 原文：<https://medium.com/geekculture/lets-talk-about-state-management-in-svelte-e4a59057b990?source=collection_archive---------1----------------------->

![](img/e422c42e62acf7c7668773fab1af0d90.png)

Photo by [Ferenc Almasi](https://unsplash.com/@flowforfrank?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/svelte?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

在构建应用程序时，状态管理是一件非常重要的事情。Svelte 中的 State 与其他大型框架略有不同，我将对其进行比较以作出反应，因为这是我在构建大型应用程序方面最有经验的地方。

# 反应

斯维尔特对国家管理相对不执着，并拥抱[反应](https://svelte.dev/tutorial/reactive-declarations)。基本的状态更新是通过变量重新分配来完成的，这在 React 中最初感觉很奇怪，因为`let`很少见。这里有一个简单的例子:

点击该按钮将更新`movies`，这将导致`otherMovies`更新，而不是`moreMovies`。只有用反应式`$:`语法定义的变量(这是[有效但晦涩难懂的 JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label) )会在重新渲染时更新，用`const`定义的变量不会。这与 React 完全不同，React 中变量在每次渲染时都会更新，除非它们在`useEffect`中(并且依赖关系不会改变)。

`$:`语法实际上有点像 React 中的`useEffect`:用`$:`定义的任何东西都将在其依赖关系改变时更新，但是不需要传递依赖关系——它们是基于定义中的变量自动检测的。没有`useEffect`依赖数组，没有持续的 ESLint 警告。

在最初的学习曲线之后，这是一次非常愉快的经历。你更新状态和变化级联通过你的反应变量，而不需要管理额外的重新渲染自己。对于所有关于 React 的声明式模型的说法(我自己也说过！)，这感觉远比`useEffect`声明性强。

# 数据绑定

Svelte 也有双向数据绑定。这对于减少输入和表单的样板文件非常有用，但是当我开始使用它时，我的蜘蛛感觉开始刺痛。

![](img/e5c3bfd7af4a06132dbea9d08457f229.png)

Someone nearby is using two-way data binding!

双向数据绑定经常用到`[footgun](https://en.wiktionary.org/wiki/footgun)`这个词，原因如下:双向数据绑定允许(鼓励？)将状态管理推到应用程序的边缘。不同于单个真实来源或多个本地化来源，您的应用程序中分散的状态相互影响，没有清晰的通信模式。想象一下应用程序根的一些状态:

Bind to as many components as you like, go nuts!

在组件树的深处，你有一个带有`movies`道具的组件。双向数据绑定意味着当您更新该组件中的状态时…

…它在本地更新，但*也会更新原始状态*，并将更改传播到其他任何地方。祝你好运。

这种间接的状态管理是有问题的，但是当您需要对数据形状进行更新时，真正的乐趣就开始了。当数据形状的知识渗透到应用程序的所有角落时，更改就变得很麻烦，因为您需要更改使用该形状的每个实例。实现变得与数据形状相耦合，并且变化通常意味着您需要重新编写大块的应用程序。

这里有一个简单的例子:你的应用程序是为单个用户设计的，所以你拥有顶级的一切:

```
const state = {
  movies: [ ... ],
  reviews: [ ... ],
  favorites: [ ... ],
};
```

但是有人听说了你的应用，他们想加入。多个用户！太好了，我们就在这里更新这个状态…

```
const state = {
  me: {
    movies: [ ... ],
    reviews: [ ... ],
    favorites: [ ... ],
  },
  you: {
    posts: [ ... ],
    reviews: [ ... ],
    favorites: [ ... ],
  }
};
```

…现在，您必须更新所有期望状态处于第一个形状的组件。希望你能找到他们！

在开始之前花时间设计你的状态会有所帮助，但是在一个应用程序的生命周期中，总会有惊喜。弹性架构针对变化进行优化，一个很好的方法是使用封装和清晰的接口。这是绝对可能的，但你必须有意识地去做。

# 反应过来道

React 还允许您从任何地方直接操纵状态，但这不是一种常见的模式，数据流是清晰的。这是成功的**陷阱**的一个例子，在那里更难做错事。为了将数据形状缠绕到你的应用程序中，你必须通过道具层向下传递`setState`,但是更常见的模式是通过在状态旁边定义一个处理器并向下传递该处理器来创建一个接口。

如果正确使用 Reducers，这一点会更加清楚。Redux 有它的缺点，但是有一点它做对了，那就是关注点的分离。它鼓励在一个地方(reducer)进行状态管理，组件发送关于**用户做了什么**的消息(动作),而不是**状态应该如何更新。多么具有宣示性！**

让我们回到苗条的地方。状态管理有点“什么都行”，让用户自己决定。这需要一些经验来做出正确的选择，但好消息是苗条是灵活的。尽管默认情况下它不像 React *那样工作，但它允许相同的模式。*

Svelte 有商店，类似于`useState`，在这里你使用`set`和`update`函数来设置状态。您可以通过公开处理程序而不是直接`set/update`来创建一个干净的接口。Svelte 不包括减速器等效物，但使用`writable`商店，你可以用不到十行代码创建一个基本的`useReducer`:

苗条商店让你订阅更新，事实上你可以给任何东西一个方法来把它变成一个商店。我们的新店可以这样使用:

那个`$store`语法是订阅存储的速记访问，更改会自动传播。

# 外卖

我不知道我更喜欢 React 模式是因为它们客观上更好，还是仅仅因为我喜欢使用这些模式管理复杂的状态。我保持开放的态度，Svelte 可能有一个干净的和完全不同的方式来管理大型应用程序的状态。

另一件要记住的事情:**这确实只是大型应用程序的问题。**对于较小的应用程序，反应值和`let`重新分配的苗条模式工作良好。但是一个小的 app 在什么点上变成大的呢？你总是提前知道吗，或者有一天你打开你的笔记本电脑，意识到你已经把自己织进了一张纠结的网？我喜欢为变化做计划，我喜欢寻找方法来保持关注点的分离。

您甚至可以混合这些模式，在一个 reducer 中保存一些状态，并从该状态派生出反应值:

Mmmmmmovies!

这是个好主意吗？我还不确定。React 的护栏让做正确的事情变得容易(或者至少让做错误的事情变得更难)，但也可能是因为关于 React 状态管理的文章已经写了太多，而 Svelte 还不够年轻，清晰的模式尚未出现。

此外，关于双向数据绑定的注意事项:像类继承一样，它本质上并不坏，只是被滥用了。没有围绕输入和表单的样板文件是件好事，你只需要明智地使用它。与限制继承类似，限制绑定的层数是个好主意(即直接绑定到 HTML 元素，而不是其他纤细的组件)。

更有趣的是，苗条和反应在他们的观点上是如何不同的。Svelte 似乎在 CSS 和可访问性等问题上固执己见，而在状态管理上则不那么固执，React 正好相反。就我个人而言，我对状态管理的灵活性很满意(我也很高兴让框架做出一些 CSS 决定)，但我认为这可能会让新来者走上一条事情纠缠在一起的道路，这可能会给一些人留下负面的体验。

也可能不是！这些只是我在与 Svelte 合作一些复杂的项目时发现的一些有趣的观察。我还没有下定决心，但迄今为止，我对 Svelte 的体验非常积极，我真的在寻找它可以扩展的方法。我看到了很多希望，我希望它尽可能好。
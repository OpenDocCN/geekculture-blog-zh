<html>
<head>
<title>Higher Order Functions in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林中的高阶函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/higher-order-functions-in-kotlin-a65653a24b19?source=collection_archive---------9-----------------------#2022-10-29">https://medium.com/geekculture/higher-order-functions-in-kotlin-a65653a24b19?source=collection_archive---------9-----------------------#2022-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="37bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">高阶函数是这样一种函数，它要么接受一个函数作为自变量，要么返回一个函数作为值，或者两者都做。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e194f3925c193f91fe3bf2d7c622a9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rs2I56f0srXihiovliVDWQ.jpeg"/></div></div></figure><p id="4d2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kotlin中的lambda在编写和调用高阶函数时被大量使用，因为<strong class="ih hj"> we </strong> <strong class="ih hj">可以自由地将lambda函数作为表达式传递，而无需实际声明它。</strong></p><p id="3223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是lambda函数在kotlin中的写法</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="5505" class="ju jv hi jq b fi jw jx l jy jz">val lambdaFn: (String) -&gt; String = { s -&gt; "modified $s" }</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/c28acf39baa7f25c6d09bf416b8dd666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COli-z6UoAteooMIymjRqQ.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">sample code for lambda function</figcaption></figure><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="d6de" class="ju jv hi jq b fi jw jx l jy jz">output of above sample code: "modified sampleString"</span></pre><blockquote class="kf kg kh"><p id="a2c0" class="if ig ki ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated">关于lambda函数的更多细节可以在https://kot linlang . org/docs/lambda . html # lambda-expressions-and-anonymous-functions找到</p></blockquote></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="d505" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当定义一个函数作为一个高阶函数的参数时，我们使用一种叫做函数类型的东西。</strong></p><blockquote class="kf kg kh"><p id="df53" class="if ig ki ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated"><a class="ae km" href="https://kotlinlang.org/docs/lambdas.html#function-types" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/lambdas.html#function-types</a></p></blockquote><p id="9430" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">函数类型优于普通函数参数，因为它们在语法上更容易编写和理解。</strong></p><p id="b412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过一个例子来理解上面的说法——</p><h2 id="3a87" class="ju jv hi bd ku kv kw kx ky kz la lb lc iq ld le lf iu lg lh li iy lj lk ll lm bi translated">具有正常函数自变量的高阶函数:</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/03e223ddd76654c53e146bed911e5aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXAfZkWQ9RHEa4gt3hsYPw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">normal function as argument</figcaption></figure><h2 id="caeb" class="ju jv hi bd ku kv kw kx ky kz la lb lc iq ld le lf iu lg lh li iy lj lk ll lm bi translated">具有lambda函数自变量的高阶函数:</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/e9523928e5ac4e8ada9530e1da1fec88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXQYmvH1uxW5M-FFI5z4Ag.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">lambda function as argument</figcaption></figure><p id="6627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看一下上面的两个代码片段，我们就能理解lambda函数是如何更直观，以及它们是如何用更少的代码完成工作的。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="17d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们明白了如何用kotlin编写高阶函数，以及如何调用它们。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="b433" class="ju jv hi jq b fi jw jx l jy jz">// sample higher order function</span><span id="231f" class="ju jv hi jq b fi lp jx l jy jz">fun hof(fn: (String) -&gt; String) = println(fn("sample_string"))</span><span id="2d76" class="ju jv hi jq b fi lp jx l jy jz">// invocation</span><span id="416c" class="ju jv hi jq b fi lp jx l jy jz">hof { s -&gt; "modified $s"}</span><span id="85c9" class="ju jv hi jq b fi lp jx l jy jz">output : modified sample_string</span></pre><p id="586a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中我们可以看到，在调用高阶函数时，我们没有写括号。这是kotlin中的结尾lambda语法<strong class="ih hj">,它说<strong class="ih hj">如果我们把函数作为高阶函数的最后一个参数，那么我们可以简单地用花括号调用hof。</strong></strong></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="09ee" class="ju jv hi jq b fi jw jx l jy jz">// trailing lambda syntax</span><span id="b38c" class="ju jv hi jq b fi lp jx l jy jz">fun hof(<br/>   s: String,<br/>   fn : (String) -&gt; String<br/>) {<br/>   println(fn(s)) <br/>}</span><span id="607d" class="ju jv hi jq b fi lp jx l jy jz">// invocation where the lambda function is passed <br/>// outside the parenthesis inside curly braces</span><span id="1eaa" class="ju jv hi jq b fi lp jx l jy jz">hof("sample_string") { s -&gt; "modified $s" }</span><span id="d8a5" class="ju jv hi jq b fi lp jx l jy jz">output: modified sample_string</span></pre></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="1cb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用kotlin编写扩展函数时，我们还可以利用高阶函数，使代码看起来更有功能性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/6caa95fab569405134fcb031510137d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgF_CgXWgiNikl3tL14iiw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">higher order extension function</figcaption></figure><p id="ce0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是用kotlin编写基本高阶函数的方法。更多信息可在<a class="ae km" href="https://kotlinlang.org/docs/lambdas.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/lambdas.html</a>找到。</p></div></div>    
</body>
</html>
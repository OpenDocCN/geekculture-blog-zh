<html>
<head>
<title>How to Log HTTP Request Input and Response Body in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在NodeJS中记录HTTP请求输入和响应体</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-log-http-request-input-and-response-body-in-nodejs-1d5219155bf4?source=collection_archive---------3-----------------------#2022-03-14">https://medium.com/geekculture/how-to-log-http-request-input-and-response-body-in-nodejs-1d5219155bf4?source=collection_archive---------3-----------------------#2022-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ae8d1b74d670698b609107d0409af917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0LUm5MrK33DSv6rqZeeYg.jpeg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="3353" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">将API部署到生产环境时，出于调试、审计和优化等原因，能够记录所有传入服务器的请求和来自服务器的响应是至关重要的。对于NodeJS，有许多流行的日志库，它们在为您设置基本配置方面做得非常好。然而，它们都没有提供默认的请求输入和响应主体日志记录。这里有一个简短的教程，告诉我们如何通过<a class="ae jv" href="https://github.com/expressjs/morgan" rel="noopener ugc nofollow" target="_blank">摩根</a>来实现这一点。</p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="5ada" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了记录morgan默认配置之外的附加信息，我们需要创建自定义令牌。让我们从一个为扩展morgan而编写的定制中间件开始。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="05e4" class="kf kg hi kb b fi kh ki l kj kk">// /middlewares/morgan.ts</span><span id="da8a" class="kf kg hi kb b fi kl ki l kj kk">import { Request, Response } from "express";<br/>import morgan from "morgan";</span><span id="5fde" class="kf kg hi kb b fi kl ki l kj kk">// in my app, I extend express's Request interface to store a <br/>// `requester` prop. this holds the decoded jwt token data<br/>morgan.token("requester", function getRequester(req: Request): string {<br/>  return JSON.stringify(req.requester);<br/>});</span><span id="6fe3" class="kf kg hi kb b fi kl ki l kj kk">morgan.token("input", function getInput(req: Request): string {<br/>  let input: Record&lt;string, any&gt; = {};<br/>  if (req.method === "GET") {<br/>    input = req.query;<br/>  } else {<br/>    input = req.body;<br/>  }<br/>  <br/>  // mask any input that should be secret<br/>  input = { ...input };<br/>  if (input.password) {<br/>    input.password = "*";<br/>  }<br/> <br/>  return JSON.stringify(input);<br/>});</span><span id="39fe" class="kf kg hi kb b fi kl ki l kj kk">morgan.token("response-body", (req: Request, res: Response): string =&gt; {<br/>  const body = { ...JSON.parse(res.responseBody) };</span><span id="fff1" class="kf kg hi kb b fi kl ki l kj kk">  // mask any input that should be secret<br/>  if (body?.data?.accessToken) {<br/>    body.data.accessToken = "*";<br/>  }<br/>  if (body?.data?.refreshToken) {<br/>    body.data.refreshToken = "*";<br/>  }<br/>  <br/>  return JSON.stringify(body);<br/>});</span><span id="4e04" class="kf kg hi kb b fi kl ki l kj kk">export { morgan };</span></pre><p id="3b65" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们现在可以在<code class="du km kn ko kb b">index.ts</code>中导入它，并用我们新定义的令牌定义一个定制格式，morgan应该使用这个格式。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="cc2f" class="kf kg hi kb b fi kh ki l kj kk">// index.ts</span><span id="6c29" class="kf kg hi kb b fi kl ki l kj kk">import express, { Express, Request, Response } from "express";<br/>import { morgan } from "./middlewares/morgan";</span><span id="9efc" class="kf kg hi kb b fi kl ki l kj kk">const PORT = process.env.PORT || 3000;<br/>const app: Express = express();</span><span id="5181" class="kf kg hi kb b fi kl ki l kj kk">// override send to store response body for morgan token to retrieve<br/>const originalSend = app.response.send;<br/>app.response.send = function sendOverride(body) {<br/>  this.responseBody = body;<br/>  return originalSend.call(this, body);<br/>};</span><span id="0404" class="kf kg hi kb b fi kl ki l kj kk">app.use(express.json());<br/>app.use(cookieParser()); // I use this to retrieve jwt from cookies<br/>app.use(<br/>  morgan(<br/>    ':requester :remote-addr [:date[clf]] ":method :url HTTP/:http-version" Input :input Response :response-body'<br/>  )<br/>);</span><span id="8b78" class="kf kg hi kb b fi kl ki l kj kk">... // other middleware, route handlers, server setup</span></pre><p id="3326" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最后，我们还需要从express扩展请求和响应类型，以避免构建时错误。确保在包含或文件选项中的<code class="du km kn ko kb b">tsconfig.json</code>中包含该文件。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="8683" class="kf kg hi kb b fi kh ki l kj kk">// custom.d.ts</span><span id="40b0" class="kf kg hi kb b fi kl ki l kj kk">declare namespace Express {<br/>  export interface Request {<br/>    requester: import("./models/Policy").Requester;<br/>  }<br/>  <br/>  export interface Response {<br/>    responseBody: any;<br/>  }<br/>}</span></pre><p id="59c8" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，我们在每个请求日志中都存储了完整的请求输入和响应主体对象！</p></div></div>    
</body>
</html>
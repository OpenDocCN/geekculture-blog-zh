<html>
<head>
<title>Virtual Eyes — A simple surrounding describing app for the visually impaired</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟眼睛——为视障人士设计的简单环境描述应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/virtual-eyes-a-simple-surrounding-describing-app-for-the-visually-impaired-3ac2af7e99f0?source=collection_archive---------43-----------------------#2021-08-31">https://medium.com/geekculture/virtual-eyes-a-simple-surrounding-describing-app-for-the-visually-impaired-3ac2af7e99f0?source=collection_archive---------43-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7584a0a34dd60781be528c9a6ebcfd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mY36jccBQ4eTU3_AYyS0YA.jpeg"/></div></div></figure><p id="8ab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的几年里，图像字幕对机器学习领域产生了巨大的影响，新的应用每天都在出现。图像字幕是使用人工智能、计算机视觉和机器学习来生成图像描述的能力，类似于人类描述图像内容的方式。在这篇文章中，我将讨论我如何创建一个简单的应用程序，使用图像字幕向视障人士描述周围的环境。</p><p id="5c63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了提供这款应用的概述，当用户发出语音命令时，它使用手机的主摄像头来捕捉照片，并使用Azure计算机视觉服务，该应用生成字幕以及对象的位置数据，并以自然语言与用户交谈。</p><p id="584e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您渴望观看该应用程序的演示，请阅读本文末尾。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="31f7" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated"><strong class="ak">开发安卓应用</strong></h2><p id="e20e" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">为了开发这个应用程序，我使用了Unity和Azure计算机视觉服务。所以，让我们来看看是怎么做到的。</p><ol class=""><li id="21e4" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated">创建Azure计算机视觉资源。</li></ol><p id="4e28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我写了一整篇关于如何创建Azure计算机视觉资源并在Unity <a class="ae le" rel="noopener" href="/codex/image-captioning-in-unity-android-using-azure-computer-vision-c9424f9d1ab1">中使用其服务的文章。你可以参考它来了解更多关于设置Azure的知识，因为我不会详细讨论这个。</a></p><p id="fa90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建Unity Android应用程序</p><p id="a7d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我首先创建了一个统一2D项目，我必须改变一些配置，以适应这个项目，如下所示:</p><p id="7491" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。换平台安卓</strong></p><p id="d8c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(文件-&gt;构建设置-&gt; Android -&gt;切换平台)</p><p id="5ba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。导入Newtonsoft DLL文件并在Assets中设置csc.rsp文件。</strong></p><p id="4366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。更改API兼容级别</strong></p><p id="939a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">'编辑-&gt;项目设置-&gt;播放器-&gt;其他设置-&gt; API兼容级别从'。NET Standard 2.0 '到'。NET 4.x '</p><p id="1a47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我关于使用Azure计算机视觉的Unity Android中的<a class="ae le" rel="noopener" href="/codex/image-captioning-in-unity-android-using-azure-computer-vision-c9424f9d1ab1">图像字幕的文章</a>中，已经解释了上述所有任务(并给出了原因)。</p><p id="974c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。设置文本到语音和语音到文本</strong></p><p id="3d7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了执行这个任务，我在他的<a class="ae le" href="https://github.com/j1mmyto9/Speech-And-Text-Unity-iOS-Android" rel="noopener ugc nofollow" target="_blank"> Github库</a>上使用了<a class="ae le" href="https://github.com/j1mmyto9" rel="noopener ugc nofollow" target="_blank"> j1mmyto9 </a>提供的插件。这个<a class="ae le" href="https://www.youtube.com/watch?v=XRXbVtr1fog" rel="noopener ugc nofollow" target="_blank">教程</a>解释了如何在你的unity项目中使用上述插件。</p><p id="6146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我是这样做的:</p><ol class=""><li id="580d" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated">下载Github库并解压文件。</li><li id="c094" class="kv kw hi is b it lf ix lg jb lh jf li jj lj jn la lb lc ld bi translated">打开“SpeechToText_AppleAPI/Assets/”文件夹，将“Plugins”和“SpeechAndText”文件夹复制到Unity项目的Assets文件夹中。</li><li id="5c4c" class="kv kw hi is b it lf ix lg jb lh jf li jj lj jn la lb lc ld bi translated">创建两个名为“SpeechToText”和“TextToSpeech”的空游戏对象，并将名为“SpeechToText.cs”和“TextToSpeech.cs”的C#脚本分别作为组件添加到上述游戏对象中。</li></ol><p id="1f25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lk">注</em> </strong> <em class="lk">:上面提到的这些名字，要完全按照规定。</em></p><p id="6ba1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，在检查器中取消选中SpeechToText脚本的“IsShowPopupAndroid”选项。</p><p id="4b33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它看起来是这样的:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/4a233b1e521535ae404d2e463555919d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AagcW78S6tZIAlbJcpaqQw.png"/></div></div></figure><p id="7151" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.创建一个空的游戏对象，并将其命名为“SpeechHandler”(这个名称可以不同)。</p><p id="92cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.创建一个名为“SpeechHandler.cs”的C#脚本，并将其作为组件添加到上面创建的“SpeechHandler”游戏对象中。这个脚本将包含处理语音相关功能的代码。</p><p id="8b8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.创建一个C#脚本来管理函数</p><p id="a78f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个名为“caption.cs”的C#脚本来管理所有其他函数，包括API调用。接下来，创建一个名为“captionHandler”的空游戏对象，并将“caption.cs”脚本添加到上面的游戏对象中。</p><p id="dee4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。在Unity中创建UI组件</strong></p><p id="e6bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个面板，在面板下创建一个RawImage(设置z旋转为-90)和一个Text gameobject作为面板的子面板，分别命名为“CameraFeed”和“SpeechStatus”。对了，我从游戏窗口把长宽比改成了2160x1080人像。您可能还想调整UI元素的大小。</p><p id="3dc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我的设置:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/21a62ff32d8a2c6904005c5112ad7654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WSeY2KJu7Vrh-Lx-b-qHA.png"/></div></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="33a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，设置过程已经完成。接下来是编码任务。</p><p id="f39e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我将讨论“caption.cs”脚本。</p><p id="0802" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> caption.cs </strong></p><p id="9b06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该脚本包含以下成员变量:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="52b9" class="jv jw hi ls b fi lw lx l ly lz">// Add your Computer Vision subscription key and endpoint<br/>static string subscriptionKey = "PASTE_YOUR_COMPUTER_VISION_SUBSCRIPTION_KEY_HERE";</span><span id="b99f" class="jv jw hi ls b fi ma lx l ly lz">//azure endpoint<br/>static string endpoint = "PASTE_YOUR_COMPUTER_VISION_ENDPOINT_HERE";</span><span id="cdb5" class="jv jw hi ls b fi ma lx l ly lz">//azure endpoint service accessed<br/>static string captionBase = "vision/v3.2/describe?"; //endpoint to generate image captions</span><span id="e9a0" class="jv jw hi ls b fi ma lx l ly lz">static string objectBase = "vision/v3.2/analyze?"; //endpoint to get object locations</span><span id="fb91" class="jv jw hi ls b fi ma lx l ly lz">//UI Components<br/>[SerializeField] private RawImage cameraFeed;</span><span id="f27a" class="jv jw hi ls b fi ma lx l ly lz">//webcamtexture<br/>private WebCamTexture webcamTexture;</span></pre><p id="e313" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述变量用于Azure订阅密钥、Azure API端点、将附加到端点的captionBase和objectBase、RawImage UI组件和webcamtexture。</p><p id="e6dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">标题库和对象库是我向azure请求的功能。“描述”特征包括图像标题，而“分析”特征包括检测到的物体相对于图像的位置。</p><p id="9d77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个项目中，我选择了单一设计模式，因此我创建了一个类本身的实例，如下所示。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="5f31" class="jv jw hi ls b fi lw lx l ly lz">//instance of caption class<br/>private static caption instance;</span><span id="541e" class="jv jw hi ls b fi ma lx l ly lz">public static caption Instance<br/>{<br/> get<br/> {<br/>  if (instance == null)<br/>   {<br/>    instance = FindObjectOfType&lt;caption&gt;();<br/>   }<br/>  return instance;<br/> }<br/>}</span></pre><p id="1a7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，需要在应用程序启动时检查用户权限。这可以通过下面的方法来完成。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="4a99" class="jv jw hi ls b fi lw lx l ly lz">void CheckPermissin()<br/>{<br/> if (!Permission.HasUserAuthorizedPermission(Permission.Camera))<br/> {<br/>  Permission.RequestUserPermission(Permission.Camera);<br/> }<br/> if (!Permission.HasUserAuthorizedPermission(Permission.Microphone))<br/> {<br/>  Permission.RequestUserPermission(Permission.Microphone);<br/> }<br/> if(Permission.HasUserAuthorizedPermission(Permission.Camera) &amp;&amp; Permission.HasUserAuthorizedPermission(Permission.Microphone))<br/> {<br/>  //start camera feed if both permissions granted<br/>  startCamera();<br/>  }<br/>}</span></pre><p id="b8d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此方法检查用户是否授予了麦克风和摄像机权限，如果没有，则要求用户授予权限。如果两种权限都被授予，该方法将调用“startCamera”方法，该方法启动摄像机并将摄像机源分配给“camera feed”raw image。显然，这对视力受损的人来说没有用，但是为了我们的方便，我已经实现了这一点。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="a728" class="jv jw hi ls b fi lw lx l ly lz">void startCamera()<br/>{<br/> //get all camera devices <br/> WebCamDevice[] cam_devices = WebCamTexture.devices;</span><span id="41d6" class="jv jw hi ls b fi ma lx l ly lz"> //Set a camera to the webcamTexture<br/> webcamTexture = new WebCamTexture(cam_devices[0].name, 480, 640, 30);</span><span id="8a41" class="jv jw hi ls b fi ma lx l ly lz"> //Set the webcamTexture to the texture of the rawimage<br/> cameraFeed.texture = webcamTexture;<br/> cameraFeed.material.mainTexture = webcamTexture;</span><span id="a3ff" class="jv jw hi ls b fi ma lx l ly lz"> //Start the camera<br/> webcamTexture.Play();<br/>}</span></pre><p id="391a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来出现的问题是我应该在哪里调用“CheckPermission”方法。由于权限检查是异步完成的，应用程序无需等待用户权限就开始运行，从而导致“相机馈送”原始图像上出现白屏，而不是渲染相机馈送。因此，在“start”方法中调用此方法会导致此类错误。因此，我在“OnApplicationFocus”回调中输入了对“CheckPermission”方法的调用，该回调在应用程序每次返回焦点时运行，因此它将重复检查所有权限，直到所有权限都被授予。下面给出了实现这一点的代码。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="40d3" class="jv jw hi ls b fi lw lx l ly lz">private void OnApplicationFocus(bool focus)<br/>{<br/> //check for permission<br/> CheckPermissin();<br/>}</span></pre><p id="6d08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我创建了一个名为‘save image’的IEnumerator方法，从摄像机输入中捕获图像，并将图像字节数据传递给另一个处理API调用的方法。此方法是IEnumerator，因为它使用“yield return”来等待当前帧的结束。此外，您会注意到对“RotateTexture”方法的调用，该方法用于将Texture2D旋转给定的角度。这个方法可以从<a class="ae le" href="https://www.programmersought.com/article/69288818191/" rel="noopener ugc nofollow" target="_blank">这里</a>得到。</p><p id="b8ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SaveImage()方法还接受一个布尔参数“isDescribe ”,如果用户需要图像标题，该参数为true如果用户需要位置数据，该参数为false。</p><p id="447b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面给出的是这种方法:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="ef0d" class="jv jw hi ls b fi lw lx l ly lz">public IEnumerator SaveImage(bool isDescribe)<br/>{<br/> //Create a Texture2D with the size of the rendered image on the screen.<br/> Texture2D texture = new Texture2D(webcamTexture.width, webcamTexture.height, TextureFormat.ARGB32, false);</span><span id="08fd" class="jv jw hi ls b fi ma lx l ly lz"> //wait till end of frame<br/> yield return new WaitForEndOfFrame();</span><span id="ed22" class="jv jw hi ls b fi ma lx l ly lz"> //save webcam frame to texture<br/> texture.SetPixels(webcamTexture.GetPixels());</span><span id="d1f1" class="jv jw hi ls b fi ma lx l ly lz"> //rotate texture<br/> texture = RotateTexture(texture, -90);<br/> texture.Apply();</span><span id="2ea3" class="jv jw hi ls b fi ma lx l ly lz"> //check user requirement whether caption or object position <br/> if (isDescribe)<br/> {<br/>  getCaption(texture.EncodeToPNG());<br/> }<br/> else<br/> {<br/>  getObjects(texture.EncodeToPNG());<br/> }<br/>}</span></pre><p id="fa86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我将讨论从“SaveImage”方法调用的“getCaption”和“getObjects”方法。</p><p id="3a90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“getCaption”方法包含创建最终uriBase的代码以及必要的请求参数。然后，该方法将这些数据与图像字节数组一起传递给“MakeRequest”方法，该方法调用API并返回数据。接下来，需要处理返回的数据以提取标题，这是通过调用“convertCaption”方法完成的，然后传递给SpeechHandler(很快就会实现)以朗读标题。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="280c" class="jv jw hi ls b fi lw lx l ly lz">public async void getCaption(byte[] imageBytes)<br/>{<br/> //uri<br/> string uriBase = endpoint + captionBase;</span><span id="d9e8" class="jv jw hi ls b fi ma lx l ly lz"> // Request parameters<br/> var requestParameters = HttpUtility.ParseQueryString(string.Empty);<br/> requestParameters["maxCandidates"] = "1";<br/> requestParameters["language"] = "en";<br/> requestParameters["model-version"] = "latest";</span><span id="1b51" class="jv jw hi ls b fi ma lx l ly lz"> // call makeRequest method to make API call<br/> String result = await MakeRequest(uriBase, requestParameters, imageBytes);</span><span id="17fc" class="jv jw hi ls b fi ma lx l ly lz"> //extract caption<br/> string convResult = convertCaption(result);</span><span id="cc80" class="jv jw hi ls b fi ma lx l ly lz"> //speak caption<br/> SpeechHandler.Instance.StartSpeaking(convResult);<br/>}</span></pre><p id="6ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与上面的“getCaptions”方法类似的是“getObjects”方法，它有自己的uriBase和request参数，以及对“MakeRequest”方法和“convertObjects”方法的调用，后者提取位置数据并创建一个句子并将其返回，最后调用SpeechHandler说出带有位置数据的句子。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="2aa8" class="jv jw hi ls b fi lw lx l ly lz">public async void getObjects(byte[] imageBytes)<br/>{<br/> // uri<br/> string uriBase = endpoint + objectBase;</span><span id="2910" class="jv jw hi ls b fi ma lx l ly lz"> // Request parameters<br/> var requestParameters = HttpUtility.ParseQueryString(string.Empty);<br/> requestParameters["visualFeatures"] = "Objects";<br/> requestParameters["language"] = "en";<br/> requestParameters["model-version"] = "latest";</span><span id="3564" class="jv jw hi ls b fi ma lx l ly lz"> // call makeRequest method to make API call<br/> String result = await MakeRequest(uriBase, requestParameters, imageBytes);</span><span id="7794" class="jv jw hi ls b fi ma lx l ly lz"> //extract position sentence<br/> string convResult = convertObjects(result);</span><span id="6291" class="jv jw hi ls b fi ma lx l ly lz"> //speak<br/> SpeechHandler.Instance.StartSpeaking(convResult);<br/>}</span></pre><p id="9a9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来是“MakeRequest”方法，它包括对Azure API的调用，并返回生成的响应。要了解更多关于这种方法的信息，请访问<a class="ae le" rel="noopener" href="/codex/image-captioning-in-unity-android-using-azure-computer-vision-c9424f9d1ab1">这里</a>。下面是“MakeRequest”方法:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="9d14" class="jv jw hi ls b fi lw lx l ly lz">async Task&lt;String&gt; MakeRequest(string uriBase, NameValueCollection requestParameters, byte[] byteData)<br/>{<br/> //initialize variable for result<br/> String responseText = "";<br/> try<br/> {<br/>  HttpClient client = new HttpClient();</span><span id="b236" class="jv jw hi ls b fi ma lx l ly lz">  // Request headers<br/>  client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);</span><span id="86f3" class="jv jw hi ls b fi ma lx l ly lz">  // Assemble the URI for the REST API method.<br/>  string uri = uriBase + requestParameters;</span><span id="2d10" class="jv jw hi ls b fi ma lx l ly lz">  HttpResponseMessage response;</span><span id="3730" class="jv jw hi ls b fi ma lx l ly lz">  // Request body<br/>  using (var content = new ByteArrayContent(byteData))<br/>  {<br/>   content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");</span><span id="a07b" class="jv jw hi ls b fi ma lx l ly lz">   // Asynchronously call the REST API method.<br/>   response = await client.PostAsync(uri, content);</span><span id="fda8" class="jv jw hi ls b fi ma lx l ly lz">   // Asynchronously get the JSON response.<br/>   responseText = await response.Content.ReadAsStringAsync();<br/>  }<br/> }<br/> catch<br/> {<br/>  responseText = "";<br/> }<br/> return responseText;<br/>}</span></pre><p id="43ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们讨论一下我们之前调用的“convertCaption”和“convertObjects”方法。</p><p id="cc5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“convertCaption”方法基本上从API接收响应字符串，将其转换为JSON对象，并提取其中包含标题的另一个JSON对象。这个标题对象包含一个标题数组，因此首先需要将它解析成一个JArray，然后提取第一个标题。这是如何做到的:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="8451" class="jv jw hi ls b fi lw lx l ly lz">public string convertCaption(string responseText)<br/>{<br/> //initialize variable for caption<br/> string textCaption = "";<br/> <br/> try<br/> {<br/>  //convert result to a dictionary<br/>  var jsonResult = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, dynamic&gt;&gt;(responseText);</span><span id="93e8" class="jv jw hi ls b fi ma lx l ly lz">  //obtain captions object from jsonResult<br/>  var captionsObj = jsonResult["description"]["captions"];</span><span id="9948" class="jv jw hi ls b fi ma lx l ly lz">  //convert captionsObj to JArray<br/>  JArray captionArray = JArray.Parse(captionsObj.ToString());</span><span id="7b5e" class="jv jw hi ls b fi ma lx l ly lz">  //get caption string from array<br/>  textCaption = captionArray[0]["text"].ToString();<br/> }<br/> catch<br/> {<br/>  textCaption = "Couldn't get description, Please try again !";<br/> }<br/> return textCaption;<br/>}</span></pre><p id="d60c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“convertObjects”方法还从API获取响应字符串，通过反序列化将其转换为对象，并提取其中的“objects”JSON对象。然后将该对象转换为JArray，以访问图像中每个检测到的对象的位置和大小。该方法还包括对“位置”方法的调用，该方法计算对象是在图像的左边、右边还是中间部分。使用此信息，创建了名为左、右和前的3个列表，并将相关对象附加到列表中。</p><p id="58f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，为应用程序创建一个句子，说出对象的位置。</p><p id="5507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是如何做到的:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="0abb" class="jv jw hi ls b fi lw lx l ly lz">public string convertObjects(string responseText)<br/>{<br/> //initialize string to store final sentence<br/> string objectsText = "";</span><span id="39fa" class="jv jw hi ls b fi ma lx l ly lz"> try<br/> {<br/>  //convert result to dictionary<br/>  var jsonResult = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, dynamic&gt;&gt;(responseText);</span><span id="47d7" class="jv jw hi ls b fi ma lx l ly lz">  //obtain objects<br/>  var objects = jsonResult["objects"];</span><span id="ee09" class="jv jw hi ls b fi ma lx l ly lz">  //obtain width of image<br/>  var width = jsonResult["metadata"]["width"];</span><span id="8984" class="jv jw hi ls b fi ma lx l ly lz"> //convert width to double<br/>  double imageWidth = double.Parse(width.ToString());</span><span id="00ea" class="jv jw hi ls b fi ma lx l ly lz">  //convert objects to JArray<br/>  JArray objsArray = JArray.Parse(objects.ToString());</span><span id="e371" class="jv jw hi ls b fi ma lx l ly lz">  //initialize 3 lists to store objects in left, front, right<br/>  List&lt;string&gt; left = new List&lt;string&gt;();<br/>  List&lt;string&gt; front = new List&lt;string&gt;();<br/>  List&lt;string&gt; right = new List&lt;string&gt;();</span><span id="e350" class="jv jw hi ls b fi ma lx l ly lz">  //for each object in array<br/>  foreach (var item in objsArray)<br/>  {<br/>   //get x value<br/>   double x = double.Parse(item["rectangle"]["x"].ToString());</span><span id="ba28" class="jv jw hi ls b fi ma lx l ly lz">   //get width of object detected<br/>   double w = double.Parse(item["rectangle"]["w"].ToString());</span><span id="7826" class="jv jw hi ls b fi ma lx l ly lz">   //check where the object is located<br/>   if (position(imageWidth, x, w) == "left")<br/>   {<br/>    left.Add(item["object"].ToString());<br/>   }<br/>   if (position(imageWidth, x, w) == "front")<br/>   {<br/>    front.Add(item["object"].ToString());<br/>   }<br/>   if (position(imageWidth, x, w) == "right")<br/>   {<br/>    right.Add(item["object"].ToString());<br/>   }<br/>  }<br/>  //if lists are not empty, create sentence<br/>  if (!(left.Count == 0))<br/>  {<br/>   objectsText = string.Join(",", left) + " to your left, ";<br/>  }<br/>  if (!(front.Count == 0))<br/>  {<br/>   objectsText = objectsText + string.Join(",", front) + " in your front,  ";<br/>  }<br/>  if (!(right.Count == 0))<br/>  {<br/>   objectsText = objectsText + "and " + string.Join(",", right) + " to your right";<br/>  }<br/> }<br/> catch<br/> {<br/>  objectsText = "Couldn't get position data, Please try again !";<br/> }<br/> return objectsText;<br/>}</span></pre><p id="2ad0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们有“位置”方法。如前所述，该方法用于计算特定对象相对于图像位于哪个部分。该方法接受三个参数，即整个图像的宽度、对象的x轴起始位置和对象的宽度。</p><p id="87a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图像分为左、前、右三个部分。将对象的宽度除以一半，并与x值相加，以获得对象中点的x值。使用该中点，可以确定对象位于图像的哪个部分。这是使用下面的代码完成的:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="50dd" class="jv jw hi ls b fi lw lx l ly lz">public string position(double width, double x, double w)<br/>{<br/> //divide image to 3 sections vertically and obtain length of one section<br/> double oneSection = width / 3;</span><span id="46bd" class="jv jw hi ls b fi ma lx l ly lz">//left section will end from oneSection length<br/> double left = oneSection;</span><span id="e1b0" class="jv jw hi ls b fi ma lx l ly lz">//front section end from 2 * oneSection length<br/> double front = oneSection * 2;</span><span id="9455" class="jv jw hi ls b fi ma lx l ly lz">//check if object's middle (x+w/2) is in which section<br/> if ((x + w / 2.0) &lt; left)<br/> {<br/>  return "left";<br/> }<br/> else if ((x + w / 2.0) &lt;= front)<br/> {<br/>  return "front";<br/> }<br/> else<br/> {<br/>  return "right";<br/> }<br/>}</span></pre><p id="494a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> SpeechHandler.cs </strong></p><p id="bb42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我将讨论处理文本到语音和语音到文本功能的SpeechHandler.cs脚本。</p><p id="d3a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此类包含用于UI文本组件、语言代码和布尔变量“isListening”的变量。UI文本组件用于显示应用程序是否在听语音。这只是为了我们的方便，因为它对视力有障碍的人没有用。“isListening”变量用于跟踪应用程序何时没有监听语音，如果没有，update方法将检查这一点并启动监听过程。以下是上述变量:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="7574" class="jv jw hi ls b fi lw lx l ly lz">//UI text<br/>[SerializeField] private Text speechStatus;</span><span id="6dee" class="jv jw hi ls b fi ma lx l ly lz">//language code constant<br/>const string LANG_CODE = "en-US";</span><span id="a408" class="jv jw hi ls b fi ma lx l ly lz">//variable to know if app is listening to voice<br/>bool isListening = true;</span></pre><p id="52c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，该项目遵循单例设计模式，因此，我创建了该类的一个实例，如下所示:</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="8ed3" class="jv jw hi ls b fi lw lx l ly lz">private static SpeechHandler instance;</span><span id="57bd" class="jv jw hi ls b fi ma lx l ly lz">public static SpeechHandler Instance<br/>{<br/> get<br/> {<br/>  if (instance == null)<br/>  {<br/>   instance = FindObjectOfType&lt;SpeechHandler&gt;();<br/>  }<br/>  return instance;<br/> }<br/>}</span></pre><p id="8a89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置TextToSpeech和SpeechToText设置的“Setup”方法设置扬声器和接收器的语言、音调和速率。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="7442" class="jv jw hi ls b fi lw lx l ly lz">void Setup(string code)<br/>{<br/> TextToSpeech.instance.Setting(code, 1, 0.8f);<br/> SpeechToText.instance.Setting(code);<br/>}</span></pre><p id="48ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，定义一个名为“StartSpeaking”的方法来启动应用程序朗读消息。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="3672" class="jv jw hi ls b fi lw lx l ly lz">public void StartSpeaking(string message)<br/>{<br/> TextToSpeech.instance.StartSpeak(message);<br/>}</span></pre><p id="cfa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，定义一个回调函数来处理讲话停止时的操作。这里，我将“isListening”设置为false，这样update方法将从下一帧调用“StartListening”。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="c644" class="jv jw hi ls b fi lw lx l ly lz">public void OnSpeakStop()<br/>{<br/> //set isListening to False<br/> isListening = false;<br/>}</span></pre><p id="4624" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面给出的是“开始监听”功能。这里，UI文本组件也被更新。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="5f17" class="jv jw hi ls b fi lw lx l ly lz">public void StartListening()<br/>{<br/> SpeechToText.instance.StartRecording();<br/> speechStatus.text = "Listening...";<br/>}</span></pre><p id="8be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，StopListening方法停止监听语音并更新UI文本组件。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="50d6" class="jv jw hi ls b fi lw lx l ly lz">public void StopListening()<br/>{<br/> SpeechToText.instance.StopRecording();<br/> speechStatus.text = "Stopped Listening";<br/>}</span></pre><p id="e761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来是“OnFinalSpeechResult”方法，它根据识别的关键字处理对标题类实例的调用。如果在用户语音输入中识别出“位置”,则调用参数设置为false的“保存图像”协程(意味着用户不需要描述，但需要位置数据)。如果在用户输入中检测到“标题”关键字，则会发生相反的情况。如果没有检测到，则将“isListening”变量设置为false。下面给出的是“OnFinalSpeechResult”方法。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="b550" class="jv jw hi ls b fi lw lx l ly lz">void OnFinalSpeechResult(string result)<br/>{<br/> speechStatus.text = result;</span><span id="a452" class="jv jw hi ls b fi ma lx l ly lz">try<br/> {<br/>  //check if 'position' or 'desribe' words in spoken sentence by user<br/>  if (result.ToLower().Contains("placement"))<br/>  {<br/>   //set is Listening to true because otherwise, app will listen to caption spoken by itself from update method<br/>   isListening = true;</span><span id="434d" class="jv jw hi ls b fi ma lx l ly lz">   //stoplistening<br/>   StopListening();</span><span id="8851" class="jv jw hi ls b fi ma lx l ly lz">//call SaveImage<br/>   StartCoroutine(caption.Instance.SaveImage(false));<br/>  }<br/>  else if (result.ToLower().Contains("caption"))<br/>  {<br/>   //set is Listening to true because otherwise, app will listen to position sentence spoken by itself from update method<br/>   isListening = true;</span><span id="50e8" class="jv jw hi ls b fi ma lx l ly lz">   //stoplistening<br/>   StopListening();</span><span id="047e" class="jv jw hi ls b fi ma lx l ly lz">   //call SaveImage<br/>   StartCoroutine(caption.Instance.SaveImage(true));<br/>  }<br/>  else<br/>  {<br/>   //set isListening to false<br/>   isListening = false;<br/>  }<br/> }<br/> catch<br/> {<br/> }<br/>}</span></pre><p id="1ebe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，“OnFinalSpeechResult”和“OnSpeakStop”回调都应该注册到各自的类中。这是在start方法中完成的，该方法还调用“Setup”方法和“StartListening”方法。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="a8da" class="jv jw hi ls b fi lw lx l ly lz">void Start()<br/>{<br/> //call setup method<br/> Setup(LANG_CODE);</span><span id="7980" class="jv jw hi ls b fi ma lx l ly lz"> //register onResultCallback<br/> SpeechToText.instance.onResultCallback = OnFinalSpeechResult;</span><span id="05ac" class="jv jw hi ls b fi ma lx l ly lz"> //register onDoneCallback<br/> TextToSpeech.instance.onDoneCallback = OnSpeakStop;</span><span id="ef19" class="jv jw hi ls b fi ma lx l ly lz"> //start listening to voice<br/> StartListening();<br/>}</span></pre><p id="8218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，“更新”方法检查变量“isListening”是否为假，如果是，则调用“StartListening”方法。</p><pre class="lm ln lo lp fd lr ls lt lu aw lv bi"><span id="05c5" class="jv jw hi ls b fi lw lx l ly lz">void Update()<br/>{<br/> //if not listening, start listening<br/> if (!isListening)<br/> {<br/>  StartListening();<br/> }<br/>}</span></pre><p id="7741" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就完成了这个项目的编码任务。</p><p id="c5c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在构建应用程序之前，需要将“camera feed”raw image和“SpeechStatus”文本UI组件分别分配给captionHandler游戏对象的标题脚本组件和SpeechHandler游戏对象的SpeechHandler脚本。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/fc90fdc8f54f4ee68688292978bf342a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*ejv3dUkBnF-haNYMW1icow.png"/></div></figure><p id="734b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就完成了这个项目的开发。</p><p id="1d49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是应用程序的演示。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="10ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个项目到此为止。请让我知道你的反馈和建议。谢谢大家！干杯！😀</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to create 37.5 million data in PostgreSQL in a matter of seconds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在几秒钟内用PostgreSQL创建3750万个数据</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-37-5-million-data-in-postgresql-in-a-matter-of-seconds-858693976d17?source=collection_archive---------1-----------------------#2021-10-17">https://medium.com/geekculture/how-to-create-37-5-million-data-in-postgresql-in-a-matter-of-seconds-858693976d17?source=collection_archive---------1-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b9d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列包括两篇文章:</p><ol class=""><li id="3cba" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/geekculture/how-to-create-37-5-million-data-in-postgresql-in-a-matter-of-seconds-858693976d17?sk=888ccfc6d0747b5df266955497ce7e7a">如何在几秒钟内用PostgreSQL创建3750万条数据</a></li><li id="994f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" href="https://josipvojak.com/4-ways-to-optimise-postgresql-database-with-millions-of-data-c70e11d27a94?sk=d2c6b400b64e89304a0a2da28eb83531" rel="noopener ugc nofollow" target="_blank">优化拥有数百万数据的PostgreSQL数据库的4种方法</a></li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/5fd23028227f2a5db7e1ac3d542e7ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HRU03UvgOt_5ih3ssEDXw.jpeg"/></div></div></figure><p id="b3e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您需要访问以特定方式形成和建模的大量数据时，有几个明显的原因:</p><ul class=""><li id="0f7d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated">测试一项功能</li><li id="c1d3" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">运行基准测试</li><li id="a0e6" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">出于学习目的(例如，学习用于创建图表的库)</li><li id="b7ea" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">用于测试和学习数据库优化技术</li></ul><h1 id="9f26" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">数据，数据，更多的数据。</h1><p id="5ff2" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">幸运的是，PostgreSQL提供了一个现成的解决方案来创建大量的样本数据。这个令人惊叹的特性是以PostgreSQL函数的形式出现的。</p><p id="3293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有真实的数据总是最好的，但从真实的用户和设备获取数据可能会很笨拙，可能需要几周、几个月或几年才能获得这么多信息。</p><p id="3a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但有时，这是不可能的，你现在就需要这些数据。事实上，有一个属于PostgreSQL的内在函数，我将向您展示如何使用它，从非常基础的角度到更高级的技术，以获得更随机但同时更真实的数据。</p><h2 id="d4a3" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">PostgreSQL函数— generate_series()</h2><p id="d5ec" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">那么，这是怎么回事？有一个generate_series()函数可以创建大型数据集。<br/>首先，让我们来看看函数语句，它有三种方式:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lw"><img src="../Images/d60f792632fdb12337ecfbd5a8f1c2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yikm-D1fK9_I4IfqG-Zi9A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">PostgreSQL Set Returning Functions</figcaption></figure><p id="860a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究函数能力之前，让我们创建一个示例数据库。我把它叫做<em class="mb"> dummy_data。</em></p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="c028" class="li kg hi md b fi mh mi l mj mk">CREATE DATABASE dummy_data;<br/>\c dummy_data</span><span id="fd40" class="li kg hi md b fi ml mi l mj mk">You are now connected to database "dummy_data" as user "postgres".</span></pre><p id="4dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> generate_series </strong>()让我们可以轻松地创建数字或日期的有序表格，PostgreSQL称之为<a class="ae jm" href="https://www.postgresql.org/docs/13/functions-srf.html" rel="noopener ugc nofollow" target="_blank">集合返回函数</a>，因为它可以返回多行。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="644c" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">1.生成系列(开始，停止)</h2><p id="0a16" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">让我们从学习使用第一个定义开始。</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="0efd" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM generate_series(1,5);</span><span id="9877" class="li kg hi md b fi ml mi l mj mk">generate_series<br/>-----------------<br/>1<br/>2<br/>3<br/>4<br/>5</span><span id="b727" class="li kg hi md b fi ml mi l mj mk">(5 rows)</span></pre><p id="1e3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成一系列整数，从1开始，以5结束。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="2e17" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">2.生成系列(开始、停止、步进)</h2><p id="cb64" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">第二种方法是，生成一个包含一个步骤的序列。这将生成一个序列，从0开始，到10结束，步长为2。</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="718d" class="li kg hi md b fi mh mi l mj mk">SELECT * from generate_series(0,10,2);</span><span id="7219" class="li kg hi md b fi ml mi l mj mk">generate_series<br/>— — — — — — — -<br/>0<br/>2<br/>4<br/>6<br/>8<br/>10</span><span id="b4a4" class="li kg hi md b fi ml mi l mj mk">(6 rows)</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h2 id="459e" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">3.generate_series(开始、停止、步长间隔)</h2><p id="a811" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">我们还可以将generate_series()与日期一起使用，如下所示，如果我们提供一个步长间隔作为第三个参数:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="fc06" class="li kg hi md b fi mh mi l mj mk">SELECT * from generate_series(<br/>   ‘2021–10–14’,<br/>   ‘2021–10–15’, <br/>   INTERVAL ‘1 hour’<br/>);</span><span id="1107" class="li kg hi md b fi ml mi l mj mk">generate_series<br/>— — — — — — — — — — — <br/>2021–10–14 00:00:00+02<br/>2021–10–14 01:00:00+02<br/>2021–10–14 02:00:00+02<br/>2021–10–14 03:00:00+02<br/>2021–10–14 04:00:00+02<br/>2021–10–14 05:00:00+02<br/>2021–10–14 06:00:00+02<br/>2021–10–14 07:00:00+02<br/>2021–10–14 08:00:00+02<br/>2021–10–14 09:00:00+02<br/>2021–10–14 10:00:00+02<br/>2021–10–14 11:00:00+02<br/>2021–10–14 12:00:00+02<br/>2021–10–14 13:00:00+02<br/>2021–10–14 14:00:00+02<br/>2021–10–14 15:00:00+02<br/>2021–10–14 16:00:00+02<br/>2021–10–14 17:00:00+02<br/>2021–10–14 18:00:00+02<br/>2021–10–14 19:00:00+02<br/>2021–10–14 20:00:00+02<br/>2021–10–14 21:00:00+02<br/>2021–10–14 22:00:00+02<br/>2021–10–14 23:00:00+02<br/>2021–10–15 00:00:00+02</span><span id="3931" class="li kg hi md b fi ml mi l mj mk">(25 rows)</span></pre><p id="e12e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">返回的日期包括开始和停止值，就像数字示例一样。</p><p id="0932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出返回25行，而不是预期的24行，因为可以使用一小时间隔(步骤参数)达到<strong class="ih hj">停止值。然而，<strong class="ih hj">如果间隔被跳过，它将不会被包括</strong>，我们可以通过修改上面的查询来检查:</strong></p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="1867" class="li kg hi md b fi mh mi l mj mk">SELECT * from generate_series(<br/>   '2021-10-14',<br/>   '2021-10-15',<br/>   INTERVAL '1 hour 25 minutes'<br/>);</span><span id="4339" class="li kg hi md b fi ml mi l mj mk">generate_series<br/>------------------------<br/>2021-10-14 00:00:00+02<br/>2021-10-14 01:25:00+02<br/>2021-10-14 02:50:00+02<br/>2021-10-14 04:15:00+02<br/>2021-10-14 05:40:00+02<br/>2021-10-14 07:05:00+02<br/>2021-10-14 08:30:00+02<br/>2021-10-14 09:55:00+02<br/>2021-10-14 11:20:00+02<br/>2021-10-14 12:45:00+02<br/>2021-10-14 14:10:00+02<br/>2021-10-14 15:35:00+02<br/>2021-10-14 17:00:00+02<br/>2021-10-14 18:25:00+02<br/>2021-10-14 19:50:00+02<br/>2021-10-14 21:15:00+02<br/>2021-10-14 22:40:00+02</span><span id="24ce" class="li kg hi md b fi ml mi l mj mk">(17 rows)</span></pre><p id="143f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这返回了<strong class="ih hj"> 17行，而不是18行</strong>，因为如果我们加上1小时25分钟，就会得到日期2021–10–15 00:05:00+02，这是越界的。</p><h1 id="3726" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">加密挖掘器—数据生成器示例</h1><p id="9f5a" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">既然我们已经了解了基础知识，我们可以从一个更具体的例子开始。</p><p id="48c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想要为加密硬币矿工人工创建指标——我们可能想要跟踪CPU使用率、平均兆哈希/秒、矿工温度、粉丝百分比。</p><h2 id="41ae" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">摆桌子</h2><p id="db52" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">我们可以从创建一个名为miners的样本表开始，假设我拥有三个miners。我们可以给它们命名:</p><ol class=""><li id="9e19" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">钻石</li><li id="5937" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">铂</li><li id="05de" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">金色的</li></ol><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="5468" class="li kg hi md b fi mh mi l mj mk">CREATE TABLE IF NOT EXISTS miners (<br/>id smallint,<br/>name varchar(20),<br/>graphic_cards smallint <br/>);</span><span id="6248" class="li kg hi md b fi ml mi l mj mk">INSERT INTO <br/>   miners (id, name, graphic_cards) <br/>   VALUES <br/>      (1, 'Diamond', 10), <br/>      (2, 'Platinum', 7), <br/>      (3, 'Gold', 4);</span><span id="cd9f" class="li kg hi md b fi ml mi l mj mk">SELECT * FROM miners;<br/> id |   name   | graphic_cards <br/>----+----------+---------------<br/>  1 | Diamond  |            10<br/>  2 | Platinum |             7<br/>  3 | Gold     |             4</span></pre><p id="39b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们为这三个矿工创建一天的数据—每个矿工每小时一个条目。</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="7b12" class="li kg hi md b fi mh mi l mj mk">SELECT <br/>   miners.name, <br/>   s1.time as time, <br/>   random() * (100–0) + 0 AS cpu_usage, <br/>   random() * (30–26) + 26 * graphic_cards AS average_mhs, <br/>   random() * (90–50) + 50 AS temperature, <br/>   random() * (100–0) + 0 AS fan <br/>FROM generate_series(<br/>   ‘2021–10–14’, <br/>   ‘2021–10–15’, <br/>   INTERVAL ‘1 hour’) AS s1(time) <br/>CROSS JOIN(<br/>   SELECT <br/>      id,<br/>      name, <br/>      graphic_cards <br/>   FROM miners<br/>) miners <br/>ORDER BY <br/>  miners.id, <br/>  s1.time;</span></pre><p id="51ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询解释，如果你不明白:</p><ul class=""><li id="bcb8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated">我们有<strong class="ih hj">名称</strong>、<strong class="ih hj">时间</strong>、<strong class="ih hj"> cpu_usage </strong>、<strong class="ih hj"> average_mhs </strong>、<strong class="ih hj">温度</strong>和<strong class="ih hj">风扇</strong>值:</li><li id="a20c" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">cpu_usage、average_mhs、温度和风扇值完全是随机的</li><li id="bf4b" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj"> cpu_usage </strong>可以从0% — 100%</li><li id="dc4d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj"> average_mhs </strong> —我举了一个例子，一个显卡可以产生26-30 Mh/s的速度</li><li id="6c1e" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">温度</strong>——在50到90度之间变化</li><li id="a9d1" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">风扇</strong> —从0% — 100%</li><li id="0e31" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">系列为2021–10–14和2021–10–15之间的每小时</strong>生成，步长为1小时(01:00、02:00、03:00等)</li><li id="1d09" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">交叉连接先前创建的矿工表</strong>，其中包含矿工姓名和显卡数量的信息</li><li id="c655" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">先按矿工id</strong>排序，然后每个分组按时间升序排序</li></ul><p id="c133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生与此类似的输出(由于用于cpu_usage、average_mhs、temperature和fan的random()函数不同，输出会有所不同)。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="f005" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">Jupyter笔记本</h2><p id="1cee" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">为了在图表中显示数值，我决定使用一个简单的<strong class="ih hj"> jupyter笔记本</strong>，这样我们就能对数据有所了解。</p><p id="a089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不熟悉jupyter，那也没关系——它是一个交互式web工具，用于将软件代码、计算输出、说明性文本和多媒体资源组合在一个文档中。它由Python驱动，但是您可以使用许多其他语言来绘制数据。</p><p id="bb40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我将用于显示表格或绘制图表的示例代码:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="6bf6" class="li kg hi md b fi mh mi l mj mk">import psycopg2 as pg<br/>import pandas.io.sql as psql<br/>import matplotlib.pyplot as plt</span><span id="b210" class="li kg hi md b fi ml mi l mj mk">conn = pg.connect(host=”localhost”, database=”dummy_data”, user=”postgres”, password=”password”)</span><span id="abff" class="li kg hi md b fi ml mi l mj mk">df = psql.read_sql(‘SELECT * FROM generate_series(1,5)’, conn)</span><span id="0a24" class="li kg hi md b fi ml mi l mj mk">df.head()</span></pre><p id="7da9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生与从命令行查询Postgres数据库相同的输出:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mv"><img src="../Images/325c12a20ada53116a849794128fe979.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*txZE5vfizLP659cE"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Using jupyter notebook to display table data</figcaption></figure><p id="554e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，这只是运行在jupyter笔记本上的python代码:</p><ul class=""><li id="c548" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated">连接到数据库</li><li id="5bff" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">执行查询</li><li id="079a" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated">在表格中显示数据。</li></ul><h2 id="d6f9" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">绘图数据</h2><p id="bbf5" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">例如，我可以绘制钻石矿工的温度(使用我们在上面已经看到的查询):</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="a11b" class="li kg hi md b fi mh mi l mj mk">import psycopg2 as pg<br/>import pandas.io.sql as psql<br/>import matplotlib.pyplot as plt</span><span id="ab9c" class="li kg hi md b fi ml mi l mj mk">conn = pg.connect(host="localhost", database="dummy_data", user="postgres", password="password")</span><span id="5fc9" class="li kg hi md b fi ml mi l mj mk">query_string = """<br/>   SELECT miners.name, s1.time,<br/>      random() * (100-0) + 0 AS cpu_usage,<br/>      random() * (30-26) + 26 * graphic_cards AS  average_mhs,<br/>      random() * (90-50) + 50 AS temperature,<br/>      random() * (100-0) + 0 AS fan<br/>   FROM generate_series(<br/>      '2021-10-14', <br/>      '2021-10-15', <br/>      INTERVAL '1 hour') AS s1(time)<br/>   CROSS JOIN(<br/>      SELECT id, name, graphic_cards <br/>      FROM miners <br/>      WHERE <br/>         name = 'Diamond'<br/>   ) miners<br/>   ORDER BY miners.id, s1.time;<br/>"""</span><span id="c568" class="li kg hi md b fi ml mi l mj mk">df = psql.read_sql(query_string, conn)<br/>#df</span><span id="0fb1" class="li kg hi md b fi ml mi l mj mk">plt.figure(figsize=(15,8))<br/>plt.plot(df["time"], df["temperature"])<br/>plt.show</span></pre><p id="1b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我稍微修改了一下查询，只返回<strong class="ih hj">钻石</strong>矿工的数据。我还添加了plt.figure，plt.plot &amp; plt.show。这将创建一个图形，定义x和y轴，并显示绘图。它产生了下面的情节:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mw"><img src="../Images/371486e2d24a4c8904245ade7806a883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6--CMm-I-fI1t-VZ"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Displaying temperature over time for Diamond miner</figcaption></figure><p id="505c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，这似乎不太现实。我们可以试着改变这个想法来获得更真实的数据</p><h1 id="c534" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">更现实的方法</h1><p id="bb4b" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">例如，我们可以说矿工只在下午6点到上午10点之间工作，因为那时的电费比较便宜。</p><p id="6bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将直接影响温度、风扇、average_mhs和cpu_usage。因此，让我们确定一个时间表，假设从上午10点到下午6点，我们用它来工作，从下午6点到上午10点，我们用它来挖掘加密。</p><p id="cce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们仍然可以预期在我们的工作时间中会有一些移动和随机性，而当miner用于挖掘crypto时，值将接近峰值。</p><p id="bf9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们还可以假设，一天中可能有一半时间，我们渲染视频并进行一些中等程度的数据处理，因此在这段时间内，我们的工作强度会稍高一些，而其余时间则是随意使用，可能是阅读、文档等。</p><h2 id="4f03" class="li kg hi bd kh lj lk ll kl lm ln lo kp iq lp lq kt iu lr ls kx iy lt lu lb lv bi translated">添加更多分散体</h2><p id="a244" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">因此，总结一下，我们有三个不同强度的三个周期:</p><ul class=""><li id="3188" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated"><strong class="ih hj">下午6点—上午10点—高强度</strong></li><li id="4216" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">上午10点—下午2点—中等强度</strong></li><li id="fa50" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">下午2点— 6点—低强度</strong></li></ul><p id="b6cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要继续，创建一个具有强度的表，从0到1描述一天中的每个小时，以增加更多的分散。<br/>表格会很简单:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="6af8" class="li kg hi md b fi mh mi l mj mk">CREATE TABLE hours ( <br/>  hour INT NOT NULL, <br/>  intensity NUMERIC NOT NULL<br/>);</span></pre><p id="2969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一天有24个小时，我们将根据以下规则定义每个小时的强度:</p><ul class=""><li id="7a7e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated"><strong class="ih hj">低强度从0–20%</strong></li><li id="666d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">中等强度为21–75%</strong></li><li id="1f8e" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">高强度超过75% </strong></li></ul><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="859d" class="li kg hi md b fi mh mi l mj mk">INSERT INTO hours(hour, intensity) VALUES<br/> (1,.9),<br/> (2,.92),<br/> (3,.89),<br/> (4,.95),<br/> (5,.94),<br/> (6,.80),<br/> (7,.88),<br/> (8,.79),<br/> (9,.78),<br/> (10,.56),<br/> (11,.55),<br/> (12,.63),<br/> (13,.28),<br/> (14,.14),<br/> (15,.18),<br/> (16,.07),<br/> (17,.07),<br/> (18,.89),<br/> (19,.8),<br/> (20,.78),<br/> (21,.92),<br/> (22,.86),<br/> (23,.82),<br/> (0,.87);</span></pre><p id="9a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有一个这样的表格:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="6dc0" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM hours;</span><span id="0dcd" class="li kg hi md b fi ml mi l mj mk">hour  | intensity <br/>------+-----------<br/>    1 |       0.9<br/>    2 |      0.92<br/>    3 |      0.89<br/>    4 |      0.95<br/>    5 |      0.94<br/>    6 |      0.80<br/>    7 |      0.88<br/>    8 |      0.79<br/>    9 |      0.78<br/>   10 |      0.56<br/>   11 |      0.55<br/>   12 |      0.63<br/>   13 |      0.28<br/>   14 |      0.14<br/>   15 |      0.18<br/>   16 |      0.07<br/>   17 |      0.07<br/>   18 |      0.89<br/>   19 |       0.8<br/>   20 |      0.78<br/>   21 |      0.92<br/>   22 |      0.86<br/>   23 |      0.82<br/>   0  |      0.87</span></pre><p id="c6f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用前面提到的值来定义峰值使用值(或某段时间内允许的最大值)，并使用如下查询:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="85e9" class="li kg hi md b fi mh mi l mj mk">SELECT <br/>   a.HOURLY, <br/>   ABS(intensity - rval)*100 as value<br/>FROM( <br/>   SELECT <br/>      HOURLY, <br/>      date_part('hour', HOURLY) _hour, <br/>      random()*0.2 as rval, <br/>      intensity                    <br/>   FROM generate_series(<br/>      '2021-10-14', <br/>      '2021-10-30', <br/>      INTERVAL '1 hour'<br/>   ) HOURLY<br/>   INNER JOIN hours h ON date_part('hour', HOURLY) = h.hour <br/>   ORDER BY hourly<br/>) AS a;</span></pre><p id="585d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">..为了得到一个随机值，它将比峰值低20%。<br/>查询中发生了什么？</p><p id="7c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从检查内部查询开始:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="42af" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM generate_series(<br/>   '2021-10-14', <br/>   '2021-10-30', <br/>   INTERVAL '1 hour'<br/>) HOURLY;</span></pre><p id="4e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生一系列时间，从2021–10–14 00:00:00开始，到2021–10–30 00:00:00结束，增量为1小时。</p><p id="1b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="393c" class="li kg hi md b fi mh mi l mj mk">2021-10-14 00:00:00+02<br/>2021-10-14 01:00:00+02<br/>2021-10-14 02:00:00+02<br/>2021-10-14 03:00:00+02<br/>2021-10-14 04:00:00+02<br/>...<br/>2021-10-30 00:00:00+02</span></pre><p id="dd8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们可以继续使用之前创建的<strong class="ih hj"> <em class="mb"> hours </em> </strong>表中的内部连接:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="38f1" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM generate_series(<br/>   '2021-10-14', <br/>   '2021-10-30', <br/>   INTERVAL '1 hour'<br/>) HOURLY<br/>INNER JOIN hours h ON date_part('hour', HOURLY) = h.hour <br/>ORDER BY hourly;</span></pre><p id="3ecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建一个包含三列的表:</p><ul class=""><li id="548a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated">每小时一次</li><li id="5c42" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">小时</strong></li><li id="068f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">强度</strong></li></ul><p id="33ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并将(小时，强度)对应用于我们先前生成的从<strong class="ih hj">2021–10–14 00:00:00</strong>到<strong class="ih hj">2021–10–30 00:00:00</strong>的一系列小时中的每个小时</p><p id="a67e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出如下所示:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="a712" class="li kg hi md b fi mh mi l mj mk">hourly                  | hour | intensity <br/>------------------------+------+-----------<br/> 2021-10-14 00:00:00+02 |    0 |      0.87<br/> 2021-10-14 01:00:00+02 |    1 |       0.9<br/> 2021-10-14 02:00:00+02 |    2 |      0.92<br/> 2021-10-14 03:00:00+02 |    3 |      0.89<br/> 2021-10-14 04:00:00+02 |    4 |      0.95<br/> 2021-10-14 05:00:00+02 |    5 |      0.94<br/> 2021-10-14 06:00:00+02 |    6 |      0.80<br/> 2021-10-14 07:00:00+02 |    7 |      0.88<br/> ...<br/> 2021-10-30 00:00:00+02 |    0 |      0.87</span></pre><p id="a376" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将其添加到外部查询中:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="278d" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM( <br/>   SELECT <br/>      HOURLY, <br/>      date_part(‘hour’, HOURLY) _hour, <br/>      random()*0.2 as rval, <br/>      intensity<br/>   FROM generate_series(<br/>      ‘2021–10–14’, <br/>      ‘2021–10–30’, <br/>      INTERVAL ‘1 hour’<br/>   ) HOURLY<br/>   INNER JOIN hours h ON date_part(‘hour’, HOURLY) = h.hour <br/>   ORDER BY hourly<br/>) AS a;</span></pre><p id="dc28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将得到四列:</p><ul class=""><li id="fa82" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ke jj jk jl bi translated"><strong class="ih hj">每小时</strong></li><li id="91ab" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">_小时</strong></li><li id="7181" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj"> rval </strong></li><li id="8aa1" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ke jj jk jl bi translated"><strong class="ih hj">强度</strong></li></ul><p id="a235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中三个是先前已知的，现在我们只计算一个rval，它是一个从0–0.2(0–20%)的随机数，<strong class="ih hj">它将在最后一次查询中从强度</strong>中减去(并且用ABS包装，这样我们永远不会得到负值)。</p><p id="298a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终产品如下所示:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mx"><img src="../Images/9c79cf682ca349a05ace256d2c419eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTyEAYT9RB9BAgZs5q5y_Q.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Displaying temperature data for period 10/14/2021–10/30/2021 randomly generated with three intensity factors — low, medium, and high</figcaption></figure><p id="a15a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，它的行为与我们在初始语句中描述的一样:</p><p id="e930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下午6点—上午10点—高强度<br/>上午10点—下午2点—中等强度<br/>下午2点—下午6点—低强度</strong></p><p id="8f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许以10分钟为间隔查看三个不同的强度级别会更好:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es my"><img src="../Images/f5cd9fd33b93b939963046b7ddf4999e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L4volJKQtgFf0KZE"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">10-minute interval with 3 intensity levels</figcaption></figure><p id="06c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当值从0–100%变化时，这可以模仿矿工的<strong class="ih hj"> fan </strong> values的行为。通过应用简单或更复杂的数学，我们也可以得到其他值。</p><p id="c22d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设这是一个适合我们需求的模型。现在，我们必须为所有设备创建数据，为期一年，增量为一小时？</p><p id="e263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧。</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="bf94" class="li kg hi md b fi mh mi l mj mk">SELECT <br/>   name, <br/>   HOURLY, <br/>   abs(intensity - rval)*100 as fan                <br/>FROM( <br/>   SELECT <br/>      miners.name, <br/>      HOURLY, <br/>      date_part('hour', HOURLY) _hour, <br/>      random()*0.2 as rval<br/>   FROM generate_series(<br/>      '2020-10-14', <br/>      '2021-10-14', <br/>      INTERVAL '1 hour'<br/>) HOURLY<br/>CROSS JOIN(<br/>   SELECT DISTINCT(name) <br/>   FROM miners<br/>) miners<br/>) m<br/>INNER JOIN hours h ON date_part('hour', HOURLY) = h.hour <br/>ORDER BY hourly;</span></pre><p id="e177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们这样计算，总共有<strong class="ih hj"> 26283行— (3个设备x 24h小时x 365天)+2021–10–14 00:00:00的3个条目</strong>(每个设备)= 26283。</p><h1 id="d49f" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">插入大量数据</h1><p id="642a" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">我们用5秒步长增量代替1小时增量，再加三个设备:<strong class="ih hj">银级，铜级，默认</strong>。</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="d440" class="li kg hi md b fi mh mi l mj mk">INSERT INTO <br/>   miners (id, name, graphic_cards) <br/>VALUES <br/>   (4, 'Silver', 3), <br/>   (5, 'Bronze', 2), <br/>   (6, 'Default', 1);</span></pre><p id="7fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开PostgreSQL计时，打开<strong class="ih hj">\计时。</strong></p><p id="80d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算行数:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="7a37" class="li kg hi md b fi mh mi l mj mk">#Input</span><span id="ab1d" class="li kg hi md b fi ml mi l mj mk">SELECT COUNT(*) FROM(<br/>   SELECT <br/>      name, <br/>      HOURLY, <br/>     abs(intensity - rval)*100 as fan                <br/>   FROM( <br/>      SELECT <br/>         miners.name, <br/>         HOURLY, <br/>         date_part('hour', HOURLY) _hour, <br/>         random()*0.2 as rval<br/>      FROM generate_series(<br/>         '2020-10-14', <br/>         '2021-10-14', <br/>         INTERVAL '5 second') HOURLY<br/>   CROSS JOIN(<br/>      SELECT DISTINCT(name) <br/>      FROM miners) <br/>   miners) m<br/>INNER JOIN hours h ON date_part('hour', HOURLY) = h.hour <br/>ORDER BY hourly) e;</span><span id="8841" class="li kg hi md b fi ml mi l mj mk"># Output</span><span id="ef6a" class="li kg hi md b fi ml mi l mj mk">count   <br/>----------<br/> 37843206<br/>(1 row)</span><span id="c2da" class="li kg hi md b fi ml mi l mj mk">Time: 48916.613 ms (00:48.917)</span></pre><p id="a6d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们花了48秒创建了3784.3万个数据。 <br/>最后，让我们将它插入到一个表格中，这样我们就不必每次都计算数据了:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="5ed4" class="li kg hi md b fi mh mi l mj mk">CREATE TABLE IF NOT EXISTS miner_data(<br/> time TIMESTAMPTZ NOT NULL,<br/> miner_name VARCHAR(20),<br/> fan_percentage FLOAT<br/>);</span></pre><p id="14c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加随机数据(这需要一些时间):</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="0126" class="li kg hi md b fi mh mi l mj mk">INSERT INTO miner_data(<br/>   miner_name, <br/>   time, <br/>   fan_percentage) <br/>SELECT <br/>   name, <br/>   HOURLY, <br/>   abs(intensity - rval)*100 as fan<br/>FROM( <br/>   SELECT <br/>      miners.name, <br/>      HOURLY, <br/>      date_part('hour', HOURLY) _hour, <br/>      random()*0.2 as rval<br/>   FROM generate_series(<br/>      '2020-10-14', <br/>      '2021-10-14', <br/>      INTERVAL '5 second'<br/>   ) HOURLY<br/>CROSS JOIN(<br/>   SELECT DISTINCT(name) <br/>   FROM miners) <br/>miners) m<br/>INNER JOIN hours h ON date_part('hour', HOURLY) = h.hour <br/>ORDER BY hourly;</span><span id="0922" class="li kg hi md b fi ml mi l mj mk">INSERT 0 37843206<br/>Time: 161775.825 ms (02:41.776)</span></pre><p id="7458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差不多三分钟就搞定了。</p><p id="beef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看我们的数据，假设我们绘制了过去10分钟的钻石和默认矿工粉丝百分比(每分钟12条记录* 10分钟=每个设备在图上有120个条目)。</p><p id="9031" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是jupyter笔记本/python代码:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="019a" class="li kg hi md b fi mh mi l mj mk">import psycopg2 as pg<br/>import pandas.io.sql as psql<br/>import matplotlib.pyplot as plt<br/>conn = pg.connect(host="localhost", database="dummy_data", user="postgres", password="password")</span><span id="353d" class="li kg hi md b fi ml mi l mj mk">query_string1 = """<br/>                SELECT * FROM miner_data WHERE miner_name = 'Diamond' ORDER BY TIME DESC LIMIT 120;<br/>                """</span><span id="46b9" class="li kg hi md b fi ml mi l mj mk">query_string2 = """<br/>                SELECT * FROM miner_data WHERE miner_name = 'Default' ORDER BY TIME DESC LIMIT 120;<br/>                """</span><span id="c96e" class="li kg hi md b fi ml mi l mj mk">df1 = psql.read_sql(query_string1, conn)<br/>df2 = psql.read_sql(query_string2, conn)<br/>#df</span><span id="b30e" class="li kg hi md b fi ml mi l mj mk">plt.figure(figsize=(15,8))<br/>plt.plot(df1["time"], df1["fan_percentage"])<br/>plt.plot(df2["time"], df2["fan_percentage"])<br/>plt.show</span></pre><p id="cd1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后的输出是:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mz"><img src="../Images/6bcd2f927a277b2bb7908d6e8403562b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eQavFBpZM7dlV3VC"/></div></div></figure><p id="9c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经成功地创建了3784.3万个完全随机但真实的数据，并将它们存储在数据库中。这可以进一步用于测试目的。</p><p id="1ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，查询如此大的数据集需要时间。<br/>例如，上面有一个简单的选择查询:</p><pre class="jt ju jv jw fd mc md me mf aw mg bi"><span id="7d90" class="li kg hi md b fi mh mi l mj mk">SELECT * FROM miner_data <br/>WHERE <br/>   miner_name = ‘Diamond’ <br/>ORDER BY TIME LIMIT 120;</span><span id="8739" class="li kg hi md b fi ml mi l mj mk">Time: 9403.223 ms (00:09.403)</span></pre><p id="4d5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询这个问题花了将近9.5秒。你不想等10秒钟再看图表吧？<br/>如果您有兴趣了解如何优化查询数据，请关注我的下一个系列— <strong class="ih hj">优化拥有数百万数据的PostgreSQL数据库的4种方法</strong></p><div class="na nb ez fb nc nd"><a href="https://josipvojak.com/4-ways-to-optimise-postgresql-database-with-millions-of-data-c70e11d27a94" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">优化拥有数百万数据的PostgreSQL数据库的4种方法</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">这些简单的技术可以将数据库性能提高25，500倍！</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">josipvojak.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kc nd"/></div></div></a></div></div></div>    
</body>
</html>
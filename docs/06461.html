<html>
<head>
<title>Auth0 Multi-Tenancy with React. Part3: Multi-tenancy with multiple DB Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带React的Auth0多租户。第3部分:具有多个数据库连接的多租户</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/auth0-multi-tenancy-with-react-part3-multi-tenancy-with-multiple-db-connections-b6b86ba94e10?source=collection_archive---------13-----------------------#2021-08-20">https://medium.com/geekculture/auth0-multi-tenancy-with-react-part3-multi-tenancy-with-multiple-db-connections-b6b86ba94e10?source=collection_archive---------13-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fd39" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是一组介绍使用React和Auth0构建多租户架构的可能方法的文章。我们将为每个可用选项实施POC(概念验证),并强调每个选项的利弊。它让你清楚地了解为当前项目选择哪些选项。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3471ca8847d2ff0f705ccaf6077eb8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GscZ_gpmwlg3DydxXH2IIA.jpeg"/></div></div></figure><h1 id="5d1d" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">文章系列的内容:</h1><ol class=""><li id="292e" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">带React的Auth0多租户。第一部分:介绍词</li><li id="7c37" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part2-multi-tenancy-attaching-tenant-specific-metadata-to-the-user-e125aa585e32"> Auth0多租户与React。第2部分:多租户，其中一个Auth0租户将特定于租户的元数据附加到使用中</a></li><li id="9219" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated">带React的Auth0多租户。第3部分:具有多个数据库连接的多租户— <strong class="kd hj">我们现在正在阅读这篇文章</strong></li><li id="0451" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated">带React的Auth0多租户。第4部分:具有多个授权租户的多租户— <strong class="kd hj"> TBD </strong></li></ol></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="6fd0" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">Auth0允许为每个Auth0租户创建多个连接。</p><blockquote class="lv lw lx"><p id="9905" class="lg lh ly kd b ke li ij lj kg lk im ll lz lm ln lo ma lp lq lr mb ls lt lu ko hb bi translated">连接是Auth0和用户源之间的关系(图1)。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/c8270931399a26d4f272f13402ff6def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeYdkZ1s8kGkKjy63-cbmA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 1 — Multi-Tenancy Architecture with multiple DB Connections</figcaption></figure><p id="2b00" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">一旦您创建了第一个Auth0租户，Auth0就会为我们创建第一个默认连接，名称为<strong class="kd hj"> <em class="ly">用户名-密码-身份验证</em> </strong>。您可以通过Auth0 Dashboard仔细检查，然后转到<strong class="kd hj">认证/数据库部分</strong>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/0588e0bfdecd919598d32ad59f930703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3npe25XbHhDsQCoYFi64rQ.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 2— Default connection</figcaption></figure><p id="4608" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">目前，您正在创建的所有用户都将使用此连接进行存储，默认情况下，Auth0将所有个人用户数据存储在内部数据库中，该数据库与创建Auth0租户的区域相同。</p><h2 id="ee7e" class="mi jk hi bd jl mj mk ml jp mm mn mo jt ki mp mq jv kk mr ms jx km mt mu jz mv bi translated">创建Auth0 DB连接</h2><p id="a059" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">在我们的例子中，我们有两个属于两个不同组织的用户池。让我们为每个组织创建两个连接(单击Create DB Connection按钮，图1)，每个连接对于每个授权租户都有一个唯一的名称:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/828beba9179f5561516638f9708009ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdmyqm9deeCJpjpZRL48Rg.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 3— Create new DB Connection for Organization1</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/c5ba712197a8855d4b5dc71341e50f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8KD4rhlFDYAfHslkJIR8w.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 4— DB Connections for each Organization</figcaption></figure><p id="6c84" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">一旦创建了连接，就转到它并启用API，我们可以在这些应用程序中使用它。转到<strong class="kd hj">应用</strong>选项卡，并启用多租户SPA，它已在上一篇文章中创建(<a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part1-introductory-word-7f2782cf71d">链接</a>):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/e0c10bd379c7ba0b88259112898a679d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktxT8asK4ZkSu06ULZi53g.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 5 — Enabling SPA Application for Connection</figcaption></figure><h2 id="2fcd" class="mi jk hi bd jl mj mk ml jp mm mn mo jt ki mp mq jv kk mr ms jx km mt mu jz mv bi translated">属于不同连接的用户创建</h2><p id="2c3f" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">出于测试目的，让我们创建两个属于不同组织(连接)的用户。您可以通过两种方式创建它们:</p><ul class=""><li id="4ec4" class="kb kc hi kd b ke li kg lk ki nc kk nd km ne ko nf kq kr ks bi translated">通过Auth0仪表板</li><li id="b6d5" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko nf kq kr ks bi translated">通过<a class="ae kt" href="https://auth0.com/docs/api/management/v2" rel="noopener ugc nofollow" target="_blank"> Auth0管理API </a></li></ul><p id="6463" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">我们遵循第一种方式，转到Auth0仪表板的<strong class="kd hj">用户管理/用户</strong>并点击<strong class="kd hj">创建用户</strong>按钮。像往常一样，您需要定义电子邮件、密码，因为我们创建了多个连接，所以为第一个用户选择了<code class="du ng nh ni nj b">Org1</code>连接:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nk"><img src="../Images/8cf80ade086473babd54dc428f690aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1afRU3CUw54Y2iVrtwS-g.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 5 — User creation for Connection belongs to Organization 1</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/87693ec35b7f29c024944fda3b55492f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCvcrpd0AXa8uQi5OvXiYw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 6 — Created users belong to different Organizations (Connections)</figcaption></figure><h2 id="8500" class="mi jk hi bd jl mj mk ml jp mm mn mo jt ki mp mq jv kk mr ms jx km mt mu jz mv bi translated">反应应用程序实施</h2><p id="1665" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">您可能已经从以前的文章中了解到，我们用<code class="du ng nh ni nj b">Auth0Provider</code>包装所有的React树，其中我们定义了<code class="du ng nh ni nj b">domain</code>、<code class="du ng nh ni nj b">clientId</code>和<code class="du ng nh ni nj b">redirectUri</code></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/d6c3689440988fafbba2cd8faa904e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkK6CIM9qxaOyq97hB5c9A.png"/></div></div></figure><p id="a145" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">由于我们为每个组织使用不同的数据库连接，我们还需要定义我们将使用哪个连接:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/b907fde82ae0eacd29db4a0dec1edfbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJh5xfWxxZEHPACwAbSpfg.png"/></div></div></figure><p id="7d6b" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">我们需要回答的第一个问题是，我们如何在前端发现用户试图从哪个组织登录？</p><p id="1071" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">有两个选项可以实现</p><h2 id="ad3f" class="mi jk hi bd jl mj mk ml jp mm mn mo jt ki mp mq jv kk mr ms jx km mt mu jz mv bi translated">用组织选择器区分组织</h2><p id="50d2" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">在用定义了特定名称<code class="du ng nh ni nj b">connection</code>的<code class="du ng nh ni nj b">Auth0Provider</code>包装应用程序树之前，我们需要让用户选择他/她来自哪个组织(图4)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/05a7a474f738bd9e5ad45b3f98e90f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84WBGjS5Kd85ta0WiFCuHA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 7 — User workflow to login</figcaption></figure><p id="a78d" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">只有在这之后，我们才可能知道特定组织的连接名称。让我们创建一个JSON文件，它包含一个对象数组，这些对象包含可用组织的元数据以及与之相关联的Auth0连接的名称:</p><pre class="iy iz ja jb fd np nj nq nr aw ns bi"><span id="7d99" class="mi jk hi nj b fi nt nu l nv nw">export const ORGANIZATIONS = [<br/>   {<br/>      "name": "Organization One",<br/>      "connection": "Org1"<br/>   },<br/>   {<br/>      "name": "Organization Two",<br/>      "connection": "Org2"<br/>]</span></pre><p id="e955" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">让我们实现<code class="du ng nh ni nj b">OrganizationSelector</code>组件，没有什么特别的，我们只是将<code class="du ng nh ni nj b">ORGANIZATIONS</code>列表传递给包含来自<code class="du ng nh ni nj b">material-ui</code>库的简单<code class="du ng nh ni nj b">Select</code>组件的组件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="e715" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">我们实现的核心是负责定义所需连接的<code class="du ng nh ni nj b">MultiTenancyAuth0Provider</code>。在我们查看特定的实现之前，让我们讨论一些细节。假设用户选择了我们保存在内存中的组织，并点击<strong class="kd hj">下一步</strong>按钮。下一步是使用通用登录将用户重定向到Auth0服务器。在用户被成功授权后，Auth0重定向回我们的应用程序(图8)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/eb0262d3addd891e39ac84d1900b3c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LW2zwnikbcW_7FAWRoH8g.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 8 — Redirections to Auth0 server and back</figcaption></figure><p id="5e69" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">在这种情况下，保存在内存中的组织将被移走。因此，我们需要将其保存在<code class="du ng nh ni nj b">localStorage</code>或<code class="du ng nh ni nj b">sessionStorage</code>中。由于该过程应该在一个浏览器选项卡中发生，<code class="du ng nh ni nj b">sessionStorage</code>更适合于此目的。该算法将具有以下逻辑:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/d9f9aadc89ce7bc7db7aadc6fef2bf22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLsrnn8licULaRQ70Qzwgw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 9 — Logic to define Organization Connection</figcaption></figure><p id="f069" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">这里还有一个问题。让我们假设用户不小心选择了我们在<code class="du ng nh ni nj b">sessionStorage</code>中保存的错误组织。你有什么方法可以让我们不通过浏览器开发工具手动清除<code class="du ng nh ni nj b">sessionStorage</code>而选择另一个组织吗？按照这种逻辑，每次当我们在同一个浏览器选项卡中点击应用程序URL时，应用程序都会用错误的连接将我们重定向到Auth0。我们可以避免在应用程序中引入两个变量来保持我们选择的组织。第一个是<code class="du ng nh ni nj b">temporaryOrganization</code>——它只是为未授权用户提供存储，允许我们在重定向到Auth0服务器的阶段暂时保留用户选择。只要Auth0将我们重定向回应用程序(我们可以通过分析重定向URL的查询属性来定义它，参见图8:包含查询参数<code class="du ng nh ni nj b">code</code>或<code class="du ng nh ni nj b">error</code>的每个URL都被认为是来自Auth0的重定向)。一旦我们发现这是应用程序的重定向阶段，我们就将组织从<code class="du ng nh ni nj b">temporaryOrganization</code>移动到<code class="du ng nh ni nj b">localStorage</code>到属性<code class="du ng nh ni nj b">authorisedOrganization</code>并删除<code class="du ng nh ni nj b">temporaryOrganization</code>。逻辑将如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ob"><img src="../Images/a7d85c313320d1178ab238c2690722d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GpYqNX5WM2alIE1_8Prkg.png"/></div></div></figure><p id="7e35" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">好了，我们来实现<code class="du ng nh ni nj b">MultiTenancyAuth0Provider</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="b072" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">让我们改变我们的<code class="du ng nh ni nj b">App.tsx</code>组件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="646a" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">此外，一旦用户想要注销，我们需要清除<code class="du ng nh ni nj b">Layout.tsx</code>组件中的所有组织存储:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="a204" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">您可以在分支<a class="ae kt" href="https://github.com/vladimirtopolev/auth0-multi-tenancy/tree/multi-tenancy-with-connections" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj">多租户连接</strong> </a>中的<a class="ae kt" href="https://github.com/vladimirtopolev/auth0-multi-tenancy" rel="noopener ugc nofollow" target="_blank">回购</a>中找到所有代码</p><p id="4f4e" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">让我们来看看演示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oc"><img src="../Images/1d53eefd26f509563bac5031b39c10c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_a06JbPRWgCInP43sXXLLQ.gif"/></div></figure><h2 id="a6ec" class="mi jk hi bd jl mj mk ml jp mm mn mo jt ki mp mq jv kk mr ms jx km mt mu jz mv bi translated">通过子域名区分组织</h2><p id="bba5" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">实现这一点的另一种方法是为每个组织使用子域名。例如，如果您通过域<code class="du ng nh ni nj b">https://app.com</code>托管您的应用程序，那么您可以使用URL的子域作为特定组织的唯一标识符:<code class="du ng nh ni nj b">https://{organizationName}.app.com</code>。在我们的例子中，我们可以定义以下URL:</p><pre class="iy iz ja jb fd np nj nq nr aw ns bi"><span id="622a" class="mi jk hi nj b fi nt nu l nv nw">https://org1.app.com<br/>https://org2.app.com</span></pre><h1 id="3b48" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">有没有办法将一个连接的每个用户池放置到不同的区域？</h1><p id="80a0" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">答案是肯定的。Auth0是一个灵活的系统，当您创建新连接时，默认情况下Auth0会将所有用户存储在内部数据库中，该数据库位于您创建Auth0租户的同一区域。Auth0允许连接一个外部数据库，它可以放在您想放的任何地方(图9)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es od"><img src="../Images/83186338e6a8f6f12706a2598b05c2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sUt48edYm9bO8rjR7GUrA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Figure 9 — Connection with Custom DB layers are placed in the necessary region</figcaption></figure><p id="8ad2" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated">要了解有关如何连接您自己的数据库存储的更多信息，请阅读此<a class="ae kt" href="https://auth0.com/docs/connections/database/custom-db/create-db-connection" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="3e4a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="0712" class="pw-post-body-paragraph lg lh hi kd b ke kf ij lj kg kh im ll ki mw ln lo kk mx lq lr km my lt lu ko hb bi translated">"+"您可以控制个人信息的物理存储位置。Auth0 connection允许您连接每个连接的外部数据库，该连接可以放置在您想要的任何区域</p><p id="ffc8" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated"><strong class="kd hj"> "+" </strong>很容易提取统计信息，如每个组织有多少用户，因为它已经被单独的连接分开</p><p id="a885" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated"><strong class="kd hj"> "+/-" </strong>用这种架构实现应用程序并不困难，但是比这篇<a class="ae kt" rel="noopener" href="/geekculture/auth0-multi-tenancy-with-react-part2-multi-tenancy-attaching-tenant-specific-metadata-to-the-user-e125aa585e32">文章</a>中提供的选项要复杂一点</p><p id="05b1" class="pw-post-body-paragraph lg lh hi kd b ke li ij lj kg lk im ll ki lm ln lo kk lp lq lr km ls lt lu ko hb bi translated"><strong class="kd hj"> "-" </strong>它增加了维护成本，因为当您将新客户端加载到您的应用程序时，您需要为它创建一个单独的连接，并将其包含在应用程序配置中。</p></div></div>    
</body>
</html>
<html>
<head>
<title>LeetCode — Binary Tree Zigzag Level Order Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —二叉树之字形层次顺序遍历</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-binary-tree-zigzag-level-order-traversal-c89427d80dce?source=collection_archive---------23-----------------------#2021-12-02">https://medium.com/geekculture/leetcode-binary-tree-zigzag-level-order-traversal-c89427d80dce?source=collection_archive---------23-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="725f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="698c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定二叉树的<code class="du kb kc kd ke b">root</code>,返回<em class="kf">其节点值的锯齿形层次顺序遍历。</em>(即从左到右，然后从右到左进行下一级并交替进行)。</p><p id="c452" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">问题陈述摘自:<a class="ae kl" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/binary-tree-zigzag-level-order-traversal/</a></p><p id="2b40" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es km"><img src="../Images/d31af91908fa4bd9258b09296f295df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*p_vrI29Dd-8BHKgCNrGpHw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">LeetCode</figcaption></figure><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="9d6e" class="lc ig hi ke b fi ld le l lf lg">Input: root = [3, 9, 20, null, null, 15, 7]<br/>Output: [[3], [20, 9], [15, 7]]</span></pre><p id="751d" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="8b7b" class="lc ig hi ke b fi ld le l lf lg">Input: root = [1]<br/>Output: [[1]]</span></pre><p id="d122" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">例3: </strong></p><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="47eb" class="lc ig hi ke b fi ld le l lf lg">Input: root = []<br/>Output: []</span></pre><p id="768d" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="d4cc" class="lc ig hi ke b fi ld le l lf lg">- The number of nodes in the tree is in the range [0, 2000].<br/>- -100 &lt;= Node.val &lt;= 100</span></pre><h1 id="b38d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="110d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要逐层遍历二叉树，我们可以参考我们之前的博文<a class="ae kl" href="https://alkeshghorpade.me/post/leetcode-binary-tree-level-order-traversal" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="fecb" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">根据问题陈述，我们需要以之字形方式穿越。我们可以通过在完全遍历一个级别时反转我们创建的<code class="du kb kc kd ke b">tmp</code>数组来实现这一点。</p><p id="4843" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">让我们检查算法:</p><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="ba87" class="lc ig hi ke b fi ld le l lf lg">- initialize 2D array as vector vector&lt;vector&lt;int&gt;&gt; result<br/>- initialize size and i<br/>- set left to true<br/><br/>- return result if root == null<br/><br/>- initialize queue&lt;TreeNode*&gt; q<br/>  - push root to queue : q.push(root)<br/><br/>- initialize TreeNode* node for iterating on the tree<br/><br/>- loop while( !q.empty() ) // queue is not empty<br/>  - initialize vector&lt;int&gt; tmp<br/>  - set size = q.size()<br/><br/>  - loop for i = 0; i &lt; size; i++<br/>    - set node = q.front()<br/><br/>    - if node-&gt;left<br/>      - push in queue: q.push(node-&gt;left)<br/><br/>    - if node-&gt;right<br/>      - push in queue: q.push(node-&gt;right)<br/><br/>    - remove the front node: q.pop()<br/>    - push node-&gt;val to tmp. tmp.push_back(node-&gt;val)<br/><br/>  - left is false: if(!left)<br/>    - reverse(tmp.begin(), tmp.end())<br/><br/>  - push the tmp to result: result.push_back(tmp)<br/>  - toggle left: left = !left<br/><br/>- return result</span></pre><h2 id="72e7" class="lc ig hi bd ih lh li lj il lk ll lm ip jo ln lo it js lp lq ix jw lr ls jb lt bi translated">C++解决方案</h2><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="b812" class="lc ig hi ke b fi ld le l lf lg">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {<br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/>        int size, i;<br/>        bool left = true;<br/><br/>        if(root == NULL)<br/>            return result;<br/><br/>        queue&lt;TreeNode* &gt; q;<br/>        q.push(root);<br/><br/>        TreeNode* node;<br/><br/>        while(!q.empty()){<br/>            vector&lt;int&gt; tmp;<br/>            size = q.size();<br/><br/>            for(i = 0; i &lt; size; i++){<br/>                node = q.front();<br/><br/>                if(node-&gt;left)<br/>                    q.push(node-&gt;left);<br/><br/>                if(node-&gt;right)<br/>                    q.push(node-&gt;right);<br/><br/>                q.pop();<br/>                tmp.push_back(node-&gt;val);<br/>            }<br/><br/>            if(!left){<br/>                reverse(tmp.begin(), tmp.end());<br/>            }<br/><br/>            result.push_back(tmp);<br/>            left = !left;<br/>        }<br/><br/>        return result;<br/>    }<br/>};</span></pre><h2 id="b11d" class="lc ig hi bd ih lh li lj il lk ll lm ip jo ln lo it js lp lq ix jw lr ls jb lt bi translated">戈朗溶液</h2><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="ef9b" class="lc ig hi ke b fi ld le l lf lg">func reverse(array []int) []int {<br/>    for i, j := 0, len(array) - 1; i &lt; j; i, j = i+1, j-1 {<br/>        array[i], array[j] = array[j], array[i]<br/>    }<br/><br/>    return array<br/>}<br/><br/>func zigzagLevelOrder(root *TreeNode) [][]int {<br/>    result := [][]int{}<br/>    left := true<br/><br/>    queue := []*TreeNode{root}<br/><br/>    for len(queue) != 0 {<br/>        tmp := []int{}<br/>        size := len(queue)<br/><br/>        for i := 0; i &lt; size; i++ {<br/>            if queue[0] != nil {<br/>                tmp = append(tmp, queue[0].Val)<br/>                queue = append(queue, queue[0].Left)<br/>                queue = append(queue, queue[0].Right)<br/>            }<br/><br/>            queue = queue[1:]<br/>        }<br/><br/>        if !left {<br/>            tmp = reverse(tmp)<br/>        }<br/><br/>        result = append(result, tmp)<br/>        left = !left<br/>    }<br/><br/>    return result[:len(result)-1]<br/>}</span></pre><h2 id="60e2" class="lc ig hi bd ih lh li lj il lk ll lm ip jo ln lo it js lp lq ix jw lr ls jb lt bi translated">Javascript解决方案</h2><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="2346" class="lc ig hi ke b fi ld le l lf lg">var zigzagLevelOrder = function(root) {<br/>    let result = [];<br/>    let queue = [];<br/>    let left = true;<br/><br/>    if(root)<br/>        queue.push(root);<br/><br/>    while(queue.length &gt; 0) {<br/>        tmp = [];<br/>        let len = queue.length;<br/><br/>        for (let i = 0; i&lt; len; i++) {<br/>            let node = queue.shift();<br/>            tmp.push(node.val);<br/><br/>            if(node.left) {<br/>                queue.push(node.left);<br/>            }<br/><br/>            if(node.right) {<br/>                queue.push(node.right);<br/>            }<br/>        }<br/><br/>        if( !left ) {<br/>            tmp = tmp.reverse();<br/>        }<br/><br/>        result.push(tmp);<br/>        left = !left;<br/>    }<br/><br/>    return result;<br/>};</span></pre><p id="2fea" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kn ko kp kq fd ky ke kz la aw lb bi"><span id="f074" class="lc ig hi ke b fi ld le l lf lg">Input: root = [3, 9, 20, null, null, 15, 7]<br/><br/>Step 1: vector&lt;vector&lt;int&gt;&gt; result<br/>        int size, i<br/>        left = true<br/><br/>Step 2: root == null<br/>        [3, 9..] == null<br/>        false<br/><br/>Step 3: queue&lt;TreeNode*&gt; q<br/>        q.push(root)<br/><br/>        q = [3]<br/><br/>Step 4: loop !q.empty()<br/>        q = [3]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 1<br/><br/>        for(i = 0; i &lt; 1; i++)<br/>          - 0 &lt; 1<br/>          - true<br/><br/>          node = q.front()<br/>          node = 3<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = 9<br/>            - q.push(node-&gt;left)<br/>            - q = [3, 9]<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = 20<br/>            - q.push(node-&gt;right)<br/>            - q = [3, 9, 20]<br/><br/><br/>          q.pop()<br/>          q = [9, 20]<br/><br/>          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(3)<br/><br/>          i++<br/>          i = 1<br/><br/>        for(i &lt; 1)<br/>        1 &lt; 1<br/>        false<br/><br/>        if !left<br/>           !left = false<br/><br/>        result.push_back(tmp)<br/>        result = [[3]]<br/>        left = !left<br/>             = false<br/><br/>Step 5: loop !q.empty()<br/>        q = [9, 20]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 2<br/><br/>        for(i = 0; i &lt; 2; i++)<br/>          - 0 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 9<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false<br/><br/>          q.pop()<br/>          q = [20]<br/><br/>          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(9)<br/><br/>          i++<br/>          i = 1<br/><br/>        for(i &lt; 2)<br/>          - 1 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 20<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = 15<br/>            - q.push(node-&gt;left)<br/>            - q = [20, 15]<br/><br/>          if node-&gt;right<br/>            - node-&gt;left = 7<br/>            - q.push(node-&gt;right)<br/>            - q = [20, 15, 7]<br/><br/>          q.pop()<br/>          q = [15, 7]<br/><br/>          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(20)<br/>          tmp = [9, 20]<br/><br/>          i++<br/>          i = 2<br/><br/>        for(i &lt; 2)<br/>          - 2 &lt; 2<br/>          - false<br/><br/>        if !left<br/>           !left = true<br/><br/>        reverse(tmp.begin(), tmp.end())<br/>        tmp = [20, 9]<br/><br/>        result.push_back(tmp)<br/>        result = [[3], [20, 9]]<br/>        left = !left<br/>             = true<br/><br/>Step 6: loop !q.empty()<br/>        q = [15, 7]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 2<br/><br/>        for(i = 0; i &lt; 2; i++)<br/>          - 0 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 15<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false<br/><br/>          q.pop()<br/>          q = [7]<br/><br/>          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(15)<br/><br/>          i++<br/>          i = 1<br/><br/>        for(i &lt; 2)<br/>          - 1 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 7<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = nil<br/>            - false<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = nil<br/>            - false<br/><br/>          q.pop()<br/>          q = []<br/><br/>          tmp.push_back(node-&gt;val)<br/>          tmp.push_back(7)<br/>          tmp = [15, 7]<br/><br/>          i++<br/>          i = 2<br/><br/>        for(i &lt; 2)<br/>          - 2 &lt; 2<br/>          - false<br/><br/>        if !left<br/>           !left = false<br/><br/>        result.push_back(tmp)<br/>        result = [[3], [20, 9], [15, 7]]<br/><br/>Step 7: loop !q.empty()<br/>        q = []<br/>        q.empty() = true<br/>        !true = false<br/><br/>Step 8: return result<br/><br/>So we return the result as [[3], [20, 9], [15, 7]].</span></pre></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="14a8" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><em class="kf">最初发布于</em><a class="ae kl" href="https://alkeshghorpade.me/post/leetcode-binary-tree-zigzag-level-order-traversal" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://alkeshghorpade . me</em></a><em class="kf">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Lock High Level Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">锁定高级设计</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lock-high-level-design-3e02bbb8eb7f?source=collection_archive---------26-----------------------#2021-03-09">https://medium.com/geekculture/lock-high-level-design-3e02bbb8eb7f?source=collection_archive---------26-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5e0e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">简介2021 </strong></h1><p id="8de7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个文档最初是我自己写的，大约在2014年实现的。</p><ul class=""><li id="4c21" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">注意，所有系统都是一堆Web服务(不是微服务！).</li><li id="908c" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">另外，请注意，每个微服务有一个共享数据库，而不是数据库/模式。</li></ul><p id="6681" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">基本思想如下:有一些离线工作的web服务。为了确保数据的一致性，任何人都不应该使用它的数据。当这样的web服务开始工作时，需要写锁。为了简单起见，我们假设此时不需要读锁(否则，写锁就不能被获取)。因此，当写锁没有被释放时，任何人都不能获得这个web服务的读锁，这样的请求将会失败。当这样的web服务将完成它的工作时，写锁将被释放，每个人都可以请求读锁并使用这些数据(可选地，我们还可以限制并发读锁的数量)。</p><p id="f40b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">第一个版本基于MySql和<code class="du ku kv kw kx b">select for update </code>特性。它写于2009年左右，不是我自己写的。决定重写实现有两个基本原因:</p><ul class=""><li id="b277" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">我们已经使用了MySql和postgresh，我们想把所有东西都移植到postgresh。</li><li id="79b9" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">如果Web服务被<code class="du ku kv kw kx b">kill -9</code> <em class="ky">停止，对DB表</em>(不仅仅是数据)<em class="ky"> </em>的锁定不会释放，需要一些手动干预。</li><li id="c3a6" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><em class="ky"> Minor </em>:用半静态表去掉左连接，在内存中进行连接，可以提高性能。</li></ul><p id="3909" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">如果我今天要重写这个系统，我会使用<a class="ae kz" href="https://aws.amazon.com/sns/" rel="noopener ugc nofollow" target="_blank">亚马逊SNS </a>或<em class="ky"> RabbitMQ </em>甚至<em class="ky"> Kafka </em>(回放<em class="ky">所有事件的能力可以这样利用)。</em></p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="4646" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">初始化</h1><p id="0bd2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当应用程序启动时，有两件事情要处理— <em class="ky"> releaseAllLocks </em>(如果我们在中间杀死应用程序，那么锁被获取而没有被释放，但是没有作业正在进行)和<em class="ky">refreshlockpletions</em>(每个锁的许可数量)。</p><ul class=""><li id="1521" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><em class="ky"> releaseAllLocks </em> —当应用程序刚刚启动时，数据库中不应存在以前运行的锁。<br/>所以我们要通过<em class="ky"> app_id </em>解锁所有look。如果我们不这样做，锁将继续丰富。只需删除这些行。(由<em class="ky"> app_id识别)</em>。</li><li id="d11a" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><em class="ky">refreshlockpletions</em>—我们应该更新被覆盖的许可值的缓存(来自<strong class="jf hj">Locking _ permissions)。</strong>有关更多详细信息，请参见“<em class="ky">锁定许可缓存</em>”部分。</li></ul></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="8b0f" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">锁定获取</h1><p id="0ee4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是API中的第一个主要方法。此方法尝试获取锁。如果失败，<code class="du ku kv kw kx b">0L</code>将被退回，如果成功，图章将被退回。</p><p id="2eb0" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">public long tryLocks(Set&lt;Lock&gt; lock)</em></code></p><p id="e051" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="ky">注意:</em>也是<em class="ky"> app_id </em>隐式传递(将在应用<code class="du ku kv kw kx b">init </code>阶段设置)。但是，不应该用这种方法。</p><p id="0b7a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">Lock是一个简单的类(不是所讨论的<code class="du ku kv kw kx b">enum </code>),如果是读或写锁，它保存<em class="ky">枚举名称</em>和<em class="ky">布尔指示</em>。</p><p id="a523" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">典型WebService2持有<code class="du ku kv kw kx b">Lock.WS2_WRITE</code>和<code class="du ku kv kw kx b">Lock.WS1_READ</code>(这就是为什么它接收<em class="ky">组锁</em>而不是单个锁)。</p><ul class=""><li id="54f3" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj">注2021: </strong>我们希望能够动态地<em class="ky"/>为系统添加网络服务和锁。所以，锁可以是Java的包含所有锁的<code class="du ku kv kw kx b">enum</code>类。我做了一些解决方案来动态地添加实例到T5，但是这只是一个大的黑客行为，可以在小的JDK更新上达到收支平衡。拼图游戏项目将会在JDK上映，所以对我来说很清楚，这种黑客行为会产生大量的技术债务。</li></ul><p id="fde7" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">它返回将作为参数传递给锁释放的戳。将返回特殊值零，表示无法获取访问权限。</p><p id="be25" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">注2021 </strong>:在实际实现中，我也实现了一些简单的重试机制，作为<code class="du ku kv kw kx b">tryLocks()</code>方法的包装。更多详情见下面的<em class="ky">“事务隔离”</em>部分。</p><h1 id="5f76" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">算法(由<em class="lm">锁名</em>提取):</h1><ol class=""><li id="993f" class="kb kc hi jf b jg jh jk jl jo ln js lo jw lp ka lq kj kk kl bi translated"><strong class="jf hj">用</strong> <code class="du ku kv kw kx b"><strong class="jf hj">SERIALIAZABLE</strong></code> <strong class="jf hj">隔离开始事务。</strong></li></ol><p id="bd17" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="ky">注意:</em> <code class="du ku kv kw kx b">SERIALIAZABLE </code>交易在8.4版本中不工作，需要升级到9.1以上版本。详情参见下面的<em class="ky">“事务隔离”</em>部分。</p><p id="71c9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">2.收集所有锁名(不考虑读/写模式)。</p><p id="fa55" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">3.按锁名选择数据库中的所有锁。</p><p id="6f00" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">4.对于锁中的每个锁:</p><p id="4709" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">a)计算<em class="ky"> writeLockInUse </em> —使用中的写锁数量(从数据库结果中)；<br/> b)计算<em class="ky"> readLockInUse </em> —使用中的读锁数量(从数据库结果中)；<br/> c)计算<em class="ky">许可</em>(从使用乐观读锁的缓存)。</p><p id="c562" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">使用乐观读锁(<code class="du ku kv kw kx b">tryOptimisticRead()</code>方法)。</p><p id="123d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">大多数情况下它会成功。在缓存更新的偶然事件中，使用常规的阻塞读锁。参见<code class="du ku kv kw kx b">StampedLock</code> <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html" rel="noopener ugc nofollow" target="_blank">的JavaDoc中的<code class="du ku kv kw kx b">distanceFromOrigin()</code>示例https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/locks/stampedlock . html</a></p><p id="eae0" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">1.1.如果是写锁定:</p><p id="304e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">a)如果<em class="ky">readLockInUse</em>T55】0返回0L；</p><p id="4f02" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">b) <em class="ky">如果writeLockInUse </em> + 1 &gt; <em class="ky">允许</em>返回0L；</p><p id="9322" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">c)否则(没有使用读锁并且<em class="ky">写锁使用</em> + 1 &lt; = <em class="ky">许可</em>，对于许可=1这简化为<em class="ky">写锁使用&lt; =0 </em>这意味着没有使用写锁)</p><p id="261a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">根据数据库数据检查我们是否应该插入或更新数据库中的行，将此信息存储在<em class="ky"> readLockToUpdate、writeLockToUpdate、readLockToInsert、writeLockToInsert中。</em></p><p id="3ae1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">1.2.如果是读锁:<br/> a)如果<em class="ky">写锁使用</em>T59】0返回0L；<br/> b)如果<em class="ky">readlock inuse</em>1&gt;T28】允许返回0L；</p><p id="ecb8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">c)否则(不使用写锁，读锁使用<em class="ky">+1&lt;=<em class="ky">许可</em>，对于许可=1，这简化为<em class="ky">读锁使用&lt; =0 </em>，这意味着不使用写锁)</em></p><p id="2cee" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">2.如果我们在这里，那就是我们成功地验证了所有的锁都可以被获取。</p><p id="1f15" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">3.创建最终SQL。使用<em class="ky"> batchUpdate() </em>批量执行。</p><p id="5ce5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="ky">注意:</em>不要求戳记是密码安全的(即有效戳记可以是可猜测的)。更多详情参见<em class="ky">“数据库表”</em>部分。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="b5ef" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">释放锁</h1><p id="fbb5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是API中的第二个主要方法。此方法释放获得的锁。如果失败，将返回0L，如果成功，将返回stamp。</p><pre class="lr ls lt lu fd lv kx lw lx aw ly bi"><span id="92ae" class="lz ig hi kx b fi ma mb l mc md"><em class="ky">public void releaseLocks(long stamp)</em></span></pre><h1 id="d4d8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">算法(按app_id删除，戳):</h1><ol class=""><li id="07b6" class="kb kc hi jf b jg jh jk jl jo ln js lo jw lp ka lq kj kk kl bi translated">删除这些行。(由<em class="ky"> app_id，stamp识别)</em>。<br/> <code class="du ku kv kw kx b">JdbcTemplate’s <em class="ky">update</em></code> <em class="ky"> () </em>方法返回受影响的<code class="du ku kv kw kx b"><em class="ky">numberOfRows</em></code>。</li><li id="1d86" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lq kj kk kl bi translated">如果<code class="du ku kv kw kx b"><em class="ky">numberOfRows</em></code> ==0抛出<code class="du ku kv kw kx b">IllegalMonitorStateException.<br/></code>没有找到行，则传递无效戳。</li></ol><p id="ab72" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>因为API接收为参数戳，所以在锁获取中不存在(除非有人会猜测，否则可以忽略)，所以<em class="ky"> releaseLocks </em>()不能与<em class="ky"> tryLocks </em>混淆。</p><ul class=""><li id="98ae" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">如果我们用不同的stamp(和app_id)对<em class="ky"> releaseLocks() </em>进行两次并发运行，这里没有问题，它们使用表的不同部分。</li><li id="8754" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">如果stamp是相同的(并且我们忽略与<em class="ky">相同stamp </em>的组合，但是<em class="ky">不同的app_id </em>将在同一时间范围内<em class="ky"> ) </em>在不同的机器上创建，由于行排他锁，一个事务将首先成功完成，而另一个事务将不删除任何行并且失败。</li></ul><p id="0c7e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">注:</strong></p><ul class=""><li id="28ae" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">只有当我们只有一个delete语句时，上面的分析才是正确的。如果我们有更多的SQL语句，它就可能被打破。</li></ul></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="6bee" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">锁定许可缓存</h1><p id="2555" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基本思想是将所有表格内容保存在<code class="du ku kv kw kx b">ConcurrentHashMap</code>中。在应用程序初始化中加载它。还有<em class="ky">后台线程</em>会定期刷新这个缓存。这样，如果我们在数据库中更改配置，所有应用程序将在一段时间后看到这一变化，不需要重新启动。</p><p id="761c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">public void refreshLockPermits()</em></code></p><p id="89cf" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">注:</strong></p><ol class=""><li id="e5eb" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka lq kj kk kl bi translated">这些配置应该存储在DB中，而不是属性文件中，因为我们希望它在所有web服务中完全相同。</li><li id="710d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka lq kj kk kl bi translated">在从数据库的每个选择中，缓存的使用优于对<strong class="jf hj">Locking _ permissions</strong>进行左连接(这是在以前的实现中)。我们需要做两个左连接(计算读锁和写锁的许可)。使用缓存会更快。</li></ol><p id="430d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在<code class="du ku kv kw kx b">ConcurrentHashMap</code>更新中几乎没有什么微妙之处。</p><p id="6f3e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">1.简单的方法是调用<code class="du ku kv kw kx b"> cache.clear();cache.putAll(dataFromDB);</code> <br/>这种方法有两个问题:</p><p id="6bad" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">a)这不是原子更新。在<code class="du ku kv kw kx b">clear() </code>完成和开始<code class="du ku kv kw kx b">putAll(</code>之间有一段时间，我们有空的缓存。我们的锁机制将在错误的许可值下工作。</p><p id="7869" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">b) <code class="du ku kv kw kx b">clear()</code>和<code class="du ku kv kw kx b"> putAll()</code>本身不是原子的。引用自ConcurrentHashMap Javadoc:</p><blockquote class="me mf mg"><p id="6151" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated">对于putAll和clear之类的聚合操作，并发检索可能只反映某些条目的插入或删除…请记住，聚合状态方法(包括size、isEmpty和containsValue)的结果通常只有在映射没有在其他线程中进行并发更新时才有用。否则，这些方法的结果反映的瞬态可能足以用于监测或估计目的，但不适用于程序控制。</p></blockquote><p id="d3d7" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/concurrent hashmap . html</a></p><p id="8e30" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">因此，我们需要使用一些外部同步机制来更新地图，更重要的是，读取地图。</p><p id="f8dd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">2.映射中的条目不是独立的。如果数据库中的读锁被更改，我们应该自动更新读锁和写锁。</p><h1 id="f389" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">算法(为<strong class="ak">锁定_许可</strong>提取全部):</h1><p id="e768" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1.使用<code class="du ku kv kw kx b">StampedLock</code>进行缓存的外部同步。</p><p id="3f18" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">2.大部分时间DB没有变化。<br/>如果没有变化——不需要更新高速缓存，因此首先让我们识别是否是这种情况。<br/>如果是，我们不会更新缓存，锁获取代码也不会阻塞。如果有变化，我们会阻止。</p><p id="b3b5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">a)将来自DB的数据存储在本地映射中(与我们的缓存具有相同的结构)；</p><p id="0339" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">b)使用阻塞读锁来访问我们的高速缓存；</p><p id="a42e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">c)比较两个映射，如果它们等于返回(释放读锁定)；</p><p id="cdae" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">d)如果它们不等于将锁升级为阻塞写锁(参见JavaDoc的<code class="du ku kv kw kx b">moveIfAtOrigin()</code>方法作为示例)；</p><p id="a03e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">e) <code class="du ku kv kw kx b">cache.clear(); cache.putAll(localMap);</code>(注意，这是在写锁定下完成的)</p><p id="0b64" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">f)释放写锁定；</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="ff86" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">数据库表</h1><p id="d892" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">锁定</strong>(主表)</p><p id="01fd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这是锁定机制中的主表。所有正在使用的锁都存储在这个表中。DB中的每一行都代表锁。</p><p id="5866" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Lock_Name</em> </code> —例如锁的名称(<code class="du ku kv kw kx b">WS1</code>)；</p><p id="b66a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Mode</em> </code> — <code class="du ku kv kw kx b">null </code>(未锁定)，<code class="du ku kv kw kx b">R </code> —读取，<code class="du ku kv kw kx b">W</code>—写入锁定；<code class="du ku kv kw kx b">WS1</code>锁定在读模式这里会有<code class="du ku kv kw kx b">R</code>，在写模式会有<code class="du ku kv kw kx b">W</code>；</p><p id="df9c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">App_id</em> </code> —标识哪个应用程序/web服务创建/管理此锁。获取锁时被忽略。</p><p id="8c2d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Stamp</em> </code> —标识所获得的锁的集合的标记；</p><p id="8755" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">戳记将使用有限表示，并且不是密码安全的(即，有效的戳记可能是可猜测的)。<code class="du ku kv kw kx b">System.currentTimeMillis()</code>将被使用。这与StampedLock接口一致。引自it's JavaDoc:</p><blockquote class="me mf mg"><p id="b4e1" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated">戳记使用有限的表示，并且不是密码安全的(即，有效的戳记可能是可猜测的)。连续运行一年后(不早于一年),印花税可以回收。超过此期限未使用或未验证的图章可能无法正确验证。StampedLocks是可序列化的，但总是反序列化为初始解锁状态，因此它们对远程锁定没有用。</p></blockquote><p id="5cba" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/locks/stampedlock . html</a></p><p id="5f3b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Created</em> </code> —仅供参考，何时获得锁定；</p><p id="c35a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">主键是<code class="du ku kv kw kx b">(lockName, mode, stamp)</code>。</p><p id="a5de" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这里不应该定义任何索引(在任何给定的时间内，该表都不应该超过100行，因此100行可能适合一个磁盘页，并且没有计划可以超过顺序获取1个磁盘页)。</p><p id="022b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">锁定_许可</strong>(可选)</p><p id="3dee" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">默认情况下，写锁是排他锁(1个允许)，如果没有使用写锁，则可以使用1个读锁。对于特定的锁，您可以覆盖此表中的这些默认值。</p><p id="b2b3" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Lock_Name</em></code> —锁的名称；</p><p id="3c05" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Mode</em> </code> — <code class="du ku kv kw kx b">null </code>(未锁定)，<code class="du ku kv kw kx b">R </code> —读取，<code class="du ku kv kw kx b">W</code>—写入锁定；</p><p id="95a5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b"><em class="ky">Permits</em> </code> —许可数量。应该是整数&gt; =1。</p><p id="f0ce" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="ky">注意:</em>这些配置应该存储在数据库中，而不是属性文件中，因为我们希望它在所有应用程序中完全相同。</p><p id="f2b9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">主键是<code class="du ku kv kw kx b">(lockName, mode)</code>。</p><p id="b500" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">此处不应定义任何索引(对于主键，回归会自动创建索引)。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="e2f9" class="if ig hi bd ih ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc bi translated">事务隔离</h1><p id="8364" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">锁定获取将通过<code class="du ku kv kw kx b">SERIALIAZABLE </code>隔离完成。所有其他的东西都会被处理掉</p><p id="c802" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="ky">默认</em> ( <code class="du ku kv kw kx b">READ_COMMITED</code>)。</p><p id="3695" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><code class="du ku kv kw kx b">SERIALIAZABLE </code>交易无法在8.4版本中运行，需要升级到9.1以上版本。详见<a class="ae kz" href="http://stackoverflow.com/questions/12824217/isolation-level-serializable-in-spring-jdbc" rel="noopener ugc nofollow" target="_blank">http://stack overflow . com/questions/12824217/isolation-level-serializable-in-spring-JDBC</a>。</p><p id="7dbd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">让我们看看一些国会文件:</p><blockquote class="me mf mg"><p id="81f5" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated">错误:由于并发更新，无法序列化访问。<br/> <br/>当应用程序收到这个错误消息时，它应该中止当前的事务，并从头开始重试整个事务。</p></blockquote><p id="64a2" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><a class="ae kz" href="https://www.postgresql.org/docs/current/static/transaction-iso.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/current/static/transaction-iso . html</a>:</p><p id="e2e1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">因此<strong class="jf hj">应该开发锁客户端的重试机制</strong>。<br/> <br/>另引:</p><blockquote class="me mf mg"><p id="83aa" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated"><code class="du ku kv kw kx b">Repeatable Read</code>模式提供了一个严格的保证，即每个事务看到一个完全稳定的数据库视图。然而，这种观点不一定总是与同一级别的并发事务的一些串行(一次一个)执行相一致。</p><p id="e8e8" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>在PostgreSQL版本9.1之前，对<code class="du ku kv kw kx b">Serializable </code>事务隔离级别的请求提供了与这里描述的完全相同的行为。<em class="hi">【上图】</em></p></blockquote><p id="71f9" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><a class="ae kz" href="https://www.postgresql.org/docs/9.4/static/applevel-consistency.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/9.4/static/applevel-consistency . html</a></p><p id="218b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj"> <em class="ky">注2021: </em> </strong>可以说<strong class="jf hj">在9.1版之前没有“真正的”</strong> <code class="du ku kv kw kx b"><strong class="jf hj"><em class="ky">Serializable </em></strong></code> <strong class="jf hj">事务隔离级别。</strong></p><p id="89d1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">另一段引用自</p><blockquote class="me mf mg"><p id="226f" class="jd je ky jf b jg kd ji jj jk ke jm jn mh kr jq jr mi ks ju jv mj kt jy jz ka hb bi translated">如果将<code class="du ku kv kw kx b">Serializable </code>事务隔离级别用于需要一致数据视图的所有写入和读取，则不需要其他努力来确保一致性。<br/> <br/>当使用这种技术时，如果应用软件通过一个自动重试因串行化失败而回滚的事务的框架，它将避免给应用程序员造成不必要的负担。将default_transaction_isolation设置为serializable可能是个好主意。<em class="hi">【在数据源级别】</em></p></blockquote><p id="1f2d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><a class="ae kz" href="https://www.postgresql.org/docs/9.4/static/applevel-consistency.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/9.4/static/applevel-consistency . html</a></p><p id="583f" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">实际上在我们的例子中没有，因为我放松了释放锁的要求，<strong class="jf hj">它不应该是可序列化的。</strong></p></div></div>    
</body>
</html>
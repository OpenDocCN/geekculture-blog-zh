<html>
<head>
<title>Resampling Methods for Machine Learning modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习建模的重采样方法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/resampling-methods-for-machine-learning-modeling-d2cdc1d3640f?source=collection_archive---------3-----------------------#2021-04-07">https://medium.com/geekculture/resampling-methods-for-machine-learning-modeling-d2cdc1d3640f?source=collection_archive---------3-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1c5a29f5853c841665595cd5f9747a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gT-NcAM-0lddm6ik"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image by <a class="ae iu" href="https://unsplash.com/@madhatterzone" rel="noopener ugc nofollow" target="_blank">Manja Vitolic</a><strong class="bd iv"> </strong>from <a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6283" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">什么是重采样方法？</strong></p><p id="cf53" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一般来说，重采样方法是一种工具，它包括从数据集中重复提取样本，并对这些样本中的每个样本计算统计数据和度量，以便获得关于某些东西的进一步信息，在机器学习设置中，这些东西是模型的性能。但是在仅仅是统计分析的情况下，这可能是关于一些参数的行为的额外洞察</p><p id="a28d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">我们为什么要用它？</strong></p><p id="3a77" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">两个词可以表达使用重采样方法的必要性:<strong class="iy hj">随机机会</strong>。每次我们从总体中抽取样本并计算统计量时，估计的参数可能会尽可能接近真实的总体值，这只是由于随机的机会，因此我们没有任何关于结论可信度的信息，我们的预测将是可疑的。这就是为什么我们使用<strong class="iy hj"> bootstrapping </strong>，从我们的原始样本中抽取多个样本(重新采样)，我们可以首先探索可能产生的不同组合，计算标准误差和置信区间，这为我们提供了估计真实总体参数的一致值范围。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/ca2ff55edf45a4b3d042b5daab543acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*aKuEDrwWA3_9z-0IuEi-zQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Computing a statistic from a sample carries some degree of uncertainty. In the image we can see how the sample estimate differs from the real value in approx. 36%. The bootstrap method helps us to address this problem. PS: the effect has been exaggerated. Image by Author</figcaption></figure><p id="1a27" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在评估模型性能的情况下，我们通常将数据集分为训练集和测试集。但是这种方法有一个缺点，模型的性能会根据所选的测试集显示不同的结果。由于关心模型的是它的泛化能力(在看不见的数据上执行)，这种测量的不稳定性使得比较不同的模型变得困难，并且给出了模型性能的可疑景象</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/1c9248ff1f4cbb310eeab1a3a3c23a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*A8lT5zYXMADQ7Ll0nqIoNQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Depending on the test set selected, the evaluation of a model can be very misleading. In the image we can see how the model shows F1 Scores (a performance metric) ranging from 0.2 to 1.0 (Which is a big deal of difference). The cross-validation approach comes in handy to address this volatility. Image by Author</figcaption></figure><p id="04fb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">自举</strong></p><p id="3808" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">自举是由反义寡核苷酸引起的重采样方法。它包括从我们的原始样本中取出多个样本，并研究由此产生的分布，我们为什么要这样做？嗯，它让我们可以看到有多少变化，并进一步了解我们首先采取的样本。</p><p id="063f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">bootstrap方法主要用于提供估计的标准误差，从而计算置信区间。</p><p id="480a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">自举方法的优势</strong></p><ul class=""><li id="e62d" class="ka kb hi iy b iz ja jd je jh kc jl kd jp ke jt kf kg kh ki bi translated">这很容易实现</li><li id="2833" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">它不依赖于我们对人口分布的任何假设</li><li id="3c88" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">让我们对数据集的不确定性有所了解，从而得出更一致的结论</li></ul><p id="3669" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">它是如何工作的？</strong></p><p id="07d9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">执行引导程序重采样的步骤如下:</p><ul class=""><li id="208d" class="ka kb hi iy b iz ja jd je jh kc jl kd jp ke jt kf kg kh ki bi translated">从人群中抽取一个样本，一个数据集</li><li id="40c2" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">从样品中取出多个样品并替换。我们采集的样本越多，它就越精确，……而且会消耗越多的时间</li><li id="7f5b" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">计算这些样品中每一个的感兴趣的统计量</li><li id="b71d" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">确定结果分布的标准误差(标准偏差),并用它们计算置信区间</li><li id="dd22" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">然后使用这个置信区间进行数据分析。你可以根据不确定性的详细程度对总体参数做出结论</li></ul><p id="cd90" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">插图</strong></p><p id="6f70" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们假设我们有两个变量X和Y，并希望量化它们之间的相关性。做统计的人现在知道这个度量可以用公式来确定:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/613a09bf764472ec935329e15c90d05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/0*eJ5zf3XOMZqu5f97"/></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/37cc84294b704c8e2373296e57da2555.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*a8VuqYiLR5932prz"/></div></figure><p id="3b98" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于我们的模拟生成的数据集(图像),我们计算出的相关性为0.55，这表明X和Y之间存在某种正相关关系:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/5250645992bf5202b694996c219d8b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*f-knmRN5fgZvsNFd8eiBUg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image by Author</figcaption></figure><p id="66fd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">问题出现在真实情况下，我们无法获得群体参数，因为我们无法通过模拟生成数据，诸如方差和相关性之类的量是不可获得的，但却是可估计的。我们能做的是使用样本数据计算这些测量的近似值，但是由于上面解释的随机机会的影响，我们不能完全依赖这些点估计。这就是bootstrap发挥作用的地方</p><p id="35de" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们首先从总体中抽取一个样本，假设我们的样本有100个观察值</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/d9348d04a2df9770dfc36609425fa8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*COhPPxUrWraHwpwvzce-0A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image by Author</figcaption></figure><p id="d414" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在，bootstrap方法允许我们使用计算机来模拟获得新样本集的过程，因此我们可以仅使用初始样本(100个观察值)来估计相关性的可变性。我们不是从总体中获得独立的数据集，而是通过从原始数据集重复采样观察值并计算每个重采样的相关性来获得不同的数据集。下图描述了这一过程:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/b20885f629a8c64ade79565fe0272d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*hBD9ZxDZiIy9wBlEn-ikFg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image by Author</figcaption></figure><p id="bcbd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在每个重采样中得到的度量(在这种情况下是相关性)构成了一个分布，即所谓的自举分布</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/e3d537c813b8f188f9402d2e7186d309.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*3d3PVjDIu-AAMzJcC24RYA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Bootstrap distribution build on a sample of 100 observations draw out from a 10K population. The black line represents the real population value (0.55). Image by Author</figcaption></figure><p id="91cf" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然后我们可以使用这个引导分布来做我们想做的任何事情。比如计算置信区间或者估计人口参数。</p><p id="b61a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">值得注意的是，自举不是减少误差的方法，而是估计误差。它旨在计算总体的形状和分布，而不是点估计(单个值而不是它们的区间)。它没有向我们的样本添加新数据，正如我们从上面的直方图中看到的，bootstrap分布的平均值与实际平均值略有不同，这是因为所选样本引入的偏差，如果我们的数据更具代表性，我们的分布将更加以平均值为中心，反之亦然。它有助于进一步了解我们的人口，但它不是万灵药，如果我们的样本是极端有偏见的，那么我们从自举或任何其他重采样方法得出的任何结论都将是可疑的</p><p id="9e73" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">交叉验证</strong></p><p id="4004" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">机器学习设置的主要缺点之一是训练误差和测试误差之间的差异。这方面的一个例子是著名的过拟合，大多数统计学习算法通过考虑比信号更多的噪声来直接或间接地寻求最小化训练误差，然后，当给模型提供新数据时，与训练度量可能首先指示的相比，它表现很差。不要误解我的意思，训练指标是自动化和了解学习算法执行情况的关键(快速比较)，但最终，模型的效用取决于它管理不可见数据的能力(通过测试指标衡量)。举例来说，当我们优化训练指标时，我们可能正在记忆数据，当优化测试指标时，我们正在从中学习，这就是我们想要的。</p><p id="7520" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">什么是交叉验证法？</p><p id="a6c8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">将数据集划分为一个大的训练集和一个小的测试集是拟合和评估模型的典型方法，这被称为验证集方法。但是这种方法存在以下问题:</p><ul class=""><li id="7c29" class="ka kb hi iy b iz ja jd je jh kc jl kd jp ke jt kf kg kh ki bi translated">测试错误率的验证估计值变化很大，具体取决于哪些观察值包含在训练集中，哪些观察值包含在验证集中(如本文第二张图所示)</li><li id="4e0a" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">只有观察值的子集(包括在训练集中而不是验证集中的观察值)用于拟合模型</li></ul><p id="938e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">交叉验证是对这种方法的改进，旨在解决以前的责任。它的变种很少，但最实用的是<strong class="iy hj">分层</strong> <strong class="iy hj"> k倍交叉验证</strong></p><p id="8fd0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">它基本上以如下方式工作:</p><ul class=""><li id="14e8" class="ka kb hi iy b iz ja jd je jh kc jl kd jp ke jt kf kg kh ki bi translated">而不是创建两个数据子集，一个用于训练，另一个用于测试。这种方法包括<strong class="iy hj">随机地</strong>将一组观察结果分成<em class="ku"> k个</em>组，或者折叠，大小大致相等。第一个折叠被视为验证集，该方法适用于剩余的k1折叠</li><li id="06a7" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">然后，测试误差(或测试度量)是根据保留的折叠(验证集)的观察值来计算的</li><li id="c8dd" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">这个过程重复<em class="ku"> k </em>次；每次，一组diﬀerent观察值被视为一个验证集。这个过程产生测试误差的<em class="ku"> k </em>估计值。k倍交叉验证估计值是通过对这些值取平均值来计算的，这可以被认为是我们评估模型的最终的、经过策划的测试度量</li></ul><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/3cf422a91c74499b549b626a861bd012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*UEDAttUgYr_CcObQBuTVmg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">An illustration of how the stratified k-fold cross-validation approach works. In this case we are performing the algorithm with k = 5. Acv is the average of all the metrics estimated, and is the metric that we can use to compare between models. Acv could be any test metric we want, like the Mean Square Error (MSE), or the F1-Score; in case of classification models. Image by Author</figcaption></figure><p id="1543" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">交叉验证的优势</strong></p><p id="24a0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">基本上，交叉验证方法的优点/效用是它解决了前面提到的责任</p><ul class=""><li id="283f" class="ka kb hi iy b iz ja jd je jh kc jl kd jp ke jt kf kg kh ki bi translated">由于重采样的数量，我们可以对获得的不同测试度量进行平均，击败当我们只有一个测试集时随机机会的影响</li><li id="877f" class="ka kb hi iy b iz kj jd kk jh kl jl km jp kn jt kf kg kh ki bi translated">我们使用所有的数据。当我们给它们更多的数据时，好的构建算法表现得更好。而且用他们没有见过的数据测试模型，获得准确的测试度量</li></ul><p id="acc4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">什么时候使用引导和交叉验证？</p><p id="3a19" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">虽然bootstrap和CV都是重采样方法，但是它们的用途是不同的。当<strong class="iy hj">通过测试指标评估<strong class="iy hj">型号</strong>的性能时，你应该使用交叉验证。当你想用他的标准误差和置信区间对某个群体的值进行估计的时候。</strong></p><h1 id="b660" class="kv kw hi bd iv kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考:</h1><p id="db63" class="pw-post-body-paragraph iw ix hi iy b iz ls jb jc jd lt jf jg jh lu jj jk jl lv jn jo jp lw jr js jt hb bi translated">R中的统计学习导论。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to mock network request in Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在玩笑中模仿网络请求</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-mock-network-request-in-jest-40958bb8d8e2?source=collection_archive---------1-----------------------#2021-10-03">https://medium.com/geekculture/how-to-mock-network-request-in-jest-40958bb8d8e2?source=collection_archive---------1-----------------------#2021-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="02fa" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">测试</h2><div class=""/><div class=""><h2 id="ac8e" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">模仿网络请求更加容易</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/7136bb0c42fda2231a0ffbb1a99eaed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poXRRZdZAElrrP9C3ZQLoQ.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@tvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Taylor Vick</a> on <a class="ae jw" href="https://unsplash.com/@tvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b870" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在需要修改一个比较老的库到<code class="du kt ku kv kw b">TS</code>，进行单元测试。如果库修改为<code class="du kt ku kv kw b">TS</code>，还是有一点点好的。单元测试纯粹是一个当前的研究，现在出售。对于初学者学习<code class="du kt ku kv kw b">Jest</code>框架，我认为单元测试中比较麻烦的是测试网络请求。所以记录下<code class="du kt ku kv kw b">Mock</code>丢弃<code class="du kt ku kv kw b">Axios</code>来发起网络请求的一些方式。这是我的第39篇中型文章。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="2a89" class="le lf hi bd lg lh li lj lk ll lm ln lo ix lp iy lq ja lr jb ls jd lt je lu lv bi translated">介绍</h1><p id="421f" class="pw-post-body-paragraph jx jy hi jz b ka lw is kc kd lx iv kf kg ly ki kj kk lz km kn ko ma kq kr ks hb bi translated">文中提到的例子都在<a class="ae jw" href="https://github.com/sabesansathananthan/jest-mock-server" rel="noopener ugc nofollow" target="_blank"> jest-mock-server </a>存储库中。可以通过安装包管理器直接启动例子，比如通过<code class="du kt ku kv kw b">yarn</code>安装:</p><pre class="jh ji jj jk fd mb kw mc md aw me bi"><span id="0a54" class="mf lf hi kw b fi mg mh l mi mj">$ yarn install</span></pre><p id="2047" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">一些命令在<code class="du kt ku kv kw b">package.json</code>中指定，如下:</p><ul class=""><li id="2b92" class="mk ml hi jz b ka kb kd ke kg mm kk mn ko mo ks mp mq mr ms bi translated"><code class="du kt ku kv kw b">npm run build</code>:<code class="du kt ku kv kw b">rollup</code>的打包命令。</li><li id="ab2a" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><code class="du kt ku kv kw b">npm run test:demo1</code>:简单来说就是<code class="du kt ku kv kw b">mock</code>封装的网络请求库。</li><li id="38cb" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><code class="du kt ku kv kw b">npm run test:demo2</code>:通过重新执行<code class="du kt ku kv kw b">hook</code>来完成<code class="du kt ku kv kw b">mock</code>。</li><li id="273f" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><code class="du kt ku kv kw b">npm run test:demo3</code>:使用<code class="du kt ku kv kw b">Jest</code>中的库完成<code class="du kt ku kv kw b">demo2</code>的实现。</li><li id="3223" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><code class="du kt ku kv kw b">npm run test:demo4-5</code>:启动<code class="du kt ku kv kw b">node</code>服务器，<code class="du kt ku kv kw b">proxy</code>通过<code class="du kt ku kv kw b">axios</code>的代理将网络请求转发给已启动的<code class="du kt ku kv kw b">node</code>服务器。通过设置相应的单元测试请求和响应数据，利用对应关系来实现测试，这就是<code class="du kt ku kv kw b">jest-mock-server</code>完成的工作。</li></ul><p id="d072" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这里我们封装了一层<code class="du kt ku kv kw b">axios</code>，更接近真实场景。可以查看<code class="du kt ku kv kw b">test/demo/wrap-request.ts</code>文件。事实上，它只是在内部创建一个<code class="du kt ku kv kw b">axios</code>实例，并转发响应数据。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="494a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du kt ku kv kw b">test/demo/index.ts</code>文件简单地导出了一个<code class="du kt ku kv kw b">counter</code>方法，在发起网络请求之前，这两个参数被处理到一定程度。然后对响应数据也进行一定程度的处理，只是为了模拟相关操作。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="e4c4" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这里<code class="du kt ku kv kw b">Jest</code>使用<code class="du kt ku kv kw b">JSDOM</code>模拟的浏览器环境，启动文件<code class="du kt ku kv kw b">test/config/setup.js</code>配置在<code class="du kt ku kv kw b">jest.config.js</code>配置的<code class="du kt ku kv kw b">setupFiles</code>属性中，<code class="du kt ku kv kw b">JSDOM</code>在这里初始化。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="8d12" class="le lf hi bd lg lh li lj lk ll lm ln lo ix lp iy lq ja lr jb ls jd lt je lu lv bi translated">演示1:简单的模拟网络请求</h1><p id="52cf" class="pw-post-body-paragraph jx jy hi jz b ka lw is kc kd lx iv kf kg ly ki kj kk lz km kn ko ma kq kr ks hb bi translated">简单的<code class="du kt ku kv kw b">mock</code>处理是在<code class="du kt ku kv kw b">test/demo1.test.js</code>中执行的，你可以尝试通过npm <code class="du kt ku kv kw b">run test:demo1</code>来运行。事实上，在包装了<code class="du kt ku kv kw b">axios</code>的<code class="du kt ku kv kw b">wrap-request</code>库上执行了一个<code class="du kt ku kv kw b">mock</code>操作。<code class="du kt ku kv kw b">wrap-request</code>将在<code class="du kt ku kv kw b">Jest</code>启动时编译。在这里模拟库之后，所有后来导入到库中的文件都将得到被模拟的对象。换句话说，我们可以认为这个库被重写了，重写后的方法都是<code class="du kt ku kv kw b">JEST</code>的<code class="du kt ku kv kw b">Mock Functions</code>。您可以使用<code class="du kt ku kv kw b">mockReturnValue</code>等功能进行数据模拟。<code class="du kt ku kv kw b">Mock Functions</code>请参见此<a class="ae jw" href="https://www.jestjs.cn/docs/mock-functions" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="e1df" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这里我们完成了返回值的<code class="du kt ku kv kw b">Mock</code>，也就是说我们可以控制<code class="du kt ku kv kw b">wrap-request</code>库中的<code class="du kt ku kv kw b">request</code>返回的值。但是，前面提到过，传入参数也有特定的过程。我们还没有对这部分内容做任何断言，所以我们也需要尝试处理这一点。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="8254" class="le lf hi bd lg lh li lj lk ll lm ln lo ix lp iy lq ja lr jb ls jd lt je lu lv bi translated">演示2:挂钩网络请求</h1><p id="78ff" class="pw-post-body-paragraph jx jy hi jz b ka lw is kc kd lx iv kf kg ly ki kj kk lz km kn ko ma kq kr ks hb bi translated"><code class="du kt ku kv kw b">demo2</code>可以通过<code class="du kt ku kv kw b">npm run test:demo2</code>试运行。如上所述，我们可以处理返回值，但是没有办法断言输入参数是否被正确处理，所以我们需要处理这种情况。幸运的是，<code class="du kt ku kv kw b">Jest</code>提供了一种直接实现被嘲笑的函数库的方法。因此，<code class="du kt ku kv kw b">Jest</code>也提供了一个<code class="du kt ku kv kw b">mockImplementation</code>方法，在<code class="du kt ku kv kw b">demo3</code>中使用。这里我们重写了被模仿的函数库。我们也可以用<code class="du kt ku kv kw b">jest.fn</code>来完成<code class="du kt ku kv kw b">Implementations</code>。这里，我们在返回之前编写一个<code class="du kt ku kv kw b">hook</code>函数，然后在每个<code class="du kt ku kv kw b">test</code>中实现断言或指定返回值。这样就可以解决上面的问题，其实就是<code class="du kt ku kv kw b">Jest</code>中<code class="du kt ku kv kw b">Mock Functions</code>的<code class="du kt ku kv kw b">mockImplementation</code>的实现。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="e093" class="le lf hi bd lg lh li lj lk ll lm ln lo ix lp iy lq ja lr jb ls jd lt je lu lv bi translated">演示3:使用Jest的模拟实现</h1><p id="a656" class="pw-post-body-paragraph jx jy hi jz b ka lw is kc kd lx iv kf kg ly ki kj kk lz km kn ko ma kq kr ks hb bi translated"><code class="du kt ku kv kw b">demo3</code>可以通过<code class="du kt ku kv kw b">npm run test:demo3</code>试运行。<code class="du kt ku kv kw b">demo2</code>中的例子其实写起来很复杂。在<code class="du kt ku kv kw b">Jest</code>中，<code class="du kt ku kv kw b">Mock Functions</code>有<code class="du kt ku kv kw b">mockImplementation</code>的实现，可以直接使用。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="532f" class="le lf hi bd lg lh li lj lk ll lm ln lo ix lp iy lq ja lr jb ls jd lt je lu lv bi translated">演示4–5:真正发起网络请求</h1><p id="993c" class="pw-post-body-paragraph jx jy hi jz b ka lw is kc kd lx iv kf kg ly ki kj kk lz km kn ko ma kq kr ks hb bi translated"><code class="du kt ku kv kw b">demo4</code>和<code class="du kt ku kv kw b">demo5</code>可以通过<code class="du kt ku kv kw b">npm run test:demo4–5</code>试运行。这样，就提出了一个真实的数据请求。这里，<code class="du kt ku kv kw b">axios</code> proxy将用于将内部数据请求转发到指定的服务器端口。因此，服务器也在本地启动，通过指定与相应的<code class="du kt ku kv kw b">path</code>相关的请求和响应数据来执行测试。如果请求的数据不正确，则相关的响应数据将不能正常匹配。所以请求会直接返回<code class="du kt ku kv kw b">500</code>。如果返回的响应数据不正确，也将在断言期间被捕获。在<code class="du kt ku kv kw b">jest-mock-server</code>库中，首先我们需要指定三个文件，分别对应每个单元测试文件在启动前要执行的三个生命周期。<code class="du kt ku kv kw b">Jest</code>测试在三个生命周期之前执行，三个生命周期在<code class="du kt ku kv kw b">Jest</code>测试完成之后执行。我们需要指定的三个文件是<code class="du kt ku kv kw b">jest.config.js</code>配置文件的<code class="du kt ku kv kw b">setupFiles</code>、<code class="du kt ku kv kw b">globalSetup</code>和<code class="du kt ku kv kw b">globalTeardown</code>配置项。</p><p id="d2a1" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">首先我们将从<code class="du kt ku kv kw b">setupFiles</code>开始。除了初始化<code class="du kt ku kv kw b">JSDOM</code>，我们还需要操作<code class="du kt ku kv kw b">axios</code>的默认代理。因为采用的解决方案是用<code class="du kt ku kv kw b">axios</code>的<code class="du kt ku kv kw b">proxy</code>来转发数据请求。因此，有必要将代理值设置在单元测试的最前面。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="0e2a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">一旦我们在<code class="du kt ku kv kw b">test/config</code>文件夹中设置了上面的文件，那么我们需要在那里再添加两个文件，分别是<code class="du kt ku kv kw b">globalSetup</code>和<code class="du kt ku kv kw b">globalTeardown</code>。这两个文件是指在<code class="du kt ku kv kw b">Jest</code>单元测试开始之前和所有测试完成之后所执行的操作。我们将服务器启动和关闭操作放在这两个文件中。</p><blockquote class="na nb nc"><p id="5357" class="jx jy nd jz b ka kb is kc kd ke iv kf ne kh ki kj nf kl km kn ng kp kq kr ks hb bi translated">请注意，这两个文件中运行的文件是一个单独独立的<code class="du kt ku kv kw b"><em class="hi">contex</em></code>，与任何单元测试的<code class="du kt ku kv kw b"><em class="hi">contex</em></code>无关，包括setupFiles配置项指定的文件。所以这里所有的数据要么在配置文件中指定，要么就是通过网络在服务器端口之间传输。</p></blockquote><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="0688" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">对于配置端口和域名信息，直接放在<code class="du kt ku kv kw b">jest.config.js</code>中的<code class="du kt ku kv kw b">globals</code>字段。对于<code class="du kt ku kv kw b">debug</code>配置项，建议配合<code class="du kt ku kv kw b">test.only</code>使用。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="402f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，可能会有人提出为什么服务器不应该在每个单元测试文件的<code class="du kt ku kv kw b">beforeAll</code>和<code class="du kt ku kv kw b">afterAll</code>生命周期中启动和关闭。因此，我尝试了这个解决方案。在这个解决方案中，对于每个测试文件，服务器启动，然后关闭。因此，这种解决方案比较耗时。但理论上，这种解决方案是合理的。毕竟，数据隔离是必要的，这是事实。但是<code class="du kt ku kv kw b">afterAll</code>关闭的时候有一个问题。它实际上并没有关闭服务器和端口占用，因为在关闭<code class="du kt ku kv kw b">node</code>服务器时会调用<code class="du kt ku kv kw b">close</code>方法。当<code class="du kt ku kv kw b">afterAll</code>关闭时，它停止处理请求，但是端口仍然被占用。当第二个单元测试文件启动时，将抛出一个异常，表明端口正在被使用。虽然我尝试了一些解决方案，但它们并不理想，因为有时端口仍然被占用。尤其是<code class="du kt ku kv kw b">node</code>开启后第一次运行时，出现异常的概率比较高。所以效果不是很理想。最终采用完全隔离方案。具体相关问题请参考此<a class="ae jw" href="https://stackoverflow.com/questions/14626636/how-do-i-shutdown-a-node-js-https-server-immediately" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="5cde" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">由于我们采用了完全隔离的解决方案，当我们想要传输测试请求的请求和响应数据时，只有两种选择。这两种解决方案要么是服务器启动时所有数据都在<code class="du kt ku kv kw b">test/config/global-setup.js</code>文件中指定，要么是服务器运行时数据通过网络传输，路径被指定，路径的网络请求将携带数据，数据请求将在服务器的关闭中指定。因此，这里支持这两种选项。我觉得在每个单元测试文件中指定自己的数据比较合适，所以这里只举一个在单元测试文件中指定要测试的数据的例子。关于要测试的数据，指定了一个<code class="du kt ku kv kw b">DataMapper</code>类型，以减少由类型错误引起的异常。因此，这里以两个数据集为例。另外，匹配<code class="du kt ku kv kw b">query</code>和<code class="du kt ku kv kw b">data</code>时支持正则表达式。<code class="du kt ku kv kw b">DataMapper</code>型的结构比较标准。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="5fc9" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在下面两个单元测试中，要测试的数据在<code class="du kt ku kv kw b">beforeAll</code>中指定。注意<code class="du kt ku kv kw b">beforeAll</code>是返回setSuitesData(data)因为单元测试是在数据置位且响应成功后执行的，后面是正常的请求和响应断言测试是否正确。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>
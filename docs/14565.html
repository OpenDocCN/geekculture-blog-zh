<html>
<head>
<title>Angular: Prevent loss of data in forkJoin operator when few of the multiple inner observables fail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:当多个内部可观察对象中有几个失败时，防止forkJoin操作符中的数据丢失</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-prevent-loss-of-data-in-forkjoin-operator-when-few-of-the-multiple-inner-observables-fail-c38225a1adf1?source=collection_archive---------3-----------------------#2022-09-09">https://medium.com/geekculture/angular-prevent-loss-of-data-in-forkjoin-operator-when-few-of-the-multiple-inner-observables-fail-c38225a1adf1?source=collection_archive---------3-----------------------#2022-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<strong class="ih hj"> mergeMap </strong>，<strong class="ih hj"> forkJoin </strong>是另一个能够并行执行可观测量的操作符。</p><p id="0584" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对mergeMap更感兴趣，你可以看看下面的故事，它探讨了同样的想法。</p><div class="jd je ez fb jf jg"><a href="https://ramya-bala221190.medium.com/angular-avoid-losing-all-data-in-mergemap-rxjs-operator-when-few-of-the-multiple-inner-observables-448251b6e8e1" rel="noopener follow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">Angular:避免在mergeMap RXJS运算符中丢失所有数据</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">RXJS操作符:mergeMap和forkJoin，当你想并行执行任务时非常有用，例如所有重要的任务…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">ramya-bala221190.medium.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><p id="5292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一下这个场景。</p><ol class=""><li id="8640" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">我使用<strong class="ih hj"> forkJoin </strong>操作符并行获取5个用户的数据:<strong class="ih hj"> A、B、C、D和E </strong>。获取每个用户数据的API调用将对应于一个内部可观察订阅。</li><li id="eb33" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">假设，2个用户<strong class="ih hj"> B，C </strong>不存在。因此，对应于这两个用户的API调用将失败，并出现HTTP 404。这意味着2个可观测量将出错，并且对应于其他3个用户<strong class="ih hj"> A、D和E </strong>的API调用可能有成功的机会，如果它们仍在进行中，也将取消。</li><li id="0bfb" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">我不想仅仅因为2个用户<strong class="ih hj"> B，C </strong>的API调用失败，就丢失剩余3个用户:<strong class="ih hj"> A，D，E </strong>的数据。</li><li id="8871" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">我还想显示与两个用户<strong class="ih hj"> B、C </strong>相关的错误。</li></ol><p id="e29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我想实现的东西的截图。这是一个小角度的应用。我试图获取5个用户的数据，其中2个不存在。但是我没有丢失其他3个用户的数据。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/1b1a5acc7366912ef71fdaec96bfd7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEAcHMC3zXahoCG4SdTnng.png"/></div></div></figure><p id="cd30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们显示了与2个用户相对应的错误消息，还显示了3个用户的ID和名称，我们可以获取他们的数据。</p><p id="0ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件模板:</strong>这正是我们在截图中看到的。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="98b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按钮<strong class="ih hj">获取数据，</strong>将调用<strong class="ih hj"> fetch()，</strong>，在这里我们尝试获取5个用户的数据。</p><p id="dff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们订阅了两个观察值:<strong class="ih hj"> errorObservable$ </strong>和<strong class="ih hj"> data$ </strong>，分别显示错误和用户数据。</p><p id="c17c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件类别:</strong></p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="3e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> fetch() </strong>中，我们使用<strong class="ih hj"> forkJoin </strong>操作符进行了API调用来并行获取5个用户的数据。我们已经调用了<strong class="ih hj">数据服务</strong>中的<strong class="ih hj"> getUser() </strong>来进行API调用以获取数据。</p><pre class="kl km kn ko fd kx ky kz la aw lb bi"><span id="72ad" class="lc ld hi ky b fi le lf l lg lh"><strong class="ky hj">getUser(id: number)</strong> {<br/>return this.http<br/>.get(`<strong class="ky hj">https://jsonplaceholder.typicode.com/users/${id}</strong>`)<br/>.pipe(<strong class="ky hj">catchError((err) =&gt; throwError(err))</strong>);<br/>}</span></pre><p id="01a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经将<strong class="ih hj"> handleRequest() </strong>管道化为从<strong class="ih hj"> getUser() </strong>返回的可观察对象，如下所示。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="5bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> handleRequest() </strong>中，我们返回了一个自定义的可观察对象，它将从<strong class="ih hj"> getUser() </strong>返回的可观察对象作为参数，并将<strong class="ih hj"> map </strong>和<strong class="ih hj"> catchError </strong>操作符通过管道传递给它。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="9086" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果由<strong class="ih hj"> getUser() </strong>发出的API调用成功，那么<strong class="ih hj">映射操作符</strong>就会执行并简单地返回响应，该响应只是一个包含用户数据的简单对象。我们在下面记录了<strong class="ih hj">地图操作符</strong>返回的每个用户的响应。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es li"><img src="../Images/f35048f804fa49475e95386dc031de5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*he42wptbUE0QsMycVb1Mhg.png"/></div></div></figure><p id="2eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API调用失败怎么办？执行<strong class="ih hj"> catchError </strong>操作符，首先将Error对象传递给<strong class="ih hj"> error$ subject </strong>。我们在模板中订阅这个主题来显示所有的错误。</p><p id="e799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何将错误对象列表连接成数组格式？我们通过管道将<strong class="ih hj"> RXJS扫描操作符</strong>传递给下面的<strong class="ih hj"> error$ subject </strong>来实现这一点。</p><pre class="kl km kn ko fd kx ky kz la aw lb bi"><span id="fe2b" class="lc ld hi ky b fi le lf l lg lh">public <strong class="ky hj">errorObservable$</strong> = <strong class="ky hj">this.error$.asObservable()</strong><br/>.pipe(<strong class="ky hj">scan((acc, curr) =&gt; (acc = acc.concat(curr)), [])</strong>);</span></pre><p id="a751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还使用运算符的<strong class="ih hj">将错误的可观察对象映射为成功的可观察对象，以防止<strong class="ih hj"> forkJoin </strong>返回的可观察对象出错。这个成功的可观测值将发出空值。</strong></p><p id="53e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，在<strong class="ih hj"> fetch() </strong>中，我们有另一个<strong class="ih hj">映射操作符</strong>，它直接通过管道传递给由<strong class="ih hj"> forkJoin操作符</strong>返回的可观察对象。在<strong class="ih hj">映射操作符</strong>中，我们从<strong class="ih hj"> forkJoin </strong>操作符得到如下最终结果，该操作符是一个包含所有用户数据的对象。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es li"><img src="../Images/651f18e6d93436c3d548ef7b5b43937c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPip1do-HGzqHeIVvn0zbw.png"/></div></div></figure><p id="9770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">观察到属性<strong class="ih hj">五十和十一</strong>包含<strong class="ih hj"> null。</strong>这是因为我们已经在<strong class="ih hj"> catchError </strong>操作符内部完成了error= &gt;成功的可观测映射。</p><p id="6148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经使用<strong class="ih hj"> Object.values()将对象转换为数组</strong>。该数组仅包含对象中属性的值。当在模板中订阅时，<strong class="ih hj"> data$ observable </strong>将发出这个数组。</p><p id="ad18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面找到完整的工作示例。</p><div class="jd je ez fb jf jg"><a href="https://stackblitz.com/edit/angular-qktmqq?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">角形(叉形)堆叠</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">stackblitz.com</p></div></div><div class="jp l"><div class="lj l jr js jt jp ju jv jg"/></div></div></a></div></div></div>    
</body>
</html>
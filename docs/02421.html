<html>
<head>
<title>How to Make a Modular App on WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在WebSockets上做一个模块化的App</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-make-modular-app-on-websockets-c2535655dbe0?source=collection_archive---------25-----------------------#2021-05-14">https://medium.com/geekculture/how-to-make-modular-app-on-websockets-c2535655dbe0?source=collection_archive---------25-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/04579034de08d64484955315cdc97874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dfhkSQAqgfwpBCzg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="39cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的一个项目中，我们在套接字上使用了IPC(进程间通信)。一个相当大的项目，一个交易机器人，其中有许多模块相互作用。随着复杂性的增加，监控微服务中发生的事情也变得越来越重要。我们决定创建自己的应用程序来跟踪两个库上的数据流<a class="ae iu" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae iu" href="https://github.com/rubender/redoor" rel="noopener ugc nofollow" target="_blank">redor</a>。我想与您分享我们的方法。</p><p id="b5fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">微服务用两个字段交换JSON对象:名称和数据。名称是对象打算用于哪个服务的标识符和数据-有效载荷字段。示例:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="915a" class="kc kd hi jy b fi ke kf l kg kh">{ name:'ticket_delete', data:{id:1} }</span></pre><p id="5fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为服务是非常原始的，协议每周都在改变，所以监控应该尽可能简单和模块化。因此，在应用程序中，每个模块都应该显示针对它的数据，因此通过添加或删除数据，我们应该获得一组独立的模块来监控微服务中的流程。</p><p id="f8a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始吧。例如，让我们制作一个简单的应用程序和一个web服务器。该应用程序将由三个模块组成。在图中，它们用虚线表示。计时器、统计和统计控制按钮。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/5660981baa97d9499f176e1641cb10f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*mKqXhLqpcN5hn5E3S9779w.png"/></div></figure><p id="fc49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个简单的WebSocket服务器。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c01d" class="kc kd hi jy b fi ke kf l kg kh">/** src/ws_server/echo_server.js */<br/><br/>const WebSocket = require('ws');<br/>const wss = new WebSocket.Server({ port: 8888 });<br/><br/>function sendToAll( data) {<br/>  let str = JSON.stringify(data);<br/>  wss.clients.forEach(function each(client) {<br/>    client.send(str);<br/>  });<br/>}<br/><br/>// <!-- -->Sending data every second<br/>setInterval(e=&gt;{<br/>  let d = new Date();<br/>  let H = d.getHours();<br/>  let m = ('0'+d.getMinutes()).substr(-2);<br/>  let s = ('0'+d.getSeconds()).substr(-2);<br/>  let time_str = `${H}:${m}:${s}`;<br/>  sendToAll({name:'timer', data:{time_str}});<br/>},1000);</span></pre><p id="7d28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器每秒生成一个日期字符串，并将其发送给所有连接的客户端。打开控制台并启动服务器:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="29e1" class="kc kd hi jy b fi ke kf l kg kh"># node src/ws_server/echo_server.js</span></pre><p id="e291" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们转到应用程序项目。对于构建和调试，我们将使用下面的汇总配置。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="31c2" class="kc kd hi jy b fi ke kf l kg kh">import serve from 'rollup-plugin-serve';<br/>import babel from '@rollup/plugin-babel';<br/>import { nodeResolve } from '@rollup/plugin-node-resolve';<br/>import commonjs from '@rollup/plugin-commonjs';<br/>import hmr from 'rollup-plugin-hot'<br/>import postcss from 'rollup-plugin-postcss';<br/>import autoprefixer from 'autoprefixer'<br/>import replace from '@rollup/plugin-replace';<br/><br/>const browsers = [  "last 2 years",  "&gt; 0.1%",  "not dead"]<br/><br/>let is_production = process.env.BUILD === 'production';<br/><br/>const replace_cfg = {<br/>  'process.env.NODE_ENV': JSON.stringify( is_production ? 'production' : 'development' ),<br/>  preventAssignment:false,<br/>}<br/><br/>const babel_cfg = {<br/>    babelrc: false,<br/>    presets: [<br/>      [<br/>        "@babel/preset-env",<br/>        {<br/>          targets: {<br/>            browsers: browsers<br/>          },<br/>        }<br/>      ],<br/>      "@babel/preset-react"<br/>    ],<br/>    exclude: 'node_modules/**',<br/>    plugins: [<br/>      "@babel/plugin-proposal-class-properties",<br/>      ["@babel/plugin-transform-runtime", {<br/>         "regenerator": true<br/>      }],<br/>      [ "transform-react-jsx" ]<br/>    ],<br/>    babelHelpers: 'runtime'<br/>}<br/><br/><br/>const cfg = {<br/>  input: [<br/>    'src/main.js',<br/>  ],<br/>  output: {<br/>    dir:'dist',<br/>    format: 'iife',<br/>    sourcemap: true,<br/>    exports: 'named',<br/>  },<br/>  inlineDynamicImports: true,<br/>  plugins: [<br/>    replace(replace_cfg),<br/>    babel(babel_cfg),<br/>    postcss({<br/>      plugins: [<br/>        autoprefixer({<br/>          overrideBrowserslist: browsers<br/>        }),<br/>      ]<br/>    }),<br/>    commonjs({<br/>        sourceMap: true,<br/>    }),<br/>    nodeResolve({<br/>        browser: true,<br/>        jsnext: true,<br/>        module: false,<br/>    }),<br/>    serve({<br/>      open: false,<br/>      host: 'localhost',<br/>      port: 3000,<br/>    }),<br/>  ],<br/>} ;<br/><br/><br/>export default cfg;</span></pre><p id="ac0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们项目的入口点是main.js，让我们创建它。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2727" class="kc kd hi jy b fi ke kf l kg kh">/** src/main.js */<br/>import React, { createElement, Component, createContext } from 'react';<br/>import ReactDOM from 'react-dom';<br/>import {Connect, Provider} from './store'<br/>import Timer from './Timer/Timer'<br/><br/>const Main = () =&gt; (<br/>  &lt;Provider&gt;<br/>    &lt;h1&gt;ws stats&lt;/h1&gt;<br/>    &lt;Timer/&gt;<br/>  &lt;/Provider&gt;<br/>);<br/>const root = document.body.appendChild(document.createElement("DIV"));<br/>ReactDOM.render(&lt;Main /&gt;, root);</span></pre><p id="af39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们为我们的项目创建一个redoor商店</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ccda" class="kc kd hi jy b fi ke kf l kg kh">/** src/store.js */<br/>import React, { createElement, Component, createContext } from 'react';<br/>import createStoreFactory from 'redoor';<br/>import * as actionsWS from './actionsWS'<br/>import * as actionsTimer from './Timer/actionsTimer'<br/><br/>const createStore = createStoreFactory({Component, createContext, createElement});<br/>const { Provider, Connect } = createStore(<br/>  [<br/>    actionsWS,     // websocket actions<br/>    actionsTimer,  // Timer actions<br/>  ]<br/>);<br/>export { Provider, Connect };</span></pre><p id="809f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在创建计时器模块之前，我们需要从服务器获取数据。让我们创建一个操作文件来使用套接字。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5687" class="kc kd hi jy b fi ke kf l kg kh">/** src/actionsWS.js */<br/>export const  __module_name = 'actionsWS'<br/>let __emit;<br/>// getting emit function from redoor<br/>export const bindStateMethods = (getState, setState, emit) =&gt; {<br/>  __emit = emit<br/>};<br/>// connect to server<br/>let wss = new WebSocket('ws://localhost:8888')<br/>// <!-- -->we receive all messages from the server and send them to the redoor stream<br/>wss.onmessage = (msg) =&gt; {<br/>  let d = JSON.parse(msg.data);<br/>  __emit(d.name, d.data);<br/>}</span></pre><p id="c457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有必要更详细地说明一下。我们的服务以带有字段的对象形式发送数据:名称和数据。在redoor库中，您还可以创建事件流，我们只需向其传递数据和名称。它看起来像这样:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f9fb" class="kc kd hi jy b fi ke kf l kg kh">+------+    <br/>| emit | --- events --+------------+----- ... --------+-----&gt;<br/>+------+              |            |                  |<br/>                      v            v                  v<br/>                 +----------+   +----------+     +----------+<br/>                 | actions1 |   | actions2 | ... | actionsN |<br/>                 +----------+   +----------+     +----------+</span></pre><p id="71bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，每个模块都有能力“监听”自己的事件，如果有必要，还可以监听其他动作事件。</p><p id="75d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们创建定时器模块本身。在“Timer”文件夹中，创建两个文件“Timer.js”和“actionsTimer.js”</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2028" class="kc kd hi jy b fi ke kf l kg kh">/** src/Timer/Timer.js */<br/><br/>import React from 'react';<br/>import {Connect} from '../store'<br/>import s from './Timer.module.css'<br/><br/>const Timer = ({timer_str}) =&gt; &lt;div className={s.root}&gt;<br/>  {timer_str}<br/>&lt;/div&gt;<br/><br/>export default Connect(Timer);</span></pre><p id="3ed4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里一切都很简单，计时器从全局状态“timer_str”中获取，该状态在“actionsTimer.js”中更新。“连接”功能将模块连接到redoor。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0ab3" class="kc kd hi jy b fi ke kf l kg kh">/** src/Timer/actionsTimer.js */<br/>export const  __module_name = 'actionsTimer'<br/>let __setState;<br/><br/>// <!-- -->getting a method for <!-- -->setState<br/>export const bindStateMethods = (getState, setState) =&gt; {<br/>  __setState = setState;<br/>};<br/><br/>// <!-- -->initialize the timer variable<br/>export const initState = {<br/>  timer_str:''<br/>}<br/><br/>// "listen" stream for "timer" event<br/>export const listen = (name,data) =&gt;{<br/>  name === 'timer' &amp;&amp; updateTimer(data);<br/>}<br/>// обновляем стейт <br/>function updateTimer(data) {<br/>  __setState({timer_str:data.time_str})<br/>}</span></pre><p id="8acc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在actions文件中，我们“监听”计时器的“timer”事件(函数“listen”)，一旦收到，我们就更新状态并输出一个包含数据的字符串。</p><p id="0ee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">了解更多有关redoor功能的信息:</p><p id="f46f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“_ _ module _ name”——调试时需要一个保留变量，它告诉我们动作包含在哪个模块中。</p><p id="dbf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“bindStateMethods”是一个获取setState的函数，因为数据是异步的，所以我们需要在局部变量中获取状态更新函数。</p><p id="0b5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“initState”——用于初始化模块数据的函数或对象，在我们的例子中，这是timer_str</p><p id="8ffd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“listen”——接收redoor生成的所有事件的函数。</p><p id="c86e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成了。运行编译并在“<a class="ae iu" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>打开浏览器</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="738c" class="kc kd hi jy b fi ke kf l kg kh"># npx rollup -c rollup.config.js --watch</span></pre><p id="4712" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应该会出现一个时钟。让我们转到一个更复杂的问题。与计时器类似，我们将添加另一个统计模块。首先，向“echo_server.js”添加一个新的数据生成器</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="389a" class="kc kd hi jy b fi ke kf l kg kh">/** src/ws_server/echo_server.js */<br/><br/>...<br/>let g_interval = 1;<br/>// Stats data<br/>setInterval(e=&gt;{<br/>  let stats_array = [];<br/>  for(let i=0;i&lt;30;i++) {<br/>    stats_array.push((Math.random()*(i*g_interval))|0);<br/>  }<br/>  let data  = {<br/>    stats_array<br/>  }<br/>  sendToAll({name:'stats', data});<br/>},500);<br/><br/>...</span></pre><p id="cdff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并将该模块添加到项目中。为此，创建一个“Stats”文件夹，我们在其中创建“Stats.js”和“actionsStats.js”</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="aefc" class="kc kd hi jy b fi ke kf l kg kh">/** src/Stats/Stats.js */<br/>import React from 'react';<br/>import {Connect} from '../store'<br/>import s from './Stats.module.css'<br/><br/>const Bar = ({h})=&gt;&lt;div className={s.bar} style={{height:`${h}`px}}&gt;<br/>  {h}<br/>&lt;/div&gt;<br/><br/>const Stats = ({stats_array})=&gt;&lt;div className={s.root}&gt;<br/>  &lt;div className={s.bars}&gt;<br/>    {stats_array.map((it,v)=&gt;&lt;Bar key={v} h={it} /&gt;)}<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/><br/>export default Connect(Stats);</span></pre><p id="34fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2b82" class="kc kd hi jy b fi ke kf l kg kh">/** src/Stats/actionsStats.js */<br/>export const  __module_name = 'actionsStats'<br/>let __setState = null;<br/><br/>export const bindStateMethods = (getState, setState, emit) =&gt; {<br/>  __setState = setState;<br/>}<br/><br/>export const initState = {<br/>  stats_array:[],<br/>}<br/><br/>export const listen = (name,data) =&gt;{<br/>  name === 'stats' &amp;&amp; updateStats(data);<br/>}<br/><br/>function updateStats(data) {<br/>  __setState({<br/>    stats_array:data.stats_array,<br/>  })<br/>}</span></pre><p id="2d39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将新模块连接到redoor存储</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f25c" class="kc kd hi jy b fi ke kf l kg kh">/** src/store.js */<br/>...<br/>import * as actionsStats from './Stats/actionsStats'<br/><br/>const { Provider, Connect } = createStore(<br/>  [<br/>    actionsWS,<br/>    actionsTimer,<br/>    actionsStats //&lt;-- module Stats<br/>  ]<br/>);<br/>...</span></pre><p id="42a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该得到这个:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/b591e06b6647bbe219a2d169e14693e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*uEmFmj-7PCF-c0Q3P-zGbg.png"/></div></figure><p id="3c5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，Stats模块与Timer模块没有本质上的区别，只是显示的不是字符串，而是数据数组。如果我们不仅要接收数据，还要将数据发送到服务器，该怎么办？添加统计管理。</p><p id="c7b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，变量g_interval是随机变量归一化的角斜率。让我们尝试从我们的应用程序管理它。</p><p id="44ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们给stats模块添加几个按钮。正值会增加区间值，负值会减少。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7384" class="kc kd hi jy b fi ke kf l kg kh">/** src/Stats/Stats.js */<br/>...<br/>import Buttons from './Buttons' <br/>...<br/>const Stats = ({cxRun, stats_array})=&gt;&lt;div className={s.root}&gt;<br/>  &lt;div className={s.bars}&gt;<br/>    {stats_array.map((it,v)=&gt;&lt;Bar key={v} h={it} /&gt;)}<br/>  &lt;/div&gt;<br/>  &lt;Buttons/&gt; {/* &lt;- new module */}<br/>&lt;/div&gt;<br/>...</span></pre><p id="6a31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和带有按钮的模块本身</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a91f" class="kc kd hi jy b fi ke kf l kg kh">/** src/Stats/Buttons.js */<br/>import React from 'react';<br/>import {Connect} from '../store'<br/>import s from './Stats.module.css'<br/><br/>const DATA_INTERVAL_PLUS = {<br/>  name:'change_interval',<br/>  interval:1<br/>}<br/>const DATA_INTERVAL_MINUS = {<br/>  name:'change_interval',<br/>  interval:-1<br/>}<br/><br/>const Buttons = ({cxEmit, interval})=&gt;&lt;div className={s.root}&gt;<br/>  &lt;div className={s.btns}&gt;<br/>      &lt;button onClick={e=&gt;cxEmit('ws_send',DATA_INTERVAL_PLUS)}&gt;<br/>        plus<br/>      &lt;/button&gt;<br/><br/>      &lt;div className={s.len}&gt;interval:{interval}&lt;/div&gt;<br/><br/>      &lt;button onClick={e=&gt;cxEmit('ws_send',DATA_INTERVAL_MINUS)}&gt;<br/>        minus<br/>      &lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/><br/>export default Connect(Buttons);</span></pre><p id="dbde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有一个带按钮的面板:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/96a7d3412bbf3b80fcccc0fda200724c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*PSeHof5Ny4JL2JMcKf7MHA.png"/></div></figure><p id="9f72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并修改它actionsWS.js</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a3da" class="kc kd hi jy b fi ke kf l kg kh">/** src/actionsWS.js */<br/>...<br/><br/>let wss = new WebSocket('ws://localhost:8888')<br/><br/>wss.onmessage = (msg) =&gt; {<br/>  let d = JSON.parse(msg.data);<br/>  __emit(d.name, d.data);<br/>}<br/><br/>// <!-- -->"listening" to the event send data to the server<br/>export const listen = (name,data) =&gt; {<br/>  name === 'ws_send' &amp;&amp; sendMsg(data);<br/>}<br/>// отправляем данные<br/>function sendMsg(msg) {<br/>  wss.send(JSON.stringify(msg))<br/>}</span></pre><p id="098d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们在Buttons.js模块中利用了在redoor库中创建事件的内置函数(cxEmit)。模块“actionsWS.js”“监听”事件ws_send。数据有效负载是两个对象:“DATA_INTERVAL_PLUS”和“DATA_INTERVAL_MINUS”。对于该实例，如果您单击加号按钮，应用程序将向服务器发送对象:</p><p id="58a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">{名称:'更改时间间隔'，时间间隔:1 }</p><p id="4da4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在服务器上，我们添加</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e911" class="kc kd hi jy b fi ke kf l kg kh">/** src/ws_server/echo_server.js */<br/>...<br/><br/>wss.on('connection', function onConnect(ws) {<br/>  // <!-- -->"listening" to the app for the "change_interval" event"<br/>  // from Buttons.js<br/>  ws.on('message', function incoming(data) {<br/>    let d = JSON.parse(data);<br/>    d.name === 'change_interval' &amp;&amp; change_interval(d);<br/>  });<br/>});<br/><br/>let g_interval = 1;<br/>// change interval<br/>function change_interval(data) {<br/>  g_interval += data.interval;<br/>  // send new event interval_changed<br/>  sendToAll({name:'interval_changed', data:{interval:g_interval}});<br/>}<br/><br/>...</span></pre><p id="ee4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而最后的触动就是在“Buttons.js”模块中反映音程的变化。为此，请转到“actionsStats.js”让我们开始监听“interval_changed”事件，并更新interval变量</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a933" class="kc kd hi jy b fi ke kf l kg kh">/** src/Stats/actionsStats.js */<br/>...<br/><br/>export const initState = {<br/>  stats_array:[],<br/>  interval:1 // add new var interval<br/>}<br/><br/>export const listen = (name,data) =&gt;{<br/>  name === 'stats' &amp;&amp; updateStats(data);<br/>  <br/>  // <!-- -->"listening" for the interval update event<br/>  name === 'interval_changed' &amp;&amp; updateInterval(data);<br/>}<br/>// update<!-- --> the interval<br/>function updateInterval(data) {<br/>  __setState({<br/>    interval:data.interval,<br/>  })<br/>}<br/><br/>function updateStats(data) {<br/>  __setState({<br/>    stats_array:data.stats_array,<br/>  })<br/>}</span></pre><p id="16b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们有三个独立的模块，其中每个模块只监视自己的事件并只显示它。当结构和协议在原型阶段还不完全清楚时，这是非常方便的。我们只需要补充一点，因为所有的事件都有一个交叉的结构，所以我们必须明确遵循创建事件的模板。我们给自己选了这个:(莫德伦·AME)_(函数名)_(变量名)。</p><p id="9205" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望它有帮助。和往常一样，该项目的源代码在<a class="ae iu" href="https://github.com/rubender/react_redoor_ws_example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><p id="8c31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kl">更多内容尽在</em><a class="ae iu" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kl">plain English . io</em></a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Multi-Broker Insights into Apache Kafka Cluster Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Kafka集群架构的多代理洞察</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/multi-broker-insights-into-apache-kafka-cluster-architecture-617b0abfc53e?source=collection_archive---------1-----------------------#2021-07-19">https://medium.com/geekculture/multi-broker-insights-into-apache-kafka-cluster-architecture-617b0abfc53e?source=collection_archive---------1-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4833" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">发布-订阅消息传递系统模式:主题持久性</h2><div class=""/><div class=""><h2 id="b8d9" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">将卡夫卡与Spring Boot集成+卡夫卡模板+消息驱动的POJO卡夫卡监听器</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/fe819ee32fad5978bee4403bc5095a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UyrLhtJLwIXgEtDwsa-I7A.gif"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Apache Kafka, Multi-Broker Architecture</figcaption></figure><h1 id="ddf9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">范围</h1><p id="b5f1" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">本文旨在帮助初学者和中级读者理解和学习Apache Kafka消息传递模式。它从专门为本文创建的动手项目中进行解释，涵盖了以下术语:<br/> a. Kafka集群、代理、主题、分区<br/> b .领导者、跟随者、ISR(同步副本)、Zookeeper <br/> c .生产者、消息键、消费者、消费者群体<br/> d .使用Spring boot堆栈在集群架构中实现单节点多代理<br/> e .创建主题<br/>实现代码可在<a class="ae lk" href="https://github.com/ganesh-nag/Apache-Kafka" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中查看。</p><h1 id="a12b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">先决条件</h1><p id="7e32" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">a.卡夫卡_ 2.13–2 . 8 . 0<br/>b .弹簧靴</p><h1 id="3013" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">术语，一瞥</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ll"><img src="../Images/1a3a60009e9bf6727796f5a071c7de00.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*CF3CfWK1Nu6LB6oBR4JpsA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Terminology ???</figcaption></figure><h2 id="f601" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">Kafka集群、代理、主题、分区</h2><p id="859f" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">A <strong class="kq hs"> B </strong> roker是一个容纳几个具有多个<strong class="kq hs"> P </strong>分区的<strong class="kq hs"> T </strong> opic的容器。<br/>一个<strong class="kq hs"> K </strong> afka集群由一个或多个被称为<em class="lz">代理</em>或<em class="lz"> Kafka代理</em>或<em class="lz">引导服务器</em>的服务器组成。与任何一个代理的连接意味着与整个集群的连接。<br/> <strong class="kq hs">让我们看一个例子来理解:- <br/> </strong>比方说，一个卡夫卡集群<strong class="kq hs"> </strong>由3个经纪人组成。每个经纪人都有一个以<strong class="kq hs"><em class="lz">【0】</em></strong>(<strong class="kq hs"><em class="lz">零</em> </strong>)开头的<strong class="kq hs"> <em class="lz"> id </em> </strong>。<em class="lz">经纪人0，经纪人1，经纪人2 </em>。<br/>每个经纪人持有一个主题，假设<strong class="kq hs"> <em class="lz">主题A </em> </strong>有3个分区。每个<strong class="kq hs"> <em class="lz">分区</em> </strong>都有一个以<strong class="kq hs"> <em class="lz"> 0(零)</em> </strong>开头的编号。<em class="lz">分区0，分区1，分区2 </em>。<br/>所有分区不属于单个代理，而是分布在每个代理中。<br/>经纪人号(<strong class="kq hs"> <em class="lz"> id </em> </strong>)和分区号之间没有关系。在Kafka中，每个代理都包含数据，如果代理失败，数据就会丢失。为了避免这种情况，Kafka提供了一个名为<strong class="kq hs">R</strong>replication(<strong class="kq hs"><em class="lz">Replicas</em></strong>)的特性来保护数据。复制因子是集群环境中多个代理上存储的数据副本的数量。这使得用户能够从另一个代理访问数据。</p><h2 id="1005" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">领导者、追随者、ISR(同步复制)、动物园管理员</h2><p id="84da" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated"><strong class="kq hs">让我们看一个例子来理解:- <br/> </strong>比方说<strong class="kq hs">，</strong>一个Kafka集群由3个经纪人组成，<em class="lz">经纪人0，经纪人1，经纪人2 </em>。<br/> <strong class="kq hs"> <em class="lz">题目A </em> </strong>拆分成复制因子为2的<em class="lz">分区0、分区1、分区2 </em>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ma"><img src="../Images/c1e44855d3913f68fbb0da6046602c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXaMMPmVpFFOKRUUdNtr6A.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Kafka Cluster Architecture</figcaption></figure><p id="a4ea" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">从上图中，我们可以看到<strong class="kq hs"> <em class="lz">分区0</em><em class="lz">【主题1】</em></strong>在<strong class="kq hs"><em class="lz">Broker 0</em><strong class="kq hs"><em class="lz">Broker 1中有其<strong class="kq hs"> <em class="lz">副本</em> </strong>。<br/>分区1 </em> </strong>的<strong class="kq hs"> <em class="lz">主题1 </em> </strong>在<strong class="kq hs"> <em class="lz">代理1 </em> </strong>和<strong class="kq hs"> <em class="lz">代理2中有其<strong class="kq hs"> <em class="lz">复制</em> </strong>。<br/><br/> </em> <strong class="kq hs"> <em class="lz">答案是</em> </strong> <em class="lz">，卡夫卡会选择其中一个经纪人分区作为</em> <strong class="kq hs"> <em class="lz"> L </em> </strong> <em class="lz">的盟主，其余的经纪人分区作为</em> <strong class="kq hs"> <em class="lz"> F </em> </strong> <em class="lz">的追随者。这里的</em><strong class="kq hs"><em class="lz">L</em></strong><em class="lz">eader被允许服务客户端请求，而</em><strong class="kq hs"><em class="lz">F</em></strong><em class="lz">followers被允许同步数据。<br/>这些副本被称为</em><strong class="kq hs"><em class="lz">ISR</em></strong><em class="lz">(</em><strong class="kq hs"><em class="lz">in-sync-replicas</em></strong><em class="lz">)。</em>L</strong>头及其<strong class="kq hs"> F </strong>跟随者由<strong class="kq hs">管理员管理。<em class="lz"> <br/> </em> </strong>如果一个Leader分区的broker由于失败而无法服务请求，那么它的<strong class="kq hs"> <em class="lz"> ISR </em> </strong>中的一个将接管Leader来服务请求。在集群环境中，这提供了容错和负载平衡。</strong></p><h2 id="129f" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">生产者、消息密钥、消费者、消费者群体</h2><p id="eafe" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">A <strong class="kq hs"> P </strong> roducer向Kafka Topic发布数据。生产者可以选择使用<strong class="kq hs"> M </strong>消息键将数据发送到特定的分区。如果生产者希望发送没有密钥数据，则数据以循环方式发送到任何分区。<br/>报文密钥可以是字符串，也可以是带分隔符(<strong class="kq hs"> <em class="lz"> key.separator </em> </strong>)的数字，以及实际要发送的数据。<br/> <strong class="kq hs"> <em class="lz">例如:-</em></strong><br/><strong class="kq hs"><em class="lz">A</em></strong>为<em class="lz">键</em>，<strong class="kq hs"> <em class="lz"> - </em> </strong> ( <em class="lz">连字符</em>为<em class="lz">键，分隔符</em>，<strong class="kq hs"><em class="lz">message 1</em></strong><em class="lz"/>为数据。<br/><strong class="kq hs">A</strong>-<strong class="kq hs"><em class="lz">message 1</em></strong><br/>Kafka会对<strong class="kq hs"><em class="lz"/></strong>键执行<strong class="kq hs"> <em class="lz">哈希</em> </strong>，并确定存储数据的分区。如果相同的密钥与不同的数据一起传递，数据将根据之前执行的密钥哈希被发送到相同的分区。</p><p id="f6c4" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">A <strong class="kq hs"> C </strong> onsumer使用Kafka集群中的数据。当多个消费者订阅一个主题并属于同一个消费者组时，该组中的每个消费者将从不同的分区接收消息。<br/>在Kafka中，为了可伸缩性和容错性，每个消费者组由许多消费者实例组成。如果所有的消费者实例都有相同的消费者组，那么记录将有效地在消费者实例之间进行负载平衡。</p><p id="f78d" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated"><strong class="kq hs">让我们理解一下，如何在一个消费者群体中的多个消费者之间分配主题分区？</strong></p><p id="45a2" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">比方说，我们有三个主题分区，我们为同一个主题启动三个消费者，然后每个消费者自动分配一个分区。</p><p id="82f6" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated"><em class="lz">比方说，我们有三个主题分区，我们为同一个主题启动两个消费者，然后一个消费者被分配一个分区，另一个被分配两个分区。</em></p><p id="5195" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated"><em class="lz">比方说，我们有三个主题分区，我们为同一个主题启动一个消费者，然后一个消费者被分配所有三个分区。</em></p><p id="f93a" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated"><em class="lz">比方说，我们有三个主题分区，我们为同一个主题启动了四个消费者，然后四个消费者中的三个被分配了一个分区，一个消费者将不会收到任何消息。</em></p><h2 id="e55b" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">使用Spring boot堆栈在集群架构中实现单节点多代理</h2><p id="c2b2" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">Spring Kafka带来了简单而典型的Spring模板编程模型，带有一个<strong class="kq hs"> <em class="lz"> KafkaTemplate </em> </strong>和<strong class="kq hs"> <em class="lz">消息驱动的POJO</em></strong>到<strong class="kq hs"> <em class="lz"> KafkaListener </em> </strong>注释。</p><h2 id="9786" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated"><strong class="ak"> <em class="mg">单节点-多代理配置</em> </strong></h2><p id="ae65" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">a.制作2份<strong class="kq hs"><em class="lz">server . properties</em></strong>并命名为<strong class="kq hs"><em class="lz">server-one . properties</em></strong>、<strong class="kq hs"><em class="lz">server-two . properties</em></strong>。<br/> b .默认情况下<strong class="kq hs"><em class="lz">server . properties</em></strong>将拥有<strong class="kq hs"> <em class="lz"> broker id 0 </em> </strong>并将指向<strong class="kq hs"> <em class="lz">端口9092 </em> </strong>。默认的日志文件名是<strong class="kq hs"> <em class="lz">【卡夫卡-日志】</em> </strong>。<br/> c .编辑<strong class="kq hs"><em class="lz">server-one . properties</em></strong>并提供<strong class="kq hs"> <em class="lz"> broker id </em> </strong>为<strong class="kq hs"> <em class="lz"> 1 </em> </strong>并点<strong class="kq hs"> <em class="lz"> port </em> </strong>到<strong class="kq hs"> <em class="lz"> 9093 </em> </strong>。请为日志提供不同的名称。<br/> d .编辑<strong class="kq hs"><em class="lz">server-two . properties</em></strong>并提供<strong class="kq hs"> <em class="lz"> broker id </em> </strong> as 2并点<strong class="kq hs"><em class="lz">port</em></strong>to<strong class="kq hs"><em class="lz">9094</em></strong>。请为日志提供不同的名称。</p><p id="b2a2" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">e.启动Zookeeper实例。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mh"><img src="../Images/232c406425ae68ecece389c558cd6b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MR7tYPqrPloNBb1HgQ0sSA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Zookeeper instance</figcaption></figure><p id="6abe" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">f.启动上面创建的Kafka broker的3个实例。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mi"><img src="../Images/936d261f2b195b352333cccd80336248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HD_zW3AI-AYh5EHgW6CSbA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Broker 0 — server.properties</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mj"><img src="../Images/257b443ee88879fdfa7b6c836ce77650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7QECF69Y5ZKOjjG6kaJRA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Broker 1 — server-one.properties</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mk"><img src="../Images/88dfafa4cdb42664af3821a88a909792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tG9Jv-nUrwWwUzpgeHme6g.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Broker 2 — server-two.properties</figcaption></figure><h2 id="d96b" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">创建主题</h2><p id="019e" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">Kafka-topics . bat-create-zookeeper localhost:2181-复制-因子3-分区1-主题多代理</p><h2 id="25e7" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">描述主题</h2><p id="89db" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">Kafka-topics . bat-describe-zookeeper localhost:2181-topic multi broker</p><h2 id="deb5" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">生成消息</h2><p id="251d" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">a.从浏览器向Kafka集群发送消息。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ml"><img src="../Images/6202c3e05e44e2f9caa94cf5366ad781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pcBIdehk8WK4jlGbPrwTg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Client sends message from Browser</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mm"><img src="../Images/73212bff70029443c1a46ca2bf477b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIE5CXY4CmA4OQAWob729A.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Message Producer in Spring boot</figcaption></figure><p id="5f26" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">b.Spring boot中的<strong class="kq hs"><em class="lz">KafkaTemplate</em></strong>将接收到该消息，并将该消息发送到下面<strong class="kq hs"><em class="lz">application . yml</em></strong>中提到的<strong class="kq hs"> <em class="lz"> bootstrap服务器集群</em> </strong>。c .在如下所示的配置文件中，代理列表以逗号分隔值的形式出现，以确保如果任何一个代理关闭，另一个代理应该能够完成客户端请求。<br/>d .<strong class="kq hs"><em class="lz">KafkaListener</em></strong>将读取来自<strong class="kq hs"> <em class="lz">主题</em> </strong>的消息，并在控制台中高亮显示该消息。使用者属于配置文件中显示的使用者组。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mn"><img src="../Images/617bfa8d8fbf7873d627146f7c716542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oL0s38Zj7MjDZCTArPssVg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Message Consumer in Spring boot</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mo"><img src="../Images/3e4407c8b33a8d1cfad16fdaeb61f896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1DEC_B1W1hZwzljYpbvpQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Bootstrap servers configuration and console output</figcaption></figure><p id="5f37" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated">让我们关闭Broker 2，看看集群和负载平衡在Kafka中是如何工作的。 <br/> 从下面的截图输出可以看到，<strong class="kq hs"> <em class="lz"> Broker 2 </em> </strong>关闭，发布的新消息由<strong class="kq hs"> <em class="lz"> Broker 0 </em> </strong>或<strong class="kq hs"> <em class="lz"> Broker 1 </em> </strong>中的一个处理。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mp"><img src="../Images/1b80686ead2d5ea13302d36d3b9c572a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlSGURfhBn9xIfDIxCL-fQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Broker 2 shutdown</figcaption></figure><h1 id="c91d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">结论</h1><p id="3c76" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">这篇文章解释了卡夫卡建筑和它的各种术语。它显示了一个<strong class="kq hs"> <em class="lz">单节点多代理</em> </strong>配置来产生和消费消息。我们创建了<strong class="kq hs"> <em class="lz">主题</em> </strong>，并在<strong class="kq hs"> <em class="lz">弹簧启动堆栈</em> </strong>的帮助下，我们运行了一些实时代码，并看到了关于<strong class="kq hs"> <em class="lz">集群</em> </strong>和<strong class="kq hs"> <em class="lz">负载平衡</em> </strong>的输出。</p><p id="147c" class="pw-post-body-paragraph ko kp hi kq b kr mb is kt ku mc iv kw kx md kz la lb me ld le lf mf lh li lj hb bi translated"><strong class="kq hs"> <em class="lz">发表于2021年7月19日</em> </strong></p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><blockquote class="mx my mz"><p id="d72a" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><strong class="kq hs"> <em class="hi">其他中等文章，</em>由<em class="hi">加内什</em> </strong>撰写</p><p id="5532" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" rel="noopener" href="/geekculture/quest-syntax-tree-and-remedy-code-smell-using-japa-visitor-patterns-f023a89842cf"> <em class="hi">探寻语法树并补救代码气味使用JAPA</em></a>访问者模式</p><p id="f679" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" rel="noopener" href="/nerd-for-tech/asynchronous-websocket-messaging-middleware-and-microservices-1a50a8f14e4b"> <em class="hi">异步WebSocket消息中间件和微服务</em> </a></p><p id="870e" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" rel="noopener" href="/geekculture/amalgamate-angular-with-spring-cloud-architecture-through-cors-7f13b5fdb98f"> <em class="hi">通过CORS </em> </a>融合棱角与春云建筑</p><p id="b953" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/remote-queue-definition-ibm-mq-v9-2-c3ec4f568dab?source=user_profile---------5----------------------------" rel="noopener">远程队列定义:IBM MQ v9.2 </a></p><p id="306f" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/kubernetes-pods-docker-containers-spin-vm-using-virtual-box-in-windows-10-home-d3be783ff087?source=user_profile---------0----------------------------" rel="noopener">Kubernetes Pods&amp;Docker Containers:在Windows 10 Home中使用虚拟盒子旋转虚拟机</a></p><p id="e261" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/federate-okta-idp-wso2-api-manager-as-gateway-to-spring-boot-microservices-integration-ba567567e81?source=user_profile---------1----------------------------" rel="noopener">联合OKTA IdP + WSO2 API管理器作为Spring boot微服务集成的网关</a></p><p id="03f5" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/integrate-ibm-business-process-manager-with-hybrid-mobilefirst-application-5aed20841bf3?source=user_profile---------2----------------------------" rel="noopener">将IBM业务流程管理器与混合MobileFirst应用程序集成</a></p><p id="911e" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/kerberos-v5-sso-authentication-in-windows-10-home-using-apache-directory-studio-fb0151899185?source=user_profile---------3----------------------------" rel="noopener"> Kerberos v5:使用Apache directory studio在Windows 10 Home中进行SSO认证</a></p><p id="f10c" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/integrate-service-providers-sps-with-okta-identity-provider-idp-ce64a4e262ae?source=user_profile---------4----------------------------" rel="noopener">整合服务提供商(sp)和OKTA身份提供商(IdP) </a></p><p id="32e6" class="ko kp lz kq b kr mb is kt ku mc iv kw na md kz la nb me ld le nc mf lh li lj hb bi translated"><a class="ae lk" href="https://ganeshblog.medium.com/integrate-ibm-websphere-service-registry-and-repository-with-ibm-process-server-f97eeb0e2ea?source=user_profile---------6----------------------------" rel="noopener">将IBM WebSphere Service Registry and Repository与IBM Process Server集成</a></p></blockquote></div></div>    
</body>
</html>
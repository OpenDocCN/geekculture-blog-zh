<html>
<head>
<title>Cryptographic Hash Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密哈希函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cryptographic-hash-functions-174875f73338?source=collection_archive---------18-----------------------#2022-02-15">https://medium.com/geekculture/cryptographic-hash-functions-174875f73338?source=collection_archive---------18-----------------------#2022-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms" rel="noopener ugc nofollow" target="_blank">散列函数</a>是一组广泛的函数。有几种类型，有不同的用途，它们不一定都与密码学中的密码有关。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/07ea1a0e08f519c40b02d92c8f04ce1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ke7_lC67ZLjJTGWi"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae jd" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Towfiqu barbhuiya</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，作为一个快速的视觉演示，这是来自维基百科关于哈希函数的页面。如果您听说过计算机科学中的术语哈希表或哈希映射，它们与哈希函数有关，这是一个假设哈希函数的示例，它只是将一些输入字符串转换为从0到15的两位数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ju"><img src="../Images/667f610cd7659bd478df2303fd77fb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIPhAtbn6TwyKtRJKWFMnw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">By Jorge Stolfi — Own work, Public Domain, <a class="ae jd" href="https://commons.wikimedia.org/w/index.php?curid=6601264" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=6601264</a></figcaption></figure><p id="9471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常简单的版本，只有16个输出，它将被视为一个有效的散列函数。密码很简单，因为我们可能有成千上万不同的用户对他们的密码进行哈希运算。如果我们只有16种不同的输出，人们输入多少输入和不同的唯一密码都没有关系。对于一个人来说，一遍又一遍地猜测密码并不需要太多的努力。他们不必为某人的电子邮件获取正确的密码；他们只是必须得到一个恰好散列到同一个数字的密码。</p><p id="865a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，并不是每个哈希函数都适合存储密码。这些算法有一个特定的子集，通常指的是获取任意大小的输入并输出固定大小的输出。对于加密哈希函数，在这组加密哈希函数中，我们最关心的是密码哈希函数或密码安全哈希函数。</p><p id="be15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，我们需要的特征首先是一个不可逆转的单向函数。因此，作为单向函数的一个例子，让我们假设我们有“<em class="jv"> pass123 </em>”，我们得到一个散列输出，不管它是什么。但是，如果有人进入我的数据库，他们看到这个密码已经被散列，他们应该没有办法逆转它，并找出输入是什么。</p><p id="b865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个简单的例子。绝对值将接受一个正数并返回该正数，作为正数，它将接受一个负数并返回一个正数。所以，如果我有一个名为absolute的函数，在JavaScript中我们只有<em class="jv"> Math.abs() </em>。如果我在这里传递一个数字，我会把它变成一个变量。你不会知道它是什么，我会把它删掉。如果我调用变量x的<em class="jv"> Math.abs(x) </em>，假设我们得到10作为输出，但是你不能告诉我输入是什么。是10分还是负10分？只有两个选择，但这是一个单向函数。你不能告诉我具体的输入是什么。恰好是负10，这就是单向函数的原理。</p><p id="6766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，<strong class="ih hj"> <em class="jv">“输入的微小变化会产生输出的巨大变化。”</em> </strong>所以，如果我们把“pass123”改成“pass 123”，那应该是输出中一个异常实质性的变化。我们应该看不出这两个密码是相似的。仅仅通过查看它们的散列输出。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ju"><img src="../Images/a024f87c057014b4835c52a011662707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zy0__ldOBwimOYMBp4F87w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">By User:Jorge Stolfi based on Image:Hash_function.svg by Helix84 — Original work for Wikipedia, Public Domain, <a class="ae jd" href="https://commons.wikimedia.org/w/index.php?curid=5290240" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=5290240</a></figcaption></figure><p id="070f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面有个例子。这是使用一种叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms" rel="noopener ugc nofollow" target="_blank">安全散列算法</a> (SHA)的散列函数。这是一个输入，它经过一些加密哈希函数，我们收到一个输出。举个例子，</p><p id="9594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jv">《赤狐跳过蓝狗》</em></p><p id="c373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后</p><p id="d413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jv">《赤狐跳过蓝狗》</em></p><p id="c682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<em class="jv">“v”</em>变成了<em class="jv">“u”</em>所以那里只是一个字符的变化，然后这里的输出就完全不同了。<em class="jv">它不像一对夫妇的性格；这完全不同。</em>我们不能看着它，想出任何关于原始输入的东西，这很重要。</p><p id="1a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个关键点是，它是确定性的。这只是意味着同样的输入总是给我们同样的输出，如果我们不能总是用同样的输入得到同样的输出，这将使我们所有的费力的工作都白费，并使整个目的落空。否则，恢复散列输出，然后再次散列，就会得到无法比较的结果。你必须承认相同的输入总是给你相同的输出。同样，我们得到两个相同值的输出是不太可能发生冲突的。这有点像，2⁸⁰中的一个，是1.2089258196146 x 10 ⁴，(这是一个巨大的数字)概率，会发生碰撞，得到两个相同的输出。</p><p id="c818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，慢功能最好。这需要时间，如果我们有一个快速哈希函数，人们就可以更容易地强行进入，尝试哈希一百万次或数十亿次不同的密码，并快速尝试不同的组合。但是如果我们使用一个故意慢的散列函数，就要花更长的时间。</p></div></div>    
</body>
</html>
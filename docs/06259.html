<html>
<head>
<title>SOLID - Design Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体设计原则</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solid-design-principles-ea0e24f60ca?source=collection_archive---------12-----------------------#2021-08-15">https://medium.com/geekculture/solid-design-principles-ea0e24f60ca?source=collection_archive---------12-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="97a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SOLID是一个首字母缩写词，用来代表由罗伯特·c·马丁(又名鲍勃叔叔)设计的5个设计原则，由软件工程师使用。固体，<strong class="ih hj"> S </strong>代表单一责任原则，<strong class="ih hj"> O </strong>代表开/闭原则，<strong class="ih hj"> L </strong>代表利斯科夫替代原则，<strong class="ih hj"> I </strong>代表接口分离原则，<strong class="ih hj"> I </strong>代表依赖倒置原则。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f00dfb0bf10ef57bb08b517e15c61fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tP8JF97UkH4fxnRPIsusGA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae jd" href="https://unsplash.com/@afgprogrammer" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> from <a class="ae jd" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6aef" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">单一责任原则</h1><p id="ad66" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">根据罗伯特·c·马丁的说法，“一个类应该有一个，而且只有一个改变的理由。”</p><p id="beb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，在面向对象中，类应该更有凝聚力。一个班应该专攻一件事/一个班应该只有一项工作。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/053cfbfab457db1f0f340c0234af6c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkmXKDPZ6BWw8p_qdIL7jg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Image show before &amp; after applying SRP</figcaption></figure><h1 id="9831" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">开闭原理</strong></h1><p id="d5ec" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">面向对象设计最重要的原则，<br/>“软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。”</p><p id="b3c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一原则的总体思想是编写能够在不改变现有代码的情况下添加新功能的代码。<br/>例如，当需要添加某些东西时，现有的、测试良好的类将需要修改。但是，改变类会导致问题或严重的错误。我们只是想扩展它，而不是改变类。</p><p id="ee67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过使用<strong class="ih hj">继承</strong>轻松实现。但是如果子类依赖于超类的实现细节，继承就会引入高耦合。所以这个原理可以定义为多态原理。</p><p id="fc67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，一家书店针对不同的图书类别提供折扣，作为一项新功能，他们需要在折扣列表中添加一个新类别。假设书店在以下几类商品上打折:<strong class="ih hj">生物</strong>，<strong class="ih hj">动物学</strong>。在新特性中，他们需要添加<strong class="ih hj">工程</strong>类别。</p><p id="b129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将我们的类定义如下，<br/> * Class <strong class="ih hj"> Discount </strong>处理与折扣相关的事情。<br/>* Class<strong class="ih hj">biology category</strong>和<strong class="ih hj"> ZoologyCategory </strong>为现有类别。<br/> * Class <strong class="ih hj">工程类别</strong>为新类别。</p><p id="6e13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在不考虑OC原则的情况下添加这个新类别</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ky"><img src="../Images/79eae890ce400e31fa9f63da2168790f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*0O4DuUIs1OQwRyOHxwoZyg.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Make the enhancement without considering OC Principle</figcaption></figure><p id="6ae7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能注意到上面的例子有OO设计问题，为了遵循OC原则，上面的设计应该使用最佳实践来实现。<em class="kz">仅供参考:改变设计不是这一原则的一部分。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/0918fe6102e1c1e4be8b3da8f21a224a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hj1sT2BjLeH9hNx98kL9Ow.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">After applying OC Principle</figcaption></figure><p id="4b7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照OC原则，我们应该只创建一个新的类，<strong class="ih hj">实现</strong>的<strong class="ih hj">BookDiscountCategory</strong><strong class="ih hj">接口</strong>。</p><h1 id="3f4d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">利斯科夫替代原理</h1><p id="c8aa" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">1987年，Barbara Liskov在她的会议主题“数据抽象”中介绍了Liskov替代原理。几年后，她与珍妮特·温(Jeanette Wing)发表了一篇论文，他们在文中将这一原则定义为:</p><p id="d207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“设<em class="kz">φ(x)</em>是关于类型<em class="kz"> T </em>的对象<em class="kz"> x </em>的一个可证性质。那么<em class="kz">φ(y)</em>对于类型<em class="kz"> S </em>的对象<em class="kz"> y </em>应该为真，其中<em class="kz"> S </em>是<em class="kz"> T </em>的子类型。</p><p id="9cfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有点令人困惑，让我用图表简化一下。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lb"><img src="../Images/6cdf04bc4148e3b1df119405620efdee.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*Q9UcX-0uJaUE5fnNzO-AIw.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Liskov Substitution Principle Visual explanation</figcaption></figure><p id="4d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据原理，一个超类的<strong class="ih hj">对象应该可以被它的子类的对象替换，而不会破坏应用</strong>。这要求你的子类的对象以和你的超类的对象相同的方式运行。</p><p id="19bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子——查看下图，在那里，子类不能做超类能做的所有事情。在下面的场景中，蜗牛是动物的一个子类，但蜗牛不会说话，这违反了这个原则。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lc"><img src="../Images/37c3eae71fddd3cb350848cacdc56b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*gDlBtdcBMF0SvjwCzsPs0w.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Demonstrating inheritance</figcaption></figure><p id="c850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决上述问题，<br/> 1)我们可以创建一个包含<strong class="ih hj"> speak </strong>的单独接口，并将其实现到必要的类中，比如Dog和Cat。<br/> 2)或者说，有时候构成比遗传更好。"比A更好"</p><h1 id="823e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">界面分离原理</h1><p id="2f2e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">"客户不应该被迫依赖他们不使用的接口."对于客户端，他指的是实现接口的类。简单地说，界面不应该包含太多的功能。违反接口分离原则会降低代码的可读性，并迫使程序员编写无用的方法。在一个设计良好的应用程序中，你应该避免接口污染(也就是胖接口)。解决方案是创建更小的接口，以便更灵活地实现。</p><p id="0b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子—</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/74191285e4c866faab0aa5d4ec0eb7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awAoYd1YVFzMyXpvCmrvSA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Before and after ISP applying</figcaption></figure><h1 id="a765" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">从属倒置原则</h1><p id="59f8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">依赖性反转原则的目标是避免紧密耦合的代码，因为它很容易破坏应用程序。</p><p id="5ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“高层模块不应该依赖低层模块。两者都应该依赖于抽象。”</p><p id="c0e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“抽象不应该依赖于细节。细节应该依赖于抽象。”</p><p id="65a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数人希望高级类依赖于低级类(比如实用程序类)。但是，根据依赖倒置原则，我们需要倒置依赖。否则，当低级类被替换时，高级类也会受到影响。</p><p id="3dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为解决方案，我们需要为低级类创建一个抽象层，这样高级类就可以依赖于抽象而不是具体的实现。</p><p id="2c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">罗伯特·C·马丁提到<strong class="ih hj">依存倒置原则</strong>是<strong class="ih hj">开/闭</strong>和<strong class="ih hj">利斯科夫替代原则</strong>的具体组合。</p><p id="14c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子—</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/08d61776813095a07532491d3cd6e06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiXMFHosXG3m5sIyRXkWJQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Before and After applying DIP</figcaption></figure><p id="866e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这些，希望以上能帮助你理解扎实的设计原则。如果你没有得到上述原则，我建议你读几遍，直到你熟悉它。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Prim’s (MST): Special Subtree, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">prim(MST):特殊子树，已解释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/prims-mst-special-subtree-explained-736307b8d822?source=collection_archive---------13-----------------------#2022-12-13">https://medium.com/geekculture/prims-mst-special-subtree-explained-736307b8d822?source=collection_archive---------13-----------------------#2022-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ae9e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Java解释的Prim算法(最小生成树)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e00d89caa845e237732e975a2b0ef3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*APT5o_zzj_uzXXZM"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="467d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Prim的算法</a>很经典。你可以从维基链接了解它的历史和算法。但是理解和实现起来并不简单。这里将用Java实现它，以便于理解。</p><p id="c212" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Prim的算法可以从任意顶点开始。我们可以从一个特定的顶点开始寻找所有顶点的最小总距离。有两种常见的方法:1 .从最小距离开始扩展，一次一个或2个。一次从一个未访问的顶点开始探索。因此，我们可以看到，最小堆是构造边的一个很好的解决方案。这里用HackerRank难题来说明这一点。</p><h2 id="361a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题</h2><p id="7732" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">给定一个由连接其节点的几条边组成的图，找出给定图的一个具有以下性质的子图:</p><ul class=""><li id="31b9" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">子图包含原始图中存在的所有节点。</li><li id="8cd7" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">在所有这样的子图中，该子图具有最小的总权重(所有边的和)。</li><li id="4a62" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">还要求子图的任意两个节点之间有<strong class="jq hj">且恰好有一条唯一的</strong>路径。</li></ul><p id="dcc3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个特定的节点S被固定为使用<a class="ae jn" href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Prim的算法</a>寻找子图的起点。<br/>求子图中所有边的总权重或和。</p><p id="b95b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请看下面的原问题:</p><div class="ly lz ez fb ma mb"><a href="https://www.hackerrank.com/challenges/primsmstsub/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">prim(MST):特殊子树| HackerRank</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">给定一个由连接其节点的几条边组成的图，找出给定图的一个子图，用…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.hackerrank.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jh mb"/></div></div></a></div><h2 id="ec9d" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">解决办法</h2><p id="4b70" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如上所述，我们可以使用最小堆来实现两种方法。这里将说明第二种方法。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="f2a2" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'prims' function below.<br/>     *<br/>     * The function is expected to return an INTEGER.<br/>     * The function accepts following parameters:<br/>     *  1. INTEGER n<br/>     *  2. 2D_INTEGER_ARRAY edges<br/>     *  3. INTEGER start<br/>     */<br/><br/>    public static int prims(int n, List&lt;List&lt;Integer&gt;&gt; edges, int start) {<br/>        <br/>        PriorityQueue&lt;List&lt;Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(<br/>                                    (a,b) -&gt; a.get(2) - b.get(2));<br/>        heap.addAll(edges);<br/>        <br/>        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();<br/>        visited.add(start);<br/>        int minSum = 0;<br/>        <br/>        while(visited.size() &lt; n) {<br/>            List&lt;List&lt;Integer&gt;&gt; temp = new LinkedList&lt;&gt;();<br/>            while(!heap.isEmpty()) {<br/>                List&lt;Integer&gt; min = heap.poll();<br/>                if (visited.contains(min.get(0)) &amp;&amp; visited.contains(min.get(1))) {<br/>                    continue;<br/>                } else if (visited.contains(min.get(0)) &amp;&amp; !visited.contains(min.get(1))) {<br/>                    visited.add(min.get(1));<br/>                    minSum += min.get(2);<br/>                    break;<br/>                } else if (visited.contains(min.get(1)) &amp;&amp; !visited.contains(min.get(0))) {<br/>                    visited.add(min.get(0));<br/>                    minSum += min.get(2);<br/>                    break;                    <br/>                } else {<br/>                    temp.add(min);<br/>                }<br/>            }<br/>            heap.addAll(temp);<br/>        }<br/>        <br/>        return minSum;<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>        int n = Integer.parseInt(firstMultipleInput[0]);<br/><br/>        int m = Integer.parseInt(firstMultipleInput[1]);<br/><br/>        List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();<br/><br/>        IntStream.range(0, m).forEach(i -&gt; {<br/>            try {<br/>                edges.add(<br/>                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))<br/>                        .map(Integer::parseInt)<br/>                        .collect(toList())<br/>                );<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        int start = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        int result = Result.prims(n, edges, start);<br/><br/>        bufferedWriter.write(String.valueOf(result));<br/>        bufferedWriter.newLine();<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="af60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它使用Java PriorityQueue作为最小堆。它100%通过了如下所有HackerRank测试案例:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/76779723a338a2ac3c9a2008c5821457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDoPc_E2SXEwmRHRsIbNGw.png"/></div></div></figure><p id="7ab9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><p id="47dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ni">问题，想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Start You WASM Journey Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今天就开始你的WASM之旅</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/start-you-wasm-journey-today-32b36ac9a817?source=collection_archive---------46-----------------------#2021-06-21">https://medium.com/geekculture/start-you-wasm-journey-today-32b36ac9a817?source=collection_archive---------46-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4aa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">互联网上流传着一种模因，可以说明开发者对新技术的态度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/96ca973f3c4c92483a3f795ced9741db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*HTS-8FoW0fS5RlGWXyc0ew.jpeg"/></div></figure><p id="ca12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然有趣，但我发现这是真的，事实上，我对这张照片唯一想改变的是，我们可能会头先着地。</p><p id="8c8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的开发技术就像最新的流行趋势，前一分钟每个人都在谈论这个新的框架，下一分钟另一个框架就会出现，人们蜂拥而至。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/d8bd34af4ae0fd02df77efcf27742f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEX5tNBEPg8mayyU"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@guoshiwushuang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Lee</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d7eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是就像大多数时尚趋势一样，这些“新的和令人兴奋的”技术一会儿在这里，一会儿又不受支持。</p><p id="95ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在我为这篇文章所做的研究中，我发现了一种技术，我认为这不是一种趋势，但在可预见的未来，这种技术将会出现。</p><p id="0edd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个技术就是Web组装。</p><p id="5356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将讨论它是什么，它有哪些不同的使用案例，对它有哪些误解，最后是这项技术的下一步。</p><h1 id="6c47" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">什么是WebAssembly？</strong></h1><p id="3c3c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">由W3C联盟设计和开发，W3C联盟是一个负责开发万维网标准的组织。创建WASM的目的是为开发人员提供一种可以在浏览器或服务器中执行的低级语言，从而提高应用程序的性能</p><p id="de11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多主要语言都支持WASM，这意味着开发人员可以使用他们选择的语言编写代码，如(C、C++、Go、Rust ),使用wasm-pack或Emscripten等编译工具来生成可以直接在浏览器中执行的Web汇编文件。</p><p id="0d9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">据w3.org 2019年12月5日报道，W3C已经正式承认WebAssembly为主流浏览器支持的第四种语言。在此之前，浏览器支持的三种语言是(<strong class="ih hj"> HTML、CSS和JS </strong>)。</p><h1 id="4a46" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">网络组装有什么好处？</strong></h1><p id="b153" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">作为编译目标，开发者可以选择性能语言来编写他们的逻辑并编译到WASM。这一发展的影响是巨大的。开发人员能够用诸如(<strong class="ih hj"> C、Rust、Go等等</strong>)的语言编写代码，然后将其编译成二进制代码，以便在浏览器上执行。这使得最终用户现在甚至可以使用原本用于桌面的应用，并直接在web浏览器中使用它们，无需安装或环境依赖，速度快得惊人，就像在桌面上使用一样。仅举几个例子，Tensorflow、Unity、AutoCAD、Google Earth等项目已经实现了web组装，将它们的代码移植到web平台上，并取得了可喜的成果。</p><h1 id="ddb1" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">可以用WebAssembly做什么？</strong></h1><p id="d3ec" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Josh Hanaford在IBM Developer的博客上写了一篇名为“为什么同时使用WebAssembly和Rust可以提高Node.js的性能”的文章，他指出了web assembly可以应用的几个用例，例如AR/VR应用程序、计算机辅助绘图(CAD)甚至人工智能。</p><p id="7142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在我的研究过程中，我偶然发现OpenCV网站和他们的演示将WebAssembly的性能与JavaScript (asm.js)进行了比较。在下面的第一张图中，我使用JavaScript测试了OpenCV人脸检测，并注意到它的人脸检测API性能不佳，因为它难以保持每秒18帧。然而，当使用OpenCV的人脸检测的WebAssembly实现时，该应用程序轻松地保持了53 fps的帧速率。这几乎是JS实现的3倍。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ky"><img src="../Images/1f71c8d564996426f62307c09c171c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKhr66Obx1qUdqud"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ky"><img src="../Images/22db7d4dbd4fab87ea70ab145ec812ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n3zbLvRiwAoe7elm"/></div></div></figure><p id="3b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了测试已经写好的演示，我还想亲自测试一下实现。为此，我选择了两个基准测试。第一个演示了WASM与使用<em class="kz">递归</em>的JS相比表现如何，第二个演示了它与使用for循环的JS相比表现如何。</p><p id="e98d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于第一个测试，我使用了斐波那契算法来测试递归。正如您在下面的第一个测试中看到的，使用Web Assembly有相当大的性能提升，但是随着输入的增加，两者之间的性能差异可以忽略不计。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/eacc1848d5ebb2a16bff088c1a58fd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*rtC5u1WLp31jOTuJzsXFrg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Chrome fibonacci Test</figcaption></figure><p id="aeee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">for循环呢，在这种情况下它的表现如何？</p><p id="b7b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了这个测试，我编写了一个函数，使用迭代For循环方法来检测一个数是否是质数。正如您在右边的表格中看到的，WASM的平均表现是传统JS的7倍！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/47ea869f52f15cef9a8346764e2e52b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*vy0xmnNHZMdWmbVp2rxdhw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Chrome detect prime number test</figcaption></figure><p id="ea28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一些我用rust写的函数的代码片段，然后使用一个名为(<strong class="ih hj"> wasm-pack </strong>)的Rust库编译成Web汇编。在这些代码片段中需要注意的一点是，为了让我在浏览器中使用这些函数，我必须使用<strong class="ih hj"> wasm-bindgen </strong>来注释我的函数。在未来的博客中会有更多的介绍。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Writing fibonacci algorithm using Rust</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Detecting if input is prime number in Rust</figcaption></figure><h1 id="b2ef" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">误解</strong></h1><p id="29ab" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">像Web Assembly这样有影响力的语言自然会在开发人员社区中产生一些误解。比如:</p><p id="830c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着像WebAssembly这样的语言在开发人员社区中逐渐流行，一些问题和误解也随之产生，比如:如果我选择使用WebAssembly，我是否必须用它重写整个应用程序？还是说WebAssembly将来会取代JavaScript？</p><p id="38d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个问题的答案都是否定的。WebAssembly的创造者们对这种语言的想法是与JavaScript一起工作，允许开发人员快速地用JavaScript编写他们的代码，但抵消了Web Assembly的沉重负担。</p><h1 id="5a2a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">结论</strong></h1><p id="4580" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我希望这篇文章能让你看到WebAssembly在未来能够实现的可能性。从JavaScript的性能提升到大量的用例，现在诸如(C、C++和Rust)等源语言可以编译成WebAssembly并直接在浏览器中执行。对于我来说，我对这项技术感到兴奋，我迫不及待地想把它应用到我的工作项目中。</p></div></div>    
</body>
</html>
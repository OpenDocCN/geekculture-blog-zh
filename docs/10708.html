<html>
<head>
<title>Angular:Simple Practical Example for Executing Dependent and Independent Methods in Sequence using RXJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:使用RXJS顺序执行依赖和独立方法的简单实例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-simple-practical-example-for-executing-dependent-and-independent-methods-in-sequence-using-af2db1f74a8c?source=collection_archive---------4-----------------------#2022-02-12">https://medium.com/geekculture/angular-simple-practical-example-for-executing-dependent-and-independent-methods-in-sequence-using-af2db1f74a8c?source=collection_archive---------4-----------------------#2022-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的工作项目中，我遇到过多种需要按顺序执行操作的情况。我们将检查两个场景:</p><ol class=""><li id="c5f9" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">按顺序执行两个方法，其中一个方法依赖于另一个方法获取数据。</li><li id="f563" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">按顺序执行两个方法，其中两个方法相互独立。</li></ol><p id="7a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是我们的目标:</p><ol class=""><li id="566f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">以表格形式显示5个用户的列表和每个用户的待办事项列表。</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/ffebf849c32f95b1434ca8b12f7af4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0eu6AKD0J76qDMuA9UfmA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">First user</figcaption></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kh"><img src="../Images/2215a03be064f12294da2087c0489e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woxeXz7XYKsFnlX1QzIUAQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Second user</figcaption></figure><p id="c87a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们没有使用数据库来获取数据。相反，我们从两个文件中导出了用户数据和每个用户的待办事项列表数据:<strong class="ih hj"> todos.ts和users.ts </strong>。下面的截图将有助于理解用户和待办事项列表数据的结构。</p><p id="80ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> todos.ts </strong>中，我们已经导出了一个数组<strong class="ih hj"> todos。</strong>数组中的每个对象包含创建了待办事项的用户的<strong class="ih hj"> userId </strong>、待办事项的<strong class="ih hj"> id </strong>、待办事项的<strong class="ih hj">标题</strong>和事项的<strong class="ih hj">完成状态</strong>。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ki"><img src="../Images/046ec97f9bb55c1eea7af7e29350c7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwKLlyDO-5M6SipQiOsdNg.png"/></div></div></figure><p id="801e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> users.ts </strong>中，我们已经导出了一个数组<strong class="ih hj"> users。</strong>这个数组包含用户的<strong class="ih hj"> id </strong>和用户的所有其他信息，这些信息在这个例子中是不相关的。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kj"><img src="../Images/eb76bbb5338f06e14831626c13646a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HF2UvsQ-9f6vSXfNQabFRg.png"/></div></div></figure><p id="89e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将首先获取用户数据，然后使用每个用户的信息来检索相应的待办事项列表数据。这将演示第一个场景。</p><p id="305b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了演示第二个场景，我们为每个用户添加了一个“<strong class="ih hj">删除所有待办事项</strong>”功能。当我们点击用户对应的“<strong class="ih hj">删除所有待办事项</strong>按钮时，该用户的所有待办事项将被删除，更新的数据将被提取。这里，删除和获取将按顺序进行。</p><p id="69a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从<strong class="ih hj"> AppComponent模板</strong>开始:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="f074" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模板有一个简单的表，它是通过迭代数组<strong class="ih hj"> todos构建的。</strong>这个数组中的每个对象都有3个属性:<strong class="ih hj">用户名，id </strong>和<strong class="ih hj"> toDos </strong>。属性名称本身表明它包含什么数据。<strong class="ih hj"> userName </strong>是包含用户名的字符串属性，<strong class="ih hj"> toDos </strong>是包含该用户对应的待办事项列表的数组属性，<strong class="ih hj"> id </strong>是包含用户id的数字属性。</p><p id="6a46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还有对应于每个用户的<strong class="ih hj">删除所有待办事项</strong>按钮。当我们点击按钮时，调用<strong class="ih hj"> delete() </strong>将相应用户的id作为参数传递。在这个方法中，我们将删除用户的ToDos列表。</p><p id="46fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AppComponent类:</strong></p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="66ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一步一步地在课堂上演示场景1。</p><p id="e242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一、在<strong class="ih hj"> ngOnInit() </strong>生命周期钩子中，我们调用了一个方法<strong class="ih hj"> getUsers()。</strong>顾名思义，在这个方法中，我们将依次获取5个用户的列表以及每个用户对应的ToDos列表。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="0ccc" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//AppComponent Class</strong></span><span id="7df9" class="kr ks hi kn b fi kx ku l kv kw">ngOnInit() {<br/>this.getUsers().subscribe((todos) =&gt; {<br/><strong class="kn hj">this.constructJSON(todos);</strong><br/>});<br/>}</span></pre><p id="2232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们先来检查一下<strong class="ih hj"> getUsers() </strong>。</p><ol class=""><li id="d52a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">变量users </strong>将保存前5个用户的详细信息，而<strong class="ih hj">变量todos </strong>将保存一个对象数组，每个对象包含用户名、用户的待办事项列表以及用户的id。这两个变量都被初始化为一个空数组。</li></ol><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="e1a1" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">this.users</strong> = [];<br/><strong class="kn hj">this.todos</strong> = [];</span></pre><p id="b282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj"> users.ts </strong>文件导出了一个包含10个对象的users数组，这些对象对应于10个用户，但是在本例中，我们想要演示的是只按顺序检索前5个用户的详细信息。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="f7de" class="kr ks hi kn b fi kt ku l kv kw">public arr = [1, 2, 3, 4, 5];</span></pre><p id="c694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由数字1-5组成的数组<strong class="ih hj"> arr </strong>已使用rxjs 运算符的<strong class="ih hj">转换为冷可观察值。每个数字对应一个用户的ID。这个可观察值将仅发出5个值，并将完成。我们将利用这一点从API中检索前5个用户的详细信息。</strong></p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="8ee0" class="kr ks hi kn b fi kt ku l kv kw">return <strong class="kn hj">from(this.arr)</strong>.pipe(<br/>tap((elem) =&gt; console.log('userIndex', elem)),<br/><strong class="kn hj">concatMap((userId, index) =&gt; this.service.getUsers(userId))</strong><br/>).pipe(<br/>tap((elem) =&gt; console.log('userInfo', elem)),<br/><strong class="kn hj">concatMap((userInfo: any, index) =&gt; {<br/>this.users.push(userInfo);<br/>return this.service.getToDos(userInfo.id);<br/>})</strong><br/>);</span></pre><p id="ea32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.来自操作符的<strong class="ih hj">将数组<strong class="ih hj"> arr </strong>转换为一个可观察值(外部可观察值),该值为1-5。</strong></p><p id="e31e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.当它发出第一个值1时，第一个<strong class="ih hj"> concatMap </strong>操作符将值1映射到由<strong class="ih hj">this . service . get users(userId)返回的内部可观察对象。</strong>请注意，我们正在使用<strong class="ih hj">点击操作符</strong>记录每个步骤。</p><p id="2068" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续之前，让我们检查一下<strong class="ih hj"> TestService </strong>类。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="9ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从<strong class="ih hj"> users.ts </strong>和<strong class="ih hj"> todos.ts </strong>导出的数组<strong class="ih hj"> users </strong>和<strong class="ih hj"> todos </strong>分别赋给两个变量<strong class="ih hj"> userList和todosList </strong>。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="1eb1" class="kr ks hi kn b fi kt ku l kv kw">public userList = […users];<br/>public todosList = […todos];</span></pre><p id="f347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> getUsers() </strong>方法中，我们将用户的ID作为参数传递。我们正在过滤数组<strong class="ih hj"> userList </strong>，以检索与作为参数传递的用户ID相对应的用户信息。我们使用来自操作符的<strong class="ih hj">将包含用户信息的对象转换成可观察对象，并将其返回给组件。</strong></p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="227a" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//TestService Class</strong></span><span id="757d" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">getUsers(index: number)</strong> {<br/>let filteredUsersList = this.userList.filter((users: any) =&gt; users.id == index<br/>);<br/>return from(filteredUsersList);<br/>}</span></pre><p id="261c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.从TestService 的<strong class="ih hj"> getUsers()返回的这个可观察对象现在成为外部可观察对象，它发出包含用户信息的对象作为值。</strong></p><p id="c3c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2nd concatMap </strong>操作符将这个值映射到一个内部可观察对象中，这个内部可观察对象将由<strong class="ih hj"> this.getToDos(userInfo.id)返回。</strong>还要注意，在内部可观察对象返回之前，我们将外部可观察对象发出的对象(包含用户信息)推入<strong class="ih hj">用户</strong>数组。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="decd" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">concatMap((userInfo: any, index) =&gt; {<br/>this.users.push(userInfo);<br/>return this.service.getToDos(userInfo.id);<br/>})</strong></span></pre><p id="3d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.移动到<strong class="ih hj"> TestService类</strong>中的<strong class="ih hj"> getToDos() </strong>方法。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="2bdf" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//TestService Class</strong></span><span id="e55b" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">getToDos(index: number) {</strong><br/>let filteredToDosList = this.todosList.filter((todos: any) =&gt; todos.userId == index<br/>);<br/>return of(filteredToDosList);<br/>}</span></pre><p id="554c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经将用户的ID作为参数传递给了这个方法。我们正在通过<strong class="ih hj">ToDo list</strong>数组进行过滤，以检索与用户ID相对应的所有待办事项列表项。</p><p id="a183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用来自操作符的<strong class="ih hj">将过滤后的列表作为可观察对象返回给组件。</strong></p><p id="6998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，在我们已经讨论过的下面这段代码中，第一个用户的这个过滤后的待办事项列表将作为订阅结果被接收。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="4ef2" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//AppComponent Class</strong></span><span id="aa9b" class="kr ks hi kn b fi kx ku l kv kw">ngOnInit() {<br/>this.getUsers().subscribe((todos) =&gt; {<br/><strong class="kn hj">this.constructJSON(todos);</strong><br/>});<br/>}</span></pre><p id="924b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将这个过滤后的ToDo列表作为参数传递给<strong class="ih hj"> constructJSON() </strong>来创建最终的数组<strong class="ih hj"> todos </strong>，它将形成表数据。这个方法的内容并不重要。您需要知道的是，我们正在将第一个用户的用户信息和对应于该用户的待办事项列表推送到<strong class="ih hj"> todos </strong>数组中。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="e1c5" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//AppComponent Class</strong></span><span id="9a7a" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">constructJSON(todos) {</strong><br/>let obj: any = {};<br/>obj.userName = this.users[this.users.length — 1].name;<br/>obj.id = this.users[this.users.length — 1].id;<br/>obj.toDos = todos;<br/>this.todos.push(obj);<br/>}</span></pre><p id="17a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的过程也将发生在其他4个用户身上。下面是最终<strong class="ih hj"> todos </strong>阵列的结构。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ky"><img src="../Images/fe849136c07f1df9e02f98554cb3373e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpfU1L6qP08Ji71JD1-VYQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Final todos used in the table</figcaption></figure><p id="0fce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请观察控制台中的以下日志，了解如何使用<strong class="ih hj"> concatMap </strong>操作符按顺序执行所有操作。这就完成了<strong class="ih hj">场景1 </strong>。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kz"><img src="../Images/10c0163f096c34b94a558015f1f182dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ypa22Azfq_xrIMMvRygnEA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Log to demonstrate the methods executing in sequence</figcaption></figure><p id="64af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二。现在让我们继续进行<strong class="ih hj">场景2 </strong>，其中两个独立的操作:删除和检索将依次发生。</p><p id="36a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我点击第一个用户“符晓薇·格拉汉姆”的“<strong class="ih hj">删除所有待办事项</strong>”按钮。它将执行delete()，将用户的ID作为参数传递。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="6944" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//AppComponent Class</strong></span><span id="2c7a" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">delete(userId: number) {</strong><br/><strong class="kn hj">concat(this.handleDelete(userId), this.getUsers())</strong>.subscribe(<br/>(todos: any) =&gt; {<br/>if (Array.isArray(todos)) {<br/><strong class="kn hj">this.constructJSON(todos);</strong><br/>}<br/>},<br/>(err) =&gt; console.log(err),<br/>() =&gt; console.log(‘completed’)<br/>);<br/>}</span></pre><p id="8f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将使用<strong class="ih hj"> concat操作符</strong>依次执行<strong class="ih hj"> handleDelete() </strong>和<strong class="ih hj"> getUsers() </strong>。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="8e73" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//AppComponent Class</strong></span><span id="617f" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">handleDelete(userId: number) {</strong><br/>let updatedToDosList = this.service.todosList.filter(<br/>(todo, todoIndex) =&gt; todo.userId !== userId<br/>);<br/>return this.service.updateToDosList(updatedToDosList);<br/>}</span></pre><p id="de86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> handleDelete() </strong>中，我们再次传递了相同的用户ID作为参数。我们通过TestService 的<strong class="ih hj">ToDo list变量进行过滤，以检索所有用户的ToDo列表，除了其ID作为参数传递的用户。</strong></p><p id="0ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目的是创建一个数组<strong class="ih hj"> updatedToDosList </strong>，其中没有ID作为参数传递的用户的待办事项列表项。</p><p id="2da7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们调用测试服务的<strong class="ih hj"> updateToDosList()，将<strong class="ih hj"> updatedToDosList </strong>作为参数。</strong></p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="c45d" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">//TestService Class</strong></span><span id="35be" class="kr ks hi kn b fi kx ku l kv kw"><strong class="kn hj">updateToDosList(updatedList) {</strong><br/>this.todosList = updatedList;<br/>return of(‘Updated Data Successfully’);<br/>}</span></pre><p id="45f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> updateToDosList() </strong>中，我们只是用更新后的数据更新了<strong class="ih hj"> todosList </strong>变量，以便在检索时，我们可以获得除第一个用户之外的所有用户的待办事项列表信息，第一个用户的ID在参数中传递。</p><p id="aa35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，<strong class="ih hj"> concat </strong>操作符将调用我们已经讨论过的<strong class="ih hj"> getUsers() </strong>来检索更新的数据并填充表格。</p><p id="c3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了场景2。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es la"><img src="../Images/2950b494a4d9e028fda0bc35b862a36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSSU0Oldv1a1VQ0nRP1_uQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Table after deleting the ToDo list of the first user</figcaption></figure><p id="f289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在下面的链接中找到完整的例子。</p><div class="lb lc ez fb ld le"><a href="https://stackblitz.com/edit/angular-vxbtln?file=src/app/test.service.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab dw"><div class="lg ab lh cl cj li"><h2 class="bd hj fi z dy lj ea eb lk ed ef hh bi translated">角形(叉形)堆叠</h2><div class="ll l"><h3 class="bd b fi z dy lj ea eb lk ed ef dx translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="lm l"><p class="bd b fp z dy lj ea eb lk ed ef dx translated">stackblitz.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls kb le"/></div></div></a></div></div></div>    
</body>
</html>
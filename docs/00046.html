<html>
<head>
<title>Introduction to Variance in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的方差介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-variance-in-java-2c0291a1388e?source=collection_archive---------0-----------------------#2019-10-27">https://medium.com/geekculture/introduction-to-variance-in-java-2c0291a1388e?source=collection_archive---------0-----------------------#2019-10-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="919b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">扩展和更新版本</h2></div><p id="950e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">这是受</em><a class="ae ju" rel="noopener" href="/javarevisited/variance-in-java-and-scala-63af925d21dc"><em class="jt">《Java和Scala差异完全指南》</em> </a>启发的扩展和更新版本</p><p id="d468" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望我在2008年读到这篇文章(在我搬到JDK 5.0之前)。文章中提供的所有代码都在JDK 8上进行了测试。</p><p id="bc60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所知，在Java中整数扩展了数字。字符串不扩展数字，字符串扩展对象。以下代码是合法的:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="dba2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一行定义整数1。</p><p id="d5f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二行是标准对象赋值，<em class="jt">通过引用复制</em>，在第二行之后我们有两个引用<em class="jt">一个</em>和<em class="jt">另一个</em>指向同一个对象整数1。</p><p id="e0d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第三行也通过引用使<em class="jt">复制。</em>它利用了所谓的<em class="jt">多态性</em>。</p><p id="b067" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第五行不编译。我们试图将String类型的引用赋值给Integer类型的引用。但是Integer和String没有任何继承关系(Integer不直接或间接扩展String，not String不直接或间接扩展Integer)。因此，这种赋值在编译时会失败。这就是该行被注释掉的原因。</p><p id="a92d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第七行定义了包含值“one"⁶.”字符串</p><p id="069d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">八行使<em class="jt">通过引用</em>在字符串之间复制。<em class="jt"> Str </em>和<em class="jt"> anotherStr </em>引用相同的值。</p><p id="b098" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">九行不编译。我们试图将字符串类型的引用赋值给数字类型的引用。但是数字和字符串没有任何继承关系。具体来说，String不扩展任何最终(也就是上面的<em class="jt">间接</em>的意思)扩展Number的类。因此，这种赋值在编译时会失败。这就是该行被注释掉的原因。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="05c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java中的数组是<em class="jt">协变的。这是什么意思？</em></p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8813" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Integer <em class="jt">是一个</em>数，Integer是Number的子类。让我们将这个事实表示为整数&lt; : Number。</p><p id="7748" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java Integer[] <em class="jt">中是一个</em>数字[]，或者在我们的新符号Integer[] &lt;:数字[]。这叫做<strong class="iz hj">协方差</strong>。这使得6号线能够工作。整数[]实际上是可将分配给数字[]的<em class="jt">。</em></p><p id="2b2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em>在Java Integer中，Number，String(任何其他对象)都是java.lang.Object的子类，因为，Java数组中的<strong class="iz hj">是协变的</strong>，这就意味着Integer[] &lt; : Object[]，Number[] &lt; : Object[]，String[] &lt; : Object。</p><p id="15e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第6行没有编译，因为赋值:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="1f26" class="ko kp hi kk b fi kq kr l ks kt">Integer a0="1";<br/>Integer a1="1";<br/>Integer a2="1";<br/>Integer a3="1";</span></pre><p id="defd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">字符串不是整数的子类。</p><p id="2d91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第10行我们定义了另一个引用来引用同一个数组(在Java中array是一个对象)。</p><p id="bcd7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第11行没有编译，原因和第8行一样。每个单元分配失败。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="b934" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">科特林和Scala选择他们的数组是<strong class="iz hj"> <em class="jt">不变的。</em> </strong>字符串<em class="jt"> </em>和数字都是不变类的例子，<em class="jt">它们都不是对方的子类。</em></p><p id="da4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kotlin和Scala中，语法上等价的第4行不会被编译。不变类型<em class="jt">不可赋值</em>。为了理解为什么让我们看看下面的代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="f3eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会深入这个代码的细节，它非常简单。有些设计的选择只是为了演示的目的(SportCar.getNumberOfWheels()是多余的，这是他们为了清晰起见；getNumberOfWheels()可以移动到Vehicle类中，如果没有轮子，则返回0(例如在rocket或dirigible中，等等)。</p><p id="406d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们首先简单地看一下这个问题:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="352b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们实例化一些汽车数组。注意数组中的SportCar <: car="" vehicle="" object.="" motorcycle=""/></p><p id="2871" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Car is subclass of Object. Because array in Java are covariant, array of car is subclass of array of object, and thus we can assign array of cars to array of objects. Now, compiler see arr as array of object. In Java arrays are mutable (we’ll get back to this point later), so it is perfectly fine to reassign it’s first element. As far as compiler concert the type of arr[0] is java.lang.Object, so he is happy to assign Motorcycle their⁷.</p><p id="bb3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">If this example fail to convenience you, let’s look on some real (sort of) code:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="9e20" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">The interesting part is SomeService.calcNumberOfWheels() method. There is edge case, if array is null (that is handle by ternary operator, 0 is returning immediately⁸). Another edge case, if array is empty, than we have optimization⁹, we return 0 immediately.</p><p id="07b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">At line 12 we are iterating over array¹⁰.</p><p id="5bd0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">At line 13 there are actually 2 things going on: we’re getting <strong class="iz hj"> out </strong>元素(记住，Java中的array是对象，所以，实际上，Car是从Car[]返回的)，然后我们<strong class="iz hj">将数组中这个元素的引用</strong>分配给cur reference。例如，我们从数组中取出SportCar引用，由于多态性(如上所述)，对Car引用的赋值将会成功。</p><p id="a003" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第14行，我们将getNumberOfWheels()的结果存储在临时变量cur中。</p><p id="3afa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第15行，我们利用了允许add将int加到long上的<code class="du ku kv kw kk b"><a class="ae ju" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2" rel="noopener ugc nofollow" target="_blank">JLS8 §5.6.2</a> </code>(在加法之前有int cur到long的隐式转换)。</p><p id="2764" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在方法结束之前，我们要进行检查，确保没有溢出。</p><p id="48fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有很多细节，让我快速总结一下。我们有以下签名的汽车服务:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="bd89" class="ko kp hi kk b fi kq kr l ks kt">public int calcNumberOfWheels(Car[] cars)</span></pre><p id="c8d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个方法应该做什么？它假设遍历汽车数组(我们一次从中取出<strong class="iz hj">)，调用它的一些方法并总结返回的结果。car的数组可以包含Car的子类，因为多态，所以不会有问题。</strong></p><p id="aa99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能不能把<strong class="iz hj">放在</strong>里不是从Car衍生出来的东西？简短的回答是:不。更长的回答如下:</p><p id="817b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过写下这样的内容来欺骗编译器:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="3dd8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码将会编译。然而，由于Java数组内置的特制保护机制<em class="jt">，它将在运行时失败。缺点是，每次访问数组时，我们都要做一些额外的验证(这会降低程序的执行速度，执行程序的时间会不断增加)。</em></p><p id="385a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，你应该注意到，我不时地强调“在Java中”一些陈述是正确的。但我说的是Java，何苦呢？如今，JVM不仅可以运行Java，还可以运行Groovy、Scala、Kotlin等。我不会详细说明这是如何实现的，我只会说，所有这些语言都编译成相同的<em class="jt">字节码，</em>但有不同的编译器。所有这些语言都是在Java之后很久才出现的，所以看看他们做了什么选择是很有趣的。</p><p id="993f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Scala和Kotlin认为数组是不变的。原因如上所述，否则，你的代码可以编译，但在运行时会崩溃。对于Java来说，改变这个设计决策为时已晚。当<em class="jt">泛型</em>在JDK 5.0中被添加时，Java团队认识到了这种设计方法(稍后将详细介绍)。它们被声明为<strong class="iz hj">不变量。</strong>例如，列表&lt;跑车&gt;不可分配<em class="jt">给列表&lt;汽车&gt;。我们稍后将回到这一点。</em></p><p id="15c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java团队还有其他选择吗？我知道，由于<em class="jt">向后兼容性</em>的考虑，我们不能真正实现任何替代方案(这会破坏现有的代码)，但是让我们把这当作理论练习。</p><p id="a0ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细看看calcNumberOfWheels()的代码。回想一下，Java中的数组是<strong class="iz hj">协变的。</strong>但是当我们从数组中取出<strong class="iz hj">和</strong>元素时没有任何问题(因为多态性)。我们确实有问题，只是我们将<strong class="iz hj">放在</strong>的一些实例中(如上所述，Java有特殊的内置保护机制)。因此，另一种选择是让数组能够从元素中获取<strong class="iz hj">(通过索引，或者通过一些其他的能力),而不能让<strong class="iz hj">改变</strong>元素。这样的对象叫做<strong class="iz hj">不可变</strong>。</strong></p><p id="3b83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">不可变</strong>对象是在构造完成后不改变其<em class="jt">状态</em>的对象。也就是说，在构造函数执行结束后，对象的<em class="jt">状态</em>不应该改变。如果我们禁止重新分配数组的元素(代码如</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="8b1f" class="ko kp hi kk b fi kq kr l ks kt">arr[0]=some_instance</span></pre><p id="38f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将是非法的)，考虑到Java中的数组没有add(数组是Java可以动态增长的)和clear(这两种方法也会改变状态)这样的方法，这样的数组将是<strong class="iz hj">不可变的。</strong>看起来<strong class="iz hj">对于不可变对象是协变的是安全的。稍后我会详细说明。</strong></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="0ae7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们看到数组可以是<strong class="iz hj">协变的</strong>。我们还简要地提到，默认情况下，泛型(又名参数化类型)是<strong class="iz hj">不变的</strong>。现在，我想指出我们也有<strong class="iz hj">协变返回类型</strong>(方法的)。<br/>让我们再来看看我们的汽车等级体系:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="1a4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们把重点放在withDriver()方法上。让我们看看这个方法的实际用法是怎样的:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8d82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们定义新汽车实例。然后，我们希望将驱动程序分配给它，并在car实例上调用一些Car特定的方法。</p><p id="40e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们真正想要的是编写第3行，只是为了调用withDriver()方法。也许我们想写这样的东西:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="24f9" class="ko kp hi kk b fi kq kr l ks kt">car.withDriver(driver)<br/>   .someCarMethod()</span></pre><p id="f778" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">边注:</em>这么做的原因之一是写<a class="ae ju" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank"><em class="jt">fluent API</em></a><em class="jt"/>(最简单的例子是StringBuilder，比较典型的例子是Stream API或者CompletableFuture)。</p><p id="2dc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可惜这个不编译。原因是withDriver()方法的返回类型是Vehicle(不是Car！).虽然我们知道<em class="jt">实际上(</em>我们返回它)在运行时会被Car，但是编译器不知道这一点。克服这个障碍的一个方法是添加显式强制转换，就像我们在第4行所做的那样。它看起来不漂亮，但这个工作。</p><p id="6c40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能有更好的解决方案吗？从JDK 5.0开始就有了。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="e4a7" class="ko kp hi kk b fi kq kr l ks kt">car.withDriver(driver)<br/>   .someCarMethod()</span></pre><p id="8f1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也会起作用。</p><p id="7ccf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解这一点，我们需要了解Java中的<strong class="iz hj">方法重载</strong> ⁴是如何完成的，以及什么是<strong class="iz hj">桥接方法</strong> ⁵.</p><ul class=""><li id="fd7f" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">具有相同签名(方法名+方法参数)但不同返回类型的两个方法是编译时错误。</li><li id="43eb" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">然而，在运行时，JVM允许两个方法具有相同的签名，但返回类型不同。</li></ul><p id="8db8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看Car.withDriver()方法。让我们问自己一个问题，这个方法是覆盖还是重载Vehicle.withDriver()方法？显然，我们想要覆盖，这是注释@Override用于⁴.但是，这是如何实现的呢？</p><p id="ea86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在5.0之前，当您覆盖超类方法时，被覆盖方法的名称、参数类型和返回类型必须与超类方法完全相同。据说覆盖方法对于参数类型和返回类型是<strong class="iz hj">不变的</strong>。</p><p id="9947" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您更改了任何参数类型，那么您并没有真正地覆盖一个方法—您实际上是在重载它。</p><p id="8504" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们添加someCarMethod(Car another):</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="f1c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将导致<strong class="iz hj">方法过载</strong>。</p><p id="592f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们再来看看方法签名:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="47b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在JDK 5.0之前，这里会有编译时错误。在JDK 5.0中有所改变。现在，<em class="jt">你可以在子类中有不同的返回类型，只要这个返回类型是超类返回类型的子类。在我们的例子中，Car &lt; : Vehicle既是withDriver()方法的返回类型，也是继承树中的子类。</em></p><p id="2790" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法覆盖被认为是相对于返回类型的<strong class="iz hj">协变。</strong></p><p id="4571" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注:</em>再比如克隆法。Object.clone()方法返回对象类型。</p><p id="d224" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em>有趣的是，<strong class="iz hj">异常声明甚至在5.0之前就已经协变</strong>。也就是说，子类方法可能抛出超类方法异常的相同类型或子类型。</p><p id="1af9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们有了理解<strong class="iz hj">协变返回类型</strong>是如何实现的所有要素。</p><p id="8cb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，java编译器正在做的是将合成/桥接方法添加到子类中(在我们的例子中是Car):</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8971" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你不能写这样的代码，编译器会产生编译时错误。但是编译器被允许这样做。</p><p id="f6c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，实际上，编译器的桥方法覆盖了车辆的原始方法。这个桥方法调用实际的实现。实际的实现方法重载了桥方法。从实际实现返回的值(在我们的例子中是Car)是bridge方法(Vehicle)的子类，所以通过多态我们可以从bridge方法返回子类(为了清楚起见，在第4行通过临时变量完成)。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="3e09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们考虑<strong class="iz hj">通用</strong>和<strong class="iz hj">集合</strong>。</p><p id="9d48" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说说List <car>和Car[]的区别。实际上，有许多点可以区分它们，我将只列出其中几个(基本类型、空值等被跳过):</car></p><ul class=""><li id="e214" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">Car[]无法动态增长。您不能添加超过其长度新车(您只能显式地复制到新创建的更大的数组)。<br/> -如果您使用LinkedList实现，您可以自由添加/删除新项目(达到内存限制)。<br/> -如果使用java.util.ArrayList实现，这种动态增长将隐式完成。<br/> -java.util.Arrays.asList()返回固定大小的列表，他不能动态增长。(你可以把它传递给java.util.ArrayList类的构造函数来克服这个缺点)。<br/>-JDK 9的java.util.List.Of()是java.util.Arrays.asList()的优化版本。</li><li id="609d" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">-At Car[]-数组中项的实际类型是Car。运行时(JVM)知道这一点。存在上述存储错误类型的嵌入式防御机制()。<br/> -列表&lt;车&gt;-列表中项目的实际类型为对象(由于<em class="jt">类型擦除</em> ⁷).编译器尽最大努力确保列表包含正确的类型，但是它可以被欺骗(我将在后面展示几个这样的技巧)。</li><li id="dd1e" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">-列表<car>是<strong class="iz hj">不变的</strong>。<br/> -Car[]是<strong class="iz hj">协变</strong>(如上所述)</car></li></ul><p id="84fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想进一步阐述最后一点。</p><p id="5677" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">List <car>是不变的——这意味着，虽然SportCar <: car="" we="" can="" determine="" relationship="" whether="" list="">或List<: list="">或<car>或<:>。为什么Java有这样的易变性？</:></car></:></:></car></p><p id="b32f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之:是<em class="jt">设计选择</em>。</p><p id="8df7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更长的答案如下:一般来说，在面向对象编程语言中有两种支持泛型(也称为参数化类型)的技术。第一种技术，<strong class="iz hj">同构转换</strong>，将泛型类型解析为单一类型，而不考虑其类型参数。这是Java使用的技术，由此<code class="du ku kv kw kk b">List&lt;Car&gt;</code>和<code class="du ku kv kw kk b">List&lt;SportCar&gt;</code>都解析为运行时类型<code class="du ku kv kw kk b">List </code>【类型被<em class="jt">擦除</em>】。第二种技术，<strong class="iz hj">异构翻译</strong>(或<strong class="iz hj">泛型特殊化</strong>)，导致单个泛型类型的不同类型参数在运行时解析为不同的类型(更多细节请参见<a class="ae ju" href="http://en.cppreference.com/w/cpp/language/templates" rel="noopener ugc nofollow" target="_blank"> C++模板类</a>)。例如，<code class="du ku kv kw kk b">List&lt;String&gt;</code>和<code class="du ku kv kw kk b">List&lt;Integer&gt;</code>将分别产生类似于<code class="du ku kv kw kk b">List_String</code>和<code class="du ku kv kw kk b">List_Integer</code>的运行时类型(与单一的同类类型<code class="du ku kv kw kk b">List</code>相反)。</p><p id="e515" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">边注:</em>截至2019年<a class="ae ju" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">瓦尔哈拉项目</a>仍在进行中。</p><p id="cedf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">因为java选择用类型擦除实现泛型，所以我们不能像对数组</em>那样实现运行时保护，因为我们在运行时只有一个包含java.lang.Object的类列表。这就是为什么Java中的<strong class="iz hj">泛型在默认情况下是不变的。</strong></p><p id="34be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，在Scala和Kotlin中，数组在默认情况下是不变的，list和collection也有所不同。</p><p id="63d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Scala中的链表是不可变的⁸和协变的。</strong></p><p id="028d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在Kotlin列表中是只读的⁸和协变的。</strong></p><p id="680a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em>您可能会注意到集合的不可变能力和只读能力之间存在一些差异，但是这种差异对于<em class="jt">差异</em>的讨论来说并不重要，所以我不会深入讨论这个问题。</p><p id="77c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em> Kotlin和Scala总体上同意<strong class="iz hj">同构转换</strong>技术是正确的选择，但是他们发现在一些重要的特殊情况下(集合是不可变的/只读的)我们可以有<strong class="iz hj">协变集合。我们将在后面的故事中探讨为什么会这样。</strong></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="3a39" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们回到Java，看看一些使用泛型的实际代码示例。这将是列表，但这只是一个方便的例子。我们还将重用上面的代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="c324" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们向SomeService添加新方法:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="7f92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是主要的:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e0a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要方法是SomeService.hasSameDriver()。让我们一行一行地过一遍。</p><p id="3180" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们检查列表的大小。如果列表为空，那么我们假设，该列表具有相同的driver⁹.如果列表为空或者比我们假设的多1个项目(长度≤1)，则该列表具有相同的驱动因素。否则，我们知道列表有不止一个条目(长度&gt; 1)。</p><p id="3efe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第15行非常有趣。我们从列表中获取<strong class="iz hj"> out </strong> iterator。调用iter.next()(之前没有检查iter.hasNext())是安全的，因为我们知道长度&gt; 1。</p><p id="8293" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第16行<strong class="iz hj">产生列表中的第一个项目</strong>。⁰或者，我们写道</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="dafa" class="ko kp hi kk b fi kq kr l ks kt">Car first = cars.get(0);</span></pre><p id="0e24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是可行的。我在这里使用迭代器有两个主要原因:</p><ul class=""><li id="eaa0" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">hasSameDriver()方法可以对任何集合起作用。例如，我们可以将签名更改为hasSameDriver(Set &lt; Car &gt;)，代码无需任何更改即可工作(Set没有get(0)方法)。</li><li id="be41" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">我们将重用迭代器从第二项开始遍历列表。</li></ul><p id="eaa1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第17行，我们从第一辆车中检索出司机。我们会把它和其他车里的司机的做比较。</p><p id="8597" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:我们可以将其与列表中每辆车的每个驾驶员进行比较。第一次比较将只是“一种浪费”。⁰</p><p id="eca1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第21行确保我们遍历迭代器，直到底层列表用尽。替代方法是:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="f924" class="ko kp hi kk b fi kq kr l ks kt">Car car = null;<br/>for(Iterator&lt;Car&gt; iter = cars.iterator;iter.hasNext();){<br/>   car = iter.next();<br/>   ...</span><span id="a055" class="ko kp hi kk b fi ll kr l ks kt">}</span></pre><p id="1c8a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:在JDK 5.0之前，上面演示的方法是我最喜欢的。在我们的例子中，我们需要在for循环之前初始化iter。因此，只剩下检查退出条件。虽然从技术上来说，这是可能的</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="11d4" class="ko kp hi kk b fi kq kr l ks kt">for(;iter.hasNext();)</span></pre><p id="9642" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我把它改成了while循环。</p><p id="291b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第22行我们正在从当前的汽车中检索司机。现在，我们调用帮助器方法isEquals()，它将检查我们是否有相同的驱动程序。如果我们有不同的驱动程序，我们将终止循环迭代并返回false，我们在循环中发现了不同的(与第一个不同的)驱动程序。</p><p id="21dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们完成迭代并且没有发现任何与第一个不同的驱动因素时，我们可以实现第119行。因为等于的传递性意味着所有的驱动都是一样的，所以我们要返回true。</p><p id="a4a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会深入讨论helper方法isEquals()实现的细节。基本上，驱动程序没有覆盖equals()方法，所以它从java.lang.Object继承了一个⁹，该对象只使用身份检查(==)。</p><p id="7a1e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em>我把空驱动当做特殊值。如果所有的车都有空的司机，我认为他们有相同的司机。</p><p id="f613" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em> isEquals(Object，Object)可以改成isEquals(Driver，Driver)。一切都会好的。让equals()的重载版本接收除java.lang.Object ⁰.之外的任何其他值是一个设计错误因此，在驱动程序的层次结构中，每个类中应该只有零个或一个equals()(本质上，我们从java.lang.Object中重写了equals())。因此，在运行时，将调用equals()的最后一个被覆盖的版本(或者是java.lang.Object中的默认版本，如果我们没有覆盖equals())。</p><p id="64fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看主函数。</p><p id="e0b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第7行是有趣的部分。这里我们实例化</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="3e13" class="ko kp hi kk b fi kq kr l ks kt">List&lt;Car&gt; cars</span></pre><p id="9d9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用java.util.Arrays.asList()方法从单个项目创建参数化列表。注意，为了简单起见，我们只是使用默认构造函数来定义列表中的项目(这意味着，驱动程序将为空)。</p><p id="1a06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:如果您使用的是JDK 9和更高版本，您可以使用java.util.List.of()函数。这是一个重载函数，根据你想要放入列表中的条目数，返回更优化的列表实现。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="0f92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，是时候告诉你，从类型用法的角度来看，上面的代码是错误的。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="4937" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第12行实际上是不编译的！编译器发出以下错误信息:</p><blockquote class="lm ln lo"><p id="916a" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">SomeService类型中的方法具有SameDriver(列表<car>)不适用于参数(列表<sportcar/></car></p></blockquote><p id="4ace" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上是说，为了调用hasSameDriver()方法，我们应该进行<em class="jt">赋值</em>来列出&lt; Car &gt; cars参数。我们传递的是List&lt;sport cars&gt;sport cars。编译器无法进行赋值。为什么？因为Java中的<strong class="iz hj">泛型类型是不变的</strong>。</p><p id="707c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果您检查hasSameDriver()方法的主体，您会注意到有趣的调用是cars.size()、cars.iterator()、iter.hasNext()、iter.next()。您可以合理地预期，在运行时，代码执行应该是相同的。如果我们只能对Java说，我们希望我们的<strong class="iz hj">列表&lt; Car &gt; cars参数是协变的</strong>。之前，我会告诉你怎么做，让我们黑类型系统。</p><p id="29ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是最简单的方法:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e283" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">java.util.Arrays.asList()具有以下签名:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="5ea7" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span></pre><p id="3dd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是所谓的<em class="jt">通用方法。</em> Java在这里使用(某种有限版本的)类型推断来计算T应该在编译类型替换为Car(因为我们在赋值端有List &lt; Car &gt;，我们看到该方法返回的类型是List&lt;T&gt;；由于多态性，我们可以将传入方法(T…)的每个SportCar实例视为Car。因此，Java编译器从SportCar项目中创建正确的Car列表。</p><p id="0e45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以试着这样写:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="bd24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在第6行，编译器会发出以下错误消息:</p><blockquote class="lm ln lo"><p id="7b97" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">类型不匹配:无法从列表<sportcar>转换到列表<car/></sportcar></p></blockquote><p id="0325" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，您应该明白，编译器告诉您，因为List <sportcar>与List <sportcar>不是共变的，所以强制转换总是会失败，所以编译器会拒绝代码。</sportcar></sportcar></p><p id="9062" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试试这个方法:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="79aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码可以工作，但是我们有两个警告。在第6行我们有</p><blockquote class="lm ln lo"><p id="40f7" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">列表是原始类型。对泛型类型列表<e>的引用应该参数化。</e></p></blockquote><p id="51ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第7行有以下警告:</p><blockquote class="lm ln lo"><p id="ed96" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">类型安全:类型列表的表达式需要进行未检查的转换以符合列表<car/></p></blockquote><p id="fcb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，编译器告诉你的是:“我看到你在使用传统的原始类型。您应该真正考虑使用参数化类型。然后他说:“嗯，现在，我看到你在我身上下功夫。我不能保证someSportCars里面只包含汽车，但我不能阻止你(因为遗留代码(JDK 5.0之前的考虑)”。</p><p id="6b84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是可行的，但是编译器在对我们大喊大叫。我们能闭嘴吗？是的，我们可以！</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5caa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，代码工作了，我们没有看到任何警告。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="64b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我向你展示这种技术，因为偶尔你会需要使用一些上述技巧的变体。例如，java.util.ArrayList的实现如下所示(只保留一小部分代码):</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8106" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际数据存储在Object[]中。对它的所有操作都是通过helper方法elementData()完成的。</p><p id="25a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在编译时，泛型参数类型E是未知的(因为上面提到的<strong class="iz hj">同构转换</strong>技术)。泛型参数类型E在运行时也不可用。因此，在运行时有效地将对E的强制转换替换为对Object的强制转换(这没有任何作用(列表不能包含原始类型，至少在<a class="ae ju" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank"> Valhalla项目</a>完成之前是这样)，所以所有东西都是对象)。编译器再次足够聪明，所以它发出警告。我们取消了警告，有效地绕过了类型安全检查。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="5bb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，解决办法是什么呢？我们如何向Java编译器表达我们希望我们的列表<car>是协变的？我们应该使用</car></p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="bbe8" class="ko kp hi kk b fi kq kr l ks kt">List&lt;? extends Car&gt; cars</span></pre><p id="3305" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是汽车类型的协变列表。这是要付出代价的。现在编译器不允许把<strong class="iz hj">放在</strong>里。这是一种只读列表。</p><p id="3ce9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我要重新迭代，List  extends Car&gt;是<strong class="iz hj">协变</strong>(排序)<strong class="iz hj">只读</strong> list。</p><ul class=""><li id="f398" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">列表<strong class="iz hj">与汽车类型</strong>共变，这意味着如果我们有列表&lt; SportCar &gt;编译器将允许我们将其赋给汽车。</li><li id="cd08" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">List是(某种)只读的<strong class="iz hj">这意味着编译器会尽最大努力阻止我们往里面放新东西。</strong></li></ul><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="62f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和主类:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a45c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第9行，我们已经修改了我们讨论过的方法签名。</p><p id="e9cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">注:</em> </strong> <em class="jt">据说方法hasSameDriver()有</em> <strong class="iz hj"> <em class="jt">协变</em> </strong> <em class="jt">参数。</em></p><p id="dcfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个变化导致了第15行的一些变化，我会稍作解释。</p><p id="83df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在主类中，我们现在同时传递List <car>(第7行)和List <sportcar>(第11行)，因为cars参数是<strong class="iz hj">而不是协变的</strong>。</sportcar></car></p><p id="4125" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们要付出的代价是这个列表是只读的。<strong class="iz hj"> </strong>什么意思？在定义cars变量的范围内(在hasSameDriver()方法内), Java编译器会尽力阻止我们调用任何接收参数类型(Car)作为其参数之一的方法。举个例子，</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="f7ba" class="ko kp hi kk b fi kq kr l ks kt">public boolean hasSameDriver(List&lt;? extends Car&gt; cars){<br/>   ...<br/>   cars.add(new Car());<br/>   ...<br/>}</span></pre><p id="cc51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不会编译。编译器将发出错误消息，指出:</p><blockquote class="lm ln lo"><p id="d703" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">该方法添加(捕获#15-of？类型列表<capture extends="" car="">中的扩展汽车)不适用于参数(汽车)</capture></p></blockquote><p id="cae3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回想一下列表的定义。这是不完整的定义(跳过了一些方法):</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="2b53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译器基本上是这样说的:“你定义<strong class="iz hj">协变</strong>(这有什么好笑的<em class="jt">捕捉#15-of？用参数化类型(" E ")汽车扩展</em>表示(扩展汽车)。你试图调用方法java.util.List.add()，但是这个方法需要类型<em class="jt"> capture#15-of？延伸汽车。</em>你试图向它供应汽车，但这不适用。”原因是，类型擦除，我们没有运行时防御机制(就像我们对数组一样)，所以编译器拒绝将<em class="jt">任何东西</em>(任何东西，除了null)作为java.util.List.add()的参数。</p><p id="3c17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:</p><ol class=""><li id="3632" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js ls ld le lf bi translated">您可以调用任何不接收“E”作为参数的方法。</li></ol><ul class=""><li id="f2f2" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">比如可以调用<em class="jt"> cars.size()。</em>没有问题。</li><li id="3af7" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">也可以调用<em class="jt"> cars.clear()。</em>它确实改变了列表的状态。编译器不知道不变性/只读。编译器关心的是，是否“E”作为参数被接收，所以编译器允许这个调用，同时改变列表。作为最佳实践，通常应避免此类呼叫。</li></ul><ol class=""><li id="9559" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js ls ld le lf bi translated">您可以传递null来代替“E”。因此调用cars.add(null)将实际编译(并将被执行)。</li><li id="0b7f" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">您可以使用强制转换来破解编译器(见上文)。所以，如果你真的想要<em class="jt">，你可以绕过类型安全编译器检查</em>。</li><li id="9119" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">您可以调用返回“E”的方法(我们从类型为“E”的对象中获取<strong class="iz hj">，这些<strong class="iz hj">方法具有协变的返回类型)</strong>。下面一行</strong></li></ol><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="15f4" class="ko kp hi kk b fi kq kr l ks kt">Car first = cars.get(0);</span></pre><p id="2a76" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完全有效。可以看到java.util.List.get(int)返回e。</p><p id="817c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译器害怕的是，你会用“错误的类型”来放置对象，比如<em class="jt"> cars.add(new Vehicle())。</em>同样，在运行时我们不能检查插入对象的类型和“E”(在java.util.List &lt; E &gt;中)是否一致。在编译时，编译器不能区分:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="765b" class="ko kp hi kk b fi kq kr l ks kt">Vehicle vehicle = new Car();<br/>cars.add(vehicle);   //should be ok, at runtime it is Car</span></pre><p id="d12f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="ce4f" class="ko kp hi kk b fi kq kr l ks kt">Vehicle vehicle = new Vehicle();<br/>cars.add(vehicle);   //should be rejected</span></pre><p id="6001" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这两种情况下，编译器看到类型Vehicle将要被插入到cars中。因此，编译器选择拒绝任何尝试(除了null)。</p><p id="ff40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们回到第15行。在第15行，我们调用java.util.List.iterator()方法。它返回迭代器<e>。那么，我们有了<strong class="iz hj">的协变</strong>列表，“E”就是<em class="jt">捕捉的第15-15个吗？延伸汽车。</em>因此，迭代器对象也应该使用与list相同的“E”进行参数化，即迭代器对于Car类型也是<strong class="iz hj">协变的</strong>。那到底是什么<em class="jt">迭代器&lt;？延伸车&gt; iter </em>的意思是。</e></p><p id="6511" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">java.util.Iterator有2个抽象方法:<em class="jt">布尔hasNext() </em>和<em class="jt"> E next()。</em>很明显，第一个方法是“独立于”E的，所以我们可以自由调用它。在next()方法中，我们从类型为的对象中获取<strong class="iz hj">，这个<strong class="iz hj">方法具有协变的返回类型，</strong>，因此可以调用它，并且我们可以断言我们将接收Car的实例。</strong></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="219d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，该谈谈<strong class="iz hj">逆变式了。</strong></p><p id="d8d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先从定义说起。鉴于一个<: b="" a="" is="" subclass="" of="" if="" t="" then="" class="iz hj">逆变在其型。</:></p><p id="14a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说例子。我将重构我们的SomeService。我会做以下的改变。我们将分两步进行重构。在第一步之后，我们将在第二步中修复代码中的一些错误。</p><p id="4685" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我将协变参数从列表 extends Car&gt;改为列表 extends Vehicle&gt;。如果你仔细观察，你会发现我们从cars中对item调用的唯一方法是<em class="jt"> getDriver() </em>这实际上是定义的Vehicle。我还将把本地变量名(和类型)从<em class="jt"> Car car </em>改为<em class="jt"> Vehicle vehicle </em>。</p><p id="3d9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将添加新的(重载的)方法，该方法将BiPredicate作为附加参数。旧方法将使用isEquals()实现，客户端将能够提供不同的实现。双预测在两个参数中都是逆变的。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="b868" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="3580" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在代码的第43行，有一个旧方法<em class="jt"> hasSameDriver() </em>，它的签名略有变化。在第44行，我们使用Java 8方法引用。现在，当comp.test()将被调用时，Lambda mechanic将调用<em class="jt"> SomeService.isEquals() </em>方法。这将确保this 1-parameter方法会像以前一样精确地比较列表中的项目。注意，当isEquals()接收2个java.lang.Object时，BiPredicate的赋值&lt;？超级司机，？超级驱动程序&gt;工作正常，因为BiPredicate在它的两个参数中是<strong class="iz hj">逆变</strong>，它<em class="jt">接受</em>驱动程序和所有it祖先(包括java.lang.Object)。</p><p id="7977" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际的实现被转移到新创建的双参数<em class="jt"> hasSameDriver() </em>方法<em class="jt">中。</em>列表&lt;中第一个参数的签名被更改？将轿厢&gt;延伸至列表&lt;？扩展了Vehicle &gt;，现在这个<strong class="iz hj">方法是<em class="jt">协变</em>在它的第一个参数与类型Vehicle </strong>列表中。第二个参数是BiPredicate，在它的两个参数中是<strong class="iz hj">逆变</strong>，它<em class="jt">接受</em>驱动程序和所有it祖先(包括java.lang.Object)。你能指出签名中的瑕疵吗？下面我给你解释一下。</p><p id="c575" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第17行，我添加了先决条件检查com不为空。在comp为null的情况下，我们实际上可以使用isEquals()。这是设计的选择。</p><p id="177c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有多个小的变化(车辆代替汽车，和变量名的变化)。主要的变化在第33行。它实际上被注释掉了。之前，我们简单地调用了我们的私有isEquals()方法，现在我们使用的是comp对象，它的两个参数是<strong class="iz hj">逆变</strong>。</p><p id="d071" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看客户端代码。注意，第7-20行没有改变。我提醒你，我们已经改变了“旧”方法的签名，现在它接收车辆及其祖先的列表，但是创建车辆列表的旧代码继续工作，没有改变。Vehicle <: car="" list=""> <: list="">，所以我们<em class="jt">扩展了【hasSameDriver()可以在其第一个参数中接收什么类型的对象。</em></:></:></p><p id="36a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看第22-29行。出于演示的目的，我写了Lamda表达式的SAM类型和参数的完整签名，在生产代码中，所有这些都可以省略。我这样做是为了演示我们可以将双预测<object object="">和双预测<driver driver="">作为第二个参数传递给<em class="jt"> hasSamedDriver() </em>方法。BiPredicate的实际实现是引用比较的捷径，只有当您只有几个驱动程序，并且没有创建新的驱动程序(例如，如果驱动程序是Singleton)并使用某种查找机制来找到合适的驱动程序(在Singleton的情况下是getInstance()静态函数)时，它在实际代码中才有用。</driver></object></p><p id="db94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第32–38行中的代码只是演示了当我们有不同的实例时代码可以工作。现在能识别出<em class="jt"> hasSameDriver </em>()方法签名中的问题吗？请看第33行的提示。</p><p id="4ec3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，有两个不同点需要考虑:</p><ul class=""><li id="71ca" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">我们允许像双预测<driver object="">这样的签名吗？也就是说当第一个和第二个参数不同时(但是一个是另一个的实例)？</driver></li><li id="3e3f" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">司机的祖先呢？我们也应该允许他们吗？换句话说，<em class="jt">是否有一个名称驱动</em>()在它的第二个参数中限制太多。</li></ul><p id="43dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，我们可能在某处定义了以下类:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="c253" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一点有些微妙。</p><p id="2a8a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们注意，像BiPredicate <driver car="">这样的东西，当我们有两个不相关的(在它们的继承树中)参数时是没有用的。我们不能比较不相关的例子。</driver></p><p id="9d85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<strong class="iz hj">它的一个参数是另一个参数的实例。</strong></p><p id="063a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们在Driver上也有一些继承层次，我们的<em class="jt"> hasSameDriver() </em>应该肯定能够使用它(提供适当的<em class="jt"> comp </em>对象)。</p><p id="4ca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了演示第二点，让我们考虑下面的代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="9040" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> Automate </em>与<em class="jt">不兼容？超级司机</em>。</p><p id="6f8f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，我们希望在两个参数中双预测为类型驱动程序的<strong class="iz hj">逆变，我们希望一个参数是另一个的实例，并且我们希望允许驱动程序的任何祖先被接受。也许我们在这里有些矛盾？让我们看看。这让我们想到了下面的签名:</strong></p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="c3a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">？超级T-表示逆变参数(两者)</p><p id="8d43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">t扩展了驱动程序的含义——我们也允许接收驱动程序的祖先。</p><p id="8745" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:最好有不同的类型，例如双指示符<driver object="">。参见下面的例子。</driver></p><p id="361c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们遇到了一些困难。如果你只改变了<em class="jt"> hasSameDriver() </em>的签名，代码将不会被编译。原因与编译器应该添加的重载方法和桥方法有关。编译器不知道是否要重写</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="499b" class="ko kp hi kk b fi kq kr l ks kt">boolean test(Object t, Object u)</span></pre><p id="2e67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="9a69" class="ko kp hi kk b fi kq kr l ks kt">boolean test(Driver t, Driver u)</span></pre><p id="25a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="8716" class="ko kp hi kk b fi kq kr l ks kt">boolean test(Automate, Automate u)</span></pre><p id="662e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它可以是这些中的任何一个。假设您有实现双向接口常规类。现在，这个类已经重载了<em class="jt">测试</em>()方法。这些方法中只有一个可以覆盖实际双预测方法。但它可以是这些中的任何一个。现在，当<em class="jt"> hasSameDriver()被</em>编译时，其中一个必须被静态链接。但是编译器不知道选择什么和如何选择。因此，在第23行，当我们调用对<em class="jt"> test </em>()方法的调用时，编译器将发出<strong class="iz hj">错误。</strong></p><p id="4513" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，在实践中，BiPredicate在大多数情况下将被实现为Lambda表达式。如果没有，实际上它仍然只有一个test()方法。所以，我们要对编译器说:“嘿，随便调用<em class="jt">任何</em> test()方法就行了”。因为，我们知道，只有1，一切都会按预期运行。</p><p id="cc9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果有人真的编写了重载的<em class="jt">测试</em>()方法。那么，在这种情况下，它们应该<em class="jt">兼容</em>在某种意义上，一个应该调用另一个(或做同样的事情)来获得适当的运行时类型，例如，参见Java . lang . timestamp . equals(Java . lang . object)和Java . lang . timestamp . equals(Java . lang . timestamp)⁰.如果实现的类是以这种方式设计的，它将“修正”编译器可能的错误选择，所以在这种情况下，我们可以在编译时只选择<em class="jt">任何</em> test()方法。</p><p id="14cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有人编写了重载的<em class="jt">测试</em>()方法，而这些方法在上述意义上是<em class="jt">不兼容的</em>，那么编译器是对的，我们什么也做不了。</p><p id="99e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们会假设双预言是“好的”，最好是Lamda表达式，而如果不是，我们会责怪给我们“不好的”实现的人。</p><p id="7a9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该把我们的决定通知编译器。代码如下:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="bc95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意第24–25行和第36行。我们正在对双预测<object object="">进行未检查的强制转换(它是未检查的，因为编译器无法在编译时验证它，所以它会发出警告；我们知道这一点，所以我们取消了第24行的警告)。我们使用这个编译时类型来调用test()方法。从技术上讲，编译器将寻找</object></p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="db3e" class="ko kp hi kk b fi kq kr l ks kt">boolean test(Object t, Object u)</span></pre><p id="963a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果只有一个名为test()的方法，带有两个参数，但是具有不同的签名，那么它将被解析为这个方法，这是没有问题的。如果有多个<em class="jt">不兼容</em>的，那么选择可能是错误的(我们刚刚抑制了来自编译器的警告)。</p><p id="5052" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，在实践中，这应该是可行的。</p><p id="f7ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看一下客户端代码:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="97ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第46行之前，这是旧代码，应该可以继续工作。</p><p id="159e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第46–48行，我们将驱动程序改为(唯一的)Automate。我们这样做是为了确保我们能够通过双认证<automate automate="">并且这将会起作用。这在第48–58行完成。</automate></p><p id="0a86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第60–62行演示了这种情况，我们用两个相关但不同的类型进行了双预测。该实现看起来像是人工的，因此，我将提供java.util.Calendar类的真实实现:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="177a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，<em class="jt">Java . util . GregorianCalendar</em>实现<em class="jt">Comparable&lt;Calendar&gt;</em>即<em class="jt"> compareTo() </em>在Calendar和Gregorian Calendar之间进行比较。它大致相当于:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="efd7" class="ko kp hi kk b fi kq kr l ks kt">BiPredicate&lt;GregorianCalendar, Calendar&gt; comp = (gregorianCalendar, calendar) -&gt; gregorianCalendar.compareTo(calendar)==0;</span></pre><p id="78fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，GregorianCalendar有compareTo()方法，该方法使用<strong class="iz hj">contra varain</strong>type Java . util . calendar进行比较(我们将在后面看到更多)。因此，在双预测中接收不完全相同的类型应该是合法的。</p><p id="0726" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第64–66行被注释掉，因为Car与Driver没有继承关系，并且我们有一个约束，即BiPredicate(两个)参数类型必须是Driver的实例。所以，这不是预期的编译。</p><p id="7029" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们看到的，声明某个类型为<strong class="iz hj">协变</strong>会对它施加一些限制。<strong class="iz hj">逆变</strong>类型有什么限制？</p><p id="c636" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:</p><ol class=""><li id="69b4" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js ls ld le lf bi translated">您可以调用任何不接收“E”作为参数的方法。</li><li id="5503" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">您可以传递null而不是“E”作为参数。</li><li id="1062" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">调用返回“E”的方法是<em class="jt">不好的做法</em>(我们应该只把<strong class="iz hj">放在</strong>的东西里)。下面一行</li></ol><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="2a32" class="ko kp hi kk b fi kq kr l ks kt">Car first = cars.get(0);</span></pre><p id="08f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不会编译。如果你真的想把东西拿出来，你可以写作</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="56a0" class="ko kp hi kk b fi kq kr l ks kt">Object first = cars.get(0);</span></pre><p id="d295" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将编译并运行。您在这里丢失了类型信息。</p><p id="dd88" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以写:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="b0d5" class="ko kp hi kk b fi kq kr l ks kt">Car first = (Car) cars.get(0);</span></pre><p id="eab7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是您可能会在运行时收到<strong class="iz hj"> ClassCastException </strong>(返回对象的类型是可用的)。</p><p id="64b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">逆变</strong>式应该只有<em class="jt">“消耗”“E”。</em>例如，Comparable &lt; E &gt;类型有接收参数类型的方法，但没有返回E的方法。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="205b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看<strong class="iz hj">协变</strong>和<strong class="iz hj">逆变</strong>类型的另一个例子。<em class="jt">可比&lt; E &gt;是</em>的例子<strong class="iz hj">逆变</strong>型(至少，是其本意)<strong class="iz hj">。让我们来看看它的定义:</strong></p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="d707" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据该定义，不清楚可比<e>的预期用途是作为<strong class="iz hj">逆变</strong>类型。正如你从<em class="jt"> GregorianCalendar </em>例子中看到的，它是<strong class="iz hj">逆变。</strong>让我们引用JEP 300:</e></p><blockquote class="lm ln lo"><p id="9df7" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">JEP 300:用声明站点默认值增加使用站点差异</p><p id="b3f1" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">增强Java编程语言，以便泛型类或接口声明可以指示每个类型参数在默认情况下是不变的、协变的还是逆变的，从而允许类或接口的参数化之间更直观的子类型关系。这补充了现有的差异机制，通配符，这是在类型使用站点编写的。</p></blockquote><p id="a446" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://openjdk.java.net/jeps/300" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/300</a></p><p id="ab86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，这个JEP仍然是唯一的候选人。截至2019年，该计划尚未实施。<em class="jt">使用地点差异</em>是我们目前看到的。客户代码，使用协变/逆变类型的代码声明我们希望它是协变/逆变的。</p><ul class=""><li id="04eb" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">双预测<t u="">本身是<strong class="iz hj">不变量</strong>。当我们声明它是双预测的时候？超T，？超T &gt;就变成了<strong class="iz hj">逆变</strong>。</t></li><li id="5635" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">列表<e>是<strong class="iz hj">不变量</strong>。列表&lt;？延伸车辆&gt;使其<strong class="iz hj">协变</strong>。</e></li><li id="38c2" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">列表<e>是<strong class="iz hj">不变的</strong>。列表&lt;？超级T &gt;使其<strong class="iz hj">逆变。</strong></e></li></ul><p id="4030" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java中没有办法在Comparable <e>类的定义类型中表达我们希望它被用作<strong class="iz hj">逆变</strong>类型。其他一些语言(Kotlin、Scala)确实有这样的特性。这就是所谓的<em class="jt">申报现场变动</em>。</e></p><p id="e4cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，Comparable <e>是Java中<strong class="iz hj">逆变</strong>类型的例子(但只在使用现场)。双预测&lt;？超T，？超T &gt;也是<strong class="iz hj">逆变。</strong></e></p><p id="5a64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表 extends Vehicle&gt;是<strong class="iz hj">的协变</strong>类型。</p><p id="2569" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java有<strong class="iz hj">协变</strong>方法返回类型。</p><p id="024d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表<e>在Java中是<strong class="iz hj">不变量</strong>。它实际上是在Generic添加之前添加到JDK的。正如我们前面讨论的，Kotlin和Scala有只读/不可变列表。他们不应该在被创造之后改变。你只能从中获得<strong class="iz hj">出</strong>的物品。在Java中我们有<em class="jt">Java . util . collections . unmodifieablelist(List&lt;？扩展T &gt;列表)。</em>它返回正则不变列表&lt; T &gt;，但是它覆盖了每一个打算做列表修改的方法(比如<em class="jt"> E set(int index，E element)) </em>，并抛出UnsupportedOperationException。所以，你有<em class="jt">运行时保护，只有修改</em>。</e></p><p id="08f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">列表&lt;？超级</em>车辆<em class="jt"> &gt;是</em> <strong class="iz hj"> <em class="jt">逆变</em> </strong> <em class="jt">型。</em></p><p id="7231" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个<: b="" a="" is="" subclass="" of="" if="" t="" then="" class="iz hj">在其类型中协变。</:></p><p id="6dc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想设计<strong class="iz hj">协变</strong>类型，你应该只有将<strong class="iz hj">放入</strong>这种类型的方法(比如<em class="jt"> add(E))，</em>，而不要有<em class="jt"> E get(int)这样的方法。</em></p><p id="04ac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个<: b="" a="" is="" subclass="" of="" if="" t="" then="" class="iz hj">逆变在其类型中。</:></p><p id="f2a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想设计<strong class="iz hj"> <em class="jt">逆变</em> </strong>类型，你应该只有从项中取出<strong class="iz hj">的方法(比如<em class="jt"> E get(int))，</em>，不要有<em class="jt"> add(E)这样的方法。</em></strong></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="4f7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看java.util.Collections中的(简化)函数。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5146" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从max()函数的签名可以看出，coll在T中是<strong class="iz hj">协变的</strong>，在同一个T中是<strong class="iz hj">逆变的</strong>。请注意，从技术上讲，您可以将签名更改为</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="b206" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;T&gt; comp)</span></pre><p id="aeaa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者去</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="4961" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T&gt; T max(Collection&lt;T&gt; coll, Comparator&lt;? super T&gt; comp)</span></pre><p id="9889" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">证据是:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="fcc8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有这个重载版本:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="b1f6" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) </span></pre><p id="4ddd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个版本是等效的(从JDK 8开始，JDK 5.0实际上需要显式约束t来对象⁴):</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="f5a7" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? <br/>extends T&gt; coll)</span></pre><p id="766b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也相当于:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="ceb6" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(Collection&lt;T&gt; coll)</span></pre><p id="408e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一个更有趣的函数<em class="jt"> copy() </em>。<em class="jt"> </em>下面是它的简化实现:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="8d69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里src是<strong class="iz hj">协变</strong>(实际上，我们是从项中获取<strong class="iz hj">，dest是<strong class="iz hj">逆变(</strong>它的作用类似于sink，它也<em class="jt">消耗</em>项<em class="jt">)。</em></strong></p><p id="3aad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个版本相当于:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="ae86" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T&gt; void copy1(List&lt;? super T&gt; dest, List&lt;T&gt; src)</span></pre><p id="82ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也相当于:</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="5f86" class="ko kp hi kk b fi kq kr l ks kt">public static &lt;T&gt; void copy2(List&lt;T&gt; dest, List&lt;? extends T&gt; src) </span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="b179" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现了关于方差和逆变的很好的总结:</p><blockquote class="lm ln lo"><p id="93be" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">珍指出，在《暮光之城》系列小说中，所谓的“狼人”(他们不会在满月时变形，因此实际上不是狼人)以狼和人的形式维持着他们严格的社会秩序；在社会秩序关系中，人到狼的投射是协变的。她还指出，在高中，编程语言极客处于社会秩序的最底层，但对成年的预测将他们推上了社会秩序的顶端，因此，成长是矛盾的。我对后一种说法有些怀疑；前者，我相信你的话。我想社会秩序如何在青少年狼人中运作的问题是一个额外研究的主题。</p></blockquote><p id="1dd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://blogs.msdn.microsoft.com/ericlippert/2009/11/30/whats-the-difference-between-covariance-and-assignment-compatibility/" rel="noopener ugc nofollow" target="_blank">https://blogs . msdn . Microsoft . com/ericlippert/2009/11/30/what-the-difference-between-co variance-and-assignment-compatibility/</a></p><p id="9900" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">脚注:</em></p><p id="fe2d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以将第一行写成</p><pre class="jv jw jx jy fd kj kk kl km aw kn bi"><span id="3337" class="ko kp hi kk b fi kq kr l ks kt">Integer one=1;</span></pre><p id="109d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且将使用自动装箱功能(在Java 5.0中添加)，它实际上相当于Integer.valueOf(1)。截至2019年<a class="ae ju" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">瓦尔哈拉项目</a>仍在进行中。</p><p id="2d1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次，<a class="ae ju" href="https://openjdk.java.net/jeps/169" rel="noopener ugc nofollow" target="_blank"> JEP 169 </a>仍在进行中。</p><p id="53c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们走进<em class="jt"/>polymorphism⁵之前，我们先来简单说说<em class="jt">的传承</em>。<br/>在面向对象编程中，继承是将一个类建立在另一个类的基础上，保留类似实现的机制。也定义为从现有的类(超类或基类)派生出新的类(子类)并将它们组成类的层次结构。</p><p id="4ed6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几种机制可以实现<em class="jt">继承。</em>以C++为例，使用虚拟表实现。简而言之，<em class="jt">c++中的每个类都是struct的扩展——它有字段(也称为数据成员)和方法(编译成常规函数)。</em>数据成员集合定义了对象的<em class="jt">状态</em>。<em class="jt"> </em>每个类都有关联的v表，编译器用来确定调用哪个方法。虚拟表是在编译时填充的，每次新的类被添加到继承层次结构中时，v表的内容都会改变。不能在类外调用的方法定义了类的<em class="jt">行为</em>。</p><p id="1b6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中实现机制是不同的。Java对多重继承的支持非常有限，也就是从多个基类继承。在Java中你可以实现多个接口(从Java 8开始可以有方法体，但不能包含状态)，但你只能从一个类扩展(此外每个类都是直接或间接从java.lang.Object扩展而来；在C++中没有这样的基类)。为了使事情更简单，我将只关注类，忽略接口。</p><p id="4a6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java中的每个对象都有关联的类。类是您正在编写的代码，创建对象的<em class="jt">收据</em>。在运行时，JVM创建表示对象“元数据”的java.lang.Class对象，这是收据的运行时表示。</p><p id="b6d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您在object⁴上调用方法时，JVM会查找具有您提供的名称和编译器从您的调用中推断出的签名的方法(类型推断超出了本文的范围)。如果在与该对象关联的java.lang.Class定义中找到这样的方法，则调用它。如果找不到方法，就在基类(这个类的超类)上查找。这个过程会不断重复，直到我们到达java.lang.Object(最终，我们会到达),如果找不到这个方法，就会出现运行时错误(java.lang.NoSuchMethodError)。</p><p id="e5c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述算法的伪代码如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="f117" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个简化版来自<a class="ae ju" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java" rel="noopener ugc nofollow" target="_blank">https://github . com/spring-projects/spring-framework/blob/master/spring-core/src/main/Java/org/spring framework/util/reflection utils . Java</a>。您可以查看考虑到接口并具有各种性能改进的实际实现。</p><p id="ba53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">独立于实际的实现机制，大多数面向对象语言中的继承实际上意味着通过继承创建的对象(“子对象”)获得父对象的所有属性和行为(除了:基类的构造函数、析构函数、重载运算符和友元函数)。继承允许程序员创建基于现有类的类，指定新的实现同时保持相同的行为(实现接口)，重用代码以及通过公共类和接口独立扩展原始软件。通过继承的对象或类的关系产生了一个有向图。继承是1969年为Simula发明的。</p><p id="d0ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继承的类被称为它的父类或超类的子类。</p><p id="6d51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不应将继承与子类型混淆。在一些语言中，继承和子类型是一致的，[这通常只在静态类型的基于类的OO语言中成立，比如C++、C#、Java和Scala]，而在其他语言中则不同；一般来说，<strong class="iz hj">子类型化建立的是一种is-a关系</strong>，而<strong class="iz hj">继承只是重用了实现</strong>，建立了一种句法关系，不一定是语义关系(继承并不能保证行为子类型化)。</p><p id="08ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继承与对象组合相反，在对象组合中，一个对象包含另一个对象(或者一个类的对象包含另一个类的对象)；<strong class="iz hj">组合实现了has-a关系</strong>，与子类型的is-a关系形成对比。</p><p id="d2d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以通过委托实现继承。这有时被称为委托模式。你将你的基类存储为数据成员，你在你的子类中定义所有属于你的基类API的方法，当这样的方法被调用时，你只需将调用转发给数据成员。下面是一个例子:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><ul class=""><li id="20d2" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated"><a class="ae ju" href="https://en.wikipedia.org/wiki/Kotlin_%28programming_language%29" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>在语言语法中包含了委托模式。</li><li id="5cc3" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">Java提供了<a class="ae ju" href="http://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Project Lombok </a>，它允许在字段上使用单个@Delegate注释来实现委托，而不是复制和维护委托字段中所有方法的名称和类型。</li></ul><p id="5327" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁴这就是所谓的<em class="jt">单分派</em>；当你基于单个对象查找你的方法时，这个对象通常是这样引用的(在其他语言中是self)。</p><p id="cb14" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁵ <em class="jt">多态</em>是<a class="ae ju" href="https://beginnersbook.com/2013/04/oops-concepts/" rel="noopener ugc nofollow" target="_blank"> OOPs </a>特性之一，它允许我们以不同的方式执行一个动作。术语“多晶型”是指“具有多种形式”Java中的多态性简化了编程，因为它在经历子类化的严格过程时提供了一个具有多种含义的单一接口。</p><p id="bccd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a8fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上例中的obj是多态对象，它可以有两种变形。它可以被视为马(实际上，在运行时，在JVM中，它是<em class="jt">实际上是</em>马)，但它也可以被视为动物(实际上，在编译时，编译器将它称为动物)。因为马<strong class="iz hj">是一种</strong>动物，马包含动物的每个公共方法的签名。因此，编译器可以像处理Horse一样处理它，但是在运行时，它将被切换到Horse(字节码的考虑超出了本文的范围)。这样的对象替换不应该中断我们的程序。这就是所谓的<a class="ae ju" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原理</a>。</p><p id="4843" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁶直到Java 9它都是由char[]，<a class="ae ju" href="http://openjdk.java.net/jeps/254" rel="noopener ugc nofollow" target="_blank"> JEP 254: Compact Strings </a>改变字符串的内部值，但是API保持不变。</p><p id="0293" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，⁷在运行时会抛出ArrayStoreException。为什么？这是从C++中吸取的教训，添加到java数组中的防御机制。为了理解为什么这种防御机制是必要的，让我们假设他不在，那么下面的代码将是合法的:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="eed8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经讨论到第3行了。现在，让我们假设数组中没有守卫检查(例如，在C++中就是这样)。那么第3行将成功执行。在第4行我们可以看到一些奇怪的事情:汽车数组包含了一些不是汽车的东西。好了，这意味着我们已经骗过了编译器。第5行演示了为什么这是个坏主意。编译器认为cars[0]包含car实例，所以第5行编译成功。我们已经设计出了编译器，现在，有摩托车(在我们的代码中不是汽车)的代码。当JVM在运行时试图解析对someCarMethod()的调用时，它将失败。在C++中，你会在这里看到著名的s <em class="jt"> egmentation错误</em>。问题的根本原因不是第5行，而是第3行，在那里我们将not car实例放入car的数组。所以在Java中，运行时检查被加入。</p><p id="8be3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还要注意，每次使用括号操作符(通过index，[])访问数组时，还要检查索引是否大于0且小于数组的长度(对于空数组，总是会抛出异常)。</p><p id="d572" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁸这是有点问题的，也许IllegalArgumentException甚至NullPointerException更好。</p><p id="b215" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁹:这是优化，因为如果我们取消检查数组的长度是否为0，代码仍将返回0(它不会进入循环，sum用0初始化，这将被返回)，但这将需要更长的路径(这将花费更多的时间)。</p><p id="2123" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁰:如果这是生产代码，我会使用“for-each”迭代。出于演示目的，我使用了显式代码。</p><p id="115f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个“for-each”特性是在5.0版本中添加到Java中的。如何生成代码取决于编译器。注意，如果数组为空，那么将抛出NullPointerException。还要注意，我们获得了一些代码抽象，但我们丢失了一些信息，我们可以访问数组中的每个元素，但我们不知道它们的索引。在我们的例子中，这个信息并不重要。</p><p id="db43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有些int不能保证在int范围内；大于整数的值。如果我们把MAX_VALUE看作int值，它就被解释为负值，如果看作long值，它就被解释为大正值。</p><p id="01bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从概念上讲，<strong class="iz hj">方法重载</strong>就是<a class="ae ju" href="https://beginnersbook.com/2013/04/runtime-compile-time-polymorphism/" rel="noopener ugc nofollow" target="_blank">静态多态</a>。你可以在这里阅读<a class="ae ju" href="https://www.scientecheasy.com/2019/02/method-overloading-in-java.html" rel="noopener ugc nofollow" target="_blank">关于这一点的</a>很好的解释。真正的规则相当复杂，你可以在这里找到它们</p><p id="0c4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁴编译器将检查方法是否被覆盖，否则将产生编译时错误。此注释是在JDK 5.0 ⁶.中添加的</p><p id="c434" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁵<a class="ae ju" href="http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html" rel="noopener ugc nofollow" target="_blank">Java bridge methods explained</a>是一篇值得一读的好文章。简而言之，它是编译器添加的合成方法。</p><p id="03fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意</em>:这个方法不仅可以为另一个方法做调用转移，还可以返回<em class="jt">类型适配</em>比如强制转换(参见<a class="ae ju" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#cast-java.lang.Object-" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/lang/class . html # cast-Java . lang . object-</a>)或者装箱/拆箱。</p><p id="b083" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">旁注</em> : <a class="ae ju" href="https://stackoverflow.com/a/21102448/1137529" rel="noopener ugc nofollow" target="_blank">方法签名中的Volatile</a>——当你使用反射或一些反编译工具时，你会遇到这种情况。</p><p id="0383" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">java平台总是有各种各样的特别注释机制。例如,<code class="du ku kv kw kk b">transient</code>修饰符是一个特别的注释，指示一个字段应该被序列化子系统忽略，而<code class="du ku kv kw kk b">@deprecated</code> javadoc标签是一个特别的注释，指示该方法不应该再被使用。从5.0版本开始，该平台有一个通用注释(也称为<em class="jt">元数据</em>)工具，允许您定义和使用自己的注释类型。该工具由声明注释类型的语法、注释声明的语法、读取注释的API、注释的类文件表示和注释处理工具(apt)组成。从5.0版本的<a class="ae ju" href="https://en.wikipedia.org/wiki/Java_Development_Kit" rel="noopener ugc nofollow" target="_blank"> Java开发工具包</a> (JDK)开始，注释在语言本身中变得可用。<code class="du ku kv kw kk b"><a class="ae ju" href="https://en.wikipedia.org/wiki/Annotation_processing_tool" rel="noopener ugc nofollow" target="_blank">apt</a></code> <a class="ae ju" href="https://en.wikipedia.org/wiki/Annotation_processing_tool" rel="noopener ugc nofollow" target="_blank">工具</a>为JDK版本5.0中的编译时注释处理提供了一个临时接口；JSR-269对此进行了形式化，并在版本6中集成到了<a class="ae ju" href="https://en.wikipedia.org/wiki/Javac" rel="noopener ugc nofollow" target="_blank"> javac </a>编译器中。</p><p id="b377" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁷Quote: <em class="jt">类型擦除可以被解释为仅在编译时强制类型约束并在运行时丢弃元素类型信息的过程。</em><a class="ae ju" href="https://www.baeldung.com/java-type-erasure" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-type-erasure</a></p><p id="cf7b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多详细解释请见上面的链接。特别有趣的是用桥⁵方法解决的边界情况。</p><p id="cedd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注:</em>截至2019年<a class="ae ju" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">瓦尔哈拉项目</a>仍在进行中。</p><p id="9845" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:</em> <code class="du ku kv kw kk b"><a class="ae ju" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="noopener ugc nofollow" target="_blank">JLS8 §4.6</a> </code>在一些非常特殊的情况下，提供一些循环孔，用于在运行时检索泛型类型信息。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="d353" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意clazz.getGenericSuperclass()的用法。您可以利用这一点:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e06d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用匿名类来捕获泛型类型信息，而不是使用显式类定义。在字节码级别，它实际上是在类定义的签名中捕获的。详见<a class="ae ju" href="https://helw.net/2017/11/09/runtime-generics-in-an-erasure-world/" rel="noopener ugc nofollow" target="_blank">https://helw . net/2017/11/09/runtime-generics-in-a-erasure-world/</a>。com . Google . gson . reflect . type token是利用这一事实的标准事实。</p><p id="a502" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">旁注:</em>在JDK 5.0中，在&lt;类旁边增加了类型层次？&gt;。类型是编译类型构造。在运行时有原始类型(建模为类&lt;？&gt;)、参数化类型、数组类型、类型变量、原语类型。这两者有着非常复杂的关系，Gson库试图为程序员简化。它还有API来动态创建类型的实例。</p><p id="e253" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引用:</p><blockquote class="lm ln lo"><p id="c825" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">Java的类型擦除适用于单个对象，<strong class="iz hj">而不是类</strong>或字段或方法。TypeToken使用一个匿名的<strong class="iz hj">类来确保它保存泛型类型信息</strong>，而不仅仅是创建一个对象。</p></blockquote><p id="8f43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://stackoverflow.com/questions/30005110/how-does-gson-typetoken-work" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/30005110/how-gson-type token-work</a></p><p id="4e4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一句话</p><blockquote class="lm ln lo"><p id="09c8" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">总之，java语言规范<a class="ae ju" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="noopener ugc nofollow" target="_blank">指定了</a>参数化类型、嵌套类型、数组类型和类型变量的擦除类型是什么。然后它说“每一个其他类型的擦除是类型本身。”</p></blockquote><p id="77cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://helw.net/2017/11/09/runtime-generics-in-an-erasure-world/" rel="noopener ugc nofollow" target="_blank">https://helw . net/2017/11/09/runtime-generics-in-a-erasure-world/</a></p><p id="c6c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于<a class="ae ju" href="https://stackoverflow.com/a/33738910/1137529" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/33738910/1137529</a>⁸<br/>的不变性类型:</p><ol class=""><li id="96a6" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js ls ld le lf bi translated">可变——你应该改变集合(科特林的<code class="du ku kv kw kk b">MutableList</code>)</li><li id="e943" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">readonly——你不应该改变它(Kotlin的<code class="du ku kv kw kk b">List</code>),但是有些东西可以改变(转换成Mutable，或者从Java改变)</li><li id="11a7" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js ls ld le lf bi translated">不可变——没有人能改变它(Guavas的不可变集合，Scala的不可变集合)</li></ol><p id="16a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在第(2)种情况下，<code class="du ku kv kw kk b">List</code>只是一个没有变异方法的接口，但是如果你把它转换成<code class="du ku kv kw kk b">MutableList</code>，你可以改变实例。</p><p id="1b4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Guava或Scala(第三种情况)，任何人都可以安全地更改集合，即使是通过强制转换或其他线程。</p><p id="12f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kotlin选择readonly是为了直接使用Java集合，所以在使用Java集合时没有开销或转换。</p><p id="2b7a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意</em> : Kotlin <code class="du ku kv kw kk b">List</code>是只读的，不是不可变的。其他调用者(例如Java)可能会更改列表。Kotlin调用者可能会转换列表并更改它。没有一成不变的保护。</p><p id="5ea8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里阅读<a class="ae ju" href="https://stackabuse.com/javas-object-methods-equals-object/" rel="noopener ugc nofollow" target="_blank">https://stackabuse.com/javas-object-methods-equals-object/</a>的简短解释或者直接阅读<a class="ae ju" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-" rel="noopener ugc nofollow" target="_blank"> java doc </a>。</p><p id="50c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⁰ <a class="ae ju" href="https://docs.oracle.com/javase/8/docs/api/java/sql/Timestamp.html" rel="noopener ugc nofollow" target="_blank"> java.sql.Timestamp </a>有一个bug (java.sql.Timestamp继承自java.util.Date)，它有方法equals(时间戳)和not equals(对象)。由于向后兼容性问题，此方法破坏了相对于<code class="du ku kv kw kk b">java.util.Date.equals(Object) </code>的对称性。如果传递的对象确实是Timestamp的实例，并且如果传递的对象不是Timestamp的实例(例如，它是java.util.Date ),则返回false。让我们看看一些代码示例，看看问题出在哪里:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="9971" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:java.util.Date以毫秒为单位存储“日期”。java.sql.Timestamp具有纳秒精度(为了达到这一精度，它添加了nanos)。</p><p id="202f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很明显，我们正在用相同的底层值(时间)构造java.util.Date和java.sql.Timestamp。因此，我们期望equals()将返回true。</p><p id="130a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，在第14行中，我们验证了d和ts都是java.util.Date的实例，展开底层时间值并进行比较。</p><p id="c8eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在第15行，我们得到了意想不到的结果。这里调用equals(Object)。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="9f7f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为d不是java.sql.Timestamp的实例，所以它返回false。</p><p id="2dfe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以尝试将实现更改为如下形式:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="54c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，如果ts不是时间戳的实例，我们将检查委托给ts本身。如果是java.util.Date，则会调用java.util.Date.equals(Object)。这种实现中问题是，时间放大器的附加场在这种比较中将被忽略。因此，如果我有两个相差不到1毫秒的“日期对象”，那么java.util.Date.equals(Object)将返回true，这在语义上是错误的。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a790" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，equals()方法将ts和d视为相等，尽管事实上它们在纳秒级别上明显不同(这对时间戳有明显的影响)。同样，这在语义上是错误的。最好打破equals()对称。</p><p id="5a5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引用自<a class="ae ju" href="https://docs.oracle.com/javase/8/docs/api/java/sql/Timestamp.html" rel="noopener ugc nofollow" target="_blank">时间戳的java文档</a>:</p><blockquote class="lm ln lo"><p id="56f5" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意:</strong>这个类型是一个<code class="du ku kv kw kk b">java.util.Date</code>和一个单独的纳秒值的组合。只有整数秒存储在<code class="du ku kv kw kk b">java.util.Date</code>组件中。小数秒-纳米-是分开的。当传递一个不是<code class="du ku kv kw kk b">java.sql.Timestamp</code>实例的对象时，<code class="du ku kv kw kk b">Timestamp.equals(Object)</code>方法从不返回<code class="du ku kv kw kk b">true</code>，因为日期的nanos部分是未知的。结果，<code class="du ku kv kw kk b">Timestamp.equals(Object)</code>方法相对于<code class="du ku kv kw kk b">java.util.Date.equals(Object)</code>方法不对称。此外，<code class="du ku kv kw kk b">hashCode</code>方法使用底层的<code class="du ku kv kw kk b">java.util.Date</code>实现，因此在其计算中不包括nanos。</p><p id="55fe" class="ix iy jt iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">由于上面提到的<code class="du ku kv kw kk b">Timestamp</code>类和<code class="du ku kv kw kk b">java.util.Date</code>类之间的差异，建议代码不要将<code class="du ku kv kw kk b">Timestamp</code>值视为<code class="du ku kv kw kk b">java.util.Date</code>的实例。<code class="du ku kv kw kk b">Timestamp</code>和<code class="du ku kv kw kk b">java.util.Date</code>之间的继承关系实际上表示实现继承，而不是类型继承。</p></blockquote><p id="20a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只有一种方法可以避免上面描述的混乱。<em class="jt">不要重载</em> equals(Object)方法，只有<em class="jt">重载</em>它。</p><p id="4fdf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我看到过一些讨论，把这个警告默认为错误。从JDK 5.0版本开始已经过去很久了。这显然破坏了向后兼容性，因此在此基础上拒绝了它。</p><p id="ccb2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">允许Null，因为null是捕获#15-of的实例。扩展Car  (null是Java中任何类型的实例)。</p><p id="27c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以阅读从Lambdas到字节码的Lambda机制<a class="ae ju" href="http://wiki.jvmlangsummit.com/images/1/1e/2011_Goetz_Lambda.pdf" rel="noopener ugc nofollow" target="_blank">和Lambda表达式的翻译</a><a class="ae ju" href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html" rel="noopener ugc nofollow" target="_blank">尤其是你可能对“方法引用捕获”小节感兴趣。</a></p><p id="457a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JDK-6785114:返回类型推断(15.12.2.8)对自动装箱不起作用类型:增强，组件:规范，受影响版本:7。正如你所看到的，JDK 7的规范改变了返回类型中对象的使用。你可以在<a class="ae ju" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6785112" rel="noopener ugc nofollow" target="_blank"> JDK-6785112 : Umbrella:泛型方法类型推断的问题</a>上找到其他的修复方法。如果你使用JDK 8和更新版本，这些错误对你来说只有历史意义。</p></div></div>    
</body>
</html>
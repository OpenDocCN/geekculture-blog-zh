<html>
<head>
<title>Node:CRUD examples to demonstrate using a reusable helper function to execute promises in sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node:CRUD示例，演示如何使用可重用的helper函数按顺序执行承诺</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/node-mon-crud-examples-to-demonstrate-using-a-reusable-helper-function-to-execute-promises-in-df9c5f2b8c8b?source=collection_archive---------9-----------------------#2022-05-17">https://medium.com/geekculture/node-mon-crud-examples-to-demonstrate-using-a-reusable-helper-function-to-execute-promises-in-df9c5f2b8c8b?source=collection_archive---------9-----------------------#2022-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b6db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开发一个节点应用程序时，我遇到了多个任务必须按顺序执行的场景。我想把它们分类如下:</p><ol class=""><li id="df0f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">任务1和任务2顺序执行，在数据方面彼此不依赖，即任务2不需要任务1的执行产生的结果来执行。</li><li id="4e01" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Task-1和Task-2按顺序执行，但Task-2只能在Task-1执行产生结果后执行。</li></ol><p id="fde8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一种情况下，我更喜欢使用一个通用的助手函数，它将按顺序执行任务，并减少控制器中的代码行。</p><p id="1ae8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第二种情况下，公共助手函数是没有用的。我们需要使用<strong class="ih hj">然后捕捉块</strong>或<strong class="ih hj">等待异步方法</strong>。</p><p id="197d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过一个例子来探讨这两种情况。</p><p id="e1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是节点应用程序的结构。对于所有的CRUD操作，节点应用程序与NoSQL数据库MongoDB通信。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/6a74122c375f1c891bb16df43e9f2cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-o6ddGd-liSFRwQCMf66g.png"/></div></div></figure><ol class=""><li id="1d5e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">路线文件夹</strong>包含每个集合的路线文件。每个文件包含一个路由器，它接收来自客户端的HTTP请求。</li><li id="6bbe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">HTTP请求被转发到<strong class="ih hj">控制器文件夹</strong>中的适当控制器。</li><li id="354b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">控制器调用<strong class="ih hj">服务文件夹</strong>中的适当服务来执行任何查询。响应由服务返回给控制器。</li></ol><p id="2af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj">服务</strong>的目的是为了跨多个控制器重用查询。这确保了两个控制器不会相互通信，也不会增加复杂性。</p><p id="bc10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.控制器将响应返回给更新视图的客户端(例如:Angular、React等)。</p><p id="1172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从<strong class="ih hj"> userRouter.js </strong>开始。这个文件实际上包含了许多路线，但是为了简单起见，我在下面的要点中只包含了一条路线来演示这两个场景。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="cecb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有2个集合:<strong class="ih hj">用户和帖子</strong>。用户可以创建帖子，检索用户创建的所有帖子，还可以删除用户创建的所有帖子。</p><p id="7c21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些动作在<a class="ae kf" href="http://localhost:3000/user/:userId/posts" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">http://localhost:3000/user/:userId/posts</strong></a>路由下处理。在这个路径下，我们已经定义了将为每个HTTP请求类型(即GET、PUT、POST和DELETE)调用的控制器方法。</p><p id="85bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集合的结构在这里并不重要，但是它可以更好地理解任务在每个场景中将做什么。</p><p id="ba8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是帖子集中一个<strong class="ih hj">文档的截图。</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kg"><img src="../Images/e3a818f8f70e8bb138af43bd9bcfc03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*qF55oNJpaFb2Xsxp5fNFTQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Document in the Posts collection</figcaption></figure><p id="4a4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是用户集合中一个<strong class="ih hj">文档的截图。</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kl"><img src="../Images/dd8e2e067222fcde9b9dcf033dee2d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*dfKRCAEuthxyN26DAHBWKA.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Document in the Users collection</figcaption></figure><p id="d7ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一、<strong class="ih hj">场景-1 </strong>:任务-1和任务-2相互独立但顺序执行</p><p id="eb8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DELETE方法就是这种情况的一个例子。我们需要执行2个步骤来删除用户创建的所有帖子。</p><p id="933f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;从posts集合中删除与用户相关的所有帖子。</p><p id="ed15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;我们将用户创建的所有帖子的引用存储在用户集合中名为<strong class="ih hj">帖子</strong>的字段(sql中的列)中。您可以在Users集合中的文档截图中看到该字段。</p><p id="50bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，帖子字段是用户创建的所有帖子的引用数组。我们需要将用户集合中的posts字段设置为[]。</p><p id="f5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> userController.js </strong>是处理来自<strong class="ih hj"> userRouter.js中所有路由的所有HTTP请求的控制器文件。</strong>正如我们在路由器文件中看到的，<strong class="ih hj"> deleteAllPostsOfUser() </strong>是处理路由的删除请求的控制器方法。</p><p id="7fd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> deleteAllPostsOfUser() </strong>控制器方法中有很多代码，但是大部分超出了本文的范围。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="9aeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我只捕获了控制器方法<strong class="ih hj"> deleteAllPostsOfUser()的相关部分。</strong>我们使用了一个公共的帮助器函数<strong class="ih hj">executetaksinsinsequence()</strong>来按顺序执行这两个任务。这两个任务实际上是在<strong class="ih hj"> UserService.js </strong>文件中定义的方法，与我们无关。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="df34" class="kr ks hi kn b fi kt ku l kv kw">try{<br/>let result=await <strong class="kn hj">executeTasksInSequence</strong>([ <strong class="kn hj">removeAllPostsOfUser</strong>(req.params.userId,opts), <strong class="kn hj">updateUser</strong>(req.params.userId,{“posts”:[]},opts) <br/>]);<br/>}<br/>catch(e){      <br/>console.log("Some error in the transaction.Aborting it");         <br/><strong class="kn hj">return next(e);</strong>    <br/>}</span></pre><p id="956d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看<strong class="ih hj"> utility.js </strong>中定义的助手函数。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="09d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法接受按顺序执行的任务数组。每个任务都有一个承诺。该方法使用<strong class="ih hj"> reduce方法</strong>按顺序执行它们，并将每个任务的响应连接成一个数组。这个按顺序包含所有任务响应的数组被返回给控制器，以进行进一步的操作。</p><p id="e6b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是来自邮递员的回复截图。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kx"><img src="../Images/954b0f3f4b392680763f37187023ddef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeqK5Bt6Zg1bAiaoWR2kDw.png"/></div></div></figure><p id="b366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任务执行期间发生的任何错误都将在catch块中被捕获。catch块将再次引发错误。这个错误将最终在控制器方法的catch块中被捕获，并返回给客户端。如果其中一个任务失败，那么下一个任务就不会执行。</p><p id="b020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二。<strong class="ih hj">场景二</strong>:任务二的执行取决于任务一的执行结果。</p><p id="9105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">POST方法就是这种场景的一个例子，用户创建一篇文章。该任务的两个步骤是:</p><p id="ede8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在Posts集合中创建一个post文档。</p><p id="f70d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;用创建的帖子的引用更新用户集合中用户文档的<strong class="ih hj">帖子字段</strong>。</p><p id="c8bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤2需要完成步骤1。为了用创建的帖子的引用更新用户文档，我们首先需要创建帖子。</p><p id="0ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在<strong class="ih hj"> userRouter.js </strong>中提到的，POST请求由<strong class="ih hj"> createPost() </strong>控制器方法处理。</p><p id="ac78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这个方法有很多超出本文范围的代码。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="4d67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只捕获代码的相关部分。我们使用了<strong class="ih hj"> await和async </strong>方法来依次执行这两个任务。</p><pre class="js jt ju jv fd km kn ko kp aw kq bi"><span id="3971" class="kr ks hi kn b fi kt ku l kv kw">await executeTransaction(<strong class="kn hj">async</strong>(session)=&gt;{<br/>try{<br/><strong class="kn hj">let newPost=await createPost(payload,opts);</strong></span><span id="dada" class="kr ks hi kn b fi ky ku l kv kw"><strong class="kn hj">let updatedUser=await updateUserArray({“_id”:req.params.userId},{$push:{“posts”:newPost[0]._id}},opts);</strong><br/>}</span><span id="aa87" class="kr ks hi kn b fi ky ku l kv kw">catch(e){ <br/>console.log(“Caught in the controller catch block”); <br/><strong class="kn hj">return next(e)</strong> <br/>}<br/>})</span></pre><p id="c570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">newPost 是在Posts集合中创建的Post文档。我们使用<strong class="ih hj"> newPost </strong>将Post文档的引用推送到<strong class="ih hj">用户文档</strong>的<strong class="ih hj"> posts字段</strong>中。</p><p id="89bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建这个节点应用程序对我来说是一次很好的学习经历。</p><p id="b868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这个故事对你也有用。</p><p id="10cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以查看下面的完整代码。</p><div class="kz la ez fb lb lc"><a href="https://github.com/ramya22111992/NodeMongoDBOperations" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab dw"><div class="le ab lf cl cj lg"><h2 class="bd hj fi z dy lh ea eb li ed ef hh bi translated">GitHub-ramya 22111992/NodeMongoDBOperations:试图在此涵盖所有可能的MongoDB操作</h2><div class="lj l"><p class="bd b fp z dy lh ea eb li ed ef dx translated">github.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp kb lc"/></div></div></a></div></div></div>    
</body>
</html>
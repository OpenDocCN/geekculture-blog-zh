<html>
<head>
<title>React Development for Senior Developers — From a Product Point of View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从产品的角度，为高级开发人员开发React</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-development-for-senior-developers-from-a-product-point-of-view-37cfcecf28de?source=collection_archive---------26-----------------------#2021-07-04">https://medium.com/geekculture/react-development-for-senior-developers-from-a-product-point-of-view-37cfcecf28de?source=collection_archive---------26-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cf9211e0b54b145606effb38f937c57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b4sLS-huGEfRT929"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Source: Unsplash</figcaption></figure><p id="5da0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您已经开发了一个React应用程序，并且很高兴它运行得非常好。您已经实现了您的逻辑，您已经创建了足够数量的组件，您已经有了在后端运行的节点服务，数据绑定进行得非常好，并且在您的UI上呈现了许多很酷的视觉上吸引人的东西。</p><p id="a091" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是接下来呢？你以为你的发展结束了吗？</p><p id="f289" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">哈哈哈..答案是一个大大的否定。</p><p id="a976" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从产品的角度考虑，老兄！！你真的认为这是你要给客户的最终产品吗？好吧，让我说，仍然有一些伟大的事迹留下来，在这篇文章中，我将简要地解释在你的代码创建之后你应该执行的那些重要的阶段。</p><blockquote class="js jt ju"><p id="4abc" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">请注意，我不会对每个阶段进行更深入的挖掘，因为已经有现成的官方文档可以为您提供关于如何实现它们的更详细的信息。我还在整篇文章中给出了一些<strong class="iw hj">超链接</strong>，以便引导你找到正确的来源。</p></blockquote><p id="29c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，调整一下你的座位，喝杯咖啡，我们开始吧。</p><h1 id="b280" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak"> 1。单元测试</strong></h1><p id="de77" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">作为开发人员，测试我们创建的每个组件是我们的工作。React带有<a class="ae lc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为它的测试运行程序，特别是当你使用<a class="ae lc" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create-React-App </a>创建样板文件时。虽然web上有其他免费的测试框架，如Mocha和Karma，但大多数react开发人员都喜欢使用Jest，因为它的高性能和易用性。用Jest对你的组件进行单元测试有多种方法，最简单的是<a class="ae lc" href="https://jestjs.io/docs/snapshot-testing" rel="noopener ugc nofollow" target="_blank">快照测试</a>。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/a635294b26a9e86f8032bb96cc1493a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/0*QYWDIwfpanuVqIAt"/></div></figure><p id="8abc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个典型的快照测试用例呈现一个UI组件，获取一个快照，然后将它与测试旁边存储的一个参考快照文件进行比较。如果两个快照不匹配，测试将失败:要么是<em class="jv">意外的</em>变更，要么是引用快照需要更新到UI组件的<em class="jv">新版本。</em></p><p id="a9f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然快照测试测试你的组件的渲染，如果你想测试一些特定的功能，你也可以通过<a class="ae lc" href="https://jestjs.io/docs/mock-functions" rel="noopener ugc nofollow" target="_blank">模仿它们</a>来完成。</p><p id="5649" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，当谈到在我们的应用程序中使用Redux时，我们不应该忘记测试相关的<a class="ae lc" href="https://scotch.io/tutorials/testing-react-and-redux-apps-with-jest#toc-testing-your-reducers" rel="noopener ugc nofollow" target="_blank">还原器</a>和<a class="ae lc" href="https://scotch.io/tutorials/testing-react-and-redux-apps-with-jest#toc-testing-your-action-creators-and-async-action-creators" rel="noopener ugc nofollow" target="_blank">动作</a>。</p><h1 id="65c9" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">2.静态代码分析</h1><blockquote class="js jt ju"><p id="5253" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">一位伟大的哲学家曾经说过，</p><p id="b41d" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">“这不是你<strong class="iw hj">什么</strong>码，而是你<strong class="iw hj">怎么</strong>码”</p></blockquote><p id="ddc8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">任何人都可以写代码。但是，当你知道编码的好习惯时，你才是一个伟大的开发者。网上有很多工具可以用来审查你的代码，比如Sonarqube，ESLint，JSlint等等。，我个人更喜欢<a class="ae lc" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> ESLint </strong> </a>，因为它附带了一个VSCode插件和一个npm包。它将帮助您在终端或控制台中以错误和警告的形式识别整个应用程序中的错误。</p><ul class=""><li id="55ca" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">不使用的变量和导入应该从代码中删除，因为它们会消耗不必要的内存。</li><li id="e137" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">使用==的条件语句应该替换为<strong class="iw hj"> === </strong>。如果需要，我们可以解析任何一边。</li><li id="7b63" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">您可能经常在终端中看到一些警告，其中提到了<em class="jv">缺少useEffect()的依赖关系。</em>我们应该在我们的函数组件中非常小心地使用<strong class="iw hj"> useEffect() </strong>钩子，因为使用不当可能会导致内存泄漏问题。它带有一个副作用或依赖数组，对于不同类型的场景表现不同。关于<strong class="iw hj">副作用</strong>的更详细解释，请参考这篇<a class="ae lc" href="https://dmitripavlutin.com/react-useeffect-explanation/#:~:text=1.%20useEffect%20%28%29%20is%20for%20side-effects%20A%20functional,output%20value%2C%20then%20these%20calculations%20are%20named%20side-effects." rel="noopener ugc nofollow" target="_blank">文章</a>。</li><li id="c304" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">避免使用内联样式属性，而是使用<a class="ae lc" href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> CSS模块</strong> </a>或SASS等预处理程序。</li><li id="0f13" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">总是使用代码格式化程序来格式化你的代码。这将增强你和你的队友的可读性。您可以使用<a class="ae lc" href="https://prettier.io/docs/en/install.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">更漂亮的</strong> </a> npm包，并为其使用脚本命令，然后构建您的应用程序并将其推送到存储库。</li><li id="9fff" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">如果您想在您的构建中对用户隐藏您的代码和源映射，您可以在您的构建脚本中包含GENERATE_SOURCE_MAP=false。<br/> <strong class="iw hj"> <em class="jv">"构建"</em>:" GENERATE _ source map = false react-scripts build "</strong></li><li id="de75" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">使用<a class="ae lc" href="http://www.developer-cheatsheets.com/es6" rel="noopener ugc nofollow" target="_blank"> ES6功能</a>如箭头功能等。，而不是传统的JS编码方式。</li></ul><h1 id="f851" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">3.启用缓存机制</h1><p id="c853" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">然而，这是可选的，但我仍然喜欢一些应用程序。我们可以通过使用浏览器的<strong class="iw hj">本地存储</strong>来减少fetch调用的数量。在这种情况下，对服务器的调用只会发生一次，除非我们重新加载页面。</p><h1 id="f25b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">4.启用安全性</h1><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8913761597fd662eda686507408e656f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*go2nl7e6YaN_RKR_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">URL Source: Unsplash</figcaption></figure><p id="19a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这已经成为开发人员在构建web应用程序时必须注意的最重要的方面之一。如果不安全，整个应用程序可能会崩溃。</p><p id="72c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在可能有各种类型的安全威胁。我已经提到了一些只能在客户端使用的技术。</p><h2 id="8a49" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated"><strong class="ak">安全来自</strong> <a class="ae lc" href="https://owasp.org/www-community/attacks/xss/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">跨站脚本【XSS】</strong></a><strong class="ak">攻击</strong> —</h2><p id="ca4b" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">黑客可以以脚本标签的形式注入代码，从而完全控制用户浏览器中运行的应用程序。这主要针对表单字段，如输入、段落和文本区域。</p><p id="0bc0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">补救措施:</strong></p><ul class=""><li id="b51a" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">只要您希望使用&lt;输入&gt;或&lt; p &gt;标签，就使用React的<strong class="iw hj"> createElement() </strong> API。<br/> <code class="du mk ml mm mn b">React.createElement('input', { placeholder: 'Enter a url', type: 'url', autoFocus: true }, 'default_url');</code></li><li id="e0cf" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">使用<strong class="iw hj">dangerouslySetInnerHTML</strong>()—直接从React设置HTML，而不是使用容易出错的<code class="du mk ml mm mn b"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML" rel="noopener ugc nofollow" target="_blank">innerHTML</a>.</code> <br/> <code class="du mk ml mm mn b">&lt;div contentEditable='true' dangerouslySetInnerHTML={{ __html: "Hello" }}&gt;&lt;/div&gt;</code></li><li id="d1e5" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">您也可以通过使用一个名为<a class="ae lc" href="https://github.com/cure53/DOMPurify" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> DOMPurify </strong> </a>的库来净化您的输入。</li><li id="bef1" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><a class="ae lc" href="https://owasp.org/www-community/xss-filter-evasion-cheatsheet" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到一系列的XSS攻击，可以用来测试你的应用中的XSS漏洞。</li></ul><h2 id="0e94" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">永远不要在本地存储中存储JWT代币—</h2><p id="5114" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">在本地存储中存储JWT或OAuth令牌的风险非常高，因为有人可以很容易地打开开发工具来窃取令牌并滥用它们。</p><p id="fab5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最好通过将令牌设置为<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank"> HTTP Cookie </a>来存储它们。或者，您也可以将令牌移动到React应用程序的状态。</p><h2 id="7dfc" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">永远不要在你的代码中包含客户秘密—</h2><p id="afda" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">如果你在你的Java脚本代码中使用客户端秘密，这是不可原谅的罪过。您可以在您的环境文件中使用它们，因为这些文件通常不会被推送到git存储库中。</p><h2 id="6297" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">使用端到端加密—</h2><p id="57c8" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">为了防止黑客看到来自后端API的响应，我们可以在前端和后端都使用<a class="ae lc" href="https://www.npmjs.com/package/crypto-js" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> crypto </strong> </a>模块进行端到端的加密。举个例子，</p><ul class=""><li id="09f7" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">从React端，我们可以首先加密URL端点。</li><li id="fe4e" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">在<strong class="iw hj"> fetch() </strong> API中使用它来请求来自后端的响应。</li><li id="2018" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">另一方面，后端服务器接收加密的端点，并对其解密以获得确切的端点或路由。</li><li id="9a48" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">后端服务器调用正确的路由来获得响应。</li><li id="799f" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">然后，后端服务器对响应进行加密，并将其发送回React服务器。</li><li id="d8eb" class="li lj hi iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">React应用程序解密响应并相应地呈现视图。</li></ul><h2 id="46ae" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">使用内容安全策略(CSP)标题—</h2><p id="f1ec" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">Content-Security-Policy是现代浏览器用来增强文档(或网页)安全性的HTTP响应头的名称。Content-Security-Policy头允许您限制资源(如JavaScript、CSS或几乎任何浏览器加载的内容)的方式。</p><p id="d3f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然它主要用作HTTP响应头，但是您也可以通过meta标记来应用它。</p><p id="ea58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CSP最初是为了减少跨站点脚本(XSS)攻击的攻击面而设计的，该规范的后续版本还可以防范其他形式的攻击，如点击劫持。</p><p id="eab3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我发现<a class="ae lc" rel="noopener" href="/@nrshahri/csp-cra-324dd83fe5ff">这篇</a>文章对于设置CSP非常有用。</p><h2 id="156f" class="lw ka hi bd kb lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">使用Nexus漏洞扫描器—</h2><p id="e504" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated"><a class="ae lc" href="https://blog.sonatype.com/nexus-vulnerability-scanner-and-vulnerability-analysis#:~:text=What%20Is%20Nexus%20Vulnerability%20Scanner%3F%20Nexus%20Vulnerability%20Scanner,around%20100%2B%20open-source%20components%20and%20around%2020%2B%20vulnerabilities." rel="noopener ugc nofollow" target="_blank">Nexus Vulnerability Scanner</a>是一款扫描应用程序漏洞并给出分析报告的工具。</p><h1 id="fb67" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">5.启用gzip压缩</h1><p id="9d66" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated"><a class="ae lc" href="https://www.gzip.org/" rel="noopener ugc nofollow" target="_blank"> Gzip </a>是一种能够快速压缩和解压文件的数据压缩算法。压缩是节省网络带宽和提高应用程序速度的最简单方法。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/08da32e00acc820d689c4f816d83c099.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*5KS0-fvuvNkTPp9-.png"/></div></figure><p id="186b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用gzip压缩大文件，图像，JS文件等。</p><p id="0912" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在收到来自前端服务器的响应时，后端服务器提取文件数据并搜索<code class="du mk ml mm mn b">Accept-Encoding</code>头以确定如何对应用程序进行编码。</p><p id="9849" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果服务器支持使用gzip压缩，资源将被压缩并通过网络发送。每个资源的压缩副本都添加了<code class="du mk ml mm mn b">Content-Encoding</code>头，指定资源使用gzip编码。</p><p id="2b23" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，浏览器在将内容呈现给用户之前，将其解压缩为原始的未压缩版本。</p><h1 id="509a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">6.渐进式网络应用程序</h1><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/b12e50d59a2f67ec802490a866fa272d.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/0*MbGjrY5qQYXVyqCx"/></div></figure><p id="8f5d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，这是一个可选功能，取决于需求。一款<strong class="iw hj">渐进式网络应用</strong>是一款<strong class="iw hj">网络</strong>应用，为用户提供可与原生移动<strong class="iw hj">应用</strong>相媲美的体验。它的功能模仿了本地<strong class="iw hj">应用</strong>的功能。<strong class="iw hj">渐进式web应用</strong>的目标是提供类似<strong class="iw hj">应用</strong>的体验。</p><p id="2e0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以通过这里提到的<a class="ae lc" href="https://create-react-app.dev/docs/making-a-progressive-web-app" rel="noopener ugc nofollow" target="_blank">步骤</a>将您的React应用程序转换为PWA。</p><h1 id="1292" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="b7f6" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">正如科学天使所说，没有一台机器是完美和纯粹高效的。虽然类似的理论适用于web应用程序，但我们应该始终牢记，技术是与我们一起发展的。因此，我们必须始终确保我们始终能够找到开发和交付我们的应用程序的方法，这些应用程序在质量、健壮性、可伸缩性和性能方面都是最高的。</p><p id="c399" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文到此为止。我很快会添加更多的东西。:)</p></div></div>    
</body>
</html>
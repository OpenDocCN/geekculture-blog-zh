<html>
<head>
<title>Change Data Capture, Use Cases and real-world example using Debezium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Debezium更改数据捕获、用例及真实示例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/change-data-capture-use-cases-and-real-world-example-using-debezium-fe4098579d49?source=collection_archive---------2-----------------------#2021-08-14">https://medium.com/geekculture/change-data-capture-use-cases-and-real-world-example-using-debezium-fe4098579d49?source=collection_archive---------2-----------------------#2021-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事重点讲述<strong class="ih hj"><em class="jd">【CDC】</em></strong>的变化数据是什么？在哪里使用它，它解决了什么问题，最后是一个真实的示例代码。</p><h1 id="13b7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是疾控中心？</h1><p id="6057" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">CDC是一组技术/流程，允许识别和捕获数据库中已更改的数据。以便您可以在稍后阶段对数据采取行动，或者在某个特定的上下文中定义业务用例。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/61c4bcafd336b300b6e1645906c3ce3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXM0kOJW6HfoGPwvZevJUQ.png"/></div></div></figure><p id="f178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变更数据捕获是检测对数据库所做更改的过程。然后，这些更改可以被流式传输并与其他数据库和系统集成。换句话说:我们从数据库中接收一系列事件。</p><p id="a806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这允许我们基于数据(流处理和流ETL)做出更快和更准确的决策。它不会像传统解决方案那样使系统和网络过载。通常这是升级遗留系统的唯一合理的解决方案。</p><p id="9f10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变更数据捕获(CDC)通常是指一种用于捕获系统数据发生的所有变更的机制。对这样一个系统的需求不难想象——敏感信息的审计、跨多个数据库实例或数据中心的数据复制、将变更从事务性数据库转移到数据湖/OLAP存储，等等。符合ACID的数据库中的事务管理本质上是CDC。CDC系统是对一个实体所做的每一次更改的记录以及该更改的元数据(更改者、更改时间等)。</p><p id="5d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CDC是关于在系统的有限上下文中捕获数据变更，通常是在物理模型方面。系统记录对其自身数据的更改。即使我们有一个单独的服务或系统来存储这些变更(某种审计存储)，这种分离也是一个实现细节。在实际数据和对它的更改之间有一个领域建模的连续性，因此两者在逻辑上属于同一个边界。</p><p id="5d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们谈谈CDC可以解决某些问题的几个用例。有很多，但我打算谈几个。</p><h2 id="36c6" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">将数据流式传输到数据湖或数据仓库</h2><p id="f57c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通常，这种流数据通过ETL或ELT，这通常是实现数据的批量加载。这可以通过以下方式实现</p><ul class=""><li id="6724" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">后台进程定期从复杂查询中提取数据，这会增加主数据库的负载。</li><li id="bf7d" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">从主数据源汇集数据以获得增量变化。</li></ul><p id="04f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法的缺点是</p><ul class=""><li id="aba0" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">数据使用量的峰值最终会降低性能(可以在低流量时发生)。</li><li id="e67c" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">传输的大量数据会给网络带来压力，需要垂直扩展来处理大量数据。</li><li id="f577" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">由于我们按时间间隔汇集数据，这不是实时数据同步，可能会影响业务决策。</li></ul><p id="5b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">疾控中心如何解决上述问题</p><ul class=""><li id="85cb" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">我们不定期进行任何高负载查询，以减少数据峰值。</li><li id="9073" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">传输的数据量要小得多，所以不会有网络压力。网络流量在这里均匀分布。</li><li id="a1b9" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">CDC是实时数据同步，因此业务决策不会延迟。</li></ul><p id="cd49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">事件驱动架构</strong></p><p id="06e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最难完成的事情之一是在服务边界之间安全一致地交付数据。在EDA中，单个服务必须提交对其本地数据的任何更改，并且应该向底层排队系统发布消息，监听消息的消费者将相应地采取行动。这里的数据传输很棘手:</p><ul class=""><li id="585a" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">如果在数据库中提交数据，并且发布到事件流失败。</li><li id="94e3" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">数据被发布到事件流，但在实际数据库中由于一些错误处理而触发了回滚。</li></ul><p id="c766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以使用<a class="ae lv" href="https://microservices.io/patterns/data/transactional-outbox.html'" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd">发件箱模式</em> </strong> </a> <strong class="ih hj"> <em class="jd">来避免/修复。</em> </strong>我会在另一篇帖子中解释这一点。</p><p id="33eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也有几种方法可以实现CDC和行业的平衡。</p><h1 id="0670" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">实现变更数据捕获的方法</strong></h1><p id="bd94" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">方法1 —使用Postgres审计触发器</em> </strong></p><p id="0f6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于触发器的方法包括在数据库上创建审计触发器，以捕获与插入、更新和删除方法相关的所有事件。这种方法的优点是一切都发生在SQL级别，开发人员只需要读取一个包含所有审计日志的单独的表。</p><p id="725d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在Postgres表中创建触发器，请执行以下命令。</p><pre class="ki kj kk kl fd lw lx ly lz aw ma bi"><span id="3066" class="kt jf hi lx b fi mb mc l md me"><strong class="lx hj">SELECT audit.audit_table('target_table');</strong></span></pre><p id="a1a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该语句将由具有访问审计模式权限的用户角色执行。写入表的应用程序不得使用超级用户角色连接到数据库。</p><h2 id="13c1" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">对PostgreSQL CDC使用Postgres审计触发器的限制</h2><p id="635d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这种方法的缺点是触发器会影响数据库的性能。避免这种性能损失的常见做法是使用一个单独的表来跟踪主表，并在第二个表上使用触发器。主表和辅助表之间的同步可以使用Postgres逻辑复制特性来完成。</p><p id="ee6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">方法二——使用Postgres逻辑解码</em> </strong></p><p id="ea53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑解码使用预写日志的内容来创建数据库中发生的活动的日志。预写日志是在存储级别描述数据库更改的内部日志。这种方法的优点是它不会以任何方式影响数据库的性能。</p><p id="99ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法基于输出插件的安装。要启用逻辑解码，需要在Postgres配置中设置以下参数。</p><pre class="ki kj kk kl fd lw lx ly lz aw ma bi"><span id="b199" class="kt jf hi lx b fi mb mc l md me"><strong class="lx hj">wal_level = logical<br/>max_replication_slots = 10</strong></span></pre><p id="9697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦设置了这些参数，执行下面的命令来创建一个逻辑解码槽。</p><pre class="ki kj kk kl fd lw lx ly lz aw ma bi"><span id="9ba3" class="kt jf hi lx b fi mb mc l md me"><strong class="lx hj">SELECT * FROM pg_create_logical_replication_slot('slot_repl', 'decode_test');</strong></span></pre><p id="dd50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【Postgres CDC使用Postgres逻辑解码的限制</p><p id="232e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，开发人员也需要编写一个复杂的逻辑来处理这些事件，然后将它们转换成目标数据库的语句。根据您试图解决的用例，这可能会增加复杂性。</p><p id="59ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">方法3 —使用时间戳列</em> </strong></p><p id="d381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Postgres引擎提供了上述两种方法来实现CDC。如果您的表中有时间戳列的灵活性，还有一个稍微复杂的自定义方法。这意味着开发人员需要定期查询该表，并监控时间戳列的更改。当检测到更改时，脚本可以创建适当的数据库语句，将这些更改写入目标数据库。然而，这种方法是劳动密集型的，需要开发者花费大量的时间和精力。</p><p id="72b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，即使Postgres通过触发器、逻辑解码或自定义逻辑提供了对连续同步的支持，<strong class="ih hj"> <em class="jd">开发人员仍然需要捕获这些事件并将其转换到目标数据库</em> </strong>。这个逻辑需要根据用例为不同的目标数据库专门编写。另一种方法是使用基于云的服务，如Hevo，它可以使用Postgres CDC将数据持续同步到大多数目的地。</p><p id="292a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上三种方法各有利弊。我对疾控中心做了大量的研究，但几乎没有现成的解决方案。</p><ul class=""><li id="400f" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated"><a class="ae lv" href="https://hevodata.com/" rel="noopener ugc nofollow" target="_blank"> Hevo数据</a></li><li id="7def" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae lv" href="https://www.ibm.com/in-en/analytics/information-server" rel="noopener ugc nofollow" target="_blank"> IBM Infosphere </a></li><li id="e7f2" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae lv" href="https://debezium.io/" rel="noopener ugc nofollow" target="_blank"> Debezium </a></li><li id="a61b" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae lv" href="https://www.qlik.com/us/products/qlik-replicate" rel="noopener ugc nofollow" target="_blank"> Qlik </a></li><li id="a7c0" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae lv" href="https://www.talend.com/" rel="noopener ugc nofollow" target="_blank">塔伦德</a></li><li id="bdb5" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae lv" href="https://streamsets.com/" rel="noopener ugc nofollow" target="_blank">流集</a></li></ul><p id="b84d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上述可用的解决方案中，我探索了Debezium，因为它是开源的。除了Debezium Hevo似乎很有前途。</p><h1 id="0057" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Debezium</h1><blockquote class="mf mg mh"><p id="8dfb" class="if ig jd ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">Debezium是一个用于变更数据捕获的开源分布式平台。启动它，将它指向您的数据库，您的应用程序就可以开始响应其他应用程序提交到您的数据库的所有插入、更新和删除操作。Debezium持久而快速，因此您的应用程序可以快速响应，即使出现问题也不会错过任何事件。</p></blockquote><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ml"><img src="../Images/1cf46112d35dd93bf9e1dc54126583b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7ODoVPyBoYSEhpwm7A5Aw.png"/></div></div></figure><p id="8e54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一个用例。假设您有一个类似于IMDB的应用程序，它有一个<code class="du mm mn mo lx b">movie-library</code>微服务，作为所有电影信息及其评级和用户实时记录的喜欢的单一来源。我们有一个<code class="du mm mn mo lx b">recommenation-engine</code>服务，将每半小时为用户列出以下功能(考虑一下)。</p><ul class=""><li id="9b06" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">最喜欢电影的前100名。</li><li id="921f" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">最受欢迎的100部电影。</li><li id="17c6" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">收视率最高的100部电影。</li><li id="1593" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">100部广受好评的电影。</li><li id="3da9" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">按流派排名的100部电影。</li></ul><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mp"><img src="../Images/0a2c306dc7be96255f89f4bf2e16e9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB1RJQHAbN7x5pO6uD_jDw.png"/></div></div></figure><p id="756a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当有人看电影时，<code class="du mm mn mo lx b">movie-library</code>服务数据库被更新，观看次数被更新，同样喜欢不喜欢的和评级也被更新。<code class="du mm mn mo lx b">recommendation-service</code>需要这些真实的数据来预测给用户的最佳推荐，以获得更好的体验和个性化。<em class="jd">一种方法是直接查询主数据库，这在微服务生态系统中不是一个好的做法。</em></p><p id="169d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一下，如果主数据库将对它们的表所做的每一个更改都作为一个流推送到外部系统，会怎么样？这是个好主意，Babi  可能也会对此感到高兴。<strong class="ih hj"> <em class="jd"> Debezium </em> </strong>服务于此目的，它帮助将数据更改流式传输到订阅的外部子系统。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mq"><img src="../Images/57ffb42809a363f1561e2323f5036f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csG2kp4LyO-ivFd3ZKvajA.png"/></div></div></figure><p id="68bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该是你了解Debezium的好时机。 </p><p id="0015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Debezium如何工作？</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mr"><img src="../Images/e268e0e1e08e8d64bf1661ef459607cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpZXrOWuTB3b_kC9OnNH0Q.png"/></div></div></figure><blockquote class="mf mg mh"><p id="aecf" class="if ig jd ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">Debezium的目标是构建一个连接器库，它可以捕获各种数据库管理系统的变化，并产生具有非常相似结构的事件，使您的应用程序更容易使用和响应事件，而不管这些变化来自哪里。(<strong class="ih hj">抄袭自原始资料</strong>)</p></blockquote><p id="7d58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">典型地Debezium架构围绕着<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd">连接器</em> </strong> </a> <strong class="ih hj"> <em class="jd">。</em> </strong>连接器有助于从源系统捕获流形式的数据更改，并将数据同步到目标系统。</p><p id="652f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Debezium目前支持<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/mysql.html" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/postgresql.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>、<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/sqlserver.html" rel="noopener ugc nofollow" target="_blank"> SQL Server </a>、<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/oracle.html" rel="noopener ugc nofollow" target="_blank"> Oracle </a>、<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/db2.html" rel="noopener ugc nofollow" target="_blank"> Db2 </a>和<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/connectors/mongodb.html" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的连接器。</p><p id="1785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Debezium提供了三种不同类型的部署方法。</p><p id="0739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">作为库嵌入到应用程序中</em> </strong></p><p id="736c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的文档非常好。请在这里找到<a class="ae lv" href="https://debezium.io/documentation/reference/1.6/operations/embedded.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ms"><img src="../Images/7f90bf0335cfcea48da9da3a3becdf96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4dYFu2ZgcRf_MT2Joeeyw.png"/></div></div></figure><p id="553e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">作为独立服务器</em> </strong></p><blockquote class="mf mg mh"><p id="f274" class="if ig jd ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated">部署Debezium的另一种方式是使用Debezium服务器。Debezium服务器是一个可配置的、随时可用的应用程序，它将变更事件从源数据库传输到各种消息传递基础设施。</p></blockquote><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mt"><img src="../Images/456d24c4e58ee3a2766c6b26563a6dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvmGjXrw-y1zsFKur8SVtA.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx">Standalone Server Architecture — <a class="ae lv" href="https://debezium.io/documentation/reference/1.5/architecture.html" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="c2a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Debezium服务器被配置为使用其中一个Debezium源连接器来捕获源数据库中的更改。变更事件可以序列化为不同的格式，如JSON或Apache Avro，然后发送到各种消息传递基础设施，如Amazon Kinesis、Google Cloud Pub/Sub或Apache Pulsar。</p><p id="e9c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">Apache Kafka Connect service一种标准方法</em> </strong>(我将演示这种方法，这通常用于企业用例)。</p><p id="789c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最常见的是，你通过Apache <a class="ae lv" href="https://kafka.apache.org/documentation/#connect" rel="noopener ugc nofollow" target="_blank"> Kafka Connect </a>来部署Debezium。Kafka Connect是一个框架和运行时，用于实现和操作:</p><ul class=""><li id="fc8e" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">Debezium等源连接器将记录发送到Kafka。</li><li id="71fc" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">将记录从Kafka主题传播到其他系统的接收器连接器。</li></ul><p id="23ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了基于Debezium的变更数据捕获管道的架构:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es my"><img src="../Images/87bf32fa7a8aa072b69eba1791fb1e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaZFZWHGQvEpqkUe0IEEWQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx">Kafka Connect Service Architecture — <a class="ae lv" href="https://debezium.io/documentation/reference/1.5/architecture.html" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="ca18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，部署了MySQL和PostgresSQL的Debezium连接器来捕获对这两种类型数据库的更改。每个Debezium连接器都与其源数据库建立连接:</p><ul class=""><li id="8f4f" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">MySQL连接器使用客户端库来访问<code class="du mm mn mo lx b">binlog</code>。</li><li id="1874" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">PostgreSQL连接器从逻辑复制流中读取。</li><li id="70c7" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">Kafka Connect是Kafka broker之外的一项独立服务。</li></ul><p id="68f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，来自一个数据库表的更改被写入一个Kafka主题，该主题的名称与表名相对应。如果需要，您可以通过配置Debezium的<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/configuration/topic-routing.html" rel="noopener ugc nofollow" target="_blank">主题路由转换</a>来调整目标主题名称。例如，您可以:</p><ul class=""><li id="1704" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">将记录路由到名称不同于表名的主题。</li><li id="80cd" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">将多个表的更改事件记录流式传输到单个主题中</li></ul><p id="bd76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变更事件记录保存在Apache Kafka中后，Kafka Connect生态系统中的不同连接器可以将记录传输到其他系统和数据库，如Elasticsearch、数据仓库和分析系统，或Infinispan等缓存。根据所选择的接收器连接器，您可能需要配置Debezium的<a class="ae lv" href="https://debezium.io/documentation/reference/1.5/configuration/event-flattening.html" rel="noopener ugc nofollow" target="_blank">新记录状态提取</a>转换。这个Kafka Connect SMT将<code class="du mm mn mo lx b">after</code>结构从Debezium的change事件传播到sink连接器。这取代了默认情况下传播的详细更改事件记录。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mz"><img src="../Images/839231509388aa04ed829dd9b220c854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6W5P72PGPIuew-n_BbiOA.png"/></div></div></figure><p id="5ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用Kafka连接器实现一个用例</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es na"><img src="../Images/35c1bf9dca88d5e30cbde9d21fd089d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2b6Vtk6C7NcYg7-D6sp56w.png"/></div></div></figure><p id="777a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基础架构建立在docker之上。所有的资源都打包在一个docker-compose文件下。docker-compose文件非常大，所以我不在这里张贴。请在这里找到<strong class="ih hj"> <em class="jd"> GitHub链接</em></strong><a class="ae lv" href="https://github.com/ereshzealous/debezium-sync-example/tree/main/pg-es-synch" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a><strong class="ih hj"><em class="jd">。</em>T25】</strong></p><p id="5a8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker-compose用于设置演示所需的基础设施:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nb"><img src="../Images/e5aa2b0c5fbb2a88b5ac07c2cd6f39d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3DRwPXck2w3hrm0TqJKXw.png"/></div></div></figure><p id="bec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">演示</strong></p><pre class="ki kj kk kl fd lw lx ly lz aw ma bi"><span id="b6fc" class="kt jf hi lx b fi mb mc l md me"><strong class="lx hj">export DEBEZIUM_VERSION=1.4 (or latest)</strong><br/><br/># Build the docker file using docker compose. It will take a while for first time.<br/><strong class="lx hj">docker-compose up --build</strong><br/><br/># Configure the connectors. For simplicity I created shell script. <br/><strong class="lx hj">./init.sh</strong></span></pre><p id="eb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Postgres启动时加载了一些记录，数据库名是<code class="du mm mn mo lx b">user_data</code>，表是<code class="du mm mn mo lx b">users</code>、<code class="du mm mn mo lx b">user_address</code>和<code class="du mm mn mo lx b">user_additional_info</code>。所以当docker-compose完成时，记录就在那里了。</p><blockquote class="mf mg mh"><p id="d093" class="if ig jd ih b ii ij ik il im in io ip mi ir is it mj iv iw ix mk iz ja jb jc hb bi translated"><strong class="ih hj">注:每次脚本生成随机数据。id可以彼此不同。</strong></p></blockquote><pre class="ki kj kk kl fd lw lx ly lz aw ma bi"><span id="1cd7" class="kt jf hi lx b fi mb mc l md me"><strong class="lx hj">FROM debezium/postgres:latest<br/>COPY ./create_schema.sql /home/create_schema.sql<br/>COPY ./seed_data.sql /home/seed_data.sql<br/>COPY ./init-db.sh /docker-entrypoint-initdb.d/init-db.sh</strong></span></pre><p id="0957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建debezium连接器</strong></p><p id="8f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> Postgres数据连接器</em> </strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="95bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">弹性搜索用户汇表索引</em> </strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="094c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">检查Postgres数据库实例中的数据</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ne"><img src="../Images/1e43ba9497f6f182e72ed4583229b6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYCWObC8b0slvnPcly_BuQ.png"/></div></div></figure><p id="83f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">同样，入住弹性搜索指数</strong></p><p id="98ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在docker-compose中添加了Kibana，这样我们就可以从Kibana开发控制台查询弹性搜索。请<a class="ae lv" href="http://localhost:5601/app/kibana#/dev_tools/console?_g=()" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd">点击这里的</em> </strong> </a>本地加载Kibana dev控制台。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nf"><img src="../Images/388e4d131a9504f7842fd8a80863dc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9XPDbWeBB-wsKx0XEimLw.png"/></div></div></figure><p id="41ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在让我们更新任何记录，看看这是否反映在弹性搜索中。</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ng"><img src="../Images/3e0971e4f0c3691e1f56fd89ad7fe6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjQa1-VVcAE0HqTus-o1Tw.png"/></div></div></figure><p id="d60e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们对照弹性搜索进行查询</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nh"><img src="../Images/e7d36ecffd069b421ae2b0d01192052d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMRour2UvSakGGNEXw3jAg.png"/></div></div></figure><p id="b557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们从源系统中删除该记录</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ni"><img src="../Images/26016d7d79065aadec49434abc2c23ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fIC-Kz_N0NGTy-qW7xGow.png"/></div></div></figure><p id="8a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们在弹性搜索索引中验证</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nj"><img src="../Images/f8667f4da85285811535062cd84b3fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJCK5CLynK3xRoGB8nYCGQ.png"/></div></div></figure><p id="278b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们检查卡夫卡事件的消息</strong></p><p id="1b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用了<strong class="ih hj"> <em class="jd"> Kafdrop </em> </strong>作为UI。我们可以看到一个主题上发布的消息列表。要在本地打开Kafdrop，请点击<a class="ae lv" href="http://localhost:9100/" rel="noopener ugc nofollow" target="_blank">此处</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nh"><img src="../Images/e37f0c83b5dd43c523a38ad4f1eddb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKZHjvHdhW0cSQ7jfJ78FQ.png"/></div></div></figure><p id="865b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mm mn mo lx b">users</code>、<code class="du mm mn mo lx b">user_address</code>和<code class="du mm mn mo lx b">user_additional_info</code>是与源数据库表相关的主题</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nk"><img src="../Images/2ebcf6debf975a426e3cf49910128385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQF75QY14Sw-v4uLWKRZuA.png"/></div></div></figure><p id="b1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们理解Debezium Kafka连接器为数据变更产生的消息内容。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nl"><img src="../Images/498bd10f8194e093b7a7964f498c15e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Y5uuG1PfoxPfR0SwE0l_g.png"/></div></div></figure></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="48dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Babi还有另一个用例。他是这样说的</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nt"><img src="../Images/177ac3940aa72bcec1bb3c0fedb93c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c98fndjkskgJt8sdtCs_RQ.png"/></div></div></figure><p id="fc30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Github回购<a class="ae lv" href="https://github.com/ereshzealous/debezium-sync-example/tree/main/mongo-pg-synch" rel="noopener ugc nofollow" target="_blank"> <em class="jd">这里</em> </a> <em class="jd">已经明确记载了。</em></p></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="e163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Babi被说服了，但是他还有最后一个用例。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nu"><img src="../Images/f11e6431343a70e9a94b9180f2be15c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXRRwBwu071AREUFdSHAmA.png"/></div></div></figure><p id="0f82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在GitHub repo <a class="ae lv" href="https://github.com/ereshzealous/debezium-sync-example/tree/main/mysql-pg-es-compound-synch" rel="noopener ugc nofollow" target="_blank">这里</a>明确记录了。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nv"><img src="../Images/c256f28d97d395d6887a7f6eab389cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyIG4O3Q7V1cYJlaPo6afQ.png"/></div></div></figure></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="58cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实现与目标系统同步的一些复杂性</strong></p><p id="b497" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从RDBMS同步数据到Elastic search时，我们经常会遇到问题，Debezium connectors中有很多选项可以定制连接选项。但是根据我的经验，我在将Postgres整合到弹性搜索时没有遇到什么问题。</p><p id="3aef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我只为Postgres创建了一个源连接器，将更改作为流发布到Kafka。然后，我编写了我们的语言和框架的自定义消费者来消费消息，并在弹性搜索中更新索引。简单的方法可能是使用lambda来消费来自卡夫卡的信息。</p><p id="dd8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">参考文献</em> </strong></p><div class="nw nx ez fb ny nz"><a href="https://debezium.io/documentation/reference/architecture.html" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab dw"><div class="ob ab oc cl cj od"><h2 class="bd hj fi z dy oe ea eb of ed ef hh bi translated">Debezium建筑</h2><div class="og l"><h3 class="bd b fi z dy oe ea eb of ed ef dx translated">最常见的是，通过Apache Kafka Connect部署Debezium。Kafka Connect是一个框架和运行时，用于…</h3></div><div class="oh l"><p class="bd b fp z dy oe ea eb of ed ef dx translated">debezium.io</p></div></div></div></a></div><div class="nw nx ez fb ny nz"><a href="https://www.striim.com/change-data-capture-cdc-what-it-is-and-how-it-works/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab dw"><div class="ob ab oc cl cj od"><h2 class="bd hj fi z dy oe ea eb of ed ef hh bi translated">变更数据捕获(CDC):它是什么以及如何工作</h2><div class="og l"><h3 class="bd b fi z dy oe ea eb of ed ef dx translated">关系数据库中捕获的业务事务对于理解业务运营的状态至关重要…</h3></div><div class="oh l"><p class="bd b fp z dy oe ea eb of ed ef dx translated">www.striim.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kr nz"/></div></div></a></div><div class="nw nx ez fb ny nz"><a href="https://www.hvr-software.com/blog/change-data-capture/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab dw"><div class="ob ab oc cl cj od"><h2 class="bd hj fi z dy oe ea eb of ed ef hh bi translated">变更数据捕获(CDC)有哪些不同的方法？</h2><div class="og l"><h3 class="bd b fi z dy oe ea eb of ed ef dx translated">在这篇博文中，我将描述执行变更数据捕获的四种常用方法:diff、date-modified…</h3></div><div class="oh l"><p class="bd b fp z dy oe ea eb of ed ef dx translated">www.hvr-software.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on kr nz"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Brief Introduction to Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/brief-introduction-to-microservices-b99a91c77c72?source=collection_archive---------23-----------------------#2021-04-09">https://medium.com/geekculture/brief-introduction-to-microservices-b99a91c77c72?source=collection_archive---------23-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2cb3696a5a7cb7e86c720c28b9622284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*rUF-KxRQGMYxfjL1MC-1Hg.jpeg"/></div></figure><p id="1f5b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">几乎可以肯定的是，在这个时代，你已经听说过微服务架构。当谈到系统内的扩展和处理增长时，这个术语经常被抛出。</p><p id="0aaa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是什么是真正的微服务呢？</p><p id="b5e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事实是，这种类型的建筑并不新鲜。Airbnb早在2012年就在大规模打造微服务，只是给你举个例子。分布式系统在那之前很多年就已经存在了。</p><p id="0829" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">微服务是小型服务[微]，只有一个目的或只服务于特定领域。有了这些，你就能够横向扩展，而不是不断扩大一个大机器。</p><p id="f0e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与传统的整体应用相比，微服务的概念实际上更好解释，这可能是最好的例子。</p><p id="88f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在早期，你的应用程序有一个单一的代码库，使用单一的编程语言，你可以根据你的增长来扩展所需的资源。事后看来，你可以清楚地看到这个问题，在某些时候，你将需要巨大的机器来支持规模。有解决这个问题的方法，但即使这样，你还是会遇到上限。</p><p id="5e3a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">合乎逻辑的下一步是开始将这些应用程序分离到不同的系统中，这些系统在彼此之间传递消息。这些系统可以按领域划分，比如说会计和库存。尽管如此，这些分裂也有些不灵活，并会以与严格的铁板一块的同行相同的方式增长。</p><p id="a005" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在某种程度上，工程师们发现，缩小这些服务可以获得灵活性，当需要添加功能时，您可以构建一个新的服务，如果系统的某个特定区域需要更多的功能，您可以旋转许多这些服务来应对负载或独立扩展它们。</p><p id="3ae7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是微服务的诞生。</p><p id="b779" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结束了。</p><p id="1d0e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi">…</p><p id="d5b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">笑话，这是事情变得令人兴奋的时候！</p><p id="908d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了这些知识，软件工程师和架构师就可以构建各种不同的拓扑来满足他们的特定需求。</p><p id="bdad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，微服务本身也带来了一些挑战。</p><h1 id="0514" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">服务之间的通信</h1><p id="5220" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">跨服务的通信方式有很多种，并且也在不断发展。传统的方式是通过HTTP或SOAP传递消息，就像其他面向服务的架构一样。</p><p id="51dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一种选择是使用共享数据存储，如数据库，在一个地方写数据，在另一个地方读数据。</p><p id="0c92" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其中的每一个都不是微服务独有的事实上，它们是从以前面向服务的迭代中采用的。现在的新奇之处是，消息可以更小，也可以服务于单一目的，例如，服务可以只接受与更新用户的个人资料信息或预订相关的消息，这降低了整体的复杂性。</p><p id="8223" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑到现代应用程序增长的规模，即使这些通信方式也是不够的，所以使用<a class="ae kn" href="https://aws.amazon.com/message-queue/" rel="noopener ugc nofollow" target="_blank">消息队列</a>的当前标准诞生了。像谷歌、亚马逊、脸书这样的公司建立了他们自己的事件队列实现，但现在我们可以找到更广泛采用的选项，如<a class="ae kn" href="https://kafka.apache.org/intro" rel="noopener ugc nofollow" target="_blank">卡夫卡</a>或<a class="ae kn" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>。</p><p id="92a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事件驱动的架构是写作时的现代标准，它们是一个全新层次的复杂性和神奇之处，我将在未来写更多。</p><h1 id="4113" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">混合架构</h1><p id="0a2a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在，拥有混合架构、在多种编程语言和设置上运行不同服务的实践非常普遍。你可以很容易地<a class="ae kn" href="https://r-arias.medium.com/why-you-should-learn-multiple-programming-languages-aa75ec73c16b" rel="noopener">让多种编程语言</a>在同一个系统中运行，因为小服务在某种程度上是相互独立运行的。</p><p id="da91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这允许你最大化你选择的每种技术的好处，只要你找到一种好的方法在它们之间交流。</p><h1 id="3faa" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">微服务需要多小？</h1><p id="1a73" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">这就是开始变得棘手的地方。没有单一的规则来定义什么是微服务或微服务有多微。有一个指导方针说，它需要足够小，以服务于一个单一的目的，并包含在一个单一的领域，但这是模糊的，可能是故意的。</p><p id="2ee6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在实践中，当您创建微服务时，往往会发生的情况是，您从类似于给定定义的微服务的东西开始，但随着时间的推移，服务会增长，您需要重新评估它是否需要拆分，因为它不再服务于单一用途。</p><p id="79b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您需要在拥有太多太小的服务并使其更难维护与拥有太大的不再是微服务并变得更难扩展的服务之间找到平衡。</p><p id="0b81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以称之为糟糕的实践，糟糕的设计，乐队规划，或者其他什么，但这就是通常发生的事情，很自然地只有在事后才注意到。好消息是，如果服务“足够小”，拆分或重写它们通常不是什么大问题。甚至用一种新的编程语言完全取代它们也在考虑之中。</p><h1 id="feab" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">分布式系统事务</h1><p id="1a3a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">微服务架构中的一个主要问题是事务的概念。如果多个服务执行一个事务的不同部分，当流程中途失败时，如何回滚？</p><p id="ac69" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个非常复杂的问题，可以根据您的架构以不同的方式解决。当然，使用现有的设计模式来解决这个问题会更好。</p><p id="fa7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解决这个问题的两种常见模式是<strong class="io hj">两阶段提交</strong>模式(2pc)，它使用orchestrator服务在出错时回滚事务。这是解决问题的同步方法；另一种模式是<strong class="io hj"> Saga </strong>模式，旨在产生事务不同阶段的事件，并在出错时补偿失败的事务。这就是异步方法。</p><p id="bcff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">详细探讨这些问题超出了本文的范围，但是深入研究这些模式是一个好主意，因为如果在微服务架构上工作，您很可能会遇到这些问题。</p><h1 id="5dac" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">微服务版本控制</h1><p id="9075" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">另一个常见的问题是必须更新微服务用来相互通信的事件结构。</p><p id="2aab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑到服务需要知道如何解析来自其他服务的消息，当事件需要更改时，您需要找到一种方法来保持通信工作，直到这些服务重新同步。</p><p id="2b6a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要解决这个问题，您可能需要使用某种形式的版本控制。如果您可以完全关闭微服务，更新并重新打开它们，这根本不是问题。</p><p id="8fb2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当这不可能时，下一个最好的情况是在不影响旧结构的情况下向事件添加新数据。通过这种方式，您可以首先升级您的发送器，添加新的字段，然后再支持侦听器。</p><p id="344e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果这也不可能，解决这个问题就变得有点复杂了。解决这个问题的一个好办法是在您转换到最新事件时在您的监听器上添加版本。然后，根据收到的消息的版本，您可以以某种方式解析它。</p><p id="9ae7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有多种方法可以解决这类问题，根据消息限制的不同，解决方案也会有所不同；例如，拥有一个硬类型的事件模式会使它变得更加复杂。</p><h1 id="6c67" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">维护</h1><p id="b762" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">大型微服务架构更难维护和更新。您也许可以对运行服务的实例进行分类，并同时更新所有的机器，但是如果您有多个服务在不同版本上运行不同的编程语言，并且以不同的速度升级，那么保持每件事都是一项重复且耗时的任务。</p><p id="087e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">记住这一点，重要的是采取尽可能多的步骤来确保域功能不会太复杂，以便服务可以尽可能独立地彼此升级。</p><h1 id="d80a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="2efb" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">微服务架构是横向扩展系统和管理业务增长的绝佳方式，但它并不便宜。需要注意权衡，对原则、模式和好处有一个坚实的理解是很重要的。</p><p id="14a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有许多不同的拓扑需要考虑，适合我的可能不适合你，所以在设计系统时要确保理解你的业务需求。</p><p id="f107" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一件要记住的事情是，这是一个复杂的架构，尽管听起来很简单。你不需要马上开始，尤其是如果你才刚刚开始。这是一个复杂性陷阱。如果你不需要处理大量的流量，最好从一个单一的应用程序开始，然后随着你的成长进行分割。这会节省你的时间，可能还会省钱。</p><p id="8e04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你喜欢这篇文章，请不要忘记给它一个掌声，并跟随👏</p><p id="6fea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">快乐编码还是…设计？🤔</p></div></div>    
</body>
</html>
<html>
<head>
<title>Moving Code Evaluation to a WebWorker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将代码评估转移到WebWorker</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/moving-code-evaluation-to-a-webworker-31066a384958?source=collection_archive---------62-----------------------#2021-05-25">https://medium.com/geekculture/moving-code-evaluation-to-a-webworker-31066a384958?source=collection_archive---------62-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9eff" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">并使用JavaScript <code class="du ix iy iz ja b">Proxy </code>类</h2></div><figure class="jb jc jd je fd jf"><div class="bz dy l di"><div class="jg jh l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://www.youtube.com/watch?v=EEyZGmmdV10" rel="noopener ugc nofollow" target="_blank">Accompanying video</a></figcaption></figure><p id="1288" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个系列中，我用多个代码编辑器创建了一个网页。然而，问题是:在一个编辑器中运行代码会用相同的结果更新两个编辑器的输出。显然，这会让任何用户感到困惑。问题是，我拦截了页面的<code class="du ix iy iz ja b">console</code>方法，并且没有明确的方法来区分哪个代码编辑器登录到控制台。</p><figure class="jb jc jd je fd jf er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/031546a7b00624cde6e5d800a1146c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6A8Hae7hU7AYoz1z2GAEoQ.png"/></div></div></figure><p id="48d1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我有更多的时间考虑这个问题，我想起我可以使用Web Workers，因为他们有自己的范围。</p><h1 id="27ad" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">观察网络工作者</h1><p id="2b3a" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">工作人员有一种叫做<code class="du ix iy iz ja b"><a class="ae jm" href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope" rel="noopener ugc nofollow" target="_blank">WorkerGlobalScope</a> </code>的东西，它类似于页面的<code class="du ix iy iz ja b">window</code>，但又与页面的<code class="du ix iy iz ja b">window</code>分开。这种与浏览器上下文的隔离可以提高安全性，而且，由于工人有他们自己的事件循环，他们也可以提高性能。</p><h1 id="c2c1" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">NextJS v10 ➕网络包v5</h1><p id="d26f" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">接下来js10提供了一个选项来启用webpack version 5，它有一个非常方便的特性:它将支持<a class="ae jm" href="https://webpack.js.org/guides/web-workers/#syntax" rel="noopener ugc nofollow" target="_blank">添加工人而不使用</a>T4。</p><pre class="jb jc jd je fd ln ja lo lp aw lq bi"><span id="2811" class="lr kr hi ja b fi ls lt l lu lv">new Worker(new URL("./worker.js", import.meta.url));</span></pre><p id="da2c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这可能看起来并不特别；然而，这个URL不同于提供给 <code class="du ix iy iz ja b"><a class="ae jm" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">Worker</a></code> <a class="ae jm" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">类</a>的<a class="ae jm" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">常规URL。Webpack v5支持指向相对文件，而不是指向构建文件夹中的路径的URL。该文件甚至可以包含导入或用TypeScript编写。这是因为文件是由Webpack构建的，然后URL被替换为构建文件的位置。</a></p><h1 id="42dd" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">与工人交流</h1><figure class="jb jc jd je fd jf er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lw"><img src="../Images/056df96a942a5c7e24776fe0184b65e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFF25UbUd97clE-OUQXrJA.png"/></div></div></figure><p id="2eb0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在该页面中，我可以生成一个新的worker，然后我将代码发送给该worker进行评估。在worker内部，对<code class="du ix iy iz ja b">console.log</code>的调用可以被收集并发送回页面。在页面和工作器上发送和接收消息的机制是各自作用域中的<code class="du ix iy iz ja b">postMessage</code>和<code class="du ix iy iz ja b">onmessage</code>方法。下面是一个简化的例子，来自我的代码库，关于如何发送和接收消息。</p><pre class="jb jc jd je fd ln ja lo lp aw lq bi"><span id="c239" class="lr kr hi ja b fi ls lt l lu lv"><em class="lx">const worker = new </em>Worker(<br/>  <em class="lx">new </em>URL("./code-runner.worker.ts", <em class="lx">import</em>.meta.url)<br/>);</span><span id="c048" class="lr kr hi ja b fi ly lt l lu lv">/* ... */</span><span id="465e" class="lr kr hi ja b fi ly lt l lu lv"><em class="lx">const sendCode </em>= (code) =&gt; <em class="lx">new </em>Promise((resolve, reject) =&gt; {<br/>  worker.onerror = (e) =&gt; reject(e.message);<br/>  worker.onmessage = ({ data }) =&gt; resolve(data);<br/>  worker.postMessage(code);<br/>});</span></pre><h1 id="5a4a" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">JS中的代理类</h1><p id="b933" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">这个想法开始是一个淋浴的想法。我记得在JavaScript中找到了<code class="du ix iy iz ja b">Proxy</code>类，我想知道它是否有拦截<code class="du ix iy iz ja b">console.log</code>的用途。一个<code class="du ix iy iz ja b">Proxy</code>可以拦截和重新定义任何对象的基本操作，这正是我所需要的。</p><figure class="jb jc jd je fd jf er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lz"><img src="../Images/d05f737ec1a16cceb5c158d76a444c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRDSZwqlyG41WEMUaXG4Vg.png"/></div></div></figure><p id="93a2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">JS <code class="du ix iy iz ja b">Proxy</code>背后的概念就像一个web代理。任何接收输入的东西都可以被代理封装，代理可以拦截调用，读取请求，并对这些请求应用逻辑。</p><p id="3b47" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我的例子中，我需要用一个<code class="du ix iy iz ja b">Proxy</code>来包装<code class="du ix iy iz ja b">console.log</code>。当我们调用<code class="du ix iy iz ja b">console.log(...args)</code>时，<code class="du ix iy iz ja b">apply</code>处理程序将在<code class="du ix iy iz ja b">Proxy</code>中被调用，它将被赋予预定的目标和参数。</p><p id="e225" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">还有一个名为<code class="du ix iy iz ja b">get</code>的处理程序，每当访问<code class="du ix iy iz ja b">Proxy</code>的属性时都会被调用。这不仅允许我拦截<code class="du ix iy iz ja b">console.log</code>，还允许我一次性拦截<code class="du ix iy iz ja b">console</code>的所有方法。其工作方式是有两个代理，第一个代理处理<code class="du ix iy iz ja b">get</code>并返回第二个代理来处理<code class="du ix iy iz ja b">apply</code>。</p><figure class="jb jc jd je fd jf er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ma"><img src="../Images/fa5b5b114595f73069b0b105bcf28861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Km_g4PrpslKgBs1jkdLDQ.png"/></div></div></figure><pre class="jb jc jd je fd ln ja lo lp aw lq bi"><span id="2860" class="lr kr hi ja b fi ls lt l lu lv"><em class="lx">type ConsoleKeys </em>= <em class="lx">keyof Console</em>;<br/><br/><em class="lx">type ConsoleMethods </em>= <em class="lx">Console</em>[<em class="lx">ConsoleKeys</em>];<br/><br/><em class="lx">type CreateApply </em>= (<br/>  level: <em class="lx">ConsoleKeys<br/></em>) =&gt; <em class="lx">ProxyHandler</em>&lt;<em class="lx">ConsoleMethods</em>&gt;["apply"];</span><span id="c89e" class="lr kr hi ja b fi ly lt l lu lv"><em class="lx">const </em>createApply: <em class="lx">CreateApply </em>= (level) =&gt;<br/>  (target, thisArg, argArray) =&gt; {<br/>    messages.push({ level, argArray });<br/>    <em class="lx">return </em>target.apply(thisArg, argArray);<br/>  };<br/><br/><em class="lx">const </em>get: <em class="lx">ProxyHandler</em>&lt;<em class="lx">Console</em>&gt;["get"] = (target, prop: <em class="lx">ConsoleKeys</em>) =&gt;<br/>  <em class="lx">new </em>Proxy(target[prop], {<br/>    apply: createApply(prop),<br/>  });<br/><br/>console = <em class="lx">new </em>Proxy(console, { get });</span></pre><h1 id="4178" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">控制台消息收集</h1><p id="1a63" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">当评估代码时，<code class="du ix iy iz ja b">messages</code>将用控制台方法调用的参数填充。一旦代码执行完毕，消息就会被发送回页面，然后被清除。</p><pre class="jb jc jd je fd ln ja lo lp aw lq bi"><span id="dbbf" class="lr kr hi ja b fi ls lt l lu lv"><em class="lx">export type Message </em>= {<br/>  level: <em class="lx">ConsoleKeys</em>;<br/>  argArray: <em class="lx">any</em>[];<br/>};<br/><br/><em class="lx">let </em>messages: <em class="lx">Message</em>[] = [];</span><span id="fe4d" class="lr kr hi ja b fi ly lt l lu lv">/* ... */</span><span id="8996" class="lr kr hi ja b fi ly lt l lu lv">self.onmessage = ({ data }: { data: <em class="lx">string </em>}) =&gt; {<br/>  <em class="lx">new </em>Function(data)();<br/>  self.postMessage(messages);<br/>  messages = [];<br/>};</span></pre><h1 id="7c14" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="90b8" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">利用WebWorkers的独立作用域从页面上下文中截取<code class="du ix iy iz ja b">console</code>方法。这样，代码可以被单独评估。我还使用了<code class="du ix iy iz ja b">Proxy</code>类来拦截对所有控制台方法的所有调用。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="6c8c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="lx">来源于:</em></p><div class="mi mj ez fb mk ml"><a href="https://www.bayanbennett.com/posts/moving-code-evaluation-to-a-webworker-devlog-009" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">将代码评估转移到WebWorker | DevLog 009</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">利用WebWorkers的独立作用域从页面上下文中截取控制台方法。这样，代码…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">www.bayanbennett.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ko ml"/></div></div></a></div></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><figure class="jb jc jd je fd jf er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es na"><img src="../Images/31bf1726c783c1a6d140c6c1e9c9ac84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p81Oz9NPq_1LOGJCUj0ekg.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">thumbnail</figcaption></figure></div></div>    
</body>
</html>
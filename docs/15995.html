<html>
<head>
<title>Understand HackerRank Lego Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解HackerRank乐高积木</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understand-hackerrank-lego-blocks-bca16e1dc065?source=collection_archive---------1-----------------------#2022-12-05">https://medium.com/geekculture/understand-hackerrank-lego-blocks-bca16e1dc065?source=collection_archive---------1-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="db55" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">洞察HackerRank乐高积木问题</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7c153adab24da110af02e5b1270e8d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ossfd-7UE9oLUNLU"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@billy_huy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Billy Huynh</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="4fb2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">问题</strong></h2><p id="1441" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">你有无限数量的4种乐高积木，尺寸如下(深x高x宽):</p><pre class="iy iz ja jb fd lf lg lh bn li lj bi"><span id="67e5" class="lk jp hi lg b be ll lm l ln lo">d	h	w<br/>1	1	1<br/>1	1	2<br/>1	1	3<br/>1	1	4</span></pre><p id="88f4" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">用这些砖块，你要做一面高<em class="lu"> n </em>宽<em class="lu"> m </em>的墙。该墙的特点是:</p><p id="3555" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">-墙上不应该有任何洞。<br/> -你建造的墙应该是一个坚固的结构，所以不应该有垂直的裂缝穿过所有的砖块。砖块必须水平放置。</p><p id="cccd" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">有多少种方法可以建造这堵墙？</p><p id="dcd6" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><strong class="ko hj">例子</strong></p><pre class="iy iz ja jb fd lf lg lh bn li lj bi"><span id="2bf2" class="lk jp hi lg b be ll lm l ln lo">n = 2<br/>m = 3</span></pre><p id="002a" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">高度为2，宽度为3。总共有9种有效排列。</p><p id="3635" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><strong class="ko hj">功能描述</strong></p><p id="010e" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">在下面的编辑器中完成乐高积木功能。</p><p id="279b" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">legoBlocks具有以下参数:</p><ul class=""><li id="f286" class="lv lw hi ko b kp lp ks lq jz lx kd ly kh lz le ma mb mc md bi translated">int n:墙的高度</li><li id="d961" class="lv lw hi ko b kp me ks mf jz mg kd mh kh mi le ma mb mc md bi translated">int m:墙的宽度</li></ul><p id="e087" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><strong class="ko hj">返回</strong> <br/> - int:有效墙形成数模(10⁹+7)</p><p id="0cbe" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><strong class="ko hj">输入格式</strong></p><p id="1d86" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">第一行包含测试用例<em class="lu"> t </em>的数量。</p><p id="6e8b" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">接下来的每一行都包含两个空格分隔的整数<em class="lu"> n </em>和<em class="lu"> m </em>。</p><p id="8bfe" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><strong class="ko hj">约束条件</strong></p><pre class="iy iz ja jb fd lf lg lh bn li lj bi"><span id="70ed" class="lk jp hi lg b be ll lm l ln lo">1 &lt;= t &lt;= 100<br/>1 &lt;= n,m &lt;= 1000</span></pre><p id="e91d" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">见下面HackerRack原问题:</p><div class="mj mk ez fb ml mm"><a href="https://www.hackerrank.com/challenges/lego-blocks/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">乐高积木| HackerRank</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">你有无限数量的4种乐高积木，尺寸如下(深×高×宽):使用这些积木…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">www.hackerrank.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jh mm"/></div></div></a></div><h2 id="45eb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决办法</h2><p id="a3ea" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">有一个Python解决方案如下:</p><pre class="iy iz ja jb fd lf lg lh bn li lj bi"><span id="4d53" class="lk jp hi lg b be ll lm l ln lo">def legoBlocks(n, m):<br/>    MOD = (10**9 +7)<br/><br/>    # Step 1: O(W)       <br/>    # The number of combinations to build a single row<br/>    # As only four kinds of sizes, so<br/>    # base case: <br/>    # if width is 0, combination is 1<br/>    # if width is 1, combination is 1<br/>    # if width is 2, combination is 2<br/>    # if width is 3, combination is 4<br/>    row_combinations = [1, 1, 2, 4]<br/>    <br/>    # Build row combinations up to current wall's width<br/>    while len(row_combinations) &lt;= m: <br/>        row_combinations.append(sum(row_combinations[-4:]) % MOD)<br/>    <br/>    # Step 2: O(W)<br/>    # Compute total combinations <br/>    # for constructing a wall of height N of varying widths<br/>    total = [pow(c, n, MOD) for c in row_combinations]<br/>    <br/>    # Step 3: O(W^2)<br/>    # Find the number of unstable wall configurations <br/>    # for a wall of height N of varying widths<br/>    unstable = [0, 0]<br/>    <br/>    # Divide the wall into left part and right part,<br/>    # and calculate the combination of left part and right part.<br/>    # From width is 2, we start to consider about violation.<br/>    for i in range(2, m + 1):<br/>        # i: current total width<br/>        # j: left width<br/>        # i - j: right width<br/>        # f: (left part - previous vertical violation)*right part<br/>        f = lambda j: (total[j] - unstable[j]) * total[i - j]<br/>        result = sum(map(f, range(1, i)))<br/>        unstable.append(result % MOD)<br/>    <br/>    # Print the number of stable wall combinations<br/>    return (total[m] - unstable[m]) % MOD</span></pre><p id="d52f" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">解决这个问题需要3个步骤:</p><ol class=""><li id="f51e" class="lv lw hi ko b kp lp ks lq jz lx kd ly kh lz le nb mb mc md bi translated">只考虑一行的所有情况</li><li id="bf2e" class="lv lw hi ko b kp me ks mf jz mg kd mh kh mi le nb mb mc md bi translated">扩展到所有行</li><li id="201e" class="lv lw hi ko b kp me ks mf jz mg kd mh kh mi le nb mb mc md bi translated">减去垂直不稳定的情况</li></ol><p id="e8f5" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">有两种方法可以理解上面的步骤3。不稳定可以通过对每个(稳定*总计)(<strong class="ko hj">解1 </strong>)求和来计算，或者通过对每个(结果*总计)(<strong class="ko hj">解2 </strong>)求和来立即计算结果。下面详细请看Java来举例说明。请注意两个解决方案的注释中的“解决方案1”和“解决方案2”。</p><pre class="iy iz ja jb fd lf lg lh bn li lj bi"><span id="21e6" class="lk jp hi lg b be ll lm l ln lo">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/>    <br/>// - Step 1: consider only one row<br/>// - Step 2: extend to all rows<br/>// - Step 3: subtract the vertically unstable<br/>// The unstable is calculated by summing each stable*total<br/>// or calculate the result immediately by summing each result*total<br/><br/>    /*<br/>     * Complete the 'legoBlocks' function below.<br/>     *<br/>     * The function is expected to return an INTEGER.<br/>     * The function accepts the following parameters:<br/>     *  1. INTEGER n - height<br/>     *  2. INTEGER m - width<br/>     */<br/><br/>    public static int legoBlocks(int n, int m) {<br/>        // Write your code here<br/>        if (n &lt; 2 || m &lt; 1) return 0;<br/>        if (m == 1) return 1;<br/>        <br/>        // - Step 1: consider only one row<br/>        long [] total = new long [m + 1];<br/>        <br/>        // set a flag (-1) to calculate only once<br/>        for (int i = 0; i &lt; total.length; i++)<br/>            total[i] = -1;<br/>        <br/>        fillTot(total, m);<br/>        <br/>        // - Step 2: extend to all rows<br/>        for (int i = 0; i &lt; total.length; i++) {<br/>            long tmp = 1;<br/>            for (int j = 0; j &lt; n; j++) {<br/>                tmp = (tmp * total[i]) % MOD;<br/>            }<br/>            total[i] = tmp;<br/>        }<br/>        <br/>        // - Step 3: subtract the vertically unstable<br/>        // don't calculate the vertically unstable at first<br/>        long [] result = new long [m + 1];<br/>        // set a flag (-1) to calculate only once<br/>        for (int i = 0; i &lt; result.length; i++)<br/>            result[i] = -1;<br/>        <br/>        getResult(total, result, m);<br/>        <br/>        // solution 1:<br/>        // - subtract the vertically unstable<br/>        // return (int) ((total[m] - result[m]) % MOD);<br/>        <br/>        // solution 2:<br/>        // - return the result<br/>        return (int) (result[m] % MOD);<br/>    }<br/>    <br/>    static long MOD = 1000000000 + 7;<br/>    <br/>    // calculate unstable by splitting it into two parts and<br/>    // multiplying unstable part with total part<br/>    static long getResult(long [] total, long [] result, int i) {<br/>        if (result[i] == -1) {<br/>            if (i == 1) {<br/>                // solution 1<br/>                // result[i] = 0;<br/>                <br/>                // solution 2<br/>                result[i] = 1;<br/>            }<br/>            else {<br/>                // solution 1<br/>                // result[i] = 0;<br/>                // for (int j = 1; j &lt; i; j++) {<br/>                //     result[i] += ((total[j] - getResult(total, result, j)) * total[i - j]) % MOD;<br/>                // }<br/>                <br/>                // solution 2            <br/>                result[i] = total[i];<br/>                for (int j = 1; j &lt; i; j++) {<br/>                    result[i] -= (getResult(total, result, j) * total[i - j]) % MOD;<br/>                }<br/>            }<br/>        }<br/>        <br/>        return result[i];<br/>    }<br/>    <br/>    // fill totals partially<br/>    static long fillTot(long [] total, int i) {<br/>        if (i &lt; 0) return 0;<br/>        <br/>        if (total[i] == -1) {<br/>            if (i == 0 || i == 1) <br/>                total[i] = 1;<br/>            else <br/>                total[i] = (fillTot(total, i - 1) + fillTot(total, i - 2) + fillTot(total, i - 3) + fillTot(total, i - 4)) % MOD;<br/>        }<br/>        <br/>        return total[i];<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        int t = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, t).forEach(tItr -&gt; {<br/>            try {<br/>                String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int n = Integer.parseInt(firstMultipleInput[0]);<br/><br/>                int m = Integer.parseInt(firstMultipleInput[1]);<br/><br/>                int result = Result.legoBlocks(n, m);<br/><br/>                bufferedWriter.write(String.valueOf(result));<br/>                bufferedWriter.newLine();<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="4a0a" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">编码快乐！</p></div></div>    
</body>
</html>
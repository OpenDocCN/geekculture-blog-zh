<html>
<head>
<title>Asynchronous iterators in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的异步迭代器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/asynchronous-iterators-in-python-fdf55198287d?source=collection_archive---------1-----------------------#2022-03-10">https://medium.com/geekculture/asynchronous-iterators-in-python-fdf55198287d?source=collection_archive---------1-----------------------#2022-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ed3e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何用python编写异步for循环</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/357cc71164791585472f3abe84c0e005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*bQ18yHseShmvnW4D"/></div><figcaption class="jf jg et er es jh ji bd b be z dx"><a class="ae jj" href="https://dock2learn.com/tech/asynchronous-iterators-in-python/" rel="noopener ugc nofollow" target="_blank">https://dock2learn.com/tech/asynchronous-iterators-in-python/</a></figcaption></figure><h1 id="762f" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">简介:</h1><p id="83d7" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">作为一名开发人员，我们现在都和<code class="du ky kz la lb b">python</code>的<code class="du ky kz la lb b">iterators</code>和<code class="du ky kz la lb b">iterables</code>一起工作过。这篇文章不是对<code class="du ky kz la lb b">python</code>中迭代器和可迭代对象的另一个区别或比较。让我把多余的东西拿出来。这篇文章概述了<code class="du ky kz la lb b">asynchronous iterators</code>如何工作以及如何编写我们自己的<code class="du ky kz la lb b">asynchronous iterators</code>。</p><p id="6440" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">要了解<code class="du ky kz la lb b">asyncio</code>的介绍，请参考<a class="ae jj" href="https://dock2learn.com/tech/asyncio-in-python/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="4513" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">带走:</h1><p id="08ef" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在这篇文章的结尾，你应该能够</p><ul class=""><li id="6af9" class="lh li hi ke b kf lc ki ld kl lj kp lk kt ll kx lm ln lo lp bi translated">写一个异步迭代器。</li><li id="fac8" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">了解<code class="du ky kz la lb b">async</code>迭代器的内部。</li><li id="6602" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">正规<code class="du ky kz la lb b">iterators</code>介绍。</li><li id="fa13" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">非异步迭代器与异步迭代器有何不同。</li></ul><p id="b0df" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">现在，让我们开始吧。我们走吧。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h1 id="d7a3" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">python中的迭代器:</h1><p id="f6fd" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在讨论<code class="du ky kz la lb b">async</code>迭代器之前，让我们快速浏览一下python中的常规迭代器。</p><ul class=""><li id="1e29" class="lh li hi ke b kf lc ki ld kl lj kp lk kt ll kx lm ln lo lp bi translated">迭代器必须实现<code class="du ky kz la lb b">__iter__</code>特殊方法。</li><li id="c397" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated"><code class="du ky kz la lb b">__iter__</code>特殊方法应该返回一个<code class="du ky kz la lb b">iterable</code>，即任何实现<code class="du ky kz la lb b">__next__</code>特殊方法的对象。这可能是它自己的类(<code class="du ky kz la lb b">self</code>)或任何其他类对象。</li><li id="e71f" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated"><code class="du ky kz la lb b">__next__</code>方法具有运行<code class="du ky kz la lb b">iterator</code>的逻辑，直到满足一个条件。</li><li id="23d5" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">一旦条件满足，应出现<code class="du ky kz la lb b">StopIteration</code>错误信息。</li></ul><p id="5b30" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">现在，让我们快速编写一个<code class="du ky kz la lb b">iterator</code>，<code class="du ky kz la lb b">OddCounter</code>，它只迭代奇数。我知道这并没有什么意义。但是玩玩<code class="du ky kz la lb b">iterators</code>的能力还是很有趣的。你可以尝试实现一个偶数计数器或者斐波那契计数器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx lw l"/></div></figure><p id="c706" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">输出:</p><pre class="iy iz ja jb fd ly lb lz ma aw mb bi"><span id="49f4" class="mc jl hi lb b fi md me l mf mg">1<br/>3<br/>5<br/>7<br/>9<br/>...<br/>...<br/>93<br/>95<br/>97<br/>99</span></pre><p id="3350" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">上面的例子只是为了说明<code class="du ky kz la lb b">python</code>中常规<code class="du ky kz la lb b">iterators</code>的工作原理。既然我们已经学会了，让我们跳到我们在这里的目的。</p><h1 id="b73d" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">异步迭代器:</h1><p id="3fa1" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">在常规迭代器中，如果有一个场景，您必须执行一些I/O任务来获取<code class="du ky kz la lb b">__next__()</code>方法中的数据，该怎么办？这正是<code class="du ky kz la lb b">async iterators</code>要做的。</p><p id="5871" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated"><code class="du ky kz la lb b">async iterator</code>通常包含:</p><ul class=""><li id="273b" class="lh li hi ke b kf lc ki ld kl lj kp lk kt ll kx lm ln lo lp bi translated">一个<code class="du ky kz la lb b">__aiter__()</code>方法而不是<code class="du ky kz la lb b">__iter__()</code>方法。</li><li id="05b8" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated"><code class="du ky kz la lb b">__aiter()__</code>方法必须返回一个实现了<code class="du ky kz la lb b">async def __anext__()</code>的对象。</li><li id="fb3c" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated"><code class="du ky kz la lb b">__anext__()</code>方法必须为每次迭代返回一个值，并在结束时抛出<code class="du ky kz la lb b">StopAsyncIteration</code>，而不是<code class="du ky kz la lb b">StopIteration</code>。</li></ul><p id="685e" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">现在，让我们尝试使用异步迭代器重写我们的<code class="du ky kz la lb b">OddCounter</code>迭代器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx lw l"/></div></figure><p id="0cfb" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">输出:</p><pre class="iy iz ja jb fd ly lb lz ma aw mb bi"><span id="de9c" class="mc jl hi lb b fi md me l mf mg">1<br/>3<br/>5<br/>7<br/>9<br/>...<br/>...<br/>93<br/>95<br/>97<br/>99</span></pre><p id="85eb" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">虽然这在语法上是正确的，并且有效，但是我们没有任何令人信服的理由在这里使用<code class="du ky kz la lb b">async iterator</code>。一个这样的场景是，如果我们在<code class="du ky kz la lb b">__anext__()</code>方法中做一些需要从其他地方获取数据的操作。例如，如果我们一次从一个远程数据库或另一个协程函数获取一个数据，那么它将是编写异步迭代器的最佳选择。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx lw l"/></div></figure><p id="2c52" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated">在上面的例子中，<code class="du ky kz la lb b">KeyTaker</code>是一个异步迭代器，它从<code class="du ky kz la lb b">coroutine</code>中提取键。现在你可能会说这可以用一个简单的类和函数来完成。我们当然可以。这里的要点是，<code class="du ky kz la lb b">all_keys()</code>方法可以执行I/O操作，比如从数据库获取信息或调用API。为了简单起见，我刚刚创建了一个字典，并为查询的键返回它们的值。</p><p id="7edc" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated"><code class="du ky kz la lb b">main()</code>函数只是遍历<code class="du ky kz la lb b">KeyTaker</code>并打印值。我们也可以在<code class="du ky kz la lb b">async for</code>循环中调用另一个协程。这将使代码完整。</p><h1 id="47e3" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">总结:</h1><ul class=""><li id="b5cd" class="lh li hi ke b kf kg ki kj kl mh kp mi kt mj kx lm ln lo lp bi translated">异步迭代器有__aiter__和__anext__特殊方法</li><li id="3872" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">StopAsyncIteration应在迭代结束时引发。</li><li id="2e4e" class="lh li hi ke b kf lq ki lr kl ls kp lt kt lu kx lm ln lo lp bi translated">如果我们按需执行一个I/O操作，而迭代器又在执行另一个I/O操作，那么可以使用异步迭代器。</li></ul><h1 id="e7fa" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">参考资料:</h1><p id="9d30" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated"><a class="ae jj" href="https://peps.python.org/pep-0525/" rel="noopener ugc nofollow" target="_blank">https://peps.python.org/pep-0525/</a></p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="4e5d" class="pw-post-body-paragraph kc kd hi ke b kf lc ij kh ki ld im kk kl le kn ko kp lf kr ks kt lg kv kw kx hb bi translated"><em class="mr">原载于2022年3月10日https://dock2learn.com</em><em class="mr">T21</em><a class="ae jj" href="https://dock2learn.com/tech/asynchronous-iterators-in-python/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>
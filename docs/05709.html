<html>
<head>
<title>Everything you need to know about tail recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于尾部递归你需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/everything-you-need-to-know-about-tail-recursion-c7475ef15f4c?source=collection_archive---------25-----------------------#2021-07-28">https://medium.com/geekculture/everything-you-need-to-know-about-tail-recursion-c7475ef15f4c?source=collection_archive---------25-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归更容易编写，可读性更好，并且不需要可变性。迭代具有更好的性能，消耗更少的内存。尾部递归结合了两者的优点。本文解释了它是什么，为什么它比普通递归更有效，以及如何使函数尾递归。</p><p id="2130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文用函数式伪代码进行了说明。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4da55a300d664973d9e33a8a1395d0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UJUZb0IzAZWoCCTa"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@pastorthomasbwilson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tom Wilson</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="49e2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是尾部递归？</h1><p id="bdc8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当递归调用是一个递归函数执行的最后一个操作时，这个递归函数被称为尾递归函数。例如，下面的函数是尾部递归的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/727d4a75b71b9a7f11e189f6c8f685cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKrmAuMJHSa2Yla7uoofyw.png"/></div></div></figure><p id="6da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这个不是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/aadd72fcd2646f31d54cc31d4a6386e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TitXmU2ROAVExFEYUug9NA.png"/></div></div></figure><p id="9bf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为我们执行递归调用<code class="du ky kz la lb b">(*) x (y — 1)</code>，然后将<em class="lc"> y </em>加到结果上:相加就是最后一次调用。</p><h1 id="3db2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">何必呢？</h1><p id="5de8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">递归函数经常因其性能而受到批评，而尾递归能够解决其中一些问题。原因有几个，但我们将重点关注其中一个:堆栈帧的积累。</p><p id="6189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑下面的例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/dd0f4e3bac8397489c356ecc621b2b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89dgpNG1OoBvfRj7-u0LrA.png"/></div></div></figure><p id="7cf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对<code class="du ky kz la lb b">bad-factorial</code>的每次调用都会创建一个堆栈框架，存储函数求值过程中创建的所有局部变量。一旦函数终止，堆栈帧将被擦除。</p><p id="78c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你调用<code class="du ky kz la lb b">bad-factorial 5</code>，就会创建一个堆栈框架——我们称之为<code class="du ky kz la lb b">bf5</code>。然后<code class="du ky kz la lb b">bad-factorial 4</code>就叫了。一个新的堆栈帧<code class="du ky kz la lb b">bf4</code>被创建，但是<code class="du ky kz la lb b">bf5</code>仍然在内存中的某个地方，因为<code class="du ky kz la lb b">bad-factorial 5</code>需要知道在执行它的最后一个操作之前<code class="du ky kz la lb b">bad-factorial 4</code>将返回什么值。然后<code class="du ky kz la lb b">bad-factorial 3</code>、<code class="du ky kz la lb b">bad-factorial 2</code>、<code class="du ky kz la lb b">bad-factorial 1</code>和<code class="du ky kz la lb b">bad-factorial 0</code>都被调用，这样就创建了四个新的堆栈帧，<code class="du ky kz la lb b">bf3</code>、<code class="du ky kz la lb b">bf2</code>、<code class="du ky kz la lb b">bf1</code>和<code class="du ky kz la lb b">bf0</code>。最近的调用没有递归调用可执行，因此它终止，并且<code class="du ky kz la lb b">bf0</code>从存储器中被擦除。这允许<code class="du ky kz la lb b">bad-factorial 1</code>计算其返回值，并且<code class="du ky kz la lb b">bf1</code>也消失，接着是<code class="du ky kz la lb b">bf2</code>、<code class="du ky kz la lb b">bf3</code>、<code class="du ky kz la lb b">bf4</code>，最后是<code class="du ky kz la lb b">bf5</code>。</p><p id="fa3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算<code class="du ky kz la lb b">bad-factorial N</code>，我们需要分别存储<code class="du ky kz la lb b">N</code>的所有值，并记住它们，直到原始调用终止，返回最终结果。如果我们的函数需要在每次调用时存储一个数组或任何其他更重的数据，那么所需的空间将会变得巨大。</p><p id="4545" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将导致可怕的堆栈溢出。</p><p id="1697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个函数是尾递归的，它会在递归调用开始工作之前终止，因此不会导致堆栈溢出。</p><h1 id="68e1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何让一个递归函数尾部递归？</h1><p id="2fdd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有两种主要的技术可以将一个普通的递归函数变成尾递归函数:使用累加器变量和延续传递方式。我们将在本节中探讨这两个问题。</p><h2 id="29f0" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">累加器变量</h2><p id="d2c1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">累加器变量是一个附加参数，它对应于最后一次递归调用终止时计算的最终值。</p><p id="4295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们更新的阶乘函数，现在是尾递归的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/381dc40c72e06f970ce5c3866d5db52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*783zrfD04GEYbDW0evrmIw.png"/></div></div></figure><p id="73c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有直接改变函数，而是创建了一个内部递归函数，<code class="du ky kz la lb b">loop</code>。因此，用户不必担心累加器参数，将能够正常调用函数，只需提供<em class="lc"> N </em>的值。</p><p id="8678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">累加器变量是<code class="du ky kz la lb b">result</code>。</p><p id="7987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不是将<code class="du ky kz la lb b">factorial (N — 1)</code>的结果乘以<em class="lc"> N </em>，而是将<em class="lc"> N </em>传递给它，这样它就知道结果最终必须乘以<em class="lc"> N </em>。同样，<code class="du ky kz la lb b">factorial (N — 1)</code>将累加器乘以<em class="lc">N</em>-1——取值<em class="lc">N</em>(<em class="lc">N</em>-1)——并发送给<code class="du ky kz la lb b">factorial (N — 2)</code>，后者将累加器更新为<em class="lc">N</em>(<em class="lc">N</em>-1)(<em class="lc">N</em>-2)，以此类推。</p><p id="956f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的计算机上使用F#时，非尾递归阶乘函数在用10^6调用时会导致堆栈溢出，尾递归函数在这方面做得很好。</p><p id="9db6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个更复杂的例子是计算某个自然数<em class="lc"> n </em>的第<em class="lc"> n </em>个斐波那契数。为了编写一个尾部递归Fibonacci计算器，我们需要引入两个累加器变量:一个对应于最终值，另一个对应于前一项。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/bb7386f90c8666eb6dd44a5d485ebcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lc9F4o79NnM7NIwXEaHmFA.png"/></div></div></figure><p id="758c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过添加<code class="du ky kz la lb b">previous</code>来更新结果，在下面的递归调用中，当前结果将是前一个结果。</p><h2 id="1ee7" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">连续传球风格</h2><p id="1c3e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用累加器变量使函数尾部递归并不总是可能的。延续传递风格，简称CPS，解决了这个问题:它是一种更通用的技术，允许将任何递归转换为尾部递归。它稍微复杂一些，一开始可能会有点混乱，但是一切都会好的！</p><p id="2c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不是将累加器变量传递给递归函数<em class="lc"> f </em>，而是传递另一个函数告诉<em class="lc"> f </em>当它完成计算时该做什么。我们称这个函数为连续函数。</p><p id="d0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们函数的非尾递归版本有签名<code class="du ky kz la lb b">f: T -&gt; U</code>，其中T和U是类型，那么尾递归版本有签名<code class="du ky kz la lb b">f: T -&gt; (U -&gt; U) -&gt; U</code>。每次调用都会更新continuation函数，基础用例将其结果传递给它，产生最终的计算结果。</p><p id="6866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设我们想计算二叉树中所有节点的值的总和。非尾递归函数如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/a70c20f34727ca6c2725da245a1cb829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_IRHdByghaUOErtNZUpTQ.png"/></div></div></figure><p id="6370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不是执行两次递归调用，而是只在一个子树(比如左边的)上递归，并使用一个连续函数来告诉递归调用:</p><p id="daa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你完成了，把你的结果发给我。我会计算右子树的和，把它们加起来。”</p><p id="8dad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更准确地说，我们传递给递归调用的延续函数:</p><ol class=""><li id="89b0" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">取一个参数，<code class="du ky kz la lb b">leftSum</code>；</li><li id="fa34" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">递归计算右边子树的和<code class="du ky kz la lb b">rightSum</code>;</li><li id="10d2" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">将<code class="du ky kz la lb b">leftSum + rightSum</code>传递给最初的延续函数。</li></ol><p id="4cef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果树是空的，我们只需向continuation函数发送0。初始连续函数是恒等函数。</p><p id="8e9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们实现函数<code class="du ky kz la lb b">sum</code>的CPS版本如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/5184cd0be69b86906ce24a388e7f7ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b88G8RsCZ8UYTsCGfM_xDg.png"/></div></div></figure><p id="b0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，这有点让人困惑。我们会给出一个证明，证明它是正确的，希望这能让我们对它的工作原理有一些直觉。</p><p id="9898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一棵只有一个节点的树，值为<em class="lc"> x </em>。初始延续功能是<code class="du ky kz la lb b">c0 = id</code>。</p><p id="ef64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算树的和<code class="du ky kz la lb b">S</code>，我们首先计算左子树的和<code class="du ky kz la lb b">SL</code>(第11行)，然后调用<code class="du ky kz la lb b">c1</code>(定义在第6行)。<code class="du ky kz la lb b">c1</code>计算右边子树的总和<code class="du ky kz la lb b">SR</code>(第9行)并调用<code class="du ky kz la lb b">c0 (x + SL + SR)</code>(第7行和第8行)。</p><p id="f80e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<code class="du ky kz la lb b">SL</code>为空，所以我们只调用<code class="du ky kz la lb b">c1 0</code>(第4行)。它计算<code class="du ky kz la lb b">SR</code>，也是空的，返回<code class="du ky kz la lb b">c0 (0 + 0 + x)</code>，也就是<code class="du ky kz la lb b">x</code>。</p><p id="00f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经成功地计算了只有一个节点的树的和。</p><p id="573f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设现在我们的函数可以计算一棵最多有<em class="lc"> n </em>个节点的树的和，对于某个自然数<em class="lc"> n </em>。更准确地说，<code class="du ky kz la lb b">loop tree c</code>，其中<code class="du ky kz la lb b">tree</code>最多有<em class="lc"> n个</em>节点，返回<code class="du ky kz la lb b">c ST</code>，其中<code class="du ky kz la lb b">ST</code>是树的实际总和。</p><p id="2263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在考虑具有n + 1个节点的树<code class="du ky kz la lb b">tree</code>。通过归纳假设，<code class="du ky kz la lb b">loop left continuation'</code>返回<code class="du ky kz la lb b">continuation' SL</code>，其中<code class="du ky kz la lb b">SL</code>是左子树的实际和。同样，<code class="du ky kz la lb b">loop right continuation''</code>返回<code class="du ky kz la lb b">continuation'' SR</code>，其中<code class="du ky kz la lb b">SR</code>是右边子树的实际和。因此<code class="du ky kz la lb b">loop tree id</code>的返回值是<code class="du ky kz la lb b">id SR + SL + value</code>，其中<code class="du ky kz la lb b">value</code>是根节点的值。这证明我们已经成功地计算出了<code class="du ky kz la lb b">tree</code>的总和。</p><p id="d5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过归纳，上面的功能<code class="du ky kz la lb b">sum</code>是正确的。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="91ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以最后一个例子结束:二叉树的有序遍历。下面是一个非尾递归版本的样子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/0be29c34c51e07969492c72cc8874f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kmoY-FpTFyoCivpz7ejbQ.png"/></div></div></figure><p id="1d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代替在函数体中运行第4行和第5行，我们将创建一个continuation函数，它说“一旦你遍历了左子树，将当前值传递给<code class="du ky kz la lb b">f</code>，然后遍历右子树。”。</p><p id="148a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们如何将它翻译成代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/2b391f479dec6748319cf4c5cfd5b4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ovd09dqw8KcwSXxRJubzVA.png"/></div></div></figure></div></div>    
</body>
</html>
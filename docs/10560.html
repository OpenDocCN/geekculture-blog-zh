<html>
<head>
<title>Automate HTTPS Certificates with Ansible Roles ft. Let’s Encrypt &amp; CloudFlare</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化HTTPS证书与可预见的角色。让我们加密&amp; CloudFlare</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/automate-https-certificates-with-ansible-roles-ft-lets-encrypt-cloudflare-16a07d5211db?source=collection_archive---------18-----------------------#2022-02-04">https://medium.com/geekculture/automate-https-certificates-with-ansible-roles-ft-lets-encrypt-cloudflare-16a07d5211db?source=collection_archive---------18-----------------------#2022-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cf4f0e1bc91f506298ddeb7532c1a594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UIoTRktuNhwIu4lYLIANQ.jpeg"/></div></div></figure><h1 id="74db" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">概述</h1><p id="4391" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们已经看到了如果你有一个VPS并且你正在使用Nginx，如何在域上<a class="ae km" href="https://santoshk.dev/posts/2021/how-i-enabled-https-on-my-ec2-hosted-website/" rel="noopener ugc nofollow" target="_blank">启用HTTPS。在另一篇文章中，我们也谈到了</a><a class="ae km" href="https://santoshk.dev/posts/2021/getting-started-with-ansible-as-a-fullstack-developer/" rel="noopener ugc nofollow" target="_blank">开始使用Ansible </a>，在这篇文章中，我写了Ansible中的一些基本概念，比如库存、模块、剧本。我们还讨论了有关目录结构的角色。</p><h1 id="4912" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">我们将涵盖的内容</h1><p id="5811" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在<a class="ae km" href="https://santoshk.dev/posts/2021/wildcard-domain-certificate-using-aws-route53-and-lets-encrypt/" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，我们看到了我是如何在一个网站的所有子域名上启用HTTPS的。我是手动做的，不是用Ansible。这篇文章是我将自动化这个过程的延续。</p><p id="c0f4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在上一篇帖子中，我也没有在公开回购中添加任何东西，因为我发现在网上公开存储我的安全相关数据令人毛骨悚然。因此，我们可以使用称为变量的东西，而不是将配置公开放在任务或模板上。vairables的好处是我们可以把它放在一个单独的文件中，并从那里使用它。如果我们分开保存变量，我们也可以从命令行覆盖变量，并使用ansi ble-vault来加密它们。变量也用于替换模板文件中的占位符文本。</p><p id="1144" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这是我的Ansible学习系列的第三篇文章，在这篇文章中，我将谈论:</p><ul class=""><li id="bd33" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">如何在获取HTTPS证书的自动化过程中使用Ansible？</li><li id="5b93" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">另一方面，我将介绍模板和变量。我们还将看到如何从命令行覆盖变量。</li></ul><h1 id="48f9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">从我们停下的地方继续</h1><p id="8e9a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">只是为了让每个人都在相同的轨道上(假设你自己也在这样做)。我现在就有这个装置。</p><ol class=""><li id="548a" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated"><strong class="jq hj"> 1 VPC </strong>运行<em class="lh"> Ubuntu 20.04 </em>。我从AWS租赁的。你可以从任何你想租的地方租。确保你可以ssh到它，并有sudo访问安装的东西。</li><li id="a58c" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated"><strong class="jq hj"> 1域</strong>。HTTPS证书通常颁发给域名，而不是IP地址。</li><li id="ad80" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">我的Ansible配置的v0.1.0版<a class="ae km" href="https://github.com/santosh/ansible/tree/v0.1.0" rel="noopener ugc nofollow" target="_blank">。</a></li></ol><p id="b681" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">一个旁注</strong>。您不能将Windows作为控制节点。虽然可以用Linux/Mac来管理Windows机器。这意味着，如果你在Windows上，请使用WSL或切换到Linux或Mac，以方便为准。</p><p id="bf8b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">另一面注</strong>。这一次我没有我的santosh.pictures域，我在以前的帖子中使用过。相反，我将使用这个santoshk.dev域。关于这个领域的一些事情:</p><ol class=""><li id="35a9" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated">映射到netlify，它是我的Hugo JAMStack网站的主机。所以我们只有<code class="du li lj lk ll b">*.santoshk.dev</code>可以修补。</li><li id="413b" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">与本系列之前的一些帖子不同，这个域名不是停在53号公路上，而是在namecheap.com。</li></ol><p id="9d3e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你实际上不需要在namecheap上注册/转让你的域名。我试图使这篇文章注册不可知。</p><h1 id="539b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">用我们的剧本安装Jenkins和Nginx</h1><p id="caf2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你跟着我，你需要用我们的剧本<a class="ae km" href="https://github.com/santosh/ansible" rel="noopener ugc nofollow" target="_blank">克隆我的可配置</a> &gt;检验到<code class="du li lj lk ll b">v.0.1.0</code> &gt;安装nginx和jenkins。</p><p id="bbb5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这是我用来在EC2机器上安装Jenkins和Nginx的命令:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="cf32" class="lu ir hi ll b fi lv lw l lx ly">ansible-playbook -i inventory -u ubuntu playbooks/jenkins.yml ansible-playbook -i inventory -u ubuntu playbooks/nginx.yml</span></pre><p id="453c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你不熟悉上面的命令，你一定要看看我以前的帖子。</p><p id="6224" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一旦您运行我们自己编写的nginx剧本，您应该会在剧本的控制台输出中收到一个IP地址。如果你去那个地址，你应该看到解锁詹金斯网页。</p><p id="4534" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">Jenkins页面的真正需求是，我们必须在浏览器和AWS上的Jenkins服务器之间建立安全连接。为此，我们需要一个域名。</p><h1 id="5b42" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务1:为子域输入一个DNS条目</h1><p id="f7d7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我将把ci.santoshk.dev映射到运行nginx剧本后得到的IP地址。这是一个手动过程，将取决于你的域名停在哪里。</p><p id="f49b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">基本上我所做的就是创建了一个<em class="lh"> A记录</em>，host是<code class="du li lj lk ll b">ci</code>而<code class="du li lj lk ll b">Value</code>是nginx主机的IP。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/3916ad93604f34154b60475643547151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MV4wnZn6VWTtUEaRtSAlYA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx"><em class="me">Adding A Record</em></figcaption></figure><h1 id="91eb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务2:为每个子域配置单独的nginx</h1><p id="2f78" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在我们的角色中查看v0.1.0的<code class="du li lj lk ll b">nginx.conf</code>，特别是<code class="du li lj lk ll b">server</code>块:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="bc99" class="lu ir hi ll b fi lv lw l lx ly">server {<br/>        listen       80 default_server;<br/>        listen       [::]:80 default_server;<br/>        server_name  _;<br/>        root         /usr/share/nginx/html;<br/><br/>        # Load configuration files for the default server block.<br/>        include /etc/nginx/default.d/*.conf;<br/><br/>        location / {<br/>            proxy_pass http://localhost:8080/;<br/>        }<br/><br/>        error_page 404 /404.html;<br/>            location = /40x.html {<br/>        }<br/><br/>        error_page 500 502 503 504 /50x.html;<br/>            location = /50x.html {<br/>        }<br/>    }</span></pre><p id="5ee4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我们计划在根域上托管Jenkins，那么这个配置就可以工作。但是现在我们是在子域的基础上做的，我们需要把它提取到另一个文件。</p><h1 id="d77c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务2.1:分离核心nginx和jenkins配置</h1><p id="9d36" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将从<code class="du li lj lk ll b">nginx.conf</code>中删除第43–45行，然后将它放在一个名为<code class="du li lj lk ll b">jenkins.conf</code>的单独文件中。以下是这个文件的内容。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="2be0" class="lu ir hi ll b fi lv lw l lx ly">server {<br/>    server_name ci.santoshk.dev;</span><span id="4455" class="lu ir hi ll b fi mf lw l lx ly">    location / { <br/>        proxy_pass <a class="ae km" href="http://localhost:8080/;" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/;</a><br/>    }<br/>}</span></pre><p id="5bc8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在稍微解释一下。正如你所看到的，我们在这个文件中覆盖了<code class="du li lj lk ll b">server_name</code>指令，告诉nginx下面的反向代理条目是针对ci.santoshk.dev子域的。这里，每个反向代理条目将被映射到ci.santoshk.dev + path，例如<code class="du li lj lk ll b">ci.santoshk.dev</code> + <code class="du li lj lk ll b">/</code> = <code class="du li lj lk ll b">ci.santoshk.dev/</code>。哪一个会去<code class="du li lj lk ll b">localhost:8080</code>。</p><p id="1a19" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我希望我在这里是清楚的，如果不是，请留下评论，我会尽我所能解释这一点。</p><p id="d3a5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">还请注意，上述<code class="du li lj lk ll b">nginx.conf</code>将被存储在<code class="du li lj lk ll b">/etc/nginx/nginx.conf</code>。而<code class="du li lj lk ll b">jenkins.conf</code>注定是nginx主机上的<code class="du li lj lk ll b">/etc/nginx/conf.d/ci.santoshk.dev.conf</code>。</p><p id="a08c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">有了詹金斯和Nginx的支持。和nginx重启与上述分离，让我们检查…</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="f933" class="lu ir hi ll b fi lv lw l lx ly">ubuntu@ip-10-2-1-10:/etc/nginx$ curl http://ci.santoshk.dev<br/>&lt;html&gt;&lt;head&gt;&lt;meta http-equiv='refresh' content='1;url=/login?from=%2F'/&gt;&lt;script&gt;window.location.replace('/login?from=%2F');&lt;/script&gt;&lt;/head&gt;&lt;body style='background-color:white; color:white;'&gt;<br/><br/><br/>Authentication required<br/>&lt;!--<br/>--&gt;<br/><br/>&lt;/body&gt;&lt;/html&gt;</span></pre><p id="b183" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">是啊，看来我们要有所进展了。看起来这个页面正在将我们重定向到<code class="du li lj lk ll b">/login?from=%2F</code>，这是Jenkins的登录页面。</p><p id="cc9c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">但是，如果你试图在浏览器上访问站点<code class="du li lj lk ll b">http://ci.santoshk.dev</code>，情况就不一样了。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/191fe170503f4e50eb3348f88f64a749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*Nu-HbTun3Olfd6OVbfw39w.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx"><em class="me">Connection Error</em></figcaption></figure><p id="54d4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这是因为你的浏览器将你从<code class="du li lj lk ll b">http://ci.santoshk.dev</code>-&gt;-T12【注意http后面的<code class="du li lj lk ll b">s</code>】重定向过来。在2022年，这是所有现代浏览器的默认行为。</p><p id="d013" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们很快就会回到这个问题上来，但让我们先做下一件事。</p><h1 id="6551" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务2.2:让nginx配置成为jenkins角色的一部分</h1><p id="a736" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">实际上，我并没有对我的回购协议做任何修改。实际上，我在上面创建的文件应该放在jenkins角色中。现在，我们将把它放在<code class="du li lj lk ll b">roles/jenkins/files</code>子目录中。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="0f3c" class="lu ir hi ll b fi lv lw l lx ly">$ tree roles/jenkins/<br/>roles/jenkins/<br/>├── files<br/>│   └── jenkins.conf<br/>└── tasks<br/>    ├── debian.yml<br/>    ├── main.yml<br/>    └── redhat.yml<br/><br/>2 directories, 4 files</span></pre><p id="6191" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们还将在安装jenkins时复制此配置。为此，我在<code class="du li lj lk ll b">roles/jenkins/tasks/main.yml</code>中添加了一个新任务:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="6dc9" class="lu ir hi ll b fi lv lw l lx ly">- include: redhat.yml<br/>   when: ansible_os_family == "RedHat"<br/> <br/>+- name: ensure /etc/nginx/conf.d/ directory exists<br/>+  file: path=/etc/nginx/conf.d state=directory recurse=yes<br/>+- name: copy jenkins nginx config<br/>+  copy: src=jenkins.conf dest=/etc/nginx/conf.d/ci.santoshk.dev.conf<br/> - name: run systemctl daemon-reload<br/>   ansible.builtin.systemd:<br/>     daemon_reload: yes</span></pre><p id="546f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你这样做了，并且在一个新的实例上运行这两个角色，你应该能够运行上面提到的<code class="du li lj lk ll b">curl</code>命令，并期望得到相同的结果。</p><p id="2c55" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">采取行动</strong>:如果你自己正在学习本教程，并且真的想记住知识，那么请验证playbook正在工作，并且你能够从nginx主机上获得相同的输出。</p><h1 id="3479" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务3:使用变量和模板重构现有角色</h1><p id="32af" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">即使在这个阶段，我们已经有太多的硬编码关键字，现在我们需要使用Ansible中的另一个概念。这将使我们的工作变得容易，因为我们可以对相同的变量使用不同的值。是的，你猜对了。我们将使用变量。</p><p id="a1e6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">使用变量的<a class="ae km" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html" rel="noopener ugc nofollow" target="_blank">文档页面是你首先应该参考的。如果你觉得这很吓人，我会保护你的。</a></p><p id="79b2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">即使在<a class="ae km" href="https://github.com/santosh/ansible/tree/4276b7c624bc572195dce6de3b07b7be634873a1" rel="noopener ugc nofollow" target="_blank">这一点上</a>我们也有很多地方可以改进。一个大的重构是移除根域的硬编码。</p><p id="7ad4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我实际上打算公开我的ansible配置，让全世界都可以访问它，在这种情况下,<code class="du li lj lk ll b">santoshk.dev</code>没有多大意义。这个值应该是动态的，应该在玩书的时候从命令行传递</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/f6c7594261826cc5ed8e3924bd508193.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*DI22XVD-4vPP1SRDcnYDzA.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Hardcoded root domain</figcaption></figure><p id="ccfd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这样，别人就更容易使用我的角色。让我们采取主动:</p><h1 id="bbd5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务3.1:将文件转换为模板</h1><p id="bc70" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你用<code class="du li lj lk ll b">{{ fqdn }}</code>替换所有出现的域名，你会有2个。conf文件，每一个都分别处于nginx和jenkins角色。角色的<code class="du li lj lk ll b">files</code>子目录中的这些配置文件现在无效。这是因为文件不能有变量。<code class="du li lj lk ll b">files</code>子目录中的每个文件都是专门为了从控制器移动到受控节点，没有任何动态性。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="4987" class="lu ir hi ll b fi lv lw l lx ly">Changes not staged for commit:<br/>        modified:   roles/jenkins/files/jenkins.conf<br/>        modified:   roles/jenkins/tasks/main.yml<br/>        modified:   roles/nginx/files/nginx.conf</span></pre><p id="0d53" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们必须将它们从<code class="du li lj lk ll b">files</code>子转盘移到<code class="du li lj lk ll b">templates</code>子转盘。此外，让它们有一个. j2扩展名，表示一个Jinja2模板文件。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="a0e7" class="lu ir hi ll b fi lv lw l lx ly">Changes to be committed:<br/>        renamed:    roles/jenkins/files/jenkins.conf -&gt; roles/jenkins/templates/jenkins.conf.j2<br/>        renamed:    roles/nginx/files/nginx.conf -&gt; roles/nginx/templates/nginx.conf.j2</span></pre><p id="7bb5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您还需要将两个角色中的<code class="du li lj lk ll b">copy</code>模块改为<code class="du li lj lk ll b">template</code>模块。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="7e93" class="lu ir hi ll b fi lv lw l lx ly">-  copy: src=jenkins.conf dest=/etc/nginx/conf.d/ci.santoshk.dev.conf<br/>+  template: src=jenkins.conf.j2 dest=/etc/nginx/conf.d/ci.{{ fqdn }}.conf</span></pre><p id="8fc6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">别忘了<code class="du li lj lk ll b">.j2</code>。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="9705" class="lu ir hi ll b fi lv lw l lx ly">-  copy: src=nginx.conf dest=/etc/nginx/nginx.conf mode=preserve<br/>+  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf mode=preserve</span></pre><p id="3bf2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在我提交上述更改之前，我需要在文件的某个地方存储一个<code class="du li lj lk ll b">fqdn</code>的默认值。</p><h1 id="de63" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务3.2:将默认值设置为变量</h1><p id="0889" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">接下来，您需要在我们的ansible config repo中的某个地方定义这个<code class="du li lj lk ll b">fqdn</code>变量。这个变量的去向是一个很好的问题。文件上说<a class="ae km" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#understanding-variable-precedence" rel="noopener ugc nofollow" target="_blank">申报单可以放在16个地方</a>。</p><p id="999c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这16种中，让我们从最常见的开始。</p><ol class=""><li id="b380" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated"><strong class="jq hj">内部角色的</strong> <code class="du li lj lk ll b">default</code> <strong class="jq hj">下级</strong>。</li></ol><p id="02dd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这个子目录专用于静态变量。这意味着，如果你必须构建一个类似_<a class="ae km" href="https://archive.apache.org/dist/tomcat/tomcat-version/_," rel="noopener ugc nofollow" target="_blank">https://archive.apache.org/dist/tomcat/tomcat-version/_,</a>的URL，那么<code class="du li lj lk ll b">https://archive.apache.org/dist/tomcat/tomcat-</code>部分将放入<code class="du li lj lk ll b">default</code>，因为它们很可能不会改变。</p><p id="5f1e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2.<strong class="jq hj">里面角色的</strong> <code class="du li lj lk ll b">vars</code> <strong class="jq hj">分角色的</strong>。</p><p id="e795" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">继续上面的例子，<code class="du li lj lk ll b">version</code>零件将放入这个子零件中，因为它们将随着时间不断增加。</p><p id="e483" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">3.<strong class="jq hj">内</strong>外<code class="du li lj lk ll b">host_vars</code>。</p><p id="34c4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这用于覆盖<code class="du li lj lk ll b">default</code>或<code class="du li lj lk ll b">vars</code>中特定于任何机器的任何变量。</p><p id="ce5d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">4.内部<code class="du li lj lk ll b">group_vars</code>。</p><p id="dc8a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这将覆盖上面列出的所有内容。<code class="du li lj lk ll b">group_vars</code>按照惯例用于覆盖特定的一组机器。这种分组因组织而异。</p><p id="7ad2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们可以将该变量放入的最窄的合理范围是jenkins角色范围(var和default)。这本来是可行的，但如果我们这样做，我们就会有一个副本。这是因为nginx角色也列出了相同的域名。当我们编写certbot角色时，我们会有相同的副本。我们需要考虑更大范围的事情。</p><p id="527c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这一次，我将使用group_vars方法。但是在这篇文章的后面，我们将同时使用<code class="du li lj lk ll b">default</code>和<code class="du li lj lk ll b">vars</code>。</p><p id="cf0a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为此，让我们在根目录下创建一个文件夹<code class="du li lj lk ll b">group_vars</code>，并在其中包含一个名为<code class="du li lj lk ll b">all</code>的文件。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="705d" class="lu ir hi ll b fi lv lw l lx ly">$ mkdir group_vars<br/>$ touch group_vars/all</span></pre><p id="70ad" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">打开文件，写下以下内容:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="3686" class="lu ir hi ll b fi lv lw l lx ly">---</span><span id="b945" class="lu ir hi ll b fi mf lw l lx ly">fqdn: santoshk.dev</span></pre><p id="247e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">所有这一切加在一起，这个工作没有错误。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="8e91" class="lu ir hi ll b fi lv lw l lx ly">PLAY RECAP ******************************************************************************************<br/>10.2.1.10                  : ok=9    changed=3    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</span></pre><p id="9cd1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我登录到那台机器，验证<code class="du li lj lk ll b">fqdn</code>是否被替换为实际值。</p><p id="84bb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您想从命令行覆盖<code class="du li lj lk ll b">fqdn</code>的值，您可以将<code class="du li lj lk ll b">-e "fqdn=example.com"</code>传递给ansible或ansible-playbook命令。下面的例子:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="16af" class="lu ir hi ll b fi lv lw l lx ly">ansible-playbook -i inventory -u ubuntu playbooks/nginx.yml -e "fqdn=example.com"</span></pre><p id="4ee0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">更新到这里可以在<a class="ae km" href="https://github.com/santosh/ansible/tree/v0.3.0" rel="noopener ugc nofollow" target="_blank">https://github.com/santosh/ansible/tree/v0.3.0</a>找到</p><h1 id="a3f6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务4:将名称廉价名称服务器指向CloudFlare for certbot</h1><p id="ffb8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这种情况对我来说是特定的，因为我使用Namecheap来保留我的域名，但我也想做一个基于DNS的验证来显示我们要加密的域名的所有权。Namecheap对Let's Encrypt的支持是有争议的。虽然你应该为商业实体使用付费证书是正确的，但这不适用于我们这些正在学习SSL的人。<a class="ae km" href="https://community.letsencrypt.org/t/web-hosting-who-support-lets-encrypt/6920#nosupport" rel="noopener ugc nofollow" target="_blank">您可能想阅读这篇关于Namecheap上certbot dns认证支持的</a>。</p><p id="14eb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">只要你使用<a class="ae km" href="https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins" rel="noopener ugc nofollow" target="_blank">这些DNS提供商中的任何一个</a>，你就是好的。因为Namecheap不在其中，所以我决定换一个上面提到的。如果您的域名没有在该列表中的任何注册商处注册，那么我建议您不花任何钱就改用CloudFlare。</p><p id="c7ae" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我决定将我的域名服务器指向CloudFlare的域名服务器，并从那里管理DNS。我将快速浏览一下将这个DNS设置从Namecheap切换到CloudFlare的过程。</p><ol class=""><li id="74f4" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated">注册并将站点添加到CloudFlare</li></ol><p id="b4c9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注册<a class="ae km" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> CloudFlare </a>完全免费。注册后，寻找一个写着“添加网站”的按钮。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/b2f26a95d63a8ab810423412e1111585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hERi3c2MLQx-6ndpLpqTvQ.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Add a new site to CloudFlare</figcaption></figure><p id="a4ae" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一旦你这样做，选择免费计划。这个计划对我们将要做的事情来说已经足够了。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/86a5bc07bb56b484ebc3c5707ee2af3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*o5DA5g6cK2LKyTCa-jMnqA.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Choose the free plan</figcaption></figure><p id="4669" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一旦您选择了计划，CloudFlare将扫描您现有的域中的DNS条目，并让您使用它们创建相同的条目，以无缝完成迁移过程。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/45488d21516578bae48d0d5d958e6534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPXRe9Xf6tKEGbwp397ZTA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Review DNS records to import</figcaption></figure><p id="2ae5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在剩下的唯一一步是更改名称服务器条目。向你的注册商查询哪里可以改变你的域名服务器。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/6e6746fe0c5095dfa2e0075e0f2e5345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjEJudMFt4u8OYPA87r8-w.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Change nameserver from Namecheap to CloudFlare</figcaption></figure><p id="9eff" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我已经通过域名服务器更新了这些内容:</p><p id="ba59" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，我有一个域名为Namecheap的域名，其域名服务器指向CloudFlare。</p><h1 id="cdfc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务5:使用Ansible自动生成证书</h1><p id="81ee" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">子域条目创建后返回Ansible。我们需要使用certbot，就像我们在之前的帖子中所做的那样。在那篇文章中，我们使用了route53 dns插件。不过这次我们要用的是<a class="ae km" href="https://certbot-dns-cloudflare.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> cloudflare插件</a>。</p><h1 id="efda" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务5.1:获取CloudFlare API令牌</h1><p id="0212" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">certbot必须通过编程方式与CloudFlare对话，以验证域的所有权。因此，我们必须从他们那里获得API令牌来代表我们行事。</p><p id="f2e9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要做到这一点…</p><ol class=""><li id="70fc" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated">转到CloudFlare配置文件的<a class="ae km" href="https://dash.cloudflare.com/profile/api-tokens" rel="noopener ugc nofollow" target="_blank"> API令牌</a>部分，点击“创建令牌”按钮。</li><li id="bd35" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">向下滚动并寻找一个选项，显示<strong class="jq hj">创建自定义令牌</strong>选择“开始”。</li><li id="f89d" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">创建自定义令牌以编辑DNS区域。确保包括所有区域。</li></ol><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/69796588fd32be2548944f75cbd52ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgwqPZn7m1R1k4DQ_Ly6ow.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">API Token to edit DNS Zone</figcaption></figure><p id="8743" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可能想要复制如上图所示的设置。<br/> 4。继续<strong class="jq hj">查看概要</strong>，然后<strong class="jq hj">创建令牌</strong>。你会得到类似<code class="du li lj lk ll b">tqFnsPtJyFAKet0KENpeIpu8lt4j_eu6JlJlYhEM</code>的东西。记下来。</p><p id="3250" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您还有任何困惑，请查看<a class="ae km" href="https://certbot-dns-cloudflare.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> certbot-dns-cloudflare </a>。</p><h1 id="4871" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务5.2:创建证书机器人角色以获取证书</h1><p id="7d13" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在是时候开始实际的证书生成工作了。受<a class="ae km" href="https://santoshk.dev/posts/2021/wildcard-domain-certificate-using-aws-route53-and-lets-encrypt/#step-3-get-certificate-for-your-domain--subdomains-from-lets-encrypt" rel="noopener ugc nofollow" target="_blank">手动启用域上的HTTPS</a>的启发，我将编写一个等效的ansible角色。由于关注点的分离，我们没有将此流程包括在任何一个现有的角色中。首先，我们需要从Jenkins或Nginx角色中分离出来，这样我们就可以在缺少这些角色的情况下重用这个角色。我们总是可以结合使用它们。</p><p id="8ec6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里与上一篇文章的主要区别是，我们这次使用的是CloudFlare。IAM和Route53不相关。</p><p id="b977" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最好先概述一下我们希望这个角色实现的目标:</p><ol class=""><li id="1808" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lg ky kz la bi translated">安装证书机器人</li><li id="e97d" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">安装certbot cloudflare dns插件</li><li id="b20c" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lg ky kz la bi translated">将<code class="du li lj lk ll b">dns_cloudflare_api_token</code>存储在cloudflare.ini中并运行certbot</li></ol><p id="326f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">写完这个角色后，我们还需要对现有角色进行一些更新。</p><p id="1460" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此，让我们快速浏览一下certbot角色中的文件。</p><h2 id="4674" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">roles/certbot/tasks/main.yml</h2><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="23de" class="lu ir hi ll b fi lv lw l lx ly">- include: debian.yml<br/>  when: ansible_os_family == "Debian"</span><span id="b7a5" class="lu ir hi ll b fi mf lw l lx ly">- name: create /etc/letsencrypt<br/>  file: path=/etc/letsencrypt state=directory recurse=yes<br/>- name: copy cloudflare.ini<br/>  template: src=cloudflare.ini.j2 dest=/etc/letsencrypt/cloudflare.ini<br/>- name: run certbot<br/>  command: certbot certonly --dns-cloudflare --dns-cloudflare-credentials /etc/letsencrypt/cloudflare.ini --email '{{ letsencrypt_email }}' --domain '*.{{ fqdn }}' --agree-tos --non-interactive</span></pre><h2 id="0045" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">roles/certbot/tasks/debian.yml</h2><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="efe9" class="lu ir hi ll b fi lv lw l lx ly">- name: update all packages on Debian<br/>  apt: "upgrade=yes update_cache=yes cache_valid_time=86400"<br/>- name: install pip3<br/>  apt: name=python3-pip state=present<br/>- name: install certbot and certbot-dns-cloudflare<br/>  command: pip3 install certbot 'zope.interface&gt;=5.3.0a1' certbot-dns-cloudflare</span></pre><h2 id="1999" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">roles/certbot/vars/main.yml</h2><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="4565" class="lu ir hi ll b fi lv lw l lx ly">---<br/>letsencrypt_email: <a class="ae km" href="mailto:you@example.com" rel="noopener ugc nofollow" target="_blank">you@example.com</a></span></pre><h2 id="9457" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">roles/cert bot/templates/cloud flare . ini . J2</h2><p id="b514" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个API令牌与我们之前获得的令牌相同。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="2b54" class="lu ir hi ll b fi lv lw l lx ly">dns_cloudflare_api_token = {{ dns_cloudflare_api_token }}</span></pre><h2 id="5efb" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">剧本/nginx.yml</h2><p id="d5ba" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我已经决定在nginx角色之前运行这个角色，所以这个:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="19f1" class="lu ir hi ll b fi lv lw l lx ly">hosts:<br/>     - web<br/>   roles:<br/>+    - certbot<br/>     - nginx</span></pre><p id="8d70" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">有了上面的文件，我运行这个命令来执行:</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="834f" class="lu ir hi ll b fi lv lw l lx ly">ansible-playbook -i inventory -u ubuntu playbooks/nginx.yml -e "letsencrypt_email=&lt;<a class="ae km" href="mailto:myemail@domain.com" rel="noopener ugc nofollow" target="_blank">myemail@domain.com</a>&gt;" -e "dns_cloudflare_api_token=LtWvEXAMPLEvs8mZnqMs_syNvHdIMA2w9EcHPEhL"</span></pre><p id="e7b7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里的新东西是<code class="du li lj lk ll b">-e</code>语法。我们已经在上面的一个模板中定义了<code class="du li lj lk ll b">dns_cloudflare_api_token</code>。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="bb29" class="lu ir hi ll b fi lv lw l lx ly">PLAY RECAP *****************************************************************************************************<br/>10.2.1.10                  : ok=14   changed=2    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0</span></pre><p id="ab72" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们的certbot角色将在<code class="du li lj lk ll b">/etc/letsencrypt/live/{{ fqdn }}/</code>生成并保存证书。</p><p id="a676" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">采取行动</strong>:在<code class="du li lj lk ll b">playbooks/nginx.yml</code>中禁用nginx角色，仅运行certbot角色。它应该运行没有任何错误。</p><h1 id="13af" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">任务5.3:在nginx上配置HTTPS</h1><p id="89ad" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Certbot角色将生成证书，但是我们还需要更新nginx和jenkins角色来使用证书。我想到了一些变化:</p><h2 id="8b3b" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">roles/nginx/templates/nginx . conf . J2</h2><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="4087" class="lu ir hi ll b fi lv lw l lx ly">@@ -17,6 +17,8 @@ http {<br/> <br/>     access_log  /var/log/nginx/access.log  main;<br/> <br/>+    server_tokens       off;<br/>+    ssl_protocols       TLSv1.2 TLSv1.3;<br/>     sendfile            on;<br/>     tcp_nopush          on;<br/>     tcp_nodelay         on;<br/>@@ -40,6 +42,17 @@ http {<br/>         # Load configuration files for the default server block.<br/>         include /etc/nginx/default.d/*.conf;<br/> <br/>+        listen       443 ssl;<br/>+<br/>+        ssl_certificate /etc/letsencrypt/live/{{ fqdn }}/fullchain.pem;<br/>+        ssl_certificate_key /etc/letsencrypt/live/{{ fqdn }}/privkey.pem;<br/>+<br/>+<br/>+        # redirect non-https traffic to https<br/>+        if ($scheme != "https") {<br/>+            return 301 <a class="ae km" href="https://$host$request_uri" rel="noopener ugc nofollow" target="_blank">https://$host$request_uri</a>;<br/>+        }<br/>+<br/>         error_page 404 /404.html;<br/>             location = /40x.html {<br/>         }</span></pre><p id="6172" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">使用<code class="du li lj lk ll b">server_tokens off</code>，nginx发送的响应头不会包含任何将该服务器标识为nginx服务器的内容。出于安全目的，攻击者无法知道服务器使用的是哪个版本的nginx，也无法利用特定于该版本的漏洞。</p><p id="cd84" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">通过<code class="du li lj lk ll b">ssl_protocols TLSv1.2 TLSv1.3</code>，我们告诉nginx使用<code class="du li lj lk ll b">TLSv1.2</code>和<code class="du li lj lk ll b">TLSv1.3</code>。还有其他旧版本，我已经省略了。用最新的来说很好。</p><p id="1014" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">除了端口80，我们还监听端口443。为此，我们需要配置<code class="du li lj lk ll b">ssl_certificate</code>和<code class="du li lj lk ll b">ssl_certificate_key</code>。配置的其余部分不言自明。</p><h2 id="9f0f" class="lu ir hi bd is mn mo mp iw mq mr ms ja jz mt mu je kd mv mw ji kh mx my jm mz bi translated">角色/Jenkins/templates/Jenkins . conf . J2</h2><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="adf7" class="lu ir hi ll b fi lv lw l lx ly">@@ -1,5 +1,11 @@<br/> server {<br/>     server_name ci.{{ fqdn }};<br/>+<br/>+    listen       443 ssl;<br/>+<br/>+    ssl_certificate /etc/letsencrypt/live/{{ fqdn }}/fullchain.pem;<br/>+    ssl_certificate_key /etc/letsencrypt/live/{{ fqdn }}/privkey.pem;<br/>+<br/>     location / {<br/>        proxy_pass <a class="ae km" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a>;<br/>        <br/>+       proxy_set_header   Host              $host;<br/>+       proxy_set_header   X-Real-IP         $remote_addr;<br/>+       proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;<br/>+       proxy_set_header   X-Forwarded-Proto $scheme;<br/>+<br/>     }</span></pre><p id="fb12" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们需要詹金斯服务器块相同的<code class="du li lj lk ll b">listen</code>和<code class="du li lj lk ll b">ssl_certificate*</code>指令。</p><p id="448a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我运行了剧本，现在ci.santoshk.dev没有拒绝我的连接。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/5f9c68d5b58aa2c429c751a7dc8de95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORAbjua1XRp3iyreruxYBA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Correct HTTPS setup of subdomain</figcaption></figure><p id="cca6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">到这里的代码可以在<a class="ae km" href="https://github.com/santosh/ansible/tree/v0.4.1" rel="noopener ugc nofollow" target="_blank">https://github.com/santosh/ansible/tree/v0.4.1</a>找到。</p><h1 id="bd44" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="12b9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这篇文章中，我们学习了角色中的变量和模板。我们也看到了我们可以把变量放在什么不同的位置。我们还看到了如何将这些变量注入模板。然后还学习了如何从命令行覆盖它们。除此之外，我们还学习了如何从“让我们加密”中获取HTTPS证书。</p><p id="04d1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">不幸的是，这篇文章越来越长，最好能在这个系列的下一部分发表。在下一篇文章中，我将讨论为更新、安全强化和重构角色设置cron。</p><p id="c023" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果这篇文章给你的生活增加了价值，请考虑与你的网络分享。如果你订阅了我的时事通讯，你会得到关于软件开发的提示和技巧、教程和操作方法。请订阅我的博客。</p></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><p id="2843" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="lh">原载于2022年2月4日</em><a class="ae km" href="https://santoshk.dev/posts/2022/automate-https-certificates-with-ansible-roles/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://santoshk . dev</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>
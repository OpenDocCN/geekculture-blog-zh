<html>
<head>
<title>Benefits of Domain Driven Design | And how to use it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">领域驱动设计的优势|以及如何使用它</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/benefits-of-domain-driven-design-and-how-to-use-it-58b9b1606c5a?source=collection_archive---------15-----------------------#2021-08-24">https://medium.com/geekculture/benefits-of-domain-driven-design-and-how-to-use-it-58b9b1606c5a?source=collection_archive---------15-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2b1af06605153d61f8a334ea7e0c7c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*t7F4tewOmvnlMXFQMbzOvw.png"/></div></figure><p id="edd0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我为什么要写这篇文章？我最近在一个小项目上遇到了一个问题，这个问题突然变成了一个大项目，并且变得越来越复杂。因为这个项目包含了我用Kotlin写的第一行代码，所以最后变得相当混乱。那么，有什么问题，只要解决这些代码气味，你就可以走了，对不对？..不完全是。导致这些代码气味的主要问题实际上是架构设计决策。其实在这个项目开始的时候，我并没有真正投入很多时间去创作一个好的设计，和项目“刚刚起步”。这正是领域驱动设计发挥作用的地方。</p><h1 id="61e6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是领域驱动设计？</h1><p id="22e1" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">领域驱动设计(DDD)是一种为复杂问题开发软件的方法，它将实现与核心业务概念的演进模型紧密联系起来。</p><p id="a547" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">DDD是来解决复杂性问题的。每个项目开始时都很小，然后变得越来越大，其复杂性也是如此。</p><p id="c8ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Eric Evans在2003年创造了DDD的概念和同名的书。</p><h1 id="b8f7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">最重要的关键词</h1><h2 id="a8a7" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">业务逻辑</h2><p id="181c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">业务逻辑<strong class="io hj"> </strong>是你应用的目的。这是您的业务规则定义对象和数据处理方式的地方。换句话说，这是你的应用程序的一部分，使它不同于其他预构建的东西。</p><h2 id="8c61" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">核心域</h2><p id="d68b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">核心域是业务逻辑所在的地方。你通常有表示业务逻辑的接口或类。</p><h2 id="7ba5" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">普遍存在的语言</h2><p id="27c7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">无处不在的语言是一种方法论，指的是领域专家和开发人员在谈论他们正在工作的领域时使用的相同语言。这是必要的，因为项目可能会面临语言中断的严重问题。这是因为领域专家使用他们自己的行话。同时，技术专家用他们自己的术语来谈论这个领域。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lc"><img src="../Images/b950d6e6f85d60a20ab938d2a8019051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbBwtVCgZv10NiMqD62okg.jpeg"/></div></div></figure><p id="123e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">日常讨论中使用的术语和准则中使用的术语之间存在差距。这就是为什么有必要定义一组每个人都使用的术语。无处不在的语言中的所有术语都是围绕领域模型构建的。</p><h2 id="72e8" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">实体</h2><p id="e30a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">实体是数据和行为的组合，就像用户或产品一样。它们代表了模型的核心元素。他们需要有一个身份，就像客户有其customerId一样。这些实体包含核心域的逻辑。</p><h2 id="5b12" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">价值对象</h2><p id="aea8" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">值对象有属性，但不能独立存在。例如，送货地址可以是一个值对象。这些值对象没有身份，大多数只包含其属性的验证逻辑。</p><h2 id="2a38" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">应用服务程序</h2><p id="3273" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">应用服务<strong class="io hj"> </strong>是一个不包含业务逻辑的层。然而，它是基于特定的用例来协调应用程序的活动。一个例子可能是需要执行一个订单。然后，该服务必须持久存储关于该订单的数据，将其从购物车中删除，并发送一封确认电子邮件。为了做到这一点，它使用了一些其他第三方系统，如存储库或邮件处理程序。</p><h2 id="f51c" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">仓库</h2><p id="3226" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">存储库模式是简化数据基础设施的业务实体的<strong class="io hj">集合。它将领域模型从基础设施问题中释放出来。<strong class="io hj">分层</strong>概念加强了关注点的分离。数据保存在哪里(数据库、文件系统)并不重要。</strong></p><h1 id="d77e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">示例项目</h1><p id="6dba" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">通过我自己的这个小项目，我想告诉你如何在现实世界中使用DDD。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ll"><img src="../Images/a91ee0994a8f989e10d2ce9294e1535c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgrT31S9YmxgOCR5b7iGuQ.png"/></div></div></figure><h2 id="6c42" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">核心领域</h2><p id="89e7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在核心域内部，有我们的应用程序使用的最重要的类和接口。它有一个DocumentService类，这个类处理我们大部分的业务逻辑。然后我们有实体文档和元数据。这些用来存储关于文档的信息，如id或标题。</p><p id="69e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了从上面保存这些实体，我们有DocumentRepository和MetadataRepository接口。这两者的实现是在基础设施层处理的。</p><h2 id="6b14" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">应用服务</h2><p id="4295" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们只有两个应用服务。第一个处理文档的上传，另一个提供这些文档的下载。他们可以通过使用基础设施中的存储库和Zip类来做到这一点。</p><h2 id="3452" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">基础设施</h2><p id="2cd9" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Zip类提供了压缩和解压上传文档的方法。存储库是核心域中存储库接口的实现。它们使用文件系统来保存数据。这三个类都是被动的，只能从应用程序本身触发。</p><p id="9433" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一方面，restApis是主动基础架构组件。它们可以由用户从外部触发。例如，gradleRestApi提供了一种上传和删除文档的方法，而userRestApi只对这些文档具有读取权限。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="dec1" class="jk jl hi bd jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh bi translated">反射</h1><h2 id="8db4" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">什么进展顺利？</h2><p id="78b0" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">老实说，在我的设计和学习过程中，我真的遇到了很多问题。唯一真正好的事情是与我的团队讨论设计，我们澄清了所有的不确定性。</p><h2 id="93ed" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">什么制造了问题？</h2><p id="c8d3" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">首先，我的一个主要问题是，我真的不知道我在寻找什么。在弄清楚这一点后，我在寻找一个好的资源以简单易懂的方式学习这类东西时遇到了一些问题。大多数情况下，我找到的资源包含了很多我当时不理解的技术术语。在我最终找到一些<a class="ae kn" href="https://www.informatik-aktuell.de/entwicklung/methoden/domain-driven-design-im-hexagon.html" rel="noopener ugc nofollow" target="_blank">好的和对我来说相关的资源</a>后，我有一些问题来分配不同的类到正确的层。在与我的团队讨论之后，我认为这些事情现在已经很清楚了。</p></div></div>    
</body>
</html>
<html>
<head>
<title>LeetCode — Find Minimum in Rotated Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —在旋转排序数组中查找最小值</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-find-minimum-in-rotated-sorted-array-eeccc3db79ca?source=collection_archive---------9-----------------------#2022-07-24">https://medium.com/geekculture/leetcode-find-minimum-in-rotated-sorted-array-eeccc3db79ca?source=collection_archive---------9-----------------------#2022-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4f84" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="e299" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设一个按升序排序的长度为<em class="kb"> n </em>的数组被<strong class="jf hj">旋转</strong>1到n次。例如，数组<em class="kb"> nums = [0，1，2，4，5，6，7] </em>可能变成:</p><p id="fbd6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">【4，5，6，7，0，1，2】</em>如果旋转<em class="kb"> 4 </em>次。<em class="kb">【0，1，2，4，5，6，7】</em>如果旋转<em class="kb"> 7 </em>次。注意<strong class="jf hj">旋转</strong>一个数组[a[0]，a[1]，a[2]，…，a[n — 1]] 1次得到数组[a[n — 1]，a[0]，a[1]，a[2]，…，a[n — 2]]。</p><p id="9f91" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">给定<strong class="jf hj">唯一</strong>元素的排序旋转数组<em class="kb"> nums </em>，返回该数组的最小元素<em class="kb">。</em></p><p id="9a72" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你必须写一个运行时间为O(log n)的算法。</p><p id="2a3c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-minimum-in-rotated-sorted-array/</a>。</p><p id="0a9f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3369" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [3, 4, 5, 1, 2]<br/>Output: 1<br/>Explanation: The original array was [1, 2, 3, 4, 5] rotated 3 times.</span></pre><p id="0c9a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例二:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1142" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [4, 5, 6, 7, 0, 1, 2]<br/>Output: 0<br/>Explanation: The original array was [0, 1, 2, 4, 5, 6, 7] and it was rotated 4 times.</span></pre><p id="b4a3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例3: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d60f" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [11, 13, 15, 17]<br/>Output: 11<br/>Explanation: The original array was [11, 13, 15, 17] and it was rotated 4 times.</span></pre><p id="60a6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fe83" class="kr ig hi kn b fi ks kt l ku kv">- n == nums.length<br/>- 1 &lt;= n &lt;= 5000<br/>- -5000 &lt;= nums[i] &lt;= 5000<br/>- All the integers of nums are unique<br/>- nums is sorted and rotated between 1 and n times</span></pre><h1 id="fcd2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="99f7" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="4305" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的方法是进行线性搜索，这需要花费<strong class="jf hj"> O(N) </strong>时间。我们需要找到第个索引的<strong class="jf hj">，其中一个较小的数字出现在第<strong class="jf hj">(I-1)个</strong>个索引之后。</strong></p><h2 id="5895" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">二进位检索</h2><p id="140d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于数组是旋转但排序的，我们可以修改我们的二分搜索法实现。旋转后的数组有两个已排序的段。排序被打乱的索引出现在数组中的最小元素处。</p><p id="e90b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查算法:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="de39" class="kr ig hi kn b fi ks kt l ku kv">- set low = 0<br/>      high = nums.size() - 1<br/><br/>- loop while low &lt; high<br/>  - set mid = low + (high - low) / 2<br/><br/>  - if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid]<br/>    - set high = mid - 1<br/>  - else if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &lt;= nums[mid]<br/>    - set low = mid + 1<br/>  - else if nums[mid] &lt;= nums[low]<br/>    - set high = mid<br/><br/>- return nums[low]</span></pre><p id="3972" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="7ba2" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="48f0" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int findMin(vector&lt;int&gt;&amp; nums) {<br/>        int low = 0;<br/>        int high = nums.size() - 1;<br/><br/>        while(low &lt; high) {<br/>            int mid = low + (high - low) / 2;<br/><br/>            if(nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid])<br/>                high = mid - 1;<br/>            else if(nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &lt;= nums[mid])<br/>                low = mid + 1;<br/>            else if(nums[mid] &lt;= nums[low])<br/>                high = mid;<br/>        }<br/><br/>        return nums[low];<br/>    }<br/>};</span></pre><h2 id="15c5" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c3fd" class="kr ig hi kn b fi ks kt l ku kv">func findMin(nums []int) int {<br/>    low, mid := 0, 0<br/>    high := len(nums) - 1<br/><br/>    for low &lt; high {<br/>        mid = low + (high - low) / 2<br/><br/>        if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid] {<br/>            high = mid - 1<br/>        } else if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &lt;= nums[mid] {<br/>            low = mid + 1<br/>        } else if nums[mid] &lt;= nums[low] {<br/>            high = mid<br/>        }<br/>    }<br/><br/>    return nums[low]<br/>}</span></pre><h2 id="6bdf" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b287" class="kr ig hi kn b fi ks kt l ku kv">var findMin = function(nums) {<br/>    let low = 0;<br/>    let high = nums.length - 1;<br/><br/>    while(low &lt; high) {<br/>        let mid = low + Math.floor((high - low) / 2);<br/><br/>        if(nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid])<br/>            high = mid - 1;<br/>        else if(nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &lt;= nums[mid])<br/>            low = mid + 1;<br/>        else if(nums[mid] &lt;= nums[low])<br/>            high = mid;<br/>    }<br/><br/>    return nums[low];<br/>};</span></pre><p id="0ea3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9aa9" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [4, 5, 6, 7, 0, 1, 2]<br/><br/>Step 1: low = 0<br/>        high = nums.size() - 1<br/>             = 7 - 1<br/>             = 6<br/><br/>Step 2: loop while low &lt; high<br/>          0 &lt; 6<br/>          true<br/><br/>          mid = low + (high - low) / 2<br/>              = 0 + (6 - 0) / 2<br/>              = 3<br/><br/>          if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid]<br/>             nums[0] &lt;= nums[3] &amp;&amp; nums[6] &gt;= nums[3]<br/>             4 &lt;= 7 &amp;&amp; 2 &gt;= 7<br/>             false<br/><br/>          else if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid]<br/>                  nums[0] &lt;= nums[3] &amp;&amp; nums[6] &lt;= nums[3]<br/>                  4 &lt;= 7 &amp;&amp; 2 &lt;= 7<br/>                  true<br/><br/>                  low = mid + 1<br/>                      = 3 + 1<br/>                      = 4<br/><br/>Step 3: loop while low &lt; high<br/>          4 &lt; 6<br/>          true<br/><br/>          mid = low + (high - low) / 2<br/>              = 4 + (6 - 4) / 2<br/>              = 4 + 1<br/>              = 5<br/><br/>          if nums[low] &lt;= nums[mid] &amp;&amp; nums[high] &gt;= nums[mid]<br/>             nums[4] &lt;= nums[5] &amp;&amp; nums[6] &gt;= nums[5]<br/>             0 &lt;= 1 &amp;&amp; 2 &gt;= 1<br/>             true<br/><br/>             high = mid - 1<br/>                  = 5 - 1<br/>                  = 4<br/><br/>Step 4: loop while low &lt; high<br/>          4 &lt; 4<br/>          false<br/><br/>Step 5: return nums[low]<br/>               nums[4]<br/>               0<br/><br/>We return the answer as 0.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="cced" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原发布于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-find-minimum-in-rotated-sorted-array" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Building a Simple Bot Protection With NGINX JavaScript Module (NJS) and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NGINX JavaScript模块(NJS)和TypeScript构建一个简单的Bot保护</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-simple-bot-protection-with-nginx-javascript-module-njs-and-typescript-386b2207ba90?source=collection_archive---------3-----------------------#2021-05-24">https://medium.com/geekculture/building-a-simple-bot-protection-with-nginx-javascript-module-njs-and-typescript-386b2207ba90?source=collection_archive---------3-----------------------#2021-05-24</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><figure class="ew ey ih ii ij ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ig"><img src="../Images/c049382e07136151b4609a14c2b4ee75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3YxGXaHfJRZLunoXU_hDg.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">Photo by <a class="ae iv" href="https://unsplash.com/@phillipglickman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Phillip Glickman</a> on <a class="ae iv" href="https://unsplash.com/s/photos/robots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4f58" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">我爱Lua。我也爱NGINX。我们三个相处得很好。像每段感情一样，我们也有高潮和低谷(是的，我正看着你的Lua模式)，但总的来说生活是完美的。然后，NGINX JavaScript模块(简称NJS)出现了。</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ju"><img src="../Images/8a64597adcba05b1d27abca6c842a65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJZhiTDBGO2mOFx01iUL8Q.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">I ❤️ JS/TS</figcaption></figure><p id="7c95" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">NGINX JavaScript模块于2015年首次推出，但最近随着0.5.x更新，功能得到了大幅提升。因为我对JS的任何东西都很感兴趣，所以我决定通过构建一个简单的(读幼稚和<strong class="iy hk">非生产就绪</strong>)机器人保护模块来测试它🤖。</p><h1 id="5979" class="jz ka hj bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">配置NGINX</h1><p id="3fc5" class="pw-post-body-paragraph iw ix hj iy b iz kx jb jc jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt hc bi translated">在进入bot fight之前，我们必须设置NGINX来支持JavaScript模块。下面的说明是针对我的设置的(Ubuntu 20.4/Nginx 1.18)，所以YMMV，但是大部分设置的大致思路应该是一样的。</p><ol class=""><li id="1b1f" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">通过运行<br/> <code class="dv ll lm ln lo b">curl -s <a class="ae iv" href="https://nginx.org/keys/nginx_signing.key" rel="noopener ugc nofollow" target="_blank">https://nginx.org/keys/nginx_signing.key</a> | sudo apt-key add -</code>来添加NGINX PPA密钥</li></ol><p id="5dc0" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">2.通过运行以下命令设置存储库密钥:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="39e0" class="lt ka hj lo b fj lu lv l lw lx">sudo sh -c 'echo "deb http://nginx.org/packages/ubuntu/ focal nginx" &gt;&gt; /etc/apt/sources.list.d/nginx.list'</span></pre><p id="cd2a" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.通过运行<code class="dv ll lm ln lo b">sudo apt update</code>更新存储库列表。</p><p id="2ac3" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.通过运行<code class="dv ll lm ln lo b">sudo apt install nginx-module-njs</code>安装NJS。</p><p id="883a" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">如果一切顺利，此时，您应该会在终端上收到这条可爱的消息:</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ly"><img src="../Images/8158e017bd1176f6147928161e7866be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR-aBRr-V8qILaSHvmVqeQ.png"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">Big success 🥂</figcaption></figure><p id="befb" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">5.通过将以下内容添加到主<strong class="iy hk"> nginx.conf </strong>文件的顶部来启用NJS:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="83c9" class="lt ka hj lo b fj lu lv l lw lx">load_module modules/ngx_http_js_module.so;</span></pre><p id="79ff" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">6.重启NGINX，将NJS加载到正在运行的实例中:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="fead" class="lt ka hj lo b fj lu lv l lw lx">sudo nginx -s reload</span></pre><p id="38db" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">现在你的NGINX已经准备好接受一些JS的爱了，所以让我们继续前进，创建我们的第一道防线——IP过滤！</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et lz"><img src="../Images/789e21b16fd8ca3c303660cf9726c894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G71NQ2tKLzd-3BmYLgNJ3A.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">damn right you are!</figcaption></figure><h1 id="a317" class="jz ka hj bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">开始行动—创建项目</h1><p id="c38f" class="pw-post-body-paragraph iw ix hj iy b iz kx jb jc jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt hc bi translated">我们的bot保护项目将使用TypeScript编写。为此，我们需要创建一个项目，将文件类型脚本转换成NJS能够理解的ES5 JavaScript。正如您可能已经猜到的，NodeJS在这里是必须的，所以在继续之前，请确保您已经设置好了。</p><ol class=""><li id="9ba8" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">创建新的项目文件夹并初始化它:</li></ol><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="92e7" class="lt ka hj lo b fj lu lv l lw lx">mkdir njs-bot-protection &amp;&amp; cd njs-bot-protection<br/>npm init -y</span></pre><p id="c152" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">2.安装所需的软件包:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="c6e0" class="lt ka hj lo b fj lu lv l lw lx">npm i -D @rollup/plugin-typescript @types/node njs-types rollup typescript</span></pre><p id="9512" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.将<strong class="iy hk">构建</strong>脚本添加到<strong class="iy hk"> package.json </strong>的<strong class="iy hk">脚本</strong>部分:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="210c" class="lt ka hj lo b fj lu lv l lw lx">{<br/>    ...<br/>    "scripts": {<br/>        "build": "rollup -c"<br/>    },<br/>    ...<br/>}</span></pre><p id="7c91" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.为了编译项目，您需要告诉TypeScript编译器如何使用<strong class="iy hk"> tsconfig.json </strong>文件来完成这项工作。在项目的根目录下创建一个新的<strong class="iy hk"> tsconfig.json </strong>文件，并在其中添加以下内容:</p><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="8123" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">5.最后，让我们添加汇总配置，这将包装一切，并产生NJS将阅读的endgame js文件。<br/>在项目的根目录下新建一个<strong class="iy hk"> rollup.config.js </strong>文件，并在其中添加以下内容:</p><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="782d" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">至此，我们的样板文件已经准备就绪。这意味着是时候踢一些机器人了！</p><h1 id="a99d" class="jz ka hj bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">第1轮— IP过滤</h1><p id="6564" class="pw-post-body-paragraph iw ix hj iy b iz kx jb jc jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt hc bi translated">我们bot防御的第一道防线是IP阻断；我们将传入请求的IP与一系列已知的声誉不佳的IP进行比较，如果发现匹配，我们会将请求重定向到“阻止”页面。</p><p id="6fb0" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">我们将从创建JavaScript模块开始:</p><ol class=""><li id="f159" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">在项目根文件夹中，创建一个名为<strong class="iy hk"> src，</strong>的新文件夹，然后在其中创建一个新的<strong class="iy hk"> bot.ts </strong>文件。</li><li id="7f4b" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt lh li lj lk bi translated">将以下代码片段添加到<strong class="iy hk"> bot.ts </strong>中:</li></ol><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="4ca2" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">💡那么我们这里有什么？</p><ul class=""><li id="42fe" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt mh li lj lk bi translated"><strong class="iy hk">第1行</strong>:导入文件系统的内置模块(即fs)。这个模块处理文件系统，允许我们读写文件以及其他活动。</li><li id="a20c" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第2行</strong>:调用<code class="dv ll lm ln lo b">loadFile</code>函数，给它传递我们希望加载的文件的名称。</li><li id="d50a" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第4–12行</strong>:执行<code class="dv ll lm ln lo b">loadFile</code>。首先，我们将<code class="dv ll lm ln lo b">data</code>变量初始化为一个空字符串数组(第5行)，然后我们尝试将一个包含错误IP地址列表的文本文件读取并解析到<code class="dv ll lm ln lo b">data</code>对象中(第7行)，最后我们返回<code class="dv ll lm ln lo b">data</code>对象(第11行)。</li><li id="d665" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第14–21行</strong>:我们模块的核心<code class="dv ll lm ln lo b">verifyIP</code>的实现(目前)。这是我们将向NGINX公开的验证IP的函数。我们首先检查不良信誉IP的阵列是否包含当前的请求客户端IP(第15行)。如果是，将请求重定向到块页面并结束处理(第16和17行)。如果不是，在内部重定向到<code class="dv ll lm ln lo b">pages</code>位置(第20行)。</li><li id="1304" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第23行</strong>:对外导出(read expose)<code class="dv ll lm ln lo b">verifyIP</code>。</li></ul><p id="e978" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.在终端中运行<code class="dv ll lm ln lo b">npm run build</code>构建模块。如果一切顺利，你应该在<strong class="iy hk"> dist </strong>文件夹中找到编译好的<strong class="iy hk"> bot.js </strong>文件🎉</p><p id="a150" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">有了这个文件，让我们配置NGINX来使用它:</p><ol class=""><li id="8872" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">在你的NGINX文件夹中(在我的例子中是<strong class="iy hk"> /etc/nginx </strong>)创建一个名为<strong class="iy hk"> njs </strong>的文件夹，并在其中复制前面部分的<strong class="iy hk"> bot.js </strong>。</li><li id="34f9" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt lh li lj lk bi translated">在<strong class="iy hk"> /var/lib </strong>下创建一个名为<strong class="iy hk"> njs </strong>的新文件夹，在里面创建一个名为<strong class="iy hk"> ips.txt </strong>、<strong class="iy hk"> </strong>的文件，并在其中填充一个信誉不好的IP列表(每行一个IP)。你可以添加你自己的IP列表或者使用类似于https://github.com/stamparm/ipsum的东西。</li><li id="a366" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt lh li lj lk bi translated">在您的<strong class="iy hk"> nginx.conf </strong>中，在<code class="dv ll lm ln lo b">http</code>部分下，添加以下内容:</li></ol><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="53ca" class="lt ka hj lo b fj lu lv l lw lx">js_path "/etc/nginx/njs/";<br/>js_import bot.js;</span></pre><p id="7c87" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">💡那么我们这里有什么？</p><ul class=""><li id="219d" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt mh li lj lk bi translated"><strong class="iy hk"> js_path </strong> —设置NJS模块文件夹的路径。</li><li id="aa81" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk"> js_import </strong> —从NJS模块文件夹中导入模块。如果没有指定，导入的模块名称空间将由文件名决定(在我们的例子中，<code class="dv ll lm ln lo b">bot</code>)</li></ul><p id="2be0" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.在<code class="dv ll lm ln lo b">server</code>部分下(我的在<strong class="iy hk">/etc/nginx/conf . d/default . conf</strong>)修改<code class="dv ll lm ln lo b">/</code>位置如下:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="7870" class="lt ka hj lo b fj lu lv l lw lx">location / {<br/>    js_content bot.verifyIP;<br/>}</span></pre><p id="4b1e" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">通过使用<code class="dv ll lm ln lo b">js_content</code>指令调用<code class="dv ll lm ln lo b">verifyIP</code>,我们将其设置为内容处理程序，这意味着<code class="dv ll lm ln lo b">verifyIP</code>可以控制我们发送回调用者的内容(在我们的例子中，要么显示一个阻塞页面，要么将请求传递给源)</p><p id="072b" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">5.仍然在<code class="dv ll lm ln lo b">server</code>部分下，添加<code class="dv ll lm ln lo b">block.html</code>位置和<code class="dv ll lm ln lo b">pages</code>命名位置:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="f957" class="lt ka hj lo b fj lu lv l lw lx">location <a class="ae iv" href="http://twitter.com/pages" rel="noopener ugc nofollow" target="_blank">@pages</a> {<br/>    root /usr/share/nginx/html;<br/>    proxy_pass <a class="ae iv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a>;<br/>}</span><span id="2937" class="lt ka hj lo b fj mi lv l lw lx">location /block.html {<br/>    root   /usr/share/nginx/html;<br/>}</span></pre><p id="9268" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">(命名的<code class="dv ll lm ln lo b">pages</code>位置将被我们的NJS模块用来在内部重定向请求，如果它不应该被阻塞的话。对于这种重定向，您可能有自己的逻辑，所以请根据您的需要进行更改)</p><p id="7d83" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">6.在文件的底部，添加端口8080的服务器块:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="63ee" class="lt ka hj lo b fj lu lv l lw lx">server {<br/>        listen 8080;<br/>        location / {<br/>        root /usr/share/nginx/html;<br/>        index index.html index.htm;<br/>    }<br/>}</span></pre><p id="280c" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">7.在<strong class="iy hk"> /usr/share/nginx/html </strong>文件夹下，添加<strong class="iy hk">block.html</strong>文件如下:</p><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="acc5" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">至此，我们的知识产权保护准备就绪！将自己的IP添加到<strong class="iy hk"> ips.txt </strong>文件中，重启NGINX ( <code class="dv ll lm ln lo b">sudo nginx -s reload</code>)。浏览到您的实例，您应该看到以下内容:</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et mj"><img src="../Images/122cc6701912409ef81709f774f2170e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ly0aRwgPudTC-TcdLZr7mg.png"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">Take that Mr. Evil Bot! 🤖 ⛔</figcaption></figure><h1 id="c3c6" class="jz ka hj bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">第2轮— JavaScript检测</h1><p id="7e5a" class="pw-post-body-paragraph iw ix hj iy b iz kx jb jc jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt hc bi translated">我们的第二个保护层是JavaScript检测。我们使用这种检测来确定访问我们站点的访问者是否正在运行JavaScript(每个普通浏览器都应该这样做)(这是一个警告信号，表明该访问者可能不是合法用户)。我们首先向页面注入一个JavaScript片段，它将在根路径上烘烤一个cookie:</p><ol class=""><li id="4b62" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">将以下代码片段添加到<strong class="iy hk"> bot.ts </strong>中:</li></ol><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="65b8" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">💡那么我们这里有什么？</p><ul class=""><li id="33a0" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt mh li lj lk bi translated"><strong class="iy hk">第1行</strong>:导入内置加密模块。这个模块处理密码学，我们很快会用它来创建一个HMAC。</li><li id="1ba2" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第5–18行</strong>:执行<code class="dv ll lm ln lo b">getCookiePayload</code>。该函数将一个<code class="dv ll lm ln lo b">date</code>对象设置为比当前时间早一个小时(第6–8行)，然后使用<code class="dv ll lm ln lo b">date</code>对象(使用<code class="dv ll lm ln lo b">crypto</code>模块)将我们传递给该函数的签名(<code class="dv ll lm ln lo b">value</code>对象)和<code class="dv ll lm ln lo b">date</code>对象(第10–14行)。最后，该函数以字符串格式返回cookie信息(名称、值、到期时间等)。).您可能注意到cookie值不仅包含散列签名，还包含我们用来HMAC签名的<code class="dv ll lm ln lo b">date</code>对象。你很快就会明白我们为什么这么做了。</li><li id="c234" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">第20–30行</strong>:执行<code class="dv ll lm ln lo b">addSnippet</code>。该函数缓冲请求数据，一旦完成(第23行)，它:<br/> -基于客户机IP和用户代理头创建一个签名(第24行)。<br/> -用一个<code class="dv ll lm ln lo b">script</code>部分替换结束的<code class="dv ll lm ln lo b">head</code>标签，该部分使用JavaScript的<code class="dv ll lm ln lo b">document.cookie</code>属性在浏览器端插入一个cookie(来自<code class="dv ll lm ln lo b">getCookiePayload</code>函数)。(第25–28行)。<br/> -将修改后的响应发送回客户端(第29行)。</li></ul><p id="790f" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">2.通过更新文件底部的导出语句，导出新的<code class="dv ll lm ln lo b">addSnippet</code>函数:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="6dd5" class="lt ka hj lo b fj lu lv l lw lx">export default { verifyIP, addSnippet };</span></pre><p id="5abf" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.在<code class="dv ll lm ln lo b">@pages</code>位置块下，修改<code class="dv ll lm ln lo b">/</code>位置如下:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="dc3f" class="lt ka hj lo b fj lu lv l lw lx">location <a class="ae iv" href="http://twitter.com/pages" rel="noopener ugc nofollow" target="_blank">@pages</a> {<br/>    js_body_filter bot.addSnippet;<br/>    proxy_pass <a class="ae iv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a>;<br/>}</span></pre><p id="f791" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">与<code class="dv ll lm ln lo b">verifyIP</code>不同，我们不希望<code class="dv ll lm ln lo b">addSnippet</code>管理响应的内容，我们希望它将内容(在我们的例子中是一个<code class="dv ll lm ln lo b">script</code>标签)注入到从源返回的任何响应中。这就是<code class="dv ll lm ln lo b">js_body_filter</code>发挥作用的地方。使用<code class="dv ll lm ln lo b">js_body_filter</code>指令，我们告诉NJS，我们提供的函数将从原点修改原始响应，并在完成后返回。</p><p id="45c5" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.重启NGINX并浏览到实例上的页面。您应该会看到我们的新脚本就添加在结束标记<code class="dv ll lm ln lo b">head</code>之前:</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et mk"><img src="../Images/13aa0f4317ed90a7b717952619971513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CB7hOzUOS7r5rsWU-HfwlQ.png"/></div></div></figure><p id="25e8" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">如果客户端运行JavaScript，一个名为<strong class="iy hk"> njs </strong>的新cookie将被烘焙。接下来，让我们为这个cookie/缺少cookie创建验证:</p><ol class=""><li id="0357" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">将<code class="dv ll lm ln lo b">verifyCookie</code>功能(及其支持功能/变量)添加到<strong class="iy hk">机器人</strong>:</li></ol><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="b474" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">💡那么我们这里有什么？</p><ul class=""><li id="4efa" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt mh li lj lk bi translated"><strong class="iy hk">第5–11行</strong>:<code class="dv ll lm ln lo b">updateFile</code>函数的实现，它使用<code class="dv ll lm ln lo b">fs</code>模块将字符串数组保存到一个文件中。</li><li id="8a6e" class="lc ld hj iy b iz mc jd md jh me jl mf jp mg jt mh li lj lk bi translated"><strong class="iy hk">行</strong><strong class="iy hk">13–52</strong>:母载实现。在验证<strong class="iy hk"> njs </strong> cookie时，我们有一个验证流程和必须遵循的结果:</li></ul><p id="802f" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">a.我们从从请求的<strong class="iy hk"> Cookie </strong>头中提取<strong class="iy hk"> njs </strong> cookie开始(第14-20行)。</p><p id="65a6" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">b.如果我们没有cookie(或者我们有，但格式不正确)，我们会将客户端IP与我们收到的没有cookie的客户端IP列表进行比较。如果我们在最后一个小时内找到一个匹配项，我们会使请求失败(返回false，第26–27行)。如果没有，我们就删除该IP(如果它在列表上，但是超过了一个小时)并传递请求(第29–34行)。</p><p id="07d7" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">c.如果我们有一个cookie，我们将它分成一个时间戳和一个有效负载，并使用时间戳根据请求的用户代理头和客户机IP创建我们自己的HMAC散列。如果我们自己的HMAC与<strong class="iy hk"> njs </strong> cookie的HMAC匹配，我们就通过请求。否则，我们会失败(第38–45行)。</p><p id="fd2f" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">d.如果在验证过程中出现任何问题，我们会失败打开(意味着通过)请求(第48–51行)。</p><p id="6f39" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">2.添加新的<code class="dv ll lm ln lo b">verify</code>函数，该函数调用新的<code class="dv ll lm ln lo b">verifyCookie</code>函数，并根据其结果进行操作:</p><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="6e48" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">🔥此时你可能会想，这个<code class="dv ll lm ln lo b">verify</code>函数看起来与之前的<code class="dv ll lm ln lo b">verifyIP</code>函数惊人地相似——你完全正确，我马上会谈到这一点！</p><p id="2991" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.为了测试我们新的cookie验证功能，打开您的配置文件(我的在<strong class="iy hk">/etc/nginx/conf . d/default . conf</strong>)并将js_content指令从<code class="dv ll lm ln lo b">verifyIP</code>更改为<code class="dv ll lm ln lo b">verify</code>:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="0620" class="lt ka hj lo b fj lu lv l lw lx">location / {<br/>    js_content bot.verify;<br/>}</span></pre><p id="ff45" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.重启NGINX，尝试在没有njs cookie的情况下访问该站点两次——✋🎤-你被挡住了！</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et mj"><img src="../Images/122cc6701912409ef81709f774f2170e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ly0aRwgPudTC-TcdLZr7mg.png"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">Not today Mr. Evil Bot! 🤖 ⛔</figcaption></figure><h1 id="aa59" class="jz ka hj bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">最后一轮——将所有人聚集在一起</h1><p id="a44a" class="pw-post-body-paragraph iw ix hj iy b iz kx jb jc jd ky jf jg jh kz jj jk jl la jn jo jp lb jr js jt hc bi translated">现在我们有了cookie验证，但是我们取消了IP验证，因为我们只能有一个<code class="dv ll lm ln lo b">js_content</code>指令，我们如何解决这个问题呢？</p><p id="05f2" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">您可能还记得几分钟前我们创建了<code class="dv ll lm ln lo b">verify</code>函数(眼尖的读者可能已经注意到了，它与我们之前使用的<code class="dv ll lm ln lo b">verifyIP</code>函数非常相似)。如果我们更新我们的<code class="dv ll lm ln lo b">verifyIP</code>函数，使它返回一个布尔响应作为验证，并将该验证添加到<code class="dv ll lm ln lo b">verify</code>，我们就可以用一个大函数来验证对IP和cookies的请求，从而两全其美！</p><ol class=""><li id="f77c" class="lc ld hj iy b iz ja jd je jh le jl lf jp lg jt lh li lj lk bi translated">如下重构<code class="dv ll lm ln lo b">verifyIP</code>函数:</li></ol><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="7235" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">2.更新<code class="dv ll lm ln lo b">verify</code>函数以调用<code class="dv ll lm ln lo b">verifyIP</code>，如下所示:</p><figure class="jv jw jx jy fe ik"><div class="bz dz l di"><div class="ma mb l"/></div></figure><p id="539a" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">3.更新<code class="dv ll lm ln lo b">export</code>语句，因为我们不再需要公开<code class="dv ll lm ln lo b">verifyIP</code>:</p><pre class="jv jw jx jy fe lp lo lq lr aw ls bi"><span id="5e76" class="lt ka hj lo b fj lu lv l lw lx">export default { addSnippet, verify };</span></pre><p id="777f" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">4.重启NGINX，使用NJS和TypeScript享受你自制的bot保护🎉</p><figure class="jv jw jx jy fe ik es et paragraph-image"><div class="es et ml"><img src="../Images/e40205090d52254768a4b3898b26f6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*ocJSogOMSWAcaTBdaLD4Rw.jpeg"/></div><figcaption class="ir is eu es et it iu bd b be z dy">Ewwwww, so cute ❤️</figcaption></figure><p id="a767" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">🍾模块源代码可在<a class="ae iv" href="https://github.com/jtordgeman/njs-bot-protection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得！</p></div></div>    
</body>
</html>
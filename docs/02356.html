<html>
<head>
<title>Explained: An Introduction to Distributed Tracing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:分布式跟踪简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/explained-an-introduction-to-distributed-tracing-bb1ef52fbac2?source=collection_archive---------11-----------------------#2021-05-12">https://medium.com/geekculture/explained-an-introduction-to-distributed-tracing-bb1ef52fbac2?source=collection_archive---------11-----------------------#2021-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0ce606109af74a1f572dc0b4154b9a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lwwwOmnQArHlR2Nh"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@colorflores?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Omar Flores</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="98fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们运行一个跨越多个容器和数据中心的分布式系统时，我们需要理解用户请求如何流经这些服务。这使我们能够更好地理解请求花费大部分时间的地方，并找出哪个服务没有按预期工作。</p><p id="e5bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数服务通过一组固定的协议相互通信，例如HTTP(作为REST调用)、RPC或基于队列的机制，其中一个服务器作为生产者，另一个作为消费者。对于解释系列的这篇文章，我们将解释当服务通过REST调用相互通信时，我们如何实现分布式跟踪。</p><p id="2792" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有两个服务，一个提供订单的订单服务和一个生成发票的发票服务。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/a79b70138e9c8d8dcad905faf435eba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps8-oNqUqmBZUbnuZx_Xjg.png"/></div></div></figure><h1 id="1f17" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">就一个简单的头球！</h1><p id="d4ec" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们可以非常容易地实现这一点的一个方法是，在从订单服务到发票服务的每个请求中添加一个标题。让我们称之为<code class="du lb lc ld le b">trace</code>，它可以是一个简单的UUID，所以它是非常独特的。我们可以添加一个请求拦截器或过滤器，将跟踪添加到<a class="ae iu" href="http://logback.qos.ch/manual/mdc.html" rel="noopener ugc nofollow" target="_blank">日志上下文</a>。尽管我们记录了一个请求通过的所有服务的惟一ID，但是我们仍然看不到两个服务之间的整个API调用的组合日志。我们需要一种方法来收集这两个应用程序的日志，而Filebeat log shipper可以帮助我们做到这一点。它被部署为一个独立的服务，从多个容器和应用程序中收集日志，并在Elasticsearch集群中对其进行索引，并通过Kibana仪表板对其进行可视化。这个设置将允许我们通过执行一个简单的查询来轻松地查询两个应用程序的日志。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/1f479708bd50e3276cba37ab1faefb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0FYesYCKjgKHtaPS3DOyg.png"/></div></div></figure><p id="f796" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然上述系统是一个良好的开端，但这仅仅是个开始。如果订单服务在同一个API调用中多次调用发票服务怎么办？我们不能仅仅依靠跟踪ID。我们需要生成另一个ID来表示整个跟踪中的单个操作范围。它可以是另一个UUID，但必须不同于跟踪ID。让我们称之为span ID。</p><p id="9f64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过上面的修改，订单服务现在创建一个支配性的父节点<code class="du lb lc ld le b">trace</code>，并将其设置为它的日志上下文，对于每个对发票服务的API调用，订单服务通过头节点<code class="du lb lc ld le b">traceparent</code>发送该父节点跟踪ID。发票服务现在创建一个<code class="du lb lc ld le b">span</code> ID，并将其设置为其日志上下文，并继续在span ID下执行任何必要的操作。一旦发票服务完成了它的工作，它就将响应以及span和父跟踪ID作为名为<code class="du lb lc ld le b">traceresponse</code>的响应头返回给订单服务。订单服务审核响应并标记该跨度的结束。最后，当订单服务向客户端返回响应时，跟踪被标记为完成。</p><p id="9b21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述机制允许我们搜索特定的跟踪和span ID组合，并通过响应头促进span的独特结束。它还允许我们验证发票服务是否真正参与了跟踪。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/771f1b6deba1a82cd4053062f079ee7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydJ4ifNfZ0SPZ81ELOQEqA.png"/></div></div></figure><h1 id="a592" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">不再仅仅是一个简单的标题！</h1><p id="baa1" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">到目前为止，我们只观察和解决了可能涉及服务间多个API调用的用例。但是非功能性用例呢？如果已经有一个系统使用不同的(非UUID) span或trace标识符，该怎么办？我们需要对我们的跟踪生成格式进行版本控制，并添加一些元信息，如跟踪头中的版本号，以说明不同的版本。它将为服务提供上下文来处理不同版本的跟踪。</p><p id="9cfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，如果我们有第三个服务调用发票服务，但不参与分布式跟踪，那该怎么办？我们需要一种方法来了解调用者是否在采样跟踪信息。因此，我们需要一些标志位来表示跟踪过程中要考虑的各种谓词。</p><p id="4f97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们可能会遇到这样的情况，我们必须传递的不仅仅是跟踪版本，而是一个完整的状态图。这意味着我们应该容纳另一个头<code class="du lb lc ld le b">tracestate</code>来保存这样的数据。本质上，<code class="du lb lc ld le b">traceparent</code>、<code class="du lb lc ld le b">traceresponse</code>和<code class="du lb lc ld le b">tracestate</code>头文件应该完善我们基本的RESTful分布式跟踪。</p><h1 id="7952" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="3d6b" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们只描述了同步RESTful系统中的可能性。异步系统提出了自己独特的挑战，因为按时间顺序，发票服务跨度的结束可能与跟踪的结束不一致。它让我们的模型可以进行一系列的修改。幸运的是，W3C已经概述了规则，描述了解决方案，并开发了与我们上面描述的相同的标准。</p><p id="086f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">已经有一些遵循W3C标准的开源项目，比如Jaeger、Zipkin和AWS X-Ray。随着越来越多的公司采用微服务，我们可以找到专注于同一领域的云原生基础项目。在我们即将发布的解释文章中，我们将着眼于Jaeger和OpenTracing，看看分布式跟踪是如何在更实际的基础上实现的。</p><h2 id="f68e" class="lh jz hi bd ka li lj lk ke ll lm ln ki jg lo lp km jk lq lr kq jo ls lt ku lu bi translated">阅读材料</h2><ul class=""><li id="89fe" class="lv lw hi ix b iy kw jc kx jg lx jk ly jo lz js ma mb mc md bi translated"><a class="ae iu" href="https://w3c.github.io/trace-context/" rel="noopener ugc nofollow" target="_blank">https://w3c.github.io/trace-context/</a></li><li id="439b" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">https://opentracing.io/<a class="ae iu" href="https://opentracing.io/" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>
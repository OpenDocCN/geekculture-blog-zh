<html>
<head>
<title>React Context API From Scratch A-Z</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始反应上下文API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-context-api-from-scratch-a-z-8954a05ebbec?source=collection_archive---------2-----------------------#2022-02-06">https://medium.com/geekculture/react-context-api-from-scratch-a-z-8954a05ebbec?source=collection_archive---------2-----------------------#2022-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c1353d1ae4aa8ad69fa8cb9cf0fa8062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMwNeEKww4RkVQU1Xjgtmw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Banner of Article</figcaption></figure><h1 id="0475" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">简介:</h1><p id="e728" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在过去的几年中，许多react项目都使用了Redux状态管理库。对于许多react项目来说，Redux 是一个很好的工具，尤其是对于整个应用程序的全局状态，使用redux-thunk或redux-saga处理动作创建者中的API请求，Redux还有其他与之相关的库，如redux-persist，它允许我们在本地存储中保存/存储数据，并在刷新时重新水合。</p><p id="b384" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">但是作为React开发人员，我问自己，如果我不需要redux提供的所有优秀特性，我只想使用Redux，以避免将道具传递给深度嵌套的组件，那该怎么办。</p><p id="530f" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">React <a class="ae kq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>已经引入，自React版本<a class="ae kq" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="noopener ugc nofollow" target="_blank"> 16.3.0 </a>起，在生产中使用变得安全。上下文API可以帮助将道具深入传递到嵌套组件或组件树。我不需要使用redux，只是为了避免将属性传递给深度嵌套的组件。</p><h2 id="7df2" class="kw iv hi bd iw kx ky kz ja la lb lc je kd ld le ji kh lf lg jm kl lh li jq lj bi translated">我们将在本文中解释:</h2><p id="0a6d" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">1-什么是React上下文？</p><p id="0e9e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">2-何时使用React上下文的示例。</p><p id="23b6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">3-如何使用React上下文？</p><p id="8e69" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">4- Class.contextType vs Context。使用基于类的组件的使用者。</p><p id="300c" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">5-对基于函数的组件使用上下文挂钩。</p><p id="aab5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">6-更新上下文。</p><p id="18a5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">7-消耗多个上下文。</p><p id="492f" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">8-注意事项。</p><h1 id="d377" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是React上下文？</h1><p id="e852" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">React context允许我们将数据从父组件传递到子组件，并在我们的应用程序中使用我们需要的任何组件中的数据，而不使用props，因此React context允许我们更容易地跨组件共享数据。当您传递可以在应用程序的任何组件中使用的数据时，React context非常有用。</p><p id="c34d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">道具演练问题可以通过上下文来解决:道具从父母传给孩子的时候。</p><p id="7d57" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">道具钻取</strong>是通过不需要道具的组件，将道具向下传递多个级别到嵌套组件的过程。</p><p id="c606" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">这里有一个道具演练的例子。该应用程序中的主题数据将作为道具传递给我们应用程序的组件。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="f2b1" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们正在钻主题道具通过多个组件，现在不需要它。</p><p id="3384" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">除了将其传递给其子组件，Header组件不需要主题。UserMenu、LoginMenu、Menu应该直接消费主题数据。</p><p id="8387" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">因为我们不需要使用道具，所以我们可以使用React context完全避免道具训练。</p><h1 id="2f74" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">何时使用React上下文的示例:</h1><p id="b2c4" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">你可以在上下文中:</p><ul class=""><li id="6c10" class="lq lr hi ju b jv kr jz ks kd ls kh lt kl lu kp lv lw lx ly bi translated">主题数据(如暗模式或亮模式)</li><li id="5740" class="lq lr hi ju b jv lz jz ma kd mb kh mc kl md kp lv lw lx ly bi translated">应用程序配置</li><li id="04ab" class="lq lr hi ju b jv lz jz ma kd mb kh mc kl md kp lv lw lx ly bi translated">已验证的用户名</li><li id="033a" class="lq lr hi ju b jv lz jz ma kd mb kh mc kl md kp lv lw lx ly bi translated">用户设置</li><li id="9f5f" class="lq lr hi ju b jv lz jz ma kd mb kh mc kl md kp lv lw lx ly bi translated">首选语言</li><li id="5298" class="lq lr hi ju b jv lz jz ma kd mb kh mc kl md kp lv lw lx ly bi translated">服务的集合</li></ul><p id="0752" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">使用上下文的目的是允许组件访问一些全局数据，并在数据更改时重新呈现。</p><p id="5dab" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">数据应该放在不需要经常更新的React上下文上，为什么？因为上下文并不是作为一个完整的状态管理系统。它是为了让消费数据更容易。</p><p id="643e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们可以将React上下文视为React组件的全局变量。</p><h1 id="9e1d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">如何使用React上下文？</h1><p id="5858" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">Context是React内置的API，所以我们可以通过在任何React文件中导入React来直接创建和使用context。</p><ol class=""><li id="fb4c" class="lq lr hi ju b jv kr jz ks kd ls kh lt kl lu kp me lw lx ly bi translated">我们通过<code class="du mf mg mh mi b">createContext</code>方法创建上下文:</li></ol><pre class="lk ll lm ln fd mj mi mk ml aw mm bi"><span id="cc0d" class="kw iv hi mi b fi mn mo l mp mq">const myContext = React.createContext(defaultValue);</span></pre><p id="5dba" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><code class="du mf mg mh mi b">createContext</code>函数接受一个<strong class="ju hj">可选参数</strong>:默认值。这个默认值有助于在不包装组件的情况下单独测试组件。</p><p id="8f29" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">2.我们将上下文提供者包装在组件树周围。</p><p id="0592" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">3.使用<code class="du mf mg mh mi b">value</code>属性传递上下文提供者的任何数据</p><p id="7296" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">4.我们使用上下文消费者来读取树中任何组件的数据。</p><p id="923f" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">创建文件myContext.js:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ff64" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">App.js文件:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="9516" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Class.contextType与上下文。使用基于类的组件的消费者:</h1><p id="b636" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在我之前的例子中，我们对基于函数的组件使用了<code class="du mf mg mh mi b">Context.Consumer</code>，我将对基于类的组件使用相同的例子:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h2 id="e939" class="kw iv hi bd iw kx ky kz ja la lb lc je kd ld le ji kh lf lg jm kl lh li jq lj bi translated">什么是contextType？</h2><p id="606a" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">React 16.6引入了一个新特性，允许基于类的组件在不使用<code class="du mf mg mh mi b">Context.Consumer</code>组件的情况下访问上下文。</p><p id="b888" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">这允许React自动将类组件连接到<strong class="ju hj">上下文</strong>，并且它给了我们一个新的属性<code class="du mf mg mh mi b">this.context</code>属性，我们可以在任何生命周期方法中使用它，包括render函数。</p><p id="8e7d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">使用<code class="du mf mg mh mi b">contextType</code>有两种方法:</p><p id="6951" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">1-类的<code class="du mf mg mh mi b">contextType</code>属性可以被分配一个由<code class="du mf mg mh mi b"><a class="ae kq" href="https://reactjs.org/docs/context.html#reactcreatecontext" rel="noopener ugc nofollow" target="_blank">React.createContext()</a></code>创建的上下文对象。使用<code class="du mf mg mh mi b">this</code>属性可以让您使用<code class="du mf mg mh mi b">this.context</code>来使用该上下文类型的最接近的当前值。</p><p id="8ca8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">2-如果你正在使用实验性的<a class="ae kq" href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="noopener ugc nofollow" target="_blank">公共类字段语法</a>，你可以使用一个<strong class="ju hj">静态</strong>类字段来初始化你的<code class="du mf mg mh mi b">contextType</code>。</p><p id="0cbd" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">下面的例子演示了这两种方式，很大一部分例子来自官方文档:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="965e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">它只能在基于类的组件中使用，之所以推荐使用它，是因为它更简短、更容易，并且可以在任何地方访问上下文。</p><p id="e833" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">将<code class="du mf mg mh mi b">myContext.Consumner</code>替换为<code class="du mf mg mh mi b">contextType</code>后的示例如下:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="3fce" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基于函数的组件的useContext挂钩:</h1><p id="f822" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">随着<a class="ae kq" rel="noopener" href="/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f"> <strong class="ju hj"> React钩子</strong> </a>的引入，React 16.8提供了一种新的使用上下文的方式。你现在可以使用<code class="du mf mg mh mi b">useContext</code>钩子来使用上下文。</p><p id="9d1e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><code class="du mf mg mh mi b">React.useContext()</code>可用于替代渲染道具，以消耗组件顶部的上下文。</p><p id="b5b5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">例如:</strong></p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="1049" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><em class="mr"/><code class="du mf mg mh mi b"><em class="mr">useContext</em></code><em class="mr">钩子的好处在于它让我们的组件更加简洁，并允许我们创建自己的</em> <a class="ae kq" rel="noopener" href="/geekculture/la-la-land-of-building-my-own-react-custom-hook-75f0a0fe53f9"> <strong class="ju hj">定制钩子</strong> </a> <em class="mr">。</em></p><p id="64f8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">根据您的喜好，您可以直接使用消费组件或<code class="du mf mg mh mi b">useContext</code>挂钩。</p><h1 id="17a7" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">更新上下文:</h1><p id="2617" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">以下示例将介绍如何更新上下文值，我们将对应用程序和标题组件进行一些更改:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h2 id="bd36" class="kw iv hi bd iw kx ky kz ja la lb lc je kd ld le ji kh lf lg jm kl lh li jq lj bi translated">从嵌套组件更新上下文:</h2><p id="a35c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">默认情况下，React上下文API是无状态的，使用者组件没有专用的方法来更新上下文值。在这种情况下，您可以通过集成状态管理机制(如useState())将函数向下传递到上下文，以允许使用者更新上下文，并在值旁边的上下文中包含更新函数，这很容易实现。</p><p id="da14" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">1-更新我的上下文文件:</strong></p><p id="84d7" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">myContext.js文件发生了一些修改:</p><p id="e9bb" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">在这里，我为<code class="du mf mg mh mi b">theme</code>和<code class="du mf mg mh mi b">setTheme</code>函数设置默认值，它将由上下文提供者发送给消费者。这些只是默认值，我将在父应用程序中使用provider组件时提供它们的值:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3098" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">注意:无论使用钩子还是基于类的组件，上下文都是一样的。</p><p id="688e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">2-设置动态上下文的父状态</strong></p><p id="447a" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">首先，为了有一个可以传递给消费者的动态上下文，我将使用父代的状态。这确保了我有一个单一的真相来源。例如，我的父应用程序将如下所示:</p><pre class="lk ll lm ln fd mj mi mk ml aw mm bi"><span id="114d" class="kw iv hi mi b fi mn mo l mp mq">import { myContext, themes } from "./myContext";<br/>import React, { useState, useMemo } from "react";<br/> const App = () =&gt; {  <br/> const [theme, setTheme] = useState(themes.light); <br/> const value = useMemo(() =&gt; ({ theme, setTheme }), [theme]);<br/> return (    <br/>   &lt;&gt;      <br/>     .......<br/>   &lt;/&gt;  <br/>   );<br/>};</span></pre><p id="3312" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><code class="du mf mg mh mi b">theme</code>存储在状态中。稍后我们将通过上下文传递<code class="du mf mg mh mi b">theme</code>和setter函数<code class="du mf mg mh mi b">setTheme</code>。</p><p id="6bd6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">3-在提供者中包装消费者</strong></p><p id="f1f4" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">现在，在一个<code class="du mf mg mh mi b">myContext.povider</code>中，我将把必须通过上下文发送的值传递到任何更深的层次。这是我父母<code class="du mf mg mh mi b">App</code>的样子:</p><pre class="lk ll lm ln fd mj mi mk ml aw mm bi"><span id="7e51" class="kw iv hi mi b fi mn mo l mp mq">const<!-- --> <!-- -->App<!-- --> = () =&gt; {</span><span id="b04f" class="kw iv hi mi b fi ms mo l mp mq">const [theme, setTheme] = useState(themes.light); <br/> const value = useMemo(() =&gt; ({ theme, setTheme }), [theme]);<br/>return (    <br/>   &lt;&gt;      <br/>   &lt;myContext.Provider value={value}&gt; <br/>       &lt;Header /&gt;    <br/>         &lt;div&gt;  <br/>          &lt;h1&gt;Hello World!&lt;/h1&gt;   <br/>        &lt;/div&gt;    <br/>       &lt;Footer /&gt;      <br/>    &lt;/myContext.Provider&gt;   <br/>   &lt;/&gt;  <br/> );<br/>}</span></pre><p id="4e84" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">现在，无论何时点击主题切换器，它都会动态更新上下文。</p><p id="528c" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">4-创建上下文消费者:</strong></p><p id="56b8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">为了让<code class="du mf mg mh mi b">themeSwitcher</code>设置主题，它应该通过上下文访问主题设置函数。它可能看起来像这样:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8bab" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">整个例子:</strong></p><p id="8a92" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj"> App.js文件:</strong></p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="2f40" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><code class="du mf mg mh mi b">&lt;App /&gt;</code>存储上下文值。<a class="ae kq" rel="noopener" href="/geekculture/great-confusion-about-react-memoization-methods-react-memo-usememo-usecallback-a10ebdd3a316"> <strong class="ju hj">记忆化</strong> </a>只要主题保持不变，就保留上下文值对象，防止&lt; App / &gt;每次重新呈现时消费者重新呈现。</p><p id="8324" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">或者，<code class="du mf mg mh mi b">const value = {theme, setTheme}</code>会在&lt; App / &gt;的重新渲染过程中创建不同的对象实例，触发上下文消费者重新渲染。你可以阅读更多关于<a class="ae kq" rel="noopener" href="/geekculture/great-confusion-about-react-memoization-methods-react-memo-usememo-usecallback-a10ebdd3a316"> <strong class="ju hj">记忆化</strong> </a>的内容。</p><h1 id="ae14" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用多个上下文:</h1><p id="a4c7" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果我们有两个上下文，一个用于主题模式，另一个用于登录用户信息，下面的示例演示了我们将如何使用它们:</p><p id="2794" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">对myContext.js文件进行了一些修改:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="17a9" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj"> App.js文件:</strong></p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3108" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果您喜欢直接使用消费者组件，下面的示例演示了我们将如何直接使用消费者组件来消费两个上下文，我将修改<code class="du mf mg mh mi b">UserMenu</code>组件:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="57e6" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">警告:</h1><p id="50fc" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">由于上下文使用引用标识来确定何时重新呈现，所以当提供者的父级重新呈现时，有一些问题可能会导致使用者中的意外呈现。</p><p id="d227" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">当您将一个对象传递给React上下文提供者，并且其上的任何属性都更新时，会发生什么呢？所有使用该上下文的组件都将重新呈现。状态值很少且不经常更新的较小应用程序(如主题数据)可能不会遇到这个问题。</p><p id="548e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果我们的应用程序在其组件树中有许多组件，并且您需要执行许多状态更新，这将是一个问题。</p><h2 id="7454" class="kw iv hi bd iw kx ky kz ja la lb lc je kd ld le ji kh lf lg jm kl lh li jq lj bi translated">示例:</h2><p id="a0f3" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">每次提供者重新呈现时，下面的代码将重新呈现所有消费者，因为总是为<code class="du mf mg mh mi b">userContext.provider value:</code>创建一个新对象</p><pre class="lk ll lm ln fd mj mi mk ml aw mm bi"><span id="38e3" class="kw iv hi mi b fi mn mo l mp mq">const App = () =&gt; {  <br/>  const [theme, setTheme] = useState(themes.light);<br/>  const value = useMemo(() =&gt; ({ theme, setTheme }), [theme]);  <br/> return (    <br/>  &lt;&gt;      <br/>   &lt;myContext.Provider value={value}&gt;     <br/>     &lt;userContext.Provider value={{name: "kirill"}&gt;    <br/>       &lt;Header /&gt;        <br/>        &lt;div&gt;           <br/>         &lt;h1&gt;Hello World!&lt;/h1&gt;      <br/>        &lt;/div&gt;         <br/>       &lt;Footer /&gt;        <br/>      &lt;/userContext.Provider&gt;  <br/>    &lt;/myContext.Provider&gt;    <br/>  &lt;/&gt;  <br/>   );<br/>};</span></pre><p id="1241" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">我们将通过将<code class="du mf mg mh mi b">userContext.provider</code>的值放入父节点的状态来解决这个问题:</p><pre class="lk ll lm ln fd mj mi mk ml aw mm bi"><span id="3f2f" class="kw iv hi mi b fi mn mo l mp mq">const App = () =&gt; {  <br/> const [userName, setUserName] = useState("kirill");<br/> return (    <br/>  &lt;&gt;      <br/>     &lt;userContext.Provider value={userName}&gt;    <br/>    <br/>      &lt;/userContext.Provider&gt;  <br/>  &lt;/&gt;  <br/>   );<br/>};</span></pre><p id="6fe1" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果你喜欢我的内容，请跟随我，我需要你的支持。我活跃在Twitter<a class="ae kq" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"><strong class="ju hj">@ IbraKirill</strong></a>。</p><p id="495e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果你喜欢读这篇文章，并且想支持我成为一名作家，你可以<a class="ae kq" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">请我喝杯咖啡！</strong> </a></p><p id="896c" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">如果你想深入<a class="ae kq" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.3645282&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Freact-the-complete-guide%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">上下文，钩子，Redux </strong> </a>。我用下面的<a class="ae kq" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.3645282&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Freact-the-complete-guide%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">课程来劝你。</strong>T15】</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Trained a Machine Learning Model in Pure SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用纯SQL训练了一个机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/trained-a-machine-learning-model-in-pure-sql-cbb75e911f80?source=collection_archive---------12-----------------------#2022-02-10">https://medium.com/geekculture/trained-a-machine-learning-model-in-pure-sql-cbb75e911f80?source=collection_archive---------12-----------------------#2022-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4af7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">因为递归cte可以“迭代”,所以有可能用纯SQL实现机器学习模型训练——完全不用Python</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6f5abd21698c2df616817d10f8caa6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ogtk8k1QXxppKxaU"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@pietrozj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pietro Jeng</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5b9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在文章<a class="ae jn" href="https://towardsdatascience.com/deep-neural-network-implemented-in-pure-sql-over-bigquery-f3ed245814d3" rel="noopener" target="_blank">用纯SQL实现的深度神经网络over BigQuery </a>中，作者声称用<em class="kk">纯SQL </em>实现了一个深度神经网络模型。但我打开他的<a class="ae jn" href="https://github.com/harisankarh/nn-sql-bq" rel="noopener ugc nofollow" target="_blank">回购</a>后，发现他<em class="kk">用Python实现迭代训练</em>，并不是真正的<strong class="jq hj"> <em class="kk">纯SQL </em> </strong>。</p><p id="045e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我将分享我如何在开源分布式SQL数据库<a class="ae jn" href="https://docs.pingcap.com/tidb/stable" rel="noopener ugc nofollow" target="_blank"> TiDB </a>上用纯SQL训练机器学习模型。主要步骤包括:</p><ol class=""><li id="ceec" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj kq kr ks kt bi translated">选择<a class="ae jn" href="https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a></li><li id="dd5e" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">选择softmax逻辑回归模型进行训练</li><li id="64a9" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">编写SQL语句来实现模型推理</li><li id="f1e8" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">训练模型</li></ol><p id="e919" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的测试中，我训练了一个softmax逻辑回归模型。在测试过程中，我发现TiDB不允许在递归公共表表达式(cte)中使用子查询和聚合函数。通过修改TiDB的代码，我绕过了这些限制，成功地训练了一个模型，并在Iris数据集上获得了98%的准确率。</p><h1 id="8413" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">为什么我选择TiDB来实现机器学习模型</h1><p id="b9f5" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated"><a class="ae jn" href="https://pingcap.com/blog/tidb-5.1-easily-build-your-mission-critical-applications-at-any-scale#common-table-expression-write-sql-statements-more-efficiently" rel="noopener ugc nofollow" target="_blank"> TiDB 5.1 </a>引入了许多新特性，包括ANSI SQL 99标准的通用表表达式(cte)。我们可以使用CTE作为临时视图的语句，以分离复杂的SQL语句并更有效地开发代码。此外，递归CTE可以引用自身。这对改进SQL功能很重要。而且，<strong class="jq hj"> CTEs和window函数让SQL成为了一种</strong> <a class="ae jn" href="https://en.wikipedia.org/wiki/Turing_completeness" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">图灵-完全</strong> </a> <strong class="jq hj">语言。</strong></p><p id="08bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">因为递归cte可以“迭代”，所以我想试试看能不能用纯SQL在TiDB上实现机器学习模型训练和推理。</strong></p><h1 id="d28d" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">虹膜数据集</h1><p id="4142" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated">我选择了scikit-learn上的虹膜数据集。该数据集包含3种类型的150条记录，每种类型有50条记录。每个记录有4个特征:萼片长度(sl)、萼片宽度(sw)、花瓣长度(pl)和花瓣宽度(pw)。我们可以使用这些特征来预测一个鸢尾是属于刚毛鸢尾、杂色鸢尾还是海滨鸢尾。</p><p id="9eaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我下载了CSV格式的数据后，我将其导入TiDB。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="f376" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">Softmax逻辑回归</h1><p id="cdf8" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated">我选择了一个简单的机器学习模型:softmax logistic回归进行多类分类。</p><p id="9f34" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在softmax回归中，将x归入y类的概率为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/27d8dcbbf438fe38407826e76f8a5113.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/0*oiWnJ2TCkcwCnaLO"/></div></figure><p id="cbf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">成本函数是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/0440363c5bc63daaf8e54145bb08c74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*1IYeR-6Cpw6i7sbL"/></div></div></figure><p id="44a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">梯度为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/5d00a3983e525abba2b4101914bf6068.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/0*AjyRCdcQ4lf7ZpL7"/></div></figure><p id="aa09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我们可以使用梯度下降来升级梯度:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/1706347363eba4c2de26937025c6ffa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/0*NBqwVGQ1YEUBqy2Q"/></div></figure><h1 id="30da" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">模型推理</h1><p id="f03e" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated">我写了一个SQL语句来实现推理。基于上面定义的模型和数据，输入数据x具有五个维度(sl、sw、pl、pw和常数1.0)。输出使用了一键编码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="486c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">共有15个参数:3种类型* 5个维度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="8434" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我将输入数据初始化为0.1，0.2，0.3。为了便于演示，我使用了不同的数字。将它们全部初始化为0.1是可以的。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="44ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我编写了一个SQL语句来统计数据推断的结果准确性。为了更好的理解，我用伪代码来描述这个过程:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="9022" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码中，我计算了每行数据中的元素。做出一个样本的推断:</p><ol class=""><li id="9acc" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj kq kr ks kt bi translated">我得到了加权向量的指数。</li><li id="8f87" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">我得到了softmax值。</li><li id="9ad7" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">我选择p0、p1和p2的最大值作为1；我把剩下的设置为0。</li></ol><p id="372f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果一个样本的推断结果与其原始分类一致，则是正确的预测。然后，我将所有样本的正确数字相加，得到最终的准确率。</p><p id="9105" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下代码显示了SQL语句的实现。我用一个权重连接每一行数据(只有一行数据)，计算每一行的推断结果，并合计出正确的样本数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="8355" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的SQL语句几乎是一步一步实现了伪代码的计算过程。我得到了结果:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="cbea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我将学习模型参数。</p><h1 id="1528" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">模特培训</h1><p id="114a" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated"><em class="kk">注意:为了简化问题，我没有考虑“训练集”和“验证集”的问题，我使用的所有数据都只用于训练。</em></p><p id="26f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我写了伪代码，然后基于它写了一个SQL语句:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e838" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我手动扩展了sum和w向量，所以这段代码看起来有点麻烦。</p><p id="60ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我开始写SQL培训。首先，我编写了一个只有一次迭代的SQL语句。</p><p id="8c5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我设置学习率和样本数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="91ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">代码迭代了一次:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="18e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一次迭代后的结果是模型参数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="a665" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是核心部分。我使用递归cte进行迭代训练:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="2287" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">核心思想是每次迭代的输入都是前一次迭代的结果，我增加了一个增量迭代变量来控制迭代次数。总体框架是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="247a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我将一个迭代的SQL语句与这个迭代框架结合起来。为了提高计算精度，我向中间结果添加了类型转换:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="0e06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个代码块和上面一次迭代的代码块有两个不同之处。在这个代码块中:</p><ul class=""><li id="4b60" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj mc kr ks kt bi translated">在<code class="du md me mf mg b">data join weight</code>之后，我添加了<code class="du md me mf mg b">where iter &lt;@num_iterations</code>来控制迭代次数和输出的<code class="du md me mf mg b">iter + 1 as iter</code>列。</li><li id="7a86" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj mc kr ks kt bi translated">我加了<code class="du md me mf mg b">having count(*)&gt; 0</code>防止聚合在最后没有输入数据的情况下输出数据。此错误可能会导致迭代无法结束。</li></ul><p id="68df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="cf89" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这表明递归cte在递归部分不允许子查询。但是我可以合并上面所有的子查询。在我手动合并它们之后，我得到了这个:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3d64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它表明不允许使用聚合函数。</p><p id="7e33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我决定改变TiDB的实现。</p><p id="7453" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据<a class="ae jn" href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-04-18-common-table-expression.md" rel="noopener ugc nofollow" target="_blank">提案</a>中的介绍，递归cte的实现遵循了TiDB的基本执行框架。在我咨询了<a class="ae jn" href="https://pingcap.com/" rel="noopener ugc nofollow" target="_blank"> PingCAP </a>的R&amp;D<a class="ae jn" href="https://github.com/wjhuang2016" rel="noopener ugc nofollow" target="_blank">Wenjun Huang</a>之后，我了解到不允许使用子查询和聚合函数有两个原因:</p><ul class=""><li id="be23" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj mc kr ks kt bi translated">MySQL不允许它们。</li><li id="2487" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj mc kr ks kt bi translated">如果允许的话，会有很多复杂的死角案例。</li></ul><p id="793b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但我只是想测试一下功能。我在<a class="ae jn" href="https://github.com/pingcap/tidb/compare/master...francis0407:cte_ml?expand=1" rel="noopener ugc nofollow" target="_blank"> diff </a>中临时删除了对子查询和聚合函数的检查。</p><p id="47f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我再次执行代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="de56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">成功了！经过1000次迭代，我得到了参数。</p><p id="dfd4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我使用新的参数来重新计算正确的比率:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="7eed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这一次，准确率达到了98%。</p><h1 id="effd" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">结论</h1><p id="31aa" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated">通过使用TiDB 5.1中的递归cte，我成功地使用纯SQL在TiDB上训练了一个softmax逻辑回归模型。</p><p id="213f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在测试过程中，我发现TiDB的递归cte不允许子查询和聚合函数，所以我修改了TiDB的代码来绕过这些限制。最后，我成功地训练了一个模型，并在Iris数据集上获得了98%的准确率。</p><p id="d387" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的工作也揭示了一些想法，我希望你能思考一下。如果你对这些话题感兴趣，请加入Slack 上的<a class="ae jn" href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=everyone&amp;ref=pingcap-blog" rel="noopener ugc nofollow" target="_blank"> TiDB社区，和我一起讨论。</a></p><ul class=""><li id="fdb0" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj mc kr ks kt bi translated">在我做了一些测试之后，我发现PostgreSQL和MySQL都不支持递归cte中的聚合函数。可能会有难以处理的棘手情况。</li><li id="af80" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj mc kr ks kt bi translated">在这个测试中，我手动扩展了向量的所有维度。其实我也写了一个不需要扩展所有维度的实现。例如，数据表的模式是(idx，dim，value)，但是在这个实现中，权重表需要连接两次。这意味着它需要在CTE中被访问两次。这也需要修改TiDB执行器的实现。所以，我在这篇文章里没有讲。但实际上，这个实现更通用，可以处理更多维度的模型，例如MNIST数据集。</li></ul></div></div>    
</body>
</html>
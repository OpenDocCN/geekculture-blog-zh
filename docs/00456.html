<html>
<head>
<title>Handy Form Validation in React Native With React-hook-form useController</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React-hook-form useController在React Native中进行方便的表单验证</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/handy-form-validation-in-react-native-with-react-hook-form-usecontroller-3d4c4297e843?source=collection_archive---------4-----------------------#2021-02-11">https://medium.com/geekculture/handy-form-validation-in-react-native-with-react-hook-form-usecontroller-3d4c4297e843?source=collection_archive---------4-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b9cb7cbb4e8abcef9a09938e8cc7f7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1g6c6shnWDmTo5HIm5WZg.png"/></div></div></figure><div class=""/><p id="5552" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React Native中管理表单与在web React中不同。我们没有快捷方式和HTML来通过ref注册字段。</p><p id="359c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的目标是创建一个方便的解决方案来满足这些需求:</p><ul class=""><li id="c44a" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">很容易理解，</li><li id="cd6b" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">可扩展，</li><li id="7e02" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">可重复使用，</li><li id="658c" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">小样本，</li><li id="fcce" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">钩子居中。</li></ul><p id="dc6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过几天的实验，我终于找到了一个令我满意的解决方案。这篇文章是我工作的总结。相信这对你会有帮助。</p><h1 id="ec54" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">如何使用react-hook-form和React Native</h1><p id="6a82" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我决定使用<code class="du lf lg lh li b">react-hook-form</code>，因为它越来越受欢迎，这是有充分理由的。</p><p id="a25a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文可以被视为React Native中的表单教程。</p><p id="8c71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以将本文中介绍的方法与<code class="du lf lg lh li b">formik</code>或您选择的其他类似包一起使用。先通读完，检查你的表单管理包有没有类似的API。</p><p id="70e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码片段中不包含导入、导出和其他杂项代码，如PropTypes，以避免过载。示例是原始文件的简化版本，可以在本文所附的git资源库中找到<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="5e26" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">0.准备项目</h1><p id="1596" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我已经创建了一个新的React本地项目，并为我们的示例准备了它。</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="0f81" class="ls kd ht li b fi lt lu l lv lw">npx react-native init ElegantFormManagement</span><span id="12ce" class="ls kd ht li b fi lx lu l lv lw">cd ElegantFormManagement</span><span id="7eee" class="ls kd ht li b fi lx lu l lv lw">yarn &amp;&amp; yarn start</span></pre><h1 id="8d1c" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1.创建没有任何逻辑的登录表单用户界面</h1><p id="5317" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们从一个简单的任务开始。我们将首先创建表单的线框。在项目的根目录里面添加<code class="du lf lg lh li b">src/components</code>目录。</p><p id="e319" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们需要两个新文件<code class="du lf lg lh li b">Input.js</code>和<code class="du lf lg lh li b">Login.js</code>:</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="d873" class="ls kd ht li b fi lt lu l lv lw">src<br/>├── components<br/>│   ├── Input.js<br/>│   └── Login.js</span></pre><h1 id="21bf" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">输入. js</h1><p id="7fd5" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du lf lg lh li b">Input.js</code>是React Native的<code class="du lf lg lh li b">TextInput</code>组件的包装器。它具有扩展功能，在输入字段上方显示标签，在其下方显示<em class="ly">(如果提供)</em>验证错误。</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="ec4b" class="ls kd ht li b fi lt lu l lv lw">&lt;Label&gt;{label}&lt;/Label&gt;<br/>&lt;TextInput /&gt;<br/>{isError &amp;&amp; &lt;Error&gt;{error}&lt;/Error&gt;}</span></pre><h2 id="996a" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">关于样式组件的一句话</h2><p id="8b8d" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du lf lg lh li b">styled-components</code>将在示例中使用，以使组件更具可读性。</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="bf6b" class="ls kd ht li b fi lt lu l lv lw">yarn add styled-components</span></pre><p id="8671" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢<code class="du lf lg lh li b">'styled-components/native'</code> <em class="ly">(注意</em> <code class="du lf lg lh li b"><em class="ly">/native</em></code> <em class="ly">后缀)</em>我们可以用React Native的组件代替HTML元素。例如用<code class="du lf lg lh li b">styled.View</code>代替<code class="du lf lg lh li b">styled.div</code>。</p><p id="40f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你不熟悉这种风格的方法，这是一个快速的比较:</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="fdcb" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">Input.js代码</h2><p id="0688" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在下面的代码中，你可以看到条件渲染<code class="du lf lg lh li b">{Boolean(value) &amp;&amp; &lt;Something /&gt;}</code>受到了<code class="du lf lg lh li b">Boolean()</code>函数的保护。如果你很好奇或者不明白我为什么这么做，请阅读React Native中的<a class="ae lj" href="https://koprowski.it/2020/conditional-rendering-react-native-text-crash/" rel="noopener ugc nofollow" target="_blank">条件渲染可能会导致你的应用崩溃</a>。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="4c52" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Login.js</h1><p id="ec49" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du lf lg lh li b">Login.js</code>将是我们的形式。目前，它只是被嘲笑的成分。它由用户名&amp;密码的两个输入框和一个提交按钮组成。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="831d" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">App.js</h1><p id="b24c" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du lf lg lh li b">App.js</code>是React Native的标准输入起始场景。删除所有的东西，只在里面渲染<code class="du lf lg lh li b">&lt;Login /&gt;</code>的形状。</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="371f" class="ls kd ht li b fi lt lu l lv lw">// App.js<br/><br/>const App = () =&gt; {<br/>  return (<br/>    &lt;View&gt;<br/>      &lt;Login /&gt;<br/>    &lt;/View&gt;<br/>  )<br/>}</span></pre><p id="45d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们的应用程序看起来像这样:</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/43e25f4330a793386b35c08f7c27ab8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hcNAPEPX5IezQh2W.jpg"/></div></div></figure><p id="bc67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要检查这一步的完整源代码，请访问git库上的分支<code class="du lf lg lh li b"><a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/01-create-basic-ui" rel="noopener ugc nofollow" target="_blank">01-create-basic-ui</a></code> <a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/01-create-basic-ui" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="660e" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">2.创建表单</h1><p id="9314" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">安装<code class="du lf lg lh li b">react-hook-form</code>包的时间到了。</p><h1 id="ba22" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">安装反应钩模板</h1><p id="7754" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用以下命令停止metro bundler并安装软件包:</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="88e9" class="ls kd ht li b fi lt lu l lv lw">yarn add react-hook-form</span></pre><p id="6f90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们准备将一些逻辑引入我们的UI <code class="du lf lg lh li b">&lt;Login /&gt;</code> mock。</p><h1 id="f569" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">导入表单的大脑</h1><p id="ce1f" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们的表单将存在于由<code class="du lf lg lh li b">useForm()</code> hook返回的对象中。我们姑且称这个对象为<code class="du lf lg lh li b">formMethods</code>。</p><p id="17ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在导入需要的钩子并在<code class="du lf lg lh li b">&lt;Login /&gt;</code>组件中添加<code class="du lf lg lh li b">const formMethods = useForm()</code>。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="dc60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将不得不与表单域进行通信。为此，我们将把<code class="du lf lg lh li b">formMethods</code>传递给我们的输入组件。</p><p id="a3d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整源代码:<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/02-create-form" rel="noopener ugc nofollow" target="_blank">02-在git repo上创建表单</a>。</p><h1 id="c948" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">3.与表单域建立通信</h1><p id="1bbb" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">以优雅的方式制作东西的最大挑战是避免太多的“魔法”。代码需要易于阅读，但也能被其他程序员理解。我们为自己和同事编写代码，而不是为计算机。如果我们要为计算机写代码，那么我们应该使用汇编语言或者更低级的语言。</p><p id="b1ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React Context只是一个小魔术。它将简化代码，当小心使用时，不会给我们的解决方案增加太多复杂性。</p><h1 id="a421" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是反应上下文？</h1><p id="9b27" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">长话短说，我们将向组件的子组件提供相同的信息和所谓的“上下文”,而不是传递大量的组件道具。然后每个孩子都可以通过一个钩子访问上下文🎣。</p><h1 id="4731" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">添加FormProvider以传递表单上下文</h1><p id="5610" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我提到过我们的形体生活在<code class="du lf lg lh li b">formMethods</code>里面。我们必须将这个对象的内容传递给表单字段。在这种情况下，我们的字段是用户名和密码的<code class="du lf lg lh li b">&lt;Input /&gt;</code>组件。</p><p id="bfb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们把<code class="du lf lg lh li b">formMethods</code>里面的一切放入上下文中。为此，我们必须从<code class="du lf lg lh li b">react-hook-form</code>进口<code class="du lf lg lh li b">&lt;FormProvider /&gt;</code>。现在我们使用对象扩展操作符<code class="du lf lg lh li b">{...formMethods}</code>将所有内容从<code class="du lf lg lh li b">formMethods</code>传递到<code class="du lf lg lh li b">FormProvider</code>。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="41db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我没有将<code class="du lf lg lh li b">Button</code>包装成<code class="du lf lg lh li b">FormProvider</code>的子对象。这是我们的形式的一个关键因素，因为按下它将提交整个事情。我们将使用良好的旧道具与按钮交互，这样它就不必知道表单中发生的所有事情。</p><p id="f93d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">见分支<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/03-pass-context-to-fields" rel="noopener ugc nofollow" target="_blank">03-传递上下文到字段</a></p><h1 id="f0ba" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">4.向输入组件添加逻辑</h1><p id="8f0b" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们的UI框架<code class="du lf lg lh li b">&lt;Input /&gt;</code>除了显示标签和错误还没有做任何事情。它不提供操纵内部<code class="du lf lg lh li b">&lt;TextInput /&gt;</code>的道具。</p><h1 id="f395" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将属性传递给输入</h1><p id="6840" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们将再次使用spread运算符将所有<code class="du lf lg lh li b">Input</code>道具(除了<code class="du lf lg lh li b">label</code>和<code class="du lf lg lh li b">error</code>)分配给名为<code class="du lf lg lh li b">textInputProps</code>的对象。接下来，我们必须将这个对象传递给<code class="du lf lg lh li b">StyledInput</code>，它只是标准React Native <code class="du lf lg lh li b">TextInput</code>组件的一个样式版本。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="3481" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">创建输入包装</h1><p id="c1ca" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们有一个非常简单的<code class="du lf lg lh li b">Input</code>组件，在将来很容易测试和扩展。保持这种方式。</p><p id="997f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想给这个组件添加逻辑。我们将创建一个新的组件，而不是直接在<code class="du lf lg lh li b">Input</code>中添加逻辑并将其与我们的表单管理解决方案绑定。它将在内部使用<code class="du lf lg lh li b">Input</code>，并为其配备额外的功能。</p><h1 id="a9eb" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">FormInput控制输入</h1><p id="3b96" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du lf lg lh li b">FormInput</code>比<code class="du lf lg lh li b">Input</code>需要一点不同的道具。例如，它会在内部决定<code class="du lf lg lh li b">error</code>和<code class="du lf lg lh li b">Input</code>的<code class="du lf lg lh li b">value</code>道具，所以我们不能将这些道具传递给它。</p><p id="d050" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们与前总部建立了联系。为了实现这一点，我们添加了<code class="du lf lg lh li b">useFormContext()</code>钩子，它返回我们已经通过<code class="du lf lg lh li b">&lt;FormProvider /&gt;</code>传递的对象。例如，我们可以读取所有访问<code class="du lf lg lh li b">formContext.errors</code>字段的表单错误。</p><p id="c211" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看一看:</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="afa8" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated"><code class="du lf lg lh li b">name</code>道具</h2><p id="2774" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">要求表单中的每个字段都有一个唯一的名称。因此，我们将<code class="du lf lg lh li b">name</code> prop传递给每个表单字段。<strong class="is hu">它是一个字段的标识符。</strong></p><h2 id="baba" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">错误对象</h2><p id="6203" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">要在<code class="du lf lg lh li b">Input</code>组件上显示适当的错误，请从上下文访问<code class="du lf lg lh li b">errors</code>对象。然后检查我们的字段<code class="du lf lg lh li b">errors[name].</code>是否有错误消息。如果没有错误，那么<code class="du lf lg lh li b">errors[name]</code>是未定义的——因此我们必须小心。为了访问错误消息，我使用了一个全新的<strong class="is hu">可选链接</strong>操作符(<code class="du lf lg lh li b"><strong class="is hu">?.</strong></code>)。</p><blockquote class="mp mq mr"><p id="862a" class="iq ir ly is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated"><em class="ht"/><code class="du lf lg lh li b"><em class="ht">?.</em></code><em class="ht">操作符的功能与</em> <code class="du lf lg lh li b"><em class="ht">.</em></code> <em class="ht">链接操作符类似，只是如果引用是</em><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish" rel="noopener ugc nofollow" target="_blank"><em class="ht">nullish</em></a><em class="ht">(</em><code class="du lf lg lh li b"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank"><em class="ht">null</em></a></code><em class="ht">或</em> <code class="du lf lg lh li b"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank"><em class="ht">undefined</em></a></code> <em class="ht">)，表达式会短路，返回值为</em> <code class="du lf lg lh li b"><em class="ht">undefined</em></code> <em class="ht">。</em></p></blockquote><p id="f8d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有错误信息，那么<code class="du lf lg lh li b">Input</code>将会收到该信息。否则，它将收到<code class="du lf lg lh li b">undefined</code>。</p><h2 id="9561" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">使用控制器</h2><p id="f4a0" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们与形式有联系，所以让我们使用它！嗯，…差不多了。</p><p id="534b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在将使用我们的表单来存储这个<code class="du lf lg lh li b">FormInput</code>的值。首先，我们必须用<code class="du lf lg lh li b">useController</code>钩子创建我们的字段实例。看看下面的代码示例:</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="75d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lf lg lh li b">useController</code>中，最重要的配置字段是前面提到的<code class="du lf lg lh li b">name</code>和<code class="du lf lg lh li b">control</code>对象。通过向控制器提供<code class="du lf lg lh li b">control</code>对象来建立字段和表单之间的连接。</p><p id="1ac2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">记住</strong> <code class="du lf lg lh li b"><strong class="is hu">control</strong></code> <strong class="is hu">是形体</strong>的一个中心点，这就是我之前提到的“形体的大脑”。</p><p id="12f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了给字段添加一些限制(如<code class="du lf lg lh li b">maxLength</code>，<code class="du lf lg lh li b">required</code>)，有<code class="du lf lg lh li b">rules</code>对象。我们也可以使用<code class="du lf lg lh li b">yup</code>模式或自定义解析函数。</p><h2 id="dedd" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">领域</h2><p id="0a0f" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了保持<code class="du lf lg lh li b">Input</code>的值和状态，我们有一个<code class="du lf lg lh li b">field</code>对象。</p><p id="4a1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从现在开始<code class="du lf lg lh li b">Input</code>由<code class="du lf lg lh li b">field</code>对象控制，所以我们传递<code class="du lf lg lh li b">value</code>和事件处理程序<em class="ly"> ( </em> <code class="du lf lg lh li b"><em class="ly">onBlur</em></code> <em class="ly">和</em> <code class="du lf lg lh li b"><em class="ly">onChange</em></code> <em class="ly"> ) </em>。</p><p id="e3a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">字段的所有属性:<code class="du lf lg lh li b">{ onChange, onBlur, value, name, ref }</code>。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6487" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，在<code class="du lf lg lh li b">Input</code>组件上，我们使用<code class="du lf lg lh li b">onChangeText</code>道具从输入字段<code class="du lf lg lh li b">onChangeText={field.onChange}</code>中获取<code class="du lf lg lh li b">string</code>而不是<code class="du lf lg lh li b">event</code>。</p><h1 id="3ab5" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">注册</h1><p id="44c9" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在我们的主窗体视图<code class="du lf lg lh li b">Login.js</code>中将<code class="du lf lg lh li b">Input</code>组件改为<code class="du lf lg lh li b">FormInput</code>。</p><p id="38a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还从密码输入中删除了<code class="du lf lg lh li b">error</code>道具，因为这不再是演示视图——它几乎可以工作了！</p><h2 id="32d7" class="ls kd ht bd ke lz ma mb ki mc md me km jb mf mg kq jf mh mi ku jj mj mk ky ml bi translated">登录_字段</h2><p id="11d1" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">表单会随着时间的推移而增长，所以明智的做法是将所有的常量保存在变量中。我已经为字段名创建了<code class="du lf lg lh li b">LOGIN_FIELDS</code> const。它可以防止在未来的几个小时里出现打字错误和寻找小错误。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="ba35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们的表单存储值并对变化做出反应。字段与中央<code class="du lf lg lh li b">formMethods</code>对象连接，但是我们缺少任何验证和提交。让我们在下一节深入探讨它。</p><p id="9340" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看git存储库上的完整源代码检查分支<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/04-create-form-input" rel="noopener ugc nofollow" target="_blank"> 04-create-form-input </a>。</p><h1 id="6652" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">5.验证并提交</h1><p id="1a27" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">要从表单发送数据，我们必须注意登录按钮。</p><p id="1a0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建两个处理程序:</p><ul class=""><li id="82b3" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du lf lg lh li b">onSubmit</code>当它有效时，它以一个完整的形式作为一个论点，</li><li id="e31e" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du lf lg lh li b">onErrors</code>它将处理表单中的错误。</li></ul><p id="fcc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们把<code class="du lf lg lh li b">handleSubmit</code>功能从<code class="du lf lg lh li b">formMethods</code>传递到按钮的<code class="du lf lg lh li b">onPress</code>道具。<code class="du lf lg lh li b">handleSubmit</code>函数以两个回调函数作为参数- <code class="du lf lg lh li b">onSubmit</code>和<code class="du lf lg lh li b">onError</code>。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="a9e4" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">没有规则</h1><p id="ea7a" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">没有规则，所以表单总是有效的！此时，每按一次按钮就会调用<code class="du lf lg lh li b">onSubmit</code>。<code class="du lf lg lh li b">onErrors</code>被忽略。我们必须为用户名和密码添加一些限制。</p><p id="3e9f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将<code class="du lf lg lh li b">rules</code>对象作为道具传递给<code class="du lf lg lh li b">FormInput</code>。注意，像<code class="du lf lg lh li b">minLength</code>这样复杂的规则由一个对象表示，而像<code class="du lf lg lh li b">required</code>这样简单的规则可以由一个带有错误消息的字符串表示。要了解规则如何工作，请参见<code class="du lf lg lh li b">react-hook-form</code>文档。</p><p id="84f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ly">此时，我们可以用</em> <code class="du lf lg lh li b"><em class="ly">yup</em></code> <em class="ly">模式来代替规则。模式在表单验证方面要强大得多。为了不使本文过于复杂，我在这里不做介绍。如果你感兴趣，请在评论中告诉我！我可以准备“第二部分”的形式冒险。</em></p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="0602" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经处理了一个非常基本的登录表单场景。现在，让我们看看在这个简单的解决方案中我们可以改进什么。</p><p id="e38e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在此时检查完整的源代码，请检查git repo上的<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/05-submit-form" rel="noopener ugc nofollow" target="_blank"> 05-submit-form </a>分支。</p><h1 id="e0a0" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">6.使每个表单域防错</h1><p id="c545" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们之前提到过表单域需要<code class="du lf lg lh li b">name</code>和表单上下文。为此，我们通过prop传递<code class="du lf lg lh li b">name</code>,并从<code class="du lf lg lh li b">useFormContext</code> hook获取上下文。</p><p id="92ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设代码的作者和团队中的每个开发人员总是会传递适当的prop并在<code class="du lf lg lh li b">FormProvider</code>中包装我们的表单，这太乐观了。我们必须让代码防错。</p><p id="399b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果能给开发人员一个适当的信息，告诉他们有东西被遗忘了，那就太好了。除非我们想向用户展示其中一个错误:</p><ul class=""><li id="fbd1" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">当你忘记传递道具名称时，</li><li id="3af5" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du lf lg lh li b">TypeError: Cannot read property 'control' of null</code>当字段未被<code class="du lf lg lh li b">FormProvider</code>包裹时弹出。</li></ul><p id="3771" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以像这样简单地尝试应用条件渲染:</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4429" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是不有条件地调用钩子会违反React规则，如果您正确配置了ESLint，您会看到这样错误:</p><p id="99d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh li b">React Hook "useController" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?</code></p><h1 id="114f" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">另一个包装纸</h1><p id="0695" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">乍看之下，这可能并不那么美好，但它让事情得以完成:</p><ul class=""><li id="ae92" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">它保持钩子调用顺序不变，</li><li id="58e7" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使包装的组件安全。</li></ul><p id="8faa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的代码片段中，我将旧的<code class="du lf lg lh li b">FormInput</code>组件重命名为<code class="du lf lg lh li b">ControlledInput</code>，并删除了其中的<code class="du lf lg lh li b">export</code>，使其成为“私有”组件。这可以防止在项目的其他文件中导入<code class="du lf lg lh li b">ControlledInput</code>。</p><p id="fdaa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我创建了一个新的“公共”组件——包装器。现在这个叫<code class="du lf lg lh li b">FormInput</code>，从文件导出。包装器内部的逻辑非常简单。它检查<code class="du lf lg lh li b">formContext</code>或<code class="du lf lg lh li b">name</code>是否为假，如果是，包装器返回<code class="du lf lg lh li b">&lt;Input /&gt;</code>一个正确的错误信息。我还阻止了对这些字段的编辑，以确保集成测试失败。</p><p id="4720" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加错误消息使得将来出现问题时更容易调试。由于这一点，你的自动测试或QA团队将立即发现有问题。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3b99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时要查看<code class="du lf lg lh li b">FormInput.js</code>的完整源代码，请检查分支<a class="ae lj" href="https://github.com/dkoprowski/react-native-form-validation-tutorial/tree/06-error-proof-fields" rel="noopener ugc nofollow" target="_blank">06-防错字段</a>。</p><h1 id="bb51" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">下一步是什么？</h1><p id="1747" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用<code class="du lf lg lh li b">FormInput.js</code> base，您可以类似地构建其他表单字段，如:<code class="du lf lg lh li b">FormChecbox</code>、<code class="du lf lg lh li b">FormTextArea</code>等。</p><p id="1fc2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我可以在这里添加更多内容，如:</p><ul class=""><li id="204a" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">使用yup模式，</li><li id="2395" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">描述如何从键盘上聚焦密码字段，</li><li id="b84a" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">如何通过<code class="du lf lg lh li b">ref</code>到<code class="du lf lg lh li b">FormInput</code>，</li><li id="e79c" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">为共享表单域逻辑创建一个自定义挂钩，</li><li id="5081" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">如何测试形式…</li></ul><p id="3f5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我这篇文章的初稿包含了所有这些东西，但是它开始超载了！如果你想看的话，我下次可以用。让我知道！</p><h1 id="2272" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">生产就绪表单</h1><p id="02ac" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在撰写本文时，我决定为React Native创建生产就绪的表单！</p><p id="696d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">带有组件库和<strong class="is hu">整体视图</strong>的移动应用模板，您可以在应用中重复使用。</p><p id="1b0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比如即用型注册表单、登录表单、app意见表、聊天等。</p><p id="28da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切可以加速React本地开发人员或团队工作的东西。我正在准备一个预建的移动应用程序，包含所有这些表单。您可以下载它并根据自己的需要进行调整。</p><p id="a97f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击这里查看项目:【ProductionReadyForms.com】T2。</p><p id="6be9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当这个包裹准备好的时候我会通知你！你可以在<a class="ae lj" href="https://productionreadyforms.com/" rel="noopener ugc nofollow" target="_blank">网站</a>上以简讯的形式给我留下你的电子邮件。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><ul class=""><li id="8dab" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><em class="ly">最初发布于</em><a class="ae lj" href="https://koprowski.it/react-native-form-validation-with-react-hook-form-usecontroller" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://koprowski . it</em></a><em class="ly">。</em></li><li id="1137" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hu">查看我的推特</strong><a class="ae lj" href="https://twitter.com/Koprowski_it" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">Koprowski _ it</strong></a></li></ul><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="nc mn l"/></div></figure></div></div>    
</body>
</html>
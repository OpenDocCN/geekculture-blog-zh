<html>
<head>
<title>Angular Routing Guide: How to Optimize App Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度路由指南:如何优化应用程序导航</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-routing-guide-how-to-optimize-app-navigation-50ba5882f577?source=collection_archive---------3-----------------------#2021-02-11">https://medium.com/geekculture/angular-routing-guide-how-to-optimize-app-navigation-50ba5882f577?source=collection_archive---------3-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3062c19154df89bd517150bb996e0d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVOFUcVtIsv5yPQvpHnudg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><p id="aeeb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Angular是最受欢迎的前端框架之一，有30%的开发人员喜欢在他们的项目中使用它。角度对于具有许多不同视图和构件的大型项目尤其有用。</p><p id="ccf7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让这些大型项目引人入胜的关键是一个逻辑导航结构，允许用户轻松地浏览和重访页面。幸运的是，Angular的路由功能使优化导航变得简单。</p><p id="d009" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">今天，我们将了解更多关于Angular Router的功能，并帮助您制作一个完全可导航的应用程序。</p><p id="de60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">这是我们今天要讲的内容:</strong></p><ul class=""><li id="e7fd" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">什么是角路由器</li><li id="bde0" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">什么是通配符路由</li><li id="a59f" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">子路由</li><li id="3228" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">RouterLink指令</li><li id="66f4" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">添加活动链接样式</li><li id="0fe1" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">延迟加载模块</li><li id="a86c" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">接下来学什么</li></ul><h1 id="bb6f" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是角路由器？</h1><p id="1eec" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated"><strong class="iw hj"> Angular Router </strong>是Angular 2+默认内置的一个重要包。它用于构建具有多个视图的单页面应用程序，可以通过URL进行导航，称为“路由”。</p><p id="bb57" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">URL由域名和路由定义(称为路径)组成。路径是服务器用来访问数据库中特定资源的JavaScript对象。当服务器为我们的应用程序提供服务时，Angular将从URL中获取路径，并将其与我们已经设置的任何有效路径进行匹配。本质上，我们设置了一个键/值关系，将类似于<code class="du lj lk ll lm b">/blog</code>的路径作为键，将期望的页面作为<code class="du lj lk ll lm b">value</code>。</p><p id="ee41" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这使得用户可以轻松地导航您的应用程序并访问他们想要的页面，而不必从主页组件开始。路由支持常见的浏览器行为，如前进/后退箭头和页面书签。</p><p id="52f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">路由器还包含用于高级行为的工具，如多个路由器出口、不同的路径匹配策略、轻松访问路由参数以及保护组件免受未授权访问的路由防护。</p><h1 id="3406" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">路由模块和路由输出</h1><p id="4ef8" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">路由模块是定义新路由并帮助配置路由器的特殊角度模块。所有路由模块的名称后都有后缀<code class="du lj lk ll lm b">-routing</code>，这是Angular CLI自动添加的。</p><p id="88a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个路由模块为具有相同基本名称的配对模块设置路由行为。例如，我们的<code class="du lj lk ll lm b">home</code>模块的路由行为将在路由模块<code class="du lj lk ll lm b">home-routing</code>中。</p><p id="edc1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是我们的<code class="du lj lk ll lm b">home</code>模块的路由模块示例，称为<code class="du lj lk ll lm b">home-routing.module.ts</code>:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="c65f" class="lv kh hi lm b fi lw lx l ly lz">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';<br/>import { HomeMainComponent } from './home-main/home-main.component';</span><span id="07c5" class="lv kh hi lm b fi ma lx l ly lz">const routes: Routes = [<br/>  { path: '', component: HomeMainComponent }<br/>];</span><span id="8c68" class="lv kh hi lm b fi ma lx l ly lz">@NgModule({<br/>  imports: [RouterModule.forChild(routes)],<br/>  exports: [RouterModule]<br/>})<br/>export class HomeRoutingModule { }</span></pre><p id="18a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以在<code class="du lj lk ll lm b">routes</code>数组变量中找到我们的路线。<code class="du lj lk ll lm b">routes</code>数组的每个元素代表一个组件视图的路径。</p><p id="ab77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些元素由两部分组成，一个是提供URL路径的属性<code class="du lj lk ll lm b">path</code>,另一个是定义哪个组件将被加载到所提供的路径的属性<code class="du lj lk ll lm b">component</code>。</p><p id="4b44" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我们输入一个空字符串(解释为正斜杠)来表示这个组件是我们的主页，如果有人只是输入域名就应该加载。然后我们输入Angular应该获取的组件名作为我们的主页，<code class="du lj lk ll lm b">HomeMainComponent</code>。</p><blockquote class="mb mc md"><p id="811b" class="iu iv me iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr hb bi translated"><em class="hi">如果我们希望用户在其他地方登陆，我们也可以使用</em> <code class="du lj lk ll lm b"><em class="hi">redirectto</em></code> <em class="hi">将空的路径URL指向另一个页面。</em></p></blockquote><p id="91e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们需要从<code class="du lj lk ll lm b">HomeModule</code>的输出中移除<code class="du lj lk ll lm b">HomeMainComponent</code>。这种路由的使用意味着我们不再导出组件，而是让路由器在用户访问路由时负责加载组件。</p><p id="e2e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们将用下面一行替换<code class="du lj lk ll lm b">app.component.html</code>文件的内容:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="58c5" class="lv kh hi lm b fi lw lx l ly lz">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><p id="6ee5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，<code class="du lj lk ll lm b">&lt;router-outlet&gt;</code>充当组件的占位符。我们的模板不是定义一个组件，而是简单地拉取用传递的URL路径呈现的任何组件。通过使用这个占位符，我们不必导出组件。相反，我们可以导出模块。</p><p id="2d89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您现在可以通过在浏览器地址栏中输入<code class="du lj lk ll lm b">http://localhost:4200</code>来查看此应用程序。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/2e161a70900b8682c85b1414cd3ccdea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*5Xtvm1kzAvsiagWW88e5KQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><p id="848e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">回顾一下，<code class="du lj lk ll lm b">HomeRoutingModule</code>是一个路由模块，我们在其中定义路由。我们有一条由空白路径组成的路线。我们将检查客户端的URL条目是否与该路径匹配。如果是，我们将通过<code class="du lj lk ll lm b">HomeMainComponent</code>加载主页。</p><p id="7341" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于一系列导入，主页组件是可用的。首先，我们将<code class="du lj lk ll lm b">home-routing</code>模块导入到它的配对标准模块<code class="du lj lk ll lm b">home</code>中。然后，我们将<code class="du lj lk ll lm b">home</code>模块导入到app模块中。最后，我们使用<code class="du lj lk ll lm b">app.component.html</code>文件中的<code class="du lj lk ll lm b">&lt;router-outlet&gt;</code>指令来加载原来的<br/> <code class="du lj lk ll lm b">routes</code>数组中注册的<code class="du lj lk ll lm b">HomeMainComponent</code>。</p><h1 id="9a29" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是通配符路由？</h1><p id="5f88" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated"><em class="me">用户输入无效路径会怎样？</em>我们可以通过包含一个<strong class="iw hj">通配符路由</strong>来避免一个错误，它捕获所有未注册的路径并将它们定向到某个页面。您可以将通配符视为“其他”类别，它与任何未注册的路径相匹配。</p><p id="c384" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大多数网站都有一个指向“404页面未找到”页面的通配符。要为我们的应用程序创建一个错误组件，请在命令提示符下输入以下内容:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="f40b" class="lv kh hi lm b fi lw lx l ly lz">ng generate component PageNotFound</span></pre><blockquote class="mb mc md"><p id="5c0c" class="iu iv me iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr hb bi translated"><em class="hi">我们不需要模块，因为这个错误屏幕只是简单的文本。</em></p></blockquote><p id="0fe4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以通过输入<code class="du lj lk ll lm b">**</code>代替<code class="du lj lk ll lm b">routes</code>数组中的标准路径来设置通配符。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="fda7" class="lv kh hi lm b fi lw lx l ly lz">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';<br/>import { PageNotFoundComponent } from './page-not-found/page-not-found.component';</span><span id="fc91" class="lv kh hi lm b fi ma lx l ly lz">const routes: Routes = [<br/>  { path: '**', component: PageNotFoundComponent }<br/>];</span><span id="232e" class="lv kh hi lm b fi ma lx l ly lz">@NgModule({<br/>  imports: [RouterModule.forRoot(routes)],<br/>  exports: [RouterModule]<br/>})<br/>export class AppRoutingModule { }</span></pre><p id="b855" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，任何无效的网址将重定向到我们的404错误页面。</p><p id="b435" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要确保这个组件是在<code class="du lj lk ll lm b">app.module.ts</code>文件中最后导入的，这样我们的其他组件才能正确加载。这是因为从第一个匹配路径角度加载元件。如果先导入<code class="du lj lk ll lm b">AppRoutingModule</code>, Angular将总是加载<code class="du lj lk ll lm b">PageNotFoundComponent</code>,因为通配符将总是作为匹配读取，因此Angular将返回该组件。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="8128" class="lv kh hi lm b fi lw lx l ly lz">imports: [<br/>    BrowserModule,<br/>    HomeModule,<br/>    AboutModule,<br/>    ContactModule,<br/>    AppRoutingModule,<br/>  ],</span></pre><p id="a7b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du lj lk ll lm b">imports</code>数组底部的通配符确保了任何有效的匹配都被返回，并且只有当没有其他匹配时才返回404。</p><h1 id="59c0" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">子路由</h1><p id="2774" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">有时，将路由分类为路由中的子组是有意义的。例如，我们的“关于我们”页面可以为员工信息、<code class="du lj lk ll lm b">/about/team</code>和过去客户信息、<code class="du lj lk ll lm b">/about/clients</code>提供单独的子页面。只有当用户在父<code class="du lj lk ll lm b">/about</code>路径上时，才会呈现子组件。</p><p id="63d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们将通过在命令提示符下输入以下内容来生成组件:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="1fa0" class="lv kh hi lm b fi lw lx l ly lz">ng generate component about/team<br/>ng generate component about/clients:</span></pre><p id="152d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们通过向<code class="du lj lk ll lm b">about-routing.module.ts</code>中的<code class="du lj lk ll lm b">about</code>路由添加一个<code class="du lj lk ll lm b">children</code>数组属性，将这些设置为“关于我们”页面的子页面。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="4577" class="lv kh hi lm b fi lw lx l ly lz">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';<br/>import { AboutMainComponent } from './about-main/about-main.component'<br/>import { BioComponent } from './bio/bio.component';<br/>import { TeamComponent } from './team/team.component';<br/>import { ClientsComponent } from './clients/clients.component';</span><span id="1fdb" class="lv kh hi lm b fi ma lx l ly lz">const routes: Routes = [<br/>  {<br/>    path: '',<br/>    component: AboutMainComponent,<br/>    children: [<br/>      { path: '', component: BioComponent },<br/>      { path: 'team', component: TeamComponent },<br/>      { path: 'clients', component: ClientsComponent },<br/>    ]<br/>  }<br/>];</span><span id="594f" class="lv kh hi lm b fi ma lx l ly lz">@NgModule({<br/>  imports: [RouterModule.forChild(routes)],<br/>  exports: [RouterModule]<br/>})<br/>export class AboutRoutingModule { }</span></pre><p id="b9ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lj lk ll lm b">children</code>数组的作用类似于<code class="du lj lk ll lm b">routes</code>数组的缩小版，具有类似格式的<code class="du lj lk ll lm b">path</code>和<code class="du lj lk ll lm b">component</code>属性。不同之处在于，子路由的路径属性被附加到它们的父路径上，这意味着您不需要写入完整的路径。</p><p id="125e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，到达<code class="du lj lk ll lm b">TeamComponent</code>的完整路径将是<code class="du lj lk ll lm b">/about/team</code>，而不仅仅是<code class="du lj lk ll lm b">'/team'</code>。</p><p id="8032" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们将用<code class="du lj lk ll lm b">&lt;router-outlet&gt;</code>更新<code class="du lj lk ll lm b">about-main.component.html</code>模板文件，让它显示<code class="du lj lk ll lm b">about</code>的任何子组件。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="a4eb" class="lv kh hi lm b fi lw lx l ly lz">&lt;h1&gt;About Page&lt;/h1&gt;</span><span id="25ad" class="lv kh hi lm b fi ma lx l ly lz">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><h1 id="8566" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">RouterLink指令</h1><p id="1ed5" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">大多数应用程序允许用户通过特定的URL和用户点击链接元素来导航。我们将需要引导添加链接。您可以使用标准的<code class="du lj lk ll lm b">href</code>属性创建链接。但是，每当页面发生变化时，就需要刷新站点和重新加载资源。</p><p id="b1c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用Angular Router的<code class="du lj lk ll lm b">routerLink</code>指令来加速加载，它利用历史API来让Angular访问您的即时浏览器历史。这意味着浏览器只需要加载每个页面一次，因为以后的访问可以显示以前加载的元素。</p><p id="4552" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了实现<code class="du lj lk ll lm b">routerLink</code>，将<code class="du lj lk ll lm b">app.component.html</code>的内容替换为:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="91ad" class="lv kh hi lm b fi lw lx l ly lz">&lt;nav class="navbar navbar-expand-md navbar-light bg-light mb-4"&gt;<br/>  &lt;a class="navbar-brand" routerLink="/"&gt;Website&lt;/a&gt;</span><span id="5afc" class="lv kh hi lm b fi ma lx l ly lz">  &lt;div class="collapse navbar-collapse"&gt;<br/>    &lt;ul class="navbar-nav mr-auto"&gt;<br/>      &lt;li class="nav-item"&gt;<br/>        &lt;a class="nav-link" routerLink="/about"&gt;About&lt;/a&gt;<br/>      &lt;/li&gt;<br/>      &lt;li class="nav-item"&gt;<br/>        &lt;a class="nav-link" routerLink="/contact"&gt;Contact&lt;/a&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/>&lt;/nav&gt;</span><span id="f5f1" class="lv kh hi lm b fi ma lx l ly lz">&lt;main class="container"&gt;<br/>  &lt;div class="card"&gt;<br/>    &lt;div class="card-body"&gt;<br/>      &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/main&gt;</span></pre><p id="cf46" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">浏览这些链接时，地址栏中的URL仍会改变，但浏览器不会在回访时刷新页面或重新加载资源。</p><h1 id="77f3" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">添加活动链接样式</h1><p id="7c70" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">基于我们新的导航链接，我们还需要一种方法来告诉用户他们当前在哪个页面。在Angular中最好的方法是使用<code class="du lj lk ll lm b">active</code>类，如果链接当前处于打开状态，它将改变链接的样式，以表明它是活动的。</p><p id="b43b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Bootstrap中，<code class="du lj lk ll lm b">active</code>类可以应用于包装在<code class="du lj lk ll lm b">&lt;a&gt;</code>元素周围的<code class="du lj lk ll lm b">&lt;li&gt;</code>元素。我们将使用Angular的<code class="du lj lk ll lm b">routerLinkActive</code>指令来实现这一点。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="72d3" class="lv kh hi lm b fi lw lx l ly lz">&lt;nav class="navbar navbar-expand-md navbar-light bg-light mb-4"&gt;<br/>  &lt;a class="navbar-brand" routerLink="/"&gt;Website&lt;/a&gt;</span><span id="6403" class="lv kh hi lm b fi ma lx l ly lz">  &lt;div class="collapse navbar-collapse"&gt;<br/>    &lt;ul class="navbar-nav mr-auto"&gt;<br/>      &lt;li class="nav-item" routerLinkActive="active"&gt;<br/>        &lt;a class="nav-link" routerLink="/about"&gt;About&lt;/a&gt;<br/>      &lt;/li&gt;<br/>      &lt;li class="nav-item" routerLinkActive="active"&gt;<br/>        &lt;a class="nav-link" routerLink="/contact"&gt;Contact&lt;/a&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/>&lt;/nav&gt;</span><span id="a44c" class="lv kh hi lm b fi ma lx l ly lz">&lt;main class="container"&gt;<br/>  &lt;div class="card"&gt;<br/>    &lt;div class="card-body"&gt;<br/>      &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/main&gt;</span></pre><p id="34a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们用<code class="du lj lk ll lm b">nav-item</code>类在<code class="du lj lk ll lm b">&lt;li&gt;</code>元素上应用指令。该指令将检查地址栏中的URL是否与<code class="du lj lk ll lm b">routerLink</code>指令中的路径匹配。</p><p id="6150" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果路径匹配，我们将把它添加到<code class="du lj lk ll lm b">active</code>类中，以改变链接文本，用较暗的文本颜色显示它是活动的。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/f24d1342ce731dba807dee8324f56f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB8IdLCypA5jjLDLNpx7Og.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><h1 id="3fb8" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">延迟加载模块</h1><p id="a269" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">我们可以通过从<strong class="iw hj">急切加载</strong>转换到<strong class="iw hj">懒惰加载</strong>来提高我们模块的性能。</p><p id="8973" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">急切加载是指浏览器被指示加载<code class="du lj lk ll lm b">app</code>模块中的所有组件，而不管它将使用哪个组件。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/b61355b44023d59b58047ff285d8ae70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTJm5SCQoHQjVcHSn7q0mQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><p id="5d61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">惰性加载将模块分成单独的文件，因此应用程序只加载当前页面渲染所需的组件。延迟加载通常是首选，因为它允许页面为每次渲染加载最少量的数据，从而加快加载速度。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/0c1b3da5a260a877b568661c9beb084f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91F7krorKFG9xQ6CKTuEQA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><p id="669e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了实现延迟加载，我们首先从<code class="du lj lk ll lm b">app.module.ts</code>中移除所有模块导入:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="d151" class="lv kh hi lm b fi lw lx l ly lz">import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';</span><span id="28fa" class="lv kh hi lm b fi ma lx l ly lz">import { AppRoutingModule } from './app-routing.module';<br/>import { AppComponent } from './app.component';<br/>import { PageNotFoundComponent } from './page-not-found/page-not-found.component';</span><span id="4fe0" class="lv kh hi lm b fi ma lx l ly lz">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    PageNotFoundComponent,<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    AppRoutingModule,<br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><p id="ee13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们仍然渴望装载<code class="du lj lk ll lm b">PageNotFoundComponent</code>，因为它重量轻，我们随时都可能需要它。</p><p id="e0dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还需要更新在<code class="du lj lk ll lm b">app-routing.module.ts</code>中找到的<code class="du lj lk ll lm b">routes</code>数组中的信息。这是在用户初始请求时发送的唯一路由模块。Angular然后可以使用这个文件来加载任何需要的未来模块。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="48a0" class="lv kh hi lm b fi lw lx l ly lz">const routes: Routes = [<br/>  { path: '', loadChildren: () =&gt; import('./home/home.module').then(m =&gt; m.HomeModule) },<br/>  { path: 'about', loadChildren: () =&gt; import('./about/about.module').then(m =&gt; m.AboutModule) },<br/>  { path: 'contact', loadChildren: () =&gt; import('./contact/contact.module').then(m =&gt; m.ContactModule) },<br/>  { path: '**', component: PageNotFoundComponent },<br/>];</span></pre><p id="8f2a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，我们没有使用component属性来告诉Angular在访问路线时加载什么组件。相反，我们使用的是<code class="du lj lk ll lm b">loadChildren</code>属性。这将告诉Angular延迟加载一个模块。我们将它设置为一个箭头函数，它将通过<code class="du lj lk ll lm b">import()</code>函数请求模块。<code class="du lj lk ll lm b">import()</code>函数返回一个承诺。我们链接了<code class="du lj lk ll lm b">then()</code>函数来处理响应。</p><p id="9fb4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些<code class="du lj lk ll lm b">loadChildren</code>路径将沿着任何先前的路径元素传递，作为后面路径的前缀。因此，我们必须将每个路由模块的<code class="du lj lk ll lm b">Routes</code>数组更新为空路径，以确保不会像<code class="du lj lk ll lm b">/about/about</code>那样重复路径名。</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="b33d" class="lv kh hi lm b fi lw lx l ly lz">{ path: '', component: AboutMainComponent }</span></pre><h1 id="2f63" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接下来学什么</h1><p id="3b3d" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">恭喜你完成了一个完全可导航的角度应用程序！路由是保持用户参与你的应用的关键，尤其是对于大型应用。但是，这只是做一个优秀的Angular app的一部分。</p><p id="1879" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一些<strong class="iw hj">更先进的概念</strong>你已经准备好在你的角度之旅中解决:</p><ul class=""><li id="370f" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">高级路由(私有路由，配对CSS样式表)</li><li id="855a" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">生命周期挂钩</li><li id="6e9b" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">模态分量</li><li id="21a0" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">证明</li><li id="418e" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">属国</li></ul><p id="5bd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="me">快乐学习！</em></p></div></div>    
</body>
</html>
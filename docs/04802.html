<html>
<head>
<title>Streaming database data to .csv file efficiently— A practical implementation using Spring Boot and HikariCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将数据库数据流式传输到。高效的csv文件——使用Spring Boot和HikariCP的实用实现</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hikaricp-multiple-connection-pools-over-single-physical-database-a1cda85fb33b?source=collection_archive---------9-----------------------#2021-07-04">https://medium.com/geekculture/hikaricp-multiple-connection-pools-over-single-physical-database-a1cda85fb33b?source=collection_archive---------9-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/bcb01b1a77bea75833624a919f180d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*iEs5ui8zUfjeQlAOA6iyDQ.png"/></div></figure><p id="f41f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章中，我将解释如何使用一个主连接池和一个辅助连接池直接从一个数据库中下载大文件。</p><p id="aeeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在此之前，我想解释一些基本的概念，并把我们的实现放在上下文中。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="ed78" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">简介</strong></h1><h2 id="aebe" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated"><strong class="ak"> <em class="ld">连接池框架- </em> HikariCP </strong></h2><p id="2612" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">在生产环境中，我们期望来自客户端的数千个并发请求，为每个请求打开和关闭数据库连接会导致数据库性能低下。</p><p id="fcb6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过汇集来自客户端的连接来解决这个问题。连接池管理器重用现有的有限连接，而不是为每个请求创建一个新连接。它避免了创建到数据库的新连接的开销。</p><p id="1279" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过简单地实现数据库连接容器，我们可以有效地节省执行大量昂贵的数据库访问的成本，从而提高数据库驱动的应用程序的整体性能。</p><blockquote class="lj lk ll"><p id="3364" class="im in lm io b ip iq ir is it iu iv iw ln iy iz ja lo jc jd je lp jg jh ji jj hb bi translated"><a class="ae lq" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">HikariCP</strong></a><strong class="io hj"/>是一个非常轻量级(大约130Kb)和闪电般快速的JDBC连接池框架，由Brett Wooldridge在2012年左右开发。<strong class="io hj"> HikariCP </strong>已经包含在<strong class="io hj">spring-boot-starter-data-JPA</strong>和<strong class="io hj">spring-boot-starter-JDBC</strong>包中。</p></blockquote><h2 id="efb3" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated"><strong class="ak"> <em class="ld">语境化</em> </strong></h2><p id="d765" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">假设您正在构建一个应用程序后端，并且需要实现:</p><ul class=""><li id="5a51" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated">核心CRUD操作。</li><li id="6f3a" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">下载—通过数据库流。</li><li id="0f77" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">执行涉及解析和插入大型<strong class="io hj">的导入操作。csv </strong>数据集。</li><li id="02a6" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">大型数据库表行上的调度任务。</li></ul><p id="5062" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑到客户机每秒钟都在通过您的应用程序并发执行事务，实现这些类型的吞吐量敏感特性而不考虑连接池的使用可能会有问题。</p><p id="6046" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你听说过<strong class="io hj"> <em class="lm">连接不可用，请求x ms后超时… </em> </strong>？</p><p id="5390" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如本文开头所述，连接池通过像<strong class="io hj"> HikariCP </strong>这样的框架进行优化，以创建、维护和交付有限数量的数据库连接，这些数据库连接应该在几毫秒内被使用并返回到池中。如果您将这些有限的连接用于长时间运行的操作，您将耗尽面临超时异常的池中的连接。</p><p id="6929" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当然，通过应用程序进行的数据库健康检查利用了这些连接，所以当您的<strong class="io hj">云基础架构</strong>中的<strong class="io hj">负载平衡器</strong>无法获得连接来检查您的应用程序和数据库是否健康时，您认为会发生什么？</p><p id="9ce4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">求救，我们正在下降。</p><h2 id="b002" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated"><strong class="ak"> <em class="ld">还是多加些人脉吧！</em> </strong></h2><p id="f461" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">请不要这样做(或者至少有意识地考虑可用的硬件)</p><p id="d342" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">仅仅为了创建新连接而创建新连接意味着高内存分配，并且需要用户名、密码和TSL规范，以便在每次创建时进行身份验证，从而导致应用程序和数据库的开销。</p><p id="cf98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">另一方面，连接的数量与数据库CPU的核心数量密切相关。</strong></p><blockquote class="lj lk ll"><p id="12b0" class="im in lm io b ip iq ir is it iu iv iw ln iy iz ja lo jc jd je lp jg jh ji jj hb bi translated">您需要一个小池，充满了等待连接的线程。</p><p id="e376" class="im in lm io b ip iq ir is it iu iv iw ln iy iz ja lo jc jd je lp jg jh ji jj hb bi translated">一篇关于池大小调整的优秀推荐文章摘录:<a class="ae lq" href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" rel="noopener ugc nofollow" target="_blank">https://github . com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a></p></blockquote><h2 id="ec77" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated"><strong class="ak"> <em class="ld">那么我们能做什么呢？</em>T15】</strong></h2><p id="f828" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">你可能认为，OLAP和OLTP的分离是你所寻求的，而且你是对的。</p><p id="4389" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，让我们想象一下，你正在一家新成立的公司工作，在这里，通过不同数据源中正确的ETL过程进行分析和事务划分是不可行的(至少在这一点上)。初创企业的现实(小的开发团队、低预算、有限的时间表、有限的资源)有时不允许我们冒这样的风险，即通过进行这样的架构重新定义，耗费时间、精力和金钱，从而危及向客户交付可见价值的实现。</p><h2 id="1b0d" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated">一个解决方案</h2><p id="e005" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">我们为什么不将操作分配到多个池中？</p><p id="a749" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们定义一个<strong class="io hj">主连接池</strong>，负责解析所有CRUD核心事务，以及一个辅助快速故障处理连接池<strong class="io hj">，我们可以调用它来执行下载、导入或调度任务等操作，模拟OLTP/OLAP分布。</strong></p><p id="d3c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您的辅助池的所有连接都耗尽了下载、导入或执行计划任务，您的主池将永远不会受到影响，您的应用程序可以保持健康和可操作，以实现其主要目的。</p><p id="8125" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您还可以为每个连接池配置不同的属性，如<strong class="io hj">超时</strong>或<strong class="io hj">事务隔离级别</strong>。</p><p id="8a19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">是的……这个实现有一个</em> <strong class="io hj"> <em class="lm">硬件资源限制</em> </strong> <em class="lm">。如上所述，我们不能只是无限地添加连接。增加</em> <strong class="io hj"> <em class="lm">处理池</em> </strong> <em class="lm">或</em> <strong class="io hj"> <em class="lm">主池</em> </strong> <em class="lm">的需求可能意味着</em> <strong class="io hj"> <em class="lm">硬件升级，需要更多的连接</em> </strong> <em class="lm">，以及</em> <strong class="io hj"> <em class="lm">更快地解析数据库进程</em> </strong> <em class="lm">，以便尽快将连接返回池</em> </p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="0de8" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">代码请……</strong></h1><blockquote class="mf"><p id="4be5" class="mg mh hi bd mi mj mk ml mm mn mo jj dx translated">GitHub资源库:<a class="ae lq" href="https://github.com/msampietro/spring-download-multiple-pools" rel="noopener ugc nofollow" target="_blank"><strong class="ak">https://GitHub . com/msampietro/spring-download-multiple-pools</strong></a></p></blockquote><p id="d444" class="pw-post-body-paragraph im in hi io b ip mp ir is it mq iv iw ix mr iz ja jb ms jd je jf mt jh ji jj hb bi translated">我们的例子是一个已知的<strong class="io hj">演员电影</strong> API(查看ERD图)。该示例的目的是在浏览器中触发一个完整的<strong class="io hj">演员列表</strong>，初始化为250k行，以及一个完整的<strong class="io hj">电影列表</strong>，初始化为550k行。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/c18f22047bafca920c3302480313ca3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*TVfTFkpS5DCiHORiCJintw.png"/></div></figure><p id="268a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">为了尽可能清晰，我们将引用类名和特定的代码片段，而不是复制和粘贴原始代码行。关于设置、项目结构和具体类的详细解释请查看repo</em><strong class="io hj"><em class="lm">readme . MD</em></strong></p><h2 id="afd4" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated">配置类别</h2><p id="32e4" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">让我们开始定义连接池配置类:</p><p id="72c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="lm">MainDatasourceConfig.java</em></strong><em class="lm">【初级】</em><strong class="io hj"><em class="lm">ProcessingDatasourceConfig.java</em></strong><em class="lm">【次级】</em></p><ul class=""><li id="8ea0" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated"><em class="lm">MainDatasourceConfig.java</em></li></ul><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="7e97" class="kp js hi na b fi ne nf l ng nh">public class <strong class="na hj">MainDatasourceConfig </strong>{...} <strong class="na hj">-&gt; THE MAIN DATASOURCE AND CONNECTION POOL</strong></span></pre><p id="faae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个类中，我们定义了主<strong class="io hj">数据源</strong>和一个全新的<strong class="io hj"> EntityManager </strong>和基于它的<strong class="io hj"> TransactionManager </strong>。</p><p id="a05a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将解释一些重要的方法。</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="100d" class="kp js hi na b fi ne nf l ng nh">protected static HikariConfig <strong class="na hj">buildHikariConfig</strong>(Map&lt;String, Object&gt; dataSourceProperties) {...}</span></pre><p id="ff86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> buildHikariConfig(…) </strong>正在手动引用<strong class="io hj"> application.properties </strong>文件属性来构建实例化数据源所需的<strong class="io hj"> HikariConfig </strong>对象。<em class="lm">(如果你愿意，你可以直接从属性文件中做同样的事情，但是我更喜欢用编程的方式。我们以后要重用这个方法)。</em></p><p id="b972" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个方法中(目前)要考虑的最重要的属性是:池名<strong class="io hj">"光-1-Main】，<em class="lm">最大连接数</em> </strong> <em class="lm">也称为</em> <strong class="io hj"> <em class="lm">最大池大小</em>，</strong>和<strong class="io hj"> <em class="lm">最小空闲连接数</em> </strong> <em class="lm"> </em>在<strong class="io hj">应用程序属性</strong>文件中相应地定义为<strong class="io hj"> 20 </strong>和<strong class="io hj"> 10 </strong></p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="5a5b" class="kp js hi na b fi ne nf l ng nh">@Primary<br/>@Bean(name = "dataSource")<br/>public DataSource <strong class="na hj">dataSource</strong>() {<br/>    var hikariConfig = <em class="lm">buildHikariConfig</em>(getDataSourceProperties());<br/>    return new HikariDataSource(hikariConfig);<br/>}</span></pre><p id="b05d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> datasource() </strong>实际上是使用定义的属性实例化datasource。</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="fab6" class="kp js hi na b fi ne nf l ng nh">@Primary<br/>@Bean(name = "entityManagerFactory")<br/>public LocalContainerEntityManagerFactoryBean <strong class="na hj">entityManagerFactory</strong>(EntityManagerFactoryBuilder builder,<br/>                                                                   @Qualifier("dataSource") DataSource dataSource) {<br/>    return builder<br/>            .dataSource(dataSource)<br/>            .packages("com.msampietro.springdownloadmultiplepools.module")<br/>            .properties(getJpaProperties())<br/>            .build();<br/>}</span></pre><p id="c3cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">EntityManager factory(…)</strong>创建关于<strong class="io hj">主数据源</strong>的<strong class="io hj"> EntityManager </strong>，并使用<strong class="io hj">扫描我们项目包的实体和存储库。包(…) </strong>构建器方法。</p><ul class=""><li id="8309" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated"><em class="lm">ProcessingDatasourceConfig.java</em></li></ul><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="1f29" class="kp js hi na b fi ne nf l ng nh">public class <strong class="na hj">ProcessingDatasourceConfig </strong>{...}<strong class="na hj"> -&gt; THE SECONDARY DATASOURCE AND FIXED CONNECTION POOL</strong></span><span id="1096" class="kp js hi na b fi ni nf l ng nh">@Bean(name = "processingDataSource")<br/>public DataSource <strong class="na hj">processingDataSource</strong>(@Qualifier("dataSourceProperties") Map&lt;String, Object&gt; dataSourcePropertiesHolder) {<br/>    Map&lt;String, Object&gt; dataSourceProperties = (Map&lt;String, Object&gt;) dataSourcePropertiesHolder.get("dataSourceProperties");<br/>    var config = MainDatasourceConfig.<em class="lm">buildHikariConfig</em>(dataSourceProperties);<br/>    <strong class="na hj">config.setMaximumPoolSize(config.getMinimumIdle());</strong><br/>    <strong class="na hj">config.setPoolName("HikariPool-Processing");</strong><br/>    config.getDataSourceProperties().remove("socketTimeout");<br/>    return new HikariDataSource(config);<br/>}</span></pre><p id="00cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">Processing data source(…)</strong>通过“data source properties”@ Bean接收与<strong class="io hj">Main</strong><strong class="io hj">data source</strong>相同的配置，但重新定义了池名以匹配“<strong class="io hj">HikariPool-Processing”</strong>和连接数。在这种情况下，如果<strong class="io hj">主池的</strong> <em class="lm">最小空闲连接数</em>等于10，那么辅助池的<em class="lm">最大连接数</em>将等于10。由于我们没有为该池指定不同的<em class="lm">最小空闲</em>，它将默认为一个<strong class="io hj">固定的</strong> <strong class="io hj">大小</strong> ( <em class="lm">最大=最小空闲</em>)</p><p id="da9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">根据您的需求，您可以为这些配置属性想到大量不同的选项和方法。这正是本例中提出的方法。</em></p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="c6e9" class="kp js hi na b fi ne nf l ng nh">@Bean(name = "processingEntityManagerFactory")<br/>public LocalContainerEntityManagerFactoryBean <strong class="na hj">processingEntityManagerFactory</strong>(EntityManagerFactoryBuilder builder,<br/>                                                                             @Qualifier("processingDataSource") DataSource processingDataSource,<br/>                                                                             @Qualifier("jpaProperties") Map&lt;String, String&gt; jpaProperties) {<br/>    return builder<br/>            .dataSource(processingDataSource)<br/>            <strong class="na hj">.persistenceUnit("processing")</strong><br/>            .packages("com.msampietro.springdownloadmultiplepools.module")<br/>            .properties(jpaProperties)<br/>            .build();<br/>}</span></pre><p id="f695" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">processing EntityManager factory(…)</strong>创建关于<strong class="io hj">辅助数据源</strong>的<strong class="io hj"> EntityManager </strong>，并使用<strong class="io hj">扫描我们项目包的相同实体和存储库。包(…) </strong>构建器方法。</p><p id="7a91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本例中的<strong class="io hj"> EntityManager </strong>使用<strong class="io hj">命名。persistenceUnit(“处理”)。</strong>在我们的服务中注入辅助EntityManager时，我们将使用这个<strong class="io hj">持久性单元</strong> <strong class="io hj">名称</strong>。</p><blockquote class="lj lk ll"><p id="6fa6" class="im in lm io b ip iq ir is it iu iv iw ln iy iz ja lo jc jd je lp jg jh ji jj hb bi translated"><strong class="io hj">澄清</strong>:由于我们不想重复实体或存储库，每个保存、更新、查找、派生查询或通过Jpa存储库执行的任何方法都将使用<strong class="io hj"> @Primary </strong> EntityManager，并连接主池。这是因为我们定义了相同的东西。包装(..)(意味着相同的实体和存储库)，并且一个比另一个优先。为了使辅助EntityManager有效，我们将在服务中的手动类型查询中显式指定该EntityManager。你可以指定一个不同的<strong class="io hj">。package </strong>扫描<strong class="io hj"> </strong>如果您愿意，指向项目结构中不同位置的存储库，重复实体和存储库，但是使用默认的Jpa存储库方法，而不必构建手动输入的查询。</p></blockquote><p id="a020" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们需要在辅助数据源配置类中添加以下配置注释:</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="9ab3" class="kp js hi na b fi ne nf l ng nh">@Configuration<br/>@PropertySource({"classpath:application.properties"})<br/>@EnableTransactionManagement<br/>@EnableJpaRepositories(entityManagerFactoryRef = <strong class="na hj">"processingEntityManagerFactory"</strong>,<br/>        transactionManagerRef = <strong class="na hj">"processingTransactionManager"</strong>,<br/>        basePackages = <strong class="na hj">"com.msampietro.springdownloadmultiplepools.module"</strong>)<br/>public class <strong class="na hj">ProcessingDatasourceConfig</strong> {...}</span></pre><p id="e153" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">在我们的主datasource配置类中我们不需要这些注释，因为Spring为EntityManager和TransactionManager使用默认的命名beans】</em></p><p id="e8cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切配置正确，我们应该在控制台中看到两个池的跟踪日志。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="er es nj"><img src="../Images/2be6a15cda22a18fcae1eaf6ae961248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-93waWmUOtkeAG_77OsqRg.png"/></div></div></figure><h2 id="bfc7" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf jb ky kz kj jf la lb kn lc bi translated">下载课程</h2><ul class=""><li id="4dcb" class="lr ls hi io b ip le it lf ix no jb np jf nq jj lw lx ly lz bi translated"><em class="lm">CSVWriterWrapper.java</em></li></ul><p id="fc4a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个类只是为这个例子选择的CSV lib的一个抽象(<a class="ae lq" href="https://github.com/uniVocity/univocity-parsers" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> univocity解析器</strong> </a> <strong class="io hj"> - &gt; </strong>强烈推荐！)你可以通过包装器使用任何你想要的csv库。</p><ul class=""><li id="45b6" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated"><em class="lm">BaseExportService.java</em></li></ul><p id="61b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">BaseExportService 是一个抽象类，它基于选择列表构建类型化查询，并使用CSVWriterWrapper将查询结果直接传输到OutputStream。每个实现类(<strong class="io hj"> ActorExportServiceImpl </strong>和<strong class="io hj"> MovieExportServiceImpl </strong>)负责定义文件头、查询选择和结果关联。</p><p id="586a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们解释一下神奇之处的基本方法:</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="df45" class="kp js hi na b fi ne nf l ng nh">@Transactional(value = "processingTransactionManager", propagation = Propagation.<em class="lm">NOT_SUPPORTED</em>)<br/>@Override<br/>public void <strong class="na hj">exportStreamToCsv</strong>(OutputStream outputStream) {<br/>    <em class="lm">log</em>.info("({}) - HikariPool-Processing Idle Connections before exportStreamToCsv: {}", this.getClass(),<br/>            this.getProcessingDataSourcePoolMetadata().getIdle());<br/>    var start = Instant.<em class="lm">now</em>();<br/>    <strong class="na hj">boolean autoCommit = getCurrentSessionAutoCommitPropertyAndSetFalse()</strong>;<br/>    <strong class="na hj">boolean readOnly = getCurrentSessionReadOnlyPropertyAndSetTrue()</strong>;<br/>    TypedQuery&lt;Tuple&gt; typedQuery = <strong class="na hj">buildTypedQuery()</strong>;<br/>    try (var csvWriter = new CSVWriterWrapper(outputStream);<br/>         Stream&lt;Tuple&gt; streamData = typedQuery.getResultStream()) {<br/>        <em class="lm">log</em>.info("({}) - HikariPool-Processing Idle Connections during exportStreamToCsv: {}", this.getClass(),<br/>                this.getProcessingDataSourcePoolMetadata().getIdle());<br/>        csvWriter.writeNext(headerNames);<br/>        streamData.forEach(d -&gt; <strong class="na hj">csvWriter.writeNext(this.toStringArray(d)))</strong>;<br/>        csvWriter.flush();<br/>    }<br/>    <strong class="na hj">restoreAutoCommitAndReadOnly(autoCommit, readOnly)</strong>;<br/>    var end = Instant.<em class="lm">now</em>();<br/>    <em class="lm">log</em>.info("({}) - Download processed in {} seconds", this.getClass(), Duration.<em class="lm">between</em>(start, end).toSeconds());<br/>}</span></pre><ol class=""><li id="f252" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj nr lx ly lz bi translated">首先，我们明确地使用@Transactional注释获得一个会话，引用辅助TransactionManager(还记得ProcessingDatasourceConfig.java类)而不传播。</li><li id="b454" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj nr lx ly lz bi translated">接下来要做的是获取当前会话的<strong class="io hj"> <em class="lm">自动提交</em> </strong> <em class="lm"> </em>和<strong class="io hj"> <em class="lm">只读</em> </strong>属性，并将它们设置为所需的值。为了成功地传输数据，我们需要指定一个<strong class="io hj"> FETCH_SIZE </strong>提示<strong class="io hj"> </strong>，该提示需要<em class="lm">自动提交</em>为<strong class="io hj">假</strong>并且<em class="lm">只读</em>为<strong class="io hj">真</strong>。</li><li id="c840" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj nr lx ly lz bi translated">下一步是构建类型化查询，并使用我们的CSVWriterWrapper将结果(基于每个实现)直接传输到OutputStream。</li><li id="7cd7" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj nr lx ly lz bi translated">最后，作为安全预防措施，我们将自动提交<strong class="io hj">和只读<strong class="io hj">恢复到它们的初始值。</strong></strong></li></ol><p id="fa51" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们放大一下<strong class="io hj"> buildTypedQuery() </strong>方法:</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="6b2b" class="kp js hi na b fi ne nf l ng nh">private TypedQuery&lt;Tuple&gt; <strong class="na hj">buildTypedQuery()</strong> {<br/>    var builder = this.getProcessingEntityManager().getCriteriaBuilder();<br/>    CriteriaQuery&lt;Tuple&gt; query = builder.createTupleQuery();<br/>    Root&lt;T&gt; root = query.from(modelType);<br/>    query.multiselect(<strong class="na hj">this.buildSelections</strong>(root, query, builder));<br/>    if (<strong class="na hj">this.getSort()</strong> != null &amp;&amp; this.getSort().isSorted())<br/>        query.orderBy(<em class="lm">toOrders</em>(sort, root, builder));<br/>    TypedQuery&lt;Tuple&gt; typedQuery = <strong class="na hj">this.getProcessingEntityManager().createQuery(query);</strong><br/>    Map&lt;String, Object&gt; queryHints = <strong class="na hj">buildQueryHints()</strong>;<br/>    queryHints.forEach(typedQuery::setHint);<br/>    return typedQuery;<br/>}</span></pre><p id="d5c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了设置实现类选择列表(<strong class="io hj">this . build selections(…)</strong>)和order ( <strong class="io hj"> this.getSort(…) </strong>)之外，该方法还使用类中注入的辅助<strong class="io hj">持久性单元</strong>有效地创建了类型化查询(还记得我们在辅助实体管理器中建立持久性单元名称的时候吗)</p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="1ed8" class="kp js hi na b fi ne nf l ng nh">@PersistenceContext(<strong class="na hj">unitName = "processing"</strong>)<br/>private EntityManager <strong class="na hj">processingEntityManager</strong>;</span></pre><p id="53d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后它调用<strong class="io hj"> buildQueryHints() </strong></p><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="dc21" class="kp js hi na b fi ne nf l ng nh"><em class="lm">/**<br/> * HINT_FETCH_SIZE ignored if autoCommit = true.<br/> * If pool autoCommit is true then it should be disabled for method execution<br/> **/<br/></em>private Map&lt;String, Object&gt; <strong class="na hj">buildQueryHints()</strong> {<br/>    Map&lt;String, Object&gt; queryHints = new HashMap&lt;&gt;();<br/>    queryHints.put(<em class="lm">HINT_FETCH_SIZE</em>, "5000");<br/>    queryHints.put(<em class="lm">HINT_READONLY</em>, "true");<br/>    queryHints.put(<em class="lm">HINT_CACHEABLE</em>, "true");<br/>    return queryHints;<br/>}</span></pre><p id="8d44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这设置了<strong class="io hj"> FETCH_SIZE </strong>、<strong class="io hj"> READONLY </strong>和<strong class="io hj"> CACHEABLE </strong>所需的提示，以实现来自db的高效数据流。</p><p id="f53a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，触发下载的控制器端点:</p><ul class=""><li id="2e82" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated">【ActorController.java T42】</li></ul><pre class="mv mw mx my fd mz na nb nc aw nd bi"><span id="e9ac" class="kp js hi na b fi ne nf l ng nh">@GetMapping(value = "/data")<br/>public ResponseEntity&lt;StreamingResponseBody&gt; <strong class="na hj">getData</strong>(HttpServletResponse response) {<br/>    response.setCharacterEncoding(StandardCharsets.<em class="lm">UTF_8</em>.name());<br/>    response.setHeader(HttpHeaders.<em class="lm">CONTENT_TYPE</em>, "application/octet-stream");<br/>    response.setHeader(HttpHeaders.<em class="lm">CONTENT_DISPOSITION</em>, "attachment; filename=actors_export.csv");<br/>  <strong class="na hj">  StreamingResponseBody stream = actorExportService::exportStreamToCsv;</strong><br/>    return ResponseEntity.<em class="lm">ok</em>(stream);<br/>}</span></pre><p id="88bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">get data(http servlet response)</strong>方法使用Spring<strong class="io hj">steaming response body</strong>将其OutputStream传递给我们的BaseExportService<strong class="io hj">exportToCsv(output stream output stream)</strong>方法。它还设置了一些必需的响应头。</p><p id="4487" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在使用<a class="ae lq" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/StreamingResponseBody.html" rel="noopener ugc nofollow" target="_blank"> StreamingResponseBody </a>时，我推荐你配置Spring中使用的<a class="ae lq" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/task/TaskExecutor.html" rel="noopener ugc nofollow" target="_blank"> TaskExecutor </a>进行异步请求处理。看一看<strong class="io hj"> application.properties </strong>任务执行器配置部分。</p><p id="1a54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以开始下载了！</p><p id="3310" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从浏览器调用<a class="ae lq" href="http://localhost:8080/movies/data" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">http://localhost:8080/movies/data</strong></a>或<a class="ae lq" href="http://localhost:8080/movies/data" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">http://localhost:8080/actors/data</strong></a><strong class="io hj"/>。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="er es ns"><img src="../Images/fc2cfa417bbd1b9db30b80bc25a432ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUdPl-M_-mhGJ2QhKrCSYw.png"/></div></div></figure><p id="91b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以在控制台日志中确认，在执行查询之前，我们在辅助池中有<strong class="io hj"> 10 </strong>个空闲连接，在下载过程中有<strong class="io hj"> 9 </strong>个空闲连接。</p><p id="efb4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是这样！</p><p id="05db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望你喜欢:)</p><p id="7f42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">特别感谢</em> <a class="nt nu ge" href="https://medium.com/u/29e8ecba5ba1?source=post_page-----a1cda85fb33b--------------------------------" rel="noopener" target="_blank"> <em class="lm">萨尔瓦多</em> </a> <em class="lm">对文章的修改。</em></p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="7253" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">贮藏室ˌ仓库</h1><div class="nv nw ez fb nx ny"><a href="https://github.com/msampietro/spring-download-multiple-pools" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">msampietro/spring-下载-多池</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">将数据库数据流式传输到。高效的csv文件——使用Spring Boot和HikariCP Post的实用实现…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ik ny"/></div></div></a></div><h1 id="0538" class="jr js hi bd jt ju on jw jx jy oo ka kb kc op ke kf kg oq ki kj kk or km kn ko bi translated">参考资料和有趣的文章</h1><div class="nv nw ez fb nx ny"><a href="https://stackoverflow.blog/2020/10/14/improve-database-performance-with-connection-pooling/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">使用连接池提高数据库性能-堆栈溢出博客</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">我们倾向于依靠缓存解决方案来提高数据库性能。在内存中缓存频繁访问的查询或…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">stackoverflow.blog</p></div></div><div class="oh l"><div class="os l oj ok ol oh om ik ny"/></div></div></a></div><div class="nv nw ez fb nx ny"><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">brettwood ridge/hikar ICP</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">配置连接池是开发人员经常犯的错误。有几个，可能…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">github.com</p></div></div><div class="oh l"><div class="ot l oj ok ol oh om ik ny"/></div></div></a></div><div class="nv nw ez fb nx ny"><a href="https://dzone.com/articles/database-connection-pooling-in-java-with-hikaricp" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">用HikariCP - DZone Java实现Java中的数据库连接池</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">连接池是一种技术，用于提高具有动态数据库驱动内容的应用程序的性能…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">dzone.com</p></div></div><div class="oh l"><div class="ou l oj ok ol oh om ik ny"/></div></div></a></div><h1 id="9237" class="jr js hi bd jt ju on jw jx jy oo ka kb kc op ke kf kg oq ki kj kk or km kn ko bi translated">联系信息</h1><div class="nv nw ez fb nx ny"><a href="https://www.linkedin.com/in/sampietromartin" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">Martin Sampietro -阿根廷|职业简介| LinkedIn</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">查看Martin Sampietro在LinkedIn(全球最大的职业社区)上的个人资料。马丁有2份工作列在…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">www.linkedin.com</p></div></div><div class="oh l"><div class="ov l oj ok ol oh om ik ny"/></div></div></a></div><p id="259f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">电子邮件:<strong class="io hj">sampietromartin1@gmail.com</strong></p></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding Services and Dependency Injection in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Angular中的服务和依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-services-and-dependency-injection-in-angular-175a5c893dcc?source=collection_archive---------6-----------------------#2022-05-20">https://medium.com/geekculture/understanding-services-and-dependency-injection-in-angular-175a5c893dcc?source=collection_archive---------6-----------------------#2022-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2c81" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">服务和依赖注入是如何工作的？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/74a2ccfedaf6d0c63f15e25bfac501d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xlY-Lm6Eg9kHLBQb.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Services and Dependency Injection</strong> in Angular (image taken from w3reign.com)</figcaption></figure><p id="7bbf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated">ngular将组件与服务区分开来，以增加模块化和可重用性。通过将组件的视图相关功能与其他类型的处理分离开来，可以使组件类精简高效。</p><p id="a9a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当组件之间的距离很大时，有时在组件之间共享数据变得非常复杂，因为有了<em class="kt">输入、输出和事件发射器</em>。因此，我们使用<strong class="jq hj">服务以优雅的方式管理这种跨组件通信</strong>。</p><p id="5764" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Angular基于<code class="du ku kv kw kx b">@Injectable</code>装饰器将类解释为服务。我们还必须在Angular的提供者中定义我们的服务，以便开始使用依赖注入或DI的概念。</p><p id="1fcf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以在组件本身上提供服务，然后该组件将为该特定组件及其子组件提供该服务的<em class="kt">相同实例，直到在子组件中被再次定义和覆盖。</em></p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="ab3b" class="lc ld hi kx b fi le lf l lg lh">@Component({<br/> selector: 'app-root',<br/> templateUrl: './app.component.html',<br/> styleUrls: ['./app.component.css'],<br/> <strong class="kx hj">providers: [AccountsService]</strong><br/>})</span></pre><p id="ef16" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一种方法是在<strong class="jq hj"> app.module.ts </strong>中的提供者数组中定义它，以便该服务的<strong class="jq hj">全局实例在整个应用程序</strong>中可用，直到在组件中被再次定义和覆盖。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="a69c" class="lc ld hi kx b fi le lf l lg lh">@NgModule({<br/>...<br/>imports: [...],<br/><strong class="kx hj">providers: [AccountsService],</strong><br/>...<br/>})</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="9f3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们深入研究服务之前，让我们<strong class="jq hj">理解依赖注入</strong>(简称DI)。</p><p id="507f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据角度文件:</p><blockquote class="lp lq lr"><p id="c186" class="jo jp kt jq b jr js ij jt ju jv im jw ls jy jz ka lt kc kd ke lu kg kh ki kj hb bi translated">依赖项是类执行其功能所需的服务或对象。依赖注入，或称DI，是一种设计模式，在这种模式中，类从外部源请求依赖，而不是创建它们。</p></blockquote><p id="3ee3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Angular的DI框架在实例化时提供了对类的依赖。使用Angular DI增加应用程序的灵活性和模块化。</p><p id="22c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">服务可以向组件树中的任何注入器注册。您将服务作为提供者插入到<code class="du ku kv kw kx b">@Component</code>元数据字段:<code class="du ku kv kw kx b">providers: []</code>。该服务可用于组件及其子组件。</p><p id="f6fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一种方式是，<code class="du ku kv kw kx b">providers: []</code>元数据作为它自己的字段存在于<code class="du ku kv kw kx b">@NgModule</code>装饰器中。从模块到底层组件树，服务都是可实例化的。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="ef70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们试着用一个例子来理解服务和DI的使用。</p><p id="8f60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是我们的应用程序的屏幕截图，显示了一个添加用户活动帐户的表单，该帐户由用户名和活动组成。</p><p id="aec7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">UserActivity类如下所示:</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="d81d" class="lc ld hi kx b fi le lf l lg lh">export class UserActivity{</span><span id="76d5" class="lc ld hi kx b fi lv lf l lg lh">username: string;<br/>activity: string;</span><span id="5133" class="lc ld hi kx b fi lv lf l lg lh">constructor(name, status) {<br/> this.username = name;<br/> this.activity = status;<br/>}</span><span id="641a" class="lc ld hi kx b fi lv lf l lg lh">}</span></pre><p id="ac77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">输入信息并触发“添加帐户”按钮的(单击)事件后，用户活动将被添加到下面的列表中(默认情况下，列表中保留2个用户活动)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/302b89398300ee19077511cbe5b90a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DadJ9J8ossqSY2V_Qly0QQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Screenshot of the Running application</figcaption></figure><p id="d37e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">应用程序的细分:1个根应用程序组件，1个用于插入新表单信息和按钮的新帐户组件，以及1个用于显示用户活动列表的帐户组件。</p><p id="564f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们观察，在新帐户组件中输入信息时，我们需要将其传递给它的兄弟帐户组件。这一切都可以在不使用服务的情况下实现，但这将需要大量的处理和数据传输，就像我们需要存储新的用户信息，然后在单击按钮时通过事件发射器发出相同的信息。该事件将到达父应用程序组件，该组件被进一步订阅、存储并作为属性传递给它的另一个子ie。帐户组件。account组件将在其中存储并显示这些新数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/f4c8ed84a9150db0b743b3b59f863e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPOQC9kNccJ6bpOkB6-Ydw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Running the application with a new user activity added via service</figcaption></figure><p id="0ac4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们创建一个服务(比如AccountsService)并让它作为管理用户活动列表和将新用户活动推送到现有列表的逻辑的中心位置，那么所有这些数据传输、本地对象的创建、事件发射器和方法都可以减少。</p><p id="9ca1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在下面的代码中，我们所要做的就是创建一个类AccountsService。可注射装饰师，定义与否由你自己决定。通常，当您将一个服务注入到另一个服务中时，会使用它，但是Angular按照惯例建议在所有服务上使用它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/3ac58d0d0bae91fb790da9259cc3f9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abbDrMkvsOIWv9N49ES14A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Service logic with the userActivityList and pushing new user activity method</figcaption></figure><p id="6ef2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我已经在app.module.ts提供程序中声明了我的服务。现在，在任何组件的构造函数中，我可以按照DI的概念直接注入我的服务的实例，如上所述。</p><p id="c67e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们可以通过调用服务addUserActivity()来推送新的用户帐户，并通过单击按钮来传递数据，该按钮的(click)事件绑定到onCreateAccount()。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/042bcbbf77659c43c05aa7f6dc0adfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1Db2TiyNkQdD2o3EQHfXw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Dependency Injection (DI) of service in a component to call its method</figcaption></figure><p id="3a12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，在根AppComponent中，我们再次注入我们的服务，并将userActivity列表存储在一个本地属性中，该属性被传递给account组件，该组件进一步显示用户活动列表。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/a04fa452c13ad1884066fffd5a23504d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIzx2vYgjm-I4JeYOX6arw.png"/></div></div></figure><p id="6803" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用ngFor指令遍历本地userActivity列表，并将每个项目的信息进一步传递给account组件，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/a1c33399932b59c8ec29ad0e4c74f62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raMOIMw-YfA-4AbA5VcfVA.png"/></div></div></figure><p id="a498" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，在account组件中，我们可以绑定account和id，我们可以使用字符串插值将它们进一步绑定到HTML。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="5218" class="lc ld hi kx b fi le lf l lg lh">import { Component, Input } from '@angular/core';<br/>import { UserActivity } from '../model/useractivity.model';</span><span id="255c" class="lc ld hi kx b fi lv lf l lg lh">@Component({<br/> selector: 'app-account',<br/> templateUrl: './account.component.html',<br/> styleUrls: ['./account.component.css']<br/>})<br/>export class AccountComponent {</span><span id="0d04" class="lc ld hi kx b fi lv lf l lg lh">@Input() account: UserActivity;<br/>@Input() id: number;</span><span id="d466" class="lc ld hi kx b fi lv lf l lg lh">constructor() {}</span><span id="fffe" class="lc ld hi kx b fi lv lf l lg lh">}</span></pre></div></div>    
</body>
</html>
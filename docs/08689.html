<html>
<head>
<title>Filter Architecture In Your Front-end Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端项目中的过滤器架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/filter-architecture-in-your-front-end-project-7e4d3d7ee957?source=collection_archive---------11-----------------------#2021-11-10">https://medium.com/geekculture/filter-architecture-in-your-front-end-project-7e4d3d7ee957?source=collection_archive---------11-----------------------#2021-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/734c3fdcebb457f8c32f60b1469e01f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOO04G24d1YU0zzZnmkGOQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@weareambitious?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ambitious Creative Co. — Rick Barrett</a> on <a class="ae iu" href="https://unsplash.com/s/photos/net?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="53e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您从事一个中型到大型的项目时，您可能需要处理许多API请求和响应。您向后端服务器发送请求体，服务器返回响应。这是一种非常常见的获取数据的方式。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/2e892900bcf41dd30677866a0530ad3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5rt6NhcEo_0aIy0xap_KQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Normal Fetching Process</figcaption></figure><p id="416f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此过程中，有时您会注意到返回的响应可能包含不必要的数据，并且数据格式与您的前端项目标准不兼容或不一致。例如，不匹配的参数键、不同的命名约定、不同的对象格式等。而所有这些“未经过滤”的数据将成为一个无意的罪魁祸首，创造错误，增加你的技术债务。</p><p id="ffe7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，通常您会花时间不断调试和修复它，直到您的组件正确显示响应。但是，你想过为什么吗？为什么所有这些bug都会发生？为什么你一直在处理这件事？</p><p id="9a96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在前端项目中已经有了一套代码标准，就意味着您有了一个遵循指南。您可以防止API响应弄乱您的代码。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/6e24ee597281921de3771d1467d752d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3X6ay784N5-nQUiECowbQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Aigues-Mortes city walls, France</figcaption></figure><p id="b6a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，想象你是这片土地的主人，你在城市的门口设置了一个检查站。你需要知道谁在穿过这个城市，他们只有在特定的权利和许可下才能进来。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/e261b494839b032208bff703886edfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qF59S9T1zCRgrAjTPKNHg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Filtered Fetching Process</figcaption></figure><p id="688a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，这里来了<strong class="ix hj">滤波器架构</strong>。它作为一个<strong class="ix hj">中间网络</strong>，停留在请求&amp;获取API响应的进程之间。基本上，您将修改您的请求和响应主体，也可以在数据获取过程中将其称为<strong class="ix hj"> <em class="ka">有效负载、</em> </strong>。</p><p id="cae1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当服务器返回响应数据时，您将根据您的要求过滤原始API数据。之后，将格式化的数据存储到Redux或项目上的任何其他状态管理位置。</p><blockquote class="kb kc kd"><p id="7ff8" class="iv iw ka ix b iy iz ja jb jc jd je jf ke jh ji jj kf jl jm jn kg jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">提醒一下，保存前过滤一下。</em>T13】</strong></p></blockquote><p id="a23e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，您使用<code class="du kh ki kj kk b">camelCase</code>作为前端负载的键，但是后端接收<code class="du kh ki kj kk b">snack_case</code>作为键。然后，在这种情况下，您将通过重命名键来格式化您的有效负载，以便符合后端要求。您可以考虑创建一个全局函数来执行这种逻辑变化。反之亦然，这同样适用于返回的API响应。您可以转换响应中的键名，使其与您的前端标准相匹配。因此，您的前端代码将始终保持其标准，以获得更好的可维护性，更容易调试&amp;更少的错误。</p><p id="9d43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，当您收到API返回的响应时，您还可以过滤掉不必要的数据。例如，您有一个由多个卡片组成的部分，这些卡片在您的页面中显示图书信息。每张卡片只显示书的名字、封面、作者和出版商。但是，API会返回冗余信息，如服务bean、作者注释、出版商注释等。所有这些不需要的信息都可以过滤掉，并在传递给你的卡组件之前重新格式化。</p><h2 id="b944" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">过滤技巧</h2><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/4a376a27ed0b7c5783df9e2e1fd223c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKAaoAMlFtMawJYMe4IXNw.jpeg"/></div></div></figure><p id="fd3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以图书信息<em class="ka">(上面提到的)</em>为演示案例。下面是使用<code class="du kh ki kj kk b">map()</code>重命名键并删除book数组<em class="ka"> </em>中不需要的数据的示例:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/795ecefdd359062837ed27ec11f3a5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BYgtuE8JAr9qqcF-K0igbQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Visual Studio Code | <a class="ae iu" href="https://marketplace.visualstudio.com/items?itemName=AyakoSky.fluffy-theme" rel="noopener ugc nofollow" target="_blank">Fluffy Theme</a></figcaption></figure><p id="1b36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，您可以看到我只获取了卡组件所需的数据。然后，我使用<code class="du kh ki kj kk b">get()</code>从原始数组中检索值。下面是<code class="du kh ki kj kk b">get()</code>的工作原理:</p><pre class="ju jv jw jx fd li kk lj lk aw ll bi"><span id="2d41" class="kl km hi kk b fi lm ln l lo lp">get(object, 'your object path, can be nested one', 'fallback value')</span></pre><p id="482b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果API数据在上面的任何键中传回空值，它将使用我默认分配的回退值。我在这里分配了一个空字符串。您可以根据需要指定任何默认的回退值。如果你明智地使用，这种方法有助于减少错误。更多信息可以阅读<a class="ae iu" href="https://lodash.com/docs/4.17.15#get" rel="noopener ugc nofollow" target="_blank"> Lodash </a>的官方文档。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/be4b19806ff9a4413813bf33c8878f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F0m0SVSAwWzrok8rIAW9Q.png"/></div></div></figure><p id="b896" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！如果你觉得这篇文章有帮助，请给我一些掌声！编码快乐&amp;干杯！</p></div></div>    
</body>
</html>
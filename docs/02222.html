<html>
<head>
<title>Refactoring your Component with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子重构你的组件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/refactoring-your-component-with-react-hooks-563fa7311f29?source=collection_archive---------19-----------------------#2021-05-07">https://medium.com/geekculture/refactoring-your-component-with-react-hooks-563fa7311f29?source=collection_archive---------19-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6f6f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">以及如何用钩子替换setState的第二个参数</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/de56872e57c93425939655b019097e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qE6hiSxc33z7IhZW1AcqbQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">React hooks allow you to mimic the behavior provided by class components</figcaption></figure><h1 id="cd75" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">使用状态</h1><p id="05b9" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">useState钩子做的和它听起来一样。它允许您在功能组件中使用使用状态。让我们看看在一个类组件中通常是如何做到这一点的，然后使用useState钩子对一个功能组件进行修改。</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="50e2" class="lg jo hi lc b fi lh li l lj lk">import React from 'react'</span><span id="21cf" class="lg jo hi lc b fi ll li l lj lk">class MyComponent extends React.Component<br/>  constructor(props) {<br/>    super(props);    <br/>   <strong class="lc hj"> this.state = {      <br/>      name: "",<br/>      email: """,<br/>      student: false,<br/>    };</strong></span><span id="24b4" class="lg jo hi lc b fi ll li l lj lk">  render() {<br/>    return (<br/>      &lt;form&gt;<br/>        {Some JSX Code Here}<br/>      &lt;/form&gt;<br/>    )<br/>  }</span><span id="00fb" class="lg jo hi lc b fi ll li l lj lk">export default MyComponent</span></pre><p id="3ee1" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">通常当在一个类组件中创建状态时，你使用构造函数，然后使用this.state声明一个状态对象。在这个对象中，你定义一些你想存储在状态中的属性。在这种情况下，我们将拥有firstName、lastName和editingName属性。</p><p id="376d" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">当您想在React中更新状态时，可以使用React提供的setState函数。下面一个更复杂的组件展示了这是如何正常工作的。</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="4c19" class="lg jo hi lc b fi lh li l lj lk">import React from 'react'</span><span id="739e" class="lg jo hi lc b fi ll li l lj lk">class MyComponent extends React.Component<br/>  constructor(props) {<br/>    super(props);    <br/>    this.state = {      <br/>      name: "",<br/>      email: """,<br/>      studentStatus: false,<br/>    };</span><span id="c933" class="lg jo hi lc b fi ll li l lj lk">    handleChange(event) {<br/>        event.preventDefault();<br/>        let name = event.target.name;<br/>        let value = event.target.value;<br/><br/>        <strong class="lc hj">this.setState({name: value})</strong><br/>    }<br/><br/>    handleSubmit(event) {<br/>        event.preventDefault();<br/>        console.log(this.state);<br/>    }</span><span id="78c6" class="lg jo hi lc b fi ll li l lj lk">render(){<br/>  return (<br/>    &lt;form onSubmit={this.handleSubmit}&gt;<br/>      &lt;label&gt; Name:<br/>      &lt;input type="text" name="name" value={this.state.name} onChange={this.handleChange)} /&gt;<br/>      &lt;/label&gt;<br/>      &lt;label&gt;Email:<br/>      &lt;input type="text" name="email" value={this.state.email} onChange={this.handleChange}/&gt;<br/>      &lt;/label&gt;&lt;br /&gt;<br/>      &lt;input className="btn" type="submit" value="Submit" /&gt;<br/>     &lt;/form&gt;<br/>    )<br/>  }</span><span id="3e9d" class="lg jo hi lc b fi ll li l lj lk">export default MyComponent</span></pre><p id="9eeb" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">上面的代码将在您使用onChange函数键入时更新state中相应的值。然后，当提交时，它会将您的更新状态的所有值记录到控制台。很简单。</p><p id="f8c9" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">现在让我们把这个组件修改成一个使用useState钩子的功能组件。</p><p id="f968" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">首先，我们需要从“react”导入useState</p><p id="c32f" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">然后，用useState的析构替换构造函数。useState函数返回一个包含2个元素的数组。第一个元素是当前状态，第二个是用于更新第一个状态值的函数。您可以随意称呼它们，但是您将看到的一般语法是['variableName '，' setVariableName']。我们将在这里使用该语法。你也可以传递一个参数给useState，无论你传递什么，数组中的第一个值将被初始化为等于那个值。</p><p id="c3af" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">例如，如果您说“[count，setCount] = useState(10)”，您将获得一个名为count的状态变量，它将被设置为等于10。然后，您可以使用setCount来更新状态，如下所示:“setCount(count + 1)”，每次调用它时，计数都会增加1。</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="ad83" class="lg jo hi lc b fi lh li l lj lk">import React, <strong class="lc hj">{useState}</strong> from 'react'</span><span id="8c2e" class="lg jo hi lc b fi ll li l lj lk"><strong class="lc hj">const MyComponent = () =&gt; {</strong><br/>     <br/><strong class="lc hj">   [name, setName] = useState("")<br/>   [email, setEmail] = useState("")<br/>   [studentStatus, setStudentStatus] = useState(false)</strong></span><span id="8c14" class="lg jo hi lc b fi ll li l lj lk">     fCh(event) { &lt;-- shortened to fit(usually called changeHandler)<br/>        event.preventDefault();<br/>        let name = event.target.name;<br/>        let value = event.target.value;</span><span id="f6b5" class="lg jo hi lc b fi ll li l lj lk"><br/>       <strong class="lc hj"> if (name === 'name'){<br/>           setName(value)<br/>        } else {<br/>           setEmail(value)<br/>        }</strong></span><span id="8168" class="lg jo hi lc b fi ll li l lj lk">    }<br/><br/>    handleSubmit(event) {<br/>        event.preventDefault();<br/>        console.log(this.state);<br/>    }</span><span id="d7c2" class="lg jo hi lc b fi ll li l lj lk">render(){<br/>  return (<br/>    &lt;form onSubmit={handleSubmit}&gt;<br/>      &lt;label&gt; Name:<br/>      &lt;input type="text" name="name" value={name} onChange={fCh)}/&gt;<br/>      &lt;/label&gt;<br/>      &lt;label&gt;Email:<br/>      &lt;input type="text" name="email" value={email} onChange={fCh}/&gt;<br/>      &lt;/label&gt;&lt;br /&gt;<br/>      &lt;input className="btn" type="submit" value="Submit" /&gt;<br/>     &lt;/form&gt;<br/>    )<br/>  }</span><span id="8af9" class="lg jo hi lc b fi ll li l lj lk">export default MyComponent</span></pre><p id="3299" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">您会注意到，现在我们有3个离散变量来表示状态中的每个值，并且我们有3个独立的函数来更新每个值，而不是将状态中的所有值都存储在一个对象中，然后使用setState来更新。有很多方法可以设置它，使得每个值仍然包含在一个对象中，并且只有一个函数更新每个值，但是对于初学者来说，我认为用我上面的方法将它分开会更清楚。</p><h1 id="aab2" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">使用效果</h1><p id="b6d6" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">useEffect钩子是我们如何模仿React类组件的生命周期方法的。默认情况下，每个使用效果将在组件首次呈现后运行，然后在组件的每次更新或更改后再次运行。(如果这听起来很像componentDidMount和componentDidUpdate，那你就对了！)</p><p id="5ba7" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">我们在组件内部定义了useEffect挂钩，这样它就可以访问我们需要的状态变量。</p><p id="54df" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">假设我们想要显示一些依赖于状态的信息，但是要在组件呈现出来之后。在我们的旧类组件中，我们将这样处理它:</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="7bc7" class="lg jo hi lc b fi lh li l lj lk">import React from 'react'</span><span id="9257" class="lg jo hi lc b fi ll li l lj lk">class MyComponent extends React.Component<br/>  constructor(props) {<br/>    super(props);    <br/>    this.state = {      <br/>      name: "",<br/>      email: """,<br/>      studentStatus: false,<br/>    };</span><span id="481e" class="lg jo hi lc b fi ll li l lj lk">handleChange(event) {<br/>        event.preventDefault();<br/>        let name = event.target.name;<br/>        let value = event.target.value;<br/><br/>        this.setState({name: value})<strong class="lc hj"><br/></strong>    }<br/><br/>    handleSubmit(event) {<br/>        event.preventDefault();<br/>        console.log(this.state);<br/>    }</span><span id="570f" class="lg jo hi lc b fi ll li l lj lk">render(){<br/>  return (<br/>&lt;div&gt;<br/>  <strong class="lc hj">&lt;h1&gt; {document.title} &lt;/h1&gt;</strong><br/>    &lt;form onSubmit={this.handleSubmit}&gt;<br/>      &lt;label&gt; Name:<br/>      &lt;input type="text" name="name" value={this.state.name} onChange={this.handleChange)} /&gt;<br/>      &lt;/label&gt;<br/>      &lt;label&gt;Email:<br/>      &lt;input type="text" name="email" value={this.state.email} onChange={this.handleChange}/&gt;<br/>      &lt;/label&gt;&lt;br /&gt;<br/>      &lt;input className="btn" type="submit" value="Submit" /&gt;<br/>     &lt;/form&gt;<br/>    )<br/>  }</span><span id="e135" class="lg jo hi lc b fi ll li l lj lk"><strong class="lc hj">componentDidMount(){<br/>  document.title = `{name}'s Profile`<br/>}</strong></span><span id="e0f0" class="lg jo hi lc b fi ll li l lj lk">export default MyComponent</span></pre><p id="a0b3" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">这是一个很傻的例子，因为我们可以用state，但是主体是一样的。当组件挂载时，componentDidMount将使用从state获取的信息设置文档的标题。</p><p id="c22b" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">如果您想在您的功能组件中模仿这种行为，您只需使用useEffect。</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="b8ff" class="lg jo hi lc b fi lh li l lj lk">import React, {useState, <strong class="lc hj">useEffect</strong>} from 'react'</span><span id="3068" class="lg jo hi lc b fi ll li l lj lk">const MyComponent = () =&gt; {<br/>     <br/>   [name, setName] = useState("")<br/>   [email, setEmail] = useState("")<br/>   [studentStatus, setStudentStatus] = useState(false)</span><span id="3b8c" class="lg jo hi lc b fi ll li l lj lk">fCh(event) { &lt;-- shortened to fit(usually called changeHandler)<br/>        event.preventDefault();<br/>        let name = event.target.name;<br/>        let value = event.target.value;</span><span id="560d" class="lg jo hi lc b fi ll li l lj lk">   if (name === 'name'){<br/>           setName(value)<br/>        } else {<br/>           setEmail(value)<br/>        }</span><span id="20fb" class="lg jo hi lc b fi ll li l lj lk">   }<strong class="lc hj"><br/></strong><br/>    handleSubmit(event) {<br/>        event.preventDefault();<br/>        console.log(this.state);<br/>    }</span><span id="801e" class="lg jo hi lc b fi ll li l lj lk"><strong class="lc hj">   useEffect(() =&gt; {    <br/>     </strong><strong class="lc hj">document.title = `{name}'s Profile`</strong><strong class="lc hj">;  <br/>   });</strong></span><span id="b05c" class="lg jo hi lc b fi ll li l lj lk">render(){<br/>  return (<br/>  &lt;div&gt;<br/>    <strong class="lc hj">&lt;h1&gt; {document.title} &lt;/h1&gt;</strong><br/>    &lt;form onSubmit={handleSubmit}&gt;<br/>      &lt;label&gt; Name:<br/>      &lt;input type="text" name="name" value={name} onChange={fCh)}/&gt;<br/>      &lt;/label&gt;<br/>      &lt;label&gt;Email:<br/>      &lt;input type="text" name="email" value={email} onChange={fCh}/&gt;<br/>      &lt;/label&gt;&lt;br /&gt;<br/>      &lt;input className="btn" type="submit" value="Submit" /&gt;<br/>    &lt;/form&gt;<br/>    )<br/>  }</span><span id="95f7" class="lg jo hi lc b fi ll li l lj lk">export default MyComponent</span></pre><p id="dae9" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">同样的事情会发生在上面，文档的标题会被更新，但是只有在组件渲染后才会更新。</p><h2 id="e505" class="lg jo hi bd jp ls lt lu jt lv lw lx jx ko ly lz jz ks ma mb kb kw mc md kd me bi translated">使用useEffect重新创建setState的第二个参数</h2><p id="60ad" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">假设您有一个组件，该组件有一个功能，当您单击它时聚焦在文本框上，当您单击外部时移除焦点。</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="fc88" class="lg jo hi lc b fi lh li l lj lk">useEffect(() =&gt; {<br/>  document.addEventListener("mousedown", handleClickOutside);<br/>  <br/>  return () =&gt; {<br/>    document.removeEventListener("mousedown", handleClickOutside);<br/>  };<br/>});</span></pre><p id="c934" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">首先，您需要添加一个useEffect，将这些侦听器添加到您的页面中，并调用相应的函数。</p><p id="4a98" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">使用useEffect时，如果您的函数在卸载后需要清理(例如，如果您想清除一个计时器的时间间隔，或者删除一个事件侦听器)，您可以将清理函数放在useEffect挂钩的返回值中，该挂钩添加了您想要清理的功能。以上就是你看到的。该代码添加一个mousedown事件侦听器，然后在组件从页面卸载后移除它。</p><p id="244c" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">在这个组件中还有</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="5817" class="lg jo hi lc b fi lh li l lj lk">onTextChange = (event) =&gt; {    <br/>  if (event.target.value !== this.state.textContents + "\n") {<br/>      this.setState({ textContents: event.target.value }, () =&gt;<br/>        this.textInput.current.focus()<br/>      );<br/>    }<br/>  };</span></pre><p id="0a46" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">这里你会看到setState函数有一个回调函数的第二个参数，它的作用是关注包含文本输入框的ref。之所以将它放在setState函数中，是因为只有通过这个特定的函数才能在状态更新后立即调用这个函数，并且它可以访问更新后的状态值。由于setState是异步的，如果这个函数不在setState函数中，您不能保证它将使用最新版本的State运行。</p><p id="a1c8" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">现在这个有点难以模仿，但我们可以通过创建另一个useEffect来实现相同的效果，但只在特定状态属性更新时运行，而不是在每次更新或第一次渲染时运行。</p><p id="a737" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated"><a class="ae lr" href="https://stackoverflow.com/questions/59677451/setstate-second-argument-callback-function-alternative-in-state-hooks" rel="noopener ugc nofollow" target="_blank">这篇栈溢出文章</a>非常好地解释了如何更详细地完成这项工作，但是你想要做的是创建一个useEffect函数，并给它一个所谓的<em class="mf">依赖数组。</em>依赖数组是您希望更新以触发此特定useEffect的所有变量的列表。</p><p id="1754" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">这是我们新功能组件的外观:</p><pre class="iy iz ja jb fd lb lc ld le aw lf bi"><span id="5737" class="lg jo hi lc b fi lh li l lj lk">const onTextChange = (event) =&gt; {<br/>  if (event.target.value !== textContents + "\n") {<br/>    setTextContents(event.target.value);<br/>    setEditingText(false)<br/>  }<br/>};</span><span id="baf6" class="lg jo hi lc b fi ll li l lj lk">useEffect(() =&gt; {<br/>  const textInput = textInput.current;<br/>    if (textInput &amp;&amp; editingText) {<br/>      textInput.focus();<br/>      const endOfInput = textInput.textLength;<br/>      textInput.setSelectionRange(endOfInput, endOfInput);<br/>    }<br/> }, [editingText]);</span></pre><p id="bf28" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">因此，第一个onTextChange函数使用useState提供的setTextContents函数来更新TextContents状态变量，并使用setEditingText函数将EditingText变量更改为false。这意味着我们已经完成了对组件的编辑。</p><p id="4c6a" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">然后，具有editingText的依赖数组的useEffect将注意到editingText已更改，它将运行代码，以便在用户编辑文本时聚焦于文本框并添加光标，或者在更新完成时不聚焦于文本框并移除光标。</p><p id="bac6" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">使用“const textInput = textInput . current”的原因是，在定义textInput ref导致错误之前，代码不会在初始呈现时运行。</p><p id="efa6" class="pw-post-body-paragraph kf kg hi kh b ki lm ij kk kl ln im kn ko lo kq kr ks lp ku kv kw lq ky kz la hb bi translated">现在你知道了。您的组件应该使用React钩子完全重构为一个功能组件！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Encapsulate Framework Implementation in Your iOS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在您的iOS应用程序中封装框架实现</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/encapsulate-framework-implementation-in-your-ios-application-74f73c5156a0?source=collection_archive---------7-----------------------#2022-05-20">https://medium.com/geekculture/encapsulate-framework-implementation-in-your-ios-application-74f73c5156a0?source=collection_archive---------7-----------------------#2022-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对您的特性隐藏任何框架实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/430487af88ba51e19d75bd61a45f69f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CYYmvwIUK1th2nP"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/es/@dollargill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dollar Gill</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3bac" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">概观</h2><p id="e97e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当我们构建一个应用程序时，有时我们需要使用框架或库来帮助我们开发特性。这是一个有效的方法，因为我们没有太多的时间自己写所有的代码。例如，当我们的应用程序需要离线功能时，我们可以使用许多框架选项，如核心数据、领域、NSCache等。或者您可能需要使用StoreKit来实现应用内购买。也许你还需要在社区中使用开源库，比如构建UI的Texture。</p><p id="7031" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，我们紧密依赖于任何框架。但问题是，我们如何使我们的应用程序中的特性与任何框架实现解耦？也许目前你在你的应用程序中离线使用Realm，但是你的团队决定在将来使用核心数据，或者也许你想在你的应用程序中实现单元测试，但是你不知道如何测试一个实现StoreKit、Vision或其他功能的特性。</p><p id="71a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让你的应用与任何框架实现分离有很多好处。您可以在不破坏功能实现的情况下切换框架，使您的应用程序能够容忍变化，而不需要付出巨大的努力，并且可能使您的应用程序可测试，这样您就可以加快功能开发迭代。你的产品经理会非常高兴的:】。</p><p id="b26d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在本文中，我将尝试向您展示如何封装框架实现，并使其与您的功能分离。我有一个简单的应用程序，用户可以管理他们的日常任务。它使用核心数据来持久化数据，通过这个设计系统，您可以在将来更改本地存储框架的实现。</p><h2 id="c4d1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">示例项目</h2><p id="8105" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">看看这个项目存储库，并随意克隆它。</p><div class="ku kv ez fb kw kx"><a href="https://github.com/tifoaudii/TaskManager" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hj fi z dy lc ea eb ld ed ef hh bi translated">GitHub - tifoaudii/TaskManager:一款iOS应用，可以用来管理日常任务</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">github.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jn kx"/></div></div></a></div><div class="je jf jg jh fd ab cb"><figure class="lm ji ln lo lp lq lr paragraph-image"><img src="../Images/777323bb475744ff904b8da8fcf29418.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*9dYG4rBgj0gmxgejO9wpPA.png"/></figure><figure class="lm ji ln lo lp lq lr paragraph-image"><img src="../Images/78e14518aa2764677c375c9255d27ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*ZdOrF_aoVLjAf6BZX6q6Dw.png"/></figure></div><p id="6bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的应用程序，允许我们创建一个有截止日期的任务。您可以在截止日期之前完成任务，并且可以根据选项卡菜单筛选显示的任务。每当您创建一个任务时，它将通过使用后台核心数据来保存。</p><p id="da40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于解释，假设我们在这个应用程序中有两个功能，分别是<strong class="ih hj">任务列表</strong>和<strong class="ih hj">添加任务</strong>。这两个特性都有表示层来管理表示逻辑。表示层需要从数据基础设施层获取任务数据。因为在这个使用核心数据作为数据源的应用程序中，这是基础架构层的代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="b87d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是简单的自定义核心数据设置，您可以通过配置isMemory中的值来定义存储类型。如果isMemory的值为false，则使用默认类型的存储，即在后台使用SQLite，否则使用NSInMemoryStoreType进行单元测试。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="2c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是核心数据端的任务实体，即NSManagedObject。它由我们已经定义的任务的属性组成。</p><p id="f6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们的核心数据基础设施已经可以使用了。但是我们也需要考虑，如果我们在应用程序端使用这个实体，它肯定是紧耦合的。<br/>想象一下，如果您将这个实体直接用于您的应用程序，而在未来您的团队决定使用Realm来更改数据层基础架构，那么迁移将会非常困难。因为可能在Realm或者任何其他框架中，他们也有某种基类来创建实体，比如核心数据中的NSManagedObject。</p><p id="ff47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的简单方法是，我们可以创建一个新的模型，作为接口模型存在于应用程序端。所以任何框架中的具体实体都可以转换成这个模型。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="7b3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，我们的应用程序不需要知道具体的实体实现。它具有不关心幕后发生什么的灵活性。让我们使任务实体符合TaskModelConvertible协议。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="dbf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那很简单但是很优雅，对吧？:]</p><p id="5eb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们可以移动到表示层。这两种功能的演示者都需要与核心数据基础设施对话，与数据进行交互，对吗？为了使表示器与核心数据基础设施分离，您需要使用协议作为它们之间的契约来定义抽象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="cab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合同完成了。您的演示者只需要与具有这些功能的核心数据基础架构进行交互。然后我们可以在presenter实现中实现依赖注入:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，您的演示者已准备好接受观众的观点。但是我们还没有具体的实现，对吗？那么我们如何初始化这个演示者呢？</p><p id="c448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">别担心，我们已经有了核心数据基础架构，对吗？我们可以从核心数据基础设施创建一个扩展，并使其符合TaskViewDataStore协议。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="4fd1" class="ju jv hi lv b fi lz ma l mb mc"><strong class="lv hj">Pro tips: </strong>If your app is modular, this extension should live on the composition root module, commonly in Main application module.</span></pre><p id="8c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁，我们有了TaskViewDataStore协议的具体实现，最后我们可以将我们的对象组合在一起:】。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="3fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">厉害！，也许只是简单的app，但我们像专业的软件工程师一样创建:】。如果你的老板要求你改变框架实现，你不必再担心，你的特性仍然是好的。</p><p id="c703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种设计系统，也很容易实现单元测试。可以为TaskViewDataStore协议创建一个spy对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="66af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您可以像这样将间谍注入到您的测试用例中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="de62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终完成了，尽管我还没有在项目中创建所有的单元测试:】。</p><h2 id="7b30" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">结论</h2><p id="214f" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如今，作为一名软件工程师，我们经常需要框架来帮助我们的工作。知道如何创建一个设计系统，让你的应用从框架实现中松耦合是很重要的。这篇文章中有许多高级主题，如果您感到困惑，请不要担心，继续练习。从依赖注入和依赖倒置原则这样的基础开始。这将极大地帮助您构建一个可扩展的系统。我也有一篇关于我们如何编写单元测试来测试核心数据<a class="ae jt" rel="noopener" href="/swlh/implement-unit-testing-for-core-data-in-ios-2b914767f7e3">的文章。感谢您阅读本文，如果您有任何反馈或问题，请告诉我。另文再见！</a></p></div></div>    
</body>
</html>
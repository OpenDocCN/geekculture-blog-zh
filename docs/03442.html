<html>
<head>
<title>Machine Learning Pipelines with Google Cloud Platform (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台的机器学习管道(第一部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/machine-learning-pipelines-with-google-cloud-platform-a3697d0ab8fb?source=collection_archive---------20-----------------------#2021-06-08">https://medium.com/geekculture/machine-learning-pipelines-with-google-cloud-platform-a3697d0ab8fb?source=collection_archive---------20-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b96b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5月18日，谷歌云公布<strong class="ih hj">Vertex AI</strong>；<em class="jd">一个托管的机器学习(ML)平台。</em>他们声称，与竞争平台相比，它需要的代码少了80%(<em class="jd">谷歌云内部研究，2021年5月)。</em></p><p id="af6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vertex有几个组件来简化数据科学家/ML工程师的生活，如功能存储、轻松部署模型的端点、托管数据集、笔记本(实际上是相同的旧Jupyter笔记本)和我最喜欢的部分:管道！</p><p id="1ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们来看看对于新人来说什么是机器学习管道。实际上，它是一个完整的工作流，封装了开发和部署ML模型时的所有小步骤。这对于几个原因是有用的，如<strong class="ih hj">训练</strong> - <strong class="ih hj">服务偏差、模式验证、数据漂移或概念漂移、连续训练、模型监控</strong>等。但是这个话题应该有自己的博文。TLDR，<em class="jd">你可以把你的训练过程分成更小的部分，这样当出现问题时你可以很容易地调试它，而且你也可以把它作为一个单独的程序来运行。</em>然后你可以回来看看是怎么回事。</p><p id="48f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们别兜圈子了，写点代码吧。我将向您展示一个玩具示例，足以让您理解ML管道的整个概念。然后你可以写你自己的代码，做最复杂的任务，如导入数据，特征工程，培训和服务。</p><p id="68b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们导入必要的库:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Import necessary libraries</figcaption></figure><p id="5997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些模块看起来像我们的老朋友坏脾气库伯弗洛！是的，但是有一个简单的变化:我们有了第2版，它允许我们直接从裸Python函数中创建组件。</p><p id="8e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们进入有趣的部分之前，让我们建立我们的GCP环境，以摆脱我们以后可能会有的头痛。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Set up Google Cloud Environment</figcaption></figure><p id="50a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使开始看起来很复杂，但不要害怕；我会解释这一切。</p><p id="406e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一行中，我输入了一个简单的shell命令来检索您的google cloud默认项目id。它返回一个列表，所以我们只得到[0]索引。</p><p id="a783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们定义了区域和存储桶名称来存储和检索对象。如果你不知道什么是bucket，你可以把它想象成你本地文件系统上的一个目录(但是记住它不是一个目录，google使用的是<a class="ae jp" href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" rel="noopener ugc nofollow" target="_blank"> GFS </a>，它是Hadoop的HDFS的祖先)。</p><p id="3b25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们需要一些<a class="ae jp" rel="noopener" href="/chingu/an-introduction-to-environment-variables-and-how-to-use-them-f602f66d15fa#:~:text=An%20environment%20variable%20is%20a,at%20a%20point%20in%20time.">环境变量</a>，因此我们使用一个<a class="ae jp" rel="noopener" href="/chingu/an-introduction-to-environment-variables-and-how-to-use-them-f602f66d15fa#:~:text=An%20environment%20variable%20is%20a,at%20a%20point%20in%20time."> Jupyter魔法</a>。简单地说，%env:列出了所有的环境变量/值，我们在这里需要PATH变量。</p><p id="4c2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们定义管道根——一个简单的桶。</p><p id="b782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们实例化kfp客户端API:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Instantiate KFP Client API</figcaption></figure><p id="bc54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您从marketplace部署了一个Kubeflow(实际上是一个托管的kubernetes集群)之后，您可以获得KFP(Kubeflow Pipelines) API所需的链接。</p><p id="7648" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们进入有趣的部分，定义我们的第一个组件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="d293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用组件<a class="ae jp" href="https://www.programiz.com/python-programming/decorator" rel="noopener ugc nofollow" target="_blank">装饰器</a>并定义简单的python函数。在我们进入组件的参数之前<em class="jd">(它们都是可选的，所以可以随意跳过这一部分)</em>我需要提到每个组件实际上都是一个容器；就像码头集装箱一样。因此，我们可能有组件的yaml文件(或者你可以说<a class="ae jp" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> dockerfile </a>用于多个容器),这是一个如何设置和运行每个容器的简单手稿。</p><p id="f395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了它，“add_component.yaml”就在那里，以防我们需要重新构建同一个组件。我们指定将哪个python图像用于这个所谓的容器。</p><p id="c8e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，第二部分:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="73f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，我将输出指定为NamedTuple。当您希望其他组件以<em class="jd">元数据句柄</em>的形式访问这些组件时，它就派上了用场，这超出了本文的范围。把它想象成组件的一个属性，我们可以像到达一个numpy数组的形状(my_array.shape)一样到达它。现在这不重要。</p><p id="70a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了两个组件，我们可以构建一个简单的hello-world管道。我们只需要一个名称和一个根路径来存储工件。然后，您可以定义一个函数(我们将在编译时使用它)来使用我们刚刚在上面创建的组件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Building pipeline</figcaption></figure><p id="dbfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的步骤都是不言自明的；我们定义了我们的管道名称(我们将在vertex ai平台上看到)，一个可选的描述和一个管道根。我们有PIPELINE_ROOT变量，但是为了让您的工作更容易，我再次定义了它。接下来，我们需要编译管道。感觉像是Keras的模特，对吧？</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Compiling pipeline</figcaption></figure><p id="7c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译方法需要我们上面定义的管道函数。您可能还记得，这个函数消耗组件。Compile方法也需要一个路径来保存json对象。我们可以在顶点管道界面中使用这个对象来导入我们的管道，我们可以调用GCP API让它为我们运行。既然你正在读这篇文章，我推断你和我一样正在为一场灾难而奔波。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="5a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们实例化了GCP AI平台(可以说是老版本的Vertex)，我们给她她需要的东西，我们的项目id和区域。然后我们调用“create_run_from_job_spec”函数，我们使用了上面提到的json对象。</p><p id="f221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们前往GCP顶点人工智能仪表板，并点击管道，选择我们的“hello-world”管道，我们将看到运行时图。注意，第二个组件的输出就像我们定义的“之前”和“之后”一样。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/f8c9b83abce22bd1ed05d5dbcce9b26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGPGGT4ITa_PCLn-EpeDrw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Vertex Pipelines Dashboard UI</figcaption></figure><p id="dbc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，我们刚刚运行了我们的第一个玩具管道。如果我们已经训练了一个模型，我们可以在模型中看到它，并且可以创建一个端点，通过一个简单的REST API调用在生产中使用它。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Common Function Attributes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见功能属性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/some-common-function-attributes-that-i-found-useful-279690ec043b?source=collection_archive---------16-----------------------#2022-07-08">https://medium.com/geekculture/some-common-function-attributes-that-i-found-useful-279690ec043b?source=collection_archive---------16-----------------------#2022-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b1b1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">我发现有用的一些常用函数属性！</strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/87d8906d7ecd1712f38626a199a6b082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HNZ3__2D525cYw4oyo7Sg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://commons.wikimedia.org/wiki/File:GNU_Love.png" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:GNU_Love.png</a></figcaption></figure><p id="7058" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的<a class="ae jn" rel="noopener" href="/@pinloon/hello-world-70a51f449d9f">第一篇帖子</a>之后，我觉得在进入机器人嵌入式C/C++编程的更高层次之前，继续从低层次的角度来看可能是好的。</p><p id="6a83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">gcc 的<a class="ae jn" href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes" rel="noopener ugc nofollow" target="_blank">文档中有很多通用的函数属性。在这篇文章中，我将展示几个函数属性的用法示例，它们是</a></p><ul class=""><li id="0672" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><code class="du kt ku kv kw b">__attribute__((warn_unused_result))</code></li><li id="36da" class="kk kl hi jq b jr kx ju ky jx kz kb la kf lb kj kp kq kr ks bi translated"><code class="du kt ku kv kw b">__attribute__((deprecated))</code></li><li id="699e" class="kk kl hi jq b jr kx ju ky jx kz kb la kf lb kj kp kq kr ks bi translated"><code class="du kt ku kv kw b">__attribute__((__weak__))</code></li></ul><p id="aeff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也许你遇到过类似下面的情况</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="629f" class="lg lh hi kw b fi li lj l lk ll">#ifndef __must_check<br/>#define __must_check __attribute__((warn_unused_result))<br/>#endif<br/><br/>#ifndef __deprecated<br/>#define __deprecated __attribute__((deprecated))<br/>#endif<br/><br/>#ifndef __weak<br/>#define __weak __attribute__((__weak__))<br/>#endif</span></pre><h2 id="5bdf" class="lg lh hi bd lm ln lo lp lq lr ls lt lu jx lv lw lx kb ly lz ma kf mb mc md me bi translated"><code class="du kt ku kv kw b">__attribute__((warn_unused_result))</code></h2><p id="76fa" class="pw-post-body-paragraph jo jp hi jq b jr mf ij jt ju mg im jw jx mh jz ka kb mi kd ke kf mj kh ki kj hb bi translated">在某些情况下，强迫用户捕捉函数的返回值是非常重要的。如下所示，有一个状态代码表示初始化过程的结果。</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="85c0" class="lg lh hi kw b fi li lj l lk ll">int Init() {<br/>  // some status code after certain intiialization process<br/>  return status_code;<br/>}</span></pre><p id="48fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，我们希望避免调用如下函数</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="5b34" class="lg lh hi kw b fi li lj l lk ll">int main(int argc, char **argv) {<br/>  Init();<br/>  return 0;<br/>}</span></pre><p id="4e47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我们可以添加<code class="du kt ku kv kw b">__attribute__((warn_unused_result))</code>,使函数看起来像</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="f946" class="lg lh hi kw b fi li lj l lk ll">__attribute__((warn_unused_result)) <br/>int Init() {<br/>  // some status code after certain intiialization process<br/>  return status_code;<br/>}</span></pre><p id="6b26" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，如果函数的返回值被忽略(像上面的例子那样调用函数)，用户将得到如下警告</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="2045" class="lg lh hi kw b fi li lj l lk ll">warning: ignoring return value of ‘int Init()’, declared with attribute warn_unused_result [-Wunused-result]</span></pre><h2 id="c014" class="lg lh hi bd lm ln lo lp lq lr ls lt lu jx lv lw lx kb ly lz ma kf mb mc md me bi translated"><code class="du kt ku kv kw b">__attribute__((deprecated))</code></h2><p id="1f80" class="pw-post-body-paragraph jo jp hi jq b jr mf ij jt ju mg im jw jx mh jz ka kb mi kd ke kf mj kh ki kj hb bi translated">大多数情况下，当我们维护一个由大量用户使用的代码库时，弃用代码是很正常的，但是可能会有一个承诺期来维护相同的接口，同时向后兼容也是一个常见的需求。下面的示例显示了当调用的函数被否决时，函数属性如何帮助向用户发出警告。</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="83cb" class="lg lh hi kw b fi li lj l lk ll">__attribute__((deprecated)) int Init();</span></pre><p id="a065" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">拥有以上属性，用户在调用<code class="du kt ku kv kw b">Init()</code>的函数时会得到如下警告。</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="3842" class="lg lh hi kw b fi li lj l lk ll">warning: ‘int Init()’ is deprecated [-Wdeprecated-declarations]</span></pre><h2 id="ef3a" class="lg lh hi bd lm ln lo lp lq lr ls lt lu jx lv lw lx kb ly lz ma kf mb mc md me bi translated">_ _已弃用_宏</h2><p id="5260" class="pw-post-body-paragraph jo jp hi jq b jr mf ij jt ju mg im jw jx mh jz ka kb mi kd ke kf mj kh ki kj hb bi translated">作为标记为弃用的延续，我们也可以将一些旧的宏标记为<code class="du kt ku kv kw b">deprecated</code>。</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="7cf0" class="lg lh hi kw b fi li lj l lk ll">#define __WARN(msg) __WARN_GCC(GCC warning msg)<br/>#define __WARN_GCC(s) _Pragma(#s)<br/><br/>#ifndef __DEPRECATED_MACRO<br/>#define __DEPRECATED_MACRO __WARN("Macro is deprecated")<br/>#endif</span></pre><p id="b2db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果之前我们有一个宏</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="31a8" class="lg lh hi kw b fi li lj l lk ll">#define MAX(a,b) (a &gt; b? a: b)</span></pre><p id="58f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以将其标记为</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="45c0" class="lg lh hi kw b fi li lj l lk ll">#define MAX(a,b) __DEPRECATED_MACRO std::max(a,b)</span></pre><p id="9d42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调用宏现在会输出</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="6961" class="lg lh hi kw b fi li lj l lk ll">warning: Macro is deprecated</span></pre><h2 id="a3a3" class="lg lh hi bd lm ln lo lp lq lr ls lt lu jx lv lw lx kb ly lz ma kf mb mc md me bi translated"><code class="du kt ku kv kw b">__attribute__((__weak__))</code></h2><p id="dd3d" class="pw-post-body-paragraph jo jp hi jq b jr mf ij jt ju mg im jw jx mh jz ka kb mi kd ke kf mj kh ki kj hb bi translated">从<code class="du kt ku kv kw b">gcc</code>文档中，</p><p id="9dc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mk">“弱属性导致声明作为弱符号而不是全局符号发出。这主要用于定义可以在用户代码中覆盖的库函数，尽管它也可以用于非函数声明。ELF目标支持弱符号，使用GNU汇编程序和链接程序时，a.out目标也支持弱符号。</em></p><p id="8e58" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，如果我们有一个</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="577e" class="lg lh hi kw b fi li lj l lk ll">__attribute__((__weak__)) int Init() { <br/>  std::cout &lt;&lt; "Init is not supported" &lt;&lt; std::endl;<br/>  return 0; <br/>}</span></pre><p id="fae7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调用该函数将导致输出</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="e5e9" class="lg lh hi kw b fi li lj l lk ll">Init is not supported</span></pre><p id="80e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">如果</strong>没有其他翻译单位提供相同功能的定义。</p><p id="54f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果有其他文件也提供了定义，</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="94cf" class="lg lh hi kw b fi li lj l lk ll">int Init() { <br/>    std::cout &lt;&lt; "Init done" &lt;&lt; std::endl;<br/>    return 2; <br/>}</span></pre><p id="9c9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调用<code class="du kt ku kv kw b">Init()</code>的输出现在应该是</p><pre class="iy iz ja jb fd lc kw ld le aw lf bi"><span id="e71d" class="lg lh hi kw b fi li lj l lk ll">Init done</span></pre><p id="9b74" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该理论是，每当链接器发现弱符号和强符号时，它将首先选择强符号。如果只有弱符号，它将被选择。这仅对静态库有效。o .a .)，它在动态环境中不起作用。所以)图书馆。</p><p id="4bb7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基于<code class="du kt ku kv kw b">One Definition Rule</code>，</p><p id="7b38" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mk">“对象和非内联函数在整个程序中不能有多个定义”</em></p><p id="58b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以如果你删除了<code class="du kt ku kv kw b">__attribute__((__weak__))</code>，你会得到一个报错多重定义的错误。</p><p id="4f84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">帖子到此结束，希望你喜欢阅读！</p></div></div>    
</body>
</html>
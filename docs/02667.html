<html>
<head>
<title>Normalization in DBMS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBMS中的规范化</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/normalization-in-dbms-3b2af915ee25?source=collection_archive---------31-----------------------#2021-05-23">https://medium.com/geekculture/normalization-in-dbms-3b2af915ee25?source=collection_archive---------31-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/14ddae435d4cbce22bc15c02f5da314f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0gEitFh287UPEo1y2Vc3Q.jpeg"/></div></div></figure><p id="7583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">规范化是一个过程，通过这个过程，我们可以将任何关系分解或划分为一个以上的关系，以消除关系数据库中的异常。</p><p id="c66d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新异常</strong>:更新异常是数据冗余和部分更新导致的数据不一致</p><p id="bcd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">删除异常:</strong>当您删除可能包含不应该删除的属性的记录时，会出现删除异常</p><p id="1bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">插入异常:</strong>我们试图在一个根本不存在的记录中插入数据。</p><p id="437d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">规范化规则分为以下几种标准形式:</p><ol class=""><li id="abe3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">第一范式</li><li id="7896" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">第二范式</li><li id="f9da" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">第三范式</li><li id="fed9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">BCNF</li></ol><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/f488a2de8a03a6f6ecde075d2082d91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*viJYbQP12Rf5KFqpXGQPbw.png"/></div></figure><p id="3b5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一范式:</strong>关系处于第一范式如果每个值的定义域只包含一个原子或单个值，这意味着原子性必须存在于关系中。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="3fcb" class="km kn hi ki b fi ko kp l kq kr">ID   Name       Courses<br/>--------------------<br/>1    Akshay     c1,c2<br/>2    Abhishek   c3<br/>3    Aditya     c2,c3</span><span id="f2c7" class="km kn hi ki b fi ks kp l kq kr">ID   Name       Courses<br/>------------------<br/>1    Akshay      c1<br/>1    Akshay      c2<br/>2    Abhishek    c3<br/>3    Aditya      c2<br/>3    Aditya      c3</span></pre><p id="a295" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二范式:</strong>如果一个关系在第一范式中，并且没有部分依赖，则它在第二范式中。<strong class="is hj">部分依赖</strong>当一个非主属性在功能上依赖于候选关键字的一部分时发生。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/7db7140552be31e5c145e1dc5b41f212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*Gg7WCBSye7ZKD8AszJs8mw.png"/></div></figure><p id="5600" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三范式:</strong>如果一个关系在第二范式中，并且没有传递依赖，则它在第三范式中。</p><p id="cebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Boyce–Codd范式:</strong>一个关系在BCNF中当且仅当每一个非平凡函数依赖X → Y都以X为超键。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/f7c11918f88f7a305430a25c0dace1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/1*XWDg9DwAR4zWGhvT9mbgcw.gif"/></div></figure><p id="e1b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">琐碎的函数依赖</strong>是一种数据库依赖，当您描述一个属性的函数依赖或包含原始属性的属性集合时，就会出现这种依赖。如果函数依赖X →Y成立，其中Y不是X的子集，这个依赖称为<strong class="is hj">非平凡函数依赖。</strong></p><p id="ef91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第四正常正常:</strong> It <strong class="is hj"> </strong>是数据库规范化的一个级别，其中除了候选关键字之外，没有非平凡的多值依赖项。</p><p id="f8be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它建立在前三个范式(1NF、2NF和3NF)和Boyce-Codd范式(BCNF)的基础上。它规定，除了满足BCNF要求的数据库之外，它不能包含多个多值依赖项。</p><p id="2d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第五范式:</strong>第五范式又称为项目-联结范式。如果在4NF，关系是第五范式(5NF ),并且不会无损分解成更小的表。</p><p id="79e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果候选键暗示了其中的每个连接依赖，您也可以认为一个关系在5NF中。</p></div></div>    
</body>
</html>
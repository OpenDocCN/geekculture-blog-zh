<html>
<head>
<title>The Surprising Cost of Protocol Conformances in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift协议一致性的惊人成本</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/the-surprising-cost-of-protocol-conformances-in-swift-dfa5db15ac0c?source=collection_archive---------4-----------------------#2021-12-03">https://medium.com/geekculture/the-surprising-cost-of-protocol-conformances-in-swift-dfa5db15ac0c?source=collection_archive---------4-----------------------#2021-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e4876c571e36ad2b7eea4638853bf088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65L3b5U827Qz_HZ0aqlh9Q.png"/></div></div></figure><div class=""/><p id="e657" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的<a class="ae jo" href="https://www.emergetools.com/blog/posts/SwiftReferenceTypes" rel="noopener ugc nofollow" target="_blank">上一篇</a> <a class="ae jo" href="https://www.emergetools.com/blog/posts/iOS15LaunchTime" rel="noopener ugc nofollow" target="_blank">两篇</a>文章中，我写了关于pre-main启动时间，以及应用程序大小如何直接影响dyld初始化应用程序的工作量。在这篇文章中，我将仔细研究Swift运行时特性，协议一致性检查，看看这个常见的操作是如何随着二进制文件大小的增加而减慢post-main时间的。</p><p id="7466" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可能是引起应用性能担忧的第一个暗示来自于<a class="ae jo" href="https://www.swift.org/blog/swift-5-4-released/" rel="noopener ugc nofollow" target="_blank"> Swift 5.4发行说明</a>:</p><blockquote class="jp jq jr"><p id="b193" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><em class="ht">在Swift 5.4中，由于采用了更快的哈希表来缓存之前的查找结果，运行时的协议一致性检查速度明显加快。特别是，这加速了通用运行时</em> <code class="du jw jx jy jz b"><em class="ht">as?</em></code> <em class="ht">和</em> <code class="du jw jx jy jz b"><em class="ht">as!</em></code> <em class="ht">的造型操作。</em></p></blockquote><p id="8e4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">协议一致性检查是指运行时需要查找变量是否符合协议。在你的代码中，这看起来像<code class="du jw jx jy jz b">myVar as? MyProtocol</code>。注意<code class="du jw jx jy jz b">as?</code>操作也可以用于将变量转换为非协议类型，这些不会导致协议一致性检查。这是Swift运行时动态特性的一部分。<code class="du jw jx jy jz b">as?</code>操作符表明在编译时不保证类型将会付出运行时代价。</p><p id="29ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从发行说明中我们知道<code class="du jw jx jy jz b">as?</code>的运行速度很慢，有“显著”加快的空间，但是它们到底有多慢呢？既然更快的缓存加快了它的速度，那么我们什么时候会达到未缓存状态，速度有多慢？我在Emerge中使用了<a class="ae jo" href="https://docs.emergetools.com/docs/startup-flame-chart" rel="noopener ugc nofollow" target="_blank">应用启动时间可视化</a>,看看这是否会出现在Swift应用的堆栈跟踪样本中...果然...👀现场报道。你可以在下面看到<code class="du jw jx jy jz b">swift_conformsToProtocol</code>花费了100多毫秒的应用程序启动时间。</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ka"><img src="../Images/eebdcf1600bd4ee4e86ff336177622f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-XMmr_O16UX6uFdEn7SNQ.png"/></div></div></figure><p id="d66a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看Swift的源代码，看看是什么原因导致速度变慢，以及在实践中需要多少时间。然后，我们将讨论在您的应用中避免这种情况的策略，甚至实现Swift运行时的更快替代。</p><h1 id="f082" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">检查协议一致性时会发生什么？</h1><p id="08b3" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">我们调查的切入点是<a class="ae jo" href="https://github.com/apple/swift/pull/33487" rel="noopener ugc nofollow" target="_blank"> Mike Ash的PR </a>，它实现了在Swift 5.4中发布的13倍快缓存。从这里您可以看到新缓存的定义位置:</p><pre class="kb kc kd ke fd li jz lj lk aw ll bi"><span id="64fd" class="lm kg ht jz b fi ln lo l lp lq"><strong class="jz hu">struct</strong> <strong class="jz hu">ConformanceState</strong> {<br/>   ConcurrentReadableHashMap&lt;ConformanceCacheEntry&gt; Cache;<br/>...</span></pre><p id="597d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码的最新版本是函数<code class="du jw jx jy jz b">swift_conformsToProtocolMaybeInstantiateSuperclasses</code>中的<a class="ae jo" href="https://github.com/apple/swift/blob/aec4ec4c4a0f647ae6670745cd389aba767f3111/stdlib/public/runtime/ProtocolConformance.cpp#L865" rel="noopener ugc nofollow" target="_blank">protocol conformance . CPP</a>，其中大部分时间是基于启动时间可视化花费的。这个函数有三个高级路径，创建一个2级缓存，然后是一个较慢的一致性全搜索。</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lr"><img src="../Images/726676e95715d96f4029771c82dd29d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGU-zE08rNmH4-VeOrUmrQ.png"/></div></div></figure><ul class=""><li id="2837" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated"><code class="du jw jx jy jz b">_dyld_find_protocol_conformance</code>:在查询Swift 5.4中增加的ConcurrentReadableHashMap之前，运行时会检查一个dyld管理的缓存。据推测，这允许在应用程序启动之间保持缓存。iOS 15中增加了对这种缓存的支持，你可以使用<code class="du jw jx jy jz b">nm /usr/lib/dyld | grep _dyld_find_protocol_conformance | c++filt</code>确认dyld中是否存在该功能。不幸的是，Swift是从dyld_priv.h导入的，所以在苹果发布最新操作系统版本的源代码之前，我们无法看到它的实现。您可以在这个函数上设置一个符号断点，并在测试应用程序中验证在使用<code class="du jw jx jy jz b">as?</code>时它总是被调用。这似乎是一项正在进行的工作，因为在实践中，总是会查询第二个缓存(使用另一个符号断点进行验证)。</li><li id="5aad" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><code class="du jw jx jy jz b">ConcurrentReadableHashMap.find()</code>接下来，运行时检查Swift 5.4中添加的缓存，这是一种内存缓存，不会在应用程序的多次运行之间持续存在。您可以通过在<code class="du jw jx jy jz b">_ZN5swift25ConcurrentReadableHashMapIN12_GLOBAL__N_121ConformanceCacheEntryENS_11StaticMutexEE4findINS1_19ConformanceCacheKeyEEENSt3__14pairIPS2_jEERKT_NS4_12IndexStorageEmS9_</code>上放置一个符号断点来验证它是否被调用。这是接受一个<code class="du jw jx jy jz b">ConformanceCacheKey</code>并返回一个<code class="du jw jx jy jz b">ConformanceCacheEntry</code>的函数的C++代码[1]名称。查看缓存键的定义，我们可以看到它是基于一致性类型和协议的</li></ul><pre class="kb kc kd ke fd li jz lj lk aw ll bi"><span id="5260" class="lm kg ht jz b fi ln lo l lp lq"><strong class="jz hu">struct</strong> <strong class="jz hu">ConformanceCacheKey</strong> {<br/>  const Metadata *Type;<br/>  const ProtocolDescriptor *Proto;</span></pre><p id="66d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着缓存键是特定于该类型/协议对的，对同一协议的多次一致性检查，但不同的类型(反之亦然)不会命中缓存。这也可以用符号断点来验证。</p><ul class=""><li id="5b35" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">线性扫描是最坏的情况，但是在填充缓存之前，总是对每个类型/协议对进行线性扫描。Swift创建了一个特殊的mach-o部分<code class="du jw jx jy jz b">__TEXT.__swift5_proto</code>,它是指向二进制文件中每个协议一致性记录的指针列表。为每个类型/协议对生成一致性记录，并允许运行时确定应用程序中的一致性。这种二进制元数据是Emerge Tool的分析工作的基础，我们使用它来将源代码的一部分归入二进制大小。[2]对您的应用中加载的每个dylib进行所有符合性扫描，包括框架或系统库，如Swift标准库本身。这意味着单个一致性查找是O(n ),查找每个可能的一致性是O(n^2)，这对性能不好！</li></ul><h1 id="ee5e" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">到底有多慢？</h1><p id="0331" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">我们现在看到，协议一致性查找的速度取决于应用程序中一致性的数量。这将受到您链接到多少Swift库以及您在自己的代码中包含多少一致性的影响。<code class="du jw jx jy jz b">otool -l Helix.app/Helix | | grep _swift5_proto -A 4</code>告诉我们优步的应用程序有一个411200字节的协议一致性部分。每4个字节是一个相对指针，所以411200/4 = 102800个一致性。基于此，我实验的测试平台是一个100k一致性的应用程序。这些类是编码的，每个都符合相同的协议。所有测试都是在运行iOS 15.1的iPhone 7上进行的</p><p id="2d13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试1:第一次一致性检查第一次执行一致性检查时，包含协议运行时元数据的应用程序二进制文件部分的所有虚拟内存都需要分页。对于100k一致性来说，这是一个巨大的成本，并且使得第一次一致性检查慢得多，在我的测试中大约20毫秒。</p><p id="c813" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试2:高速缓存未命中如果第二次一致性检查是针对新类型的，则它将未被高速缓存，并且仍然需要完全扫描一致性，但是这一次它不会导致任何页面错误。在我的测试中，这花费了大约3.8毫秒。这可能看起来不多，但它已经是60fps设备上帧之间16毫秒的23%。当执行多个未缓存的协议检查时，这些会增加大量的时间。</p><p id="1bbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试3:缓存命中为了测量<code class="du jw jx jy jz b">ConcurrentReadableHashMap</code>的时间，我们简单地在一个循环中做同样的<code class="du jw jx jy jz b">as?</code>操作，并平均它所花费的时间。正如所料，它非常快，大约0.0004毫秒。一旦缓存被填充，协议一致性检查就不是性能的主要瓶颈，这就是为什么当缓存为空时，在应用程序启动期间会特别成问题。</p><p id="c826" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试4:否定结果为每个一致性运行的运行时循环有一个<a class="ae jo" href="https://github.com/apple/swift/blob/aec4ec4c4a0f647ae6670745cd389aba767f3111/stdlib/public/runtime/ProtocolConformance.cpp#L936" rel="noopener ugc nofollow" target="_blank">早期返回</a>，如果被检查的协议不等于一致性记录中的协议，它可以避免大部分工作。为了测试这一点的影响，我测量了在一个协议上运行一致性检查所需的时间，该协议与我生成的100k个类不一致。这仍然花费了相当长的时间，0.9毫秒，但是这个最佳情况时间是之前最差情况的时间。</p><p id="419a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些测试为您将看到的协议一致性检查的变化提供了一些见解，但为了真正了解它们的影响，我从app store上传了几个大型Swift应用程序到Emerge，并使用倒置的flamegraph视图来大致估计应用程序启动期间检查协议一致性所花费的时间。优步、DoorDash和Grab等应用的一致性检查持续超过100毫秒。</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/9f7a240de16bc3382d8a1af131240fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5q63BR6h7cFA-_WfkWE8Qg.png"/></div></div></figure><h1 id="3f7b" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">这是什么时候发生的？</h1><p id="5e68" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">我们已经看到，当执行<code class="du jw jx jy jz b">as?</code>操作时，应用程序为缓慢的一致性查找付出了代价，但是使用<code class="du jw jx jy jz b">as!</code>也会遇到同样的性能损失。当您使用<code class="du jw jx jy jz b">as!</code>时，Swift会验证是否满足协议，并总是中止或继续。</p><p id="92f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">泛型类型元数据是协议一致性检查的另一个来源。您将会遇到代码如下所示的一致性查找:</p><pre class="kb kc kd ke fd li jz lj lk aw ll bi"><span id="e1fc" class="lm kg ht jz b fi ln lo l lp lq"><strong class="jz hu">class</strong> <strong class="jz hu">Test</strong>&lt;<strong class="jz hu">T</strong>: <strong class="jz hu">Decodable</strong>&gt; {}<br/><strong class="jz hu">let</strong> _ = Test&lt;Int&gt;.<strong class="jz hu">self</strong></span></pre><p id="f429" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Joe Groff在<a class="ae jo" href="https://forums.swift.org/t/understanding-code-that-leads-to-swift-checkgenericrequirements-calls/35128" rel="noopener ugc nofollow" target="_blank">这个线程</a>中解释说，Swift从二进制文件中一个损坏的名称中为该类型生成运行时元数据。这种分离需要一致性查找。您可以在Swift应用程序启动中经常看到这种堆栈跟踪，下面是一个通过Emerge Tool的应用程序启动工具启动Slack应用程序的示例:</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/e0f9a09bb8b7e11c7214f0712c36df3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTBVDAftwE76Z5uB9BQ0DA.png"/></div></div></figure><p id="8f26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JSON解码和字符串插值都会导致<code class="du jw jx jy jz b">as?</code>操作。字符串插值调用<a class="ae jo" href="https://github.com/apple/swift/blob/85d9507fde3deb5889f71f81f09a05319898b029/stdlib/public/core/OutputStream.swift#L404" rel="noopener ugc nofollow" target="_blank"> _print_unlocked </a>，它有3个一致性检查并使用<code class="du jw jx jy jz b">Mirror</code>，在内部执行更多的一致性检查。这种综合效应对应用程序的性能是一个巨大的打击。</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="7795" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">帮助提高应用性能的策略</h1><p id="12e0" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">通过协议一致性检查提高app性能的两种方法是最小化一致性和<code class="du jw jx jy jz b">as?</code>操作的数量。Emerge Tool的应用程序大小分析可以帮助解决这两个问题。众所周知，应用程序的大小是应用程序质量的一个主要指标，这一点在协议一致性案例中得到了清晰的证明。通过关注二进制文件大小的减少，你将从你的应用中移除一致性，并使运行速度更快。</p><p id="0268" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你的应用程序中，一个唾手可得的结果就是删除那些只用于在单元测试中提供存根实现的协议。这些可以从应用程序的发布版本中编译出来，以避免它们包含在运行时元数据中。</p><blockquote class="jp jq jr"><p id="b822" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><strong class="is hu">提示:</strong>在Objective-C领域，今年早些时候有一个属性被添加到clang中<code class="du jw jx jy jz b">objc_non_runtime_protocol</code>，它指示编译器不要为协议发出任何元数据。如果您知道该协议只在编译时使用，这将减少应用程序的大小并提高运行时性能。更多细节可参见<a class="ae jo" href="https://clang.llvm.org/docs/AttributeReference.html#objc-non-runtime-protocol" rel="noopener ugc nofollow" target="_blank">属性参考</a>。</p></blockquote><p id="85dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Instruments或Emerge startup time visualization等工具分析应用程序，可以帮助您识别应用程序中最常使用一致性检查的位置。然后你可以重构代码来完全避免它们。考虑这些例子:</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="cc04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第二种情况下，只要编译器知道调用点的事件类型，它就会完全避免动态强制转换。</p><p id="b992" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个具体的例子，<a class="ae jo" href="https://github.com/noahsmartin/lottie-ios/commit/3d3deed0d47f2c10abebdc029c41168b4c9f9f88" rel="noopener ugc nofollow" target="_blank">这个提交</a>重写了动画框架Lottie中的一小部分代码，以避免22个可能的一致性检查。有11种动画节点类型，根据加载的动画类型，每种类型都可以使用2种协议进行检查。这种改变很容易绕过动态强制转换，允许编译器保证协议一致性。</p><h1 id="2477" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">实现更快的运行时</h1><p id="bb6e" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">在最底层，app二进制文件将协议一致性存储在一个列表中，因此如果不对整个列表进行O(n)扫描，就无法进行完整的一致性检查。然而，这并不意味着我们不能将列表转换成更适合我们需求的数据结构。由于协议一致性检查占用了如此多的应用程序启动时间，我们可以完全绕过运行时，制作我们自己的数据结构，以实现更快的一致性检查。这就是我们所做的。</p><p id="4d5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">zconform背后的概念是急切地加载所有可能的协议一致性，并将它们存储在由内存中的协议地址控制的映射中。每个条目的值是保存所有符合类型的地址的集合。如果在缓存中没有找到给定的类型，我们知道一致性不可能成功，可以在没有<code class="du jw jx jy jz b">as?</code>操作符的情况下提前返回<code class="du jw jx jy jz b">nil</code>。</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="0c8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Zconform初始化使用<code class="du jw jx jy jz b">getsectiondata</code>为每个mach-o映像检索<code class="du jw jx jy jz b">TEXT.__swift5_proto</code>的地址和大小，然后按照指针链构建一个<code class="du jw jx jy jz b">unordered_map</code>作为缓存。</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="f610" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了检查一致性，使用unsafeBitCast将输入类型转换为它们的运行时表示。通过检查swift ABI可以找到这些类型在内存中的表示，例如<a class="ae jo" href="https://github.com/apple/swift/blob/e65ae80172ade4120ef51c100e1a69026866936e/include/swift/ABI/Metadata.h#L2059" rel="noopener ugc nofollow" target="_blank">ExistentialTypeMetadata</a>。由于您可以编写像<code class="du jw jx jy jz b">typealias MultipleProtocols = MyProtocol1 &amp; MyProtocol2</code>这样的协议，我们循环检查协议一致性的数量，并验证每一个。[3]</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="3c65" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子中省略了一些细节，但是这些都可以在<a class="ae jo" href="https://github.com/EmergeTools/zconform/blob/main/ZConformDemo/ZConform/ZConform.swift#L107" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>中找到。</p><p id="bd73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的基准测试显示，构建这个缓存需要3毫秒的开销。如果您的使用模式与这里优化的相匹配，许多一致性检查可能会导致<code class="du jw jx jy jz b">nil</code>，它可以完全消除我们之前测量的<code class="du jw jx jy jz b">as?</code>的最坏情况3.8毫秒。该项目是一个概念验证，仍然有一些功能是全面推广所必需的。它只支持检查结构与非类绑定协议的一致性。</p><p id="4820" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">支持更多的情况下可以添加，如果你有兴趣使用这个为你的应用程序你可以</em> <a class="ae jo" href="mailto:team@emergetools.com" rel="noopener ugc nofollow" target="_blank"> <em class="js">取得联系</em> </a> <em class="js">与</em> <a class="ae jo" href="https://emergetools.com" rel="noopener ugc nofollow" target="_blank"> <em class="js">涌现</em> </a> <em class="js">团队。</em></p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="42c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]符号<a class="ae jo" href="https://en.wikipedia.org/wiki/Name_mangling" rel="noopener ugc nofollow" target="_blank">名称变换</a>将人类可读的功能名称转换为存储在二进制符号表中的格式。</p><p id="6b50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2]当我们构建自己的一致性检查函数时，会有更多关于运行时元数据布局的细节，但如果你对二进制文件中元数据的所有细节感兴趣，请查看Scott Knight 的这篇<a class="ae jo" href="https://knight.sc/reverse%20engineering/2019/07/17/swift-metadata.html" rel="noopener ugc nofollow" target="_blank">帖子。</a></p><p id="3851" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[3]关于这些运行时元类型的介绍以及存在和协议之间的区别，请参见Bruno Rocha的<a class="ae jo" href="https://swiftrocks.com/whats-type-and-self-swift-metatypes" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p></div></div>    
</body>
</html>
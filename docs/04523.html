<html>
<head>
<title>Revisiting the “Back-Burner” Fundamentals in Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新审视编程中的“次要”基础知识</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/revisiting-the-back-burner-fundamentals-in-programming-6f5282759f1c?source=collection_archive---------63-----------------------#2021-06-28">https://medium.com/geekculture/revisiting-the-back-burner-fundamentals-in-programming-6f5282759f1c?source=collection_archive---------63-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="66a0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个新来者试图向其他新来者解释令人困惑的不变状态概念</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d646659ad6910b7c8284163b88b61c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KdD6ufg-d9cUkFpr.jpg"/></div></div></figure><p id="ffb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在为期六个月的密集编码训练营中，你可能会得到很多信息。这些信息中的大部分可以被归类为我喜欢称之为“次要知识”的东西，或者是被提出的基本概念或想法——通常是仓促或随意的——也需要大量的研究才能完全理解。因为一周只有这么几个小时，这些概念被认为是真理，然后很快就被扔到众所周知的“次要”位置，留待以后或更晚的时候研究。</p><p id="4bb5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，当我结束了我的课程作业，开始应对繁重的求职工作的有点可怕的前景时，我开始重新审视这些核心的基本原则，以努力在我遇到的任何潜在面试中看起来不那么白痴。</p><p id="b9b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们课程的最后阶段涵盖了React和Redux，这两个非常流行的Javascript库用于构建智能、快速和可靠的web应用程序。</p><p id="eeff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我已经在另一篇关于普通Javascript的博文中提到了状态的概念。现在回顾它的简单性时，我真的笑了，但可以说React和Redux将状态管理带到了一个全新的水平，特别是当它涉及到Redux及其存储时，包含了应用程序的整个状态树，如果你选择使用它的话。</p><p id="6c81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kg">我应该注意，Redux并不总是必要的，尤其是对于较小的web应用程序。参考</em> <a class="ae kf" rel="noopener" href="/@dan_abramov/you-might-not-need-redux-be46360cf367"> <em class="kg">这篇短文</em> </a> <em class="kg">了解更多关于那个主题的内容。</em></p><p id="6080" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我第一次了解Redux存储时，我被告知，对所述存储的任何更新(通过reducers)都必须以不可变的方式完成。<em class="kg">嗯……我想知道为什么，</em>我想，我很快在谷歌上搜索了不可变状态和可变状态。搜索结果让我比一个容易拖延的厨师更快地将整个想法抛到了脑后。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="bed0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要理解的东西太多了，而且没有足够的时间在不影响我其余研究的情况下深入研究不变性的好处。直到现在…</p><p id="61a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我对React/Redux中不可变状态的困惑与一个简单的问题有关:“为什么我们实际上关心我们是否在应用程序中改变Redux状态？”</p><p id="984d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">毕竟这不正是我们想要做的吗？我们希望通过reducers以某种方式改变Redux存储的值。既然我们可以省去中间人，为什么还要复制原始状态呢？改变原始状态不会提高我们应用程序的性能吗？</p><p id="af68" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">事实证明，情况恰恰相反。为了理解这一点，你必须理解大多数程序员所说的<strong class="jl hj">浅层和深层相等检查之间的区别。</strong></p><p id="485b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为这是一篇为像我这样的初学者写的博文，所以我只想说浅层等式检查(Redux用来比较原始状态对象和reducers返回的新对象的那种检查)的内存效率更高。下面的图片直接取自Redux的官方文档，在解释这种差异方面比我做得更好。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kj"><img src="../Images/2df345039279f559196f1059a53483ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0Ks_2vi0j1-3CPeBlAFHA.png"/></div></div></figure><p id="08f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，每个从reducer新返回的对象都返回一个唯一的状态“片”,它决定了您的组件是否需要基于浅层相等检查重新呈现。</p><p id="6874" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">返回新的状态片段还具有更安全的额外好处，因为您不会完全覆盖对应用程序的其他领域至关重要的数据。这种实践还可以防止bug，并创建一个变更的“时间线”,以便您可以梳理Redux存储状态的跟踪变更历史。谈个三赢！</p><p id="0567" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我强烈建议您通过访问<a class="ae kf" href="https://redux.js.org/faq/immutable-data#what-are-the-benefits-of-immutability" rel="noopener ugc nofollow" target="_blank">这个链接来看看Redux中不变性好处的完整文档页面。</a></p><p id="57b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我在虚构的穿越太阳系的旅行社Flatiron School的最后一个项目使用了一个reducer，它通过使用JavaScript的spread运算符返回新对象，这是返回新对象而不改变原始状态的几种方法之一。</p><p id="b3eb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下是所述减速器的屏幕截图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/758c80f63ed216c8984cc64e90964904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1IIRoZ7kVAt3AKFUWCYOg.png"/></div></div></figure><p id="5f12" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从Redux存储中返回一个全新的状态对象还有很多其他方法，包括稍微老一点但不太流行的Object.assign()方法，以及通过使用。用于返回新的、经过筛选的数组的filter方法。这完全取决于你到底想要完成什么。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="a92d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我回顾我刚刚在熨斗学校完成的半年旅程时，我开始意识到一个业余程序员总会遇到一些想法或概念，需要大量的作业才能完全理解。</p><p id="51fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">说实话，我仍然没有完全掌握我在这篇文章中触及的概念，如果你也没有也没关系！至关重要的是，你要继续深入学习那些在学习时被“搁置”的教育领域，无论需要多少次都要重新审视，以理解更复杂的编程基础。</p></div></div>    
</body>
</html>
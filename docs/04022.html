<html>
<head>
<title>Identity in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的身份</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/identity-in-swiftui-6aacf8f587d9?source=collection_archive---------9-----------------------#2021-06-20">https://medium.com/geekculture/identity-in-swiftui-6aacf8f587d9?source=collection_archive---------9-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/c2b8ebc48715e2f93d1fc29d9227c02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cPiTIGf-tnUzbDp-"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6320" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">视图的身份在管理SwiftUI视图生命周期中起着重要的作用。每个视图都有自己的特性。它可以显式给出，也可以从结构布局中获取。</p><p id="5b49" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在UIKit/APPKit中，每个视图都有指针标识，因为它们是引用类型。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kb"><img src="../Images/9ca37702620ebb06c40acfbbfb23190c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7GAFHLvELkWJi-8ZxjR5A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Source: https://developer.apple.com/wwdc21/10022</figcaption></figure><p id="55f3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">但是SwiftUI中的视图是值类型。SwiftUI中视图的身份有两种类型。他们是</p><ol class=""><li id="246b" class="kc kd hi jf b jg jh jk jl jo ke js kf jw kg ka kh ki kj kk bi translated">结构同一性</li><li id="4866" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">显式身份</li></ol><h1 id="ec23" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结构同一性</h1><p id="ca49" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">SwiftUI中的每个视图都有自己的身份。如果没有显式给出视图的标识，则SwiftUI会根据其在视图层次结构中的位置给出一个标识。让我们考虑一个有条件变化的观点。</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="9852" class="ly kr hi lu b fi lz ma l mb mc"><strong class="lu hj">struct</strong> TestingStructuralIdentity: View {</span><span id="fab9" class="ly kr hi lu b fi md ma l mb mc">@State <strong class="lu hj">var</strong> changeView = <strong class="lu hj">false</strong></span><span id="4ff3" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  var</strong> body: <strong class="lu hj">some</strong> View {</span><span id="3ef4" class="ly kr hi lu b fi md ma l mb mc">    VStack {</span><span id="4aea" class="ly kr hi lu b fi md ma l mb mc">      Button {</span><span id="026d" class="ly kr hi lu b fi md ma l mb mc">        changeView.toggle()</span><span id="066e" class="ly kr hi lu b fi md ma l mb mc">      } label: {</span><span id="a260" class="ly kr hi lu b fi md ma l mb mc">        Text("Change View")</span><span id="ff5a" class="ly kr hi lu b fi md ma l mb mc">      }.buttonStyle(.bordered)</span><span id="1c5d" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">      if</strong> changeView {</span><span id="ff3d" class="ly kr hi lu b fi md ma l mb mc">        Text("View 1")</span><span id="1ec4" class="ly kr hi lu b fi md ma l mb mc">     } <strong class="lu hj">else</strong> {</span><span id="8735" class="ly kr hi lu b fi md ma l mb mc">        Text("View 2")</span><span id="6993" class="ly kr hi lu b fi md ma l mb mc">     }</span><span id="1573" class="ly kr hi lu b fi md ma l mb mc">    }</span><span id="24ed" class="ly kr hi lu b fi md ma l mb mc">  }</span><span id="2016" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="b371" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在上面的例子中，每次changeView切换时，一个新的文本视图会以新的身份创建。让我们以保留文本视图身份的方式重写上面的代码。</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="e0e8" class="ly kr hi lu b fi lz ma l mb mc"><strong class="lu hj">struct</strong> TestingStructuralIdentity: View {</span><span id="0974" class="ly kr hi lu b fi md ma l mb mc">@State <strong class="lu hj">var</strong> changeView = <strong class="lu hj">false</strong></span><span id="7e3c" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  var</strong> body: <strong class="lu hj">some</strong> View {</span><span id="4c98" class="ly kr hi lu b fi md ma l mb mc">    VStack {</span><span id="c798" class="ly kr hi lu b fi md ma l mb mc">      Button {</span><span id="af96" class="ly kr hi lu b fi md ma l mb mc">        changeView.toggle()</span><span id="bf3c" class="ly kr hi lu b fi md ma l mb mc">      } label: {</span><span id="8bbb" class="ly kr hi lu b fi md ma l mb mc">        Text("Change View")</span><span id="0734" class="ly kr hi lu b fi md ma l mb mc">      }.buttonStyle(.bordered)</span><span id="df24" class="ly kr hi lu b fi md ma l mb mc">      Text(changeView ? "View 1" : "View 2")</span><span id="c7bf" class="ly kr hi lu b fi md ma l mb mc">    }</span><span id="f2b5" class="ly kr hi lu b fi md ma l mb mc">  }</span><span id="d1fe" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="b628" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在每次changeView切换时重写的代码中，只有显示内容发生变化，而视图不会每次都被创建。</p><p id="30d3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">创建具有稳定身份的视图有助于围绕您的视图创建漂亮的动画。</p><h1 id="dcce" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">显式身份</h1><p id="f3bb" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">与结构化标识不同，SwiftUI视图可以使用id()创建显式标识。我们用来给出显式标识的最常见的情况是使用ForEach。</p><p id="fded" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">很多时候，当我们需要用ForEach显示字符串列表时，我们可以简单地编写</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="21e2" class="ly kr hi lu b fi lz ma l mb mc">List(0..&lt;list.count) {(l) <strong class="lu hj">in</strong></span><span id="fa97" class="ly kr hi lu b fi md ma l mb mc">    Text(list[l])</span><span id="5cfb" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="0a4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">但是从SwiftUI 3.0开始，我们不能使用非常数范围，我们需要在上面明确指定身份以进行无声警告</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="8b0c" class="ly kr hi lu b fi lz ma l mb mc">List(0..&lt;list.count, id: \.self) {(l) <strong class="lu hj">in</strong></span><span id="973a" class="ly kr hi lu b fi md ma l mb mc">   Text(list[l])</span><span id="22f1" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="2f3b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这看起来不错，但是让我们理解为什么identity在使用ForEach创建视图列表中起着重要的作用。</p><p id="1ef7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为此，我们创建了一个带有字符串列表的视图，该列表随着用户交互而变化。然后，我们将字符串映射到一个新的值类型，该值类型除了字符串之外还具有标识。从这里开始，我们使用不同的标识符进行测试，例如索引、随机标识符和自定义序列号。然后，我们测试在所有场景中向列表添加一个新值。</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="db47" class="ly kr hi lu b fi lz ma l mb mc"><strong class="lu hj">//StringWithId value type holds identity for every string</strong></span><span id="c191" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">struct</strong> StringWithId: Identifiable {</span><span id="04cd" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  let</strong> string: String</span><span id="b7a6" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  let</strong> id: String</span><span id="71a1" class="ly kr hi lu b fi md ma l mb mc">}</span><span id="d144" class="ly kr hi lu b fi md ma l mb mc">/// extension to map array of strings to custom stringWithID objects</span><span id="e802" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">extension</strong> Array <strong class="lu hj">where</strong> Element == String {</span><span id="7c31" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj"> func</strong> customStringMapper() -&gt; [StringWithId] {</span><span id="cea0" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">   var</strong> stringsWithId = [StringWithId]()</span><span id="e379" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">   for</strong> (i,string) <strong class="lu hj">in</strong> <strong class="lu hj">self</strong>.enumerated() {</span><span id="bf26" class="ly kr hi lu b fi md ma l mb mc">     stringsWithId.append(StringWithId(string: string, id: "\(i)"))</span><span id="082a" class="ly kr hi lu b fi md ma l mb mc">   }</span><span id="4c94" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">   return</strong> stringsWithId</span><span id="8338" class="ly kr hi lu b fi md ma l mb mc"> }</span><span id="6654" class="ly kr hi lu b fi md ma l mb mc">}</span><span id="0f83" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">struct</strong> ListView: View {</span><span id="2993" class="ly kr hi lu b fi md ma l mb mc">@State <strong class="lu hj">var</strong> list = ["Apple","Mango","orange"]</span><span id="ca3d" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  var</strong> body: <strong class="lu hj">some</strong> View {</span><span id="4df0" class="ly kr hi lu b fi md ma l mb mc">    NavigationView {</span><span id="d89c" class="ly kr hi lu b fi md ma l mb mc">     List {</span><span id="f63e" class="ly kr hi lu b fi md ma l mb mc">        ForEach(list.customStringMapper(), id: \.id) {(fruit) <strong class="lu hj">in</strong></span><span id="662d" class="ly kr hi lu b fi md ma l mb mc">            Text(fruit.string)</span><span id="9a23" class="ly kr hi lu b fi md ma l mb mc">        }</span><span id="3789" class="ly kr hi lu b fi md ma l mb mc">     }.listStyle(InsetGroupedListStyle())</span><span id="bb7f" class="ly kr hi lu b fi md ma l mb mc">     .toolbar {</span><span id="3e0e" class="ly kr hi lu b fi md ma l mb mc">       ToolbarItem(placement: .navigationBarTrailing) {</span><span id="b73e" class="ly kr hi lu b fi md ma l mb mc">         Button {</span><span id="90d7" class="ly kr hi lu b fi md ma l mb mc">            withAnimation {</span><span id="2174" class="ly kr hi lu b fi md ma l mb mc">               list.append("heelo")</span><span id="7cae" class="ly kr hi lu b fi md ma l mb mc">            }</span><span id="f5de" class="ly kr hi lu b fi md ma l mb mc">         } label: {</span><span id="9426" class="ly kr hi lu b fi md ma l mb mc">              Image(systemName: "plus")</span><span id="ec56" class="ly kr hi lu b fi md ma l mb mc">         }</span><span id="c957" class="ly kr hi lu b fi md ma l mb mc">     }}</span><span id="fef1" class="ly kr hi lu b fi md ma l mb mc">   }</span><span id="1ab9" class="ly kr hi lu b fi md ma l mb mc"> }</span><span id="f4f1" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="51de" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在上面的例子中，如果我们在列表中添加了一个新的条目，那么列表中的所有视图都会被重新创建，因为每个视图的标识都会随着UUID()而动态变化。这工作完美，但结果出乎意料的动画。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es me"><img src="../Images/7aaff6eed0bd5fbd97d18eb5ed94c86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*IH0mO6Edh2t22hhph0gDXw.gif"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">using UUID as identifier</figcaption></figure><p id="f456" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">相反，我们用字符串索引创建标识，</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="b1f8" class="ly kr hi lu b fi lz ma l mb mc">// Maps list of strings to list of StringWithId</span><span id="f3de" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">func</strong> customStringMapper() -&gt; [StringWithId] {</span><span id="8ef4" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  var</strong> stringsWithId = [StringWithId]()</span><span id="40d0" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  for</strong> (i,string) <strong class="lu hj">in</strong> self.enumerated() {</span><span id="fde2" class="ly kr hi lu b fi md ma l mb mc">   stringsWithId.append(StringWithId(string: string, id: <br/>       "\(i)"))</span><span id="09a6" class="ly kr hi lu b fi md ma l mb mc">  }</span><span id="8fe9" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  return</strong> stringsWithId</span><span id="8865" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="642b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这种情况下，视图具有稳定的身份。每个对象都有自定义的序列号，这很好。</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="3484" class="ly kr hi lu b fi lz ma l mb mc">// Maps list of strings to list of StringWithId</span><span id="40a0" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">func</strong> customStringMapper() -&gt; [StringWithId] {</span><span id="d992" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  var</strong> stringsWithId = [StringWithId]()</span><span id="012d" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  for</strong> (i,string) <strong class="lu hj">in</strong> self.enumerated() {</span><span id="4429" class="ly kr hi lu b fi md ma l mb mc">  stringsWithId.append(StringWithId(string: string, id: <br/>       "\(i)-\(string)"))</span><span id="9ff4" class="ly kr hi lu b fi md ma l mb mc">  }</span><span id="7e5d" class="ly kr hi lu b fi md ma l mb mc"><strong class="lu hj">  return</strong> stringsWithId</span><span id="d66e" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="326e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第二种和第三种情况都有流畅的动画效果。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es me"><img src="../Images/bfab060dbe1d7234b7e4a6cf576e133b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gjlNsokAxECDcyeVZUi3bw.gif"/></div><figcaption class="iy iz et er es ja jb bd b be z dx">using custom serial number as identifier</figcaption></figure><p id="f68c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在现实世界的场景中，如果我们只想显示字符串而不需要任何用户交互，那么下面的方法就可以了。</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="342a" class="ly kr hi lu b fi lz ma l mb mc">List(0..&lt;list.count, id: \.self) {(l) <strong class="lu hj">in</strong></span><span id="b811" class="ly kr hi lu b fi md ma l mb mc">  Text(list[l])</span><span id="98a2" class="ly kr hi lu b fi md ma l mb mc">}</span></pre><p id="d4f0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最好设计具有稳定标识符的真实对象，这样有助于管理视图的生命周期。例如，每个核心数据对象都有唯一的标识符。</p><p id="d6bf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有关View的生命周期和最佳实践的更多信息，请参考本次WWDC <a class="ae jc" href="https://developer.apple.com/wwdc21/10022" rel="noopener ugc nofollow" target="_blank">演讲</a></p><p id="ead8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">感谢阅读..))</p></div></div>    
</body>
</html>
<html>
<head>
<title>Battle of the iOS Architecture Patterns: Model View Presenter (MVP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS架构模式之战:模型视图演示者(MVP)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e?source=collection_archive---------10-----------------------#2021-05-17">https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e?source=collection_archive---------10-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cd8a2069b484dacd489a362a64b78b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ak_W_ee9OjC3SmenUpaOzQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Architecture Series — Model View Presenter (MVP)</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="fbfd" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">动机</h1><p id="1c23" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在开始开发一个iOS应用之前，我们必须考虑项目的结构。我们需要考虑如何将这些代码添加到一起，以便它们在以后有意义——当我们回来重新访问应用程序的一部分时——以及如何与其他开发人员形成已知的“语言”。</p><p id="9f83" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在本系列的第三篇文章中，我们将在MVP中改造MVVM应用程序。像往常一样，我们将看到如何将模式应用到每个屏幕，看到实际的实现和源代码。最后，我们将展示构建时间，并详细说明与其他架构模式相比，MVP的一些关键观察结果。</p><p id="fd72" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果你只是想看代码，可以跳过这篇文章。代码可以在GitHub 上开源获得。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="656e" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">为什么你的iOS应用需要一个架构模式？</h1><p id="77e0" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最需要考虑的是要有一个可维护的app。你知道视图在那里，这个视图控制器应该做X而不是y。更重要的是，其他人也知道。</p><p id="e7df" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">以下是选择一个好的架构模式的一些优势:</p><ul class=""><li id="2fec" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">更易于维护</li><li id="0175" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">更容易测试业务逻辑</li><li id="33b5" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">与其他队友发展共同语言</li><li id="17dd" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">分离实体的职责</li><li id="dedb" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">更少的错误</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="e20d" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">定义需求</h1><p id="98de" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">给定一个有六七个屏幕的iOS应用程序，我们将使用iOS世界最流行的架构模式来开发它:MVC、MVVM、MVP、VIPER、VIP和Coordinators。</p><p id="59bc" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">该演示应用程序名为Football Gather，是朋友们跟踪业余足球比赛比分的一种简单方式。</p><h2 id="270e" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">主要特征</h2><p id="3cb3" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">能够:</p><ul class=""><li id="53f0" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">在应用程序中添加玩家</li><li id="3233" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">给运动员分配队伍</li><li id="c2b8" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">编辑玩家</li><li id="0e5e" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">为比赛设置倒计时</li></ul><h2 id="1037" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">屏幕模型</h2><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/0ccdbaa0ea60ed99f4b23a862c965b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpEd0oX8fKQqSVetSiT03A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Screen mockups of “Football Gather”, the iOS app</figcaption></figure><h2 id="4fef" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">后端</h2><p id="fbc3" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">该应用由在<a class="ae lc" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank"> Vapor web框架</a>中开发的web应用提供支持。可以查看我的<a class="ae lc" href="https://www.radude89.com/blog/vapor.html" rel="noopener ugc nofollow" target="_blank"> Vapor 3初始篇</a>和<a class="ae lc" href="https://www.radude89.com/blog/migrate-to-vapor4.html" rel="noopener ugc nofollow" target="_blank">篇关于迁移到Vapor 4 </a>的app。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="b605" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">什么是MVP</h1><p id="7532" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">MVP和MVVM有些相似，但是有一些关键的地方:</p><ul class=""><li id="6eda" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">您现在有一个演示者层。</li><li id="e156" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">您可以从演示者层控制视图。</li></ul><h2 id="ddfb" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">模型</h2><ul class=""><li id="d9ae" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">模型层与其他层完全一样，用于封装业务数据。</li><li id="7b95" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">是负责域数据的接口。</li></ul><p id="a0fb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">通讯</strong></p><ul class=""><li id="c75b" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">当视图层中发生一些事情时，例如当用户发起一个动作时，它会通过表示器传递给模型。</li><li id="623a" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">当模型改变时，例如，当新的数据变得可用，我们需要更新UI时，演示者更新视图。</li></ul><h2 id="6b64" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">视角</h2><ul class=""><li id="d156" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">视图层与MVVM中的相同，但是视图现在缺少更新其状态的责任。演示者拥有视图..</li></ul><p id="b70a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">通信</strong></p><ul class=""><li id="3d2b" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">视图不能直接与模型交流，一切都是通过演示者完成的。</li></ul><h2 id="d846" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">提出者</h2><ul class=""><li id="64fb" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">负责处理来自视图的事件，并用模型触发适当的事件。</li><li id="2413" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">将视图与模型连接起来，但不在视图中添加任何逻辑。</li><li id="33a4" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">对视图有1:1的映射。</li></ul><p id="eef8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">沟通</strong></p><ul class=""><li id="5616" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">可以与模型和视图/视图控制器这两个层通信。</li><li id="9518" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">视图更新将由演示者完成。</li><li id="7c5e" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">当数据改变时，它确保那些改变被传达给用户界面，更新视图。</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="45cb" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">何时使用MVP</h1><p id="56b0" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当你觉得MVC和MVVM不太适合你的用例时，就使用它。你想让你的应用更加模块化，增加你的代码覆盖率。当你是一个初学者或者你没有太多的iOS开发经验时，不要使用它。<br/>做好多写代码的准备。</p><p id="4915" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">对于我们的应用程序，我们将<strong class="kb hj">视图</strong>层分成两个组件:<strong class="kb hj">视图控制器</strong>和实际的<strong class="kb hj">视图</strong>。<br/><strong class="kb hj">视图控制器</strong>充当协调器/路由器，并保存对视图的引用，通常设置为<code class="du mn mo mp mq b">IBOutlet</code></p><h2 id="2a08" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">优势</h2><ul class=""><li id="fc48" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">层的分离比在其他模式中更好。</li><li id="ff88" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">我们可以测试大部分业务逻辑。</li></ul><h2 id="278a" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">不足之处</h2><ul class=""><li id="f38e" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">装配问题在MVP中表现得更加突出。最有可能的是，你将不得不引入一个路由器或者一个协调器来处理导航和模块组装。</li><li id="6734" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">有一个风险是，你的演讲者会变成一个庞大的班级，因为他有更多的责任。</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="b5d7" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">适用于我们的准则</h1><p id="d121" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们需要做两大步骤:</p><ol class=""><li id="e416" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw mr lj lk ll bi translated">逐一浏览视图模型，并让他们成为演示者</li><li id="da17" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw mr lj lk ll bi translated">将视图与ViewController分开</li></ol><p id="11c6" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">应用的MVP模式详述如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="d204" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated"><code class="du mn mo mp mq b">LoginPresenter</code></h2><p id="a5f4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">让我们看看<code class="du mn mo mp mq b">LoginPresenter</code>是什么样子的:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="5f30" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">所有参数将通过初始化器注入。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="88eb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">钥匙圈互动的定义如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="56ab" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们有两种服务:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="feed" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">注册功能与登录功能基本相同:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="8126" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">LoginView</code>有以下协议:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="a84c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">大多数<strong class="kb hj">视图控制器</strong>逻辑现在都在<strong class="kb hj">视图</strong>中。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="ce1c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，<strong class="kb hj">视图控制器</strong>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="5aca" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们一个屏幕接一个屏幕，把现有的MVVM建筑变成一个MVP。</p><h2 id="02d4" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated"><code class="du mn mo mp mq b">PlayerListPresenter</code></h2><p id="be82" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">下一个屏幕是<strong class="kb hj"> PlayerList </strong>，我们从web API调用开始:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="8f64" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在，对playe删除的检查是在<strong class="kb hj">演示器</strong>中进行的，而不是在<strong class="kb hj">视图/视图控制器</strong>中。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="f39d" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果我们在<code class="du mn mo mp mq b">PlayerListView</code>中查看表格视图的数据源方法，我们会发现<strong class="kb hj">呈现者</strong>的行为与<strong class="kb hj">视图模型</strong>完全相同:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="2605" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerListViewController</code>现在更像是编辑、确认和添加屏幕之间的路由器。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="2629" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj"> PlayerList </strong>模块分为以下几个部分。</p><p id="cbe4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerListViewController</code>职责:</p><ul class=""><li id="8ae7" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">正在执行<code class="du mn mo mp mq b">PlayerListTogglable</code>协议，以在采集完成时返回到<code class="du mn mo mp mq b">listView</code>模式状态(从<code class="du mn mo mp mq b">GatherViewController</code>调用)。</li><li id="3560" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">保持一个<code class="du mn mo mp mq b">IBOutlet</code>到<code class="du mn mo mp mq b">PlayerListView</code>。</li><li id="42b2" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">它设置演示者、视图代表并告诉视图进行设置。</li><li id="d828" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">处理导航逻辑，并为编辑、添加和确认屏幕构建模型。</li><li id="90ff" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">执行<code class="du mn mo mp mq b">PlayerListViewDelegate</code>并执行以下操作:</li><li id="cc0c" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">当视图请求更改标题时更改标题(<code class="du mn mo mp mq b">func didRequestToChangeTitle(_ title: String</code>)。</li><li id="5739" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">添加右侧导航栏按钮项(<strong class="kb hj">选择</strong>或<strong class="kb hj">取消</strong>选择玩家)</li><li id="d123" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">使用<strong class="kb hj">表示器</strong>中构建的标识符执行适当的序列。</li><li id="9a7b" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">显示一个带有标题和消息的简单警报(例如，当服务失败时)</li><li id="e615" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">显示删除确认警报。</li><li id="b2d5" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">通过实现<code class="du mn mo mp mq b">PlayerDetailViewControllerDelegate</code>，当一个玩家被编辑时，它告诉<strong class="kb hj">视图</strong>刷新。</li><li id="4ef3" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">对于<code class="du mn mo mp mq b">AddPlayerDelegate</code>也是如此，这里，它告诉<strong class="kb hj">视图</strong>再次加载玩家列表。</li></ul><p id="f826" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerListView</code>职责:</p><ul class=""><li id="c7b5" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">公开公共API，<code class="du mn mo mp mq b">PlayerListViewProtocol</code>。这一层要尽量哑，不做复杂的事情。</li></ul><p id="4490" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerListPresenter</code>职责:</p><ul class=""><li id="dc19" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">在第一眼看到<code class="du mn mo mp mq b">PlayerListPresenterProtocol</code>时，我们注意到它做了很多事情。</li><li id="cba8" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">公开<strong class="kb hj">视图</strong>所需的方法，如<code class="du mn mo mp mq b">barButtonItemTitle</code>、<code class="du mn mo mp mq b">barButtonItemIsEnabled</code>等。</li></ul><p id="94b8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerListViewState</code>职责:</p><ul class=""><li id="a1bb" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">我们决定将<code class="du mn mo mp mq b">ViewState</code>提取到一个新文件中，保持我们在MVVM时的相同功能，使用工厂方法模式来分配<code class="du mn mo mp mq b">PlayerListView</code>的不同状态。</li></ul><h2 id="0dc0" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">播放器详细屏幕</h2><p id="9147" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">继续<strong class="kb hj"> PlayerDetail </strong>屏幕，我们将<strong class="kb hj">视图</strong>与<strong class="kb hj">视图控制器</strong>分开。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="90c9" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">遵循相同的模式，导航到编辑屏幕是通过委托完成的:</p><ul class=""><li id="6e4b" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">用户点击与玩家属性对应的一行。<strong class="kb hj">视图</strong>告诉<strong class="kb hj">视图控制器</strong>我们想要编辑那个字段，而<strong class="kb hj">视图控制器</strong>执行正确的序列。在<code class="du mn mo mp mq b">prepare:for:segue</code>方法中，我们分配编辑播放器所需的属性。</li></ul><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="55e2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">内部<code class="du mn mo mp mq b">PlayerDetailViewController</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="721a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerDetailView</code>呈现如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="4b5e" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">以及表视图委托和数据源实现:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="4c6b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerDetailPresenter</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="4ba7" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">编辑屏幕</h2><p id="e277" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">对于应用程序的其余屏幕，我们遵循相同的方法。<br/>举例说明下面的<code class="du mn mo mp mq b">PlayerEdit</code>功能。<code class="du mn mo mp mq b">PlayerEditView</code>类基本上是新的<strong class="kb hj">视图控制器</strong>。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="681a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">选择器非常简单:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="162b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">和公共API:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="c930" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，<code class="du mn mo mp mq b">UITableViewDataSource</code>和<code class="du mn mo mp mq b">UITableViewDelegate</code>方法:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="edd1" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mn mo mp mq b">PlayerEditPresenter</code>处理业务逻辑，公开更新UI元素的属性。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="743c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">API调用详述如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="c518" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">player添加</strong>，<strong class="kb hj">确认</strong>和<strong class="kb hj">采集</strong>画面遵循相同的方法。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="f679" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">测试我们的业务逻辑</h1><p id="1a15" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">测试方法与我们在MVVM的测试方法有90%相同。</p><p id="589c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">此外，我们需要模拟视图，并检查是否调用了适当的方法。例如，当进行服务API调用时，检查视图是否重载了它的状态，或者在失败时处理了错误。</p><p id="f7e2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">以下单元测试<code class="du mn mo mp mq b">GatherPresenter</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="fba4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">测试<code class="du mn mo mp mq b">countdownTimerLabelText</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="fa98" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">切换计时器变得更加有趣:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="e13b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">下面是模拟视图:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="77ea" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我认为测试演示者非常酷。你不需要做什么神奇的事情，而且这些方法非常小，这很有帮助。复杂的是，你需要模拟视图层，并检查一些参数是否在相应地改变。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="cad4" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">关键指标</h1><h2 id="1c4b" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—视图控制器</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="ee51" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—视图</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="8da7" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—演示者</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="8d49" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—本地模型</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="6760" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">单元测试</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="7040" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">构建时间</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="3f04" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><em class="mu">测试在iPhone 8模拟器中运行，iOS 14.3，使用Xcode 12.4，并在i9 MacBook Pro 2019上运行。</em></p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="f312" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">结论</h1><p id="6cef" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">应用程序现在已经从MVVM重写为MVP。方法很简单，我们用<strong class="kb hj"> ViewModel </strong>代替<strong class="kb hj"> ViewModel </strong>，并用<strong class="kb hj"> Presenter </strong>层替换它。</p><p id="4144" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">此外，我们在<strong class="kb hj"> ViewController </strong>之外创建了一个新层——视图，以便更好地分离关注点。代码看起来更干净，视图控制器更精简，类和函数更小，并且集中做一件事，拥抱单一责任原则。</p><p id="12f0" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">说到用<code class="du mn mo mp mq b">UIKit</code>开发的应用程序，我个人更喜欢这种模式，而不是MVVM。感觉比MVVM更自然。</p><p id="9690" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">看一下关键指标，我们可以记下以下几点:</p><ul class=""><li id="72ea" class="ld le hi kb b kc kx kg ky kk lf ko lg ks lh kw li lj lk ll bi translated">视图控制器要薄得多，总的来说，我们减少了1000多行代码</li><li id="fad0" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">然而，我们为UI更新引入了一个新的层—称为视图</li><li id="9ce0" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">演示者比视图模型更重要，因为他们承担着管理视图的额外责任</li><li id="9df8" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">按照MVVM编写单元测试是相似的，获得了几乎相同的代码覆盖率，<strong class="kb hj"> 97.2% </strong></li><li id="6aa4" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">有了更多的文件和类，我们对构建时间的影响很小，与MVVM相比增加了<strong class="kb hj"> 530 ms </strong>，与MVC相比增加了<strong class="kb hj"> 400 ms </strong></li><li id="8849" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">令人惊讶的是，<strong class="kb hj">的平均单元测试执行时间比MVVM快了1.36秒</strong></li><li id="844e" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">与MVC模式相比，涵盖业务逻辑的单元测试更容易编写</li></ul><p id="d248" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">真的很酷，我们一起看到了如何将一个在MVVM编写的应用程序转换成一种不同的模式，例如MVP。在我看来，将视图从视图控制器中分离出来的MVP比MVVM好得多。它为您的层带来了更多的功能，使它们相互解耦，并且更容易使用依赖注入。</p><p id="c391" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">谢谢你坚持到最后！像往常一样，下面是一些有用的链接。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="8e38" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">有用的链接</h1><ul class=""><li id="9c17" class="ld le hi kb b kc kd kg kh kk mk ko ml ks mm kw li lj lk ll bi translated">iOS应用，足球聚会— <a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a></li><li id="84d4" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">用Vapor制作的web服务器应用程序— <a class="ae lc" href="https://github.com/radude89/footballgather-ws" rel="noopener ugc nofollow" target="_blank"> GitHub Repo Link </a></li><li id="c19d" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">Vapor 3后端API<a class="ae lc" href="https://radu-ionut-dan.medium.com/using-vapor-and-fluent-to-create-a-rest-api-5f9a0dcffc7b" rel="noopener">文章链接</a></li><li id="e4f9" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">迁移到蒸汽4 <a class="ae lc" href="https://radu-ionut-dan.medium.com/migrating-to-vapor-4-53a821c29203" rel="noopener">文章链接</a></li><li id="6557" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">模型视图控制器(MVC)——<a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVC" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae lc" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="94e1" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">模型视图ViewModel (MVVM) — <a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVVM" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae lc" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="3ecc" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">模型视图演示者(MVP) — <a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP" rel="noopener ugc nofollow" target="_blank"> GitHub Repo链接</a>和<a class="ae lc" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e">文章链接</a></li><li id="6cb6" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">协调员模式—带协调员的MVP(MVP-C)—<a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP-C" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae lc" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36">文章链接</a></li><li id="31f8" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">查看交互者展示者实体路由器(VIPER)——<a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIPER" rel="noopener ugc nofollow" target="_blank">GitHub Repo链接</a>和<a class="ae lc" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960">文章链接</a></li><li id="ef3e" class="ld le hi kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">查看互动主持人(VIP)——<a class="ae lc" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae lc" href="https://radu-ionut-dan.medium.com/battle-of-the-ios-architecture-patterns-view-interactor-presenter-vip-59ebdae86e84" rel="noopener">文章链接</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Breadth-First Search: A Simple Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索:一个简单的解释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/breadth-first-search-a-simple-explanation-d7c323960d35?source=collection_archive---------8-----------------------#2021-03-24">https://medium.com/geekculture/breadth-first-search-a-simple-explanation-d7c323960d35?source=collection_archive---------8-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图是一组连接的模型，是一种不可避免的数据结构。从你的社交媒体连接到地图上的城市，你会发现到处都是图表，伴随着图表而来的是<em class="jd">图表遍历</em>方法。访问图中每个节点的过程称为图遍历。<strong class="ih hj">广度优先搜索</strong>或<strong class="ih hj"> BFS </strong>就是这样一种图遍历算法，你可能已经在日常生活中使用它了。一个常见的例子是当你想找到一个目的地的方向。你会检查是否有一条路可以到达你的目的地，并且经常试图找到最短的路径。本文采用了一种更技术性但更简单的方法来解释这个算法。我制作了一个视频<a class="ae je" href="https://youtu.be/HpY8f30e_OQ" rel="noopener ugc nofollow" target="_blank">来解释这个算法。这个例子的灵感来自Aditya Bhargava的书<em class="jd">Grokking Algorithms:a illustrated guide for programmers and other quicking people</em>(查看详细而有趣的算法方法)<em class="jd">。</em></a></p><h1 id="d893" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">图形结构</h1><p id="cd96" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">图由有限的节点(或顶点)和连接两个节点的边组成。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/2f3316ad006ffcfa435390f9c5346184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exDWG4G-CP75Q8Tw6-I1zQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">A Graph</figcaption></figure><p id="6d93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图可以是有向的，也可以是无向的。无向图的边没有方向。有向图有指向一个方向的边。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ky"><img src="../Images/85f495cc28f9f95a4790750e5ee1010f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKhIEjkzN3_Lh2FygQfZTA.png"/></div></div></figure><h1 id="5c61" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">BFS是如何工作的？</h1><p id="38ce" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">广度优先搜索回答了两个主要问题:</p><p id="580b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类型1: <strong class="ih hj">两个节点之间有路径吗？</strong></p><p id="394b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类型二:<strong class="ih hj">两个节点之间的最短路径是什么？</strong></p><p id="073f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个简单的例子来看看BFS是如何回答这些问题的。</p><p id="d652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你拥有一个西瓜农场，你正在寻找一个卖西瓜的人。你去脸书很容易找到卖家。你和你的脸书朋友形成了一个网络，可以用图表的形式来表示。</p><div class="kj kk kl km fd ab cb"><figure class="kz kn la lb lc ld le paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f62fc76ee3afff5895701d9e7dec69a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*VuIqoW29nJDEQI4Wb6RtiA.png"/></div></figure><figure class="kz kn lf lb lc ld le paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/11bf0dc1391123d371159ba59f450a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*MV8C0qItxjqaI8JPgeF_lw.png"/></div></figure></div><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lg"><img src="../Images/b5166cda5a4122bd1402ceb84b95da98.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*dk5o86gVRdNdUSyvGMKJgw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">List of friends</figcaption></figure><p id="941a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步是<strong class="ih hj">创建一个好友列表</strong>。现在你一个接一个地拜访名单上的每个名字。你需要回答一个简单的是非问题，“你的朋友卖西瓜吗？”，如果<strong class="ih hj">是</strong>，你就找到了你的卖家。如果你的答案是<strong class="ih hj">否</strong>，那么你从列表中划掉这个朋友的名字<strong class="ih hj">并转到下一个名字</strong>。</p><p id="43a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在假设你的朋友都不卖西瓜。所以，你的下一步是搜索你朋友的朋友。每次你把某人从列表中删除，你就把他的朋友添加到了列表中。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lh"><img src="../Images/e936c6ef949226cbc8f21c0716c3ecd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HCY3MZ8nzkTlwD02aOkByQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">Graph showing your friends and their friends</figcaption></figure><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es li"><img src="../Images/4fb76abee2c500da155b0524161cde8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*1k-0zhqbF6vs6FjOm-49gg.png"/></div></figure><p id="0aee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你不仅在寻找你的朋友，也在寻找他们的朋友。你的目标是在网络中找到一个卖西瓜的人。所以，如果你的朋友不是卖西瓜的，你也可以把他们的朋友加入名单。你继续寻找，直到你找到一个卖西瓜的人，或者你把所有的名字都从列表中删除(在这种情况下，你的网络中没有卖西瓜的人)。如果你的两个朋友有一个共同的朋友(除了你之外)，你将只写一次共同朋友的名字。这种算法被称为广度优先搜索。</p><p id="b8e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谈到BFS回答的两个主要问题</p><ol class=""><li id="6e13" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">在两个节点之间存在路径吗——对于我们的例子，这可以被重新定义为<em class="jd">“在你的网络中存在卖西瓜的吗？”。</em></li><li id="eefd" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">两个节点之间的最短路径是什么——这个可以重新架构为<em class="jd">“谁是最近的卖西瓜的？”</em></li></ol><p id="4f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到了第一个问题是如何回答的。再来看第二个问题。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lx"><img src="../Images/2be3d8b264521369ad2794d11c43d7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKGhVIdynCgPwxumGGQ5Hg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">First and second-degree connections</figcaption></figure><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ly"><img src="../Images/21974177ad16a37dd10e909159d2941e.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*KBohAZtV8lMEo3HxudiJZQ.png"/></div></figure><p id="8051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你的朋友是你的一级人脉，他们的朋友是你的二级人脉。比起二级关系，你总是更喜欢一级关系。因此，你不会在搜索第一级关系之前搜索第二级关系，这将有助于你找到最近的西瓜卖家。BFS已经这样做了。搜索<em class="jd">从源节点</em>辐射出去(这里源节点就是你)。一级关系在二级关系之前被添加到列表中，因此它们会首先被检查，只要您按照添加顺序搜索人员。所以，如果你在你的人脉中找到一个卖西瓜的，他们也会是和你最亲近的卖家。</p><h1 id="64af" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">一、实施</h1><p id="2a4a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">首先，我们必须制作一个图表。在python中，为了容易地实现图形，我们使用字典。这个字典中的一个键代表一个节点，值在数组的帮助下被映射。为了简单起见，我们在这里使用一个有向图。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="ad20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了维护这个列表，我们可以使用队列，因为我们需要FIFO结构(首先检查最先出现的名字)。这里我将使用deque来维护这个列表。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="8271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得共同好友的案例吗？汤姆是杰里和太妃糖的朋友。所以他可以被列入名单两次。为了避免这种问题，我们将保留一个数组，记录我们已经访问过的所有节点。如果一个人是卖西瓜的，我们就完成了，如果不是，我们继续搜索，直到我们找到一个卖家或访问所有节点。这方面的代码是:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a6e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最不需要的是一个函数来确定一个人是不是卖西瓜的(对<em class="jd">的定义是_seller() </em>)。我在这里提出的条件是，这个人的名字以<em class="jd">‘T’</em>开头。所以这个案例的答案是<em class="jd">太妃糖</em>。这个函数可以被任何条件代替，以找到<em class="jd">目的地</em>节点。所以最后的代码是:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h1 id="e1f2" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">执行时间</h1><p id="3f9c" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">因为你是在搜索一个卖西瓜的人，所以你会沿着所有的边(连接)走。最起码运行时间是O(边数)。如果边数是E，我们得到O(E)。</p><p id="2ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还需要为这个算法保留一个队列。将一个元素推入队列需要常数(O(1))的时间。对所有节点或顶点执行此操作将花费O(节点数)时间。如果图中有N个节点，则需要O(N)时间。</p><p id="ce73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以总的来说，广度优先搜索耗时O(节点数+边数)或<strong class="ih hj"> O(N + E) </strong>。</p><h1 id="84be" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">BFS的应用</h1><p id="6560" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">就像我之前提到的，你已经在日常生活中使用了广度优先搜索算法。这是一个非常简单的算法，这也是它被应用于许多现实生活场景的原因。下面列出了一些应用:</p><ol class=""><li id="512a" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">GPS导航</li><li id="d726" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">未加权的图遍历(最短路径和最小生成树)</li><li id="0eef" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">搜索引擎爬虫</li><li id="0a25" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">网络广播</li></ol><h1 id="17ea" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">参考资料和资源</strong></h1><p id="6c91" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这篇文章试图对BFS做一个简单的解释。关于BFS还有很多需要了解的。查看以下链接了解更多信息:</p><ol class=""><li id="cea4" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated"><a class="ae je" href="https://youtu.be/HpY8f30e_OQ" rel="noopener ugc nofollow" target="_blank">广度优先搜索视频</a></li><li id="d921" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><a class="ae je" href="https://www.amazon.in/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230" rel="noopener ugc nofollow" target="_blank">搜索算法</a></li><li id="d411" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><a class="ae je" href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/" rel="noopener ugc nofollow" target="_blank">图形数据结构和算法</a></li><li id="f483" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><a class="ae je" href="https://www.mathworks.com/help/matlab/math/directed-and-undirected-graphs.html#:~:text=Undirected%20graphs%20have%20edges%20that,be%20traversed%20in%20both%20directions.&amp;text=Directed%20graphs%20have%20edges%20with,traversed%20in%20a%20single%20direction." rel="noopener ugc nofollow" target="_blank">有向和无向图</a></li><li id="f66a" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><a class="ae je" href="https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/" rel="noopener ugc nofollow" target="_blank">图形的应用</a></li></ol></div></div>    
</body>
</html>
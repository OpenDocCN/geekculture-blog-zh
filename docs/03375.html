<html>
<head>
<title>Coding Interview: Big O Notation in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试:简而言之的大O符号</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/coding-interview-big-o-notation-in-a-nutshell-23cc641594b1?source=collection_archive---------27-----------------------#2021-06-07">https://medium.com/geekculture/coding-interview-big-o-notation-in-a-nutshell-23cc641594b1?source=collection_archive---------27-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7f03cc1f881621df5e5721d1cc495844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5EIgjpIJZCgK9waS"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@tvschaitanya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chaitanya Tvs</a> on <a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="1f50" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">大O </strong>符号将算法的<strong class="ix hz">复杂度</strong>描述为输入大小的函数。复杂性可能与性能(运行时复杂性)或空间(使用的内存量)有关。</p><p id="126d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">大O </strong>是给定函数的最坏情况<strong class="ix hz">或增长上限</strong>的渐近符号。这不是找到一个确切的值，而是尽可能接近地描述最坏的情况。举个例子，</p><ul class=""><li id="1196" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hz">打印N个元素的数组的所有元素</strong>，需要<strong class="ix hz"> O(N) </strong>时间，并且</li><li id="4a11" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hz">在一个有N个元素的数组中线性搜索一个元素</strong>也是<strong class="ix hz"> O(N) </strong>。</li></ul><p id="6907" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么？因为最坏的情况是在搜索时进行N次比较，一次检查每个元素，就像我们在打印时一样。</p><p id="43bf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图1显示了输入大小从0到100的大O的典型值，这只是一个示例。可以注意到，很明显我们有三个区域:即使输入大小值很高也保持低的大O，即使输入大小值很低也保持高的大O，以及<em class="kh">几乎</em>随着输入大小的增加而线性增长的大O。</p><p id="e067" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，问题是如何计算给定一个算法源代码的大O？让我们关注运行时复杂性，即性能。以下部分描述了各种可能性。</p><figure class="kj kk kl km fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ki"><img src="../Images/be7f79f9bb320a6cf8d35ece0425b6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*is_GksIKYHQHsvXmkqepXQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx"><strong class="bd kn">Figure 1</strong>. Typical values for Big O. X-axis represent the size of the input. Y-axis represents Big O function values. O(log n) is considered a good complexity. O(n) is fair. O(n log n), O(n²), and so are bad.</figcaption></figure><h2 id="f753" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">1.大O表示说明和条件</h2><p id="729e" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">第一，<strong class="ix hz">大O </strong>对于一个指令，包括条件句，是一个常量<strong class="ix hz"> O(1) </strong>。下面的算法(例1)复杂度为<strong class="ix hz"> O(1) </strong>。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="1ad1" class="ko kp hy lo b fi ls lt l lu lv">// Example 1<br/>void sayHello () {<br/>  System.out.<strong class="lo hz">println</strong> ("Hello!");<br/>}</span></pre><p id="ade6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样的规则也适用于条件。下面的方法(示例2)具有恒定的复杂度。为了实用，即使我们有两条指令，复杂度也是<strong class="ix hz"> O(1) </strong>。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="06b3" class="ko kp hy lo b fi ls lt l lu lv">// Example 2<br/>void isEven (int number) {<br/>  if (<strong class="lo hz">number % 2 == 0</strong>) {<br/>    System.out.<strong class="lo hz">println</strong> ("It is even!");<br/>  }<br/>}</span></pre><blockquote class="lw lx ly"><p id="84a6" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">关键思想:<strong class="ix hz"> O(1) </strong>典型为简单指令，包括条件。</p></blockquote><h2 id="1044" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">2.大O代表循环</h2><p id="797b" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">循环的大O回答问题，循环体将运行多少次。一个简单的例子运行n次，比如下面的算法(例子3)具有复杂度<strong class="ix hz"> O(n) </strong></p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="0f94" class="ko kp hy lo b fi ls lt l lu lv">// Example 3<br/>void printNumbers() {<br/>  for (int <strong class="lo hz">i=0</strong>; <strong class="lo hz">i&lt;n</strong>; <strong class="lo hz">i++</strong>) {<br/>    System.out.println(i); <br/>  }<br/>}</span></pre><blockquote class="lw lx ly"><p id="da71" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">关键思想:<strong class="ix hz"> O(n) </strong>是简单单循环的典型。</p></blockquote><h2 id="01db" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">3.运行时删除常量和非主导术语</h2><p id="3d21" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">一个结合了指令和各种独立循环的算法怎么样呢，比如下面的例子(例4)？</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="f2e5" class="ko kp hy lo b fi ls lt l lu lv">// Example 4<br/>void doThis () {  <br/>  <strong class="lo hz">// sinlge instruction</strong><br/>  System.out.println("Hello World!");<br/>  <strong class="lo hz">// condition</strong><br/>  if (input % 2 == 0) {<br/>    System.out.println("This is even!"); <br/>  }<br/>  <strong class="lo hz">// loop 1</strong><br/>  for (int i=0; i &lt; n; i++) {<br/>    System.out.println(i); <br/>  }<br/>  <strong class="lo hz">// loop 2</strong><br/>  for (int i=0; i &lt; n; i++) {<br/>    System.out.println(i); <br/>  }<br/>}</span></pre><p id="529e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你正在考虑增加，你是对的。描述运行时间的等式可能类似于(1 + 2 + n + n)或(3 + 2*n)。但是，在代表大O时，请记住以下关键观点:</p><ul class=""><li id="c425" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hz">删除常量</strong>。例如，O(2*n)是O(n)</li><li id="f725" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hz">删除非主导术语</strong>。例如，O(1 +n)变成O(n)，O(n +n)变成O(n)，或者O(n+ log n)变成O(n)等等。</li></ul><p id="7d3c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们的代码(例4)只是<strong class="ix hz"> O(n)。</strong></p><p id="823f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个例子，考虑一个如下的循环(例子5 ),它不以1递增:</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="74d9" class="ko kp hy lo b fi ls lt l lu lv">// Example 5<br/>void doThis () {  <br/>  for (int i=0; i &lt; n; <strong class="lo hz">i=i+2</strong>) {<br/>    System.out.println(i); <br/>  }<br/>}</span></pre><p id="5196" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它运行了n/2次，所以它的复杂度是O(n/2)或O(0.5 * n)，但是在应用了我们的规则(<strong class="ix hz">去掉常数)，</strong>之后，对于之前给出的代码(示例5)，我们的复杂度是<strong class="ix hz"> O(n) </strong>。</p><blockquote class="lw lx ly"><p id="5af2" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">关键思想:使用<strong class="ix hz">加法</strong>来组合算法复杂性的不同部分，但是<strong class="ix hz">去掉常数</strong>和<strong class="ix hz">非主导项。</strong></p></blockquote><h2 id="da22" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">4.改变问题空间的循环的运行时大O</h2><p id="9901" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">对于像<strong class="ix hz"> </strong>二分搜索法这样的搜索算法，大O怎么样？</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="4c1d" class="ko kp hy lo b fi ls lt l lu lv">// Example 6<br/>int binarySearch(int[] sortedArray, int key, int low, int high) {     <br/>  int index = Integer.MAX_VALUE;          <br/>  while (<strong class="lo hz">low &lt;= high</strong>) {         <br/>    int mid = (low + high) / 2;         <br/>    if (sortedArray[mid] &lt; key) {             <br/>      <strong class="lo hz">low</strong> = mid + 1;         <br/>    } else if (sortedArray[mid] &gt; key) {             <br/>      <strong class="lo hz">high</strong> = mid - 1;         <br/>    } else if (sortedArray[mid] == key) {             <br/>      index = mid;             <br/>      break;         <br/>    }     <br/>  }     <br/>  return index; <br/>}</span></pre><p id="c15e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是一个循环，但是你要记住，在每次迭代中，问题空间中的元素数量会减半。一个数可以减半多少次？答案是<strong class="ix hz"> log n. </strong>例如，一个大小为10的数组将开始比较5中的元素，然后是2，然后是1。这是一个运行3次的循环。由此，<strong class="ix hz"> O (log n)。我们正在讨论以2为底的对数。然而，对数底数并不重要，因为以“<em class="kh">a”</em>为底数的对数和以“<em class="kh">b”</em>为底数的对数之差是一个常数值。是的，logₐn=·k·logᵦn.和我们在表达大o的时候去掉了常数</strong></p><blockquote class="lw lx ly"><p id="53a0" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">数学笔记:<strong class="ix hz">logᵦn=logₐ<em class="hy">b/</em>logₐn</strong><em class="hy">。</em></p></blockquote><p id="0498" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个类似的例子如下所示(例7)，注意变量在循环中是如何变化的</p><ul class=""><li id="05c8" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">如果n=5，那么它将打印2，然后停止</li><li id="95c7" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果n=10，那么它将打印2，9，然后停止</li><li id="c180" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果n=20，那么它将打印2，9，16，然后停止</li><li id="44c1" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果n=30，那么它将打印2，9，16，25，然后停止</li></ul><p id="a2ec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">诸如此类。它运行的次数等于数字<em class="kh"> x </em>的次数，因此<em class="kh"> x </em> <em class="kh"> &lt; n </em>。这听起来像平方根的定义！没错，这是<strong class="ix hz"> O(√n) </strong></p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="7f34" class="ko kp hy lo b fi ls lt l lu lv">// Example 7<br/>public void method (int n) {<br/>  for (int x = 2; <strong class="lo hz">x * x &lt; = n</strong>; x++) {<br/>    System.out.println (x);<br/>  }<br/>}</span></pre><blockquote class="lw lx ly"><p id="dd3d" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">注意:<strong class="ix hz"> O(log n) </strong>是在每次迭代中问题空间减半的典型算法。</p><p id="5130" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">注意:仔细检查循环中的停止条件。他们不总是O(n)；您可以确定其他值，包括<strong class="ix hz"> O(√n)。</strong></p></blockquote><h2 id="0066" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">5.递归算法的运行时大O</h2><p id="db69" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">递归实现的大O类似于循环的大O。它回答了肉体会被执行多少次的问题。简单的递归函数有一个大O，就像它们的循环版本一样。例如，如下所示的递归阶乘(例8)将运行n次；因此，它是<strong class="ix hz"> O(n)。</strong></p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="84c1" class="ko kp hy lo b fi ls lt l lu lv">// Example 8<br/>public long <strong class="lo hz">factorial</strong>(int n) {<br/>    if (n &lt;= 2) {<br/>        return n;<br/>    }<br/>    return n * <strong class="lo hz">factorial</strong>(n - 1);<br/>}</span></pre><p id="d755" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有不止一个递归调用，比如在下面显示的经典递归Fibonacci数计算中(示例9)，会怎么样呢？</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="f915" class="ko kp hy lo b fi ls lt l lu lv">// Example 9<br/>int <strong class="lo hz">fibonacci</strong> (int n) {<br/>    if (n &lt;= 1)<br/>        return n;<br/>    return <strong class="lo hz">fibonacci</strong>(n-1) + <strong class="lo hz">fibonacci</strong>(n-2);<br/>}</span></pre><p id="eb58" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它将创建一棵树。一个调用可以完成两个，这两个调用中的每一个都可以完成自己的两个调用，以此类推。它将创建一棵树，如图2所示。</p><figure class="kj kk kl km fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/9ca84d8cd83804731ef919c7e9eb3dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkHA-f4Sxa2fZvvjkQryzg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx"><strong class="bd kn">Figure 2.</strong> Recursive calls when calculating Fibonacci of 6.</figcaption></figure><p id="227e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，树中的每个节点代表函数运行的总次数。树中的节点总数是1 + 2 + 4 + 8 … 2 <strong class="ix hz"> ᵈ- </strong>，其中<em class="kh"> d </em>是树的深度。它是一个几何级数，有一个方程可以求解。</p><blockquote class="lw lx ly"><p id="03f5" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">数学笔记:<strong class="ix hz">b⁰+ b+ b+ b…bᵈ- =(bᵈ-1)/(d-1)</strong></p></blockquote><p id="e9ae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此复杂度是(Bᵈ -1) / (d-1)。然而，我们放弃常数；结果是:对于一个进行多次调用的递归函数，大o通常是像<strong class="ix hz"> O(B ᵈ) </strong>这样的东西，其中b是每次调用的分支数，d是递归树的深度。在上面的例子中(例子9)，每个调用创建两个分支，深度是6。因此，我们的递归斐波那契有一个<strong class="ix hz"> O(2ⁿ).请记住，我们表达的是最坏的情况，也就是树拥有所有节点的情况。</strong></p><p id="6af4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面代码的运行时大O怎么样(例10)？</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="1a2e" class="ko kp hy lo b fi ls lt l lu lv">// Example 10<br/>int <strong class="lo hz">sum</strong> (Node node) {<br/>  if (node == null) <br/>    return 0;<br/> return <strong class="lo hz">sum</strong> (node.left) + node.value + <strong class="lo hz">sum</strong> (node.right);<br/>}</span></pre><p id="78ec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有点棘手。分支机构每次调用2个；因此，<em class="kh"> B=2 </em>。深度呢？嗯，这看起来像是一个树的方法，那么问题是，有一个n个节点的树，树的深度是多少？答案是<em class="kh"> d=log n </em>。因此，B ᵈ = n。在这种情况下，我们的算法是<strong class="ix hz"> O(n) </strong>。等等，如果所有的节点都插在不同的层次，所以形成一条线呢？那也是<strong class="ix hz"> O(n)。</strong></p><blockquote class="lw lx ly"><p id="4d32" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">注意:O <strong class="ix hz"> (B ᵈ) </strong>常见于你有一个递归函数，每次进行多次调用(分支)。</p></blockquote><h2 id="4fe1" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">6.嵌套循环的运行时大O</h2><p id="464f" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">嵌套循环很有趣。例如，下面显示的冒泡排序算法实现的大O是什么？对于具有n个元素的数组，第一个循环运行n次，每次执行外部循环时，内部循环运行<strong class="ix hz"> n </strong>次，因此<strong class="ix hz"> O(n*n) </strong>或<strong class="ix hz"> O(n ) </strong></p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="7032" class="ko kp hy lo b fi ls lt l lu lv">// Example 11<br/>void <strong class="lo hz">bubbleSort</strong>(int[] arr) {<br/>  for (int <strong class="lo hz">k</strong> = 0; k &lt; <strong class="lo hz">arr.length</strong> - 1; k++) {<br/>    for (int i = 0; i &lt; <strong class="lo hz">arr.length - 1 - k</strong>; i++) {<br/>      if (arr[i] &gt; arr[i + 1]) {<br/>        swap(arr, i, i + 1);<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="48af" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能已经注意到了-k，并认为内部循环不会运行n次。第一次会运行n次，然后n-1，n-2，n-3，n-4等等。因此，代码执行的总次数不是n * n，而是n + (n-1) + (n-2) + (n-3) + …+ 1.</p><blockquote class="lw lx ly"><p id="1bbc" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">数学笔记:<strong class="ix hz"> n + (n-1) + (n-2) + (n-3) + …。+ 1 = n* (n-1) / 2 </strong></p></blockquote><p id="ac49" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过去掉常数和非主导项，得到<strong class="ix hz"> O(n)。</strong></p><p id="2fd1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们有两个，比如在典型的矩阵乘法代码中，而不是一个数组，如下所示(图12)，会怎么样？</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="4cd5" class="ko kp hy lo b fi ls lt l lu lv">// Example 12<br/>public static int[][] multiplication(int[][] A, int[][] B) {<br/>  int[][] C = new int[A.length][B[0].length];<br/>  for (int i = 0; <strong class="lo hz">i &lt; A.length</strong>; i++) {<br/>    for (int j = 0; j &lt; <strong class="lo hz">B[0].length</strong>; j++) {<br/>      C[i][j] = 0;<br/>    }<br/>  }<br/>  for (int i = 0; i &lt; <strong class="lo hz">A.length</strong>; i++) { <br/>    for (int j = 0; j &lt;  <strong class="lo hz">B[0].length</strong>; j++) {<br/>      for (int k = 0; k &lt; <strong class="lo hz">A[0].length</strong>; k++) {<br/>        C[i][j] += A[i][k] * B[k][j];<br/>      }<br/>    }<br/>  }<br/>  return C;<br/>}</span></pre><p id="d295" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两个部分；首先，结果矩阵被初始化为零。该部分的执行次数等于矩阵A中的行数乘以矩阵b中的列数。它运行的次数等于矩阵A中的行数乘以矩阵B中的列数乘以矩阵A中的列数。图3突出显示了矩阵乘法的步骤，以供参考。</p><figure class="kj kk kl km fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/5f04c71a0b8e2b8be3d76474b4b0c239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us4OGITPzNHFUNmu-hUvVg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Figure 3. Example of matrix multiplication step-by-step.</figcaption></figure><p id="3b64" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，O(aᵣ*b𝒸 + aᵣ*b𝒸*a𝒸).然而，由于我们丢弃了非主导项，所以它是<strong class="ix hz"> O(aᵣ*b𝒸*a𝒸) </strong>。一个关键的想法是，我们可以有不止一个输入，因此不止一个变量控制大O方程。要知道这不是n或者n</p><blockquote class="lw lx ly"><p id="535a" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">注意:在处理嵌套循环时，要注意输入。可能有O(n*n)的情况，即O(n)，或者有多个输入的情况，如<strong class="ix hz"> O(n*m) </strong>。他们不一样。</p></blockquote><h2 id="7cd3" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">6.循环和递归的运行时大O</h2><p id="4db5" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">如果我们把循环和递归放在一起呢？复杂性与我们之前评估的并没有太大的不同。然而，关注停止条件是很重要的。让我们考虑下面的例子(例13)。</p><pre class="kj kk kl km fd ln lo lp lq aw lr bi"><span id="5ff6" class="ko kp hy lo b fi ls lt l lu lv">// Example 13<br/>private static void <strong class="lo hz">permute</strong>(String str, String permutedStr) {<br/>  if (str.length()==0) {<br/>    System.<em class="kh">out</em>.println(permutedStr);<br/>  } else {<br/>    for (int i=0; i&lt;<strong class="lo hz">str.length()</strong>; i++) {<br/>      String newStr = str.substring(0, i) <br/>                    + str.substring(i+1, str.length());<br/>      <strong class="lo hz"><em class="kh">permute</em></strong>(newStr, permutedStr + str.charAt(i));<br/>    }<br/>  }<br/>}</span></pre><p id="8437" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以找出问题所在:打印字符串中字符的所有排列。这个的大O是什么？</p><p id="c831" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它看起来像我们之前看到的东西，像是<strong class="ix hz"> O(B ᵈ) </strong>的东西，但它不是。分支的数量不是恒定的。在每一个层次上，我们都减少了分支。我们有:</p><ul class=""><li id="6396" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">顶部有1个节点</li><li id="d81e" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">第二层中的n个节点</li><li id="12bb" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">下一级中的n*(n-1)个节点</li><li id="538e" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">下一级中的n*(n-1)*(n-2)个节点</li><li id="e248" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">依此类推，直到n*(n-1)*(n-2)*(n-3)… * 1</li></ul><p id="7d6e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以表示为:</p><p id="4849" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1 + n + n*(n-1) + n*(n-1)*(n-2) + …+n*(n-1)*(n-2)*(n-3)… * 1</p><p id="e559" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过一些数学魔法，这是一回事，</p><p id="10c6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">n！/n！+ n！/(n-1)！+ n！/(n-2)！+ n！/(n-3)！+ … + n！/(n-n)！</p><p id="bbf5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一样的，</p><p id="5cf2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">n！* (1/n！+ 1/(n-1)！+ 1/(n-2)！… + 1/3!+ 1/2!+ 1/1!)</p><p id="4e3c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，也是</p><p id="f5dd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">n！* (e)</p><blockquote class="lw lx ly"><p id="29d5" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">数学笔记:<strong class="ix hz"> e = 1/n！+ 1/(n-1)！+ 1/(n-2)！… + 1/3!+ 1/2!+ 1/1!</strong></p></blockquote><p id="e9ec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欧拉数(e)是一个数学常数，大约等于2.71828。所以，我们的大O是O (n！* e)，并且我们丢弃常数，那么我们得到<strong class="ix hz"> O(n！)</strong>。</p><p id="904a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，最后一件事，我们在for循环中计算的这些<strong class="ix hz">子串</strong>呢，它们是O(n)，我们每次在递归调用之前计算它们，所以我们的运行时复杂度是<strong class="ix hz"> O(n * n！)</strong></p><blockquote class="lw lx ly"><p id="2717" class="iv iw kh ix b iy iz ja jb jc jd je jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">注意:注意<strong class="ix hz"> O(n！)</strong>进行排列。</p></blockquote></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h2 id="c991" class="ko kp hy bd kn kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">常用算法的大O</h2><p id="1bda" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">建议您记住不同版本的排序和搜索算法的大O值。我在线性和二分搜索法之前提到过:</p><ul class=""><li id="7f05" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">线性搜索是<strong class="ix hz"> O(n) </strong></li><li id="c982" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">二分搜索法是<strong class="ix hz"> O(log n) </strong></li></ul><p id="4012" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，在上面的例子中，我们回顾了冒泡排序算法，并解释了它的大O为<strong class="ix hz"> O(n ) </strong>。快速排序或者合并排序呢？</p><ul class=""><li id="ad3f" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">快速排序是<strong class="ix hz"> O(n ) </strong></li><li id="bd73" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Mergesort是<strong class="ix hz"> O(n*log n) </strong></li></ul><p id="1b04" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，测试一下你们自己。是时候练习了。</p><ul class=""><li id="7d97" class="jt ju hy ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">记住使用递归遍历二叉树的实现(前序、后序、按序)。这些的大O是什么？</li><li id="2b7a" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">常见的数据结构操作呢，比如在二叉查找树中插入新元素？在AVL树中插入一个新元素怎么样？在队列或堆栈中插入一个新元素怎么样？</li><li id="ae29" class="jt ju hy ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Dijkstra算法的大O是什么？</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Motion Detection in Unity with OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV中的Unity运动检测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/motion-detection-in-unity-with-opencv-299b1720eac9?source=collection_archive---------16-----------------------#2021-08-02">https://medium.com/geekculture/motion-detection-in-unity-with-opencv-299b1720eac9?source=collection_archive---------16-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c3e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运动检测是检测物体相对于其周围环境的位置变化的能力。这在许多应用中可能是一个非常有用的概念，尤其是在智能CCTV摄像机中，当它检测到运动时就会开始记录。</p><p id="feaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检测摄像机视野内是否有任何物体的运动，我们可以使用差分图像技术来实现我们的目标。首先，我应该提到的是，我是从<a class="ae jd" rel="noopener" href="/@deepakkumar1984/motion-detection-with-open-cv-and-c-88cdad521c15">这篇</a>博客中发现这种技术的，作者已经使用OpenCV用C#实现了这种技术。</p><p id="8b36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我要做的是使用相同的技术(和来自同一博客的一些代码)在unity中实现运动检测。这里，我们将检测运动并点亮一个红色灯泡(只是改变图像的颜色和alpha值😅)基于运动的强度。如果您想了解我们最终的应用结果，请跳到故事的结尾。</p><p id="d05e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">微分图像概念</strong></p><p id="b82c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差分图像概念的思想是，当一个物体移动时，它的位置在两个连续的帧中将是不同的，但是周围的环境将保持不变。所以，通过减去这两帧，我们可以看到物体的运动。</p><p id="2489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们将使用3个连续的帧来完成这个任务，因为使用3个帧的优点是可以消除静止的环境。我也是从我之前提到的同一篇<a class="ae jd" rel="noopener" href="/@deepakkumar1984/motion-detection-with-open-cv-and-c-88cdad521c15">文章</a>中获得这个想法的。参考一下可以更好的理解这个概念。</p><p id="791d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行上述步骤后获得的帧如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/dd30642c16a68136c9879d0570343611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXUNpi4eJvN4P04Fdlgk6Q.jpeg"/></div></div></figure><h1 id="d0fb" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">实现</strong></h1><p id="871e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">因此，让我们首先创建一个unity项目(2D或3D无关紧要)，并为unity导入OpenCV资产。</p><p id="85b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该资产可在以下位置找到:</p><p id="e5de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://assetstore.unity.com/packages/tools/integration/opencv-for-unity-21088" rel="noopener ugc nofollow" target="_blank">OpenCV for Unity | Integration | Unity Asset Store</a></p><p id="02c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创建一个画布，在画布中创建三个RawImages，分别命名为CameraView、DetectionView和Bulb，保存场景。我已经将游戏窗口中的画布大小从自由纵横比更改为4:3。</p><p id="57c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相机视图—显示原始相机馈送</p><p id="13b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检测视图—显示运动检测馈送</p><p id="2beb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">灯泡—显示运动的强度</p><p id="3d5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(要创建canvas/RawImage:右键单击层次部分-&gt; UI -&gt; Canvas/RawImage)</p><p id="9685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，创建一个空的游戏对象，并将其命名为“ScriptHandler”。(我们可以使用这个游戏对象来附加脚本，这样会很方便)。</p><p id="7273" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，下载任何图像，并将其导入unity assets部分。(我从<a class="ae jd" href="https://www.clipartmax.com/middle/m2i8d3A0A0m2m2A0_yes-sign-clip-art-at-clker-red-circle-no-background/" rel="noopener ugc nofollow" target="_blank">这里</a>下载了一个剪贴画。)之后，选择灯泡RawImage，在检查器窗口中，您会在Raw Image部分看到“纹理”。从那里，打开选择窗口，选择你刚才导入的图像的纹理。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kt"><img src="../Images/11c97e951d070d8ba9ef840380332e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*14DD9xga-4HCWbxkN_B72A.png"/></div></figure><p id="35f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以根据需要调整对象的大小和位置。</p><p id="8faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后，您的项目结构应该如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/c2e25d2f18357f505d074991f5baa11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJ3WLlBPi5m1Bj1DUfdYEA.jpeg"/></div></div></figure><p id="6555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来让我们创建一个名为“detection”(或任何名称)的C#脚本来开始编码。</p><p id="c30e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(右键单击项目窗口中的资产部分-&gt;创建-&gt; C#脚本)</p><p id="0b57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在Visual Studio中打开C#脚本。</p><p id="f3b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先添加以下导入。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="d5de" class="la jr hi kw b fi lb lc l ld le">using OpenCVForUnity.CoreModule;<br/>using OpenCVForUnity.ImgprocModule;<br/>using OpenCVForUnity.UnityUtils;<br/>using System;<br/>using System.Collections;<br/>using System.Collections.Generic;<br/>using UnityEngine;<br/>using UnityEngine.UI;</span></pre><p id="1d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要创建如下4个成员变量:</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="0874" class="la jr hi kw b fi lb lc l ld le">[SerializeField] private RawImage cameraView;</span><span id="7e66" class="la jr hi kw b fi lf lc l ld le">[SerializeField] private RawImage detectionView;</span><span id="59b5" class="la jr hi kw b fi lf lc l ld le">[SerializeField] private RawImage bulb;</span><span id="0d1b" class="la jr hi kw b fi lf lc l ld le">private WebCamTexture webcamTexture;</span></pre><p id="c388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，让我们初始化start方法来显示摄像机的输入。</p><p id="a4f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要获得可用的相机设备，并将“camera view”raw image的纹理设置为webcamTexture，然后启动网络摄像头馈送。</p><p id="60e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的设备有多个摄像机(例如移动电话)，您可以通过更改cam_devices[]数组中的值来更改要访问的摄像机。</p><p id="b3d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Start()方法:</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="8f16" class="la jr hi kw b fi lb lc l ld le">void Start()</span><span id="8674" class="la jr hi kw b fi lf lc l ld le">{<br/>  //obtain cameras avialable<br/>  WebCamDevice[] cam_devices = WebCamTexture.devices;</span><span id="54cc" class="la jr hi kw b fi lf lc l ld le">  //create camera texture<br/>  webcamTexture = new WebCamTexture(cam_devices[0].name, 480, 640, 30);</span><span id="8cdb" class="la jr hi kw b fi lf lc l ld le">  //set raw image texture to obtain feed from camera texture<br/>  cameraView.texture = webcamTexture;<br/>  cameraView.material.mainTexture = webcamTexture;</span><span id="0a18" class="la jr hi kw b fi lf lc l ld le">  //start camera<br/>  webcamTexture.Play();</span><span id="e07b" class="la jr hi kw b fi lf lc l ld le">  //start coroutine<br/>  StartCoroutine(motionDetection());<br/>}</span></pre><p id="8a04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一行代码是启动motionDetection()协程方法，我们稍后将实现该方法。</p><p id="79ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们创建DiffImage方法来计算三个连续帧之间的差异。我从之前提到的同一个博客的<a class="ae jd" rel="noopener" href="/@deepakkumar1984/motion-detection-with-open-cv-and-c-88cdad521c15">那里获得了这个方法，并且我已经修改了代码以适应OpenCV for Unity。</a></p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="f7a0" class="la jr hi kw b fi lb lc l ld le">Mat DiffImage(Mat t0, Mat t1, Mat t2)</span><span id="31ae" class="la jr hi kw b fi lf lc l ld le">{<br/>  Mat d1 = new Mat();<br/>  Core.absdiff(t2, t1, d1);</span><span id="dff3" class="la jr hi kw b fi lf lc l ld le">  Mat d2 = new Mat();<br/>  Core.absdiff(t1, t0, d2);</span><span id="43c7" class="la jr hi kw b fi lf lc l ld le">  Mat diff = new Mat();<br/>  Core.bitwise_and(d1, d2, diff);</span><span id="6c79" class="la jr hi kw b fi lf lc l ld le">  return diff;<br/>}</span></pre><p id="3da3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里主要做的是获得帧t1、t0和t2、t1之间的像素的绝对差，并将值分别存储在d2和D1 Mats’中。(Mat是存储图像值的OpenCV类)。接下来，我们获得d2和d1的按位AND运算。</p><p id="f74f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们实现motionDetection()方法。这是一个协程方法，处理我们大部分工作。该方法包含一个循环，该循环将无终止地运行，以保持运动检测的摄像机馈送连续地渲染到原始图像视图。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="7a49" class="la jr hi kw b fi lb lc l ld le">private IEnumerator motionDetection()</span><span id="56c6" class="la jr hi kw b fi lf lc l ld le">{<br/>  while (true)<br/>  {<br/>  }<br/>}</span></pre><p id="a05b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里开始，将提供的所有代码添加到上述方法(motionDetection()方法)的while循环中。</p><p id="333b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要创建三个OpenCV Mats来存储3个连续的帧。</p><p id="8cae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当获得一帧接一帧的画面时，我增加了0.04秒的延迟，这样我们看到的画面更真实。您可以根据需要更改该值。</p><p id="e01b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用webcamTexture的大小初始化Mat，并使用OpenCV的“webCamTextureToMat”方法将像素值加载到Mat。</p><p id="17e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面给出了设置这三个垫子的代码。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="a3b4" class="la jr hi kw b fi lb lc l ld le">  Mat t0 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>  Utils.webCamTextureToMat(webcamTexture, t0); //obtain fram from webcam<br/>  yield return new WaitForSeconds(0.04F);// wait for 0.04s<br/>  yield return new WaitForEndOfFrame();// wait till end of frame</span><span id="7a42" class="la jr hi kw b fi lf lc l ld le">  Mat t1 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>  Utils.webCamTextureToMat(webcamTexture, t1);<br/>  yield return new WaitForSeconds(0.04F);<br/>  yield return new WaitForEndOfFrame();</span><span id="7a34" class="la jr hi kw b fi lf lc l ld le">  Mat t2 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>  Utils.webCamTextureToMat(webcamTexture, t2);<br/>  yield return new WaitForSeconds(0.04F);<br/>  yield return new WaitForEndOfFrame();</span></pre><p id="043f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将把帧转换成灰度，因为我们在检测运动时不需要颜色信息。为此，请将以下代码添加到motionDetection()方法中。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="4795" class="la jr hi kw b fi lb lc l ld le">Imgproc.cvtColor(t0, t0, Imgproc.COLOR_RGBA2GRAY);<br/>Imgproc.cvtColor(t1, t1, Imgproc.COLOR_RGBA2GRAY);<br/>Imgproc.cvtColor(t2, t2, Imgproc.COLOR_RGBA2GRAY);</span></pre><p id="9016" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，创建一个新的Mat并将三个Mat帧传递给我们之前创建的DiffImage()方法，并将结果存储在新的Mat中。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="b4a5" class="la jr hi kw b fi lb lc l ld le">Mat final = new Mat();<br/>final = DiffImage(t0, t1, t2);</span></pre><p id="f8a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们需要创建一个与“最终”Mat大小相同的新纹理，然后使用OpenCV的“matToTexure2D”方法将Mat的值分配给纹理，并将detectionView纹理设置为这个新纹理。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="2a44" class="la jr hi kw b fi lb lc l ld le">Texture2D texture = new Texture2D(final.cols(), final.rows(), TextureFormat.RGBA32, false);</span><span id="0ad9" class="la jr hi kw b fi lf lc l ld le">try<br/>{<br/>  Utils.matToTexture2D(final, texture);<br/>  detectionView.texture = texture;<br/>}<br/>catch (Exception)<br/>{<br/>}</span></pre><p id="caef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要设置灯泡的颜色。在这里，我使用了一种不太可靠的方法来改变阿尔法和颜色值，但这只是为了给人一种运动的印象，所以我认为这很好。</p><p id="114e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里所做的是，我已经获得了“最终”Mat中非零值的计数。这是因为，在“最终”Mat中，我们将在没有运动的区域使用全零(黑色),而在检测到运动的区域使用其他灰度值。因此，首先我使用Debug.Log检查了通常出现的非零值的范围(当然，要做到这一点，我们需要在运行这个脚本之前在unity editor中配置其他东西，我们还没有这样做)。我发现通常这个计数小于250000(即使没有运动，这个值也在80000左右。我觉得是因为相机的噪音)。所以我决定将这个值除以1000，这样我们可以得到一个介于1和255之间的值，它可以用作颜色(红色)和alpha值。</p><p id="0c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是实现它的代码。</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="5b7b" class="la jr hi kw b fi lb lc l ld le">Byte value = 0;</span><span id="20aa" class="la jr hi kw b fi lf lc l ld le">try<br/>{<br/>  value = Convert.ToByte(Core.countNonZero(final) / 1000);<br/>}<br/>catch (OverflowException)<br/>{<br/>  value = 255;<br/>}<br/>bulb.color = new Color32(value, 0, 0, value);</span></pre><p id="ebf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我添加了一个try-catch块来捕获任何溢出(以防字节值超过255)，如果有溢出，我将该值设置为最大可能值255。</p><p id="9dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的motionDetection()方法应该如下所示:</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="095a" class="la jr hi kw b fi lb lc l ld le">private IEnumerator motionDetection()</span><span id="e5d5" class="la jr hi kw b fi lf lc l ld le">{<br/>  while (true)<br/>  {<br/>    //create Three Mats<br/>    Mat t0 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>    Utils.webCamTextureToMat(webcamTexture, t0); //obtain fram from webcam<br/>    yield return new WaitForSeconds(0.04F);// wait for 0.04s<br/>    yield return new WaitForEndOfFrame();// wait till end of frame</span><span id="4e62" class="la jr hi kw b fi lf lc l ld le">    Mat t1 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>    Utils.webCamTextureToMat(webcamTexture, t1);<br/>    yield return new WaitForSeconds(0.04F);<br/>    yield return new WaitForEndOfFrame();</span><span id="a204" class="la jr hi kw b fi lf lc l ld le">    Mat t2 = new Mat(webcamTexture.height, webcamTexture.width, CvType.CV_8UC4);<br/>    Utils.webCamTextureToMat(webcamTexture, t2);<br/>    yield return new WaitForSeconds(0.04F);<br/>    yield return new WaitForEndOfFrame();</span><span id="40ba" class="la jr hi kw b fi lf lc l ld le">    //Change color to greyscale<br/>    Imgproc.cvtColor(t0, t0, Imgproc.COLOR_RGBA2GRAY);<br/>    Imgproc.cvtColor(t1, t1, Imgproc.COLOR_RGBA2GRAY);<br/>    Imgproc.cvtColor(t2, t2, Imgproc.COLOR_RGBA2GRAY);</span><span id="610f" class="la jr hi kw b fi lf lc l ld le">    //obtain difference in frames<br/>    Mat final = new Mat();<br/>    final = DiffImage(t0, t1, t2);</span><span id="83b8" class="la jr hi kw b fi lf lc l ld le">//set final Mat to texture of raw image<br/>    Texture2D texture = new Texture2D(final.cols(), final.rows(), TextureFormat.RGBA32, false);<br/>    try<br/>    {<br/>      Utils.matToTexture2D(final, texture);<br/>      detectionView.texture = texture;<br/>    }<br/>    catch (Exception)<br/>    {  <br/>    }</span><span id="7bb8" class="la jr hi kw b fi lf lc l ld le">//change bulb alpha value<br/>    Byte value = 0;<br/>    try<br/>    {<br/>      value = Convert.ToByte(Core.countNonZero(final) / 1000);<br/>    }<br/>    catch (OverflowException)<br/>    {<br/>      value = 255;<br/>    }<br/>    bulb.color = new Color32(value, 0, 0, value);<br/>  }<br/>}</span></pre><p id="f549" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在打开unity编辑器，将我们的detection.cs脚本作为组件添加到ScriptHandler游戏对象中。然后你会看到它需要3张原始图像。将我们之前创建的原始图像拖放到相关的框中。</p><p id="4ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的设置应该如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lg"><img src="../Images/563eb8a60418319c912ff688da694423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctsE9kzaq8sbNjuuXrvpeg.jpeg"/></div></div></figure><p id="027f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在保存场景并在编辑器中运行它。</p><p id="9795" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你应该得到这样的东西。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/93bb2b37e2be1ea5c84da7d6d19f99fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wvpH6IWtgKKk57rLJVbZmg.gif"/></div></div></figure><p id="7ffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想在此基础上构建一个android应用，进入构建设置，将平台切换到android，根据需要调整画布上对象的大小和位置，并构建项目以获得apk文件。(此外，您可能需要从游戏窗口调整画布的大小)。此外，将CameraView和DetectionView的旋转z值更改为'-90 '，因为出于某种原因，默认情况下相机进给是旋转的。</p><p id="e9d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是它在我的android手机上的工作原理。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/abeae23923ffa9ae5a66ed5d669c31aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/1*pXU9fCpFIScdumQX02RtwA.gif"/></div></figure><p id="d5be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目到此为止。请让我知道你的反馈。谢谢大家！干杯！😀</p></div></div>    
</body>
</html>
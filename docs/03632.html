<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/geekculture/reusing-variables-in-golang-bcb02e7e84ab?source=collection_archive---------14-----------------------#2021-06-12">https://medium.com/geekculture/reusing-variables-in-golang-bcb02e7e84ab?source=collection_archive---------14-----------------------#2021-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6524c41fb8847b4fe7c63042b2f34af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzDzMSjd0Z8BvfE-1bKpeA.png"/></div></div></figure><h2 id="5f42" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">Go中重用的变量</h2><p id="f44a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">一般来说，重用/回收变量是个坏主意(参见:<a class="ae jl" href="https://en.wikiversity.org/wiki/Software_Design/Don%27t_reuse_a_variable" rel="noopener ugc nofollow" target="_blank">软件设计/不要重用变量</a>)。它降低了代码的可读性，增加了调试的难度，并可能导致糟糕的设计。</p><p id="a415" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">下面几节将重点介绍Go中重用/回收变量的一些问题。</p><h2 id="b141" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated"><code class="du jr js jt ju b">range</code></h2><p id="33a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated"><code class="du jr js jt ju b">range</code>是一个Go内置关键字，用于迭代数组和切片。该语法比C-style for循环<a class="ae jl" href="https://golang.org/ref/spec#RangeClause" rel="noopener ugc nofollow" target="_blank">for SMT = " for "[Condition | for clause | range clause]块更短。</a>，但其工作方式一开始可能会令人困惑。</p><p id="e76b" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">查看以下代码片段:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="edf4" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">输出:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="22ff" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">注意，<code class="du jr js jt ju b">a</code>的地址在迭代之间是相同的，并且<code class="du jr js jt ju b">input </code>中的底层值不会改变。这是因为:</p><blockquote class="kb kc kd"><p id="ca3a" class="iq ir ke is b it jm iv iw ix jn iz ja kf jo jc jd kg jp jf jg kh jq ji jj jk hb bi translated">当在一个片上进行范围调整时，每次迭代返回两个值。第一个是索引，第二个是该索引处元素的副本。<a class="ae jl" href="https://tour.golang.org/moretypes/16" rel="noopener ugc nofollow" target="_blank">https://tour.golang.org/moretypes/16</a></p></blockquote><p id="61e4" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">在每次迭代之间，只有一个变量被修改——而且是副本，而不是底层元素。</p><h2 id="83d7" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">解码</h2><p id="c349" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">虽然重用结构来解码数据(例如JSON、XML、数据库行)可能很诱人，但我要指出这种方法的一个问题，尤其是在解码部分或无效数据时。</p><h2 id="3d3e" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">包含省略字段的有效JSON</h2><p id="f48a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">这里的问题是在处理省略的数据时会有副作用。当多次重用一个变量来解码数据时，第一个变量中的一些字段会泄漏到第二个变量中，这可能会有问题。</p><p id="640b" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">下面的简短代码片段展示了问题的本质:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="cdc2" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">输出:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="06fb" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">注意第二个JSON字符串中省略了<code class="du jr js jt ju b">valB</code>。在很多情况下，您可以像这样省略JSON可能是来自一个(不安全的)HTTP补丁请求，其中API只需要客户端想要更新的字段。或者可能该字段在以前的JSON序列化中未被设置，而<code class="du jr js jt ju b">omitempty</code>标签指示编码器忽略未设置的字段。</p><p id="d4b7" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">无论是哪种情况，我们都有JSON，所以让我们看看解码时会发生什么。</p><p id="017e" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">第一个解组操作导致每个字段被设置为1 ( <code class="du jr js jt ju b">{"valA":1,"valB":1}</code>)，第二个JSON字符串将<code class="du jr js jt ju b">valA</code>覆盖为0 ( <code class="du jr js jt ju b">{"valA":0,"valB":1}</code>)。注意<code class="du jr js jt ju b">valB</code>从第一个解码步骤开始就保持不变。</p><p id="2028" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">这可能并不奇怪——您正在重用内存并用新数据覆盖其中的一部分。</p><h2 id="2f62" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">包含省略字段的有效数据库行</h2><p id="75d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">好吧，让我们看一个可能更微妙的数据库示例:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="4dc2" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">输出:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="204f" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">这个例子与上一个例子基本相同，除了不是用省略的字段解码JSON，而是用省略的值解码数据库行。</p><h2 id="507b" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">解码失败</h2><p id="fbc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">到目前为止，我已经提供了传入数据(JSON/DB行)有效但包含省略数据的例子。但是有些情况下，传入的数据可能是错误的格式或者部分不完整(例如<a class="ae jl" href="https://en.wikipedia.org/wiki/JSON_streaming" rel="noopener ugc nofollow" target="_blank">streaming JSON</a>)，或者您可能只是在用错误的输入数据运行测试。不管是哪种情况，在这里重用一个结构也会产生问题。</p><p id="ffb7" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">以下示例在<code class="du jr js jt ju b">dataSequence</code>数组的开头和结尾包含2个有效的JSON字符串，另一个包含一个无效字段，并且没有添加到<code class="du jr js jt ju b">As</code>数组中。</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="cf42" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">输出:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="1d8c" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">这是一个有趣的情况。由于<code class="du jr js jt ju b">valA</code>字段的无效类型，第二次解组将(部分)失败，但是解码器继续工作并成功设置了<code class="du jr js jt ju b">valB</code>。虽然解组操作返回一个错误，并且解码后的对象没有放入数组的<code class="du jr js jt ju b">A[1]</code>索引中，但是值仍然在循环的迭代之间溢出，就像以前一样。</p><h2 id="8f68" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">并发问题(竞争条件)</h2><p id="1da4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">让我们假设这是您为HTTP补丁处理程序选择的一般设计，对单个资源的请求进行并发处理，并且您将该资源存储在内存中的某个地方以便重用。(我希望您已经看到了运行多个线程共享一个资源的并发代码的问题，如果没有，请查看代码片段下面的输出)</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="8c33" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">输出:</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="2030" class="pw-post-body-paragraph iq ir ht is b it jm iv iw ix jn iz ja id jo jc jd ih jp jf jg il jq ji jj jk hb bi translated">我想到了几个解决方案来避免这种数据竞赛:</p><ol class=""><li id="d983" class="ki kj ht is b it jm ix jn id kk ih kl il km jk kn ko kp kq bi translated">将变量复制到不同的地址，并将副本传递给每个线程。</li><li id="f667" class="ki kj ht is b it kr ix ks id kt ih ku il kv jk kn ko kp kq bi translated">实现共享资源的锁定机制(<code class="du jr js jt ju b"><a class="ae jl" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank">"sync"</a></code>)。</li><li id="5727" class="ki kj ht is b it kr ix ks id kt ih ku il kv jk kn ko kp kq bi translated">不要跨线程重用和共享这个结构。</li></ol><h2 id="1f1f" class="hr hs ht bd hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip bi translated">结论</h2><p id="7c7b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja id jb jc jd ih je jf jg il jh ji jj jk hb bi translated">结论是，通常最好避免重用/回收结构，尤其是在解码数据时应该避免。</p></div></div>    
</body>
</html>
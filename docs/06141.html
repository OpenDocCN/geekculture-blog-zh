<html>
<head>
<title>How to implement Singleton in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中实现Singleton</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-implement-singleton-in-typescript-3af39070d01?source=collection_archive---------7-----------------------#2021-08-07">https://medium.com/geekculture/how-to-implement-singleton-in-typescript-3af39070d01?source=collection_archive---------7-----------------------#2021-08-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/07a8d292da80591b8fe1d3b70fa24378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pQpSlrT5x7Ot8UYH"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="iv iw ix"><p id="192c" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在软件工程中，单例模式是一种<strong class="jb hj">软件设计模式，它将一个类的实例化限制为一个“单个”实例</strong>。当只需要一个对象来协调整个系统的动作时，这很有用。这个术语来自独生子女的数学概念。</p></blockquote><p id="c0a6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">免责声明:这篇文章不是要讨论单例设计模式是否真的有用，而是如何在TypeScript中实现它</em></p><p id="a18f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们来看看我们通常如何定义一个<em class="ja">类</em></p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="e52b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我相信你们大多数人都非常熟悉上面的模板，基本上我们有一个<code class="du kg kh ki kj b">constructor</code> <em class="ja"> </em>函数，它允许我们使用关键字<code class="du kg kh ki kj b">new</code>来创建一个新的实例。</p><p id="2700" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在，如果我需要使用这个定制的<code class="du kg kh ki kj b">log</code>函数，我可以通过声明一个新的<code class="du kg kh ki kj b">Logger</code> <em class="ja"> </em>类实例并调用该函数来轻松实现。但是从代码可读性的角度来看，拥有一个以上的<code class="du kg kh ki kj b">Logger</code>实例并没有什么意义，因为这个类不需要定制，这就是<em class="ja">单例设计模式</em>发挥作用的地方。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="925d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">为了将上面的类变成一个<em class="ja">单例</em>类，首先我们需要禁用其他任何人来创建一个<code class="du kg kh ki kj b">Logger</code> <em class="ja"> </em>类的新实例，为了做到这一点，我们可以简单地向我们的构造函数添加一个<code class="du kg kh ki kj b">private</code> <em class="ja">访问修饰符</em></p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="e784" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">从结果可以看出，当我们试图实例化该类时，TypeScript立即对第9行感到不满。</p><p id="fa9a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">然后，我们可以有一个类属性来存储单个实例，如下所示</p><pre class="ka kb kc kd fd kr kj ks kt aw ku bi"><span id="5169" class="kv kw hi kj b fi kx ky l kz la">private static instance: Logger;</span></pre><p id="9c0e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">请注意我们是如何将它标记为<code class="du kg kh ki kj b">private static</code>的，因此这是一个<em class="ja">静态</em>属性，不允许从类本身之外的任何地方访问，并且它的类型是<code class="du kg kh ki kj b">Logger</code> <em class="ja">。</em></p><p id="00ab" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">既然我们已经有了存储实例的类属性，我们只需要一个方法来创建并存储这个实例</p><pre class="ka kb kc kd fd kr kj ks kt aw ku bi"><span id="a49b" class="kv kw hi kj b fi kx ky l kz la">static getInstance() {<br/>  if (Logger.instance) {<br/>    return this.instance;<br/>  }<br/>  this.instance = new Logger();<br/>  return this.instance;<br/>}</span></pre><p id="477e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">上面的代码非常简单，基本上我们检查我们之前定义的类属性<code class="du kg kh ki kj b">instance</code>是否有值，如果有，返回那个实例，否则我们通过<code class="du kg kh ki kj b">new</code>关键字创建一个新的实例。</p><p id="7046" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">你可能想知道为什么我们在这里可以有<code class="du kg kh ki kj b">new</code>关键字，这仅仅是因为<code class="du kg kh ki kj b">getInstance</code>方法本身在<code class="du kg kh ki kj b">Logger</code>类中，因此它可以访问构造函数——即使它被标记为<code class="du kg kh ki kj b">private</code></p><p id="cd5b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">就这样，我们已经将我们的<code class="du kg kh ki kj b">Logger</code>类转换成了一个<em class="ja"> Singleton。</em>下面是它的完整代码</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="8831" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">感谢您的阅读，我希望这将帮助您了解更多的设计模式。为了获得反馈和合作机会，我邀请您与我联系，让我们继续对话！</p></div></div>    
</body>
</html>
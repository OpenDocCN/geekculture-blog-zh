# 递归

> 原文：<https://medium.com/geekculture/recursion-ea2e3b35cb49?source=collection_archive---------17----------------------->

## 如果一个函数可以调用其他函数，那么它就可以调用自己。这叫做递归。

![](img/4b6621c24605f427d71af3a76e572dd1.png)

根据维基百科的定义:

*递归是一种方法，其中问题的解决方案依赖于同一问题的较小实例的解决方案。*

我已经可以想象你的眼睛呆滞。让我们用一个电影院的类比来解释递归。

假设你在一个电影院，那里的排是没有编号的。有人问你在哪一排。你不想数，所以你问你前面的人。他也不想数，所以他们问他们前面的人。这延续到前排的人。那个人看不到他们前面的人，所以他们告诉后面的人他在第一排。第二排的人在他的回答上加 1，并告诉他后面的人他在第三排。这一直延续到最初提出问题的人。

问题“我是第几排？”可以(递归地)重新表述为“我前面有多少人+ 1？”基本情况是零。

*如果一个函数可以调用其他函数，那么它就可以调用自己。这叫做递归。*

递归可能是解决大量问题的有用策略。当一个问题可以被定义为子问题的解决方案时，它工作得很好。

**示例 1 —阶乘**

什么是 n！(n 阶乘)？n！是 n * (n-1) * (n-2) * … * 1。我们也可以说 n！是 n * (n-1)！。这导致计算 n 的代码非常短！。

1.int factorial(int n) {

2.if (n == 0 或 n == 1) { /*基本情况*/

3.返回 1；

4.}否则{

5.返回 n *阶乘(n-1)；

6\. }

7\. }

基本情况(或终止条件)极其重要。没有它，函数将永远运行。

**内存使用量**

任何可以递归解决的问题也可以迭代解决(非递归地使用循环)，尽管有时这样做要复杂得多。然而，递归有一个缺点，那就是内存使用。

阶乘示例的内存使用量也是 O(N)。factorial(n)方法调用 factorial(n-1)，后者调用 factorial(n-2)，依此类推。请注意，factorial(n)在 factorial(n-1)完成之前不会完成，而 factorial(n-1)在 factorial(n-2)之前不会完成。

因此，在某个时间点，我们在“调用堆栈”上同时运行 n 个函数

阶乘(0)

阶乘(1)

…

阶乘(n-1)

阶乘

每一个都会占用一些内存。因此，在某个时间点，正在使用 n 个内存块。这意味着这个程序在递归实现时，时间和内存都是 O(N)。

这就是递归的缺点:递归调用占用内存。

**示例 2 —斐波那契数**

大家可能还记得，第 n 个斐波那契数 f(n)是 f(n-1) + f(n-2)。

1.int fibonacci(int n) {

2.if (n == 0) {

3.返回 0；

4.} else if (n == 1) {

5.返回 1；

6.}否则{

7.返回斐波那契(n-1) +斐波那契(n-2)；

8\. }

9\. }

这是一个可以递归实现的自然函数，因为第 n 个斐波那契数是由它们较小的问题定义的。
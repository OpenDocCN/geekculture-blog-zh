<html>
<head>
<title>Why you shouldn’t use booleans in REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该在REST APIs中使用布尔值</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-you-shouldnt-use-booleans-in-rest-apis-2747b187876c?source=collection_archive---------0-----------------------#2021-06-16">https://medium.com/geekculture/why-you-shouldnt-use-booleans-in-rest-apis-2747b187876c?source=collection_archive---------0-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3ccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当设计REST APIs时，方便的决定会对我们工作的发展产生负面影响。这方面的一个例子是在API契约中使用布尔值。如果不仔细考虑，布尔值可以:</p><ul class=""><li id="9333" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">阻碍<strong class="ih hj"> API </strong> <strong class="ih hj">扩展性</strong></li><li id="25c9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">屏蔽和混淆<strong class="ih hj">域清晰度</strong></li><li id="cf07" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">防碍<strong class="ih hj">代码</strong> <strong class="ih hj">可读性和可维护性</strong></li></ul><p id="a848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们深入研究这些领域，并审核如何在REST APIs中普遍使用布尔值。</p><h1 id="1537" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak"> API扩展性</strong></h1><p id="c8dd" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一个可扩展的API <em class="ku">应该</em>让未来的改变变得显而易见并易于实施。It <em class="ku">不应该</em>引入复杂性或不必要的重复或打破现有的消费者。</p><p id="1068" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku">示例:</em> </strong> <em class="ku"> Github API —创建新的资源库</em></p><p id="763c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一下Github的REST API。为了<a class="ae kv" href="https://docs.github.com/en/rest/reference/repos#create-a-repository-for-the-authenticated-user" rel="noopener ugc nofollow" target="_blank">创建一个新的存储库</a>，开发者通过设置一个布尔字段(默认:<code class="du kw kx ky kz b">false</code>)来指定该存储库是否为<code class="du kw kx ky kz b">private</code>。这是布尔的一种常见用法HTTP资源(<code class="du kw kx ky kz b">repos</code>)的单个<strong class="ih hj">状态指示器</strong>。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="525d" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request:</strong> <strong class="kz hj">POST </strong>/user/repos<strong class="kz hj"><br/></strong>{<br/>  "name": "Hello-World",<br/>  "description": "This is your first repository",<br/><strong class="kz hj">  "private": false,<br/>  ...<br/></strong>}</span></pre><p id="a52a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个示例POST请求乍一看似乎很简单。但是当Github后来引入组织库时，他们需要限制只能由组织成员访问。在这种情况下，布尔字段<code class="du kw kx ky kz b">private</code>不再足够。因此，他们添加了一个新的<code class="du kw kx ky kz b">visibility</code>枚举，具有以下选项:</p><ul class=""><li id="3bf5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du kw kx ky kz b">internal</code> —仅限于组织成员</li><li id="2f57" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kw kx ky kz b">public</code> —可从互联网上公开访问</li><li id="cdca" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kw kx ky kz b">private</code> —仅限于存储库创建者和协作者</li></ul><p id="918f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着这一改变，文档说明当两者都被使用时,<code class="du kw kx ky kz b">visibility</code>优先于<code class="du kw kx ky kz b">private</code>。如果Github最初使用带有两种可能性<code class="du kw kx ky kz b">['public', 'private']</code>的<code class="du kw kx ky kz b">visibility</code>枚举，那么在不引入新字段的情况下添加第三种(<code class="du kw kx ky kz b">internal</code>)可能会更明显。虽然这种变化没有破坏现有的消费者，但它导致了文档的混乱和API中领域概念的重复。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="33d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看API中布尔的另一个常见用法HTTP资源的<strong class="ih hj">功能配置</strong>。在这种情况下，一组布尔值一起工作来提供一组打开或关闭的功能。使用Github端点创建一个存储库，请求如下所示:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="56f5" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request:</strong> <strong class="kz hj">POST </strong>/user/repos<strong class="kz hj"><br/></strong>{<br/>  "name": "Hello-World",<br/>  "description": "This is your first repository",<br/>  "private": false,<strong class="kz hj"><br/>  "has_issues": true,<br/>  "has_projects": true,<br/>  "has_wiki": false,<br/>  "has_downloads": true</strong><br/>}</span></pre><p id="6913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，布尔值<code class="du kw kx ky kz b">has_issues, has_projects, has_wiki, has_downloads</code>表示一旦创建了存储库，用户将看到的功能。在这个例子中，客户机代码将为每个真实的布尔值有一个单独的执行流。下面是表示这一流程的图表:</p><figure class="la lb lc ld fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/be369bf651d02c727e1c670680642b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aw32jUA_rVcYcyIY5Vc_g.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Capability Configuration booleans</figcaption></figure><p id="a03f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的问题是，<em class="ku"> </em> <strong class="ih hj"> <em class="ku"> 4个布尔值</em> </strong>产生了<strong class="ih hj"> <em class="ku"> 16种不同的排列</em> </strong>来测试客户端代码。这是用一个指数复杂度函数<strong class="ih hj"><em class="ku"/></strong>来描述的，其中<strong class="ih hj"> <em class="ku"> n </em> </strong>是布尔数，<strong class="ih hj"> <em class="ku"> 2 </em> </strong>是二进制值<code class="du kw kx ky kz b">true</code>或<code class="du kw kx ky kz b">false</code>。假设有条件地需要一个新的、相关的用户特性。添加一个新的布尔将产生32种不同的排列<strong class="ih hj"><em class="ku"/></strong>来测试。</p><p id="3c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种指数级的复杂性违反了前面介绍的可扩展性定义。更好的设计是将这种配置转换成一种相互包含的数据结构，比如数组<code class="du kw kx ky kz b">repository_capabilities: ["has_issues", "has_projects", "has_downloads"]</code>。这减少了不同的路径，因为API消费者可以使用能力到执行流的映射来动态构建用户功能。</p><h1 id="cdaf" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">领域清晰度</h1><p id="d39c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一个明确的领域<em class="ku">应该</em>有指导意义。它的组件<em class="ku">应该</em>可以通过一种无处不在的语言被发现。It <em class="ku">应该</em>通过清晰的边界封装逻辑，以避免下游的错误。最后，它<em class="ku">应该</em>很难误用它的任何组件。</p><p id="563f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku">示例:</em> </strong> <em class="ku">付款API —发送新付款</em></p><p id="42a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一个金融服务行业的例子。大多数支付网关API会用一个布尔字段<code class="du kw kx ky kz b">isApproved</code>来响应支付请求。这是HTTP资源(<code class="du kw kx ky kz b">/payments</code>)的单个<strong class="ih hj">状态指示器</strong>。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="438b" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request: POST </strong>/payments<strong class="kz hj"><br/></strong>{<br/>  "<!-- -->transactionId": "uniqueId",<br/>  "paymentDetails": {...}<br/>  "<!-- -->chargeAmount": 15.00,<strong class="kz hj"><br/>  ...<br/></strong>}</span><span id="a412" class="li js hi kz b fi mg lk l ll lm"><strong class="kz hj">HTTP Response:</strong><strong class="kz hj"><br/></strong>{<br/><strong class="kz hj">  "</strong><strong class="kz hj">isApproved": true,</strong><br/>  "<!-- -->approvedAmount": 15.00,<strong class="kz hj"><br/>  ...<br/></strong>}</span></pre><p id="d213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，这个API契约是有意义的。客户发送付款，然后付款被批准或拒绝。但是随着您的深入挖掘，您会发现除了二元结果<code class="du kw kx ky kz b">isApproved</code>之外，不同批准结果的隐藏概念。</p><p id="9cba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了详细说明这一点，假设您使用一张余额为10美元的借记卡来支付15美元的交易金额。根据商家的配置，交易可能被批准支付$10的余额。这是一种<em class="ku">部分批准</em>，商家欣然接受你的10美元，并要求通过现金或另一张卡支付剩余部分。下面是这个场景的一个API契约示例:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="c329" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request: POST </strong>/payments/<strong class="kz hj"><br/></strong>{<br/>  "<!-- -->transactionId": "uniqueId",<br/>  "paymentDetails": {...}<br/>  <strong class="kz hj">"</strong><strong class="kz hj">chargeAmount": 15.00,<br/>  ...<br/></strong>}</span><span id="a12c" class="li js hi kz b fi mg lk l ll lm"><strong class="kz hj">HTTP Response:</strong><strong class="kz hj"><br/></strong>{<br/><strong class="kz hj">  "</strong><strong class="kz hj">isApproved": true,</strong><br/>  <strong class="kz hj">"</strong><strong class="kz hj">approvedAmount": 10.00,<br/>  ...<br/></strong>}</span></pre><p id="e83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个API中，“部分批准”的概念是隐含的。API消费者必须检查1)支付<code class="du kw kx ky kz b"><strong class="ih hj">isApproved</strong></code>和2)支付<code class="du kw kx ky kz b"><strong class="ih hj">approvedAmount</strong></code>是否小于初始<code class="du kw kx ky kz b"><strong class="ih hj">chargeAmount</strong></code>。这里的隐含性质是领域逻辑泄露给消费者的症状。换句话说，这迫使消费者弄清楚“部分认可”的逻辑是什么，而不是我们直接告诉他们。领域边界的不清晰也将消费者与领域逻辑联系在一起。</p><p id="e840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看这个例子如何影响代码的可读性和可维护性。</p><h1 id="b18d" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">代码可读性和可维护性</strong></h1><p id="2523" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">代码可读性不仅仅是阅读代码做了什么。揭示代码的意图才是最重要的——为什么代码会这样做。</p><p id="b5a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前面的例子中，API中“<em class="ku">部分批准</em>”的隐含性质促使API消费者编写以下代码:</p><figure class="la lb lc ld fd lv"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="mc md et er es me mf bd b be z dx">Here, “Partial Approvals” for payments are <strong class="ak">implicit</strong></figcaption></figure><p id="dd35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有一个更好的方法。如果我们在API中明确引入“部分批准”,我们可以编写反映该领域普遍语言的代码——清楚揭示我们意图的代码。以下是推荐的API:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="b12d" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request: POST </strong>/payments/<strong class="kz hj"><br/></strong>{<br/>  "<!-- -->transactionId": "uniqueId",<br/>  "paymentDetails": {...},<br/>  "<strong class="kz hj">chargeAmount": 15.00,<br/>  ...<br/></strong>}</span><span id="28a5" class="li js hi kz b fi mg lk l ll lm"><strong class="kz hj">HTTP Response:</strong><strong class="kz hj"><br/></strong>{<br/>  <strong class="kz hj">"</strong><strong class="kz hj">paymentStatus": "PARTIALLY_APPROVED"<br/>  "</strong><strong class="kz hj">approvedAmount": 10.00,<br/>  "remainingAmount": 5.00,<br/>  ...<br/></strong>}</span></pre><p id="2f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的API有了一个值为<code class="du kw kx ky kz b">PARTIALLY_APPROVED</code>的枚举<code class="du kw kx ky kz b">paymentStatus</code>。API中这种有意的清晰性促使开发人员编写反映API语言的代码:</p><figure class="la lb lc ld fd lv"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="mc md et er es me mf bd b be z dx">Here, “Partial Approvals” for payments are <strong class="ak">explicit</strong></figcaption></figure><p id="a7d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用enum，我们允许API消费者1)通过API本身发现不同的值，从而了解更多关于域的信息，2)从它的强类型值中受益，这反过来减少了错误(即:舍入错误)。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="3246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑API中布尔用法的最后一个例子HTTP资源上的<strong class="ih hj">策略执行</strong>。这和<strong class="ih hj">功能配置</strong>布尔的区别在于客户端可能不太关心排列。相反，客户可能只关心什么是允许的，而忽略除此之外的任何事情。执行流程大致保持不变。让我们看一个例子。</p><p id="cad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当非接触式支付(Google Pay、Apple Pay等)被引入时，商家需要调整他们的配置来接受它们。这种配置变化可能通过API发生——通常通过布尔值不正确地发生。下面是这个配置的GET请求示例。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f9c2" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request:</strong> <strong class="kz hj">GET</strong> /store/{id}/configuration<br/>{<br/>   "allow_apple_pay": true,<br/>   "allow_google_pay": true,<br/>   "allow_samsung_pay": false,<br/>   ...<br/>}</span></pre><p id="5ccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在此看到商店配置允许的付款方式列表。然而最终结果是一样的——用允许的方法处理支付，如果不支持，就拒绝支付。下面是这个<strong class="ih hj">策略执行</strong>布尔示例的示意图:</p><figure class="la lb lc ld fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mj"><img src="../Images/4284e8c95bdb62f3ef7a2d279b9e538e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbZuQRQwLIAN16GA5-CSUg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Policy Execution booleans</figcaption></figure><p id="9dc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个API响应促使开发人员编写如下所示的代码:</p><figure class="la lb lc ld fd lv"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="d649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些不同的排列不仅影响代码的可维护性，还会使代码测试变得更加笨拙和不必要的重复。现在让我们更改API响应，返回一个数组<code class="du kw kx ky kz b">allowedPaymentMethods</code>,如下所示:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="8734" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request:</strong> <strong class="kz hj">GET</strong> /store/{id}/configuration<br/>{<br/>   "allowedPaymentMethods": [<br/>      "GOOGLE_PAY", <br/>      "APPLE_PAY"<br/>   ],<br/>   ...<br/>}</span></pre><p id="5a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一简单的更改将比代码具有巨大的可维护性优势。我们的代码现在看起来会像这样:</p><figure class="la lb lc ld fd lv"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="c69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果新的支付方式被引入并被某个商店允许，这段代码不需要修改。</p><h1 id="60d9" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">何时在API中使用布尔值</h1><p id="d41e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在某些情况下，我们可以从REST APIs中布尔的严格特性中获益。但是，这些情况应该由域本身的约束来指导。</p><p id="d7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku">举例:</em> </strong> <em class="ku">钱包API — </em>添加支付选项。</p><p id="3e93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了说明，让我们考虑一个数字钱包API。钱包包括不同的卡支付选项(如:信用卡、借记卡、礼品卡)或支付方式(如:Google Pay)。钱包应用编程接口负责<code class="du kw kx ky kz b"><strong class="ih hj">default</strong></code>支付，因此用户不必每次交易都选择同一张卡。这里有一个例子:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="06e2" class="li js hi kz b fi lj lk l ll lm"><strong class="kz hj">HTTP Request: POST </strong>/wallet/payment-options<br/>{<br/>   "maskedNumber": "*******4433"<br/>   "cardNetwork": "VISA",<br/>   "nickname": "<em class="ku">My Preferred Card",<br/>   </em><strong class="kz hj">"default": true,<br/>   ...<br/></strong>}</span></pre><p id="04a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为同时用多张卡在线支付一笔交易是不可能的，所以最好使用一个类似于域限制的布尔值。</p><p id="c2a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们想象一下，从两个独立的支付选项中为交易融资成为可能。随着这种变化，<code class="du kw kx ky kz b">default</code>的概念仍然有效吗？事实证明，现在依然如此。在这种情况下，用户可能不得不在他们的<code class="du kw kx ky kz b">default</code>上选择另一张卡。</p><p id="9aad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们的设计意图通过布尔的严格性质得到了最好的传达。使用布尔值1)不会阻碍我们扩展API功能，2)不会混淆领域，因此，3)不会影响我们代码的可读性。</p><h1 id="5cd7" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结束语</h1><ul class=""><li id="55ee" class="jd je hi ih b ii kp im kq iq mk iu ml iy mm jc ji jj jk jl bi translated">API需要在严格性和灵活性之间取得平衡。根据定义，布尔是限制性的。</li><li id="6415" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">API应该是指导性的。领域语言应该贯穿他们的合同。合同中每个字段的可能值应该很容易被发现。</li><li id="b356" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">布尔值不仅仅给REST APIs带来问题。这里有一篇关于<a class="ae kv" href="https://martinfowler.com/bliki/FlagArgument.html" rel="noopener ugc nofollow" target="_blank">标志参数</a>问题的好文章，作者是<a class="ae kv" href="http://martinfowler.com" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>。</li><li id="941d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">枚举和数组在API设计中比布尔提供了更多的灵活性。查看Google的<a class="ae kv" href="https://cloud.google.com/apis/design/design_patterns#bool_vs_enum_vs_string" rel="noopener ugc nofollow" target="_blank"> API设计模式，布尔vs枚举vs字符串</a>。</li></ul><h1 id="d05f" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">感谢</h1><p id="501e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">非常感谢Megan Lusher和Smitha Ajay阅读本文草稿并提供改进反馈。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="221f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这主要发生在当面/店内交易(又名:出示卡交易)。如果交易发生在网上，信用卡可能会被直接拒绝。根据客户和银行的不同，还可能出现其他情况，如过度起草。</p><p id="e671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在极少数情况下，商家允许顾客使用信用卡/借记卡和他们自己发行的礼品卡的组合。这当然是一个例外，不是一个常见的流程。</p></div></div>    
</body>
</html>
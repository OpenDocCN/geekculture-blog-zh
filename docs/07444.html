<html>
<head>
<title>Data Science Series | Visual Programming Using Orange Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学系列|使用Orange工具进行可视化编程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-science-series-visual-programming-using-orange-tool-27addd176448?source=collection_archive---------21-----------------------#2021-09-18">https://medium.com/geekculture/data-science-series-visual-programming-using-orange-tool-27addd176448?source=collection_archive---------21-----------------------#2021-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="eb77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用Orange Tool执行可视化编程的分步指南</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/51aed1db1ec8cff66bdfb7c4371e4700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WFbtQq6ZL79XM81byD6RPg.png"/></div></figure><p id="18ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你是使用Orange3的新手，那么我建议你点击这里阅读Orange的基本概述。</p><p id="ce10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从基本的工作流程开始。我们在工作流程中使用了IRIS数据集。</p><blockquote class="jm jn jo"><p id="ac64" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">将数据拆分为训练数据和测试数据</em> </strong></p></blockquote><p id="fc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了分割数据集，我们使用<strong class="ih hj">数据采样器</strong>小部件。我们将把数据分成两部分，80%的数据用于训练，20%用于测试。我们将发送前80%的建立一个模型，其余的测试目的。</p><p id="c0a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，将文件连接到数据采样器。然后，单击数据采样器，并在数据采样器中修改您想要的更改。</p><p id="9bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">数据采样器</em> </strong></p><p id="ed62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它从输入数据集中选择数据实例的子集。</p><p id="554e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入</strong></p><ul class=""><li id="a6a3" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">数据:输入数据集</li></ul><p id="4aea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><ul class=""><li id="24ae" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">数据样本:采样的数据实例(用于训练)</li><li id="4de4" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">剩余数据:样本外数据(用于测试)</li></ul><p id="4eba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们必须将整个数据集传递到<strong class="ih hj">数据采样器</strong>小部件中。默认情况下，数据集在<strong class="ih hj">数据采样器</strong>中分为训练数据(70%)和测试数据(30%)。在<strong class="ih hj">数据采样器</strong>小部件中，我们将把数据集分成训练(80%)和测试数据(20%)。</p><blockquote class="jm jn jo"><p id="c9f0" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">数据拆分对分类模型的影响&amp;结果</em> </strong></p></blockquote><p id="0e47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，为了知道效果，我们必须创建一个工作流来测试数据上的学习算法(SVM，KNN，等等)并给它们打分。我们将使用<strong class="ih hj">测试和评分</strong>小部件，该小部件从<strong class="ih hj">数据采样器</strong>获取数据，并对学习器算法进行训练、测试和评分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kh"><img src="../Images/03788f31730cd24de793415838abd441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_cvKjTC-P3W_PGeCqqizg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Generated Workflow</figcaption></figure><p id="7077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">测试和评分</em> </strong></p><p id="f1d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试数据的学习算法。</p><p id="9d29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入</strong></p><ul class=""><li id="3db8" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">数据:输入数据集</li><li id="8e01" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">测试数据:用于测试的单独数据</li><li id="11db" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">学习者:学习算法</li></ul><p id="a8c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><ul class=""><li id="5cd7" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">评估结果:测试分类算法的结果。</li></ul><p id="c1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分割数据后，我们必须通过连接两条线用于训练数据，另一条用于测试数据，将数据采样器与测试和得分小部件连接起来。因此，通过点击链接，它打开<strong class="ih hj">编辑链接，</strong>我们必须编辑链接，如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/ab0ca467674004d9c6ea06fdf1e31e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*sQj_fB_0_bbw8Gx-.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Link edit</figcaption></figure><p id="b2f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据样本(80%) -&gt;数据(训练数据)</p><p id="0ba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩余数据(20%) -&gt;测试数据</p><p id="a8d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此工作流利用朴素贝叶斯、随机森林、神经网络和KNN ( K近邻)微件来创建模型。所有的小工具都使用了机器学习方法。您可以像在生成的工作流中所做的那样，将您的所有小部件与作为学习者的<strong class="ih hj">测试&amp;分数</strong>小部件连接起来(见上图)。</p><p id="a921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试和评分</strong>小工具必须需要两件东西来测试和评分，如上面的<strong class="ih hj">测试和评分</strong>部分所示。</p><p id="fabf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(1)数据(培训和测试)</p><p id="dff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(2)机器学习算法</p><p id="c9c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将模型与训练和测试样本一起发送到<strong class="ih hj">测试&amp;得分</strong>后，我们在<strong class="ih hj">测试&amp;得分</strong>小部件内的表格中观察它们的表现。但是在观察评估结果之前，我们必须制作<strong class="ih hj"> Test and Score </strong> widget，通过点击widget左侧面板上的<strong class="ih hj"> Test on test data </strong>选项来评估测试样本，如下图所示。因为还有其他可供评估的选项，比如交叉验证、忽略一个选项等等。所以当使用测试数据时，我们总是在测试数据上测试我们的模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kr"><img src="../Images/3601dc9ccd416c839ea7cf404b81d6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8p8ljibSl_DDyRvW6bH6Q.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Test and Score on Test Data</figcaption></figure><blockquote class="jm jn jo"><p id="e8b0" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">测试与训练数据分离的重要性</em> </strong></p></blockquote><p id="4fbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据分离的主要目的是为了评估。因为过拟合是训练模型时常见的问题。当一个模型在我们用来训练它的数据上表现得非常好，但不能很好地推广到新的、以前看不见的数据点时，就会发生这种现象。</p><p id="92fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，测试数据充当新的、以前看不见的数据点，当模型基于测试数据进行评估时，我们开始知道模型的实际准确性。或者，当模型基于训练数据进行评估时，它会给出比测试数据更好的准确性，因为模型已经基于我们用于评估目的的相同特征进行了训练。但是这种模型并不适用于真实世界的数据，它们只是过度适应了训练集。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ks"><img src="../Images/52548646e88fb941a12bc516ac32fd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu9av5dmpm8BeraKA9PhdQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Test and Score on Training Data</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ks"><img src="../Images/37b42979bcc8fd613161bf59b04fc2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koJnpqrYikgEih9VGjrmBw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Test and Score on Test Data</figcaption></figure><p id="2890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以拆分数据对分类模型的影响无非就是CA(分类准确率)。这里我们可以看到，用于训练数据测试的CA(左侧)更大，但我们知道这并不被认为是实际的准确性；我们真的希望我们的模型能够推广到每一个测试数据。</p><blockquote class="jm jn jo"><p id="9adf" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">交叉验证</em> </strong></p></blockquote><p id="043e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉验证是一种用于估计机器学习模型性能(或准确性)的统计方法。它用于防止预测模型中的过度拟合，尤其是在可用数据量有限的情况下。在交叉验证中，创建一组数量的数据折叠(或分区)，对每个折叠进行分析，并对总误差估计值进行平均。</p><p id="f5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将数据分为训练数据和测试数据，这也是我们上面所做的验证类型，称为维持验证。改进维持方法的一种技术是使用K-fold交叉验证。这种策略确保了我们的模型的分数独立于训练和测试集的选择。数据集被细分为k个子集，并且保持方法被应用于每个子集k次。</p><p id="499a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于交叉验证的进一步阅读，请访问这个<a class="ae jl" href="https://www.mygreatlearning.com/blog/cross-validation/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">博客</strong> </a> <strong class="ih hj">。</strong></p><p id="24fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">橙色中交叉验证的高效使用</em> </strong></p><p id="1253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于使用测试和评分小部件的相同工作流，我们可以通过单击小部件左侧面板上的交叉验证选项来使用交叉验证，如下图所示。同样，我们可以改变K倍的值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kt"><img src="../Images/f8526a2055129375bfef34b221c61cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yh6C312Z7XmKdhZgMlO2Q.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Cross-Validation</figcaption></figure><p id="3854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如我们所见，我们使用K=10进行交叉验证，因此这里的折叠数是10。数据集被细分为10个子集，并且维持方法被应用于每个子集10次。</p><blockquote class="jm jn jo"><p id="5efe" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">对模型输出的影响&amp;精度</em> </strong></p></blockquote><p id="5b2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉验证是一种评估机器学习模型预测新数据能力的方法。它还可以用于检测过度拟合或选择偏差等问题，并提供有关模型如何推广到不同数据集的信息。这里，它执行K次，而不是单次保持方法，提供了模型更好的实际准确性。因此，我们可以看到交叉验证的准确性较低，但更准确或更一般化。</p><p id="a5f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">混淆矩阵也可以用于分析输出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ku"><img src="../Images/0a3bd3f619d81139c7311d5b310d558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5DuPaN1FKvNd0w0RWxQmQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Confusion Matrix for the Neural Network</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kv"><img src="../Images/9f1aa31af50746562c65d07dd85c3e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9c-wdnDy9c2UGB3tDIZsQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">The output of the Prediction method</figcaption></figure><p id="8368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预测</strong>小部件接受两个输入。一个是数据集，通常来自测试数据，另一个是“<strong class="ih hj">预测器</strong>”。"<strong class="ih hj">预测器</strong>是指任何<strong class="ih hj">模型</strong>小部件的输出。您可以将任意数量的<strong class="ih hj">模型</strong>部件与<strong class="ih hj">预测</strong>部件连接起来。</p><p id="8976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，就这样了。这就是你如何用Orange3进行基本的可视化编程。</p></div></div>    
</body>
</html>
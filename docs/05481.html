<html>
<head>
<title>Swift Core Concepts: Mastering Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift核心理念:掌握协议</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/swift-core-concepts-mastering-protocol-da56f0d35ab3?source=collection_archive---------7-----------------------#2021-07-22">https://medium.com/geekculture/swift-core-concepts-mastering-protocol-da56f0d35ab3?source=collection_archive---------7-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swift协议中最重要的功能之一:]</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3b00b66838b0f4cf2937a5d7829e1caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f2X-PNGof0GeYUdj"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@medbadrc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Med Badr Chemmaoui</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="f176" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">概观</h2><p id="4198" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">协议和面向协议的编程是Swift编程语言的重要特征。想象一下，如果我们在Swift中没有一个协议，我们在构建一个可扩展的系统时会面临许多困难。我们不能实现委托模式，不能做抽象，我们的系统不容易重构，有很高的脆弱性。所以在这篇文章中，我想对协议有一个很好的更新，我们如何使用它，并通过了解<strong class="ih hj">静态分派</strong>和<strong class="ih hj">动态分派</strong>之间的区别来理解它实际上是如何工作的。为了创建高质量的系统，掌握协议对我们作为iOS开发人员来说非常重要。</p><h2 id="86d4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">协议入门</h2><p id="8a8e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">假设我们有下面一行代码:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="904b" class="ju jv hi kv b fi kz la l lb lc">profileViewController.showLoading()</span></pre><p id="7978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码中，我们可以假设<strong class="ih hj"> profileViewController </strong>是来自<strong class="ih hj"> ProfileViewController </strong>类的一个实例，而<strong class="ih hj"> showLoading() </strong>是来自<strong class="ih hj"> ProfileViewController </strong>类中的一个函数的实例。Swift使用一种叫做type-system的东西来工作，它会检查<strong class="ih hj"> ProfileViewController </strong>是否有一个叫做<strong class="ih hj"> showLoading() </strong>的函数。如果你有一些使用Objective-C的经验，如果我们没有在<strong class="ih hj"> ProfileViewController </strong>类中定义<strong class="ih hj"> showLoading() </strong>函数，编译器会很高兴地运行程序。但是我们在使用Swift时会得到一个错误，因为基本上Swift是一种强类型编程语言，它会防止我们犯愚蠢的错误，比如忘记在类中定义<strong class="ih hj"> showLoading() </strong>函数。</p><p id="b295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如何将<strong class="ih hj"> showLoading() </strong>函数实现到另一种类型呢？也许我们有一些视图控制器，比如<strong class="ih hj"> HomeViewController </strong>，或者<strong class="ih hj"> ExploreViewController？我们是否可以实现函数showLoading() </strong>,而不需要为每种类型一一定义它？那么礼仪就成了英雄。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0dba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们之前的讨论，Swift将验证每种类型是否具有<strong class="ih hj"> showLoading() </strong>功能。如果不是，编译器会告诉我们一些错误。有了协议，我们可以定义<strong class="ih hj"> showLoading() </strong>函数，而不仅仅是针对特定的一种类型。无论哪种类型符合<strong class="ih hj">可加载</strong>协议，它都必须实现<strong class="ih hj"> showLoading() </strong>函数。这是协议的基本用法，让我们深入了解一下其他人从协议中获得了什么好处，并配置我们如何在真实的用例场景中实现它。</p><h2 id="189d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">抽象:隐藏具体的实现</h2><p id="aeaf" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">协议是一种工具，我们可以将一些类型分组，并且会有一些称为超类型的东西，这就是协议本身，我们可以隐藏每个类型的具体实现。例如，假设我们有两个类，正方形和长方形。我们都知道正方形有一个要求，那就是每条边的长度必须相等。我们也知道基本上正方形也是长方形。为了计算面积，我们用同样的方法计算正方形和长方形的面积，也就是x边。然后我们可以创建一个名为Rectangle的协议，我们可以将Square和Rectangle类组合成一个名为Rectangle的超类型。使用这种方法，我们只需要编写一个实现来计算面积。协议让我们觉得不在乎从正方形或长方形计算面积的细节实现。我们只需要在协议中定义需求，这样我们就可以使协议变得灵活和易于维护。</p><h2 id="ce80" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">协议语法</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="cd7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们将定义使用协议翻译语言的基本实现。看看<strong class="ih hj">可本地化的</strong>协议，它只有一个需求，就是静态变量，类型为<strong class="ih hj">语言的数组。</strong>它只需要getter，我们不需要定义setter。我们可以遵循<strong class="ih hj">可本地化的</strong>协议，并满足计算属性的需求，或者我们也可以使用<strong class="ih hj">私有(set) </strong>访问修饰符。我们还需要将变量设为静态，同时将它实现为我们的类型。</p><p id="d917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们有一个<strong class="ih hj">不可变可定位</strong>协议，它也符合<strong class="ih hj">可定位</strong>协议。如果我们想要符合<strong class="ih hj"> ImmutableLocalizable </strong>协议，那么我们需要满足两个要求:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="8edd" class="ju jv hi kv b fi kz la l lb lc">static var languages: [Language] { get }<br/>func translate(to language: Language) -&gt; Self</span></pre><p id="8a63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> translate </strong>函数返回<strong class="ih hj"> Self </strong>，这意味着它将返回符合协议的当前类型。例如，如果我们有一个<strong class="ih hj"> UILabel </strong>类，并且它符合<strong class="ih hj">不可变可定位</strong>协议，那么<strong class="ih hj">自身</strong>类型就是一个<strong class="ih hj"> UILabel </strong>自身<strong class="ih hj">。</strong></p><p id="c6ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们有一个<strong class="ih hj">可变本地化</strong>协议。实际上，这个协议有点类似于<strong class="ih hj">不可变本地化</strong>协议，如果你意识到我们把<strong class="ih hj">突变</strong>关键字放到<strong class="ih hj">可变本地化</strong>功能需求中是有区别的。<strong class="ih hj">如果我们想修改结构体内部的属性值，就在结构体内部使用变异</strong>。我们不需要在类中添加<strong class="ih hj">可变的</strong>关键字，因为默认情况下它已经是<strong class="ih hj">可变的了。</strong></p><h2 id="f2e1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">实现类型协议</h2><p id="db58" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对于我们之前已经制定的一些协议，让我们试着将它实现到类型中。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="024a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的实现来看，我们已经通过定义<strong class="ih hj">语言</strong>静态变量和<strong class="ih hj">翻译</strong>函数并在前面加上<strong class="ih hj">变异</strong>关键字来满足需求。我们也可以用类型的扩展来实现协议。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="cfe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有没有可能给协议一个默认的实现，这样我们就不需要在现有的类型中提供实现了？是的，它是。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="9f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个问题，有没有可能给协议一些约束？也许只有<strong class="ih hj"> UIViewController </strong>和它的子类型才能够符合协议？是的，它是:】。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><h2 id="c6b6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">但是协议实际上是如何工作的呢？:]</h2><p id="949a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">从之前关于协议的解释来看，老实说，作为一名iOS开发人员，我们能够在现实世界的用例中实现它已经足够了。但是如果你想成为一名真正的工程师，请跟我一起，不要停下来读这篇文章，让我们来配置协议如何工作，配置性能，以及需要考虑的事情。我们需要更深入地了解Swift编译器是如何工作的。</p><h2 id="416a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">静态调度与动态调度</h2><p id="f5e6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">具体来说，我们需要知道如果在Swift中调用某个功能会发生什么。Swift中关于函数调用有两种机制，静态调度和动态调度。静态调度非常简单，它习惯于一些永远不会改变或者已经被标记为final的函数。它可以在一些场景中找到，如全局函数、结构中的函数或标记为final的类中的函数。函数永远不变的意义是什么？基本上，它是永远不会被覆盖的函数，编译器作为一个高层会硬编码函数地址，并在Swift中调用函数时保存来自它的引用。</p><p id="6cc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那动态调度呢？与静态调度相比，这有点复杂。如果我们实现继承或者符合协议，函数调用将是一件复杂的事情。编译器不知道函数到底来自哪里，是来自超类吗？还是孩子班的？还是像我们在前面的例子中讨论的那样来自协议默认实现？</p><p id="9ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">swift编译器使用了一种叫做<strong class="ih hj">见证表</strong>的东西。每当我们创建一个新的类时，这个表就会被创建。类中的每个函数都会保存到表中。然后，子类将从表中复制一个值，并替换它需要覆盖的函数。Swift在运行时使用这个表。当函数被调用时，Swift将使用该表来配置函数的源。</p><p id="5449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用动态调度有一些缺点，比如编译器不能进行一些优化，因为每次调用函数都需要一个恒定的开销成本。我们可以得出结论，动态调度比静态调度慢。</p><h2 id="025c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">协议中的调度</h2><p id="cd3f" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">协议中的函数分派与前面的解释有点类似。每个符合协议的类型都会有一个叫做<strong class="ih hj">的协议见证表</strong>。协议中的每个需求，无论是变量还是函数，都会在表中有一行。该表将与符合协议的实例一起保存。和前面的例子一样，Swift将在运行时使用这个表。编译器将从表中找到函数并调用它。如果我们使用来自类的实例，编译器将从类表或协议见证表中动态地找到函数，以找到正确的源实现。</p><h2 id="3ced" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">从这里去哪里</h2><p id="1254" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">祝贺我的朋友读了这篇文章，我希望它对你有用。协议是Swift编程语言的一个重要特征。我们可以用它来解决现实世界中许多问题。如果您对本文有任何问题或反馈，请告诉我。非常感谢。我想我会继续写Swift的核心概念，比如通用、内存管理，甚至高阶函数。如果我通过我的linkedin创建了新文章，我会让你知道。谢谢:】。</p></div></div>    
</body>
</html>
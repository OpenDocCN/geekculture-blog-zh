<html>
<head>
<title>Internals Of Java Parallel Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java并行流的内部结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pitfalls-of-java-parallel-streams-731fe0c1eb5f?source=collection_archive---------6-----------------------#2021-06-03">https://medium.com/geekculture/pitfalls-of-java-parallel-streams-731fe0c1eb5f?source=collection_archive---------6-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3351" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为什么并行流不一定总是更快</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3e87b3046e57e556b740062e7e49247c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vyy7N0awIHsrIyyZ7MsjzQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@redviking509?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">John Anvik</a> on <a class="ae jn" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java 8中引入了流API，作为操作集合的有效方式。并行流作为并行处理的一部分被引入，以使应用程序运行得更快。虽然并行流被认为可以通过在多个线程之间分割任务并比顺序执行更快地完成任务来提高应用程序的性能，但是并行流有时也有可能会降低整个应用程序的速度。</p><h1 id="51c5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">顺序和并行执行中的线程</h1><p id="f7ea" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">考虑一个例子，一个流在一列数字上运行，它通过将数字乘以10来转换数字并返回结果。正在使用的线程的名称打印在<em class="lh"> transform() </em>中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/5e7bfc39ec4fc49f1ad4f2e7cd7b6de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0o3DaOQIeUF6o40AUn--fg.png"/></div></div></figure><p id="29d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行上述程序会产生以下输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/d6365b2a5dd64c0ebe4939804570e57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aul8xXSoq8KFHGknxQAgXA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Output of sequential and parallel execution</figcaption></figure><p id="fc86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顺序执行只使用主线程，而并行执行同时使用主线程和来自ForkJoinPool的线程。</p><h1 id="599f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">叉加入池</strong></h1><p id="9f93" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Java 7中引入的<em class="lh"> fork/join框架</em>，通过分而治之的方法，尝试使用所有可用的<strong class="jq hj"> <em class="lh">处理器内核</em> </strong>，帮助加速并行处理。<strong class="jq hj"> Fork </strong> step将任务分割成更小的子任务，这些任务由不同的线程并发执行。执行完所有子任务后，<strong class="jq hj"> Join </strong>步骤会将所有结果组合成一个结果。与顺序执行相比，这些步骤给并行执行增加了更多的开销。</p><p id="fc75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">fork/join框架使用由<em class="lh"> ForkJoinPool管理的线程池。</em>当使用Java并行流并行运行任务时，它在内部使用来自<em class="lh"> ForkJoinPool </em>的默认线程池(称为<em class="lh"> commonPool()，</em>的线程，这是一个静态线程池。</p><h2 id="ff01" class="lk kl hi bd km ll lm ln kq lo lp lq ku jx lr ls kw kb lt lu ky kf lv lw la lx bi translated"><strong class="ak">在公共池中有多少线程可用于并行执行？</strong></h2><p id="c641" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated"><strong class="jq hj"><em class="lh">forkjoinpool . common pool()</em></strong>中的线程数量比您机器中可用的<strong class="jq hj">逻辑CPU内核</strong>的数量少一个。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/f1a44a658b187390b93ead7215f5ad0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_tI7SDWFH7EcQ4LWuuzTg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Code to get the available processors on the machine and the amount of parallelism provided by ForkJoinPool</figcaption></figure><p id="6582" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的机器上的逻辑CPU数量是12，ForkJoinPool可以并行执行的线程数量是11。因此，总共12个任务可以在这里并行执行(main + ForkJoinPool)，使用所有12个CPU内核。<strong class="jq hj">并行流被配置为使用与运行程序的计算机或虚拟机中的核心数量一样多的线程。</strong></p><p id="d395" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了说明这一点，考虑上面列表中有15个数字的相同程序运行，这是并行运行的15个任务。因为在我的机器上可以并行执行的任务数量是12，所以首先执行前12个任务，剩下的3个任务将等待另外3个正在运行的线程完成执行。在下面给出的输出中，标记为<strong class="jq hj"> T1、T2和T3 </strong>的线程被使用了两次。<strong class="jq hj">因此，如果要执行的任务数量大于commonPool中的线程数量，剩余的任务将等待正在运行的任务完成。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/3542b487b24d8865156e6d4b72d600b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQx8EQFWP5tkNa5oZE41hA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Output of parallel execution with 15 numbers in list</figcaption></figure><h1 id="3473" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">平行流的副作用</h1><p id="cded" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">假设一个并行流在一个<em class="lh"> cpu密集型/阻塞任务</em>上运行。在此任务完成之前，用于此操作的ForkJoinPool中的线程不会被释放回commonPool。因此，当这个请求在每秒处理数千个请求的服务器上运行时，该服务器并行运行许多parallelStreams，少量请求将占用ForkJoinPool的commonPool中的整个线程，并导致其余请求排队，从而降低整个应用程序的速度。</p><p id="b9d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用ForkJoinPool线程时，任务不应处于阻塞状态，而应在合理的时间内结束。因此，对于需要同时处理多个请求的应用程序，应该谨慎使用并行流。</p></div></div>    
</body>
</html>
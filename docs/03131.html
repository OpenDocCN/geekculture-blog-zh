<html>
<head>
<title>Why Do We Need Interfaces in Java?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们在Java中需要接口？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-do-we-need-interfaces-in-java-9a95ef57a156?source=collection_archive---------3-----------------------#2021-06-01">https://medium.com/geekculture/why-do-we-need-interfaces-in-java-9a95ef57a156?source=collection_archive---------3-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/70a05430a0de51ae697a73b59edc11b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*y9zLbH0Y1g5kK1dVsRHVkw.gif"/></div></figure><p id="30c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接口在面向对象编程中起着非常重要的作用。面向对象的程序设计基于对象之间相互作用的思想。这些对象是从作为我们对象蓝图的类中实例化出来的。当我们创建一个类时，我们试图考虑我们想要在代码中重新创建的现实生活中的对象。说我们要一个班鸭。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/8f87f03a768891b24fa511ea4bb1e4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/1*KYfvFPou_Zta2btdX5UqhQ.gif"/></div></figure><p id="b9d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们开始考虑鸭子的状态和行为，它们与我们想要在程序中实现的目标相关。(这是四个创始概念之一——<strong class="io hj"><em class="jp"/></strong>——另外三个是封装、多态和继承)。我们希望我们的鸭子有一个名字，颜色和大小，这些将描述我们的鸭子的状态(其属性或特性)。我们还希望我们的鸭子会游泳、会飞、会吃东西，通过定义负责这些动作的方法，我们定义了鸭子的行为。</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="9872" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">import static </strong>java.lang.System.<strong class="jr hj"><em class="jp">out</em></strong>;<br/><br/><strong class="jr hj">public class </strong>Duck{<br/><br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">name</strong>;<br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">color</strong>;<br/>    <strong class="jr hj">private int size</strong>;<br/><br/>    <strong class="jr hj">public </strong>Duck(String name, String color, <strong class="jr hj">int </strong>size) {<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">name </strong>= name;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">color </strong>= color;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">size </strong>= size;<br/>    }<br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is swimming"</strong>);<br/>    }<br/><br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is flying"</strong>);<br/>    }<br/><br/>    <strong class="jr hj">public void </strong>eat() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is eating"</strong>);<br/>    }<br/>}</span></pre><p id="bf67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们在鸭子中定义的所有状态和行为都是与鸭子相关的状态和行为——这是一只真正的鸭子应该有的。如果想让我们的鸭子具有被绘制的能力(如果我们想让我们的鸭子有一张图片)——以图片的形式呈现，该怎么办？</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/76040cccf25ca7da9fcb05ac48862ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*wZaExymqExaKsEqScOayOw.gif"/></div></figure><p id="f414" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">把一个画鸭子的方法放到类duck里其实没有什么意义，因为画鸭子不是Duck的行为。让我们定义一个接口:</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="414d" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">public interface </strong>Drawable {<br/>    <strong class="jr hj">void </strong>draw();<br/>}</span></pre><p id="87b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们有我们的类Duck实现接口Drawable()。这迫使我们的类Duck拥有draw()方法的具体实现:</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="55c9" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">import static </strong>java.lang.System.<strong class="jr hj"><em class="jp">out</em></strong>;<br/><br/><strong class="jr hj">public class </strong>Duck <strong class="jr hj">implements </strong>Drawable{<br/><br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">name</strong>;<br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">color</strong>;<br/>    <strong class="jr hj">private int size</strong>;<br/><br/>    <strong class="jr hj">public </strong>Duck(String name, String color, <strong class="jr hj">int </strong>size){<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">name </strong>= name;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">color </strong>= color;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">size </strong>= size;<br/><br/>    }<br/><br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is flying"</strong>);<br/>    };<br/><br/>    <strong class="jr hj">public void </strong>eat() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is eating"</strong>);<br/>    }<br/><br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/><br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is swimming"</strong>);<br/>    }<br/>    @Override<br/>    <strong class="jr hj">public void </strong>draw() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I drew a duck"</strong>);<br/>    }<br/>}</span></pre><p id="79da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">！接口的使用允许类拥有逻辑上不属于它们的功能。</strong></p><p id="26de" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们希望能够数我们的鸭子呢？</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/2a595beb6080378b4dfdd99712d666b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Ck8bFertdxszmzXbpnRQ8w.gif"/></div></figure><p id="5ea0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以有可数的接口。</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="1f27" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">public interface </strong>Countable {<br/>    <strong class="jr hj">void </strong>count();<br/>}</span></pre><p id="7f1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了Drawable接口，Duck类还可以实现Countable接口，因为Java允许接口的多种实现。</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="2057" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">public class </strong>Duck <strong class="jr hj">implements </strong>Drawable, Countable{<br/><br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">name</strong>;<br/>    <strong class="jr hj">private </strong>String <strong class="jr hj">color</strong>;<br/>    <strong class="jr hj">private int size</strong>;<br/><br/>    <strong class="jr hj">public </strong>Duck(String name, String color, <strong class="jr hj">int </strong>size){<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">name </strong>= name;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">color </strong>= color;<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">size </strong>= size;<br/><br/>    }<br/><br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is flying"</strong>);<br/>    };<br/><br/>    <strong class="jr hj">public void </strong>eat() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is eating"</strong>);<br/>    }<br/><br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/><br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"Duck is swimming"</strong>);<br/>    }<br/>    @Override<br/>    <strong class="jr hj">public void </strong>draw() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I drew a duck"</strong>);<br/>    }<br/>    @Override<br/>    <strong class="jr hj">public void </strong>count() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I have 1 duck"</strong>);<br/>    }</span></pre><p id="95db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">！！接口的使用允许我们拥有多重继承。</strong></p><p id="c7df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">抽象是OOP的四大支柱之一。抽象就是只暴露关于我们项目的必要信息。接口只有抽象方法，实现这些接口的类需要提供这些方法的具体实现。用户只知道实现接口和方法的类，但是不知道这些方法是如何实现的。</p><p id="10f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">！！！接口的使用允许我们实现完全的抽象。</strong></p><p id="2f64" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们来看看下面的代码:</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="cb27" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">import static </strong>java.lang.System.<strong class="jr hj"><em class="jp">out</em></strong>;<br/><strong class="jr hj">public class </strong>BabyDuck {<br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can swim"</strong>);<br/>    }<br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I am learning to fly"</strong>);<br/>    }<br/>}</span><span id="2504" class="jv jw hi jr b fi kd jy l jz ka"><strong class="jr hj"><br/>public class </strong>GrownDuck {<br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can swim"</strong>);<br/>    }<br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can fly"</strong>);<br/>    }<br/>}</span><span id="8211" class="jv jw hi jr b fi kd jy l jz ka"><strong class="jr hj">public class </strong>NewDuck {<br/>    <strong class="jr hj">private </strong>BabyDuck <strong class="jr hj">babyDuck</strong>;<br/><br/>    <strong class="jr hj">public </strong>NewDuck(BabyDuck babyDuck) {<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">babyDuck </strong>= babyDuck;<br/>    }<br/>    <strong class="jr hj">public void </strong>move() {<br/>        <strong class="jr hj">babyDuck</strong>.fly();<br/>        <strong class="jr hj">babyDuck</strong>.swim();<br/>    }<br/><br/>    <strong class="jr hj">public static void </strong>main(String[] args) {<br/>        BabyDuck hatchling = <strong class="jr hj">new </strong>BabyDuck();<br/>        NewDuck myDuck = <strong class="jr hj">new </strong>NewDuck(hatchling);<br/>        myDuck.move();<br/>    }<br/>}</span></pre><p id="e3a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><p id="3572" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在学习飞行，我会游泳</p><p id="1502" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到我们的类NewDuck依赖于类BabyDuck，如果我们想要GrownDuck，我们必须返回并重写我们的类。这种类的相互依赖是紧密耦合的一个例子，应该避免。如果您有许多相互依赖的类，紧密耦合会使代码维护成为一项麻烦的任务。</p><p id="8062" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们使用接口来避免类相互依赖的情况。首先，我们定义包含所需行为的抽象方法的接口，然后我们设计包含这些方法的具体实现的类。这种方法被称为接口编码。</p><p id="93bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">查看以下代码:</p><pre class="jl jm jn jo fd jq jr js jt aw ju bi"><span id="b68d" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">public interface </strong>Movable {<br/>    <strong class="jr hj">void </strong>swim();<br/>    <strong class="jr hj">void </strong>fly();<br/>}</span><span id="8bb1" class="jv jw hi jr b fi kd jy l jz ka"><strong class="jr hj"><br/>public class </strong>BabyDuck  <strong class="jr hj">implements </strong>Movable{<br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can swim"</strong>);<br/>    }<br/><br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I am learning to fly"</strong>);<br/>    }<br/>}</span><span id="4477" class="jv jw hi jr b fi kd jy l jz ka"><strong class="jr hj">public class </strong>GrownDuck  <strong class="jr hj">implements </strong>Movable{<br/><br/>    <strong class="jr hj">public void </strong>swim() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can swim"</strong>);<br/>    }<br/>    <strong class="jr hj">public void </strong>fly() {<br/>        <strong class="jr hj"><em class="jp">out</em></strong>.println(<strong class="jr hj">"I can fly"</strong>);<br/>    }<br/>}<br/></span><span id="f18d" class="jv jw hi jr b fi kd jy l jz ka"><strong class="jr hj">public class </strong>NewDuck {<br/>    <strong class="jr hj">private </strong>Movable <strong class="jr hj">babyDuck</strong>;<br/><br/>    <strong class="jr hj">public </strong>NewDuck(Movable babyDuck) {<br/>        <strong class="jr hj">this</strong>.<strong class="jr hj">babyDuck </strong>= babyDuck;<br/>    }<br/>    <strong class="jr hj">public void </strong>move() {<br/>        <strong class="jr hj">babyDuck</strong>.fly();<br/>        <strong class="jr hj">babyDuck</strong>.swim();<br/>    }<br/><br/>    <strong class="jr hj">public static void </strong>main(String[] args) {<br/>        Movable hatchling = <strong class="jr hj">new </strong>GrownDuck();<br/>        NewDuck myDuck = <strong class="jr hj">new </strong>NewDuck(hatchling);<br/>        myDuck.move();<br/>    }<br/>}</span></pre><p id="c963" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><p id="becd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我会飞，我会游泳</p><p id="465b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">！！！！接口的使用允许我们避免紧密耦合。</strong></p><p id="79d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来总结一下本帖标题所贴问题的答案。</p><p id="81d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要界面:</p><p id="687c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">让类拥有不属于它们的行为。</strong></p><p id="1485" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">对多重继承进行建模。</strong></p><p id="5824" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">达到完全的抽象。</strong></p><p id="0f09" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">联轴器松动。</strong></p><p id="022d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">快乐编码，我的朋友们！</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/afe857685f04e1c894cd64875722990c.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*hv7krdQ_GRDuiafxx15WeQ.gif"/></div></figure><p id="eff0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里的所有代码:</p><div class="kf kg ez fb kh ki"><a href="https://github.com/forfireonly/MediumArticlesJava" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">forfireonly/MediumArticlesJava</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">在GitHub上创建一个帐户，为forfireonly/MediumArticlesJava开发做贡献。</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">github.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ik ki"/></div></div></a></div></div></div>    
</body>
</html>
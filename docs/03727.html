<html>
<head>
<title>DHT1 Temperature Sensor Library for the Raspberry Pico</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树莓Pico的DHT1温度传感器库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dht1-temperature-sensor-library-for-the-raspberry-pico-796122e83fe7?source=collection_archive---------44-----------------------#2021-06-14">https://medium.com/geekculture/dht1-temperature-sensor-library-for-the-raspberry-pico-796122e83fe7?source=collection_archive---------44-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/812ad0976886f604967f541d96c6572b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_TzzKE3MVrgYymFtB5Dug.png"/></div></div></figure><p id="2800" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Raspberry Pico，简称Pico，是Raspberry Pi基金会的一款新型微控制器。它提供了双核ARM处理器、2MB闪存和26个GPIO引脚。您可以使用C/C++ SDK或MicroPython对Pico进行编程。我被这个设备迷住了，并开始开发一个用于控制移位寄存器的库，特别是HC595N移位寄存器。为了更好地掌握Pico C SDK，我寻找了另一个可以开发库的传感器，并找到了DHT11温度传感器。</p><p id="a7c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DHT11传感器仅通过一个数据引脚连接。它还有一个交换数据的专有协议:发送低电压和高电压脉冲来激活传感器，然后读取代表编码温度读数的位模式的脉冲。</p><p id="4f4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文解释了我的开发旅程的第一部分:理解DHT11协议，创建库文件夹结构，然后尝试读取温度数据。</p><p id="d287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em> <a class="ae jp" href="https://admantium.com/blog/pico08_temperature_sensor_library/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的博客</em> </a>。</p><h1 id="0ba3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">数据表</h1><p id="d54d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">任何传感器的第一个接触点都是获取数据手册并了解其一般工作原理。我对DHT11传感器的参考是关于mouser.com的<a class="ae jp" href="https://www.mouser.com/datasheet/2/758/DHT11-Technical-Data-Sheet-Translated-Version-1143054.pdf" rel="noopener ugc nofollow" target="_blank">文档。您阅读数据手册的次数越多，从中获得的信息就越多。以下列表总结了我对的主要关注:</a></p><ul class=""><li id="b458" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">引脚布局:传感器以三引脚或四引脚版本出售。四引脚版本实际上也是三引脚——他们只是焊接了(为了方便)另一个引脚。反正管脚就是v-in，地，数据。</li><li id="f564" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">输入电压:支持3–5.5V，因此可以直接连接到Pico。</li><li id="2b5f" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">通信协议:数据引脚用作输入和输出。MCU发送特征信号以在DHT11上执行“唤醒”呼叫。传感器确认此唤醒，然后发送40位数据</li><li id="aba5" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">其他操作限制:传感器不应在通电后1秒内被请求，且查询频率不应超过每2秒一次。</li></ul><p id="454c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些事实，我们就可以开始实施了。</p><h1 id="47a4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">库设置</h1><p id="20b2" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">该库从<a class="ae jp" href="https://github.com/admantium-sg/rp2040-shift-register-74HC595" rel="noopener ugc nofollow" target="_blank">移位寄存器库</a>中分离到我的可信结构中:</p><ul class=""><li id="3316" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><code class="du lh li lj lk b">./</code>包含三种不同构建类型的中央<code class="du lh li lj lk b">CMakeLists.txt</code>文件:仅库、测试和示例。</li><li id="7e84" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">./include</code>包含头文件</li><li id="24a7" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">./src</code>库源文件及其附带的cmake配置</li><li id="5cb2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">使用CMocka框架，测试验证库对象和函数是正确的</li><li id="3663" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">./examples</code>如何使用图书馆的简单食谱</li></ul><h1 id="cd25" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">核心对象和功能</h1><p id="60d1" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">该库使用以下签名公开结构对象<code class="du lh li lj lk b">DHT11</code>:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="5b9a" class="lt jr hi lk b fi lu lv l lw lx">typedef struct DHT11<br/>{<br/>  uint8_t DATA_PIN;</span><span id="b68d" class="lt jr hi lk b fi ly lv l lw lx">  double last_temp;<br/>  double last_humidity;</span><span id="b363" class="lt jr hi lk b fi ly lv l lw lx">  double temp_measurements[30];<br/>  double humidity_measurements[30];</span><span id="7536" class="lt jr hi lk b fi ly lv l lw lx">} DHT11;</span></pre><p id="70bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传感器对象是用<code class="du lh li lj lk b">dht11_new</code>创建的，然后提供这些功能:</p><ul class=""><li id="5af2" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_probe()</code> -从传感器获取新的测量值，但仅在上次尝试后至少两秒钟时</li><li id="19fd" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_process()</code> -一种辅助方法，接收有序的40位数据，计算校验和，并在探测有效时更新内部值。</li><li id="80c1" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_get_last_temperature_measurement()</code> -返回最近的温度测量值</li><li id="d482" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_get_last_humidity_measurement()</code> -返回最近的湿度测量值</li><li id="5cbe" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_get_historic_temperature_measurement()</code> -从最后30个探头中检索温度测量值</li><li id="ca8d" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><code class="du lh li lj lk b">dht11_get_historic_humidity_measurement()</code> -从最后30个探头中检索湿度测量值</li></ul><p id="4486" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个函数都有一个测试套件——参见github库中的<a class="ae jp" href="https://github.com/admantium-sg/pico-dht11-lib/blob/main/test/test.c" rel="noopener ugc nofollow" target="_blank"> test.c。我不会在本文中详述测试，而是将重点放在让传感器工作上。如果你对我的测试方法感兴趣，请阅读我之前的文章，关于用CMocka进行单元测试的</a><a class="ae jp" href="https://admantium.com/blog/pico04_unit_tests_cmocka/" rel="noopener ugc nofollow" target="_blank">和测试移位寄存器库的</a><a class="ae jp" href="https://pico06_shift_register_library_part2.md" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6f2e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">命令式协议验证</h1><p id="54aa" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">该程序的第一个版本可以概括为带有显式协议验证的命令性语句。</p><p id="f9af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总体思路是定义处理传感器启动、传感器确认和传感器数据三个阶段的代码块。然后，每个阶段将使用一个计数器和一个<code class="du lh li lj lk b">sleep_us</code>调用来明确等待数据手册中指定的时间。然后，我会在每个阶段之后输出一条调试语句，以确认传感器的行为符合预期。</p><h1 id="ab62" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">启动和确认</h1><p id="1bff" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">启动信号很简单:</p><ul class=""><li id="fa01" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">将数据引脚设置为输出</li><li id="2170" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">发送低电平18毫秒</li><li id="2c22" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">为20us发送HIGH</li></ul><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="d82f" class="lt jr hi lk b fi lu lv l lw lx">// I Activate DHT<br/>{<br/>  gpio_put(pin, 0);              // LOW<br/>  sleep_ms(18);              // 18us</span><span id="1e05" class="lt jr hi lk b fi ly lv l lw lx">  gpio_put(pin, 1);              // HIGH<br/>  sleep_us(20);              // 20us<br/>}</span></pre><p id="88a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要测试传感器确认阶段，具体步骤是:</p><ul class=""><li id="685d" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">将数据引脚设置为输入</li><li id="a299" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">等待80微秒后，读取一个低值</li><li id="ce61" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">打印调试语句</li><li id="8627" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">等待80us，读取高值</li></ul><p id="b1aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特别是代码:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="b7b0" class="lt jr hi lk b fi lu lv l lw lx">// II Read DHT Confirmation<br/>{<br/>  gpio_set_dir(pin, GPIO_IN);<br/>  bool init_state = 0;</span><span id="1def" class="lt jr hi lk b fi ly lv l lw lx">  int count = 0;<br/>  while(init_state = !gpio_get(pin)) {          // EXPECT LOW 80us<br/>    count++;<br/>    sleep_us(1);<br/>  };</span><span id="de3f" class="lt jr hi lk b fi ly lv l lw lx">  printf("DHT Confirmation LOW: %d\n", count);</span><span id="665a" class="lt jr hi lk b fi ly lv l lw lx">  count = 0;<br/>  while(init_state = gpio_get(pin)) {<br/>    count++;<br/>    sleep_us(1);<br/>  };<br/>  printf("DHT Confirmation HIGH: %d\n", count);  // EXPECT HIGH 80us<br/>}</span></pre><p id="af10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个初始代码，我开始测试传感器。</p><h1 id="6161" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">小心硬件</h1><p id="b761" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在花了大约4个小时尝试显式等待，然后甚至不断地通过GPIO引脚写入/读取数据后，我无法从传感器获得任何响应。</p><p id="1d0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要么是我的方法完全错误，要么是我把协议搞混了，但这与我在其他博客文章中看到的一致。所以我用Arduino连接了传感器，上传了可信的<a class="ae jp" href="https://github.com/adafruit/DHT-sensor-library/blob/master/examples/DHTtester/DHTtester.ino" rel="noopener ugc nofollow" target="_blank"> Adafruit DHT Lib exmaple </a>草图..代码失败！只看到了错误信息<code class="du lh li lj lk b">Failed to read from DHT sensor!</code>。传感器坏了，所有的时间都浪费了。</p><p id="9678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我订购了一个新的传感器，上传了Arduino草图，并可以在串行终端上获得这些结果:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="d86f" class="lt jr hi lk b fi lu lv l lw lx">Humidity: 46.00%  Temperature: 24.30°C 75.74°F  Heat index: 23.99°C 75.18°F</span></pre><p id="9091" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传感器坏了！当问题出在硬件上的时候，我浪费了大量的时间和精力去修复代码。嵌入式软件开发中的重要一课。</p><h1 id="cdf6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">把握好时机</h1><p id="e0b6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">即使有一个工作传感器，我也没有成功地得到正确的时间。无论是阅读数据手册，还是用另一个数据手册仔细检查，或者查看官方的Pico示例，或者查看同一类型传感器的Arduino库，都于事无补。两个库都在传感器指定的时间内显式调用<code class="du lh li lj lk b">sleep</code>,但是我无法完成。投入更多的项目时间来研究我的代码中各种语句的时间效应——比如计数器的影响是什么，printf的影响是什么——也不起作用。</p><p id="13e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我花了一些时间研究其他项目，发现MicroPython可以实现这种传感器。这些图书馆使用的是Pico PIO系统，这是Pico上的一个特殊的硬件系统，你用类似汇编的语言编程。我放弃了纯C，决定考察一下Pico的利用率。下一篇博客文章将详细介绍如何使用Pico。</p><h1 id="6aa4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="1994" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我第一次尝试从DHT传感器读取温度数据失败了。我想了很久这个过程，以及我是否应该写一个失败的尝试。我当然应该，因为我想分享这些重要的知识。首先，始终检查您正在使用的硬件是否正常工作。我浪费了4个小时来修复一个坏了的传感器上不工作的代码。第二，据我所知，仅用C SDK很难获得非常精确的计时——如果你在这个方向上取得了更好的进展，请告诉我。</p><p id="6237" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一篇文章将间接继续传感器的开发:我们将学习PIO系统的基础知识，并看看如何将它包含在C程序中。</p></div></div>    
</body>
</html>
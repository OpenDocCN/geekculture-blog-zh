<html>
<head>
<title>Bresenham’s Line Drawing Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布雷森汉姆画线算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/bresenhams-line-drawing-algorithm-2e0e953901b3?source=collection_archive---------4-----------------------#2021-05-23">https://medium.com/geekculture/bresenhams-line-drawing-algorithm-2e0e953901b3?source=collection_archive---------4-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d75c" class="pw-subtitle-paragraph ig hh hi bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dx translated">Bresenham画线算法举例说明</h2></div><p id="a661" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们在<a class="ae ju" href="https://aihalapathirana.medium.com/dda-line-drawing-algorithm-be9f069921cf" rel="noopener">上一篇文章</a>中谈到了计算机图形学中的线条画基础和DDA线条画算法。在这篇文章中，我将解释另一种流行的扫描转换线算法，Bresenham的画线算法。</p><p id="422f" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你想了解更多关于扫描转换一行的信息，请阅读我的<a class="ae ju" href="https://aihalapathirana.medium.com/dda-line-drawing-algorithm-be9f069921cf" rel="noopener">前一篇文章</a>。</p><h1 id="7d95" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ip kg iq kh is ki it kj iv kk iw kl km bi translated">在Bresenham算法中寻找下一个像素</h1><p id="58a1" class="pw-post-body-paragraph iy iz hi ja b jb kn ik jd je ko in jg jh kp jj jk jl kq jn jo jp kr jr js jt hb bi translated">类似于DDA算法，我们需要两个端点P和Q，使用Bresengham算法画一条线。</p><p id="20eb" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Bresenham的算法只使用整数值、整数比较和加法。这使得Bresenham的算法比DDA算法更有效、更快速、更容易计算。</p><p id="7396" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一旦我们选择了一个像素，我们有两个可能的像素来选择作为下一个像素。</p><ol class=""><li id="a583" class="ks kt hi ja b jb jc je jf jh ku jl kv jp kw jt kx ky kz la bi translated">右侧像素(东—东)</li><li id="2f06" class="ks kt hi ja b jb lb je lc jh ld jl le jp lf jt kx ky kz la bi translated">右上角像素(东北—东北)</li></ol><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es lg"><img src="../Images/6285ef9f6ddf2679a08144e4c652b2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*cP9OaF3n4mmbAhtguD52rg.png"/></div></figure><p id="deba" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">假设当前像素坐标为<strong class="ja hj"><em class="lo">【x，y】</em></strong></p><p id="af65" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">选择E作为下一个像素—仅增加X值1 - <strong class="ja hj"> <em class="lo"> (x+1，y) </em> </strong></p><p id="c947" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">选择NE作为下一个像素—X和Y值都增加1 - <strong class="ja hj"> <em class="lo"> (x+1，y+1) </em> </strong></p><p id="8f64" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了选择下一个像素，我们使用基于斜率误差的决策参数。如果斜率误差大于0.5，实际线在ne附近。当斜率误差小于0.5时，直线更接近E。</p><p id="11a8" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在每一步，我们需要根据像素的选择，通过增加△E或△NE来递增计算决策变量。</p><p id="38f6" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们试着更好地理解算法。</p><h1 id="8a04" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ip kg iq kh is ki it kj iv kk iw kl km bi translated">布雷森汉姆算法</h1><p id="6545" class="pw-post-body-paragraph iy iz hi ja b jb kn ik jd je ko in jg jh kp jj jk jl kq jn jo jp kr jr js jt hb bi translated">假设起点是<strong class="ja hj"> <em class="lo"> (x1，y1) </em> </strong>，终点是<strong class="ja hj"> <em class="lo"> (x2，y2) </em> </strong></p><p id="133d" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">场景:x1&lt;x2</em>T27<strong class="ja hj">T29】0&lt;斜率&lt;1T31】</strong></strong></p><p id="39aa" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">首先我们需要计算<strong class="ja hj"> <em class="lo"> dx </em> </strong>和<strong class="ja hj"> <em class="lo"> dy </em> </strong></p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es lp"><img src="../Images/a9c23c6a8234d931887008b230211749.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*Dv-jLr8LuyDS8BLJUcVW2g.png"/></div></figure><p id="9956" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们用<strong class="ja hj"> <em class="lo"> dx </em> </strong>和<strong class="ja hj"> <em class="lo"> dy </em> </strong>的值来计算初始决策变量(<strong class="ja hj"><em class="lo"/></strong><em class="lo">)</em>。决策变量的值在每一步都是变化的。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es lp"><img src="../Images/b718d47a956cc7d934255653cdcdb199.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*NhQ_Lq9OuhkrWDc6a86JXA.png"/></div></figure><p id="c11b" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">同样，我们需要计算<strong class="ja hj"> <em class="lo"> △E </em> </strong>和<strong class="ja hj"> <em class="lo"> △NE </em> </strong>的值。首次启动后，这些值不会改变。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es lq"><img src="../Images/f560d969b9c2a9488f2a31f5d320fd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*1zuLPPP08ZXW0gvx2Aywrg.png"/></div></figure><p id="1797" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在我们要决定接下来要选择的最佳像素是什么，<strong class="ja hj"> <em class="lo"> NE </em> </strong>还是<strong class="ja hj"> <em class="lo"> E </em> </strong>。我们使用决策参数的符号来做出决策。</p><p id="bd34" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">情况1: d ≤ 0 </em> </strong></p><p id="ea73" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果决策变量为负或零，我们将选择像素E。在这个场景中，我们只将<strong class="ja hj"> <em class="lo"> x </em> </strong>值增加1，并使用<strong class="ja hj"> <em class="lo"> △E </em> </strong>计算新的决策变量。<em class="lo">记住保持</em> <strong class="ja hj"> <em class="lo"> y </em> </strong> <em class="lo">值不变</em>。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es lr"><img src="../Images/fb3261b60a42c15feeb61f3a1337edff.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*3th2XvhrcWM8jJuDJ1a9OA.png"/></div></figure><p id="0957" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">案例2: d &gt; 0 </em> </strong></p><p id="c0fb" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">当决策变量为正时，选择NE作为下一个像素。除了计算新的决策变量并增加x值<strong class="ja hj"><em class="lo"/></strong>外，还需要增加y值<em class="lo"/>1。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es ls"><img src="../Images/9a77dbf8b792b8f4f2a86839b16b970d.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*XB0XvOQ71iCRU-GzDoDxQA.png"/></div></figure><p id="bd64" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">继续直到x = x2</p><p id="e788" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们用一个例子来试试这个算法。</p><h2 id="b9c2" class="lt jw hi bd jx lu lv lw kb lx ly lz kf jh ma mb kh jl mc md kj jp me mf kl mg bi translated">例子</h2><p id="007c" class="pw-post-body-paragraph iy iz hi ja b jb kn ik jd je ko in jg jh kp jj jk jl kq jn jo jp kr jr js jt hb bi translated">我将采用我在DDA算法教程<a class="ae ju" rel="noopener" href="/geekculture/dda-line-drawing-algorithm-be9f069921cf">中使用的同一个例子</a>，以便我们可以比较结果。</p><p id="f50f" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">假设<strong class="ja hj"><em class="lo">x1&lt;x2</em>T45<strong class="ja hj">和<em class="lo"> 0 &lt;斜率&lt;1</em>T49】</strong></strong></p><p id="f1af" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">从(2，1)到(8，5)画一条线</p><p id="228d" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="lo"> X1 </em> = 2，<em class="lo"> X2 = </em> 8 <em class="lo">，Y1 = </em> 1 <em class="lo">和<em class="lo"> Y2 = </em> 5</em></p><p id="ae5a" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在计算决策变量之前，我们需要找到X和Y坐标值的差值，<strong class="ja hj"> <em class="lo"> dx </em> </strong>和<strong class="ja hj"> <em class="lo"> dy </em> </strong>。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es mh"><img src="../Images/7f15ad2122eb95ca1846109c6d3f642b.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*B8Jz8N0nbE8US6u1CzUhIw.png"/></div></figure><p id="af98" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在我们可以利用<strong class="ja hj"><em class="lo"/></strong>△E、 和<em class="lo"> △NE </em> 的值，利用<strong class="ja hj"> <em class="lo"> dx </em> </strong>和<strong class="ja hj"> <em class="lo"> dy。</em>T83】</strong></p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es mi"><img src="../Images/53b0c6668a5ff34af4ef352f99ca72c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*m_oQB0zGGD5UudafrjqMuA.png"/></div></figure><p id="179b" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">按照<strong class="ja hj"> <em class="lo">情况1 </em> </strong>和<strong class="ja hj"> <em class="lo">情况2 </em> </strong>为该线寻找下一个最佳像素。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es mj"><img src="../Images/053cbf60995af150302b7e0173f74391.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*evIfeKEXv3pwr_HbCkd5ug.png"/></div></figure><figure class="lh li lj lk fd ll er es paragraph-image"><div class="er es mk"><img src="../Images/70736ad6ab567f4f8726bc385bd967aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*KGXjMVbkl-XUJLnNGqPcfQ.png"/></div></figure><p id="2df8" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果您将这些结果与DDA算法的结果进行比较，您可以看到我们得到了与DDA算法相同的结果。</p><p id="8ced" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">正如我之前提到的，Bresenham的算法涉及简单的计算，这使得该算法比DDA算法更高效、更快。</p><p id="86f3" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">由于涉及整数算术计算，Bresenham算法提供了比DDA算法更精确的结果。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="2923" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">到目前为止我们只讲了这个算法的一般场景，其中<strong class="ja hj"> <em class="lo"> x1 &lt; x2 </em> </strong>和<strong class="ja hj"> <em class="lo"> 0 &lt;斜率&lt; 1 </em> </strong>。我们还需要考虑另外三种情况。</p><p id="ddd7" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">案例1: x1 &gt; x2 </em> </strong></p><p id="0c50" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这种情况下，我们应该从左向右画线。以<strong class="ja hj"> <em class="lo"> (X2，Y2) </em> </strong>为起点，以<strong class="ja hj"> <em class="lo"> (X1，Y1) </em> </strong>为终点，然后继续Bresenham算法。</p><p id="a99b" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">案例二:斜率&lt; 0 </em> </strong></p><p id="af7f" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在斜率为负的情况下，我们可以通过绕X轴反射原直线，得到斜率为正的直线。我们对具有正斜率的线执行Bresenham算法，并绕X轴反射回来以获得像素。</p><p id="cdd1" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">例题</em> </strong></p><p id="a30b" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">从<strong class="ja hj"> <em class="lo"> (x1，y1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (x2，y2) </em> </strong>画一条线。在这种情况下，我们假设斜率为负。</p><p id="a60a" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在不使用Bresenham从<strong class="ja hj"> <em class="lo"> (x1，y1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (x2，y2) </em> </strong>，而是使用<strong class="ja hj"> <em class="lo"> (x1，-y1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (x2，-y2) </em> </strong>上的算法。在计算完从<strong class="ja hj"> <em class="lo"> (x1，-y1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (x2，-y2) </em> </strong>的所有像素后，我们改变所有像素的<strong class="ja hj"><em class="lo"/></strong>y值的符号来获得原始行的像素。</p><p id="5a62" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="lo">案例三:坡度&gt; 1 </em> </strong></p><p id="0a74" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在斜率大于1的情况下，我们可以通过交换<strong class="ja hj"> <em class="lo"> x </em> </strong>和<strong class="ja hj"> <em class="lo"> y </em> </strong>的值来使用Bresenham算法。计算结束后，将<strong class="ja hj"> <em class="lo"> x </em> </strong>和<strong class="ja hj"> <em class="lo"> y </em> </strong>的值交换回来，得到要显示在该行上的像素。</p><p id="f4df" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj">例子<em class="lo">例子</em>例子</strong></p><p id="3dfe" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">从<strong class="ja hj"> <em class="lo"> (x1，y1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (x2，y2) </em> </strong>画一条线。假设斜率大于1。</p><p id="8d46" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对<strong class="ja hj"> <em class="lo"> (y1，x1) </em> </strong>到<strong class="ja hj"> <em class="lo"> (y2，x2) </em> </strong>使用Bresenham算法。像前面一样计算直线的像素。然后通过交换<strong class="ja hj"> <em class="lo"> x </em> </strong>和<strong class="ja hj"> <em class="lo"> y </em> </strong>值将所有像素转换回来。</p><p id="685b" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">GitHub链接到Bresenham的算法—<a class="ae ju" href="https://github.com/anushaihalapathirana/Bresenham-line-drawing-algorithm" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/anushaihalapathrana/Bresenham-line-drawing-algorithm</a></p><p id="54a2" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Bresenham线算法的npm包—【https://www.npmjs.com/package/bresenham-line-algorithm T2】</p></div></div>    
</body>
</html>
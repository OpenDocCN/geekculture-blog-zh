<html>
<head>
<title>React 18 new features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18项新功能</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-18-new-features-558f159762f3?source=collection_archive---------8-----------------------#2021-07-02">https://medium.com/geekculture/react-18-new-features-558f159762f3?source=collection_archive---------8-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f5a39dea194499e1105bede8f252992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHnzNKFp6aLFtXneFGLrmg.png"/></div></div></figure><p id="b019" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> React 17专注于改善基础，但React 18中增加了一些重要的东西。在这篇文章中，我们将浏览一些关于如何开始使用react 18 alpha中很酷的新功能的最新更新。</em></p><p id="e6e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装React 18 alpha : <code class="du jp jq jr js b">npm install react@alpha react-dom@alpha</code></p><p id="7868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是几个更新的列表。</p><ol class=""><li id="1eae" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">新建根API</li><li id="5fd9" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">焦虑</li><li id="b501" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">暂停列表</li><li id="1aa1" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">useDeferredValue</li><li id="5cda" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">自动配料</li></ol><blockquote class="kh ki kj"><p id="2658" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">新根API </em> </strong></p></blockquote><p id="6d3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React 18中有一个新的根API。</p><p id="220c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前面的reactDOM.render方法中，我们使用传递App组件，然后是document.getElementById和根元素。因此，我们将应用程序组件呈现到页面上的根元素中。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="401d" class="kv kw hi js b fi kx ky l kz la">import ReactDOM from "react-dom";<br/>import App from "App";<br/>ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</span></pre><p id="7003" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在React 18中，我们首先必须通过createRoot方法创建根。这将被传递给我们的根元素，然后我们调用<em class="jo"> root.render </em>并传递我们的应用程序组件。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="3219" class="kv kw hi js b fi kx ky l kz la">import ReactDOM from "react-dom";<br/>import App from "App";<br/>const root = ReactDOM.createRoot(document.getElementById("root"));<br/>root.render(&lt;App /&gt;);</span></pre><p id="a6c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们的React应用程序的根已经被分离。我们现在首先需要使用createRoot方法创建根，然后在其上调用render方法。</p><blockquote class="kh ki kj"><p id="afd5" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">悬念</em> </strong></p></blockquote><p id="7768" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像它的名字一样，悬疑暂停某些东西，直到它准备好被渲染。</p><p id="bc23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在react的以前版本中，下面的代码会导致ReadyComponent被立即挂载，并调用它的效果。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="0727" class="kv kw hi js b fi kx ky l kz la">&lt;Suspense fallback={&lt;Loading /&gt;}&gt;<br/>    &lt;ComponentWaitingForData /&gt;<br/>    &lt;ReadyComponent /&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="56ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在React 18中已经解决了。</p><p id="a351" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考上面的代码，现在它不会挂载ReadyComponent，而是先等待ComponentWaitingForData进行解析。</p><blockquote class="kh ki kj"><p id="032e" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">暂停</em> </strong></p></blockquote><p id="6766" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个悬而未决的人期待两个道具。“revealOrder”和“tail”。</p><p id="4650" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“revealOrder”是暂停列表配置选项之一。它可以是未定义的、一起的、向前的和向后的。</p><ul class=""><li id="c4c2" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn lb jz ka kb bi translated"><em class="jo"> undefined </em>(默认):当吊杆解决时显示孩子。</li><li id="f34b" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn lb jz ka kb bi translated"><em class="jo">一起</em>:一旦所有的吊杆都解决了，一起露出孩子。</li><li id="4833" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn lb jz ka kb bi translated"><em class="jo">转发</em>:从上到下渲染小孩，对吊带无动于衷。决议顺序</li><li id="a17b" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn lb jz ka kb bi translated"><em class="jo">向后</em>:自下而上渲染子体，不考虑吊杆分辨率顺序</li></ul><p id="7f65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“tail”属性决定了悬挂列表中未加载的项目是如何显示的。它的值可以折叠或隐藏。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="6357" class="kv kw hi js b fi kx ky l kz la">&lt;SuspenseList revealOrder="forwards" &gt;<br/>    &lt;Suspense fallback={&lt;p&gt;Loading attendance...&lt;/p&gt;}&gt;<br/>        &lt;Attendance id={facultyID}/&gt;<br/>    &lt;/Suspense&gt;<br/>    &lt;Suspense fallback={&lt;p&gt;Loading homework...&lt;/p&gt;}&gt;<br/>        &lt;Homework id={facultyID}/&gt;<br/>    &lt;/Suspense&gt;<br/>&lt;/SuspenseList&gt;</span></pre><p id="2f50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面带有SuspenseList的代码演示了我们可以设置revealOrder来强制出勤先出现，然后是作业部分。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="1f5e" class="kv kw hi js b fi kx ky l kz la">&lt;SuspenseList revealOrder="forwards" tail="collapsed"&gt;<br/>    &lt;Suspense fallback={&lt;p&gt;Loading attendance...&lt;/p&gt;}&gt;<br/>        &lt;Attendance id={facultyID}/&gt;<br/>    &lt;/Suspense&gt;<br/>    &lt;Suspense fallback={&lt;p&gt;Loading homework...&lt;/p&gt;}&gt;<br/>        &lt;Homework id={facultyID}/&gt;<br/>    &lt;/Suspense&gt;<br/>&lt;/SuspenseList&gt;</span></pre><p id="fc19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码演示了一次只显示一个回退。即首先是出勤的后退，然后是家庭作业的后退。</p><blockquote class="kh ki kj"><p id="39a7" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"><em class="hi">useDeferredValue</em></strong></p></blockquote><p id="1dce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“useDeferredValue”是一个挂钩，它将返回传递值的延迟版本。它接受状态值和以毫秒为单位的超时。它将返回该值的延迟版本，对于大多数超时，该值可能“滞后于”它。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="0deb" class="kv kw hi js b fi kx ky l kz la">import { useDeferredValue } from "react";<br/>const [text, setText] = useState("react js");<br/>const deferredText = useDeferredValue(text, { timeoutMs: 2000 });</span></pre><p id="5faa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们有一些基于用户输入立即呈现的内容和一些需要等待数据获取的内容时，这通常用于保持UI的响应性。</p><blockquote class="kh ki kj"><p id="6405" class="iq ir jo is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">自动配料</em> </strong></p></blockquote><p id="c3ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自动配料有了巨大的改进。在React的早期版本中，它使用将多个状态更新批处理为一个状态更新，以减少不必要的重新渲染。问题是它只能在DOM事件处理程序中完成，而不能在承诺、超时或其他处理程序中完成。</p><p id="2ddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看下面的代码，看看早期版本的React是如何进行批处理的。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="4896" class="kv kw hi js b fi kx ky l kz la">export default function App() {<br/>    const [count, setCount] = useState(0);<br/>    const [color, setColor] = useState(undefined);<br/>    <br/>    const handleClick = () =&gt; {<br/>        setCount(count + 1); //No re-render<br/>        setColor(count % 2 === 0 ? "Green" : "Red"); //No re-render<br/>        // Now re-renders once at the end (this is batching)<br/>    } </span><span id="b546" class="kv kw hi js b fi lc ky l kz la">    return (<br/>        &lt;&gt;<br/>            &lt;button onClick={handleClick}&gt;Next&lt;/button&gt;<br/>            &lt;span style={{<br/>                color: count % 2 === 0 ? "red" : "green",<br/>            }}&gt;<br/>                {color}<br/>            &lt;/span&gt;<br/>        &lt;/&gt;<br/>    );<br/>}</span></pre><p id="6227" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用React 18，承诺、超时或其他处理程序也将利用这一点。无论状态更新发生在哪里，它都会批量更新。这将导致更好的性能。</p><p id="3cd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看下面发生批处理的代码。在下面的代码中，批处理在React 18中运行良好，但是早期版本的React不能批处理它。</p><pre class="kn ko kp kq fd kr js ks kt aw ku bi"><span id="7654" class="kv kw hi js b fi kx ky l kz la">export default function App() {<br/>    const [count, setCount] = useState(0);<br/>    const [color, setColor] = useState(undefined);    const handleClick = () =&gt; {<br/>        Promise.resolve().then(() =&gt; {<br/>            setCount(count + 1); //Re-render<br/>            setColor(count % 2 === 0 ? "Green" : "Red"); //Re-render<br/>        });<br/>    }    return (<br/>        &lt;&gt;<br/>            &lt;button onClick={handleClick}&gt;Next&lt;/button&gt;<br/>            &lt;span style={{<br/>                color: count % 2 === 0 ? "red" : "green",<br/>            }}&gt;<br/>                {color}<br/>            &lt;/span&gt;<br/>        &lt;/&gt;<br/>    );<br/>}</span></pre><p id="367f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果我们不希望我们的组件被批处理，我们可以使用<code class="du jp jq jr js b">ReactDOM.flushSync()</code>选择退出那个组件。</p><p id="4008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考—<a class="ae ld" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank">https://react js . org/blog/2021/06/08/the-plan-for-react-18 . html</a></p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="4c05" class="ll kw hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结束语:</h1><p id="34e7" class="pw-post-body-paragraph iq ir hi is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hb bi translated">我们刚刚了解了React 18 alpha版本中一些很酷的更新。作为一名JavaScript开发人员，我真的很喜欢这些更新，并且很高兴看到React 18的测试版是什么样子。</p><p id="4e3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢你一直坚持到最后🙌。如果您喜欢这篇文章或学到了新东西，请点击下面的分享按钮来支持我，与更多人联系，和/或在<a class="ae ld" href="https://twitter.com/amir__mustafa" rel="noopener ugc nofollow" target="_blank"><em class="jo">Twitter</em></a><em class="jo">上关注我，以查看我在那里学到和分享的其他技巧、文章和东西。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>HPACK: Header Compression format for HTTP/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">h pack:HTTP/2的头压缩格式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hpack-header-compression-format-for-http-2-155a0b4934f7?source=collection_archive---------3-----------------------#2022-07-11">https://medium.com/geekculture/hpack-header-compression-format-for-http-2-155a0b4934f7?source=collection_archive---------3-----------------------#2022-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bb7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我一直在探索是什么让HTTP/2和HTTP/3比它们的1.1前辈快得多。虽然很明显，像流复用这样的具体特性是它的核心，但有一个我们将在本帖中讨论的未言明的英雄。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="4770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HPACK是HTTP/2中使用的头压缩技术，它对应于HTTP/3，QPACK在处理动态表方面略有不同(不要担心，我将在博客的后半部分详细解释)。</p><blockquote class="jk jl jm"><p id="3833" class="if ig jn ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated"><strong class="ih hj">免责声明</strong>:这篇博客或多或少是RFC的总结，上面还有一些额外的插图。请随意直接阅读HPACK RFC[1]或Cloudflare[2]提供的关于静态+动态表如何帮助压缩过程的摘要。这篇文章将关注如何在头字段表示中表示头字段，以及如何在头和解码器之间传递原始数据类型。</p></blockquote><h1 id="b059" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">压缩法⏮</h1><p id="ddb6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在RFC中要注意的一件有趣的事情是，没有具体的算法规范，因此，只要实现在运行期间确保以下属性，就可以让实现自由地找出它们自己的编码过程——</p><ul class=""><li id="253e" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">编码器必须<strong class="ih hj">保持在原始报头列表中接收的报头块内的报头字段表示</strong>的顺序，并确保解码器遵循相同的顺序。</li><li id="e1dc" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">标题块<strong class="ih hj">的解压缩应该仅依赖于作为附加解码上下文</strong>的动态表。</li><li id="5138" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">编码器必须维护几个<strong class="ih hj">表</strong>来将头字段与索引相关联。<br/> - <strong class="ih hj">静态表:</strong>静态表是由<code class="du li lj lk ll b">accept</code>、<code class="du li lj lk ll b">allow</code>、<code class="du li lj lk ll b">authorization</code>等预定义表头字段和<code class="du li lj lk ll b">:scheme</code>、<code class="du li lj lk ll b">:status</code>等伪表头组成的表格。你可以在这里查看整个列表。<br/> - <strong class="ih hj">动态表:</strong>这是一个按照FIFO顺序遇到的头字段的动态表，并据此进行索引。这是一个严格的内存限制资源，由解码器和编码器共同商定。</li><li id="3caf" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">在标题字段表示中，标题字段名称可以是按原样表示的<strong class="ih hj">,或者可以引用上述任一表格内的条目</strong>,而标题字段值是按字面表示的(值和字段的字面表示<strong class="ih hj">可以是直接的或者霍夫曼编码的)</strong></li></ul><h1 id="94f4" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">动态表格🏗</h1><p id="3f91" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">动态表绝对值得详细说明，这些表最初是空的，条目是按照先进先出的顺序添加的。该表中最新的条目处于最低顺序，而最老的条目将处于最高顺序。在大小改变命令的情况下或者为了容纳较新的报头字段，旧的条目被驱逐。</p><p id="4064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以包含重复的条目，并且编码器将决定在更新/创建动态表时要使用多少内存。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/daa7490e9056bbb23a1ac88523f20693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4a0ANI_MoibiKR2TZ3Grtw.png"/></div></div></figure><h1 id="050a" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">数据表示法📑</h1><h2 id="3182" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated">整数</h2><p id="c7b4" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一般来说，在HTTP协议中，整数用于表示字符串长度，或者在这种特定情况下，表示头字段索引。根据RFC，整数表示可以在八位字节内的任何地方开始<strong class="ih hj">，但是为了优化处理，每个表示应该在八位字节的末尾结束。</strong></p><p id="32a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们说“从中间的任何地方开始”时，它到底是什么意思？正如我们所知，一个八位字节有8位，协议允许实现从第2位开始一个整数，第0和第1位可以是空的(或者可以以任何方式设置)在<strong class="ih hj">前缀</strong>中。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/c6c205aaab2a8ce534a255df06e1f612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXApDNo43HVVjktgbqEenQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Prefix Octet Example</figcaption></figure><p id="6db3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在整数为&gt; <code class="du li lj lk ll b">2 ^ N — 1</code>的情况下，整数由填充当前八位字节+附加八位字节的前缀<strong class="ih hj">表示</strong></p><p id="0ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单不是吗？让我们通过几个例子来理解这一点。</p><p id="353d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例-用N = 6编码45</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mm"><img src="../Images/8f6cd68fe8214878413f7d41be6392a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s6o7NvJMxJ44lUjIvk_7g.png"/></div></div></figure><p id="5572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自45 &lt; 63 (  【T1】 ), we could encode 45 into a binary where the first bit started from the 2nd index. This is what it means to “Start from anywhere”. Had  【T2】  was set, we could start the integer from the first bit itself.</p><p id="9646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例-用N=6 </strong>编码458963</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mn"><img src="../Images/4f9741475eff735c549d4863e24f2cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Tsagydl86fm0pQmtB46Gg.png"/></div></div></figure><p id="6616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，你可以看到，我们使用4个八位字节来编码这么大的数字。(1个前缀，3个附加)。<strong class="ih hj">有趣的是，除了最后一个八位字节，其他八位字节的MSB(最高有效位)都被设置为1。</strong></p><p id="41fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将整数<code class="du li lj lk ll b">I</code>编码到<code class="du li lj lk ll b">N</code>位的通用伪代码如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mo"><img src="../Images/4ff66876b8b4097fa7f6f6468cf5108e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0FvY54hL1v_qyDu9y1VSQ.png"/></div></div></figure><h2 id="64ab" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated"><strong class="ak">字符串文字表示法</strong></h2><p id="a649" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在表和标题表示中，标题字段名称和值可以表示为字符串文字。它被编码为一个八位字节序列，并包括一个标志，表明字符串数据是字符串的文字八位字节，还是实际上，霍夫曼编码的八位字节。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mp"><img src="../Images/b3602396f9af7404225c0eef9453dd11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mD7Rf78B4N_19Xe09kopQ.png"/></div></div></figure><p id="3d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，<code class="du li lj lk ll b">H</code>位表示数据是否是霍夫曼编码的，而<code class="du li lj lk ll b">StringLength</code>顾名思义，表示字符串八位字节的长度。详细说明一个单字符串文字的例子是没有意义的，直到我们了解了这些文字是如何在标题字段中表示的，然后，我们可以看看附录[4]中给出的几个例子。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="9aa6" class="jr js hi bd jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko bi translated">标题字段表示💠</h1><p id="bc69" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在RFC的“二进制格式”中有详细介绍，现在我们将探究这些文字表示实际上是如何工作的。利用不同的报头字段表示，一个编码器实现可以向解码器给出关于该表示实际上意味着什么以及是否应该将其保存到动态表中，以及是否应该改变动态表的大小的指令。</p><h2 id="97bf" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated">索引头字段表示</h2><p id="58fd" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">索引头字段以<code class="du li lj lk ll b">1</code> 1位模式开始，其余的八位字节由匹配头字段的索引填充(是的，你猜对了，它是N=7的整数)。这种表示识别静态或动态表中的条目。</p><h2 id="87f5" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated">文字头字段表示</h2><p id="3ae4" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">文字头字段表示包含文字头值。这可能是一个字符串或对现有表条目的引用(静态或动态都无所谓。)</p><blockquote class="jk jl jm"><p id="1d5b" class="if ig jn ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated">另外，让我们暂时将<strong class="ih hj">文字头字段缩写为LHF </strong>(是的，我很懒)</p></blockquote><h2 id="757a" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated"><strong class="ak">带增量索引的LHF</strong></h2><p id="889b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这导致将头字段附加到“解码的头列表”并将其作为新条目插入到动态表中。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nc"><img src="../Images/99beb9a64d1cbb26a54f2f7947f77ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkSAaG11hgnfM2GK6ZU-Kw.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Literal Header Field with incremental indexing</figcaption></figure><p id="f401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的二进制表示以一个<code class="du li lj lk ll b">01</code> 2位模式开始。如果<strong class="ih hj">标题字段名</strong>与静态/动态表中条目的标题字段名匹配，那么编码器可以简单地引用该条目的索引，并且该索引将被表示为具有6位前缀的整数。</p><p id="88e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，前缀八位位组被设置为0，并且发送2个字符串值，每个表示<strong class="ih hj">报头字段名称</strong>和<strong class="ih hj">报头字段值</strong>，并且随后在成功解码时存储在动态表中。</p><h2 id="7caa" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated"><strong class="ak"> LHF无索引</strong></h2><p id="d5be" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这导致将头字段附加到“解码的头列表”上，而动态表中没有任何变化。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nc"><img src="../Images/a4becc2251c525ed6513452e84eda60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME15KBwxG0AfXjeb1kJNKA.png"/></div></div></figure><p id="ac94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的二进制表示以<code class="du li lj lk ll b">0000</code> 4位模式开始，其余的规则类似于你刚刚读到的带有索引的LHF的规则，所以我在这里不再重复。</p><h2 id="3fce" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated">动态表格大小更新</h2><p id="df45" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">它是一个简单的八位字节，以3位模式<code class="du li lj lk ll b">001</code>开始，后面是一个新的最大大小，用N = 5的整数表示。这表示大小更新改变了动态表的大小。顺便说一下，它必须低于或等于在连接阶段由HTTP/2协议在<code class="du li lj lk ll b">SETTINGS_HEADER_TABLE_SIZE</code>参数中确定的限制。</p><h2 id="b6f9" class="lt js hi bd jt lu lv lw jx lx ly lz kb iq ma mb kf iu mc md kj iy me mf kn mg bi translated">题头字段表示实施✍️</h2><p id="a258" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在，让我们来看一个例子，好吗？我将选择附录C.2.1 [5]中给出的例子，它讨论了在<strong class="ih hj">头字段事先没有出现在任何表中的情况下，带有增量索引</strong>的<strong class="ih hj">文字头字段的情况。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nd"><img src="../Images/65b319df98b4bc0a3ff9bdb07dd5280e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqiD3nlBCG3RRuPgEGoGWA.png"/></div></div></figure><p id="4428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要监控解码器如何处理图片中给出的hexdump。让我们一个一个来看，如果你将<code class="du li lj lk ll b">40</code>解码成一个八位字节，它将是<code class="du li lj lk ll b">01000000</code>，这意味着它是解码器中动态表的一个命令，对它解码的任何内容进行索引，并且没有对任何现有索引值的引用。<code class="du li lj lk ll b">0a</code>被转换为<code class="du li lj lk ll b">0000 1010</code>，这意味着后面的字符串是<strong class="ih hj">非霍夫曼编码的</strong>并且长度为10，那么<strong class="ih hj"> 63 75 73 74 6F 6D 2D 6B 65 79 </strong>对应于头字段名称。</p><p id="99c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随后的<code class="du li lj lk ll b">0d</code>被转换为<code class="du li lj lk ll b">0000 1101</code>，其再次示出了随后的字符串是<strong class="ih hj">非霍夫曼编码的</strong>，并且长度为13，则<strong class="ih hj">63 75 73 74 6F 6D 2D 68 65 61 64 65 72</strong>对应于报头字段值。</p><p id="a89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个操作完成后，解码器内部的动态表将把<code class="du li lj lk ll b">[1]custom-key: custom-header</code>作为一个键值对，它将能够在以后引用这个键值对。我强烈推荐这个Cloudflare的博客[2],以了解这个关键值对后来是如何被利用的。</p><h1 id="7174" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">但是节省了多少空间呢？🤔</h1><p id="682d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这种压缩和缓存策略的全部目的是节省空间，对吗？让我们试着找出使用计数器请求节省了多少空间，让我们假设当条目<strong class="ih hj">自定义键</strong>已经存在于动态表中时，上面的例子将被编码。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ne"><img src="../Images/a975df9033ec670052d53b17b9fd1045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baIDsAI_wthOkOf8997zwg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">When the header is in dynamic table</figcaption></figure><p id="0ee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">3E</code>，这是编码器需要输入的所有内容，它将被解码为<code class="du li lj lk ll b">1 0111110</code>，这意味着这是一个索引头字段，其索引号为<code class="du li lj lk ll b">63</code> ( <strong class="ih hj">为什么是63？</strong>因为有62个静态不可修改的标题列表，动态标题索引就在那之后开始。</p><p id="c48b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在第一个请求中，使用了16 * 13 = <strong class="ih hj"> 208位</strong>，而在具有相同报头的第二个请求中，仅使用了<strong class="ih hj"> 8位</strong>。在这个特殊的例子中，后续的缓存请求只使用了最初通过网络需要的的<strong class="ih hj">到3.8%的内存。然而，假设了以下条件:</strong></p><ol class=""><li id="ba0a" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc nf la lb lc bi translated">动态表不会删除索引</li><li id="49d9" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc nf la lb lc bi translated">编码器使用索引表示，而不是添加/复制键值对。</li><li id="b811" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc nf la lb lc bi translated">实际头的长度相当大，因此用索引代替它可以有效地通过网络进行传递。</li><li id="f41b" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc nf la lb lc bi translated">解码器和编码器之间有足够的内存来将这个键值对添加到动态表中。</li></ol><h1 id="42fd" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="b199" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">通过这个例子，我可以得出结论，如果初始条目是非霍夫曼编码的，并且其他条件是理想的，那么存在一个96% 的压缩<strong class="ih hj">。但是这是一个一次性的例子，以具体展示这种计算是如何工作的，Cloudflare的博客[2]给出了对一个大得多的样本集的详细见解，他们注意到入口头中有一个76%<strong class="ih hj">的压缩。这是一个有趣的理解算法，你可以在帖子中随意指出任何不准确的地方。</strong></strong></p><p id="2b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到下一次:D</p><h1 id="e614" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">资源</h1><ul class=""><li id="9317" class="ku kv hi ih b ii kp im kq iq ng iu nh iy ni jc kz la lb lc bi translated">[1]<a class="ae nj" href="https://datatracker.ietf.org/doc/html/rfc7541" rel="noopener ugc nofollow" target="_blank">HPACK RFC:HTTP/2的报头压缩</a></li><li id="f099" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">[2]<a class="ae nj" href="https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/" rel="noopener ugc nofollow" target="_blank">HPACK:HTTP/2</a>的无声杀手(特性)</li><li id="1f43" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">[3] <a class="ae nj" href="https://datatracker.ietf.org/doc/html/rfc7541#appendix-A" rel="noopener ugc nofollow" target="_blank">附录A:静态标题定义</a></li><li id="d143" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">[4] <a class="ae nj" href="https://datatracker.ietf.org/doc/html/rfc7541#appendix-C.2" rel="noopener ugc nofollow" target="_blank">附录C:标题字段表示示例</a></li><li id="4279" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">[5] <a class="ae nj" href="https://datatracker.ietf.org/doc/html/rfc7541#appendix-C.2.1" rel="noopener ugc nofollow" target="_blank">附录C.2.1 </a></li></ul></div></div>    
</body>
</html>
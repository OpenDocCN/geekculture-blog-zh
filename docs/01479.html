<html>
<head>
<title>Exception Propagation From Another Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自另一个进程的异常传播</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/exception-propagation-from-another-process-bb09894ba4ce?source=collection_archive---------23-----------------------#2021-04-11">https://medium.com/geekculture/exception-propagation-from-another-process-bb09894ba4ce?source=collection_archive---------23-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<em class="jd">异常</em>处理回父进程是非常困难的，甚至是不可能的。</p><p id="71ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单的有用，但是很多其他的没用。</p><p id="bf4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，<code class="du je jf jg jh b">CalledProcessError</code>是不可选择的(我猜，这是因为<code class="du je jf jg jh b">stdout</code>、<code class="du je jf jg jh b">stderr </code>数据成员)。</p><p id="266c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，如果子进程抛出未被捕获的<code class="du je jf jg jh b">CalledProcessError</code>，它将传播到父进程，但传播将失败，这显然是因为Python本身的缺陷。这将导致<em class="jd"> pool.join()永远停止——从而导致内存泄漏！</em>参见<a class="ae ji" href="https://stackoverflow.com/questions/15314189/python-multiprocessing-pool-hangs-at-join" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/15314189/python-multi processing-pool-hangs-at-join</a>和<a class="ae ji" href="https://bugs.python.org/issue9400" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue9400</a></p><p id="1bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我创建了<code class="du je jf jg jh b">GuardedWorkerException </code>上下文管理器来缓解这个问题。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="aa4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">源代码你可以在这里找到<a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py" rel="noopener ugc nofollow" target="_blank"/>。它是我的AlexBerUtils项目的一部分。</p><p id="a5be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以从PyPi安装AlexBerUtils:</p><p id="f17d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">python3 -m pip install -U alex-ber-utils</code></p><p id="2bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见<a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils" rel="noopener ugc nofollow" target="_blank">这里的</a>了解更多关于如何安装的详细说明。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="1413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一些具有多进程计算的应用程序的代码存根。</p><p id="ab28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您编写了一些脚本或应用程序，打包并安装为YourApp(也就是说，它安装在site-packages或venv中)。大概是这样的:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div class="er es jq"><img src="../Images/422bc98791324545648fe88892f2a875.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*9c9YYGgfgmP48mvIfG9QJg.png"/></div></figure><p id="f105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">app.py</code>的代码:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="f9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>这里我使用的是<em class="jd"> init_app_conf </em>模块。你可以在这里阅读<a class="ae ji" rel="noopener" href="/analytics-vidhya/my-major-init-app-conf-module-1a5d9fb3998c">。</a></p><p id="a365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>通常，在脚本/应用程序的<code class="du je jf jg jh b">main()</code>函数的末尾有以下几行:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="d13f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看这里<a class="ae ji" href="https://alex-ber.medium.com/making-more-yo-relative-path-to-file-to-work-fbf6280f9511" rel="noopener">为我的替代设置制作更多的文件相对路径</a>。你可以在下面的附录中找到完整的代码。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="b14d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">真正有趣的部分发生在<code class="du je jf jg jh b">compute_parallel()</code>和<code class="du je jf jg jh b">prepare_parallel()</code>内部。注意，<code class="du je jf jg jh b">prepare_parallel()</code>在单个子流程中运行。</p><p id="0abe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，<code class="du je jf jg jh b">compute_parallel()</code>和<code class="du je jf jg jh b">prepare_parallel()</code>是分开运行的。因此，如果异常发生，它将传播到主进程，并可能挂起我们的应用程序。</p><p id="1267" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将这些函数的代码包装在<code class="du je jf jg jh b">GuardedWorkerException</code>上下文管理器中，它将防止这种挂起。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h1 id="289d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">GuardedWorkerException是如何工作的？</h1><p id="0d88" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">先来看看<code class="du je jf jg jh b">prepare_parallel()</code>功能。</p><p id="9720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，导入，所有的函数体都封装在</p><pre class="jr js jt ju fd ld jh le lf aw lg bi"><span id="4a03" class="lh kb hi jh b fi li lj l lk ll">with GuardedWorkerException(logger=logger):<br/>   #...</span></pre><p id="861f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录器参数是可选的。如果未通过，则使用<code class="du je jf jg jh b">sys.stderr</code>代替。</p><p id="d671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我上面的代码中，日志是在<code class="du je jf jg jh b">global_init()</code>函数中配置的。这个全局函数实际上也是初始化的全局<code class="du je jf jg jh b">logger</code>变量，它被传递给<code class="du je jf jg jh b">GuardedWorkerException</code>并用于日志记录。</p><p id="b3b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，如果任何<code class="du je jf jg jh b">Exception</code>(注:<code class="du je jf jg jh b">not BaseException</code>)被引发，它将被记录，到<code class="du je jf jg jh b">new Exception(‘Worker failed<strong class="ih hj">’</strong>)</code>时将被引发。</p><p id="c94c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做是为了暂停常规执行，而是为了对流程传播异常使用“良好行为”。我确信上述异常不会中断程序执行或导致内存泄漏。</p><p id="c5ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">with</code>块中的代码正常返回，那就没有什么有趣的事情发生。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="958d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对<code class="du je jf jg jh b">GuardedWorkerException</code>有什么灵活性？</p><p id="22cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看看<code class="du je jf jg jh b">compute_parallel()</code>功能。</p><p id="9ce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，导入，所有的函数体都封装在</p><pre class="jr js jt ju fd ld jh le lf aw lg bi"><span id="b959" class="lh kb hi jh b fi li lj l lk ll">with GuardedWorkerException(logger=logger, suppress=True):<br/>    #...</span></pre><p id="ebc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，如果任何<code class="du je jf jg jh b">Exception</code>(注意:<code class="du je jf jg jh b">not BaseException</code>)被引发，它将被记录，并且<code class="du je jf jg jh b">Exception</code>本身将被抑制，不会引发任何东西，就像块执行正常退出一样。</p><p id="bf36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">suppress</code>参数的默认值为<code class="du je jf jg jh b">False</code>。</p><p id="c139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">default_exc_message </code>参数的默认值为“工人故障”。如果您在此处提供另一个值，则引发的消息<code class="du je jf jg jh b">Exception</code>将为<code class="du je jf jg jh b">default_exc_message</code>。</p><p id="9c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有一些并行处理的不相关计算，这是有意义的。如果你在一个计算中有异常，你不想中止并行的计算，你想完成所有的事情(有一些迹象表明你只有部分结果是个好主意，但是你可以在所有的<code class="du je jf jg jh b">compute_parallel()</code>计算完成后再做)。</p><p id="2739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:你也可以实现重试机制。最简单的实现如下:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="4d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>我已经省略了被传递的参数(<code class="du je jf jg jh b">compute_parallel()</code>通常会有一些参数，这些参数将被传递给<code class="du je jf jg jh b">YourClass</code>的<code class="du je jf jg jh b">__init__()</code>方法。</p><p id="3ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在第6–8行中，我们实例化并运行了<code class="du je jf jg jh b">YourClass.</code>，如果这个代码块引发了<code class="du je jf jg jh b">Exception</code>，我们将等待一段时间，然后再次重试。任何重试失败都将被禁止。</p><p id="e283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>如果我们有一些严重的问题(<code class="du je jf jg jh b">BaseException</code>被抛出，它不会被缓存；这是通过设计实现的)。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h2 id="c11a" class="lh kb hi bd kc lm ln lo kg lp lq lr kk iq ls lt ko iu lu lv ks iy lw lx kw ly bi translated">附录</h2><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="675e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些“外部主要”:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jy jz l"/></div></figure></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h1 id="854f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">另请参见:</h1><ul class=""><li id="d2d2" class="lz ma hi ih b ii ky im kz iq mb iu mc iy md jc me mf mg mh bi translated"><a class="ae ji" rel="noopener" href="/analytics-vidhya/integrating-pythons-logging-and-warnings-packages-7ffd6f65e02d">集成Python的日志和警告包</a>。</li><li id="f5bc" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py#L12" rel="noopener ugc nofollow" target="_blank"><em class="jd">fixabscwd()</em></a><em class="jd"> </em></code>功能在<code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py" rel="noopener ugc nofollow" target="_blank"><em class="jd">mains</em></a></code> <em class="jd"> </em>模块或<a class="ae ji" rel="noopener" href="/@alex_ber/making-relative-path-to-file-to-work-d5d0f1da67bf">制作相对路径的文件才能工作</a>。</li><li id="0d78" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py" rel="noopener ugc nofollow" target="_blank"><em class="jd">mains</em></a></code> <em class="jd"> </em>模块中的<code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py#L237" rel="noopener ugc nofollow" target="_blank"><em class="jd">fix_retry_env</em></a><em class="jd">() </em></code>函数或<a class="ae ji" href="https://alex-ber.medium.com/make-path-to-file-on-windows-works-on-linux-402ed3624f66" rel="noopener">Make path to file on Windows works on Linux。</a></li><li id="b782" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py" rel="noopener ugc nofollow" target="_blank"><em class="jd">mains</em></a></code> <em class="jd"> </em>模块中的<code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py#L263" rel="noopener ugc nofollow" target="_blank">FixRelCwd()</a></code>功能或<a class="ae ji" href="https://alex-ber.medium.com/making-more-yo-relative-path-to-file-to-work-fbf6280f9511" rel="noopener">使更多到文件的相对路径工作</a></li><li id="3378" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py" rel="noopener ugc nofollow" target="_blank"><em class="jd">mains</em></a></code> <em class="jd"> </em>模块中的<code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/mains.py#L295" rel="noopener ugc nofollow" target="_blank">GuardedWorkerException()</a></code>函数或<a class="ae ji" href="https://alex-ber.medium.com/exception-propagation-from-another-process-bb09894ba4ce" rel="noopener">异常从另一个进程</a>传播</li><li id="852e" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/files.py" rel="noopener ugc nofollow" target="_blank"><em class="jd">files </em></a></code>模块中的<code class="du je jf jg jh b"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/files.py#L9" rel="noopener ugc nofollow" target="_blank">join_files()</a></code>功能或<a class="ae ji" href="https://alex-ber.medium.com/join-files-cc5e38e3c658" rel="noopener">加入文件</a>。</li><li id="2f6f" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><a class="ae ji" href="https://github.com/alex-ber/AlexBerUtils/blob/master/alexber/utils/stdlogging.py" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> stdLogging </em> </a>模块，或<a class="ae ji" href="https://alex-ber.medium.com/stdlogging-module-d5d69ff7103f" rel="noopener">我的stdLogging模块</a></li></ul></div></div>    
</body>
</html>
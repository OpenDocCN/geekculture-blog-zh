<html>
<head>
<title>Intro to Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/intro-to-big-o-notation-f299915f403f?source=collection_archive---------42-----------------------#2021-07-28">https://medium.com/geekculture/intro-to-big-o-notation-f299915f403f?source=collection_archive---------42-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/52d48a6b9e3d20f3cca568d75ee709a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*lYk0IF6QCJFV396WDHxfAQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx">Warp 1 or O(1)..?</figcaption></figure><p id="93d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着输入大小的增加，大O符号用于对算法的运行时或空间效率进行分类。这是一种描述算法功能的性能和/或复杂性的方式。算法的Big-O分类是基于最坏的情况。它是开发人员用来比较解决问题的不同方法的效率的“语言”(或者术语)。就个人而言，数学从来都不是我的强项，因此我将使用一些编码示例来说明常见的大O类别。</p><h2 id="6b79" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">时间和空间复杂性的背景</h2><p id="72d5" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">因为单个计算机的处理速度差异很大，很明显，不能用计算机运行一个算法所花费的时间来衡量算法的效率。取而代之的是，使用一个概念来观察运行时增长有多快。为了测量<em class="ko">时间复杂度</em>，使用了计算机为了完成算法/功能而需要执行的操作数量。至于推导<em class="ko">空间复杂度</em>，使用成功完成算法/功能所需的内存量。</p><p id="362c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">优化时间和空间复杂性需要了解数据结构及其属性/特征——有些对于搜索功能更有效，而有些对于插入目的更节省内存。我写了一篇关于常见数据结构的文章，并将链接如下:</p><div class="kp kq ez fb kr ks"><a rel="noopener follow" target="_blank" href="/geekculture/intro-to-data-structures-735142170c7a"><div class="kt ab dw"><div class="ku ab kv cl cj kw"><h2 class="bd hj fi z dy kx ea eb ky ed ef hh bi translated">数据结构介绍</h2><div class="kz l"><h3 class="bd b fi z dy kx ea eb ky ed ef dx translated">在这篇文章中，我将介绍作为程序员应该知道的常见数据结构，以及哪些数据…</h3></div><div class="la l"><p class="bd b fp z dy kx ea eb ky ed ef dx translated">medium.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg ik ks"/></div></div></a></div><p id="e257" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要理解大O符号，首先必须理解几个定义:</p><ul class=""><li id="c3b9" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><strong class="is hj"> n </strong> —代表大O内某算法的输入，</li></ul><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lq"><img src="../Images/80726bdce353ac84b0a13a0946f91e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkQzWqqIMlAHZ_xNrEPKeA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx">Graphical Representation of Big O Notation</figcaption></figure><p id="20bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你进一步阅读时，你可以参考上面的图表。</p><h2 id="fcc6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">O(1)</h2><p id="dfce" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">O(1)是黄金标准。如果算法的时间或空间复杂度得分为O(1 ),这意味着无论输入数据集的大小如何，执行时间或内存需求都将保持不变— <em class="ko">一次</em>操作或内存分配。它在时间和空间上都是不变的。</p><pre class="lr ls lt lu fd lz ma mb mc aw md bi"><span id="409f" class="jo jp hi ma b fi me mf l mg mh">function countUpTo(n) {<br/>    return arr[0]<br/>}</span><span id="5129" class="jo jp hi ma b fi mi mf l mg mh">nums = [5, 6, 7, 1, 8, 2]</span><span id="0c0b" class="jo jp hi ma b fi mi mf l mg mh">printFirst(6) // =&gt; 5</span></pre><p id="27ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论<strong class="is hj"> printFirst </strong>的输入值大小如何，该函数将只执行一次操作，使其为O(1)。</p><h2 id="3228" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">O(n)</h2><p id="7b8f" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">O(n)描述了操作数与输入中的项目数相同的情况。现在是<em class="ko">线性时间</em>。</p><pre class="lr ls lt lu fd lz ma mb mc aw md bi"><span id="5429" class="jo jp hi ma b fi me mf l mg mh">function printAll(arr) {<br/>   for(let i = 0; i &lt; arr.length;  i++) {<br/>      return arr[i]<br/>   }<br/>}</span><span id="57ba" class="jo jp hi ma b fi mi mf l mg mh">nums = [5, 6, 7, 1, 8, 2]</span><span id="7c2c" class="jo jp hi ma b fi mi mf l mg mh">printAll(nums) // =&gt; <br/>// 5<br/>// 6<br/>// 7<br/>// 1<br/>// 8<br/>// 2</span></pre><p id="35aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数返回值的次数取决于输入中的项数，即运算次数与<strong class="is hj"> n </strong>成比例增长。和上面的循环一样，简单循环的时间复杂度是O(n)。</p><p id="71c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上，完成该函数所执行的操作的数量取决于输入(n ),因为每次执行循环的迭代时，输入的长度都与新的值<strong class="is hj"> i </strong>、<strong class="is hj"> i </strong>进行比较，并且随着每次迭代，返回索引<strong class="is hj"> i </strong>处的值。这导致了基于函数为了到达输入的结尾而必须执行的循环数的可变操作数(<strong class="is hj"> n </strong>)。</p><h2 id="7296" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">O(n^2)</h2><p id="0ccb" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">对于O(n ),为完成该函数而执行的操作数会根据输入呈指数增长。当一个O(n)操作嵌套在另一个O(n)操作(例如嵌套循环)，在这种情况下运行时间将以n的速度增长。O(n)次运算是<em class="ko">的二次时间复杂度</em>。</p><pre class="lr ls lt lu fd lz ma mb mc aw md bi"><span id="a424" class="jo jp hi ma b fi me mf l mg mh">function bubbleSort(arr) {<br/>    for (let i = 0; i &lt; arr.length; i++) {<br/>        for (let j = i; j &lt; arr.length; j++) {<br/>            if(arr[i] &lt; arr[j] {<br/>              let switch = arr[i]<br/>              arr[i] = arr[j]<!-- --> <br/>              arr[j] = switch<br/>        <!-- -->}<br/>    }<br/>    return arr<br/>}</span></pre><p id="4cd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有一个时间复杂度为O(n)的冒泡排序算法的表示，因为我们嵌套了两个循环。如果<strong class="is hj"> arr </strong>有<em class="ko"> n </em>个项目，那么对于外循环的每次迭代，外循环运行<em class="ko"> n </em>次，内循环运行<em class="ko"> n </em>次，总共有n次操作。</p><p id="0bbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<strong class="is hj"> arr </strong>有10个项目，我们必须循环100次。如果它有1，000个项目，我们必须打印1，000，000次。</p><h2 id="ef13" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">o(登录号)</h2><p id="b2b7" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">对数运行时，即O(log n)，意味着运行时与输入大小的对数成比例增长。一个可以用来可视化O(log n)的常见例子是在电话簿中查找某人。为了做到这一点，你不需要检查书中的每一个T21人，直到你找到你要找的人。相反，你可以<em class="ko">分而治之</em>查看电话簿，看看你登陆的页面上是什么字母——然后只搜索电话簿中包含你要搜索的姓氏的第一个字母的子集。你继续这种模式，翻书，只搜索包含给定字母的部分，直到你发现你还有一页，并搜索该页上的名字。</p><p id="ffe1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种<em class="ko">分治</em>方法是O(log n ),因为它随着每次划分而提高效率——因为你正在搜索的部分的大小每次被分成一半。上面的电话簿解释是一个<em class="ko">二分搜索法</em>的例子。O(log n)是<em class="ko">对数时间</em>。</p><pre class="lr ls lt lu fd lz ma mb mc aw md bi"><span id="1679" class="jo jp hi ma b fi me mf l mg mh">function logarithmic(n) {<br/>   for(let i = 1; i &lt; n; i*=2) {<br/>      let result = i;<br/>   }<br/>}</span></pre><p id="cd80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，迭代的次数总是小于登录输入的大小，因此最坏情况下的时间复杂度是O(log n)。</p></div></div>    
</body>
</html>
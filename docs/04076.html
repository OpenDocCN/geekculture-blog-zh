<html>
<head>
<title>Selenium Grid With Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Docker群的硒网格</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/selenium-grid-with-docker-swarm-d66e97320380?source=collection_archive---------17-----------------------#2021-06-21">https://medium.com/geekculture/selenium-grid-with-docker-swarm-d66e97320380?source=collection_archive---------17-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本指南中，我们将讨论在GCP或AWS等云服务上使用Docker Swarm建立Selenium网格。</p><p id="671b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们先从基础开始，即什么是Selenium Grid和Docker Swarm。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="b958" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">硒格是什么？</h1><p id="f8f9" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi kn translated">elenium Grid 通过将客户端发送的命令路由到远程浏览器实例，允许在远程机器(虚拟或真实)上执行WebDriver脚本。它旨在提供一种在多台机器上并行运行测试的简单方法。</p><p id="6670" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Selenium Grid允许我们在多台机器上并行运行测试，并集中管理不同的浏览器版本和浏览器配置(而不是在每个单独的测试中)。</p><h2 id="f2e8" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">Selenium网格的用途和主要功能</h2><ol class=""><li id="cb86" class="ll lm hi ih b ii ki im kj iq ln iu lo iy lp jc lq lr ls lt bi translated">所有测试的中心入口点</li><li id="6139" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">管理和控制浏览器运行的节点/环境</li><li id="6d99" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">缩放比例</li><li id="a8cb" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">并行运行测试</li><li id="6da2" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">负载平衡</li></ol><h2 id="532c" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">现在一个问题来了“什么时候用网格”？</h2><p id="5f55" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">一般来说，有两个原因会让你想使用网格。</p><ol class=""><li id="3f63" class="ll lm hi ih b ii ij im in iq lz iu ma iy mb jc lq lr ls lt bi translated">针对多个浏览器、多个版本的浏览器以及运行在不同操作系统上的浏览器运行测试。</li><li id="a46d" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">减少测试套件完成一次测试所需的时间。</li></ol><p id="789b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格通过使用多台机器并行运行测试来加速测试的执行。例如，如果您有一个包含100个测试的套件，但是您设置了Grid来支持4个不同的机器(虚拟机或单独的物理机器)来运行这些测试，那么您的测试套件将在(大约)四分之一的时间内完成，就像您在单台机器上顺序运行测试一样。</p><h1 id="a748" class="jk jl hi bd jm jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh bi translated">什么是Docker Swarm？</h1><p id="9b60" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi kn translated"><span class="l ko kp kq bm kr ks kt ku kv di"> D </span> <a class="ae kw" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> ocker swarm </a>是一个容器编排工具，这意味着它允许用户管理部署在多台主机上的多个容器。</p><p id="ecd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker集群的一个重要优势是为应用程序提供了高水平的可用性。在docker群中，通常有几个工作节点和至少一个管理节点，管理节点负责有效地处理工作节点的资源，并确保集群有效地运行。</p><h2 id="28db" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">Docker群模式服务有哪两种？</h2><p id="6ae6" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">Docker Swarm有两种类型的服务:复制的和全局的。</p><p id="51a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">复制服务:</strong>群模式复制服务通过指定群管理器分配给可用节点的复制任务数量来发挥作用。</p><p id="beac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全局服务:</strong>全局服务通过使用swam管理器向每个满足服务约束和资源需求的可用节点调度一个任务来工作。</p><h2 id="d0a7" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">什么是Docker群节点？</h2><p id="9dac" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">docker群由一组在集群中运行的物理机或虚拟机组成。当一台机器加入集群时，它就成为了集群中的一个节点。docker swarm功能可识别三种不同类型的节点，每种节点在docker swarm生态系统中扮演不同的角色:</p><p id="7525" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Docker群管理器节点:</strong>管理器节点的主要功能是将任务分配给群中的工作者节点。管理节点也有助于执行一些管理任务，这些任务是操作集群所必需的。Docker建议一个群最多有七个管理节点。</p><p id="243d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Docker Swarm Leader节点:</strong>当一个集群建立后，使用Raft共识算法将其中一个分配为“Leader节点”。领导者节点为群做出所有的群管理和任务协调决策。如果领导节点由于中断或故障而变得不可用，则可以使用Raft共识算法来选举新的领导节点。</p><p id="6034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Docker Swarm工作节点:</strong>在拥有众多主机的Docker Swarm中，每个工作节点通过接收和执行管理节点分配给它的任务来工作。默认情况下，所有管理器模式也是工作者节点，并且当它们有可用的资源时能够执行任务。</p><h1 id="b569" class="jk jl hi bd jm jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh bi translated">为什么我们应该将Selenium Grid与Docker Swarm一起使用？</h1><p id="d23c" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">有了Docker Swarm，创建一个具有高可用性的动态网格变得很容易，它可以根据我们的需求进行扩展。本文将带您使用3台机器(1个管理器，2个工作节点)在GCP上建立一个网格。建议的最小设置是至少5台机器(3个管理器，2个工作节点)。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="e5cf" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">让我们从设置开始</h1><p id="1ebb" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">既然我们清楚了什么是Selenium Grid、Docker Swarn、它们的优点以及为什么要一起使用它们，那么让我们从设置开始。</p><h2 id="c647" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">在GCP创建基础机器</h2><p id="a028" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">创建3台<code class="du mh mi mj mk b">E2</code>实例类型的机器，选择<code class="du mh mi mj mk b">Ubuntu Server 21.04 LTS (HVM), SSD Volume Type</code>作为操作系统。我们将使用ubuntu，以便安装最新版本的Docker。</p><p id="e8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先在所有3台机器上安装docker</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="f329" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">设置群组主节点和工作节点</h2><p id="f38b" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">选择一台机器作为主机器，并通过运行<code class="du mh mi mj mk b">docker swarm init</code>在其上启动Docker Swarm模式</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es ms"><img src="../Images/a214089e763ef94ed7c3c2660957ccb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThTWZqEtrK48NIhlrV9T1w.png"/></div></div></figure><p id="98ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在另外两台机器上执行join命令，作为工作节点加入群网络:</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es mz"><img src="../Images/cb85535516a170c33b56c28cdba93d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQo8cmfIKSWyeJU0RsLhNA.png"/></div></div></figure><p id="59b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦主节点和工作节点设置完成，在主节点上执行<code class="du mh mi mj mk b">docker info</code>命令以查看更多关于群网络的信息。如果一切正常，您将在输出中看到<code class="du mh mi mj mk b">Swarm: active</code>和<code class="du mh mi mj mk b">Nodes: 3</code>(3，因为即使经理也是节点之一)</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es na"><img src="../Images/c6d3d974afb634d939ac366e25a82f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAJ5AQHXkIvk6XaBDkAQ9g.png"/></div></div></figure><h2 id="90e8" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">创建硒网格</h2><p id="a25c" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">一旦创建了swarm manager节点和worker节点，下一步就是设置Selenium网格。为此，我们创建一个Docker堆栈兼容的合成文件。下面的<code class="du mh mi mj mk b">.yaml</code>将用于部署docker堆栈。</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="c660" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">端口映射:</strong>我们已经将<code class="du mh mi mj mk b">ports</code>公开为<code class="du mh mi mj mk b">4444:4444</code>，这基本上意味着可以在Swarm网络中的任何节点上通过端口<code class="du mh mi mj mk b">4444</code>连接到网格。但是我们没有为节点这样做，因为我们不想在群节点上暴露单个节点。</p><p id="4469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">部署约束:</strong>约束选项<code class="du mh mi mj mk b">constraints: [node.role == worker]</code>允许我们将工作负载放在worker节点上，而不是manager节点上。如果您想在manager节点上运行hub，请使用<code class="du mh mi mj mk b">[node.role == manager]</code>作为值</p><p id="c0b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">环境变量:</strong>我们为节点定义了两个环境变量<code class="du mh mi mj mk b">HUB_PORT_4444_TCP_ADDR: hub</code>和<code class="du mh mi mj mk b">HUB_PORT_4444_TCP_PORT: 4444</code>。这是因为selenium入口点脚本使用了这些环境变量。这些变量是在Docker的早期版本中使用链接时自动创建的。这个特性现在被弃用了，不再创建变量。所以我们需要定义它们。</p><p id="45d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">卷映射</strong>:卷<code class="du mh mi mj mk b">/dev/shm</code>和<code class="du mh mi mj mk b">/dev/urandom</code>从主机共享，因为它们对于浏览器的某些工作是必需的。</p><h2 id="bd15" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">入口点覆盖</h2><p id="7f3f" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们使用了两种不同的方法来覆盖<code class="du mh mi mj mk b">chrome</code>和<code class="du mh mi mj mk b">firefox</code>图像的入口点</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="22b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用两种不同方法的原因是为了展示这两种方法。</p><p id="96a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么首先，为什么我们需要在<code class="du mh mi mj mk b">SE_OPTS</code>中覆盖主机？原因是一个容器可以有多个接口，当我们启动<code class="du mh mi mj mk b">selenium-server.jar</code>时，它试图根据可用的接口进行猜测。然后，它将这个地址发送给hub，以便与它联系。在多个接口的情况下，地址可能被错误地确定，并且在这种情况下，集线器将不能与节点通信。要解决这个问题，我们需要自己确定容器的IP或主机名。</p><p id="d040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有两种方法，一种是使用容器的主机名。这是随机的，可以是字母数字。第二种方法是使用IP地址。这需要在容器映像上安装IP命令。这在<code class="du mh mi mj mk b">chrome</code>图像中可用，但在<code class="du mh mi mj mk b">firefox</code>图像中不可用。所以主机名方法在这两种情况下都适用。</p><p id="df23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker会在运行的容器中自动创建一个名为HOSTNAME的环境。我们使用双美元<code class="du mh mi mj mk b">$$</code>来确保docker在解析我们的合成文件时不处理环境变量</p><h2 id="fb33" class="kx jl hi bd jm ky kz la jq lb lc ld ju iq le lf jy iu lg lh kc iy li lj kg lk bi translated">部署Selenium网格</h2><p id="83af" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">为了部署Selenium网格，我们必须在Swarm manager节点上执行下面的命令</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="6ef1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<code class="du mh mi mj mk b">docker stack ps grid</code>命令检查堆栈的状态</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nb"><img src="../Images/35e59630b2ad1b33674ee172ddac3aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrlIHC9WZId7nUPxhwWasA.png"/></div></div></figure><h1 id="bf96" class="jk jl hi bd jm jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh bi translated">测试网格</h1><p id="d726" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们已经部署了网格，下一步是验证它是否已经启动并运行。我们将使用python来测试我们的网格。Python不会预装在GCP的ubuntu图像上。所以我们需要先安装python。</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="0f00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦python和pip安装完毕，下一步就是安装<strong class="ih hj"> selenium </strong>。</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="3d89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦selenium就绪，我们就可以在python中执行以下命令来测试网格:</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="26fa" class="jk jl hi bd jm jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh bi translated">缩放网格</h1><p id="94b6" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们可以轻松地放大和缩小网格，甚至可以根据负载应用自动缩放来添加新的工作节点。</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="mq mr l"/></div></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="2e6c" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="6762" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">本文研究了如何使用Docker和Docker Swarm配置Selenium Grid，以便在多台机器上分布测试。</p><p id="95f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">寻找一些挑战？</p><ol class=""><li id="a5e2" class="ll lm hi ih b ii ij im in iq lz iu ma iy mb jc lq lr ls lt bi translated">通过在不同的Selenium网格节点上并行运行所有测试方法，尝试进一步减少测试执行时间。</li><li id="446c" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">在Travis或Jenkins(或其他CI工具)上配置测试的运行，使它们成为持续集成过程的一部分。</li></ol></div></div>    
</body>
</html>
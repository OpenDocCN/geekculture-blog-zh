<html>
<head>
<title>Create Docker Images without Docker daemon (Kaniko)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建没有Docker守护进程的Docker映像(Kaniko)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-docker-images-without-docker-daemon-kaniko-847a688155a6?source=collection_archive---------4-----------------------#2021-08-03">https://medium.com/geekculture/create-docker-images-without-docker-daemon-kaniko-847a688155a6?source=collection_archive---------4-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="24e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker中众所周知的安全缺陷是，它需要root访问权限来使用Docker守护程序构建您的Docker映像。</p><p id="f07f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道在使用root访问权限时应该小心。本文将有助于理解使用docker和Docker替代品(Kaniko)来缓解安全问题的缺点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b1b40f962baca2e3bf0580d4fdacf764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2e3j39VFN5D4GJrNrrkh6g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Docker Inside Docker</figcaption></figure><h1 id="4a59" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Docker内部Docker的已知问题:</strong></h1><p id="6bea" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了理解为什么docker守护进程以root权限运行，以及这是一个什么问题，我们首先需要理解Docker的高层架构。</p><p id="d3ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器图像是用Dockerfile文件指定的。docker文件详细介绍了如何根据您的应用和资源<a class="ae kw" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">构建</a>映像。使用Docker，我们可以使用build命令来构建我们的容器映像。一旦你有了docker文件的图像，你就可以<a class="ae kw" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank">运行</a>它。运行映像时，会创建一个容器。</p><p id="97a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Docker架构的简化图，直接取自<a class="ae kw" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/021816895301a388d384505c414735f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMwScMsMUafCPs9iwP060Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Docker Architecture</figcaption></figure><p id="e5e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker的问题是我们不能在你的系统上直接使用docker。在大多数情况下，我们只会与Docker CLI交互。然而，使用Docker运行应用程序意味着您必须使用root权限运行<a class="ae kw" href="https://docs.docker.com/engine/install/linux-postinstall/" rel="noopener ugc nofollow" target="_blank"> Docker守护进程。它实际上绑定到Unix套接字，而不是TCP端口。默认情况下，用户只能使用由用户<em class="ky"> root </em>拥有的<em class="ky"> sudo </em>命令来访问Unix套接字。</a></p><p id="ef9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker守护进程负责容器和图像的状态，并促进与“外部世界”的任何交互。Docker CLI仅用于将命令转换为发送到Docker守护进程的API调用。这允许您使用本地或远程Docker守护程序。</p><p id="9c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌通过提供一个叫做<a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>的工具解决了这个问题。Kaniko帮助您在不访问Docker守护进程的情况下在容器中构建容器映像。这样，您可以在容器内执行构建作业，而无需授予对主机文件系统的任何访问权限。</p><h1 id="b5e1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> Kaniko: </strong></h1><p id="cc1e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Kaniko 是一个开源工具，允许用户构建映像，即使没有授予它root访问权限。这些图像构建在一个容器或Kubernetes集群中。与Docker守护进程不同，Kaniko执行用户空间中的所有命令。Kaniko由谷歌维护。</p><p id="8e46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署和运行Kaniko有几种不同的方法:</p><ul class=""><li id="6a01" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-a-kubernetes-cluster" rel="noopener ugc nofollow" target="_blank">在一个Kubernetes集群中</a></li><li id="e092" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-google-cloud-build" rel="noopener ugc nofollow" target="_blank">在谷歌云构建中</a></li><li id="424f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-docker" rel="noopener ugc nofollow" target="_blank">在码头</a></li><li id="eb83" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">在<a class="ae kw" href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-gvisor" rel="noopener ugc nofollow" target="_blank"> gVisor </a>中</li></ul><p id="ea20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要运行容器，Kaniko需要三个参数:</p><ol class=""><li id="2f7c" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc ln lf lg lh bi translated">一份文件</li><li id="4df9" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc ln lf lg lh bi translated">构建上下文:包含docker文件的目录，Kaniko可以用它来构建您的映像。</li><li id="1614" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc ln lf lg lh bi translated">最终映像应被推送到的注册表的名称。</li></ol><h1 id="dfae" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Kaniko如何工作</h1><ul class=""><li id="1c9d" class="kz la hi ih b ii kr im ks iq lo iu lp iy lq jc le lf lg lh bi translated">读取指定的<code class="du lr ls lt lu b">Dockerfile</code>。</li><li id="75ef" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">将基本映像(在<code class="du lr ls lt lu b">FROM</code>指令中指定)提取到容器文件系统中。</li><li id="b03f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">单独运行<code class="du lr ls lt lu b">Dockerfile</code>中的每个命令。</li><li id="2fe3" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">每次运行后，拍摄用户空间文件系统的快照。</li><li id="76a6" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">每次运行时将快照层附加到基础层。</li></ul><p id="1ef6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，Kaniko不依赖于Docker守护进程。</p><h1 id="79cc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">从Kaniko开始:</strong></h1><p id="bb71" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们将在Kubernetes集群中使用Kaniko。为了开始使用Kaniko并执行后续步骤，我们假设您有以下设置:</p><ul class=""><li id="05fc" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">正在运行的Kubernetes集群，具有创建、列出、更新和删除作业、服务、pod和机密的权限。</li><li id="efd9" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">用于存储<code class="du lr ls lt lu b">Dockerfile</code>和Kubernetes清单的GitHub帐户。</li><li id="897e" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">用于托管容器映像的Docker Hub帐户。</li></ul><h1 id="6062" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">为集装箱注册创建密码</strong></h1><p id="2195" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">要推送构建的映像，需要向容器注册中心进行认证。因此，请确保在集群中创建它。</p><p id="1bef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将需要以下内容:</p><ul class=""><li id="ed1a" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><code class="du lr ls lt lu b">docker-server</code>—Docker注册服务器，您需要在其中托管您的图像。如果您使用Docker Hub，请使用<code class="du lr ls lt lu b"><a class="ae kw" href="https://index.docker.io/v1/" rel="noopener ugc nofollow" target="_blank">https://index.docker.io/v1/</a></code>。</li><li id="ac2d" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du lr ls lt lu b">docker-username</code>—Docker注册表用户名。</li><li id="97ef" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du lr ls lt lu b">docker-password</code>—Docker注册表密码。</li><li id="e063" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du lr ls lt lu b">docker-email</code>—Docker注册表上配置的电子邮件。</li></ul><p id="2793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令，替换必要的值:</p><pre class="je jf jg jh fd lv lu lw lx aw ly bi"><span id="ce37" class="lz ju hi lu b fi ma mb l mc md">kubectl create secret docker-registry regcred --docker-server=&lt;docker-server&gt; --docker-username=&lt;username&gt; --docker-password=&lt;password&gt; --docker-email=&lt;email&gt;</span></pre><p id="5d08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个测试，我使用nignx图像，我已经有dockerfile和kaniko yaml工作和测试负载来测试图像。</p><p id="00d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们看看Dockerfile。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="a7b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lr ls lt lu b">Dockerfile</code>包含两个步骤。它将基础映像声明给<code class="du lr ls lt lu b">nginx</code>，并将<code class="du lr ls lt lu b">This image is created by kaniko</code>写入<code class="du lr ls lt lu b">/usr/share/nginx/html/index.html</code>。当我们到达NGINX端点时，我们应该得到一个响应。</p><p id="f659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看<code class="du lr ls lt lu b">kaniko.yaml</code>是什么样子的:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="7bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">清单使用<code class="du lr ls lt lu b">gcr.io/kaniko-project/executor:latest</code>图像创建一个容器，并使用以下参数运行它:</p><ul class=""><li id="eb2e" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><code class="du lr ls lt lu b">docker-file</code>—Docker文件的路径，相对于上下文。</li><li id="6cf5" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du lr ls lt lu b">context </code>—Docker上下文。在这种情况下，我们已经指明了我们的GitHub存储库</li><li id="0888" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du lr ls lt lu b">destination</code> —推送构建好的映像的Docker存储库。</li></ul><p id="fd2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，它还在<code class="du lr ls lt lu b">/kaniko/.docker</code>上安装了一个docker config JSON文件，以通过docker存储库进行身份验证。我们在上一节中对此进行了定义。</p><h1 id="a6a3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用Kaniko构建容器映像</h1><p id="2778" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">通过应用<code class="du lr ls lt lu b">kaniko.yaml</code>清单构建映像:</p><pre class="je jf jg jh fd lv lu lw lx aw ly bi"><span id="204a" class="lz ju hi lu b fi ma mb l mc md">[node1 kaniko]$ kubectl apply -f kaniko.yaml<br/>job.batch/kaniko created<br/>[node1 kaniko]$ k get po<br/>NAME           READY   STATUS    RESTARTS   AGE<br/>kaniko-rcdqj   1/1     Running   0          5s<br/>[node1 kaniko]$<br/>[node1 kaniko]$ k get po<br/>NAME           READY   STATUS      RESTARTS   AGE<br/>kaniko-rcdqj   0/1     Completed   0          16s<br/>[node1 kaniko]$</span></pre><p id="ed78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是kaniko pod的日志片段。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mg"><img src="../Images/d87c2330b0cc6ef7ce30331310b97748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_FX7yLu97zvYtIVC0mTmg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Kaniko Logs to verify the image build &amp; Push</figcaption></figure><p id="10f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前新的图像正在被推送到dockerhub。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/26cd3a96cb79a444fabb4166b1e60a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXb-boS_IV9SOrKt_5R5Ag.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Docker Hub Image</figcaption></figure><h1 id="8914" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试创建的映像:</h1><p id="3b77" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了测试这一点，我们创建了简单的部署文件，以使用kaniko创建的图像并打印页面。</p><p id="ab9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lr ls lt lu b">nginx-deployment.yaml</code>文件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="9c14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在spec，containers，image部分，我使用了我们通过kaniko创建的自定义图像名称。</p><p id="4026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lr ls lt lu b">nginx-service.yaml</code>文件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="4159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上述服务中，我们将应用程序暴露在互联网上进行测试。</p><p id="ebad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在应用这两个清单文件，用我们通过kaniko创建的图像创建应用程序。</p><pre class="je jf jg jh fd lv lu lw lx aw ly bi"><span id="31f9" class="lz ju hi lu b fi ma mb l mc md">[node1 tests]$ kubectl apply -f nginx-deployment.yaml<br/>deployment.apps/nginx-deployment created<br/>[node1 tests]$ kubectl apply -f nginx-service.yaml<br/>service/nginx-service created<br/>[node1 tests]$<br/>[node1 tests]$<br/>[node1 tests]$ kubectl get all<br/>NAME                                   READY   STATUS      RESTARTS   AGE<br/>pod/kaniko-rcdqj                       0/1     Completed   0          10m<br/>pod/nginx-deployment-7dd46f65d-d96v7   1/1     Running     0          23s<br/>pod/nginx-deployment-7dd46f65d-dqz7f   1/1     Running     0          23s</span><span id="9b4a" class="lz ju hi lu b fi mi mb l mc md">NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE<br/>service/kubernetes      ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        11m<br/>service/nginx-service   NodePort    10.103.233.221   &lt;none&gt;        80:31065/TCP   15s</span><span id="383d" class="lz ju hi lu b fi mi mb l mc md">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/nginx-deployment   2/2     2            2           23s</span><span id="3406" class="lz ju hi lu b fi mi mb l mc md">NAME                                         DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/nginx-deployment-7dd46f65d   2         2         2       23s</span><span id="ad41" class="lz ju hi lu b fi mi mb l mc md">NAME               COMPLETIONS   DURATION   AGE<br/>job.batch/kaniko   1/1           14s        10m<br/>[node1 tests]$</span></pre><p id="136a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所见，测试应用程序已经启动，运行良好，使用我们创建的图像，让我们进行小的curl/web测试。</p><p id="b0ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我已经启用了<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">节点端口</a>，所以我必须用<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">节点端口</a>端口号点击kubernetes节点IP来测试应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/dec5a5dac960cba8e369f280b594ef20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upXPNI55WR9iTrKZuxGdyw.png"/></div></div></figure><pre class="je jf jg jh fd lv lu lw lx aw ly bi"><span id="c607" class="lz ju hi lu b fi ma mb l mc md">[node1 tests]$ curl <a class="ae kw" href="http://ip172-19-0-11-c44f1k975d7000bk418g.direct.labs.play-with-k8s.com:31065/" rel="noopener ugc nofollow" target="_blank">http://ip172-19-0-11-c44f1k975d7000bk418g.direct.labs.play-with-k8s.com:31065/</a><br/>This image is created by kaniko<br/>[node1 tests]$</span></pre><p id="0cdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是卷曲测试。</p><p id="c1e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">邮报到此为止。我希望你对Kaniko和它的工作原理有所了解。我将在接下来的几周提出更高级的话题。在那之前，注意安全。</p><p id="c3aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续学习！</p><p id="b839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">叉</strong> <a class="ae kw" href="https://github.com/Sarvabhowma1995/kaniko.git" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这个资源库</strong> </a> <strong class="ih hj">到你的GitHub账号中存放所有的练习文件。</strong></p></div></div>    
</body>
</html>
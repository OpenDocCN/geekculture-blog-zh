<html>
<head>
<title>Implementing K-Means Clustering From Scratch in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中从头开始实现K-Means集群</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-k-means-clustering-from-scratch-in-javascript-13d71fbcb31e?source=collection_archive---------2-----------------------#2021-03-22">https://medium.com/geekculture/implementing-k-means-clustering-from-scratch-in-javascript-13d71fbcb31e?source=collection_archive---------2-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="786a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文结束时，您将理解k-means聚类算法的内部工作原理，并能够自己实现它。</p><h1 id="cabf" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是k-means聚类？</h1><p id="9782" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">K-means聚类是一种无监督的机器学习算法，用于在数据集中查找组。k-means聚类的目标是将一个数据集分成相似项目的组(聚类)。</p><p id="7cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用k-means聚类，您需要为“k”提供一个数据集和一个数值:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7ef1" class="kp je hi kl b fi kq kr l ks kt">k = 3<br/>result = kmeans(dataset, k)</span></pre><p id="e1ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">k-means中的“k”是要将数据集分成的组的数量。在上面的例子中，你说“将这个数据集分成3组，每组的项目彼此相似。<br/>另一种理解方式是“将相似的项目分成三个不同的组”。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ku"><img src="../Images/c4b632de99c47b214d3bb5f9fdb13eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNYL__wr6MbmJUdXtFlw3Q.png"/></div></div></figure><p id="3c7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-means是一种在数据中寻找模式的有用算法。对具有相似性的项目进行分组，并查找彼此不同的项目。<br/>你甚至可以用k-means构建一个分类器，k-means可以从中构建一个分类器。并将新数据分类到新发现的组中。</p><h1 id="21e7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">k-means聚类是如何工作的？</h1><p id="171f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们知道了k-means聚类的目标，让我们看看如何创建它。</p><p id="7310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步:</strong>我们从选择数据集中的随机点开始。这些将是初始质心(群集的中心点)。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lc"><img src="../Images/712b003fad8fbfbcad2582da5073ec92.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*P8gYdMl3ibikh0fmVQejaA.png"/></div></figure><p id="2acf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步:</strong>现在我们检查每个点，并将其分配到一个簇中。我们希望将该点分配给最近的质心。我们通过计算该点和所有质心之间的欧几里德距离，然后将该点分配给最近的一个质心来实现这一点。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lc"><img src="../Images/3bb4a1fe1e3aa519729e4ca92b2c0122.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*NH354uugUOUpMrIV_AUYhw.png"/></div></figure><p id="7fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>在所有的点都被分配到一个聚类之后，我们重新计算聚类的质心。我们通过计算组平均值来做到这一点。这将把质心移动到簇的中心:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lc"><img src="../Images/83a1fbab3e67c616bb52b2e83b7de4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*b1uYUQCM_9qZnKHNNZwxhQ.png"/></div></figure><p id="56bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们重复步骤2和3，直到质心已经收敛(质心与前一次迭代中的质心相同)或者已经达到最大迭代次数。</p><p id="9867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总之:<br/> 1:选择初始质心<br/> 2:将点分配到最近的质心<br/> 3:重新计算质心<br/>重复步骤2和3，直到收敛</strong></p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lc"><img src="../Images/ebfcc16c67d2e9eb3acd0a922dfd0030.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/1*b3GwzgwyQP5djhxEyEEmfA.gif"/></div></figure><p id="81f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过基于聚类平均值重新计算质心，在每次迭代中，质心将移动并逐渐收敛。创建相似项目的组。</p><h1 id="5c3e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Javascript实现</h1><p id="8f23" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">选择初始质心:<br/> </strong>这里我从数据集中随机选择3个数据点。这是选择初始质心的更简单的方法之一，但是存在更好的方法(<a class="ae ld" href="https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/K-means _ clustering # initial ization _ methods</a>)。</p><figure class="kg kh ki kj fd kv"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="11e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将点分配到最近的质心:<br/> ( </strong>出于优化原因，我使用平方欧几里得距离。)</p><figure class="kg kh ki kj fd kv"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="9721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重新计算质心<br/> </strong>通过计算聚类的平均值来重新计算聚类的质心。</p><figure class="kg kh ki kj fd kv"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="6748" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">将所有这些整合在一起:</h1><p id="c8c8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，对于完整的k均值聚类实现。<br/>初始质心对k-means的收敛能力以及到达那里需要多长时间有很大影响。因此，不建议从完全随机选择的点开始。在最终的实现中，我添加了一个更复杂的初始化方法，叫做Naive Sharding(<a class="ae ld" href="https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2017/03/Naive-Sharding-centroid-initial ization-method . html</a>)。</p><p id="57ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在一个循环中运行前面的步骤，直到质心收敛，或者达到最大迭代次数。</p><p id="0e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们返回最终的质心和每个聚类中的数据点列表。</p><figure class="kg kh ki kj fd kv"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="af33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以运行一个简单的例子来测试算法:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lg"><img src="../Images/4abe4b9a5dccdd0d00b0d512a3b495dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*2MeaAPwYXNGAXNO4AYUVMA.png"/></div></figure><p id="7c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且成功了！:)</p><p id="6c6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你对k-means聚类和如何实现有了更好的理解！</p><p id="b14a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一定要把你的新知识付诸实践，并创造性地应用它！<br/>您可以在各种数值数据中应用k-means。例如，我创建了一个应用程序，它可以拍摄一幅图像，并将像素颜色值聚集成五种主色:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lh"><img src="../Images/6e74a80ffb99379201c9de03772bfea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/1*Gb3ZaidhZCch48kJI_vK9Q.gif"/></div></figure><p id="69fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我看看你能用它做什么！</p><p id="331c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这篇文章！如果你用k-means做了很酷的事情，请告诉我。我很想看看你创造的东西！</p></div></div>    
</body>
</html>
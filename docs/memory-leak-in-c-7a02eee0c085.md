# C++中的内存泄漏

> 原文：<https://medium.com/geekculture/memory-leak-in-c-7a02eee0c085?source=collection_archive---------6----------------------->

## 你的程序有内存泄漏吗？

![](img/82a0d735fcffd5b7d3478b42295c1ebe.png)

Photo by [Liam Briese](https://unsplash.com/@liam_1?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

```
ERROR: LeakSanitizer: detected memory leaks
```

哦不，内存泄漏？怎么发生的？

当在堆中分配了内存，但在使用后没有释放内存时，就会发生内存泄漏。因此，它将减少可用的内存。

# 简单的例子

为了说明它是如何发生的，我们将使用一些带有“危险”关键字的简单示例，`new`。

要运行并观察内存泄漏，您可以在运行程序的同时**检查本地计算机的内存。确保您的计算机至少有 4GB 的内存，并准备终止程序！**

您会观察到内存使用量**逐渐增加**，直到您终止程序。如果您将`BigMemory`中的`10`的值增加到一个更大的数字，例如`20`，情况可能会更糟。请注意，`BigMemory`结构中的`usleep`和`10`的值有助于减缓内存泄漏，并且只泄漏一小部分仍可观察到的内存。请不要试图泄漏太多的内存，或者在观察到内存增长后不要终止程序，否则可能会发生的情况是在您的计算机冻结之前填满交换分区，这取决于您的操作系统的处理。

从上面的代码来看，对于默认构造函数`BadClass`的每次调用，`new`操作将为`BigMemory`分配堆内存，然后复制指向`big_memory_`成员变量的指针。但是，由于对象中没有释放内存，所以会发生内存泄漏。

要对这个例子进行简单的修正，只需添加一个析构函数，在对象被销毁时删除分配的内存。

现在再次运行代码，您不会看到任何内存泄漏。

# 可能隐藏内存泄漏的示例

有时，内存泄漏可能隐藏在代码中，与前面的例子相比不太容易识别。

如果类中有很多公共成员函数，那么`AddNewId(int id)`中的`new`关键字很容易被忽略。

现在用`HiddenBadClass`再次运行示例代码，您会发现内存再次泄漏。这次是因为分配了包含`BigMemory`的`BadClass`。

如果我们在析构函数中使用前面的方法来`delete`，我们必须小心地删除映射中每个分配的内存

我相信你们中的一些人可能会想到 RAII(资源获取是初始化)和智能指针来简化代码，并消除记住何时正确删除分配的内存的需要。你说得对，我们可以做得更好

然而，请注意，如果`BadClass`是析构函数中没有`delete`的初始版本，这个`StillHiddenBadClass`仍然会泄漏内存。

# 我们能做什么来避免可能的内存泄漏

因此，我们能做什么来防止可能的内存泄漏呢？答案之一是让洗手液来帮你。例如，您可以在上面的示例中尝试的简单方法是在编译期间添加一个标志

运行内存泄漏的代码会导致

```
ERROR: LeakSanitizer: detected memory leaks
```

但是对于`StillHiddenBadClass`，当泄漏发生在`BadClass`时，可能检测不到。因此，首先理解程序中的内存泄漏是很重要的。

# 泄漏的额外可能原因

从上面的代码来看，不再有`new`或者`delete`，它只是一个基类和派生类。

然而，调用下面的代码

还是会造成 memory_leak。

为什么会这样？

这是因为当派生类对象离开作用域并通过一个指向带有非虚拟析构函数**的基类的指针被销毁时，结果是未定义的。运行时通常会发生的情况是派生类永远不会被销毁。因此，对象被部分破坏，分配给`DerivedClass`中的`BigMemory`的内存将会泄漏。**

解决方案很简单，给基类`virtual`一个析构函数。

```
virtual ~BaseClass() = default;
```

在这种情况下，整个对象将被销毁，包括派生类中的部分

这也是为什么我们在有效的 C++中有*“第 7 项:在多态基类*中声明虚析构函数”。

帖子的结尾到了，希望我已经向你“泄露”了一些关于内存泄漏的见解。

谢谢你的阅读！
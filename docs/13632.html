<html>
<head>
<title>Securing APIs via JWT in GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过戈朗的JWT保护API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/securing-apis-via-jwt-in-golang-9d3659a32c34?source=collection_archive---------3-----------------------#2022-07-20">https://medium.com/geekculture/securing-apis-via-jwt-in-golang-9d3659a32c34?source=collection_archive---------3-----------------------#2022-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b8c9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Json Web令牌(JWT)</h1><p id="c0e8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">JSON Web Token (JWT)是一个开放标准(<a class="ae kb" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它定义了一种紧凑且独立的方式，以JSON对象的形式在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。jwt可以使用秘密(使用<strong class="jf hj"> HMAC </strong>算法)或使用<strong class="jf hj"> RSA </strong>或<strong class="jf hj"> ECDSA </strong>的公钥/私钥对进行签名。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="01a6" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">从Go应用程序开始</h1><p id="d254" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可以直接从一个空的Go项目开始。我们基本上需要一个客户端和一个服务器。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/3f0f024537d1b675d441cef1a61923e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-3TDM-Lhd9054x55BrJ5g.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">project structure</figcaption></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="6fcb" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">在旅途中创建简单的客户端</h1><p id="7887" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将从GoLang的OAuth客户开始。我们将从一个主文件开始，在这里我们需要导入jwt-go库。</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="9625" class="lj ig hi lf b fi lk ll l lm ln">import "github.com/golang-jwt/jwt/v4"</span></pre><p id="397a" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">创造一个JWT发电机</p><p id="a487" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">您可以使用jwt-go库创建JWT生成器函数</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="a84f" class="lj ig hi lf b fi lk ll l lm ln">func GenerateJWTToken() (string, error) {<br/>   token := jwt.New(jwt.SigningMethodHS256)<br/><br/>   claims := token.Claims.(jwt.MapClaims)<br/><br/>   claims["authorized"] = true<br/>   claims["user"] = "@binator_1308"<br/>   claims["exp"] = time.Now().Add(time.<em class="lt">Minute </em>* 30).Unix()<br/><br/>   tokenString, err := token.SignedString(mySignedKey)<br/><br/>   if err != nil {<br/>      fmt.Errorf("generating JWT Token failed")<br/>      return "", err<br/>   }<br/><br/>   return tokenString, nil<br/>}</span></pre><p id="059d" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">您可以运行方法来检查客户端是否可以生成JWT令牌</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lu"><img src="../Images/9889f18b92fa973aac51af4b01d2c485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Vg4lN4KRmKW07RGfCgRcg.png"/></div></div></figure><p id="0aed" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">接下来，我们可以创建一个方法，通过http公开这个特性，并在新请求中创建一个有效的JWT令牌</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="6749" class="lj ig hi lf b fi lk ll l lm ln">func HomePage(w http.ResponseWriter, r *http.Request) {<br/>   validToken, err := GenerateJWTToken()<br/>   if err != nil {<br/>      fmt.Fprintf(w, err.Error())<br/>   }<br/><br/>   fmt.Fprintf(w, validToken)<br/>}</span></pre><p id="e196" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们还需要为此创建一个处理程序。我们将为客户端使用端口9001</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="309d" class="lj ig hi lf b fi lk ll l lm ln">func handleRequests() {<br/>   http.HandleFunc("/", HomePage)<br/>   log.Fatal(http.ListenAndServe(":9001", nil))<br/>}</span></pre><p id="9b0b" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">您应该能够看到在运行应用程序和访问localhost:9001时生成的JWT令牌</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lv"><img src="../Images/92cfa439af3a57a732659a92b11e7a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glB0T6RX75XZnEXyMnKo2A.png"/></div></div></figure><p id="f7c8" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们现在有了一个可以生成JWT令牌的基本客户端。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="7be4" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">在移动中创建简单的服务器</h1><p id="6469" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在从一个简单的服务器开始。我们可以初始化一个简单的主文件。</p><p id="339f" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们可以创建一个包含一些秘密信息的虚拟主页</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="f518" class="lj ig hi lf b fi lk ll l lm ln">func homePage(w http.ResponseWriter, r *http.Request) {<br/>   fmt.Fprintf(w, "Dummy secret information")<br/>}</span></pre><p id="fa65" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们还需要一个在端口9000上服务它的处理程序</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="c34e" class="lj ig hi lf b fi lk ll l lm ln">func handleRequests() {<br/>   http.HandleFunc("/", homePage)<br/>   log.Fatal(http.ListenAndServe(":9000", nil))<br/>}</span></pre><p id="cf7d" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们应该能够在localhost:9000上看到伪秘密信息</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lw"><img src="../Images/7f8a816c96d93ef5c7fb337a0f1b4666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrA-qSfSPU63cQLz853lrg.png"/></div></div></figure><p id="183b" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">现在，我们希望将此信息限制为授权访问它的经过验证的用户。</p><p id="d4ed" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们将从创建一个授权请求的函数开始。现在让我们对<em class="lt">令牌</em>头进行基本检查。</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="183d" class="lj ig hi lf b fi lk ll l lm ln">func isAuthorized(endpoint func(w http.ResponseWriter, r *http.Request)) http.Handler {<br/>   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>      if r.Header["Token"] != nil {<br/><br/>      } else {<br/>         fmt.Fprintf(w, "Not Authorized")<br/>      }<br/>   })<br/>}</span></pre><p id="2fc4" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">接下来，我们将在处理程序中用<em class="lt">句柄</em>替换<em class="lt"> HandleFunc </em>方法，并用我们的认证方法包装它。</p><p id="012a" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">现在我们可以继续讨论授权方法了。我们可以使用签名密钥和HMAC算法(我们在客户机中使用的)解析<em class="lt">令牌</em>头。如果它是有效的，那么我们可以服务于原始端点。</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="1dec" class="lj ig hi lf b fi lk ll l lm ln">func isAuthorized(endpoint func(w http.ResponseWriter, r *http.Request)) http.Handler {<br/>   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>      if r.Header["Token"] != nil {<br/>         token, err := jwt.Parse(r.Header["Token"][0], func(token *jwt.Token) (interface{}, error) {<br/>            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {<br/>               return nil, fmt.Errorf("there was an error")<br/>            }<br/>            return mySigningKey, nil<br/>         })<br/><br/>         if err != nil {<br/>            fmt.Fprintf(w, err.Error())<br/>         }<br/><br/>         if token.Valid {<br/>            endpoint(w, r)<br/>         }<br/>      } else {<br/>         fmt.Fprintf(w, "Not Authorized")<br/>      }<br/>   })<br/>}</span></pre><p id="05bf" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">现在我们可以再次运行服务器了。它仍然应该在浏览器上抛出<em class="lt">未授权</em>异常</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lx"><img src="../Images/f609b9dd3a26dd51b89dd7e31717aa8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSUqIsIqBKopD_tgRAijJA.png"/></div></div></figure><p id="a14f" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">但是在postman上使用来自客户端的有效头运行它，我们应该能够获取秘密信息。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ly"><img src="../Images/357e68ceec07b806e884373d61dc978d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRaGcf8HCrE9ztXriAzl8w.png"/></div></div></figure><p id="29db" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">我们可以在<a class="ae kb" href="https://jwt.io/#debugger-io" rel="noopener ugc nofollow" target="_blank"> json.io调试器</a>上检查正确的头文件。回应应该是这样的:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lz"><img src="../Images/e1eedea4cd88806054f224778f4dca26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXylERlQW27J8bdSOtXK9g.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">decrypting a JWT token</figcaption></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="9bf5" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">在客户端对服务器发出的请求进行身份验证</h1><p id="45ca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们需要将带有有效JWT的令牌头添加到客户端，以获得请求授权。</p><pre class="kp kq kr ks fd le lf lg lh aw li bi"><span id="ec43" class="lj ig hi lf b fi lk ll l lm ln">client := &amp;http.Client{}<br/>req, _ := http.NewRequest("GET", "http://localhost:9000", nil)<br/>req.Header.Set("TOKEN", validToken)<br/>res, err := client.Do(req)<br/>if (err != nil) {<br/>   fmt.Fprintf(w, err.Error())<br/>}<br/><br/>body, err := ioutil.ReadAll(res.Body)<br/>if err != nil {<br/>   fmt.Fprintf(w, err.Error())<br/>}</span></pre><p id="09e2" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">这样，我们的令牌应该是有效的，我们对服务器的所有请求都应该得到服务。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ma"><img src="../Images/6d1644a4d0ac4d3adc96e5e954f05f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVXCk8_jqhfmn3foQaPbiQ.png"/></div></div></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="5bb2" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">结论</h1><p id="d959" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在在GoLang上有了一个基本的服务器和客户端，并通过JWT令牌授权了一个ReST API。API现在是安全的。<br/>这篇文章的代码可以在<a class="ae kb" href="https://github.com/abinator-1308/oauth-implement-golang" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="24a0" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated"><em class="lt">祝贺你坚持到了最后！在</em> <a class="ae kb" href="https://twitter.com/bot_pragmatic" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> Twitter </em> </a> <em class="lt">，</em><a class="ae kb" href="https://github.com/abinator-1308/abinator-1308" rel="noopener ugc nofollow" target="_blank"><em class="lt">GitHub</em></a><em class="lt">，</em><a class="ae kb" rel="noopener" href="/@abhinav.as1308"><em class="lt">Medium</em></a><em class="lt">，</em><a class="ae kb" href="https://www.linkedin.com/in/abinator-1308/" rel="noopener ugc nofollow" target="_blank"><em class="lt">LinkedIn</em></a><em class="lt">，或者</em><a class="ae kb" href="https://www.instagram.com/abinator_1308/" rel="noopener ugc nofollow" target="_blank"><em class="lt">insta gram</em></a><em class="lt">。</em></p><p id="080f" class="pw-post-body-paragraph jd je hi jf b jg lo ji jj jk lp jm jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">感谢阅读！</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="5ad0" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">参考</h1><ul class=""><li id="46ab" class="mb mc hi jf b jg jh jk jl jo md js me jw mf ka mg mh mi mj bi translated"><a class="ae kb" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank">https://oauth.net/2/</a></li><li id="943d" class="mb mc hi jf b jg mk jk ml jo mm js mn jw mo ka mg mh mi mj bi translated"><a class="ae kb" href="https://github.com/golang-jwt/jwt" rel="noopener ugc nofollow" target="_blank">https://github.com/golang-jwt/jwt</a></li><li id="0470" class="mb mc hi jf b jg mk jk ml jo mm js mn jw mo ka mg mh mi mj bi translated"><a class="ae kb" href="https://github.com/dgrijalva/jwt-go" rel="noopener ugc nofollow" target="_blank">https://github.com/dgrijalva/jwt-go</a></li><li id="1d09" class="mb mc hi jf b jg mk jk ml jo mm js mn jw mo ka mg mh mi mj bi translated"><a class="ae kb" href="https://www.youtube.com/watch?v=-Scg9INymBs" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=-Scg9INymBs</a></li><li id="2afe" class="mb mc hi jf b jg mk jk ml jo mm js mn jw mo ka mg mh mi mj bi translated"><a class="ae kb" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Elements of Programming: Fundamental Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程元素:基本数据结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/elements-of-programming-fundamental-data-structures-882a6e57245f?source=collection_archive---------15-----------------------#2021-04-13">https://medium.com/geekculture/elements-of-programming-fundamental-data-structures-882a6e57245f?source=collection_archive---------15-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5590" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据结构是我们在计算机科学中所做的一切的基础:理解它们对于编写严谨的软件和有效的算法是至关重要的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/87a06f748066d6c09081e0b9968e973b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L-pkWJBNTAACn6nK"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alina Grubnyak</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种看待数据结构的一般方法:概念和实现。理想情况下，它们应该帮助您为给定的问题选择有效的数据结构。基本的数据结构在大多数情况下自然地表现出来。问题通常需要某种数据结构，而其他的可以用不同的方式表示。一个有效的数据结构应该可以简化这个问题。但这只是故事的一半，因为数据结构还必须确保计算效率。我们可以通过从概念上寻找一个合适的数据结构来简化问题，同时通过研究实现来获得性能优势。</p><p id="4319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经熟悉了在选择数据结构时从两个角度看问题的本质，我应该正式向您介绍这些特征了。我们可以从抽象和实现的角度来看待数据结构——从现在开始我们称之为抽象数据类型。</p><p id="3205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象数据类型(ADT)应该描述给定数据结构中的一组功能——它们是以声明的方式编写的。它接近于数学中的一种代数结构，概括了特定上下文中的规则和运算[1]。来自数学的灵感建立在一个类中，这个类包含了一系列的值和行为，这些值和行为支持我们在一个结构中可以做的操作。这样的抽象模型隐藏了实现逻辑。ADT是语言无关的，因为它只描述数据结构的原型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Example of ADT in List.</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="fca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用抽象模型(ADT)编程数据结构时，一个好的实践是在包含ADT和实现细节的模块之间建立<a class="ae ju" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松耦合</a>。目的是维护编程逻辑和功能之间的概念图，从而提高系统的可维护性。</p><p id="d5e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个在C++语言中实现ADT的例子，因为标准模板库(STL)被认为是成熟和先进的，它是阅读一个好软件的好参考。然而，由于它的细微差别和技术复杂性，我们将只讨论STL的核心概念之一:容器。</p><p id="4924" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将它保存在一个单独的模块中可以提高可维护性，并在开发人员实现特定于该功能的逻辑之前澄清他们的意图。不要担心新词<em class="jd">单链表</em>，因为我们不会在这里谈论它。现在，关注我们如何编写ADT来描述数据结构的操作——在本例中是一个列表。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Expressing ADT in C++</figcaption></figure><p id="2050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时，实现细节包含了确保ADT中所描述的操作的特殊之处和技巧。从这个角度来看，了解你的语言的特点以了解确保安全和效率的技术是很重要的，比如像C/C++这样的语言中的引用和内存管理。就此而言，实现ADT中定义的概念与语言密切相关；程序员必须精通这门语言的技术。</p><p id="e153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，这两个镜头通过首先建立清晰度，然后建立规格来协同工作。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="d38c" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">基本数据结构</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/7f2f6726853fc43c729eb4da9db71214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n5IR6KA3dCmoWXXQ.jpg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Euclid in Raphael’s <a class="ae ju" href="http://commons.wikimedia.org/wiki/File%3ARaphael_School_of_Athens.jpg" rel="noopener ugc nofollow" target="_blank"><em class="ld">School of Athens</em></a><em class="ld"> </em>(Wikimedia Commons).</figcaption></figure><blockquote class="le"><p id="f895" class="lf lg hi bd lh li lj lk ll lm ln jc dx translated">就像欧几里得几何对世界的抽象和实际的相似性一样，ADT和它的实现以一种方式对应，前者是纯粹理想的，而后者更接近现实。</p></blockquote><p id="bbbc" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">在本节中，我们简要介绍基本的数据结构，并引用一些它们的用例。我们将介绍以下数据结构。</p><ul class=""><li id="759a" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">目录</li><li id="4eb6" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">双端队列</li><li id="43b3" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">树</li><li id="4375" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">一组</li><li id="30c2" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">地图</li><li id="7d04" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">图表</li></ul><p id="2036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们深入研究之前，我们应该记住数据结构的基本功能。每个结构的基线必须支持以下操作:它应该能够搜索一个项目，排序，插入，更新和删除项目。</p><ul class=""><li id="9331" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj">搜索</strong>——算法到<strong class="ih hj">T5找到 </strong>数据结构中的一项。</li><li id="28e0" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">排序</strong>—算法到<strong class="ih hj"> <em class="jd">按一定顺序组织</em> </strong>项。</li><li id="5004" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">插入</strong>—算法到<strong class="ih hj"> <em class="jd">在一个数据结构中插入</em> </strong>项。</li><li id="917f" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">更新</strong>——算法到<strong class="ih hj"> <em class="jd">更新</em> </strong> <em class="jd"> </em>一个数据结构中的现有项。</li><li id="4f90" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">删除</strong>—算法到<strong class="ih hj"> <em class="jd">从数据结构中删除</em> </strong>一个现有项目。</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">base functionality</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h2 id="88c8" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">目录</h2><p id="7cac" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">list是一种抽象数据类型，表示可计数的有序值，其中相同的值可能出现多次。列表可以线性或非线性排序。非线性列表可以以树、图或地图的形式实现。然而，我们在它们各自的类别中对它们进行了区分，因为它们本身有它们自己的细微差别。在这个上下文中，列表属于线性列表族。</p><p id="ea79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当获得顺序的概念时，一个值允许有重复项时，以及当我们想要对数据集进行排序和搜索时，列表数据结构是有用的。List ADT是在C++ STL中的<a class="ae ju" href="https://www.cplusplus.com/reference/stl/" rel="noopener ugc nofollow" target="_blank">序列容器</a>类中实现的。它包括以下内容:数组、向量、队列、forwad_list和list。</p><p id="f754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从概念上讲，所有其他的数据结构都可以用列表来实现[2],然而，我们想根据它们所代表的结构来对它们进行分类，这对我们遇到的问题很有用。(这与我在这里列出的算法分类有关:<a class="ae ju" rel="noopener" href="/swlh/making-sense-of-algorithms-general-perspective-c3ba626577ae">理解算法:一般观点</a>。)</p><p id="8d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们谈论一个列表时，一个常见的结构叫做链表(在STL中实现为一个列表)。它被应用在许多用例中，比如派生其他结构、您在web浏览器中访问的链接或者音乐播放列表。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es na"><img src="../Images/2ccc0005feb14dfde16b64bfeae6480d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RB4qQl63FfDkNtN4"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@fhavlik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Filip Havlik</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="d1ef" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">双端队列</h2><p id="c004" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">Deque是队列和堆栈的组合，因为这些数据结构之间的区别在于它们的排序，而队列保持FIFO顺序，堆栈保持LIFO顺序。因此，deque支持列表的FIFO和LIFO排序。</p><p id="0594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FIFO的意思是先进先出的排序。最常见的例子是在超市排队。有时我们称之为队列，其中建立的策略是先来先服务。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nb"><img src="../Images/e70c064b39b616cb2a2a16cbc2eda080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*va6QOwTag39DhuOn"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@123juli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julius Vincent</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="88c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，LIFO代表后进先出排序。想象一下从一堆书中取出一本书。你必须反复移除最上面的书，直到你找到你想读的书。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nc"><img src="../Images/b2a850acb8aa69ac79a653c26961707e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P6yuO0aLd6H6hozz"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">队列用于在处理请求时保持后进先出的优先顺序。一个很好的例子是调度系统:处理是基于<em class="jd">先来先服务</em>的基础上完成的。CPU调度系统利用队列的LIFO特性[3]。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nd"><img src="../Images/bc41b2c5faa2cf79fe0a07f26656e77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QiX0NiXb7uXEdplR.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">A sample <a class="ae ju" href="https://en.wikipedia.org/wiki/Thread_pool" rel="noopener ugc nofollow" target="_blank">thread pool</a> (green boxes) with a queue (FIFO) of waiting for tasks (blue) and a queue of completed tasks (yellow). Image source: <a class="ae ju" href="https://commons.wikimedia.org" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org</a></figcaption></figure><p id="136b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">栈的常见用例在语言中产生共鸣，例如调用栈，其中栈数据结构存储关于计算机程序的活动子例程的信息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ne"><img src="../Images/a0317cd0e7721f5e07adbe87b92907f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-b5wXeJieY4fFAzt.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Call stack. Source: <a class="ae ju" href="https://commons.wikimedia.org" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org</a></figcaption></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">ADT of Deque container.</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><blockquote class="le"><p id="0a53" class="lf lg hi bd lh li nf ng nh ni nj jc dx translated">转移到更专门化的数据结构，因为它们依赖于以前的数据结构。这就是令人兴奋的地方！</p></blockquote><h2 id="f9d7" class="mh kf hi bd kg mi nk mk kk ml nl mn ko iq nm mp ks iu nn mr kw iy no mt la mu bi translated">树</h2><p id="b799" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">树形数据结构用于表示层级或非线性排序。我们通常用类似于家谱的东西给它们命名。我们将讨论一些常用术语，但请记住，这些术语并不详尽。</p><ul class=""><li id="e08c" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">根-根节点是树结构的起点。它没有父节点。</li><li id="ceb5" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">父节点—父节点是节点的直接前任。</li><li id="bd48" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">子节点—子节点是父节点的后续节点</li><li id="1992" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">叶子-叶子位于树的末端。它没有任何子代。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es np"><img src="../Images/4ab69d926d2ab047fc0bfc30e50c7d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*13EokVYoOaxcBsL-.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Binary Search Tree. From <a class="ae ju" href="https://en.wikipedia.org/wiki/Binary_search_tree#/media/File:Binary_search_tree.svg" rel="noopener ugc nofollow" target="_blank">Wikimedia Commons</a>.</figcaption></figure><p id="9c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树有很多种版本，它们可以用不同的方式实现。值得注意的是，尽管C++ STL没有树容器，但它将集合实现为一个<a class="ae ju" href="https://bityl.co/6Mhm" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>。</p><p id="e9c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉查找树(BST)是一种特殊类型的树，它保持了每个父节点只允许两个子节点的属性，其中左边的子节点总是小于父节点，而右边的子节点总是大于父节点[4]。</p><p id="2638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种在密码学中广泛使用的树被称为Merkle树，其中每个<a class="ae ju" href="https://en.wikipedia.org/wiki/Leaf_node" rel="noopener ugc nofollow" target="_blank">叶节点</a>用数据块的<a class="ae ju" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">密码哈希</a>标记，每个非叶节点用其子节点标签的密码哈希标记[5]。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nd"><img src="../Images/be9a87e8d38ba050b2b7ee4e0552ba46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZJhDk-xR2a74pGKH.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">An example of a binary hash tree (Merkle Tree). <a class="ae ju" href="https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg" rel="noopener ugc nofollow" target="_blank">From Wikimedia Commons.</a></figcaption></figure><p id="dde5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译器和解释器[6]利用了树的层次结构和顺序。解析树是计算机可以理解的语言的形式表示。</p><h2 id="eb57" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">一组</h2><p id="0ded" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">正如我们前面提到的，集合被实现为树。集合对于在给定的列表中保存唯一的元素非常有用，更不用说它们是数学的基础——我们从<a class="ae ju" href="https://plato.stanford.edu/entries/set-theory/" rel="noopener ugc nofollow" target="_blank">集合论</a>中知道这一点。由此可见，高级数学概念是在集合的结构中实现的。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">ADT of Set container.</figcaption></figure><h2 id="a5ce" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">地图</h2><p id="79d6" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">map是一种键值对数据结构，Python等其他语言称之为字典。键是一个索引，您可以用它来调用其相应的值。</p><p id="8d9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机科学家Brian Kernighan认为它们是最有用的数据结构。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nq jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Essentials: Brian Kernighan on Associative Arrays — Computerphile</figcaption></figure><p id="b4ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">地图最显著的应用是在数据库系统中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Map container ADT.</figcaption></figure><h2 id="fb3f" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">图表</h2><p id="1425" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">最后，最广泛的数据结构类别在这里。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nr"><img src="../Images/24b0f816ce0c7b87477929be9613befa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n_atYiBEgAqHOXY6"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Hypergraph of the universe. Source: <a class="ae ju" href="https://bityl.co/6Mnj" rel="noopener ugc nofollow" target="_blank">https://bityl.co/6Mnj</a></figcaption></figure><p id="2cb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图是树的概括。数学和计算机科学的一个领域致力于探索图形的世界。我个人最喜欢的是自动定理证明中的图论实现和物理学中的一些理论基础，如在史蒂夫·沃尔夫勒姆的项目中发现的。</p><p id="df69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图无处不在，我们可以用图来表示几乎所有的问题，因为树是图的特例，链表是树的特例。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="a733" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">外卖食品</h1><p id="b0ee" class="pw-post-body-paragraph if ig hi ih b ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc hb bi translated">既然我们已经讨论了基本的数据结构和它们的用例，我们知道我们可以用各种形式的数据结构来表示问题。我们还讨论了这种数据结构最重要的应用领域。我们为实现这些数据结构设计了抽象模型。探索计算机科学这一领域的一个有趣的方法是尝试自己实现它们。</p><p id="0c87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想和我一起讨论这个话题，我将很快发布一系列关于实现这些数据结构的古怪细节，敬请关注！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h2 id="b635" class="mh kf hi bd kg mi mj mk kk ml mm mn ko iq mo mp ks iu mq mr kw iy ms mt la mu bi translated">参考</h2><ol class=""><li id="b234" class="lt lu hi ih b ii mv im mw iq ns iu nt iy nu jc nv lz ma mb bi translated">戴尔，内尔；亨利·沃克(1996年)。<em class="jd">抽象数据类型:规范、实现和应用</em>。琼斯&amp;巴特利特学习。<a class="ae ju" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">ISBN</a><a class="ae ju" href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-66940000-7" rel="noopener ugc nofollow" target="_blank">978–0–66940000–7</a>。</li><li id="a8dc" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc nv lz ma mb bi translated">斯蒂芬斯河(2019)。基本算法:使用Python和C语言实现计算机算法的实用方法。约翰·威利的儿子们。</li><li id="66a1" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc nv lz ma mb bi translated">GeekforGeeks (2018)。队列数据结构的应用。<a class="ae ju" href="https://www.geeksforgeeks.org/applications-of-queue-data-structure/" rel="noopener ugc nofollow" target="_blank">https://www . geeksforgeeks . org/applications-of-queue-data-structure/</a></li><li id="bbd6" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc nv lz ma mb bi translated">维基百科贡献者。(2021年3月31日)。二叉查找树。在<em class="jd">维基百科，免费百科</em>。检索到2021年4月13日08:24，来自<a class="ae ju" href="https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=1015282423" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/index.php?title = Binary _ search _ tree&amp;oldid = 1015282423</a></li><li id="0b81" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc nv lz ma mb bi translated">乔治·贝克尔。<a class="ae ju" href="http://www.emsec.rub.de/media/crypto/attachments/files/2011/04/becker_1.pdf" rel="noopener ugc nofollow" target="_blank">“Merkle签名方案、Merkle树及其密码分析”</a> (PDF)。波鸿鲁尔大学。第16页。</li><li id="20bb" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc nv lz ma mb bi translated">纽约州斯特伦市(2018年)。制作口译员。<a class="ae ju" href="https://craftinginterpreters." rel="noopener ugc nofollow" target="_blank"><em class="jd">https://crafting interpters。</em> </a> <em class="jd"> com/[2。8.【2020】。</em></li></ol></div></div>    
</body>
</html>
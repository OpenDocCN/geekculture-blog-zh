<html>
<head>
<title>Pitfalls of GoLang interface streaming to JSON (part3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang接口流向JSON的陷阱(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-part3-c37a4caf322b?source=collection_archive---------8-----------------------#2022-08-16">https://medium.com/geekculture/pitfalls-of-golang-interface-streaming-part3-c37a4caf322b?source=collection_archive---------8-----------------------#2022-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1bb2d4a491e1e9d07d2f19601580615f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FFVvpXQAay-MqmoZ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@deonblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Deon Black</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前两节中，我介绍了一种允许从JSON流重建接口类型的方法。为了实现这一点，我在父消息中添加了一个新字段来指示流中结构的类型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="66b9" class="kc kd hi jy b fi ke kf l kg kh">type StructX struct {<br/>   X           string      `json:"x"`<br/>   MyInterface MyInterface `json:"my_interface"`<br/>}</span></pre><p id="1df4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在溪流中变成了</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="27d7" class="kc kd hi jy b fi ke kf l kg kh">var xr struct {<br/>   X               string      `json:"x"`<br/>   MyInterface     MyInterface `json:"my_interface"`<br/>   MyInterfaceType Type        `json:"my_interface_type"`<br/>}</span></pre><p id="5490" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请阅读第一部分和第二部分，看看这个结构来自哪里。</p><div class="ki kj ez fb kk kl"><a href="https://mdcfrancis.medium.com/pitfalls-of-golang-interface-streaming-to-json-part1-1a067c9bb3cd" rel="noopener follow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">GoLang接口流向JSON的陷阱(第1部分)</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">将接口值传输到JSON并返回到Go的陷阱。走查和解决方案。</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">mdcfrancis.medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz io kl"/></div></div></a></div><div class="ki kj ez fb kk kl"><a href="https://mdcfrancis.medium.com/pitfalls-of-golang-interface-streaming-to-json-part2-c1b93a2d7a30" rel="noopener follow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">GoLang接口流向JSON的陷阱(第二部分)</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">在这个简短系列的第一部分中，我介绍了基本的技术。在这一节中，我将谈到反思和问题…</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">mdcfrancis.medium.com</p></div></div><div class="ku l"><div class="la l kw kx ky ku kz io kl"/></div></div></a></div><p id="4914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们看到JSON流中的嵌入式类型时会发生什么？为了保持一致，我将使用第1部分中创建的相同类型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a1c9" class="kc kd hi jy b fi ke kf l kg kh">[ <br/>   {"$type":"StructA", "a":4.56},<br/>   {"$type":"StructA", "a":1.23},<br/>   {"$type":"StructB", "b":"lazy"}<br/>]</span></pre><p id="78bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们有一组异构类型，所有这些类型都实现了我们的MyInterface接口。</p><p id="7956" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们天真地希望下面的代码能够工作，但是仔细想想，我们知道它不会工作，并且会抛出一个错误。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d9fb" class="kc kd hi jy b fi ke kf l kg kh">func main() {<br/>   b := []byte(`[ <br/>      {"$type":"StructA", "a":4.56},<br/>      {"$type":"StructA", "a":1.23},<br/>      {"$type":"StructB", "b":"lazy"}<br/>   ]`)<br/>   data := make([]MyInterface, 0)<br/><br/>   err := json.Unmarshal(b, &amp;data)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>   fmt.Printf("%s", data)<br/>}</span></pre><p id="025d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这和我们之前遇到的错误一样，Go不知道如何解组到一个接口类型中。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2869" class="kc kd hi jy b fi ke kf l kg kh">panic: json: cannot unmarshal object into Go value of type main.MyInterface</span></pre><p id="b8e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，我们可以将一个定制的解组方法绑定到MyInterface的数组上，没那么快。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e5a5" class="kc kd hi jy b fi ke kf l kg kh">func (l []MyInterface) UnmarshalJSON( b []byte) error {<br/>   return nil <br/>}</span></pre><p id="2a04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您尝试编译，您将得到以下错误</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="04c6" class="kc kd hi jy b fi ke kf l kg kh">.\main.go:104:7: invalid receiver type []MyInterface</span></pre><p id="f2e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你深究一下，这是因为[]MyInterface是一个未命名的类型，而Go不允许绑定接收者。这很容易解决，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="45c7" class="kc kd hi jy b fi ke kf l kg kh">type MyList []MyInterface<br/><br/>func (l *MyList) UnmarshalJSON(b []byte) error {<br/>   return nil<br/>}</span></pre><p id="7ba6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以命名类型，Go将很乐意允许我们添加方法。注如第1部分所述，解组函数的接收者应该是一个指针。这允许我们修改类型，如果我们不这样做，我们就不能分配切片的长度。</p><blockquote class="lb lc ld"><p id="cc75" class="iv iw le ix b iy iz ja jb jc jd je jf lf jh ji jj lg jl jm jn lh jp jq jr js hb bi translated">这种类型命名是Go-type系统中最强大的部分之一，在许多情况下可以用来代替复杂的逻辑。在第1部分中，我们使用了一个字符串别名来保证流类型的类型安全。我们还可以将其他方法绑定到该类型，例如，实现stringer接口以提供自定义输出。</p></blockquote><p id="7d4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用json时。解组我们必须提供我们的命名类型，这确保我们将调用我们的自定义方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2dda" class="kc kd hi jy b fi ke kf l kg kh">var data MyList<br/>err := json.Unmarshal(b, &amp;data)</span></pre><p id="921b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的解组方法中，我们现在有一个字节数组来表示JSON对象的完整列表。我们可以开始做一些字符串数学，不建议偷看里面，或者我们可以把它分成一片字节。如果你还记得json。RawMessage，我们以前用它来执行延迟解码，我们可以在这里做同样的事情。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f990" class="kc kd hi jy b fi ke kf l kg kh">func (l *MyList) UnmarshalJSON(b []byte) error {<br/>   var raw []json.RawMessage<br/>   err := json.Unmarshal(b, &amp;raw)<br/>   if err != nil {<br/>      return err<br/>   } <br/>   return nil<br/>}</span></pre><p id="a518" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不必验证JSON，也不必编写解析器来理解每个元素的结尾在哪里。尽管Go将它的解析器应用于JSON，但这也有一个缺点，尽管我不认为我会做得更好，甚至可能更差。那么，现在我们有了这些数据，我们该怎么做呢？嗯，我们知道我们可以使用json。根据自定义类型解组，如果该类型只有一个$type字段，那么我们可以从列表中提取对象的类型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7023" class="kc kd hi jy b fi ke kf l kg kh">type LazyType struct {<br/>   Type Type `json:"$type"`<br/>}</span></pre><p id="f8bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在这里使用一个命名类型，但是我们同样可以内联定义它。现在我们可以遍历二进制文件列表。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c7a5" class="kc kd hi jy b fi ke kf l kg kh">// Allocate an array of MyInterface<br/>*l = make(MyList, len(raw))<br/>var t LazyType<br/>for i, r := range raw {<br/>   // Unmarshal the array first into a type array<br/>   err := json.Unmarshal(r, &amp;t)<br/>   if err != nil {<br/>      return err<br/>   }<br/>}</span></pre><p id="1b8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得看一下注释后的第一行，我们将接收器的大小分配为与我们的字节列表相同的长度。没有指针接收器，我们无法完成这项工作。最后，我们添加在第2部分中使用的逻辑来创建接口的实例。我将在这里添加整个解码器。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8fe0" class="kc kd hi jy b fi ke kf l kg kh">func (l *MyList) UnmarshalJSON(b []byte) error {<br/>   var raw []json.RawMessage<br/>   err := json.Unmarshal(b, &amp;raw)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   // Allocate an array of MyInterface<br/>   *l = make(MyList, len(raw))<br/>   var t LazyType<br/>   for i, r := range raw {<br/>      // Unmarshal the array first into a type array<br/>      err := json.Unmarshal(r, &amp;t)<br/>      if err != nil {<br/>         return err<br/>      }<br/>      // Create an instance of the type<br/>      myInterfaceFunc, ok := lookup[t.Type]<br/>      if !ok {<br/>         return fmt.Errorf("unregistered interface type : %s", t.Type)<br/>      }<br/>      myInterface := myInterfaceFunc.New()<br/>      err = json.Unmarshal(r, myInterface)<br/>      if err != nil {<br/>         return err<br/>      }<br/>      (*l)[i] = myInterface<br/>   }<br/>   return nil<br/>}</span></pre><p id="3d08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们拥有的。我们可以把我们的JSON转换成我们的异构结构列表。如果我运行整个，我得到预期的输出。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b1d0" class="kc kd hi jy b fi ke kf l kg kh">[%!s(*main.StructA=&amp;{4.56}) %!s(*main.StructA=&amp;{1.23}) %!s(*main.StructB=&amp;{lazy})]</span></pre><p id="d138" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有预期有效负载的两个StructA和一个StructB的切片。就个人而言，我发现以这种方式融入内置功能比开始手工开发我自己的JSON解析器更令人满意。最大的缺点是我们需要解析和遍历JSON列表三次才能得到结果。</p><p id="7078" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我知道你对这个解决方案的想法，我很想听听有其他方法来完成这些流任务的人的意见。</p><p id="be7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完全可运行样本</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5516" class="kc kd hi jy b fi ke kf l kg kh">package main<br/><br/>import (<br/>   "encoding/json"<br/>   "fmt"<br/>)<br/><br/>type Type string<br/>type MyInterface interface {<br/>   Type() Type<br/>   New() MyInterface<br/>}<br/><br/>var lookup = make(map[Type]MyInterface)<br/><br/>func Register(iface MyInterface) {<br/>   lookup[iface.Type()] = iface<br/>}<br/><br/>func init() {<br/>   Register(StructA{})<br/>   Register(StructB{})<br/>}<br/><br/>type StructA struct {<br/>   A float64 `json:"a"`<br/>}<br/>type StructB struct {<br/>   B string `json:"b"`<br/>}<br/><br/><br/>func (_ StructA) Type() Type {<br/>   return "StructA"<br/>}<br/><br/>func (_ StructB) Type() Type {<br/>   return "StructB"<br/>}<br/><br/>func (_ StructA) New() MyInterface {<br/>   return &amp;StructA{}<br/>}<br/><br/>func (_ StructB) New() MyInterface {<br/>   return &amp;StructB{}<br/>}<br/><br/>// Check that we have implemented the interface<br/>var _ MyInterface = (*StructA)(nil)<br/>var _ MyInterface = (*StructB)(nil)<br/><br/><br/>type LazyType struct {<br/>   Type Type `json:"$type"`<br/>}<br/><br/>type MyList []MyInterface<br/><br/>func (l *MyList) UnmarshalJSON(b []byte) error {<br/>   var raw []json.RawMessage<br/>   err := json.Unmarshal(b, &amp;raw)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   // Allocate an array of MyInterface<br/>   *l = make(MyList, len(raw))<br/>   var t LazyType<br/>   for i, r := range raw {<br/>      // Unmarshal the array first into a type array<br/>      err := json.Unmarshal(r, &amp;t)<br/>      if err != nil {<br/>         return err<br/>      }<br/>      // Create an instance of the type<br/>      myInterfaceFunc, ok := lookup[t.Type]<br/>      if !ok {<br/>         return fmt.Errorf("unregistered interface type : %s", t.Type)<br/>      }<br/>      myInterface := myInterfaceFunc.New()<br/>      err = json.Unmarshal(r, myInterface)<br/>      if err != nil {<br/>         return err<br/>      }<br/>      (*l)[i] = myInterface<br/>   }<br/>   return nil<br/>}<br/><br/>func main() {<br/>   b := []byte(`[ <br/>      {"$type":"StructA", "a":4.56},<br/>      {"$type":"StructA", "a":1.23},<br/>      {"$type":"StructB", "b":"lazy"}<br/>   ]`)<br/><br/>   var data MyList<br/>   err := json.Unmarshal(b, &amp;data)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>   fmt.Printf("%s", data)<br/>}</span></pre></div></div>    
</body>
</html>
<html>
<head>
<title>When will the Ethereum “Merge” Happen?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊什么时候会“合并”？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/when-will-the-ethereum-merge-happen-58b80babdf16?source=collection_archive---------13-----------------------#2022-09-14">https://medium.com/geekculture/when-will-the-ethereum-merge-happen-58b80babdf16?source=collection_archive---------13-----------------------#2022-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4164" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用几行Julia代码做出你自己的预测</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/83f44d2f7336a19c85b718641111bc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UIegTJ7G8PDp8MG_"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1a30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">到这个时候，你们中的许多人可能已经<a class="ae jn" href="https://cointelegraph.com/news/google-gets-in-on-ethereum-merge-excitement-with-nifty-easter-egg" rel="noopener ugc nofollow" target="_blank">读过</a>或者至少听说过“<a class="ae jn" href="https://www.coinbase.com/ethereum-merge" rel="noopener ugc nofollow" target="_blank">合并</a>”。这被广泛认为是以太坊网络最重要的升级，对整个区块链生态系统具有潜在的深远影响。长话短说，在“合并”成功完成后，以太坊将从目前的工作证明(PoW)转向利益证明(PoS)共识机制。为了了解这一切意味着什么，我强烈建议你阅读以太坊基金会的详细的<a class="ae jn" href="https://ethereum.org/en/upgrades/merge/#what-is-the-merge" rel="noopener ugc nofollow" target="_blank">博客</a>。</p><p id="90b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们怎么知道合并会在什么时候发生？一旦当前以太坊网络达到<strong class="jq hj">终端总难度(TTD)</strong>587500000000000000000，合并将被激活。这是一个巨大的数字！TTD是网络中所有累积难度的度量。它是通过简单地将当前块之前的所有块难度相加来计算的。如果我们知道当前的TTD，预测何时会发生合并只是外推当前数据的问题。当然，现实世界从来没有那么简单。然而，为了本文的目的，我们将做一个简单的线性外推。</p><h1 id="2bca" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="6bd7" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">根据最后10，000个数据块的平均网络难度，预计合并将发生在2022年9月15日05:45 UTC。</p><h1 id="ef73" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">先决条件</h1><p id="5361" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">和往常一样，我们将使用Julia对以太网进行API调用。最好运行我们自己的本地节点，然后通过JSON-RPC接口连接到它。我对比特币做过类似的事情，记录在下面这篇文章里:</p><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/geekculture/connect-to-the-bitcoin-network-using-julia-418c76fed393"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">使用Julia连接到比特币网络</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">一种访问实时区块链数据的简洁方法</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly jh lk"/></div></div></a></div><p id="a56a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，由于时间和资源的短缺(约1 TB空间的快速NVMe SSD)，我决定利用来自<a class="ae jn" href="https://docs.infura.io/infura/getting-started" rel="noopener ugc nofollow" target="_blank"> Infura </a>的商业API服务。设置起来出奇的容易！你所需要做的就是注册，之后你会自动加入“核心”计划。它是免费的，每天仅限100，000次请求。在我看来，这已经很慷慨了，对于我们这个有趣的项目来说已经足够了。</p><h1 id="3ce0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">添加包</h1><p id="9588" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我用Julia 1.8.0在Pluto笔记本(v0.19.9)上写了这段代码，但是你可以随时使用任何你自己喜欢的支持的IDE。Pluto内置的包管理器将处理包及其依赖项的安装。我们将使用以下内容进行API调用、收集数据和创建图:</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="b5fc" class="me kl hi ma b fi mf mg l mh mi">using HTTP, JSON, DataFrames, Statistics, Dates, VegaLite</span></pre><h1 id="b23c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">证明</h1><p id="b385" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在Infura仪表板上，您应该能够找到mainnet URL，它将具有附加到它后面的API键。这就是我们所需要的。</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="a806" class="me kl hi ma b fi mf mg l mh mi">const URL = "<a class="ae jn" href="https://mainnet.infura.io/v3/ce5a9344b4a34df2877d6e38e5ec8ef6" rel="noopener ugc nofollow" target="_blank">https://mainnet.infura.io/v3/</a>YOUR_API_KEY"</span></pre><h1 id="0158" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">创建一个HTTP请求</h1><p id="df30" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们需要创建一个HTTP请求，它遵循一定的结构。请求需要一个带有特定参数的主体。下面的函数给出了一个物体通常是什么样子的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="140d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">“RPC_name”是一个定义方法的输入参数，它反过来控制我们想要获得的信息类型。“params”是附加参数，它也取决于我们使用的方法。上面的URL和正文被组合成一个请求，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="e3ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果一切顺利，请求应该返回一个有效的响应，然后被解析成一个Julia dict。让我们测试我们的API！</p><h1 id="59b6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">测试API</h1><p id="669e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们可以使用“eth _ block number”RPC方法来找出最新的块号。在下面的函数中，我们发出一个HTTP请求来获取该信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="e4ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，根据<a class="ae jn" href="https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber" rel="noopener ugc nofollow" target="_blank">约定</a>，数量(数字、整数)被编码为十六进制，并以“0x”为前缀。这意味着需要过滤块号十六进制字符串(删除前导“0x”)，然后将其解析为一个整数供我们读取。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/8aa627d485257d25bc8d8ed5fb970dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QX_TtC4jU611Mp3bHu4vw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Block number around 20:46, Sep 12, 2022</figcaption></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="6c10" class="kk kl hi bd km kn mt kp kq kr mu kt ku io mv ip kw ir mw is ky iu mx iv la lb bi translated">收集块数据</h1><p id="96cc" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">与前面的例子类似，我们可以使用“eth_getBlockByNumber”方法来获取特定块的数据。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="7eff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，如前所述，块号需要转换成十六进制字符串，前缀为“0x”。生成的字典如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/ff15f149c5b8579acc34adda54c40782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_VYKfnG1AFsmXphRQxX7A.png"/></div></div></figure><p id="0424" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以验证所有十六进制编码的条目确实以“0x”为前缀。我们对“总难度”、“难度”和“时间戳”特别感兴趣。这些名字是不言自明的，但是要记住，这个程序块的TTD等价于总难度。</p><p id="d096" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们现在将收集给定块数的历史数据块数据。结果可以存储在数据帧中，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="2e1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，时间戳是Unix纪元，所以应该转换成Julia的DateTime对象。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/20f182fd0ee7ae1b4dc12e84b85d6b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9A2Ojd1Wb571LTmvpe5Jg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Sample DataFrame with block difficulty and timestamps</figcaption></figure><p id="722c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们知道时间戳，所以我们也可以计算连续块之间的间隔。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h1 id="cf53" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">闭塞时间分布</h1><p id="c202" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">以太坊网络中的平均块生成时间约为14秒。让我们看看最后2000个块的分布情况。我们将使用优秀的<a class="ae jn" href="https://www.queryverse.org/VegaLite.jl/stable/gettingstarted/tutorial/" rel="noopener ugc nofollow" target="_blank"> VegaLite.jl </a>软件包绘制数据。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/43a9fa8c76dd5e71182da3333d42cf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oB34ewP9kZmwe3UTeO2wkg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Checked around 21:14, Sep 12, 2022</figcaption></figure><p id="fb5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">平均阻塞时间确实是~ 14 s，这对我们文章的下一部分至关重要。</p><h1 id="98d6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">到达极限难度的时间(TTD)</h1><p id="b675" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">到目前为止，我们已经了解了如何收集块难度数据和计算平均块生成时间。对于当前块，我们可以查询“总难度”，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="14d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">目标TTD也为我们所知。更多信息见<a class="ae jn" href="https://ethmerge.com/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/6746e44072a9027f1e037042f285d566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqnrkzAF73-dr2YWbcPOxA.png"/></div></div></figure><p id="6611" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们现在需要做的就是估计到达<strong class="jq hj">目标_TTD </strong>所需的时间。我们通过首先估计到达TTD所需的块数来得出这个结论。简单来说，那就是:</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="88d1" class="me kl hi ma b fi mf mg l mh mi">blocks_to_go = (target_TTD - current_TTD)/avg_block_diff</span></pre><p id="3d47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其中<strong class="jq hj"> avg_block_diff </strong>可以通过收集历史难度数据来计算，如前所示。因此，到达目标TTD的时间是:</p><pre class="iy iz ja jb fd lz ma mb mc aw md bi"><span id="f8ee" class="me kl hi ma b fi mf mg l mh mi">time_to_go = blocks_to_go * avg_block_time</span></pre><p id="795d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其中<strong class="jq hj"> avg_block_time </strong>也可以使用历史样本确定(通常约14秒)。所有这些都集中在以下函数中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="2c91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用过去10，000个街区的历史数据，我们得到了以下结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/087c378db6c7113c4e0ec7d979bd851e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15va6WvRKipIlnI8hAF84w.png"/></div></div></figure><p id="80c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">时间以UTC表示。我们的合并块估计值(15，537，292)与另一个值(15，537，351)非常接近，详细信息可以在<a class="ae jn" href="https://www.ethernodes.org/merge" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="12c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们做了一个简单的线性外推来确定合并将在何时发生。实际上，准确的时间会有所不同，因为封锁的难度会根据网络哈希表进行调整。不过，我希望你今天学到了一些有趣的东西。感谢您的宝贵时间！在LinkedIn上与我联系，或者访问我的Web 3.0网站。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="263a" class="kk kl hi bd km kn mt kp kq kr mu kt ku io mv ip kw ir mw is ky iu mx iv la lb bi translated">参考</h1><ol class=""><li id="6d55" class="nd ne hi jq b jr lc ju ld jx nf kb ng kf nh kj ni nj nk nl bi translated"><a class="ae jn" href="https://ethresear.ch/t/predicting-ttd-on-ethereum/12742/1" rel="noopener ugc nofollow" target="_blank">https://ethresear.ch/t/predicting-ttd-on-ethereum/12742/1</a></li><li id="0a98" class="nd ne hi jq b jr nm ju nn jx no kb np kf nq kj ni nj nk nl bi translated"><a class="ae jn" href="https://ethmerge.com/" rel="noopener ugc nofollow" target="_blank">https://ethmerge.com/</a></li><li id="4229" class="nd ne hi jq b jr nm ju nn jx no kb np kf nq kj ni nj nk nl bi translated"><a class="ae jn" href="https://ethereum.org/en/upgrades/merge/#what-is-the-merge" rel="noopener ugc nofollow" target="_blank">https://ethereum.org/en/upgrades/merge/#what-is-the-merge</a></li></ol></div></div>    
</body>
</html>
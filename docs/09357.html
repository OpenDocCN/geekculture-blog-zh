<html>
<head>
<title>Implementing Webpack’s Module federation in a Vue 2 application.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue 2应用程序中实现Webpack的模块联合。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-webpacks-module-federation-in-a-vue-2-application-38997c696094?source=collection_archive---------1-----------------------#2021-12-07">https://medium.com/geekculture/implementing-webpacks-module-federation-in-a-vue-2-application-38997c696094?source=collection_archive---------1-----------------------#2021-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/54849d5251a4116e6cbfe952f7c75ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPa0YECwJpuERsyH2k-B8g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@mangofantasy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tim Johnson</a> on <a class="ae iu" href="https://unsplash.com/s/photos/coupled-components?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="365a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">微前端:</h1><p id="a42b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">微前端是一种前端架构，其中相同产品/应用的模块彼此独立地构建。</p><p id="4554" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这种架构已经被证明是真正可扩展的，所以我决定在我最近的项目中使用这种架构。开发几周后，我有了一个vue2应用程序和一个Gridsome应用程序。由于这两个应用程序使用了相同的设计系统，我复制/粘贴了两个应用程序共有的组件，这是不可维护的，复制/粘贴组件违背了<a class="ae iu" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则。我决定寻找一个更具可扩展性的解决方案，这让我选择了Webpack的模块联盟。</a></p><p id="6461" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于这个演示，我们将从头到尾设置Webpack的模块联合。所以，系好安全带😃。</p><h2 id="5238" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">要求</h2><ol class=""><li id="0b6e" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">两个已经建立了vue2项目:我们不会在这篇博文中讨论这个。如果您在设置vue项目时遇到问题，请访问<a class="ae iu" href="https://cli.vuejs.org/guide/creating-a-project.html#vue-create" rel="noopener ugc nofollow" target="_blank"> vue文档</a>。</li></ol><h2 id="5d32" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">装置</h2><p id="480b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了正确配置Webpack，我们需要在项目中添加一些开发依赖项。附注:这两个项目都应该完成这些步骤。要添加开发依赖项，我们将运行以下命令:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="2c04" class="kw iw hi ly b fi mc md l me mf">yarn add webpack webpack-cli webpack-dev-server vue-loader url-loader sass-loader mini-css-extract-plugin html-webpack-plugin dart-sass css-loader -D</span></pre><p id="3c47" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">完成后，我们需要向package.json添加一个启动脚本。这个脚本的目标是在启动服务器时使用Webpack-CLI，而不是vue-cli。我们的package.json的脚本部分现在应该包含一个启动脚本:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="e9a9" class="kw iw hi ly b fi mc md l me mf">"scripts": {</span><span id="3c93" class="kw iw hi ly b fi mg md l me mf">"serve": "vue-cli-service serve",</span><span id="7884" class="kw iw hi ly b fi mg md l me mf">"build": "vue-cli-service build",</span><span id="cae2" class="kw iw hi ly b fi mg md l me mf">"start": "webpack-cli serve",</span><span id="13d1" class="kw iw hi ly b fi mg md l me mf">"lint": "vue-cli-service lint"</span><span id="54f5" class="kw iw hi ly b fi mg md l me mf">},</span></pre><p id="08d6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果您运行<code class="du mh mi mj ly b">yarn start</code>命令，您会注意到有一个错误…不要烦恼…然而😏。</p><h2 id="034e" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">现在让我们开始…</h2><p id="d506" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这篇博文中，我们有两个项目。Micro-main是需要共享组件的项目，web-common是包含共享组件的项目。</p><p id="1880" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这两个项目中，我们将在根目录中创建一个<code class="du mh mi mj ly b">webpack.config.js</code>文件:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/1a36be7d05c77c54e9f8130f05d51a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*OF-SkXPVkF_BuZ4Z7FcrGA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">The location of the webpack.config.js file in the project.</figcaption></figure><p id="f2e1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在我们已经创建了我们的<code class="du mh mi mj ly b">webpack.config.js</code>文件，我们将用以下内容填充它:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="7802" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">两个应用程序的<code class="du mh mi mj ly b">webpack.config.js</code>文件应该包含下面的代码<strong class="jv hj">，但是记住给两个项目不同的端口变量</strong>。现在，如果您运行<code class="du mh mi mj ly b">yarn start</code>命令，您应该有一个满意的服务器😄。</p><p id="55c6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在让我们解释一下这里所写的重要部分。</p><ol class=""><li id="d29b" class="lk ll hi jv b jw kr ka ks ke mn ki mo km mp kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/concepts/entry-points/" rel="noopener ugc nofollow" target="_blank">入口点</a>:入口点是Webpack用作起点的文件。默认情况下，Webpack使用<code class="du mh mi mj ly b">src/index.js</code>作为入口点。但是为了符合Vue方法，我们将入口点设置为<code class="du mh mi mj ly b">src/main.ts</code>。</li><li id="f4ac" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/concepts/output/" rel="noopener ugc nofollow" target="_blank"> Output </a>:该输出是我们指定在构建之后应该将我们的捆绑应用程序放在哪里的地方。默认情况下，Vue应用程序内置在dist目录中，因此将Webpack构建放在dist文件夹中是正确的。</li><li id="884f" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/configuration/resolve/#resolveextensions" rel="noopener ugc nofollow" target="_blank">解析</a>:解析模块解析方式的变化。它还有助于设置别名。在我们的用例中，我们通过在resolve.alias中添加<code class="du mh mi mj ly b">@assets</code>属性来添加资产文件夹的快捷方式</li><li id="4c5f" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/concepts/loaders/" rel="noopener ugc nofollow" target="_blank">规则</a>:默认情况下，Webpack只理解Javascript和JSON文件。这就是装载机的用武之地。加载器使Webpack能够理解其他文件，如typescript、Vue、CSS、e.t.c .在我们的例子中，我们已经为Vue、typescript、CSS和SASS添加了加载器。</li><li id="02e1" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/configuration/plugins/" rel="noopener ugc nofollow" target="_blank">插件</a>:插件用于以多种方式定制Webpack构建过程。</li><li id="c90f" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><a class="ae iu" href="https://webpack.js.org/configuration/dev-server/#devserver" rel="noopener ugc nofollow" target="_blank"> devServer </a>:开发应用程序所需的配置就放在这里。</li></ol><p id="63ea" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">填充您的<code class="du mh mi mj ly b">webpack.config.js</code>后，导航至<code class="du mh mi mj ly b">http://localhost:${port}</code>。你会注意到这是一个没有应用程序徽标的空白页面，服务器可能正在哭泣😢。为了解决这个问题，替换<code class="du mh mi mj ly b">public/index.html</code>中的动态变量，例如:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="ba4d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在此之后，如果您仍然有一个空白页，请检查控制台，您可能会看到:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/13ee301a492bda2c098d67d95fcda1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dj7D5C2eYQwQi-KKnygH4w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">An error resulting from using environment variables in the router.</figcaption></figure><p id="18fa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了解决这个问题，我们将添加一个新插件:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="1884" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这之后，你现在可以导航到你的网站，看到一个快乐的网站👌。</p><h2 id="a6bf" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">模块联盟</h2><p id="6196" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们完成了Webpack的设置，现在我们有了满意的服务器和一个正常工作的网站。现在，是我们实现模块联邦的时候了。</p><p id="e893" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">模块联盟的所有酱都包含在<code class="du mh mi mj ly b">ModuleFederationPlugin</code>中。在这部分配置中，两个代码库具有不同的配置。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="iq ir et er es is it bd b be z dx">The end configuration of the web_common project.</figcaption></figure><h2 id="280f" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">需要注意的几件事:</h2><ol class=""><li id="3c48" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">ModuleFederationPlugin是从<code class="du mh mi mj ly b">require("webpack").container</code>而不是从<code class="du mh mi mj ly b">require("webpack")</code>导入的。</li><li id="ad7d" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated">ModuleFederationPlugin的<code class="du mh mi mj ly b">exposes</code>对象负责共享项目中的代码。另外，<code class="du mh mi mj ly b">exposes</code>对象的键必须是<code class="du mh mi mj ly b">./[KEY_NAME]</code>的格式。</li><li id="0b8e" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated">文件名可以是任何名称。但是<code class="du mh mi mj ly b">remoteEntry</code>或者<code class="du mh mi mj ly b">web_commonRemoteEntry</code>是一个很棒的名字。</li><li id="3e12" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated">名称也可以是任何名称，但我会给它项目的名称。</li></ol><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="iq ir et er es is it bd b be z dx">The End configuration of the main project.</figcaption></figure><h2 id="fc32" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">需要注意的几件事:</h2><ol class=""><li id="3874" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated"><code class="du mh mi mj ly b">remotes</code>是我们添加项目远程的地方，我们从那里接收共享代码。</li><li id="2bd7" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated"><code class="du mh mi mj ly b">web_common</code>是我们从中接收共享代码的项目的名称。</li><li id="8c8b" class="lk ll hi jv b jw mq ka mr ke ms ki mt km mu kq lp lq lr ls bi translated">项目共享代码的远程必须是格式<code class="du mh mi mj ly b">[PROJECT_NAME]@[PROJECT_URL]/[PROJECT_filename]</code>在我们的例子中，文件名是remoteEntry.js</li></ol><p id="dae9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了测试实现，我们将全局导入组件。即:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Global importation of the HelloWorld component</figcaption></figure><p id="a4b6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果您使用typescript，您可能需要将<code class="du mh mi mj ly b">web_common</code>声明为一个模块。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="7cc5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在，服务器应该很高兴了。</p><p id="30da" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在，HelloWorld组件可以在主项目中使用了。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="bfa0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这是结果:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/ab57e3c7507e1fb0ef440a80a443e314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlsdYjQSQkgQzQVYEU0fMw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The HelloWorld component was imported from the web_common project to the main project.</figcaption></figure><h2 id="0143" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">还有一个问题…</h2><p id="5454" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">万岁！！我们已经完成了模块联合…但是您可能已经注意到导航到另一个路径并重新加载页面会导致一个404错误，这会影响开发人员的体验😿。</p><p id="74a5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">修复方法是将<a class="ae iu" href="https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback" rel="noopener ugc nofollow" target="_blank"> historyApiFallback </a>设置为true。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="cde1" class="kw iw hi ly b fi mc md l me mf">// webpack.config.js<br/>module.exports = {<br/>  //...<br/>  devServer: {<br/>    historyApiFallback: true,<br/>  },<br/>};</span></pre><h2 id="22ad" class="kw iw hi bd ix kx ky kz jb la lb lc jf ke ld le jj ki lf lg jn km lh li jr lj bi translated">结论</h2><p id="ec99" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这篇博文中，我给出了如何设置Webpack以及如何正确设置模块联合插件的一步一步的清晰步骤。如果这篇文章对您的用例不尽如人意，请随时联系我。</p></div></div>    
</body>
</html>
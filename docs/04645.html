<html>
<head>
<title>How I Built a Self Driving Model Car</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何建造一辆自动驾驶模型车的</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-built-a-self-driving-model-car-8e70d024f117?source=collection_archive---------55-----------------------#2021-06-30">https://medium.com/geekculture/how-i-built-a-self-driving-model-car-8e70d024f117?source=collection_archive---------55-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a699" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第2部分—软件和学习第一个模型</h2></div><p id="3303" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个系列以前的文章可以在这里找到。</p><h1 id="f057" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">安装软件</h1><p id="98a6" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我喜欢使用ssh登录Jetson，然后使用安装了tmux _ resurrect的byobu来允许我在putty控制台中运行多个窗口，并从我上次关闭汽车之前停止的地方进行恢复。</p><h2 id="e9e2" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">虚拟</h2><p id="cc4f" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在Jetson上，首先安装VirtualEnv并创建一个DonkeyCar环境。激活这个，在这个环境里做所有的事情。我在这里使用<a class="ae jt" href="https://virtualenvwrapper.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">的virtualenvwrapper】。</a></p><h2 id="3581" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">东奇卡</h2><p id="77dc" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">要安装的第一个也是主要的软件来自<a class="ae jt" href="https://github.com/autorope/donkeycar" rel="noopener ugc nofollow" target="_blank"> DonkeyCar </a>。对于Nano，根据您的JetPack版本，配置会有小的变化。DonkeyCar发行版附带了一个为JetPack 4.4安装的脚本，但我安装的是4.5。转到install/nano文件夹，创建一个新的install-jp45.sh并更改相关行:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="84eb" class="kr jv hi lk b fi lo lp l lq lr">sudo -H pip3 install --pre --extra-index-url <a class="ae jt" href="https://developer.download.nvidia.com/compute/redist/jp/v45" rel="noopener ugc nofollow" target="_blank">https://developer.download.nvidia.com/compute/redist/jp/v45</a> tensorflow==2.2.0+nv20.6</span></pre><p id="a9b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后可以运行pip install -e .[nano]</p><h2 id="47ff" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">校准</h2><p id="d8f2" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">DonkeyCar带有一个校准工具，允许您确定汽车的最大、最小和中心或零位置。首先，值得检查PCA9865总线是否配置正确。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d5ff" class="kr jv hi lk b fi lo lp l lq lr">sudo i2cdetect -r -y 1</span></pre><figure class="lf lg lh li fd lt er es paragraph-image"><div class="er es ls"><img src="../Images/860fb11ac3dc7186169f1cda9b78db15.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*reHOGyb85H91SV8YB22E5w.png"/></div></figure><p id="32fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它会输出类似这样的内容。据说PCA9865可以通过0x40和0x70寻址。第一种是默认设置，应该已经配置好了。在myconfig.py中查找以下内容，它表示我们在0x40上使用1号总线。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="519f" class="kr jv hi lk b fi lo lp l lq lr">PCA9685_I2C_ADDR = 0x40<br/>PCA9685_I2C_BUSNUM = 1</span></pre><p id="d240" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，运行校准工具，将数值手动输入控制台，观察转向和油门(确保汽车离开地面！).通过迭代和逐渐增加/减少值，您可以找到阈值的位置。这些进入我车里的myconfig.py。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="8495" class="kr jv hi lk b fi lo lp l lq lr">donkey calibrate --channel 0 --bus=1</span></pre><p id="d992" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这例如可能导致</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="885a" class="kr jv hi lk b fi lo lp l lq lr">STEERING_CHANNEL = 0<br/>STEERING_LEFT_PWM = 480<br/>STEERING_RIGHT_PWM = 280</span><span id="8ff4" class="kr jv hi lk b fi lw lp l lq lr">THROTTLE_CHANNEL = 1<br/>THROTTLE_FORWARD_PWM = 450<br/>THROTTLE_STOPPED_PWM = 370<br/>THROTTLE_REVERSE_PWM = 330</span></pre><h2 id="1acf" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">操纵杆</h2><p id="1936" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我有一个现有的蒸汽控制器，想用它来让我前进。不幸的是，这不是DonkeyCar的标准配置之一，所以我不得不使用DonkeyCar自带的自定义游戏杆工具创建自己的配置。然而，Steam控制器需要PyGameController和其他一些小部件才能工作。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d1ff" class="kr jv hi lk b fi lo lp l lq lr">sudo apt-get install python-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev libsdl1.2-dev libsmpeg-dev python-numpy subversion libportmidi-dev ffmpeg libswscale-dev libavformat-dev libavcodec-dev libfreetype6-dev<br/>sudo apt-get install libsdl2-dev<br/>sudo apt-get install python-pygame</span></pre><p id="adeb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后从<a class="ae jt" href="https://github.com/ynsta/steamcontroller" rel="noopener ugc nofollow" target="_blank">这里</a>获取steamcontroller代码。我克隆了它并运行了设置，然后在/etc/udev/rules.d中添加了steamcontroller规则。现在我们可以运行:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9ef1" class="kr jv hi lk b fi lo lp l lq lr">sc-xbox.py start</span></pre><p id="6c04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将看到js0出现在/dev/input中。这是DonkeyCar查找控制器的默认位置。</p><p id="8d2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在运行操纵杆向导:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="fb79" class="kr jv hi lk b fi lo lp l lq lr">donkey createjs</span></pre><p id="8e8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将写出一个python文件，但该类被配置为扩展JoystickController。我们需要编辑它，以便它扩展PyGameController:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="0460" class="kr jv hi lk b fi lo lp l lq lr">from donkeycar.parts.controller import PyGameJoystick, JoystickController<br/>class MyJoystick(PyGameJoystick):</span></pre><p id="557b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要让DonkeyCar使用CustomController，这意味着编辑myconfig，以便创建CustomController:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="cbe8" class="kr jv hi lk b fi lo lp l lq lr"># add controller<br/>    if cfg.USE_JOYSTICK_AS_DEFAULT:<br/>        from my_joystick import MyJoystickController<br/>        ctr = MyJoystickController(throttle_dir=cfg.JOYSTICK_THROTTLE_DIR,<br/>            throttle_scale=cfg.JOYSTICK_MAX_THROTTLE,<br/>            steering_scale=cfg.JOYSTICK_STEERING_SCALE,<br/>            auto_record_on_throttle=cfg.AUTO_RECORD_ON_THROTTLE)<br/>        ctr.set_deadzone(cfg.JOYSTICK_DEADZONE)<br/>        print('created myjoystick controller')<br/>        print(ctr)</span></pre><p id="6731" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并在myconfig.py中将控制器类型设置为custom:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="bdc9" class="kr jv hi lk b fi lo lp l lq lr">CONTROLLER_TYPE=custom</span></pre><p id="d1a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我有这个控制器的问题，虽然这是很难控制汽车容易，有时有很多滞后或控制没有反应，蓝牙范围不是很大。我还尝试了一个“标准”控制器，罗技F710，但是范围更差(最多几米)。</p><p id="295f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些控制器对第一辆室内原型车来说还可以，尽管我不得不跟着车走，所以我不会超出范围，但它们对下一个版本来说不够好。</p><h2 id="5774" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">OpenCV</h2><p id="f2c8" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我想做一些图像预处理，所以我安装了openCV，这意味着建立它。这需要第一篇文章中的额外交换空间，然后我使用了<a class="ae jt" href="https://qengineering.eu/install-opencv-4.5-on-jetson-nano.html" rel="noopener ugc nofollow" target="_blank">这个</a>。注意这构建了一个支持gpu的OpenCV版本，尽管你必须修改你的代码来使用Cuda。它也可以在cpu上工作，不需要改变，所以这是我开始做的。</p><h1 id="4d81" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">学习第一个模型</h1><p id="9e6d" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在开着车在里面转了一圈，收集了大约8000张照片后，我准备学习一个模型。我有一台Nvidia 1080Ti，所以我决定在这台机器上学习模型，然后将模型复制到车上。</p><p id="889f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我从480x640图像开始，我想使用来自<a class="ae jt" href="https://developer.nvidia.com/blog/deep-learning-self-driving-cars/" rel="noopener ugc nofollow" target="_blank">的Nvidia架构。当然，这意味着在DonkeyCar keras.py文件中添加一个定制的神经架构，如果传入的模型类型是nvidia，则更新utils.py以选择该架构。</a></p><p id="f478" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在keras.py中:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="f3c7" class="kr jv hi lk b fi lo lp l lq lr">class NvidiaModel(KerasPilot):<br/>    def __init__(self, num_outputs=2, input_shape=(240, 320, 3), *args, **kwargs):<br/>        super(NvidiaModel, self).__init__(*args, **kwargs)<br/>        self.model = customArchitecture(num_outputs, input_shape)<br/>...</span></pre><p id="4f29" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在utils.py:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a671" class="kr jv hi lk b fi lo lp l lq lr">elif model_type == "nvidia":<br/>        from donkeycar.parts.keras import NvidiaModel<br/>        kl = NvidiaModel(input_shape=(480,640,3))</span></pre><p id="8db5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和列车命令:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c0f3" class="kr jv hi lk b fi lo lp l lq lr">python train.py --model models/my_nvidia.h5 --type nvidia --tubs data</span></pre><p id="c250" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这导致了以下损失曲线:</p><figure class="lf lg lh li fd lt er es paragraph-image"><div class="er es lx"><img src="../Images/6ff08bf904f8266271c8afdd1187f145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*E3Lq0qr3Ytfv7ewGdPhnQw.png"/></div></figure><p id="7926" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是相对较高的损失。无论如何，我把模型下载到车上，并进行测试。这辆车偶尔看起来能认出路边，但大多数时候它只是驶过了路边。</p><figure class="lf lg lh li fd lt"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="a767" class="kr jv hi bd jw ks kt ku ka kv kw kx ke jg ky kz kg jk la lb ki jo lc ld kk le bi translated">下一步是什么？</h2><p id="5e37" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在下一篇文章中，我将研究如何使用OpenCV进行图像预处理来帮助训练，以及在推理管道中查找bug。</p></div></div>    
</body>
</html>
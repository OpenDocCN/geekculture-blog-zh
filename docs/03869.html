<html>
<head>
<title>A handwritten introduction to analysis of algorithms (1/2): asymptotic notations and examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法分析的手写介绍(1/2):渐近符号和例子</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-handwritten-introduction-to-analysis-of-algorithms-1-2-asymptotic-notations-and-examples-57324f6becb5?source=collection_archive---------43-----------------------#2021-06-16">https://medium.com/geekculture/a-handwritten-introduction-to-analysis-of-algorithms-1-2-asymptotic-notations-and-examples-57324f6becb5?source=collection_archive---------43-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是关于渐近符号以及我们如何使用它们来估计算法的运行时复杂度。我们将从介绍这些符号背后的数学概念开始。本文的其余部分将给出许多分析一些著名算法的例子，以涵盖广泛的技术</p><p id="501d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将用用Go和F#编写的代码来说明本文，这取决于哪种范式更适合每种函数。我会尽量让程序不那么地道，所以没有这些语言的经验不应该成为理解这篇文章的问题。</p><p id="2ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">先决条件:</strong></p><p id="2bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">真实序列:</em>界限，极限；</p><p id="3a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">级数:</em>我们举一个例子，需要级数收敛的基础知识，但这不是理解文章其余部分所必需的；</p><p id="a54d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">编程:</em>理解以过程风格(对于大多数例子)或函数风格(对于一个例子)编写的简单程序。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="ef54" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">内容</h1><p id="e0b6" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这个系列有两部分。这是第一个，包含以下部分:</p><ol class=""><li id="95e3" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">大O，Omega和Theta:动机，形式定义，性质；</li><li id="1953" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">具有多项式时间复杂性的算法；</li><li id="ba1a" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">具有阶乘时间复杂性的算法；</li><li id="9780" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">多变量复杂性；</li><li id="80ec" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">指数时间复杂度算法。</li></ol><p id="b153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二部分着重分析分治算法和缓冲分析。</p><h1 id="e46c" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">大O，ω和θ:动机，定义，性质</h1><h2 id="83cf" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">动机和定义</h2><p id="a240" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><em class="jd">渐近表示法是一种估算算法在输入任意大的输入时执行的操作数量的方法，不考虑依赖于编程语言或机器的方面。</em></p><p id="9344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这句话中，<em class="jd">输入大小</em>的概念取决于我们使用的数据结构。它可以指存储在一个数组或一个列表中的元素的数量，一个图中节点和边的数量，或者一个数的位数。</p><p id="0a7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用映射t来表示算法的运行时复杂性:ℕ⟶ℕ；⟼。在接下来的段落中，字母T、U、V和W指的是这些功能。</p><blockquote class="lv lw lx"><p id="d4b4" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">定义(大O): <em class="hi">我们说T = </em> 𝑂 <em class="hi"> (U)当存在</em> A <em class="hi">，</em> B <em class="hi"> ∈ ℕ使得T ≤ </em> B <em class="hi"> U对于所有大于</em> A <em class="hi">的自然数。</em></p></blockquote><p id="3327" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个定义的英文解释是:当T的增长速度不比U快很多时，T就是U的一个大O</p><p id="0553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如1 = O(log <em class="jd"> n </em>)和log <em class="jd"> n </em> = O( <em class="jd"> n </em>)(对于所有<em class="jd">a</em>T34】0)。</p><p id="db8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个有用的符号是大ω:</p><blockquote class="lv lw lx"><p id="0ff4" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">定义(大ω，knuth):<em class="hi">t =ω(u)当存在</em> A <em class="hi">，</em> B <em class="hi"> ∈ ℕ*使得T ≥ </em> B <em class="hi"> U对于所有大于</em> A的自然数</p></blockquote><p id="ecc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个重要的性质我们会经常用作替代定义:<em class="jd"> T是U的大O等价于U是T的大ω</em>。</p><p id="8c21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">证明:假设T = O(U): T ≤ <em class="jd"> B </em> U对于某些<em class="jd"> B </em> ∈ <em class="jd">、</em>和T ≤ ( <em class="jd"> B </em> +1) U也是如此。由于<em class="jd"> B </em> + 1 ≠ 0，我们可以设置<em class="jd"> C </em> := 1/( <em class="jd"> B </em> + 1)。所以两边乘以<em class="jd"> C </em>得到U ≥ <em class="jd"> C </em> T:我们证明了U =ω(T)。反过来，假设U =ω(T)。然后存在<em class="jd"> C </em> ∈ <em class="jd"> </em> ℕ*使得U ≥ <em class="jd"> C </em> T .由于<em class="jd"> C </em> ≠ 0，我们设置<em class="jd"> B </em> = 1/ <em class="jd"> C </em>两边乘以<em class="jd"> B </em> : T ≤ <em class="jd"> B </em> U所以T = O(U)。</p><p id="261d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像大O一样，这个定义的英文对等词是<em class="jd"> T是U的一个大ω，当T的增长不比U慢很多的时候。</em></p><p id="bc2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，大θ是最重要的符号。这是我们在分析算法时经常使用的方法，因为它给出了算法复杂性的最准确的概念。</p><blockquote class="lv lw lx"><p id="ee19" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">当T = O(U)，T =ω(U)时，T =θ(U)。</em></p></blockquote><p id="55f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当T和U以大致相同的速度增长时，我们可以说T是U的大θ<em class="jd">。</em></p><p id="6990" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意你有时候会看到∈而不是等号写某函数是另一个的大O/大ω/大θ:T∈O(U)。虽然等号更常见，但它可能会引起误解，因为我们可以从等式中得到一些渐近符号所不能满足的性质。特别是T <em class="jd"> = </em> O(V)和U <em class="jd"> = </em> O(V)并不暗示T<em class="jd">=</em>U<em class="jd">；</em>T<em class="jd">+</em>O(V)<em class="jd">=</em>U<em class="jd">+</em>O(V)也没有。</p><h2 id="f737" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">性能</h2><p id="5872" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在这一部分，我们将证明渐近运算的一些性质，这些性质在实践中是很有用的。</p><ul class=""><li id="c8da" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc mb ku kv kw bi translated">如果<em class="jd"> T是U </em>的大θ，那么<em class="jd"> aT对于任意正实数<em class="jd"> a </em>都是U </em>的大θ。这是我们想要忽略依赖于语言和机器的计算元素的事实的正式转录:如果你想要计算一个程序的运行时复杂性，该程序计算一个具有n个元素的数组的所有元素的和，你不重视通过元素的索引检索元素的值和修改存储和的变量所需的内部步骤；重要的是它执行一些基本操作<em class="jd"> n </em>次。</li></ul><p id="4ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个性质的一个重要结果是，我们可以写出某个序列是对数的大θ，而不考虑对数的底。</p><ul class=""><li id="58a4" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc mb ku kv kw bi translated">如果比率U/V向一个有限的非零极限l收敛，那么V/U向1/l收敛。因此，U/V和V/U都是有界的:U = O(V)和V = O(U)所以U =θ(V)。</li><li id="33f2" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc mb ku kv kw bi translated">如果t是一个次数为<em class="jd"> d </em>的多项式序列，那么t(<em class="jd">n</em>)=θ(<em class="jd">nᵈ</em>):低次项可以忽略不计。这个性质来自上面的一个，因为比率T( <em class="jd"> n </em> )/ <em class="jd"> nᵈ </em>趋向于T( <em class="jd"> n </em>)中的<em class="jd"> nᵈ </em>的系数。</li><li id="eca1" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc mb ku kv kw bi translated">如果T =θ(U)且V =θ(W ),则TV =θ(UW)</li></ul><p id="19b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">证明:(i) </em>:假设T = O(U)，V = O(W)。那么就存在<em class="jd"> A </em>，<em class="jd"> B </em>这样T ≤ <em class="jd"> B </em> U和V ≤ <em class="jd"> C </em> W .既然大家都是非负的，那么TV ≤ ( <em class="jd"> BC </em> ) UW: TV = O(UW)。由于T，V，U和W是任意的，由<em class="jd"> (i) </em> , (U = O(T)和W = O(V))隐含着UW = O(TV)。因此，如果T =θ(U)，V =θ(W)，则TV =θ(UW)。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="466e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很可能你经常遇到大O符号，即使大θ更合适。这是对符号的一种滥用。例如，如果我们只使用大O符号，线性复杂度将意味着阶乘复杂度。</p><p id="eb49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进入算法分析的例子之前，最后一个注意事项:渐近分析是一个有用的工具，但是你必须记住，两个算法具有相同的渐近复杂度并不意味着在某些情况下其中一个不能比另一个更有效。有时，乘法常数和低阶项确实很重要。例如，当输入足够小时，内置排序函数通常使用二次复杂度的算法，因为它们可能比线性复杂度的算法更有效(θ(<em class="jd">n</em>log<em class="jd">n</em>))，即使<em class="jd"> n </em> log <em class="jd"> n </em>比<em class="jd"> n </em>增长得更慢。另一个例子:快速排序具有最坏情况的二次复杂度，而合并排序具有线性复杂度，但是快速排序通常被认为比合并排序更有效(部分是因为最坏情况很少发生，并且可以在快速排序中避免)。</p><h1 id="de73" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">多项式复杂性</h1><p id="5fb3" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">多项式复杂度的算法可能是最容易分析的。在这一部分中，我们将使用我们以前看到的性质来分析几个具有多项式复杂性的算法的例子。</p><h2 id="ef8e" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">数组的最大值</h2><p id="303d" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">下面实现的函数<em class="jd"> max </em>是我们能想到的最简单的算法之一。</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="ca99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有一个for循环，执行子程序(第8行到第10行)n次<em class="jd"/>。子程序的执行不依赖于任何参数:它有一个恒定的运行时间。因此，如果<em class="jd"> C </em>表示子程序内部执行的步数，<em class="jd"> A </em>表示循环前后执行的步数，<code class="du mj mk ml mm b">max</code>具有复杂度T(<em class="jd">n</em>)<em class="jd">= Cn+A =</em>θ(<em class="jd">n</em>)。</p><h2 id="c095" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">选择排序</h2><p id="43a9" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">现在让我们来看一个稍微复杂一点的例子:<em class="jd">选择排序。</em>我们将使用下面的实现:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于数组中的每个元素，<em class="jd"> array </em> [ <em class="jd"> i </em> ]，<code class="du mj mk ml mm b">selectionSort</code>用<em class="jd"> j </em> ≥ <em class="jd"> i </em>找到最小元素<em class="jd"> array </em> [ <em class="jd"> j </em>，并将<em class="jd"> array </em> [ <em class="jd"> i </em>与<em class="jd"> array </em> [ <em class="jd"> j </em>互换，使<em class="jd">array<em class="jd"/></em></p><p id="d7e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与max函数的主要区别在于，在外循环<em class="jd"> (i) </em>的每次迭代中执行的子程序的复杂性取决于迭代变量。有一种依赖于求和公式的方法，它能够计算第12到15行被执行的次数。我们可以这样做:</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/267a1a780f36bb503d298da2852d7f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXeRD70FOE8eZhBrLUw90Q.png"/></div></div></figure><p id="ab05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原来选择排序具有二次复杂度(大Theta的<em class="jd"> n </em>)，尽管是<em class="jd">好的</em>一个；在某种意义上，它仍然比内部循环运行<em class="jd"> n </em>次的算法更有效，即使它们具有相同的渐近复杂度。</p><p id="d7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在分析中我们没有计算第7、8和19行:我们只计算了内部循环中子程序运行的次数。这是因为在分析排序算法的运行时复杂性时，我们通常只计算数组元素之间的比较。但是这并没有改变渐近符号。</p><p id="4602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这种分析是假设在内循环的每次迭代中执行的子程序以恒定的时间运行。特别是，它要求数组索引花费恒定的时间。它适用于数组(分配在连续的内存块上)，但不适用于链表。如果索引的复杂度是由某个函数U的大θ的任意函数给定的，那么我们将使用前面看到的乘积公式来说明算法的复杂度是<em class="jd">T</em>(<em class="jd">n</em>)=<em class="jd">n</em>*<em class="jd"/>θ(<em class="jd">U</em>(<em class="jd">n</em>)=θ(<em class="jd">n</em>)*θ(<em class="jd"/></p><p id="a468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，选择排序的复杂度与数组的元素无关。因此，我们不需要讨论最佳情况、一般情况和最坏情况的复杂性。例如，传递给selection sort的数组是否已经排序并不重要:在这两种情况下，它将执行相同数量的操作。</p><p id="d9d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这并不总是正确的:一些算法在某些输入上比在其他输入上运行得更快，即使它们具有相同的大小。排序算法经常会出现这种情况，我们将在下面的例子中看到。在这些情况下，我们分析最坏情况和最好情况的复杂性。另一个相关的度量是平均情况的复杂性，但是它依赖于更高级和更复杂的概念，我们不会在本文中讨论这些概念。</p><h2 id="f0e0" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">冒泡排序</h2><p id="979c" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">冒泡排序是另一种(相当低效的)排序算法。它遍历数组几次，检查每对相邻的元素，并在需要时交换它们。它在遍历数组后终止，没有交换任何对，这表明数组已经排序。下面是我们将使用的版本(摘自维基百科关于冒泡排序的文章:<a class="ae mu" href="https://en.wikipedia.org/wiki/Bubble_sort#Optimizing_bubble_sort" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Bubble_sort</a>):</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f43c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个分析比前两个更复杂，因为内部循环运行的次数取决于数组的元素，而不仅仅取决于数组的大小。</p><p id="407c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的部分是最佳情况的复杂性。首先，外部循环必须至少运行一次，因为<code class="du mj mk ml mm b">swapped</code>最初被设置为<code class="du mj mk ml mm b">true</code>。因此，内部循环将至少运行一次，并且从第10行到第13行的子例程(我们假设花费恒定的时间)将被执行<em class="jd"> n </em>次。所以冒泡排序的运行时复杂度不可能比线性好。如果数组已经排序，第10行的条件将永远不会满足，<code class="du mj mk ml mm b">swapped</code>将保持为假:外部循环不会运行超过一次，并将在<em class="jd"> n </em>比较后停止。这证明了最好的运行时复杂度是一个大的θ值<em class="jd"> n. </em></p><p id="94e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要找到内循环中子程序运行次数的上限。如果我们证明存在一个达到这个上限的输入<em class="jd"> A </em>，我们就找到了冒泡排序的最坏情况运行时间复杂度。</p><p id="2922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了给我们一些关于运行冒泡排序时会发生什么的直觉，我们将举一个输入的例子，比如长度为<code class="du mj mk ml mm b">n = 4</code>的数组<code class="du mj mk ml mm b">A = [4; 5; 2; 1]</code>。下面是外部循环在输入A上运行时发生的情况:</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mv"><img src="../Images/b87307042ac30ee85da68b1bc9daea80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-vnTF3oLp2VDfIXqT50yg.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">First iteration of the outer loop.</figcaption></figure><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es na"><img src="../Images/230a17c49477fe7e6c25d1161cd4fab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vveV5FWFyNi2hKasZDk_g.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">Second iteration of the outer loop.</figcaption></figure><p id="42ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个合理的假设是，在外部循环的第<em class="jd"> i </em>次迭代之后，数组的最后<em class="jd"> i </em>个元素位于正确的位置，也就是说，位于与最终排序后的数组相同的位置。给定一个长度为<em class="jd"> n </em> ( <em class="jd"> n </em> ≠ 0)的零索引数组<em class="jd"> A </em>，我们要证明以下性质:</p><blockquote class="lv lw lx"><p id="009e" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi"> Pn(j):外循环第</em> j <em class="hi">次执行后，对于所有索引</em>I<em class="hi">≥</em>n<em class="hi">-</em>j<em class="hi">(最后一个</em> j <em class="hi">索引)，</em> A <em class="hi"> [ </em> i <em class="hi">大于等于索引</em> k <em class="hi"> &lt; </em> i <em class="hi">处的所有元素；</em></p></blockquote><p id="342f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于任意自然数<em class="jd"> j </em>使得1 ≤ <em class="jd"> j </em> ≤ <em class="jd"> n. </em></p><p id="fceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从一个引理开始:</p><blockquote class="lv lw lx"><p id="4c67" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">对于所有指数A和b，</em> A <em class="hi"> [ </em> a <em class="hi">..</em> b <em class="hi">表示由从索引</em> a <em class="hi">到</em> b <em class="hi">的</em> A <em class="hi">元素组成的数组。</em></p><p id="a37a" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">设</em> j <em class="hi">为0和</em> n <em class="hi"> -1之间的自然数。设</em> M <em class="hi">为</em>A<em class="hi">【0】的最大元素..</em> j <em class="hi">。</em> <strong class="ih hj"> <em class="hi">运行内循环后，M至少在数组</em> </strong>中的索引j处。</p><p id="ea16" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">证明大纲:设</em> k <em class="hi">为</em> M <em class="hi">的索引。由于</em> M <em class="hi">属于A【0..</em> j <em class="hi">】，则0 ≤ k ≤ j ≤ </em> n <em class="hi"> -1。因此，内部循环的变量</em> i <em class="hi">将在某个点取值</em> k <em class="hi">。如果</em> k <em class="hi"> = </em> j <em class="hi">，那么第10行(</em> <code class="du mj mk ml mm b"><em class="hi">if array[i] &gt;= array[i + 1]</em></code> <em class="hi">)的求值无关紧要:</em> M <em class="hi">已经在大于等于</em> j <em class="hi">的索引处，我们就大功告成了。如果</em> k <em class="hi"> &lt; </em> j <em class="hi">，则第10行评估为真(因为M大于或等于索引l ≤ j处的所有元素)并且</em> M <em class="hi">移动到位置</em> k <em class="hi"> + 1。我们重复完全相同的过程，直到</em> M <em class="hi">到达索引</em> j <em class="hi">为止。</em></p></blockquote><p id="a78c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以通过归纳法证明我们的初始性质:</p><ul class=""><li id="3c96" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc mb ku kv kw bi translated">基本情况:我们应用引理<em class="jd"> j = n </em> -1。<em class="jd"> M </em>是整个数组的最大值。第一次执行内部循环后，<em class="jd"> M </em>位于索引<em class="jd"> n </em> -1。这证明Pn(1)是真的。</li><li id="f856" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc mb ku kv kw bi translated">归纳:设<em class="jd"> j </em>为0到n-1之间的自然数，使得Pn( <em class="jd"> j </em>)为真，即在第<em class="jd"> j </em>次执行外循环后，从索引<em class="jd"> n </em> - <em class="jd"> j </em> on开始的每个元素都大于或等于更低索引的所有元素。我们想要证明Pn(j + 1)是真的，也就是说，来自索引<em class="jd">n</em>-<em class="jd">j</em>-<em class="jd">1</em>on的元素都在最终排序数组中的相同位置。<br/>设<em class="jd"> M </em>为A[0]的最大值..<em class="jd">n</em>-<em class="jd">j</em>-<em class="jd">1</em>。根据引理，如果我们再运行一次外循环(总共<em class="jd"> j </em> +1)，那么在某个时刻，<em class="jd"> M </em>将被移动到索引<em class="jd"> n-j-1 </em>。由归纳假设，<em class="jd">M</em>≤<em class="jd">A</em>[<em class="jd">n</em>-<em class="jd">j</em>-1】。因此，<em class="jd"> M </em>不会进一步移动(除非M = A[n-j-1]，但这对最终数组中的排序没有影响)。因此，位于索引<em class="jd"> n </em> - <em class="jd"> j </em> -1的元件处于正确的位置。由于索引<em class="jd"> n </em> - <em class="jd"> j </em> -1之后的元素没有移动(它们已经被排序了，因为它们都比紧跟着它们的元素大)，我们已经证明Pn( <em class="jd"> j </em> +1)为真。</li></ul><p id="7054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该属性的重要结果是，最多在执行完第<em class="jd"> n </em>个外部循环后，对数组进行排序。如果我们传递一个没有重复元素的按相反顺序排序的数组<em class="jd">A</em>(<em class="jd">A</em>[<em class="jd">I</em>]≦<em class="jd">A</em>[<em class="jd">j</em>)对于所有不同的索引<em class="jd"> i </em>，<em class="jd"> j </em>)就是这种情况。因此，冒泡排序具有二次最坏情况复杂性。</p><h1 id="b489" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">阶乘复杂性</h1><p id="fead" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">具有阶乘复杂性的算法的最自然的例子是寻找一个数组的所有排列，因为正好存在<em class="jd"> n </em>！n个元素的排列。</p><h2 id="97c3" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">堆算法</h2><p id="6caa" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">堆的算法是一种有效的算法，以产生所有排列的数组。有几种优化它的变体，但是我们将集中在这个简单的实现上:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="ea14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个算法和它的“奇偶校验技巧”有点反直觉，我们不会细说它为什么是正确的。它需要两个参数，第一个参数必须是第一次调用函数时数组的长度。</p><p id="9999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分析</strong></p><p id="a697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第12行到第16行的子程序在常数时间内运行，所以当<em class="jd"> k </em> ≥ 1时，函数的复杂度为T(k)=<em class="jd">k</em>(T(<em class="jd">k</em>-1)+<em class="jd">A</em>)，其中<em class="jd"> A </em>为第12行到第16行的复杂度。我们可以证明存在两个序列α和β，使得对于所有的<em class="jd"> k </em> ≥ 1，T(<em class="jd">k</em>)=α(<em class="jd">k</em>)T(0)+β(<em class="jd">k</em>)<em class="jd">A</em>，且α( <em class="jd"> k </em> ) = <em class="jd"> k </em>！(见下图)。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/3ebced9a44261858dcd1834aa38a143e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSu4u38dXhfyJvKwaRNkbA.png"/></div></div></figure><p id="d4b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">找到β的通项更难，但这无关紧要。我们会想办法证明T(<em class="jd">n</em>)=θ(<em class="jd">n</em>)！)而没有给它一个明确的值。</p><p id="91bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将证明β( <em class="jd"> n </em> )/ <em class="jd"> n </em>！向一个有限的极限收敛。为此，我们为比率β( <em class="jd"> n </em> )/ <em class="jd"> n </em>)找到一个通项！并利用阶乘的倒数级数收敛的事实:</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/b35131e95fd5d9736dea9caa89e0f10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqEjWmtBo4aNe83_fNNx8g.png"/></div></div></figure><p id="b3f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以T( <em class="jd"> n </em> )/ <em class="jd"> n </em>！= T(0)+A(β(<em class="jd">n</em>)/<em class="jd">n</em>！)，它向一个非零的有限极限收敛:T(<em class="jd">n</em>)=θ(<em class="jd">n</em>！).</p><h1 id="6a27" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">多变量复杂性和BFS</h1><p id="1610" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">到目前为止，我们只处理过大小可以用单个变量表示的数据结构。然而，存在其复杂性取决于几个参数的算法。这是涉及图的情况，因为图的大小取决于边的数量和顶点的数量。</p><p id="1e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以像以前一样对多变量函数使用渐近符号。例如，如果<em class="jd"> f </em>将ℕ映射到ℕ，那么<em class="jd"> f </em> ( <em class="jd"> m </em>，<em class="jd">n</em>)= o(<em class="jd">m</em>+<em class="jd">n</em>)当存在阈值<em class="jd"> A </em>和常数因子<em class="jd"> B </em>使得f( <em class="jd"> m </em>， <em class="jd">n</em>)&lt;<em class="jd">B</em>(<em class="jd">m</em>+<em class="jd">n</em>)对于所有的<em class="jd"> m </em>和<em class="jd"> n </em>都大于a .当一个算法的复杂度是一个<em class="jd"> m </em> + <em class="jd"> n </em>的大θ时，我们说它在线性时间内运行【T82 </p><h2 id="60c5" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">广度优先搜索</h2><p id="c0e6" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">广度优先搜索(BFS)是一种算法，在一些图中找到从给定顶点到另一个顶点的最短路径。</p><p id="3bdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本节的其余部分，<em class="jd"> n </em>将表示输入图中顶点的数量，而<em class="jd"> m </em>将表示边的数量。</p><p id="9ae7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用下面的实现。</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BFS首先将除起始点以外的所有顶点标记为未访问，这需要θ(<em class="jd">n</em>)时间。</p><p id="c82f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们维护一个顶点队列。只要队列不为空，我们就弹出下一个顶点，检查它是否不是我们的目标，并将其所有未访问的邻居排队。</p><p id="bed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最好的情况下，<code class="du mj mk ml mm b">start = destination</code>并且唯一重要的操作是构造<code class="du mj mk ml mm b">visited</code>列表。所以这个函数的复杂度是θ(n)。然而，我们通常认为最好的复杂度是θ(1)，因为第一个子程序(我们初始化<code class="du mj mk ml mm b">visited</code>的地方)并不是算法的一部分。</p><p id="eaf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个顶点不能被访问超过一次，所以外部循环(第14行)不会运行超过<em class="jd"> n </em>次。第15行到第24行花费的时间不变。对于每个顶点<em class="jd"> v </em>，第26到35行正好运行deg⁺( <em class="jd"> v </em>次，其中deg⁺( <em class="jd"> v </em>是<em class="jd"> v </em>的出度，即尾部为<em class="jd"> v </em>的边的数量。我们介绍的选择排序方法的一个简单应用证明了BFS不会比线性差，如下图所示。算法以θ(<em class="jd">n</em>)步运行的输入的一个例子是具有顶点0、1和2以及带有<code class="du mj mk ml mm b">start = 0</code>和<code class="du mj mk ml mm b">destination = 2</code>的边(0，1)和(1，2)的图。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/7edc802c48dd0aae8256c7d5ef1e7944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJusz1BOn9SaH397D_YzDQ.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">Analysis of BFS. A, B and C are positive natural numbers. V is the set of vertices in the input graph. deg⁺(<em class="nb">v</em>) is the number of edges whose tail is <em class="nb">v</em>.</figcaption></figure><p id="39c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们关于图是有向图的假设不失一般性。我们可以用度来代替出度，因为度和公式会将乘法因子2加到<em class="jd"> m </em>上，这在大Theta符号中会消失。</p><h1 id="7ab4" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">指数复杂性</h1><p id="e3c8" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">[灵感来自杰夫·埃里克森的<em class="jd">算法</em>，第1.3节:汉诺塔]</p><p id="d007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的最后一部分是关于指数复杂度的算法。这是指复杂度为θ(<em class="jd">rⁿ</em>)的算法，其中<em class="jd"> r </em>是严格大于1的数。这些算法的运行速度在渐近上比多项式算法慢，比指数算法快:<em class="jd"> n </em> = O( <em class="jd"> rⁿ </em>)和<em class="jd"> rⁿ </em> = O( <em class="jd"> n </em>！)(对于任何一个<em class="jd">r</em>1和<em class="jd"> a </em> ∈ ℝ).</p><h2 id="51df" class="lh jm hi bd jn li lj lk jr ll lm ln jv iq lo lp jz iu lq lr kd iy ls lt kh lu bi translated">河内塔</h2><p id="593f" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们将通过分析解决汉诺塔难题的算法来说明这一部分。它由几个圆盘和三个杆组成，因此所有圆盘的直径都不同，如果圆盘A大于圆盘B，则圆盘A不能位于圆盘B上方。所有圆盘都堆叠在杆上，多个圆盘不能同时从一个杆移动到另一个杆。</p><p id="58ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将用链表来模拟杆，用不同的整数来模拟盘。我们将使用以下用F#实现的算法:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="fb97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先创建一个函数，它可以将磁盘从一个杆移动到另一个杆，确保我们不会尝试执行非法移动。主功能<code class="du mj mk ml mm b">solveHanoi</code>负责将<code class="du mj mk ml mm b">original</code>顶部的<code class="du mj mk ml mm b">n</code>圆盘移动到<code class="du mj mk ml mm b">goal</code>。</p><p id="3298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是本文的目标，但我会尝试给你一些直觉，为什么这个算法是正确的。当n ≥ 2时，我们要将第<code class="du mj mk ml mm b">n</code>个圆盘从原杆移动到目标。为此，我们首先移动最先出现的<code class="du mj mk ml mm b">n</code> -1个磁盘(我们如何做并不重要——递归调用将为我们找到一个解决方案),这样第<code class="du mj mk ml mm b">n</code>个磁盘就在它的杆的顶部结束。然后我们可以将它移动到目标。我们只剩下留在临时杆上的<code class="du mj mk ml mm b">n</code> -1个小圆盘:临时杆成为原点，我们递归。当我们只需要移动一个磁盘时，我们可以直接这样做:这是我们的基本情况。</p><p id="dc8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分析</strong></p><p id="5d57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<em class="jd"> n </em> ≥ 1，设T( <em class="jd"> n </em>)表示算法的复杂度，其中<em class="jd"> n </em>表示磁盘数。如果n ≥ 2那么T(n) = 2T(n-1) + A，其中A是<code class="du mj mk ml mm b">moveDisk</code>的复杂度，需要常数时间。基本情况是T(1) = A，这是一个由a(<em class="jd">n</em>+1)=<em class="jd">α</em>a(<em class="jd">n</em>)+<em class="jd">β</em>形式的递推关系定义的序列，其中<em class="jd"> α </em>、<em class="jd"> β </em>为实数。有一个简单的方法可以找到它的通项，如下图所示。在于引入由b(<em class="jd">n</em>)= a(<em class="jd">n</em>)-<em class="jd">l</em>定义的序列<em class="jd"> b </em>，其中<em class="jd"> L </em>是递归函数<em class="jd">x</em>⟼<em class="jd">α</em><em class="jd">x</em>+<em class="jd">β</em>的唯一不动点。b( <em class="jd"> n </em>)恰好是一个几何数列，它的通项很容易计算。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/6da2753f95656d6d2de7cbc784dcbee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSKdtzaKKMmMsID_frxHhQ.png"/></div></div></figure><p id="5d8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mj mk ml mm b">solveHanoi</code>的复杂度为t(<em class="jd">n</em>)=<em class="jd">a</em>(2<em class="jd">ⁿ</em>-1)，其中<em class="jd"> A </em>为走一步棋所用的时间。</p><p id="cf02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在1883年发表的最初的问题陈述中，这个难题由64个圆盘组成，牧师们把它们从一个钻石针转移到另一个。如果他们每秒移动一个磁盘，他们将需要执行1.8*10次⁹移动，连续工作超过50亿个世纪。实际证明2 <em class="jd"> ⁿ </em> -1是我们解决这个谜题可以执行的最少步骤数，其中<em class="jd"> n </em>是圆盘的个数。</p><h1 id="7ecc" class="jl jm hi bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">结论</h1><p id="f8a8" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们已经探索了几种用于分析算法复杂性的方法。即使没有通用的技术来帮助发现任何一种函数的复杂性，它们也涵盖了广泛的情况。现在你应该对渐近符号有了很好的理解，并且能够将我们看到的方法应用到各种算法中。</p><p id="8580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一部分将继续我们学习的最后一个例子，并重点讨论如何分析分治算法。它们通常有一个包含对数的复杂度，对数以递减的速率增加。对数算法优于线性算法，线性算法(<em class="jd"> n </em> log <em class="jd"> n </em>)优于二次算法。我们还会提到摊销分析。</p><p id="d173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎在评论中指出错误或值得澄清的部分！</p><p id="fe9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">🐙</p></div></div>    
</body>
</html>
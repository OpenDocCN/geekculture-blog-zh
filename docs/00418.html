<html>
<head>
<title>Java Lambda Expression Tutorial: Functional Programming in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Lambda表达式教程:Java中的函数式编程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-lambda-expression-tutorial-functional-programming-in-java-ccd01c2a8ec?source=collection_archive---------2-----------------------#2021-02-04">https://medium.com/geekculture/java-lambda-expression-tutorial-functional-programming-in-java-ccd01c2a8ec?source=collection_archive---------2-----------------------#2021-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/25d94cb3101852bcb11acadeba9d0bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR36h8h1jdQeaAqZtQwFbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image Source: Author</figcaption></figure><p id="d130" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在2021年初超过60%的专业开发人员仍在使用Java 8的情况下，理解Java 8的特性是一项基本技能。Java 8于2014年发布，带来了大量新功能。</p><p id="c9e8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些变化包括允许Java开发人员以函数式编程风格编写代码的特性。最大的变化之一是添加了<strong class="iw hj">λ表达式。</strong></p><p id="e0fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Lambdas类似于方法，但是它们不需要名字，并且可以在类之外实现。因此，它们为全功能程序开辟了可能性，并为将来Java提供更多的功能支持铺平了道路。</p><p id="3eb2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">今天，我们将帮助您开始学习lambda表达式，并探索如何将它们用于接口。</p><p id="0dce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">下面是我们今天要讲的内容:</strong></p><ul class=""><li id="7c24" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">什么是lambda表达式？</li><li id="68fd" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">如何编写lambda表达式</li><li id="95e4" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">Java中的接口</li><li id="acee" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">接下来学什么</li></ul><h1 id="4d63" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是lambda表达式？</h1><p id="0d3c" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">Lambda表达式是一个匿名函数，这意味着它们没有名字或标识符。它们可以作为参数传递给另一个函数。它们与一个函数接口成对出现，并带有一个参数，该参数带有一个引用该参数的表达式。</p><p id="3827" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基本lambda表达式的语法是:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5237" class="ls kh hi lo b fi lt lu l lv lw">parameter -&gt; expression</span></pre><p id="f2f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">表达式在成对的函数接口中用作抽象方法(一个已命名但为空的方法)的代码体。</p><p id="c072" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与Java中的大多数函数不同，lambda表达式<strong class="iw hj">存在于任何对象的范围之外。</strong>这意味着它们可以在程序中的任何地方被调用，并且可以被传递。用最简单的话来说，lambda表达式允许函数的行为就像另一段数据一样。</p><h1 id="e1ea" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Java中的Lambda用例</h1><p id="9072" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">Lambda表达式用于实现匿名类的功能，而没有杂乱的实现。它们非常适合于重复简单的行为，这些行为可以在程序的多个区域中使用，例如，在不改变输入数据的情况下添加两个值。</p><p id="6322" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些属性使得lambda对于Java中的函数式编程风格特别有用。在Java 8之前，Java努力寻找工具来满足函数式编程的所有原则。</p><p id="51a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">函数式编程有5个关键原则:</p><ul class=""><li id="b891" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hj">纯函数</strong>:独立于函数之外的状态运行的函数，并且只包含找到输出所必需的运算。</li><li id="8540" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj">不变性</strong>:输入被引用，不被修改。函数应该避免复杂的条件行为。一般来说，不管调用多少次，所有函数都应该返回相同的值。</li><li id="7265" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj">一级函数</strong>:函数被视为与任何其他值相同。您可以用函数填充数组，将函数作为参数传递，等等。</li><li id="8d18" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj">高阶函数</strong>:高阶函数要么将一个或多个函数作为参数，要么返回一个函数。这些对于用函数式编程创建复杂的行为是必不可少的。</li><li id="b321" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj">功能组合</strong>:可以将多个简单的功能按照不同的顺序串在一起，创建复杂的功能。简单函数完成一个步骤，该步骤可以在多个任务之间共享，而复杂函数完成整个任务</li></ul><p id="b7bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Lambda表达式帮助我们在Java中实现纯函数、不变性和一级函数原则。</p><p id="bac9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Lambda函数是纯函数，因为它们不依赖于特定的类范围。它们是不可变的，因为它们引用传递的参数，但不修改参数的值来获得结果。最后，它们是一级函数，因为它们可以匿名传递给其他函数。</p><p id="7023" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于Lambda表达式的类独立性，它也被用作非函数式程序中的事件监听器和回调函数。</p><h1 id="827e" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如何用Java编写lambda表达式</h1><p id="5cf8" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">正如我们前面看到的，lambda表达式的基本形式是传递一个参数。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a8c4" class="ls kh hi lo b fi lt lu l lv lw">parameter -&gt; expression</span></pre><p id="8f06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个lambda表达式也可以有多个参数:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6385" class="ls kh hi lo b fi lt lu l lv lw">(parameter1, parameter2) -&gt; expression</span></pre><p id="8edc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">表达式段或lambda体包含对参数的引用。lambda表达式的值是用传递的参数执行时表达式的值。</p><p id="11fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="cb75" class="ls kh hi lo b fi lt lu l lv lw">import java.util.ArrayList;</span><span id="43e1" class="ls kh hi lo b fi lx lu l lv lw">public class main {<br/>  public static void main(String[] args) {<br/>    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();<br/>    numbers.add(5);<br/>    numbers.add(9);<br/>    numbers.add(8);<br/>    numbers.add(1);<br/>    numbers.forEach( (n) -&gt; { System.out.println(n); } );<br/>  }<br/>}</span></pre><p id="95bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参数<code class="du ly lz ma lo b">n</code>被传递给表达式<code class="du ly lz ma lo b">System.out.println(n)</code>。然后使用print语句中参数<code class="du ly lz ma lo b">n</code>的值执行表达式。对数组列表中的每个数字重复这个过程，将列表中的每个元素作为<code class="du ly lz ma lo b">n</code>传递给lambda表达式。因此，这个表达式的输出是数组列表元素的打印列表:<code class="du ly lz ma lo b">5 9 8 1</code>。</p><h1 id="3b0e" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">λ函数体</h1><p id="377e" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">如果用花括号括起来，lambda函数体可以包含多行表达式。</p><p id="dddb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3a02" class="ls kh hi lo b fi lt lu l lv lw">(oldState, newState) -&gt; {<br/>    System.out.println("Old state: " + oldState);<br/>    System.out.println("New state: " + newState);<br/>  }</span></pre><p id="c120" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这允许执行代码块而不是单个语句的更复杂的表达式。</p><p id="09e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还可以通过在函数体中添加return语句来从lambda函数返回。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="fb8a" class="ls kh hi lo b fi lt lu l lv lw">public static Addition getAddition() {<br/>      return (a, b) -&gt; a + b; // lambda expression return statement<br/>   }</span></pre><p id="568e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Lambda甚至有自己的返回语句:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="29ae" class="ls kh hi lo b fi lt lu l lv lw">(a, b) -&gt; a + b;</span></pre><p id="3750" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译器假设<code class="du ly lz ma lo b">a+b</code>是我们的返回值。这种语法更清晰，将产生与上一个示例相同的输出。</p><p id="ec80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不管表达式有多长或多复杂，记住lambda表达式必须立即输出一致的值。这意味着表达式不能包含任何条件语句，如<code class="du ly lz ma lo b">if</code>或<code class="du ly lz ma lo b">while</code>，也不能等待用户输入。</p><p id="2f71" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论运行多少次，表达式中的所有代码都必须有一个不可变的输出。</p><h1 id="5c0a" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">作为对象的Lambdas</h1><p id="4a6a" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">您可以将lambdas作为参数发送给其他函数。想象一下，我们想要创建一个欢迎程序，可以用不同的语言添加更多的<code class="du ly lz ma lo b">greeting</code>功能。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="24ea" class="ls kh hi lo b fi lt lu l lv lw">// WellWisher.java<br/>public class WellWisher {<br/>    public static void wish(Greeting greeting) {<br/>        greeting.greet();<br/>    }<br/>    // Passing a lambda expression to the wish method<br/>    public static void main(String args[]) {<br/>        wish( () -&gt; System.out.println("Namaste") );<br/>    }<br/>}</span><span id="80ed" class="ls kh hi lo b fi lx lu l lv lw">// Greeting.java<br/>@FunctionalInterface<br/>public interface Greeting {<br/>    void greet();<br/>}</span></pre><p id="d7a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里传递表达式本身，并立即执行<code class="du ly lz ma lo b">greet();</code>函数。从这里，我们可以为不同的语言添加额外的问候功能，这些功能将覆盖只打印正确的问候。</p><h1 id="8c59" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Java中的接口</h1><p id="e311" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">Java中的接口类似于类。它们是包含变量和方法的蓝图。然而，接口只包含有签名但没有代码实现的抽象方法。</p><p id="fff0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接口可以被认为是实现类必须定义来操作的属性或方法的列表。接口说明了它必须具备什么特性，但没有说明如何实现它们。</p><p id="f54c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，你可能有一个接口<code class="du ly lz ma lo b">Character</code>，它列出了一个视频游戏中的角色必须能够做的所有事情的方法。界面列出了所有角色都必须有一个<code class="du ly lz ma lo b">move()</code>方法，但是由各个角色的职业来定义距离和方式(飞行、奔跑、滑行等)。)的运动。</p><p id="a1b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接口的语法是:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="60a1" class="ls kh hi lo b fi lt lu l lv lw">interface &lt;interface_name&gt; {</span><span id="c174" class="ls kh hi lo b fi lx lu l lv lw">    // declare constant fields<br/>    // declare methods that abstract <br/>    // by default.<br/>}</span></pre><p id="54dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了接口，Java类可以实现多重继承，因为它们不受一个类继承的限制。它还帮助我们实现完全抽象，因为默认情况下，接口没有范围或值。</p><p id="a2d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Lambda表达式用于表达这些接口的实例。在Java 8之前，我们必须创建一个内部匿名类来使用这些接口。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6dfd" class="ls kh hi lo b fi lt lu l lv lw">// functional interface before java8</span><span id="968b" class="ls kh hi lo b fi lx lu l lv lw">class Test <br/>{ <br/>    public static void main(String args[]) <br/>    { <br/>        // create anonymous inner class object <br/>        new Thread(new Runnable() <br/>        { <br/>            @Override<br/>            public void run() // anonymous class<br/>            { <br/>                System.out.println("New thread created"); <br/>            } <br/>        }).start(); <br/>    } <br/>}</span><span id="668c" class="ls kh hi lo b fi lx lu l lv lw">// functional interface using lambda expressions </span><span id="5078" class="ls kh hi lo b fi lx lu l lv lw">class Test <br/>{ <br/>  public static void main(String args[]) <br/>  { </span><span id="ebf3" class="ls kh hi lo b fi lx lu l lv lw">    // lambda expression to create the object <br/>    new Thread(()-&gt; <br/>       {System.out.println("New thread created");}).start(); <br/>  } <br/>}</span></pre><h1 id="5f03" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">功能界面</h1><p id="a1ea" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">Lambda表达式只能实现<strong class="iw hj">函数接口</strong>，也就是只有一个抽象方法的接口。lambda表达式实质上为函数接口中的抽象方法提供了主体。</p><p id="f7fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果接口有不止一个抽象方法，编译器将不知道哪个方法应该使用lambda表达式作为它的主体。内置功能接口的常见例子有<code class="du ly lz ma lo b">Comparator</code>或<code class="du ly lz ma lo b">Predicate</code>。</p><p id="5563" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最佳实践是将可选的<code class="du ly lz ma lo b">@FunctionalInterface</code>注释添加到任何功能接口的顶部。</p><p id="9f34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Java将注释理解为被标记的接口只能有一个抽象方法的限制。如果有一个以上的方法，编译器将发送一个错误信息。</p><p id="8fdb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用注释可以确保调用该接口的lambda表达式不会出现意外行为。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4921" class="ls kh hi lo b fi lt lu l lv lw">@FunctionalInterface<br/>interface Square <br/>{ <br/>    int calculate(int x); <br/>}</span></pre><h1 id="b5b2" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接口中的默认方法</h1><p id="4f85" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">虽然函数接口对抽象方法有限制，但对默认或静态方法没有限制。默认或静态方法可以微调我们的接口，以便与继承类共享不同的行为。</p><p id="9cf0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">默认方法可以在接口中有一个主体。最重要的是，接口中的默认方法为给定的类型提供额外的功能，而不会破坏实现类。</p><p id="b7c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Java 8之前，如果一个新方法被引入一个接口，所有的实现类都会崩溃。要解决这个问题，我们需要在所有实现类中单独提供该方法的实现。</p><p id="b1eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，有时方法只有一个实现，不需要在每个类中提供它们的实现。在这种情况下，我们可以在接口中将该方法声明为默认方法，并在接口本身中提供其实现。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a3da" class="ls kh hi lo b fi lt lu l lv lw">public interface Vehicle {<br/>    void cleanVehicle();<br/>    default void startVehicle() {<br/>        System.out.println("Vehicle is starting");<br/>    }<br/>}</span></pre><p id="1f77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，默认方法是<code class="du ly lz ma lo b">startVehicle()</code>，而<code class="du ly lz ma lo b">cleanVehicle()</code>是抽象的。不管实现的类是什么，<code class="du ly lz ma lo b">startVehicle()</code>将总是打印相同的短语。因为行为不会基于类而改变，所以我们可以简单地使用默认方法来避免重复的代码。</p><p id="93bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最重要的是，<code class="du ly lz ma lo b">Vehicle</code>接口仍然只有一个抽象方法，因此被认为是可以和lambda表达式一起使用的函数接口。</p><h1 id="98b4" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接口中的静态方法</h1><p id="1aa4" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">接口中的静态方法类似于默认方法，但是它们不能被重写。当您希望一个方法的实现不会因为实现类而改变时，静态方法非常有用。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e9f9" class="ls kh hi lo b fi lt lu l lv lw">// Car.java<br/>public abstract class Car implements Vehicle {<br/>    public static void repair(Vehicle vehicle){<br/>        vehicle.repairVehicle();<br/>    }<br/>    public static void main(String args[]){</span><span id="0626" class="ls kh hi lo b fi lx lu l lv lw">        Vehicle.cleanVehicle(); //This will compile.<br/>        Car.repair(() -&gt; System.out.println("Car repaired"));<br/>    }<br/>}</span><span id="caee" class="ls kh hi lo b fi lx lu l lv lw">// Vehicle.java<br/>//functional interface<br/>public interface Vehicle {<br/>    static void cleanVehicle(){<br/>        System.out.println("I am cleaning vehicle");<br/>    }<br/>    void repairVehicle();<br/>}</span></pre><p id="8ac6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ly lz ma lo b">Car</code>类中，我们能够调用<code class="du ly lz ma lo b">cleanVehicle()</code>来产生在我们的接口中定义的实现。如果我们试图对<code class="du ly lz ma lo b">cleanVehicle()</code>方法进行<code class="du ly lz ma lo b">@Override</code>，我们会得到一个错误消息，因为它被声明为<code class="du ly lz ma lo b">static</code>。</p><p id="e4fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们仍然可以在lambda表达式中使用这个接口，因为<code class="du ly lz ma lo b">repairVehicle()</code>是我们唯一的抽象方法。</p><h1 id="f8c0" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接下来学什么</h1><p id="5415" class="pw-post-body-paragraph iu iv hi iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr hb bi translated">Lambda函数是Java 8最有用的附加功能之一。然而，还有许多特性使Java 8成为专业开发人员最常用的语言。</p><p id="c27e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">接下来要学习的一些功能有:</strong></p><ul class=""><li id="1b18" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">流API</li><li id="f8e1" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">并发API添加</li><li id="1bf5" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">批量数据处理工具</li><li id="e60d" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">内置高阶函数</li></ul><p id="fb1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="mb">快乐学习！</em></p></div></div>    
</body>
</html>
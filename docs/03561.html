<html>
<head>
<title>Developing on Kubernetes: The Inner &amp; Outer Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上开发:内部和外部循环</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/developing-on-kubernetes-the-inner-outer-loop-6957f9597f7a?source=collection_archive---------20-----------------------#2021-06-10">https://medium.com/geekculture/developing-on-kubernetes-the-inner-outer-loop-6957f9597f7a?source=collection_archive---------20-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="cab1" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">本文面向在Kubernetes或通用系统管理方面有一些经验的开发人员，尽管希望任何人都可以从这些实践中学到一些东西。</p></blockquote><p id="f889" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">kubernetes“K8s”发展成为将服务部署到云的标准方式。理所当然！使用像K8s这样的容器编排引擎提供了许多好处，包括但不限于:</p><ul class=""><li id="3caf" class="jk jl hi il b im in iq ir jh jm ji jn jj jo jg jp jq jr js bi translated">可伸缩性:<em class="ik">永远不要超出您的基础设施</em></li><li id="1e35" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">模块化:<em class="ik">让K8s适应你的需求，而不需要修补上游源代码</em></li><li id="d9be" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">自我修复:<em class="ik">重启失败的容器</em></li><li id="678e" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">简单服务发现</li><li id="5ada" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated"><strong class="il hj">基础设施抽象的标准化</strong></li><li id="e338" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated"><strong class="il hj">部署的清晰原子性</strong></li><li id="8b43" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi">…</li></ul><p id="67dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">K8s已经发展成为一个行业标准，它允许团队在部署策略方面有一个共同的标准。尽管它没有重新发明软件架构和部署策略的一般概念，但由于K8s资源的声明性，这些方法比以往任何时候都更容易掌握。这种标准化至关重要，因为它将个人的专业知识与公司潜在的遗留基础设施强有力地分离，并允许更快速的迭代和创新。</p><p id="bb9c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">虽然K8s在生产中使用时在复杂性和开销方面有缺陷，但这些问题很少超过它提供的好处。因此，我将提供一个我喜欢在K8s上开发的开发工作流的简明概述。这包括:</p><ul class=""><li id="21df" class="jk jl hi il b im in iq ir jh jm ji jn jj jo jg jp jq jr js bi translated">(引导项目)</li><li id="7fcd" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">内部循环:<em class="ik">局部开发</em></li><li id="ff9e" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">外环:<em class="ik">部署策略&amp;配置管理</em></li></ul><p id="586c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">依我拙见，这些阶段不是互不关联的，而是级联的。因此，每个阶段之间的转换和互操作性至关重要。如果处理得当，生命周期管理轻而易举。此外，我坚信只有在有特定原因的情况下，才应该引入复杂性。</p><blockquote class="jy"><p id="dce5" class="jz ka hi bd kb kc kd ke kf kg kh jg dx translated">尽可能保持简单，但不要更简单。</p></blockquote><p id="e211" class="pw-post-body-paragraph ii ij hi il b im ki io ip iq kj is it jh kk iw ix ji kl ja jb jj km je jf jg hb bi translated">所有项目文件都可以在<a class="ae kn" href="https://github.com/fabius/dev-on-k8s" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。请注意，这些实践是我个人最喜欢的。如果你同意/不同意某些陈述，请随意开始讨论。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="5fca" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">先决条件</h1><p id="d2e6" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">为了以后不中断流程，让我们预先安装所有必要的包。请注意，您可以在每个项目的网站上找到最新的安装说明:</p><ul class=""><li id="0ff8" class="jk jl hi il b im in iq ir jh jm ji jn jj jo jg jp jq jr js bi translated">码头工人</li><li id="957f" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated"><a class="ae kn" href="https://github.com/kubernetes/kompose" rel="noopener ugc nofollow" target="_blank"> Kompose </a></li><li id="aec6" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated"><a class="ae kn" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank">迷你库贝</a></li><li id="466a" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated"><a class="ae kn" href="https://github.com/kubernetes/kubectl" rel="noopener ugc nofollow" target="_blank">库贝克特尔</a></li><li id="8fa3" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg jp jq jr js bi translated">斯卡福德<a class="ae kn" href="https://github.com/GoogleContainerTools/skaffold" rel="noopener ugc nofollow" target="_blank"/></li></ul><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="4d76" class="mh kw hi md b fi mi mj l mk ml"># nix<br/>nix-env -bi docker kompose minikube kubectl skaffold</span><span id="c2d0" class="mh kw hi md b fi mm mj l mk ml"># brew<br/>brew install --cask docker<br/>brew install docker kompose minikube <!-- -->kubernetes-cli skaffold<br/># start docker desktop manually<!-- --> </span><span id="e86d" class="mh kw hi md b fi mm mj l mk ml"># openSUSE<br/>sudo zypper in docker kompose minikube kubernetes-client<br/>sudo systemctl enable --now docker<br/>curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 &amp;&amp; \<br/>sudo install skaffold /usr/local/bin/</span><span id="b87c" class="mh kw hi md b fi mm mj l mk ml"># debian<br/>sudo apt install docker.io<br/>sudo systemctl enable --now docker<br/># kompose<br/>curl -L https://github.com/kubernetes/kompose/releases/download/v1.22.0/kompose-linux-amd64 -o kompose<br/>chmod +x kompose<br/>sudo mv ./kompose /usr/local/bin/kompose<br/># minikube<br/>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br/>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br/># kubectl<br/>curl -LO "https://storage.googleapis.com/kubernetes-release/release/<strong class="md hj">$(</strong>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<strong class="md hj">)</strong>/bin/linux/amd64/kubectl"<br/>chmod +x ./kubectl<br/>sudo mv ./kubectl /usr/local/bin/kubectl<br/># skaffold<br/>curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 &amp;&amp; \<br/>sudo install skaffold /usr/local/bin/</span><span id="4e7f" class="mh kw hi md b fi mm mj l mk ml"># fedora<br/>sudo dnf install moby-engine kompose<br/>sudo systemctl enable --now docker<br/># minikube<br/>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br/>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br/># kubectl<br/>curl -LO "https://storage.googleapis.com/kubernetes-release/release/<strong class="md hj">$(</strong>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<strong class="md hj">)</strong>/bin/linux/amd64/kubectl"<br/>chmod +x ./kubectl<br/>sudo mv ./kubectl /usr/local/bin/kubectl<br/># skaffold<br/>curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 &amp;&amp; \<br/>sudo install skaffold /usr/local/bin/</span></pre></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="f7b8" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">启动项目</h1><blockquote class="jy"><p id="9dd4" class="jz ka hi bd kb kc kd ke kf kg kh jg dx translated">如果你习惯于编写K8s资源或者已经有了一个可用的服务，可以完全跳过这一部分。这应该可以简化从dockerised设置到部署到K8s集群的过渡。</p></blockquote><blockquote class="if ig ih"><p id="060e" class="ii ij ik il b im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc km je jf jg hb bi translated">TL；DR:敏捷思维——不要陷入不同的过程中。专注于要解决的核心问题。最简单的解决方案是正确的。</p></blockquote><p id="99a1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">所以你已经收集了所有的需求并设计了系统的架构。现在到了有趣的部分:编码实际的业务逻辑。但是我们该如何开始呢？我们可以克隆一个最小的支架来匹配我们设计的架构。我们可以使用像<code class="du mn mo mp md b">helm create</code>这样的工具来搭建一些基线K8s资源文件，或者只是手工编写那些可爱的yaml文件。就我个人而言，我不喜欢在一个全新的项目中引入K8s，原因有二:</p><ol class=""><li id="165f" class="jk jl hi il b im in iq ir jh jm ji jn jj jo jg mq jq jr js bi translated">刚开始时，你在本地工作。现在还没有要部署的东西，也没有要编排的东西。那么为什么要在这个时候推出K8s呢？</li><li id="3fdd" class="jk jl hi il b im jt iq ju jh jv ji jw jj jx jg mq jq jr js bi translated">软件开发包括一个<strong class="il hj">发现和学习</strong>的过程。在实际开发过程中，你经常会发现自己在调整设计的某些部分。让我们不要陷入这个过程，保持事情的灵活性和简单性。</li></ol><p id="b644" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">此外，当在您的机器上开始和测试您的软件时，您可以通过完全消除它们(看着您，DNS)来为您自己省去额外的麻烦。就像你习惯的那样运行你的容器。你很可能熟悉<code class="du mn mo mp md b">docker run</code>和<code class="du mn mo mp md b">docker compose</code>。就我个人而言，我喜欢一个最小的<code class="du mn mo mp md b">docker-compose.yml</code>来开始，因为我真的很喜欢它清晰的描述格式。你做你的。</p><p id="0229" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们假设这是你的花式服务:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="3d0e" class="mh kw hi md b fi mi mj l mk ml">// main.go<br/>package main</span><span id="ed58" class="mh kw hi md b fi mm mj l mk ml">import (<br/>        "log"<br/>        "os"<br/>        "time"<br/>)</span><span id="09ce" class="mh kw hi md b fi mm mj l mk ml">func main() {<br/>        for {<br/>                log.Println("Hello from service " + os.Getenv("NAME"))<br/>                time.Sleep(time.Second)<br/>        }<br/>}</span></pre><p id="2620" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">可以用这样的<code class="du mn mo mp md b">Dockerfile</code>装箱:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="bda8" class="mh kw hi md b fi mi mj l mk ml"># Dockerfile<br/>FROM golang:1.16<br/>COPY main.go .<br/>RUN go build -o myservice main.go<br/>CMD ./myservice</span></pre><p id="4389" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">最小的<code class="du mn mo mp md b">docker-compose.yml</code>看起来像:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="c434" class="mh kw hi md b fi mi mj l mk ml"># docker-compose.yml<br/>version: "3"<br/>services:<br/>  myservice: # call this anything you like<br/>    build: .<br/>    environment:<br/>      NAME: "kube"</span></pre><p id="9b06" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这就是运行<code class="du mn mo mp md b">docker compose up --build</code>所需的全部内容，它将构建并运行您的服务。假设您的服务需要一个类似<code class="du mn mo mp md b">postgres</code>的数据库，只需扩展<code class="du mn mo mp md b">docker-compose.yml</code></p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="8994" class="mh kw hi md b fi mi mj l mk ml"># docker-compose.yml<br/>version: "3"<br/>services:<br/>  myservice: # call this anything you like<br/>    build: .<br/>    environment:<br/>      NAME: "kube"<br/>    depends_on:<br/>      - db<br/>  db:<br/>    image: postgres:13<br/>    environment:<br/>      POSTGRES_PASSWORD: "postgres"</span></pre><p id="ac8a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">运行<code class="du mn mo mp md b">docker compose up --build</code>将构建您的服务，并在<code class="du mn mo mp md b">postgres</code>启动并运行后运行它。直截了当，不是吗？</p><p id="092a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">一旦您的服务准备好被部署，假设您正在部署到K8s，您将最终想要放弃<code class="du mn mo mp md b">docker compose</code>并切换到针对K8s的开发。幸运的是，我们可以将我们的<code class="du mn mo mp md b">docker-compose.yml</code>转换为它们的K8s表示，从而显著平滑过渡:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="81d3" class="mh kw hi md b fi mi mj l mk ml">mkdir k8s<br/>kompose convert --out k8s/<br/>rm docker-compose.yml</span></pre><p id="8381" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这将在<code class="du mn mo mp md b">k8s</code>目录中创建两个部署资源，让我们看看内部开发循环。但是等等，我们首先需要一个本地K8s集群。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="986a" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">本地K8s集群</h1><p id="68af" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">选择本地K8s集群可能会让人不知所措，因为有很多解决方案。一般来说，您希望尽可能接近生产集群的配置奇偶校验。例如，如果你部署到EKS，考虑一下<a class="ae kn" href="https://snapcraft.io/eks" rel="noopener ugc nofollow" target="_blank"> EKS快照</a>。Minikube 是一个易于使用和可扩展的高保真本地集群，从来没有让我感到惊讶。除非你已经有了不使用Minikube的具体理由，否则你不会错的。要使用Minikube通过docker启动本地K8s集群，运行<code class="du mn mo mp md b">minikube start --driver=docker</code></p><h1 id="bc90" class="kv kw hi bd kx ky mr la lb lc ms le lf lg mt li lj lk mu lm ln lo mv lq lr ls bi translated">内部循环</h1><p id="0ecc" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">根据您的设置，您的本地K8s集群可能无法访问您的本地docker映像注册表。因此，我们不能使用<code class="du mn mo mp md b">kubectl apply -f k8s/</code>创建我们的资源，直到我们已经构建了我们的服务映像并将其推送到集群的注册中心(显然，我们不想将每个开发映像迭代推送到DockerHub/GitHub容器注册中心)。正如您可能注意到的那样，在每次更改时手动触发这个过程是非常繁琐的！幸运的是，有工具可以帮助解决这个问题。最受欢迎的有<a class="ae kn" href="https://github.com/GoogleContainerTools/skaffold" rel="noopener ugc nofollow" target="_blank">斯卡福德</a>、<a class="ae kn" href="https://github.com/garden-io/garden" rel="noopener ugc nofollow" target="_blank">花园</a> &amp; <a class="ae kn" href="https://tilt.dev" rel="noopener ugc nofollow" target="_blank">倾斜</a>。我将展示<code class="du mn mo mp md b">skaffold</code>，因为它是我个人最喜欢的。如果你想更多地了解这些工具是如何脱颖而出的，请查看Liran Haimovitch的这个令人敬畏的综合比较。</p><h2 id="4abd" class="mh kw hi bd kx mw mx my lb mz na nb lf jh nc nd lj ji ne nf ln jj ng nh lr ni bi translated">斯卡福德来救援了</h2><p id="71e2" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">我们当前的目录如下所示:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="f3ed" class="mh kw hi md b fi mi mj l mk ml">$ tree<br/>.<br/>├── Dockerfile<br/>├── k8s<br/>│   ├── db-deployment.yaml<br/>│   └── myservice-deployment.yaml<br/>└── main.go</span></pre><p id="4b38" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">由于它的交互式演练，配置<code class="du mn mo mp md b">skaffold</code>相当简单。<code class="du mn mo mp md b">skaffold init</code>将引导你:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="2f11" class="mh kw hi md b fi mi mj l mk ml">$ skaffold init<br/><strong class="md hj">? Choose the builder to build image myservice</strong>  [Use arrows to move, type to filter]<br/><strong class="md hj">&gt; Docker (Dockerfile)<br/></strong>None (image not built from these sources)</span></pre><p id="5f2a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">将从我们自己的docker文件中构建。点击<code class="du mn mo mp md b">Enter</code>确认选择</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="49ff" class="mh kw hi md b fi mi mj l mk ml">$ skaffold init<br/><strong class="md hj">? Choose the builder to build image myservice</strong> Docker (Dockerfile)<br/><strong class="md hj">? Choose the builder to build image postgres</strong>  [Use arrows to move, type to filter]<br/><strong class="md hj">&gt; None (image not built from these sources)</strong></span></pre><p id="36dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du mn mo mp md b">postgres</code>应该是从DockerHub拉出来的，所以<code class="du mn mo mp md b">None</code>听起来很合理。点击<code class="du mn mo mp md b">Enter</code>确认选择</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="9193" class="mh kw hi md b fi mi mj l mk ml">$ skaffold init<br/><strong class="md hj">? Choose the builder to build image myservice</strong> Docker (Dockerfile)<br/><strong class="md hj">? Choose the builder to build image postgres</strong> None (image not built from these sources)<br/>apiVersion: skaffold/v2beta17<br/>kind: Config<br/>metadata:<br/>  name: dev-on-k-s<br/>build:<br/>  artifacts:<br/>  - image: myservice<br/>    docker:<br/>      dockerfile: Dockerfile<br/>deploy:<br/>  kubectl:<br/>    manifests:<br/>    - k8s/db-deployment.yaml<br/>    - k8s/myservice-deployment.yaml</span><span id="969a" class="mh kw hi md b fi mm mj l mk ml"><strong class="md hj">? Do you want to write this configuration to skaffold.yaml?</strong> (y/N)</span></pre><p id="0e16" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du mn mo mp md b">deploy</code>拿起我们之前生成的两个K8s资源。然而，只有<code class="du mn mo mp md b">myservice</code>将建立在使用我们的<code class="du mn mo mp md b">Dockerfile</code>的变化上。这看起来很合理。用<code class="du mn mo mp md b">y</code>确认</p><p id="67b7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">就是这样！</strong>就像这样，我们或任何与我们合作的人都可以使用<code class="du mn mo mp md b">skaffold dev</code>启动我们的服务，而无需任何预先设置。<code class="du mn mo mp md b">skaffold</code>将观察源文件的变化。一旦发生变化，<code class="du mn mo mp md b">skaffold</code>将使用相应的<code class="du mn mo mp md b">Dockerfile</code>重建映像，并触发新的部署。试试吧！从<code class="du mn mo mp md b">main.go</code>改变第10行记录的信息，观察<code class="du mn mo mp md b">skaffold</code>立即获得改变。如果你需要一些特定的定制，比如端口转发，你可能会在<a class="ae kn" href="https://skaffold.dev/docs/references/yaml/" rel="noopener ugc nofollow" target="_blank">ska fold . YAML参考</a>中找到一个选项。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="661e" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">外环</h1><p id="8439" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">假设我们对我们的服务满意，我们最终希望将它部署到一个动态集群中。最有可能的是，我们希望资源配置在部署环境(如<em class="ik"> local、dev、staging、production </em>)之间稍微有些不同。这就是健壮的配置管理系统发挥作用的地方。</p><p id="2452" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><em class="ik">注意，我们谈论的是配置管理，而不是通常在集群外部的秘密管理。如果你想升级你的秘密管理，看看</em> <a class="ae kn" href="https://www.vaultproject.io" rel="noopener ugc nofollow" target="_blank"> <em class="ik">金库</em> </a> <em class="ik">。</em></p><h2 id="44ea" class="mh kw hi bd kx mw mx my lb mz na nb lf jh nc nd lj ji ne nf ln jj ng nh lr ni bi translated">配置管理:Kustomize aka。kubectl应用-k</h2><blockquote class="if ig ih"><p id="8f4f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">Kustomize让您自定义原始的，无模板的YAML文件的多种用途，留下原来的YAML原封不动和可用。Kustomize使用补丁在现有的标准配置文件上引入特定于环境的变化，而不会干扰它。<br/>-<a class="ae kn" href="https://github.com/kubernetes-sigs/kustomize" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/kustomize</a></p></blockquote><p id="6f95" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">换句话说，Kustomize将名为<code class="du mn mo mp md b">kustomization.yaml</code>的特定于环境的配置文件中指定的补丁应用于原始K8s资源文件。这使得基础设施作为代码原则更加灵活和透明。Kustomize期望的文件结构如下所示:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="625a" class="mh kw hi md b fi mi mj l mk ml">~/someApp<br/>├── base # the raw, unmodified k8s resource files<br/>│   ├── deployment.yaml<br/>│   ├── kustomization.yaml<br/>│   └── service.yaml<br/>└── overlays # the deployment environment specific patches to apply<br/>    ├── development<br/>    │   ├── cpu_count.yaml<br/>    │   ├── kustomization.yaml<br/>    │   └── replica_count.yaml<br/>    └── production<br/>        ├── cpu_count.yaml<br/>        ├── kustomization.yaml<br/>        └── replica_count.yaml</span></pre><p id="b092" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们将我们的简单服务kustomize。目前我们的项目布局如下所示:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="a09a" class="mh kw hi md b fi mi mj l mk ml">$ tree<br/>.<br/>├── Dockerfile<br/>├── k8s<br/>│   ├── db-deployment.yaml<br/>│   └── myservice-deployment.yaml<br/>├── main.go<br/>└── skaffold.yaml</span></pre><p id="875e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">为了使它符合Kustomize的预期结构，我们需要将K8s资源文件移动到一个<code class="du mn mo mp md b">base</code>目录中，并在一个<code class="du mn mo mp md b">kustomization.yaml</code>中注册它们</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="f5a2" class="mh kw hi md b fi mi mj l mk ml">mkdir k8s/base<br/>mv k8s/*.yaml k8s/base/<br/>echo "apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization</span><span id="47de" class="mh kw hi md b fi mm mj l mk ml">resources:<br/>  - db-deployment.yaml<br/>  - myservice-deployment.yaml<br/>" &gt; k8s/base/kustomization.yaml</span></pre><p id="9e6f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">创建特定于环境的补丁就像创建只包含要应用的补丁的<code class="du mn mo mp md b">overlays</code>一样简单。例如，如果我们想要为本地开发环境修补环境变量的值，我们只需要指定YAML的这一特定部分，并在引用我们想要应用修补程序的<code class="du mn mo mp md b">base</code>文件的<code class="du mn mo mp md b">kustomization.yaml</code>文件中注册资源:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="57b9" class="mh kw hi md b fi mi mj l mk ml"># local environment patches<br/>mkdir -p k8s/overlay/local</span><span id="d3fb" class="mh kw hi md b fi mm mj l mk ml">echo "<br/><strong class="md hj">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: myservice<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: myservice<br/>          env:<br/>            - name: NAME<br/>              value: local<br/></strong>" &gt; k8s/overlay/local/myservice-deployment.yaml</span><span id="4d74" class="mh kw hi md b fi mm mj l mk ml">echo "<br/><strong class="md hj">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>patchesStrategicMerge:<br/>  - myservice-deployment.yaml<br/>resources:<br/>  - ../../base</strong><br/>" &gt; k8s/overlay/local/<!-- -->kustomization.yaml</span></pre><p id="79cb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">类似地，如果需要的话，我们可以为试运行和生产环境修补YAML。</p><h2 id="4982" class="mh kw hi bd kx mw mx my lb mz na nb lf jh nc nd lj ji ne nf ln jj ng nh lr ni bi translated">修复内部循环</h2><p id="9022" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">现在我们改变了我们的文件结构，我们打破了先前生成的<code class="du mn mo mp md b">skaffold.yaml</code>。谢天谢地，<code class="du mn mo mp md b">skaffold</code>和<code class="du mn mo mp md b">kustomize</code>是可互操作的，所以重新生成<code class="du mn mo mp md b">skaffold.yaml</code>就像再次运行<code class="du mn mo mp md b">skaffold init</code>一样简单。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="a086" class="mh kw hi md b fi mi mj l mk ml">rm skaffold.yaml<br/>skaffold init</span></pre><p id="2737" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">请注意<code class="du mn mo mp md b">skaffold</code>如何配置其<code class="du mn mo mp md b">deploy</code>阶段以使用kustomize的<code class="du mn mo mp md b">base</code>目录，并为<code class="du mn mo mp md b">local</code>环境追加了一个<code class="du mn mo mp md b">profile</code>:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="4cad" class="mh kw hi md b fi mi mj l mk ml"># skaffold.yaml<br/>apiVersion: skaffold/v2beta12<br/>kind: Config<br/>metadata:<br/>  name: dev-on-k-s<br/>build:<br/>  artifacts:<br/>  - image: myservice<br/>    docker:<br/>      dockerfile: Dockerfile<br/><strong class="md hj">deploy:<br/>  kustomize:<br/>    paths:<br/>    - k8s/base<br/>profiles:<br/>- name: local<br/>  deploy:<br/>    kustomize:<br/>      paths:<br/>      - k8s/overlay/local</strong></span></pre><p id="f0a2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du mn mo mp md b">skaffold dev</code>将默认使用<code class="du mn mo mp md b">base</code>路径。要使用<code class="du mn mo mp md b">local</code>配置，将<code class="du mn mo mp md b">local</code>配置文件指定为CLI标志:<code class="du mn mo mp md b">skaffold dev -p local</code></p><h2 id="69af" class="mh kw hi bd kx mw mx my lb mz na nb lf jh nc nd lj ji ne nf ln jj ng nh lr ni bi translated">外环:GitOps</h2><blockquote class="if ig ih"><p id="9cb4" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">GitOps的核心思想是拥有一个Git存储库，该存储库总是包含生产环境中当前所需的基础设施的声明性描述，以及一个使生产环境与存储库中描述的状态相匹配的自动化过程。如果您想要部署一个新的应用程序或更新一个现有的应用程序，您只需要更新存储库—自动化过程会处理所有其他事情。这就像用巡航控制来管理生产中的应用程序一样。<br/>-<a class="ae kn" href="https://www.gitops.tech" rel="noopener ugc nofollow" target="_blank">https://www . gitops . tech</a></p></blockquote><p id="173d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用Kustomize的YAML资源配置不同的部署环境允许我们对每个配置进行版本控制。这意味着我们的CI/CD管道的CD部分包含的代码不会比</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="8a92" class="mh kw hi md b fi mi mj l mk ml">skaffold run -p &lt;profile&gt;<br/># you will probably specify a dev/staging/production<br/># profile that you want to use here respectively</span></pre><p id="eb89" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">它将构建和测试工件，标记它们并将K8s清单部署到您的集群中。对于更复杂/细粒度的CD管道，考虑不同的<code class="du mn mo mp md b">skaffold</code>调用，如</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="5ab1" class="mh kw hi md b fi mi mj l mk ml">skaffold build --push<br/>skaffold deploy</span><span id="9238" class="mh kw hi md b fi mm mj l mk ml"># or to separate the configuration from<br/># <!-- -->the application's <!-- -->source code</span><span id="4b81" class="mh kw hi md b fi mm mj l mk ml">skaffold render --output render.yaml<br/>skaffold apply render.yaml</span></pre><p id="dad8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><em class="ik">要了解更多关于Skaffold的CI/CD工作流程，请查看他们的</em> <a class="ae kn" href="https://skaffold.dev/docs/workflows/ci-cd/" rel="noopener ugc nofollow" target="_blank"> <em class="ik">超棒的CI/CD文档</em> </a> <em class="ik">。</em></p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="de6f" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">包扎</h1><p id="7457" class="pw-post-body-paragraph ii ij hi il b im lt io ip iq lu is it jh lv iw ix ji lw ja jb jj lx je jf jg hb bi translated">为了清理您的本地环境，<code class="du mn mo mp md b">minikube delete</code>将一次性关闭并清理您的K8s集群。</p><p id="413a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">重申:当使用正确的工具时，Kubernetes上的可再现性和应用程序生命周期管理可以轻而易举。Skaffold和Kustomize提供了一个清晰易懂的工作流程。</p><p id="1cea" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我希望这对任何人都有帮助。欢迎在评论区联系我，或者在twitter上找到我。</p></div></div>    
</body>
</html>
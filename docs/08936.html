<html>
<head>
<title>Part 2: VerneMQ — ACL using MySQL database and cluster setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:VerneMQ —使用MySQL数据库和集群设置的ACL</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-2-vernemq-acl-using-mysql-database-and-cluster-setup-288fb3d2eff8?source=collection_archive---------9-----------------------#2021-11-20">https://medium.com/geekculture/part-2-vernemq-acl-using-mysql-database-and-cluster-setup-288fb3d2eff8?source=collection_archive---------9-----------------------#2021-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/22a72db1860a066d188d18aa2ae6ad62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSNDyGeXLmHBaxRuyvtjYg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Part 2 of the VerneMQ series — access control list using MySQL and cluster setup</figcaption></figure><p id="3f14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本系列文章由3部分组成:</p><p id="046d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" rel="noopener" href="/geekculture/part-1-vernemq-a-great-alternative-9ebf75486e81?sk=5665e157d748ecc249e93a9ce9697ca2"> <strong class="iw hj">第一部分:Verne MQ——一个很好的选择</strong> </a></p><p id="d8f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://josipvojak.com/part-2-vernemq-acl-using-mysql-database-and-cluster-setup-288fb3d2eff8?sk=c53c5b550a48eaef1c77dcdc20a4e0e3" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">第二部分:Verne MQ—使用MySQL数据库的ACL和集群设置</strong> </a></p><p id="c0c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">第3部分:Verne MQ——使用Graphite、Prometheus和Grafana </strong>监控指标(进行中<em class="jt"/>)</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="b1d5" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">修订本</h1><p id="08a7" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">在前一篇文章中:</p><ul class=""><li id="a8b0" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">我们学习了什么是MQTT协议</li><li id="1427" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">在哪里使用</li><li id="7da0" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hj"> VerneMQ </strong>有多棒</li><li id="2f6f" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">我们将它与其他竞争对手进行了比较</li><li id="7e4d" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">我们做了一个简单的本地设置。</li></ul><p id="3912" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们进一步探索两件事:</p><ol class=""><li id="165b" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr ls lk ll lm bi translated">如何通过建立一个MySQL数据库来拒绝到代理的不允许的连接,该数据库将被用作VerneMQ代理(ACL)的访问控制列表。</li><li id="32e4" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr ls lk ll lm bi translated">设置一个<strong class="iw hj">简单集群</strong>——额外的节点相互交织，相互通信，需要时自动同步。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="530a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一般设置</h1><p id="ce15" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">VerneMQ支持两种不同选项的授权和认证:</p><ul class=""><li id="301b" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">使用文件进行授权</li><li id="206a" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">使用数据库进行授权</li></ul><p id="7c40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们将只关注使用数据库的<strong class="iw hj">认证。</strong></p><h2 id="ca60" class="lt kc hi bd kd lu lv lw kh lx ly lz kl jf ma mb kp jj mc md kt jn me mf kx mg bi translated">数据库支持</h2><p id="14a5" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">VerneMQ支持不同的数据库:</p><ul class=""><li id="fc95" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">一种数据库系统</li><li id="1749" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">CockroachDB</li><li id="289e" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">关系型数据库</li><li id="e443" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">MongoDB</li><li id="c57c" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">雷迪斯</li></ul><p id="a085" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将向您展示如何使用MySQL数据库进行身份验证和授权，以及访问控制列表(ACL)。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="479b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">访问控制表</h1><p id="a793" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">提供每个用户拥有的权限和权利列表。</p><p id="2c3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一般来说，ACL定义了每个用户对特定对象的访问权限。</p><p id="39bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们从MQTT客户机/代理逻辑的角度来理解这一点。</p><p id="14ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">MQTT交换消息的主要方式是通过主题。你可以在我的上一篇文章中读到更多的主题。</p><p id="8bd7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，一个主题可能具有如下形式:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="01bc" class="lt kc hi mm b fi mq mr l ms mt">a/b/c</span></pre><p id="d0b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者…</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="10be" class="lt kc hi mm b fi mq mr l ms mt">a/+/c</span></pre><p id="3f74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着下一级(<strong class="iw hj">副标题</strong>)“<em class="jt">a</em>”线程是一个<strong class="iw hj">通配符</strong>——它可以替代一个单词。</p><p id="6ed3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有效的模式是:</p><p id="0ac8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">账户/账户</em></p><p id="7417" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt"> a/josip/c </em></p><p id="bc5b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当发布或订阅一个主题时，区分不同客户端的一般方法是拥有一个唯一的客户端id。</p><p id="f691" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以限制某些客户只能<strong class="iw hj">发布</strong>或<strong class="iw hj">订阅</strong>(写或读)<strong class="iw hj">某些主题</strong>。这就是访问控制列表的价值所在。</p><p id="4dab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基本上，你<strong class="iw hj">定义一个客户列表和他们的限制</strong>(这就是你如何控制你的客户——通过定义一个列表，这就是名字的来源)。</p><p id="7c0a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了使用数据库进行认证和授权，<strong class="iw hj">必须正确配置数据库，并提供认证数据(用户名、客户端id、密码、ACL)</strong>。</p><h2 id="ebb6" class="lt kc hi bd kd lu lv lw kh lx ly lz kl jf ma mb kp jj mc md kt jn me mf kx mg bi translated"><strong class="ak">通用ACL </strong></h2><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="86ea" class="lt kc hi mm b fi mq mr l ms mt">{<br/>  "pattern": "a/+/c"<br/>}</span></pre><p id="7cd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">模式</strong>是一个MQTT主题字符串，它可以包含MQTT通配符，还可以包含模板变量%m(挂载点)、%u(用户名)和%c(客户端ID)，这些变量由提供的auth数据替换。</p><p id="5c0a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过使用ACL，我们可以控制<strong class="iw hj">最大QoS </strong>、<strong class="iw hj">有效负载大小</strong>，如果允许保留<strong class="iw hj">消息的话</strong>，以及其他一些东西(您可以在文档中阅读更多内容: )</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="6371" class="lt kc hi mm b fi mq mr l ms mt">{<br/>  "pattern": "a/+/c",<br/>  "max_qos": 2,<br/>  "max_payload_size": 128,<br/>  "allowed_retain": true<br/>}</span></pre><p id="c260" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，使用ACL，我们只允许数据库中的客户端能够使用相应的用户名和密码访问某些资源。</p><h1 id="fdcd" class="kb kc hi bd kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky bi translated">准备</h1><p id="056a" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">在这里，我将尝试解释为了配置VerneMQ以利用MySQL数据库表作为访问控制列表需要做些什么。这将分为两部分:</p><ul class=""><li id="a492" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><strong class="iw hj"> VerneMQ配置</strong></li><li id="1828" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hj"> MySQL配置</strong></li></ul><h1 id="f74b" class="kb kc hi bd kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky bi translated">VerneMQ配置:</h1><ul class=""><li id="eb21" class="le lf hi iw b ix kz jb la jf mz jj na jn nb jr lj lk ll lm bi translated">使用<strong class="iw hj"> vmq_diversity插件</strong>处理数据库驱动程序，因此需要启用它:(vmq_diversity插件使得使用Lua扩展VerneMQ成为可能)</li></ul><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="e57e" class="lt kc hi mm b fi mq mr l ms mt">plugins.vmq_diversity = on</span></pre><ul class=""><li id="4d5c" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">由于我们使用数据库授权和身份验证，默认启用的基于文件的身份验证和授权很可能是不需要的，应该禁用:</li></ul><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="f479" class="lt kc hi mm b fi mq mr l ms mt">plugins.vmq_passwd = off<br/>plugins.vmq_acl = off</span></pre><p id="166f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">必须设置<em class="jt"> allow_anonymous = off </em>，否则VerneMQ不会使用数据库插件进行认证和授权。</p><ul class=""><li id="1c75" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated">要使用数据库进行身份验证和授权，必须正确配置数据库并提供身份验证数据(用户名、客户端id、密码和ACLS):</li></ul><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="f0d7" class="lt kc hi mm b fi mq mr l ms mt">vmq_diversity.auth_mysql.enabled = on<br/>vmq_diversity.mysql.host = 127.0.0.1<br/>vmq_diversity.mysql.port = 3306<br/>vmq_diversity.mysql.user = vernemq<br/>vmq_diversity.mysql.password = vernemq<br/>vmq_diversity.mysql.database = vernemq_db<br/>vmq_diversity.mysql.password_hash_method = password</span></pre><h1 id="e3cf" class="kb kc hi bd kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky bi translated">MySQL数据库配置</h1><ul class=""><li id="ea9a" class="le lf hi iw b ix kz jb la jf mz jj na jn nb jr lj lk ll lm bi translated">我们需要创建一个名为<em class="jt"> vernemq_db </em>的数据库，用户为<em class="jt"> vernemq </em>，密码为<em class="jt"> vernemq </em>(正如上面的vernemq配置中所述——Verne MQ将使用该配置来尝试连接MySQL数据库):</li></ul><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="b0dc" class="lt kc hi mm b fi mq mr l ms mt">CREATE USER 'vernemq'@'%' IDENTIFIED BY 'vernemq';<br/>GRANT ALL PRIVILEGES ON <em class="jt">.</em> TO 'vernemq'@'%' WITH GRANT OPTION;</span></pre><p id="b826" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于MySQL 8.0以上版本，还需要执行以下操作:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="e7c2" class="lt kc hi mm b fi mq mr l ms mt">ALTER USER 'vernemq'@'%' IDENTIFIED WITH mysql_native_password BY 'vernemq';</span></pre><p id="6965" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">切换到已创建的用户(<em class="jt"> vernemq </em>)，并创建一个新的数据库:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="134d" class="lt kc hi mm b fi mq mr l ms mt">CREATE DATABASE vernemq_db;<br/>USE vernemq_db;</span></pre><p id="413a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建vmq_auth_acl表，VerneMQ代理将使用该表作为访问控制列表。</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="c0a7" class="lt kc hi mm b fi mq mr l ms mt">CREATE TABLE vmq_auth_acl<br/>(<br/>  mountpoint VARCHAR(10) NOT NULL,<br/>  client_id VARCHAR(128) NOT NULL,<br/>  username VARCHAR(128) NOT NULL,<br/>  password VARCHAR(128),<br/>  publish_acl TEXT,<br/>  subscribe_acl TEXT,<br/>  CONSTRAINT vmq_auth_acl_primary_key PRIMARY KEY (mountpoint, client_id, username)<br/>);</span></pre><p id="0fa0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">插入三个客户端:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="f942" class="lt kc hi mm b fi mq mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client', 'test-user', md5('test-password'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span><span id="1ec8" class="lt kc hi mm b fi nc mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client1', 'test-user1', md5('test-password1'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span><span id="d59b" class="lt kc hi mm b fi nc mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client2', 'test-user2', md5('test-password2'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span></pre><p id="de04" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了让一切更简单，我决定把事情复杂化(:D)并使用docker。开个玩笑，我只是继续我在上一篇文章中开始的道路，因为我喜欢保持东西有条理，这有助于我们在不需要的时候轻松地设置或销毁它。</p><p id="d05f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，让我们从创建一个<em class="jt"> docker网络</em>开始，这样我们所有的服务都在同一个网络中运行。姑且称之为'<em class="jt">网络_测试</em>':</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="ec16" class="lt kc hi mm b fi mq mr l ms mt">docker network create network_test</span></pre><p id="e563" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">继续运行一个包含MySQL的新docker容器，并加入之前创建的网络:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="ca17" class="lt kc hi mm b fi mq mr l ms mt">docker run --name=mysql_test --network=network_test -e MYSQL_ROOT_PASSWORD=root_password -d mysql</span></pre><p id="d105" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(如果你没有docker MySQL镜像，你可能需要先做一个<em class="jt"> docker pull mysql </em></p><p id="d840" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用<em class="jt"> docker ps </em>检查集装箱是否运行:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="1d29" class="lt kc hi mm b fi mq mr l ms mt"><br/>|CONTAINER ID| IMAGE | COMMAND | CREATED | STATUS | PORTS | NAMES |</span><span id="7f5d" class="lt kc hi mm b fi nc mr l ms mt">| 8018aea5a395 | mysql | "docker-entrypoint.s…" | About a minute ago | Up About a minute | 3306/tcp, 33060/tcp | mysql_test |<br/></span></pre><p id="c0d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">进入docker容器:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="1382" class="lt kc hi mm b fi mq mr l ms mt">docker exec -it mysql_test bash</span></pre><p id="1c6d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">进入容器后，登录MySQL:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="02cc" class="lt kc hi mm b fi mq mr l ms mt">mysql -u root -p</span></pre><p id="0a50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">密码是root_password(来自容器的环境变量- MYSQL_ROOT_PASSWORD)</p><p id="d80d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们必须创建vernemq用户和vernemq_db数据库:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="0f01" class="lt kc hi mm b fi mq mr l ms mt">CREATE USER 'vernemq'@'%' IDENTIFIED BY 'vernemq';<br/>GRANT ALL PRIVILEGES ON *<em class="jt">.*</em> TO 'vernemq'@'%' WITH GRANT OPTION;</span></pre><p id="1925" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您使用的是MySQL版本8或更高版本，您可能需要这样做:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="481c" class="lt kc hi mm b fi mq mr l ms mt">ALTER USER 'vernemq'@'%' IDENTIFIED WITH mysql_native_password BY 'vernemq';</span></pre><p id="dde0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，退出MySQL并以vernemq用户身份登录</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="78e9" class="lt kc hi mm b fi mq mr l ms mt">mysql -u vernemq -p</span></pre><p id="b92a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(密码是vernemq)</p><p id="4ada" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在将创建一个数据库，创建一个表并创建三个用户:</p><ol class=""><li id="b3de" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr ls lk ll lm bi translated">创建数据库:</li></ol><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="2013" class="lt kc hi mm b fi mq mr l ms mt">CREATE DATABASE vernemq_db;</span><span id="236c" class="lt kc hi mm b fi nc mr l ms mt">USE vernemq_db;</span></pre><p id="9206" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.创建表格</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="a54e" class="lt kc hi mm b fi mq mr l ms mt">CREATE TABLE vmq_auth_acl<br/>(<br/>  mountpoint VARCHAR(10) NOT NULL,<br/>  client_id VARCHAR(128) NOT NULL,<br/>  username VARCHAR(128) NOT NULL,<br/>  password VARCHAR(128),<br/>  publish_acl TEXT,<br/>  subscribe_acl TEXT,<br/>  CONSTRAINT vmq_auth_acl_primary_key PRIMARY KEY (mountpoint, client_id, username)<br/>);</span></pre><p id="07bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.创建三个测试客户端:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="70bd" class="lt kc hi mm b fi mq mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client', 'test-user', md5('test-password'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span><span id="576c" class="lt kc hi mm b fi nc mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client1', 'test-user1', md5('test-password1'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span><span id="b51d" class="lt kc hi mm b fi nc mr l ms mt">INSERT INTO vmq_auth_acl<br/>  (mountpoint, client_id, username,<br/>  password, publish_acl, subscribe_acl)<br/>VALUES<br/>  ('', 'test-client2', 'test-user2', md5('test-password2'),<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]',<br/>  '[{"pattern":"a/b/c"},{"pattern":"c/b/#"}]');</span></pre><p id="43fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们已经配置好MySQL数据库，VerneMQ可以使用它进行授权和认证，broker可以利用新创建的ACL来认证用户并管理他们的权限。</p><p id="58cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，退出MySQL &amp; docker容器(通过键入exit并按enter键)，创建一个文件<em class="jt"> docker-compose.yml </em>，以下是docker的配置:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="3c02" class="lt kc hi mm b fi mq mr l ms mt">version: '3.3'<br/>services:<br/>  vernemq_test:<br/>  image: erlio/docker-vernemq<br/>  container_name: vernemq_test<br/>  restart: always<br/>  environment:<br/>    DOCKER_VERNEMQ_ALLOW_ANONYMOUS: 'off'<br/>    DOCKER_VERNEMQ_PLUGINS.vmq_diversity: 'on'<br/>    DOCKER_VERNEMQ_PLUGINS.vmq_passwd: 'off'<br/>    DOCKER_VERNEMQ_PLUGINS.vmq_acl: 'off'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.auth_mysql.enabled: 'on'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.host: mysql_test<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.port: '3306'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.user: 'vernemq'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.password: 'vernemq'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.database: 'vernemq_db'<br/>    DOCKER_VERNEMQ_VMQ_DIVERSITY.mysql.password_hash_method: 'md5'<br/>    DOCKER_VERNEMQ_ACCEPT_EULA: 'yes'<br/>  ports:<br/>    - '3881:1883'<br/>  expose:<br/>    # Opens port 1883 on the container<br/>    - '1883'<br/>  # Where our data will be persisted<br/>  volumes:<br/>    - /var/lib/<br/>networks:<br/>  default:<br/>    external: true<br/>    name: network_test</span></pre><p id="4576" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后跑</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="8210" class="lt kc hi mm b fi mq mr l ms mt">docker-compose up -d</span></pre><p id="fa89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果没有重大问题(可以使用<em class="jt">docker inspect&lt;container _ name&gt;，docker ps，docker logs&lt;container _ name&gt;</em>进行调试)，应该可以启动并运行了。</p><p id="4109" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们试着测试一下这个场景。如果我们检查上面的ACL，test-client1、test-client2和test-client3能够在a/b/c和c/b/#上发布和订阅。不知道这有没有用。</p><p id="5d96" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为此，我将使用<a class="ae js" href="https://mosquitto.org/" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> mosquitto客户端</em></a><em class="jt"/>(<strong class="iw hj">mosquitto _ sub</strong>和<strong class="iw hj"> mosquitto_pub </strong>命令)。我们可以<strong class="iw hj">连接</strong>或者<strong class="iw hj"> : </strong></p><ul class=""><li id="a11e" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><strong class="iw hj">直接到启动MQTT代理的容器</strong>的端口1883</li><li id="13f0" class="le lf hi iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hj">通过localhost:3881 </strong>因为我们在<em class="jt"> docker-compose.yml </em>中定义了端口3881被转发到相应容器的端口1883。</li></ul><p id="e37a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们先尝试不进行身份验证:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="4291" class="lt kc hi mm b fi mq mr l ms mt"><strong class="mm hj">mosquitto_sub -h localhost -p 3881 -t a/b/c -d</strong></span><span id="7dc4" class="lt kc hi mm b fi nc mr l ms mt">Client (null) sending CONNECT<br/>Client (null) received CONNACK (5)<br/>Connection error: Connection Refused: not authorised.<br/>Client (null) sending DISCONNECT</span></pre><p id="3a87" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们不能，经纪人用一条信息拒绝了我们—</p><p id="c3ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">连接被拒绝:未授权</em>。</p><p id="5418" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们尝试一下身份验证:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="3a9a" class="lt kc hi mm b fi mq mr l ms mt"><strong class="mm hj">mosquitto_sub -h localhost -p 3881 -t a/b/c -d -u test-user -i test-client -P test-password</strong></span><span id="f0db" class="lt kc hi mm b fi nc mr l ms mt">Client test-client sending CONNECT<br/>Client test-client received CONNACK (0)<br/>Client test-client sending SUBSCRIBE (Mid: 1, Topic: a/b/c, QoS: 0, Options: 0x00)<br/>Client test-client received SUBACK<br/>Subscribed (mid: 1): 0</span></pre><p id="ba10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">恭喜你，你可以使用ACL订阅主题了！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="fe4f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">集群设置</h1><p id="3422" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">VerneMQ提供了一种非常简单的方法来创建和管理集群。<strong class="iw hj">客户端能够加入任何集群节点(单个VerneMQ实例)并从任何其他集群节点接收消息。</strong></p><h2 id="d687" class="lt kc hi bd kd lu lv lw kh lx ly lz kl jf ma mb kp jj mc md kt jn me mf kx mg bi translated">状态</h2><p id="8b97" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">这里需要注意的一点是，MQTT代理是一个有状态的应用程序，而VerneMQ集群是一个有状态的集群。这意味着群集节点将共享有关连接的客户端和会话的信息，以及有关群集的其他元数据。</p><p id="8c6b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，如果您停止一个集群节点，VerneMQ集群将知道有一个节点丢失，并将寻找它。</p><p id="df5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果群集重新联机，它会检测到它；然而，如果它再也没有回来，它会<strong class="iw hj">将其检测为永恒的网络分裂</strong>(可以通过让丢失的节点显式离开来移除)。</p><h2 id="1657" class="lt kc hi bd kd lu lv lw kh lx ly lz kl jf ma mb kp jj mc md kt jn me mf kx mg bi translated">如何运行集群？</h2><p id="76d0" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">我们不会在这里讨论太多细节——我只会使用<a class="ae js" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>建立一个最简单的VerneMQ集群。Docker swarm让您轻松设置、扩展、组织和管理Docker引擎集群。您可以通过阅读官方文档了解更多信息。</p><p id="8532" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要运行docker swarm和VerneMQ集群，我们必须<strong class="iw hj">创建一个新配置</strong>并<strong class="iw hj">将其保存到文件</strong>(我将其命名为<em class="jt">docker-compose-cluster . yml</em>)</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="2c60" class="lt kc hi mm b fi mq mr l ms mt">version: "3.7"<br/>services:<br/>  vmq0:<br/>    image: vernemq/vernemq<br/>    environment:<br/>      DOCKER_VERNEMQ_SWARM: 1<br/>      DOCKER_VERNEMQ_ACCEPT_EULA: 'yes'<br/>  vmq:<br/>    image: vernemq/vernemq<br/>    depends_on:<br/>      - vmq0<br/>    environment:<br/>      DOCKER_VERNEMQ_SWARM: 1<br/>      DOCKER_VERNEMQ_DISCOVERY_NODE: vmq0<br/>      DOCKER_VERNEMQ_ACCEPT_EULA: 'yes'<br/>    deploy:<br/>      replicas: 2</span></pre><p id="8ffb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里重要的一点是，您必须有一个<strong class="iw hj">发现节点</strong>，这样其他节点才能加入集群。</p><p id="149f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将<strong class="iw hj"> vmq0 </strong>定义为一个发现节点，并且我们将创建两个额外的节点来加入集群，使得集群中总共有3个节点。</p><p id="a3b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们用以下方式运行:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="ae99" class="lt kc hi mm b fi mq mr l ms mt"><strong class="mm hj">docker stack deploy -c docker-compose-cluster.yml vernemq_cluster</strong></span><span id="7bbb" class="lt kc hi mm b fi nc mr l ms mt">Creating network vernemq_cluster_default<br/>Creating service vernemq_cluster_vmq0<br/>Creating service vernemq_cluster_vmq</span></pre><p id="a912" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您因没有现有的docker群组而出错，您可以使用以下命令创建一个:</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="0079" class="lt kc hi mm b fi mq mr l ms mt">docker swarm init</span></pre><p id="dad7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">再试一次。</p><p id="a5cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您想查看集群的状态，让我们来了解一下。</p><ol class=""><li id="9db4" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr ls lk ll lm bi translated">用docker ps找出vmq0节点的名称。我的是:</li></ol><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="66c7" class="lt kc hi mm b fi mq mr l ms mt">vernemq_cluster_vmq0.1.qnt26xrcfl6xuyifmr3ng91io</span></pre><ol class=""><li id="6de0" class="le lf hi iw b ix iy jb jc jf lg jj lh jn li jr ls lk ll lm bi translated">奔跑</li></ol><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="dc19" class="lt kc hi mm b fi mq mr l ms mt"><strong class="mm hj">docker exec</strong> vernemq_cluster_vmq0.1.qnt26xrcfl6xuyifmr3ng91io <strong class="mm hj">vmq-admin cluster show</strong></span><span id="d3fa" class="lt kc hi mm b fi nc mr l ms mt">+------------------+---------+<br/>| Node             | Running |<br/>+------------------+---------+<br/>| VerneMQ@10.0.2.3 | true    |<br/>+------------------+---------+<br/>| VerneMQ@10.0.2.4 | true    |<br/>+------------------+---------+<br/>| VerneMQ@10.0.2.7 | true    |<br/>+------------------+---------+</span></pre><p id="c44d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">三个节点都在运行。</p><h1 id="07f1" class="kb kc hi bd kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky bi translated">结论</h1><p id="f14b" class="pw-post-body-paragraph iu iv hi iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr hb bi translated">我们学习了如何使用MySQL建立访问控制列表，以及如何使用VerneMQ代理运行集群。虽然一开始可能会有点吓人，尤其是如果您不熟悉术语<strong class="iw hj"> MQTT、broker、ACL、cluster和docker </strong>的话，但是一旦您对文档和概念更加熟悉，就很容易理解和复制了。</p><p id="d1df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然VerneMQ记录了一些事情，但我并不总是能在他们的官方文档中找到答案 — <strong class="iw hj">这就是我想记录这一点并提供运行服务</strong>的不同方式的主要原因(使用<em class="jt"> docker run，docker-compose文件，在容器内使用docker bash，从外部执行命令等等</em>)。</p><p id="c8dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您几乎总是可以只使用一种方式，或者根本不需要使用docker(尽管我发现这更难以理解)。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><figure class="mh mi mj mk fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/d1b8bd8cde894801fd5356240402c2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/1*zxwArJYXUgIvcZjNeHEQLQ.gif"/></div></figure><p id="4b17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你喜欢这篇文章吗？</p><p id="a861" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">给它鼓掌(你可以做50次！).这有助于其他人找到文章，也有助于作者承认他做得很好！让我们看看那些掌声！</p></div></div>    
</body>
</html>
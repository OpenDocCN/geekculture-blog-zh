<html>
<head>
<title>Low-poly Smoke Particles in Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three.js中的低聚烟雾颗粒</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/low-poly-smoke-particles-in-three-js-acd3942fd250?source=collection_archive---------4-----------------------#2022-11-22">https://medium.com/geekculture/low-poly-smoke-particles-in-three-js-acd3942fd250?source=collection_archive---------4-----------------------#2022-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="541c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简短的教程，关于如何在不使用完整粒子系统的情况下制作简单的低多边形粒子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/220e38d6f2596a7d9ef4815c93f7aa94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUAOkcW-2VFwNG--yiY-6Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">I like them colorful</figcaption></figure><h1 id="4782" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">关键要点</h1><ul class=""><li id="d0b9" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">学习使用内置的<code class="du lc ld le lf b">Vector3.lerp</code>功能来减缓物体运动</li><li id="1cc8" class="kr ks hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">了解如何将屏幕坐标转换为世界空间坐标</li></ul><h1 id="5a13" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">现场演示和代码</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="9e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大部分代码和想法都来自这个很酷的代码笔:<a class="ae ln" href="https://codepen.io/vcomics/pen/KBMyjE?editors=0010" rel="noopener ugc nofollow" target="_blank">https://codepen.io/vcomics/pen/KBMyjE?editors=0010</a>作者维克多·维加拉🙇🏻‍♂️，我不久前找到的，还做了书签。我对它进行了改进，增加了统计数据和gui控件。我的代码托管在<a class="ae ln" href="https://github.com/franky-adl/smoke-blobs" rel="noopener ugc nofollow" target="_blank">https://github.com/franky-adl/smoke-blobs</a>。</p><h1 id="358d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">这是如何工作的？</h1><p id="29c3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">这个想法很简单。创建一堆不同大小的球体，然后使用缓动和三角函数来帮助制作类似布朗运动的动画。还添加了雾来创建场景的深度错觉。不需要照明，因为我们只使用<code class="du lc ld le lf b">MeshBasicMaterial</code>。</p><p id="ef47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建球体是容易的部分，但制作伪随机动画有点难。</p><p id="6020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们有一个“种子”球体，它是球体阵列中的第一个球体，作为所有后续球体的运动指南。它随时间以规则的圆形路径运动(暂时忽略<code class="du lc ld le lf b">offset</code>):</p><pre class="je jf jg jh fd lr lf ls bn lt lu bi"><span id="b554" class="lv ju hi lf b be lw lx l ly lz">// the first blob has a regular circular path (x y positions are calculated using the parametric function for a circle)<br/>first_obj.position.set(<br/>  offset.x + Math.cos(elapsed * 2.0),<br/>  offset.y + Math.sin(elapsed * 2.0),<br/>  offset.z + Math.sin(elapsed * 2.0)<br/>)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/4a110075b3e1aac298e136598a827e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdOtwmEWwdjmpBCA9_6PXg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">The parametric function of a circle</figcaption></figure><p id="b396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们使每个下一个球的运动成为其前一个球的函数。所以球体2跟随球体1，球体3跟随球体2，以此类推。有很多方法可以做到这一点，但至少我们必须防止球体过于有规律地跟随它们的同伴，从而导致整体有规律的运动。让事情看起来更随机的一个简单且划算的方法是使用三角函数来计算每个球体的坐标(现在忽略<code class="du lc ld le lf b">offset</code>):</p><pre class="je jf jg jh fd lr lf ls bn lt lu bi"><span id="276f" class="lv ju hi lf b be lw lx l ly lz">object.position.lerp(<br/>  new THREE.Vector3(<br/>    offset.x + Math.cos(object_left.position.x * 3),<br/>    offset.y + Math.sin(object_left.position.y * 3),<br/>    offset.z + Math.cos(object_left.position.z * 3),<br/>  ), params.lerpFactor<br/>)</span></pre><p id="0588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我解释一下这个<code class="du lc ld le lf b">lerp</code>功能是关于什么的。</p><h1 id="0941" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">使用</strong> <code class="du lc ld le lf b"><strong class="ak">lerp</strong></code> <strong class="ak">功能</strong></h1><p id="608b" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">我将原始代码的GSAP补间函数替换为这个内置的lerp函数，我认为这样可以使代码更简洁，并且可以达到几乎相同的效果。lerp因子(封闭区间:[0，1])确定向量向目标向量“lerp”的距离百分比。当以固定的时间间隔使用时，这基本上是一个“放松”动画。我使用了一个非常小的插值因子，这样物体在每一帧中移动的距离就更小了。系数越高，球体的运动越快。要了解更多关于<code class="du lc ld le lf b">lerp</code>的信息，请阅读这里的文档:<a class="ae ln" href="https://threejs.org/docs/#api/en/math/Vector3.lerp" rel="noopener ugc nofollow" target="_blank">https://threejs.org/docs/#api/en/math/Vector3.lerp</a>。</p><p id="9759" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，如果只有两个球体，即使我们使用三角函数，第二个球体仍然会以某种圆形的规则方式运动。这是因为正弦余弦函数给出了规则的波形。</p><p id="27c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果你将球体的数量增加到几十或几百个，这种规律性将很快消失，因为人眼很难跟踪每个球体的运动，加上前面较大的球体阻挡了后面其他球体的视线。</p><h1 id="f3ff" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">将屏幕坐标转换成世界空间坐标</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/b70cb9655d654a3365b96c487ab84ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*pgMOrN1l1GG7lvowpmWo3Q.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">followMouse turned on</figcaption></figure><p id="8f2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还添加了一个“跟随鼠标”复选框，这样当你的鼠标打开时，烟雾就会跟随鼠标。</p><p id="eaa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要做到这一点，您需要一种将鼠标/屏幕坐标转换为世界空间坐标的方法。这不是一个猜谜游戏，因为你希望物体正好在你的鼠标位置上。这需要精确的计算。</p><p id="fa64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，这个代码片段可以帮助我们做到这一点。这个解决方案是由Three.js大师韦斯特兰利提供的🙇🏻‍♂️在<a class="ae ln" href="https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z</a>。</p><p id="9c8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么这个神奇的片段是如何工作的呢？</p><p id="1070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解这一点，我们必须绕一点弯子，回到一些WebGL的基础知识。下面是底层WebGL如何将每个对象从其本地空间转换到最终屏幕空间的管道:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/578a923bebf3d850ebbf955733db1c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6WuMJYoTZ6UVuVvk.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Transformation of coordinate systems, image from <a class="ae ln" href="https://learnopengl.com/Getting-started/Coordinate-Systems" rel="noopener ugc nofollow" target="_blank">https://learnopengl.com/Getting-started/Coordinate-Systems</a></figcaption></figure><p id="c426" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，应用了3个矩阵，但让我们只关注投影矩阵，它将视图空间转换为剪辑空间。视图空间是从相机的角度看到的空间，这就是我在本文中所说的世界空间。(<strong class="ih hj">注意不要把我的世界空间误认为上图中的世界空间。抱歉，我没有别的名字。)由于WebGL的工作方式是，最终它期望摄像机可见平截头体中的所有坐标都映射到NDC(归一化设备坐标)，这是每个维度中范围[-1.0，1.0]的一个框，NDC之外的所有内容都被裁剪掉，不可见。这就是为什么它被称为剪辑空间。请注意，WebGL中NDC的z轴与Three.js的z轴相反。NDC z轴指向屏幕的正方向。</strong></p><div class="je jf jg jh fd ab cb"><figure class="md ji me mf mg mh mi paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/0a3f589e5ea9fd6d0926e00ebf67fa7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*lDBObnqlSVruDwb7sd3Ahw.png"/></div></figure><figure class="md ji mj mf mg mh mi paragraph-image"><img src="../Images/8226b55ec2895a5dea2ddc2e107118c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RGuLXNdzyjb3RaBv3cGGwA.png"/><figcaption class="jp jq et er es jr js bd b be z dx mk di ml mm">Left: the camera’s visible frustum (<a class="ae ln" href="https://threejs.org/manual/#en/cameras" rel="noopener ugc nofollow" target="_blank">img source</a>), Right: the NDC(normalized device coordinates) box (<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection" rel="noopener ugc nofollow" target="_blank">img source</a>)</figcaption></figure></div><p id="ac90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们想将屏幕坐标转换回世界空间(从摄像机看)，我们需要一个函数来将空间转换管道从步骤5反转回步骤3，这意味着转换后的坐标回到视图空间。</p><p id="6218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数写在下面的要点中。这是从我的回购中提取的。我还写了注释来解释每一步是怎么回事。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mn lm l"/></div></figure><p id="0a03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从代码中可以很快看出，你可以将步骤2 <code class="du lc ld le lf b">vec.unproject(camera)</code>作为你的结果，因为它已经将屏幕坐标转换为世界空间坐标，如果你不在乎它的z值的话。在步骤1中，将剪辑空间z设置为1.0越接近(越接近相机的远平面)，得到的贴图世界空间z越负；将剪辑空间z设置为-1.0越近(越靠近摄影机的近平面)，贴图世界空间z就越正。</p><p id="3777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要返回点的指定z平面，只需将<code class="du lc ld le lf b">targetZ</code>传递到函数中。轻松点。</p><p id="5df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，计算出的世界空间坐标被分配给<code class="du lc ld le lf b">mouseWorldSpace</code>，然后被分配给我之前告诉你忽略的<code class="du lc ld le lf b">offset</code>变量。<code class="du lc ld le lf b">offset</code>是让烟雾跟随鼠标位置的东西。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="bada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是了。你一直读到最后，这很值得称赞。我可以告诉你是一个好奇和持之以恒的学习者！希望你能从本教程中学到一些东西，直到下次👋🏼。</p></div></div>    
</body>
</html>
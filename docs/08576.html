<html>
<head>
<title>Why does a code review have to be blocking?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么代码评审必须是阻塞的？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-does-a-code-review-have-to-be-blocking-47622a28f265?source=collection_archive---------17-----------------------#2021-11-06">https://medium.com/geekculture/why-does-a-code-review-have-to-be-blocking-47622a28f265?source=collection_archive---------17-----------------------#2021-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="69fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管在开源项目中非常流行，但是通过拉请求的代码评审的阻塞性质真的对闭源项目有帮助吗？本文探讨了阻塞代码审查的缺点及其替代方法的原因。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6e09ea06456a49e82901f1aa4aa0a425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5oe5KhdPUfPkZtwL"/></div></div></figure><p id="3bec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码审查长期以来一直是并将永远是软件开发生命周期不可分割的一部分。它们和拉请求一起通过开源社区得到了进一步的推广，在开源社区中，贡献者可以针对他们想要引入的变更集提出拉请求，然后存储库的所有者可以审查并接受、请求变更或拒绝PR。自然地，在整个过程完成之前，变更集不会被合并，使得<strong class="ih hj">被阻止</strong>发布。</p><p id="c1c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“拉”请求和代码审查也已经在“封闭的”源代码项目中被积极地采用。但是通过PRs的代码审查的<strong class="ih hj">阻塞</strong>本质真的对闭源项目有帮助吗？我一直建议在团队中进行PRs和代码评审，尤其是在新的(额)团队中。随着时间的推移，随着我读得更多(听得更多)和从其他人的经验中学习，我开始意识到传统的代码审查弊大于利。让我们试着推理一下。</p><p id="ffa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong> : <em class="jp">除非明确声明，否则我将在通过Pull请求(或本文其余部分提到的PR)完成的代码审查的上下文中引用阻塞的代码审查，其中代码等待(因此被阻塞)合并，直到代码审查完成令人满意。</em></p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="7df7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">好的代码评审有什么好处？</h1><p id="2afb" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在我们开始分析代码评审的阻塞风格的缺陷之前，让我们就代码评审(不管是否阻塞)在软件工程中的重要性达成一致。概括地说，良好的代码审查的好处如下:</p><ul class=""><li id="7f80" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">它确保设计和实现在整个项目中保持一致</li><li id="10b4" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">帮助检查代码中的潜在漏洞和逻辑错误。</li><li id="dcc0" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">通过参与者和评审者之间的讨论促进知识共享。</li><li id="d97c" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">帮助根据预期范围和期望结果验证开发的功能。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="4dab" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么，阻止代码审查有什么错呢？</h1><h2 id="a55a" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">1.增加交付周期</h2><ul class=""><li id="eb0c" class="la lb hi ih b ii kv im kw iq mc iu md iy me jc lf lg lh li bi translated">代码审查的大部分假定和公认的好处是以阻止代码进入主干(或主分支)并最终阻止开发人员挑选下一个故事为代价的。这种阻塞会增加提前期，并使反馈回路变得更大。</li><li id="d653" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">不要忘记提到过多的合并冲突，评审“在评审通道中”的时间越长，它将继续积累。</li><li id="98be" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">尽管对交付时间影响最大的是异步通信的上下文切换和开销。(对于提交者和审阅者都一样)。<a class="ae mf" href="https://twitter.com/d_stepanovic" rel="noopener ugc nofollow" target="_blank">Dragan stepanovi</a>在他的一张幻灯片中非常漂亮地解释了这一点:</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="3d80" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">2.阻塞代码评审不是持续集成的。</h2><ul class=""><li id="df67" class="la lb hi ih b ii kv im kw iq mc iu md iy me jc lf lg lh li bi translated">仅仅因为你使用了顶级的“CI/CD”工具，并不能保证你的团队拥有<a class="ae mf" href="https://www.thoughtworks.com/continuous-integration" rel="noopener ugc nofollow" target="_blank">持续集成</a>或<a class="ae mf" href="https://continuousdelivery.com/" rel="noopener ugc nofollow" target="_blank">持续交付</a>。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><ul class=""><li id="3956" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">与特性分支结合使用的拉请求并不意味着持续集成。虽然很少有TBD和CD的热心支持者认为代码在本地主机上保持“足够长的时间”而不是“频繁地”(至少每天一次)推送到远程仍然是本地分支，但我在这里只指长期分支和显式特性分支。</li></ul><blockquote class="mi mj mk"><p id="6a8e" class="if ig jp ih b ii ij ik il im in io ip ml ir is it mm iv iw ix mn iz ja jb jc hb bi translated">“功能分支的设计意图是隐藏更改。持续集成旨在公开变更。这两者是相互排斥的。”<a class="ae mf" href="https://twitter.com/davefarley77" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> @DaveFarley </em> </a></p></blockquote><h2 id="e248" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">3.容易出现“伪橡皮图章”</h2><ul class=""><li id="f3b4" class="la lb hi ih b ii kv im kw iq mc iu md iy me jc lf lg lh li bi translated">没有人想阻挡一个工作单元，阻止它发生。要评审的变更集越关键或越大，评审它就要花费越多的时间。复习花的时间越多，就越堵。在这种情况下，我们更渴望给公关盖上一个“LGTM”的橡皮图章(在我看来不错)，然后让它继续前进。</li><li id="3fd1" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><a class="ae mf" href="https://jellyfish.co/" rel="noopener ugc nofollow" target="_blank">水母</a>做了一个有趣而详细的研究，可以在他们的<a class="ae mf" href="https://jellyfish.co/blog/do-larger-pull-requests-receive-more-comments/" rel="noopener ugc nofollow" target="_blank">博客</a>上看到，研究表明，随着公关规模的增加，讨论量(评论和回复)变化很大。讨论中的差异表明，并非所有减贫战略都得到了应有的重视。因此，并非所有的PRs都如我们最初所希望的那样得到了审查。这恰恰违背了代码评审本身的目的。</li></ul><blockquote class="mi mj mk"><p id="0f70" class="if ig jp ih b ii ij ik il im in io ip ml ir is it mm iv iw ix mn iz ja jb jc hb bi translated"><em class="hi">这并不是说较大的PRs讨论过多或过少，而是说它们的讨论量比较小的PRs有更大的可变性。</em></p></blockquote><ul class=""><li id="8ca1" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">期望个人(而不是团队整体)理解系统本身的所有方面也是不合理的。最终期望他们能够尽职尽责地完成所有关键的代码审查是一种谬论！随着代码和团队规模的增长，这一点开始变得更加明显。</li></ul><blockquote class="mi mj mk"><p id="0305" class="if ig jp ih b ii ij ik il im in io ip ml ir is it mm iv iw ix mn iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">伍兹定理:</em> </strong> <em class="hi">随着一个系统复杂性的增加，那个系统的任何单个智能体自己的模型的准确性迅速降低。</em></p></blockquote><h2 id="eca5" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">4.淡化责任和所有权</h2><ul class=""><li id="8cb4" class="la lb hi ih b ii kv im kw iq mc iu md iy me jc lf lg lh li bi translated">在过度依赖少数资深人员(可能是技术领导或架构师)来进行关键评审的团队中，不仅会有更大的瓶颈，而且会让这些资深人员忙得不可开交，使他们自己无法从事其他有意义和重要的工作。</li><li id="7877" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">当代码被提交审查时，代码的所有权从最初的开发人员(编写代码的人)转移到审查人员。这可能是一个挑战。这给了开发人员一个错误的信号，即他们的工作已经“完成”。实际上，直到发布并在部署后对其进行简单的监控之后，它才得以完成。其他任何“做”真的只是一个门面！</li></ul><h2 id="6756" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">5.阻碍团队间有效的知识共享</h2><p id="01c1" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">长期以来，社区中一直在争论和提倡代码评审有助于团队内部的知识共享。通过代码评审，团队不仅与编码和设计的一致性保持一致，而且发现和分享新的更好的技术来做事。另外，我认为模块化和异步的代码评审通常与知识共享是对立的。</p><ul class=""><li id="6dd2" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">对于异步代码评审，大多数参与代码评审的开发人员都知道这些对话。很可能其他团队成员会重复同样的错误/模式，除非整个团队都意识到这一点。</li><li id="3295" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">在大多数情况下，异步代码评审时的知识共享已经太晚了！这是被动的，而不是主动的。如果知识是预先共享的(并与整个团队共享)，花在审查和验证一致性和设计上的时间就可以节省下来并得到更好的利用。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="885c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我们能以不同的方式做事吗？</h1><p id="becb" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">毫无疑问，我们都同意代码审查很重要。我们还推理了在以分块和异步的方式进行代码评审时的某些陷阱。这是路的尽头吗？还是我们可以做些不同的事情来减少陷阱，同时仍然获得我们一开始就想获得的好处？</p><h2 id="8a2b" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">1.结对编程和持续代码审查</h2><p id="797e" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">使用pair/mob编程，您可以获得关于代码的持续和即时的反馈。对每一行代码的审查都是实时进行的。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><ul class=""><li id="3a09" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">最少发生上下文切换。在给定的时间内，这两个人或一群人唯一的职责就是他们正在工作的代码。在他们编码和推理的同时进行同步审查是一个巨大的奖励！</li><li id="4f84" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">没有等待审查，然后做出改变，并再次得到审查。大多数情况下，周期更长。通过结对或围殴，每个参与者都一直在场。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><ul class=""><li id="6acb" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">交付时间大大缩短。</li></ul><h2 id="7858" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">2.轮换你的搭档</h2><ul class=""><li id="149b" class="la lb hi ih b ii kv im kw iq mc iu md iy me jc lf lg lh li bi translated">有效的结对轮换有助于将知识孤岛降至最低。</li><li id="1178" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">经常更换观察进展中的功能的眼睛可以带来新的视角，也可以发现以前隐藏的东西。</li><li id="118d" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">让软件成为一种共享的社会责任。</li></ul><h2 id="d36d" class="lo jy hi bd jz lp lq lr kd ls lt lu kh iq lv lw kl iu lx ly kp iy lz ma kt mb bi translated">3.主持人“展示和讲述”</h2><p id="7106" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在你的团队中经常组织“展示和讲述”。</p><ul class=""><li id="c417" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">多谈谈设计愿景。</li><li id="34ce" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">展示你发现的新的实现技术。</li><li id="4bb2" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">谈论理想的代码编写方式。</li><li id="4980" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">讨论你的代码随着时间积累的债务，以及如何处理。</li><li id="ca11" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">同样重要的是，展示从代码失败和错误中学到的东西。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="12fa" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">你说结对编程是银弹？</h1><p id="d9f7" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">嗯，这是一个反问。如果每个团队和每个组织都可以通过结对和群殴来工作，我们会比现在更经常地看到这种情况。</p><p id="1947" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在几种情况下，结对编程或群殴可能无效:</p><ul class=""><li id="d87a" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">缺乏适当的基础设施和工具。</li><li id="dac9" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">这些团队的杠杆率高于应有水平。团队中经验水平和任期的比例是不均衡的。</li><li id="3b19" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">有多个(有时甚至两个就足够了)地理上分离的团队。这些团队相互依赖，既不是真正分布式的，也不是自治的。</li><li id="6f74" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">低到没有心理安全感。在心理安全度较低的环境中，配对可能是一项令人生畏的任务。它可以被理解为“被监视”或“被监视”。</li><li id="b2be" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">不理解实用配对的团队。并把它当成教条！</li><li id="b4cb" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">关键的代码评审，比如关于治理和遵从性(通常与安全性相关)，并且在组织/团队中只有少数人具有完整的知识。</li><li id="43ed" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">如果没有按照双方同意的配对时间和休息时间完成，会导致疲劳。</li></ul></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="66f3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结束语…</h1><p id="ba8c" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">本文的目的不是建议采取一种绝对主义的方法。我理解为“看情况”。我知道一种方法可能不适用于不同的工程团队。我也理解同样的方法可能并不总是适用于同一个团队。</p><p id="1d77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章更像是试图强调团队在采用阻塞式代码评审时所继承的权衡。这些权衡可能并不适用于每种类型的代码评审。也许很少有人比大多数人需要更多的关注。我的建议是谨慎选择。不要把它当成教条！明智地运用你的判断力！</p></div></div>    
</body>
</html>
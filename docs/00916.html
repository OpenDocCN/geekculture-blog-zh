<html>
<head>
<title>Data Structure in Swift: Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的数据结构:链表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-structure-in-swift-linked-list-136d0975e081?source=collection_archive---------10-----------------------#2021-03-19">https://medium.com/geekculture/data-structure-in-swift-linked-list-136d0975e081?source=collection_archive---------10-----------------------#2021-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e685" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本文中，我想总结一下我使用Swift学习链表数据结构的经验。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4228c0c4f251bcc7800e90fcd530107d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KjeetE_igWtcIRR4"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@nateggrant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nate Grant</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="e437" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">概观</h2><p id="9f61" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">链表基本上是对象的集合，其中每个对象(通常称为节点)都有对下一个节点的引用。你可以把链表想象成一条链。下面是链表表示法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/b17d3a616e70250602a86d9ddb301e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BBe-wHUupA6kSeSk.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Source: <a class="ae jn" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/data-structures/linked-list/</a></figcaption></figure><p id="2d0f" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">节点对象保存数据和对下一个节点的引用。第一个节点叫<code class="du ll lm ln lo b">Head</code>，最后一个节点叫<code class="du ll lm ln lo b">Tail</code>。在上图中，它通常被称为常规链表。还有一些其他类型的链表，如双向链表，其中每个节点保存下一个引用和上一个引用，以及循环链表，其中从尾部开始的下一个引用是头部。</p><p id="ff49" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">下面是用Swift编写的节点对象实现:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="46ce" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">我们可以使用通用实现，这样节点对象可以保存任何数据类型。这个类也符合<code class="du ll lm ln lo b">CustomStringConvertible</code>，只是为了让我们通过获取它的描述来打印链表数据变得更容易。</p><p id="7e85" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">下面是用Swift编写的链表实现:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="9899" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">在链表类中，它有两个可选属性，分别是<code class="du ll lm ln lo b">head</code>和<code class="du ll lm ln lo b">tail</code>。头部是列表中的第一个节点，尾部是列表中的最后一个节点。同样，为了让我们的生活变得更容易，我扩展了链表类以符合<code class="du ll lm ln lo b">CustomStringConvertible</code>协议。我们可以通过调用<code class="du ll lm ln lo b">description</code>值来打印列表。</p><p id="3fea" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">最后，我们已经创建了节点和链表类，让我们进行一些测试:</p><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="6aff" class="jo jp hi lo b fi lv lw l lx ly"><strong class="lo hj">let</strong> node = Node&lt;Int&gt;(value: 0)</span><span id="66fb" class="jo jp hi lo b fi lz lw l lx ly"><strong class="lo hj">let</strong> node2 = Node&lt;Int&gt;(value: 1)</span><span id="c891" class="jo jp hi lo b fi lz lw l lx ly"><strong class="lo hj">let</strong> node3 = Node&lt;Int&gt;(value: 2)</span><span id="d4f4" class="jo jp hi lo b fi lz lw l lx ly">node.next = node2</span><span id="fb13" class="jo jp hi lo b fi lz lw l lx ly">node2.next = node3<br/></span><span id="f374" class="jo jp hi lo b fi lz lw l lx ly"><strong class="lo hj">let</strong> ll = LinkedList&lt;Int&gt;(head: node)</span><span id="2895" class="jo jp hi lo b fi lz lw l lx ly">// result<br/><strong class="lo hj">Optional(0 -&gt; 1 -&gt; 2)</strong></span><span id="461a" class="jo jp hi lo b fi lz lw l lx ly">print(ll) <br/></span></pre><p id="1073" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">恭喜你，你已经知道如何从链表数据结构创建基本功能。让我们通过添加一些功能来改进这个实现。</p><h2 id="7f3f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">推送操作</h2><p id="431b" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">推送操作是在前端添加新节点——或者换句话说，我们添加新节点并使其成为新的头。这个操作的复杂度应该是O(1 ),因为我们只需要知道当前的<code class="du ll lm ln lo b">head</code>是否存在。如果当前的<code class="du ll lm ln lo b">head</code>为空，那么我们可以直接插入新的节点并使其成为新的<code class="du ll lm ln lo b">head</code>，如果当前的<code class="du ll lm ln lo b">head</code>存在，那么我们可以创建新的节点并将引用传递给旧的<code class="du ll lm ln lo b">head</code>，并使新的节点成为新的<code class="du ll lm ln lo b">head</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="43c6" class="jo jp hi lo b fi lv lw l lx ly"><strong class="lo hj">let</strong> ll = LinkedList&lt;Int&gt;()</span><span id="8d2b" class="jo jp hi lo b fi lz lw l lx ly">ll.push(value: 3)</span><span id="aa70" class="jo jp hi lo b fi lz lw l lx ly">ll.push(value: 2)</span><span id="ca07" class="jo jp hi lo b fi lz lw l lx ly">ll.push(value: 1)</span><span id="378e" class="jo jp hi lo b fi lz lw l lx ly">print(ll) // <strong class="lo hj">Optional(1 -&gt; 2 -&gt; 3)</strong></span></pre><h2 id="d1bc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">追加操作</h2><p id="9303" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">另一个操作是追加。追加是在列表的最后添加新节点并使其成为新的<code class="du ll lm ln lo b">tail</code>的操作。它的复杂度为O(n ),因为它需要迭代到列表的末尾。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><pre class="iy iz ja jb fd lr lo ls lt aw lu bi"><span id="9188" class="jo jp hi lo b fi lv lw l lx ly"><strong class="lo hj">let</strong> ll = LinkedList&lt;Int&gt;()</span><span id="3d49" class="jo jp hi lo b fi lz lw l lx ly">ll.append(value: 1)</span><span id="2ac5" class="jo jp hi lo b fi lz lw l lx ly">ll.append(value: 2)</span><span id="8620" class="jo jp hi lo b fi lz lw l lx ly">ll.append(value: 3)</span><span id="967f" class="jo jp hi lo b fi lz lw l lx ly">print(ll) // 1 -&gt; 2 -&gt; 3</span></pre><p id="434a" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">第一步是我们需要检查链表是否为空。如果列表是空的，那么我们可以调用之前已经创建的push函数。如果列表不为空，那么我们可以在第一时间创建一些变量来保存列表的<code class="du ll lm ln lo b">head</code>。然后我们可以使用While循环迭代节点，条件是<code class="du ll lm ln lo b">current</code>不为零。在循环内部，我们检查<code class="du ll lm ln lo b">next</code>是否不为零，然后我们用<code class="du ll lm ln lo b">next</code>引用赋值<code class="du ll lm ln lo b">current</code>。如果<code class="du ll lm ln lo b">next</code>为零，那么我们知道<code class="du ll lm ln lo b">current</code>是一个<code class="du ll lm ln lo b">tail</code>，所以我们可以将<code class="du ll lm ln lo b">current</code>分配给<code class="du ll lm ln lo b">newNode</code>的下一个，并将其作为一个新的<code class="du ll lm ln lo b">tail</code>。</p><h2 id="7297" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">操作时插入</h2><p id="3055" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">插入操作是在给定的索引处添加新的节点。实现可能类似于追加操作，我们迭代，直到我们满足给定的索引。我们可以创建一个变量作为计数器，并检查计数器是否与给定的索引相同，然后将节点插入到那里。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="564b" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">这次的实现有点复杂。但是让我们分解代码:</p><ol class=""><li id="d29c" class="ma mb hi ko b kp lg ks lh jz mc kd md kh me le mf mg mh mi bi translated">第一次，我们需要检查索引是否大于0，列表是否不为空。如果索引为0或者列表为空，那么我们可以调用之前已经创建的push函数</li><li id="aba6" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated">就像append操作一样，我们创建变量来保存head作为第一个节点。此时，我们还创建了<code class="du ll lm ln lo b">counter</code>变量和<code class="du ll lm ln lo b">prev</code>来保存循环开始时的前一个节点。稍后，当我们已经插入新节点时，需要使用<code class="du ll lm ln lo b">prev</code>变量来设置新的引用。</li><li id="34e9" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated">在循环内部，我们检查<code class="du ll lm ln lo b">index</code>是否与<code class="du ll lm ln lo b">counter</code>不同。如果<code class="du ll lm ln lo b">index</code>和<code class="du ll lm ln lo b">counter</code>已经相同，那么我们设置<code class="du ll lm ln lo b">current</code>节点旁边的<code class="du ll lm ln lo b">newNode</code>，下一个<code class="du ll lm ln lo b">prev</code>设置为<code class="du ll lm ln lo b">newNode</code>。</li><li id="a15c" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated">该代码检查当前<code class="du ll lm ln lo b">next</code>是否为零，但给定的索引与计数器不一致。你可以想象一下，如果我们的链表中只有3个数据，而给定的索引是5。在这种情况下，我们只需要像append操作一样添加新节点作为尾部。</li><li id="b419" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated">如果给定的索引仍然与计数器不相同，并且当前的next不为零，则循环必须继续。我们用<code class="du ll lm ln lo b">current</code>指定<code class="du ll lm ln lo b">prev</code>值，用<code class="du ll lm ln lo b">next</code>参考指定<code class="du ll lm ln lo b">current</code>，并递增<code class="du ll lm ln lo b">counter</code>。</li></ol><h2 id="15c7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">挑战</h2><p id="eeda" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">是的，您已经实现了一些重要的功能，如push、append和insert at操作。让我们给你一些挑战作为家庭作业。</p><ol class=""><li id="bcff" class="ma mb hi ko b kp lg ks lh jz mc kd md kh me le mf mg mh mi bi translated"><strong class="ko hj">在操作中删除</strong></li><li id="4e35" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated"><strong class="ko hj">获取中间节点</strong></li><li id="94fd" class="ma mb hi ko b kp mj ks mk jz ml kd mm kh mn le mf mg mh mi bi translated"><strong class="ko hj">反向链表</strong></li></ol><p id="fdc0" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">如果你想认真学习链表，我鼓励你接受挑战，自己尝试一下。如果你卡住了，那么你可以回到这里，看看我的实现。</p><h2 id="f3da" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">在解决方案时删除</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h2 id="6fba" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">获取中间节点解决方案</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h2 id="34ae" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">反向链表解决方案</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h2 id="4580" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h2><p id="66f7" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">祝贺您关注这篇文章。你是知道链表的高手:】。你可能不会在日常项目中使用链表，但是作为一名软件工程师，知道这一点对你是有好处的。我可能会在另一个时间写另一个数据结构。如果你对这篇文章满意，请鼓掌并给我一些反馈:】。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Quest Syntax Tree and remedy Code Smell using JAPA Visitor Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JAPA访问者模式的任务语法树和补救代码味道</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/quest-syntax-tree-and-remedy-code-smell-using-japa-visitor-patterns-f023a89842cf?source=collection_archive---------35-----------------------#2021-08-18">https://medium.com/geekculture/quest-syntax-tree-and-remedy-code-smell-using-japa-visitor-patterns-f023a89842cf?source=collection_archive---------35-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3f8f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">抽象语法树和Java解析器框架</h2><div class=""/><div class=""><h2 id="8db7" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">简单的自动化:使用Visitor遍历抽象语法树</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/8ecb10ed7e6e7fb9cd43f18afba8f6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nbBhccb3XavH9Hva6ZWv-Q.gif"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Structure of Abstract Syntax Tree — Java Parser Framework Visitor Pattern</figcaption></figure><h1 id="56e5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">范围</h1><p id="626b" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">写这篇文章是为了帮助<strong class="kq hs"> <em class="lk">初学者</em> </strong>和<strong class="kq hs"> <em class="lk">中级</em> </strong>理解<em class="lk">抽象语法树</em>、<em class="lk"> Java解析器框架</em>、<em class="lk">访问者模式</em>的结构。<br/>上面的动画图显示了<em class="lk">应用程序接口</em> ( <strong class="kq hs"> <em class="lk"> API </em> </strong>)的<strong class="kq hs"> <em class="lk">部分列表</em> </strong>，在本文中使用它们来演示如何使用访问者模式通过<em class="lk">自动化来处理<em class="lk">代码气味</em>。<br/>文章以<strong class="kq hs"> <em class="lk">现场动手</em> </strong>实例[<a class="ae ll" href="https://github.com/ganesh-nag/AbstractSyntaxTree" rel="noopener ugc nofollow" target="_blank"><strong class="kq hs"><em class="lk">GitHub</em></strong></a>]为后盾，具体编写并测试，解释各种组件如何交互及其用途。屏幕截图和解释有助于理解细微差别。</em></p><h1 id="3b09" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">先决条件(最低)</h1><p id="4cd8" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">如果读者希望尝试一下，<em class="lk">这里有先决条件！</em><br/><em class="lk">a . Spring Boot-Maven依赖<br/>Java parser-1 . 0 . 11 . jar<br/>b . sonar cube-8.0<br/>c . sonar-scanner-4 . 2 . 0 . 1873-windows<br/>d . Eclipse IDE(或)您选择的任何IDE<br/>e . Java SE平台v1.8 </em></p><h1 id="905a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">这篇文章的重点是什么？</h1><h2 id="c5d9" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">一些基本的开始..</h2><p id="1c40" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">一个Java源文件(<em class="lk">)。java </em>)必须遵守java语言规范(<strong class="kq hs"> <em class="lk"> JLS </em> </strong>)。如果<strong class="kq hs"> <em class="lk">不符合</em> </strong>与<strong class="kq hs"> <em class="lk"> JLS规范</em> </strong>，声纳扫描仪之类的工具可以捕捉<strong class="kq hs"> <em class="lk">代码气味</em> </strong>，并提供源文件中发现的不符合<strong class="kq hs"><em class="lk"/></strong>的列表作为要遵守的<strong class="kq hs"> <em class="lk">规则</em> </strong><br/>  在<strong class="kq hs"> <em class="lk"> </em> </strong>这篇文章中我们用<em class="lk">声纳扫描仪</em>来扫描(<em class="lk">)。java) </em>源文件和<em class="lk">声纳服务器</em>来获取在仪表板中发布的报告。</p><h2 id="e3c6" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">术语？？</h2><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lz"><img src="../Images/740b47114e4d6b1c2864da58ec1f68d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*J3_9MazfsoKPyVvbaAdRww.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Terminology ??</figcaption></figure><p id="3351" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><strong class="kq hs"><em class="lk"/></strong>a .<strong class="kq hs"><em class="lk">【可维护性】<br/> </em> </strong> <em class="lk">下面的术语可以在声纳服务器仪表盘中看到。<br/>(一)</em> <strong class="kq hs"> <em class="lk">代码气味，</em> </strong>是一个<strong class="kq hs"> <em class="lk"> </em> </strong>代码中与可维护性相关的问题。让它保持原样意味着维护者将很难对代码进行修改。在最坏的情况下，他们会被代码的状态弄得晕头转向，以至于在修改时会引入额外的错误。<br/> <em class="lk">(二)</em> <strong class="kq hs"> <em class="lk">规则</em> </strong>，为每个问题提供了一个<em class="lk">唯一的规则号</em>和一个关于可维护性的问题描述。规则编号以<strong class="kq hs"> <em class="lk"> S. <br/> </em> </strong>规则具体到<strong class="kq hs"> <em class="lk"> Java SE平台</em> </strong>大约是<strong class="kq hs"> <em class="lk"> 547到date。</em>T41】</strong></p><h2 id="8292" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">让我们了解手动与自动化</h2><p id="d699" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated"><strong class="kq hs"> <em class="lk">手动<br/> </em> </strong>顾名思义，基于仪表盘中生成的声纳报告，源文件<strong class="kq hs"> <em class="lk">的<em class="lk">作者/开发者</em>要按照JLS规范手动修正</em> </strong>的代码气味。<br/>重新运行声纳扫描仪，并重新访问声纳服务器仪表板，查看是否已达到合规级别。<br/> <strong class="kq hs"> <em class="lk">自动化<br/> </em> </strong>在自动化中，<em class="lk">作者/开发者</em> <strong class="kq hs"> <em class="lk">无需</em> </strong>手动执行代码修正过程，而是使用Java解析器框架和访问者模式来<em class="lk">自动化</em>和<em class="lk">遍历<em class="lk">抽象语法树</em> ( <strong class="kq hs"> <em class="lk"> AST </em><br/> <em class="lk">声纳扫描器</em>可以通过<strong class="kq hs"> <em class="lk">编程方式</em> </strong>在需要时随时运行以捕获结果源代码，而<em class="lk">声纳服务器</em>的报告可以通过<strong class="kq hs"> <em class="lk"> WEB API </em> </strong>进行检索以进一步处理。</strong></em></p><h1 id="3794" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">让我们通过几个用例来理解</h1><p id="69ac" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">本文将用代码示例演示<strong class="kq hs"> <em class="lk"> 2规则</em> </strong>。让我们首先理解规则，然后它应该给出一个自动化是如何完成的想法。</p><h1 id="0faf" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">用例1</h1><h2 id="96dd" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">1.<strong class="ak">规则<em class="mf"> S1118 </em>规则</strong></h2><p id="8db8" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">本规则<strong class="kq hs"> <em class="lk"> </em> </strong>状态、<strong class="kq hs"><em class="lk"/></strong><strong class="kq hs"><em class="lk">实用程序类不应该有公共构造函数</em> </strong>。<br/> a .这么说吧，a ( <em class="lk">)。java) </em>文件用<strong class="kq hs"> <em class="lk">静态</em> </strong>方法创建。<br/> b .一个<strong class="kq hs"> <em class="lk">类</em> </strong>用<strong class="kq hs"><em class="lk"/></strong>静态方法调用为<em class="lk"> ClassName.methodName() </em>。<br/> c .即使没有指定构造函数，也有一个<em class="lk">隐式无参数</em>公共构造函数可用。<br/>当源文件进行可维护性度量检查时，声纳扫描仪扫描并将结果上传到声纳服务器仪表板。这导致了规则S1118突出显示的问题。</p><p id="6943" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><strong class="kq hs">什么是修复？</strong> <br/> <strong class="kq hs"> <em class="lk">修复方法是，</em> </strong> <em class="lk"> </em> <br/> a .由于有一个隐式无参公共构造函数可用，所以通过自动化创建一个私有构造函数，并将其作为<strong class="kq hs"><em class="lk"/></strong>成员插入到类中。这将确保实用程序类<strong class="kq hs"> <em class="lk">不会使用<strong class="kq hs"> <em class="lk">新的</em> </strong>操作符实例化</em> </strong>。<br/> b .如果<strong class="kq hs"> <em class="lk">作者/开发者</em> </strong>在utility类中创建了一个公共构造函数，那么通过自动化将构造函数的<strong class="kq hs"> <em class="lk">修饰符</em> </strong>从<strong class="kq hs"> <em class="lk">公共</em> </strong>改为<strong class="kq hs"> <em class="lk">私有</em> </strong>。</p><h1 id="36ba" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">用例2</h1><h2 id="8b84" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">2.规则S106</h2><p id="f292" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">规则规定，<strong class="kq hs"> <em class="lk">“标准输出不应该直接用来记录任何东西”<br/> </em> </strong> a .假设，a ( <em class="lk">)。java </em>文件包含<strong class="kq hs"><em class="lk">system . out . println()</em></strong>语句。<br/> b .声纳扫描后，声纳服务器将突出显示规则S106。</p><p id="5330" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><strong class="kq hs">什么是修复？</strong> <br/> <strong class="kq hs"> <em class="lk">修复是，<br/></em></strong>a .<strong class="kq hs"/>用<strong class="kq hs"> <em class="lk"> Logger </em> </strong>替换<strong class="kq hs"><em class="lk">system . out . println()</em></strong>语句。<br/> b .强烈建议定义和使用专用记录器。</p><h2 id="6df3" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated"><strong class="ak">自动化如何帮助实现上述修复？</strong></h2><p id="bca5" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">a.<strong class="kq hs"><em class="lk">【AST】</em></strong>抽象语法树是源文件的树形表示。这里的<strong class="kq hs">(<em class="lk">)。java) </em> </strong>源文件将以语法树结构查看。<br/> b. <strong class="kq hs"> <em class="lk">访问者模式</em> </strong>是提供松散耦合和灵活性的行为设计模式。<br/>访问者模式提供抽象语法树【应用程序接口】(<strong class="kq hs"> <em class="lk"> API </em> </strong>)访问源文件结构。本文顶部显示的<strong class="kq hs"> <em class="lk">动画图</em> </strong>显示了可用于解决给定用例的最小<strong class="kq hs"> <em class="lk"> API </em> </strong>。</p><h2 id="0fdc" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated"><strong class="ak">让我们访问几个API并了解它们的用途</strong></h2><ol class=""><li id="d77e" class="mg mh hi kq b kr ks ku kv kx mi lb mj lf mk lj ml mm mn mo bi translated"><strong class="kq hs"><em class="lk">compilation unit</em><br/></strong>Java解析器对象会读取源文件(<strong class="kq hs"> <em class="lk">)。java </em> </strong>)编译成一个编译单元。因此，编译单元对象包含按照JLS规范需要遵守的源代码。</li><li id="77ec" class="mg mh hi kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><strong class="kq hs"><em class="lk">class or interface declaration</em><br/></strong>一个<strong class="kq hs"> </strong>编译单元<strong class="kq hs"> </strong>包含一个<strong class="kq hs"> <em class="lk">类</em> </strong> <em class="lk">或</em> <strong class="kq hs"> <em class="lk">接口。</em> </strong>这叫做<em class="lk">类型声明</em>。每个<strong class="kq hs"> <em class="lk">类</em> </strong> <em class="lk">或</em> <strong class="kq hs"> <em class="lk">接口</em> </strong>包含<strong class="kq hs">主体</strong>，称为<em class="lk">主体声明</em>。</li><li id="ab72" class="mg mh hi kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><strong class="kq hs"> <em class="lk">方法声明<br/> </em> </strong>一个体声明包含<strong class="kq hs"> <em class="lk">方法</em> </strong>和<strong class="kq hs"> <em class="lk">构造函数。</em>T84】</strong></li><li id="5529" class="mg mh hi kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><strong class="kq hs"><em class="lk">block stmt<br/></em></strong>一个block语句在一个<strong class="kq hs"> <em class="lk">类</em> </strong> <em class="lk">或</em> <strong class="kq hs"> <em class="lk">构造函数</em> </strong>中以花括号<strong class="kq hs"> <em class="lk"> { } </em> </strong>开始和结束，它包含<strong class="kq hs"> <em class="lk">语句</em> </strong>和<strong class="kq hs"> <em class="lk">表达式</em></strong></li><li id="150f" class="mg mh hi kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><strong class="kq hs">表达式tmt <br/> </strong>表达式语句包含<strong class="kq hs"> <em class="lk">表达式</em> </strong>。<strong class="kq hs"> </strong> <em class="lk">例如:</em><strong class="kq hs"><em class="lk">name expr</em></strong>。</li></ol><h1 id="8654" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">让我们了解一下实际操作的代码和涉及的组件</h1><p id="d11f" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated"><em class="lk"> a. </em> <strong class="kq hs"> <em class="lk">启动声纳服务器<br/> </em> </strong> <em class="lk">这里我已经创建了声纳服务器执行作为一个插件项目，并将其添加到Eclipse中。也可以从安装文件夹的命令提示符下启动。</em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/2beedcf1cba5f9ed76517d3ad01f3601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEEwTEcVuIQpRRPP7IseuA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Sonar Server started</figcaption></figure><p id="7596" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><em class="lk"> b. </em> <strong class="kq hs"> <em class="lk">声纳服务器仪表盘</em> </strong></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mu"><img src="../Images/507d457ffbc6291c9e03ba2d57aff8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIykCm1hBorT_1SJErV-3A.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Sonar Server Dashboard</figcaption></figure><h2 id="0ba3" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">SampleTest项目[自动化之前]</h2><p id="1bc1" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">c.<strong class="kq hs"><em class="lk">SampleApp.java<br/></em></strong>为了演示本文，我创建了下面的带有代码味道的源文件，它涵盖了前面章节中解释的<strong class="kq hs">用例1 </strong>和<strong class="kq hs">用例2 </strong>。<br/> <em class="lk">这个源文件是在eclipse </em>中单独的Java项目 <strong class="kq hs"> <em class="lk">(样本测试项目)</em> </strong> <em class="lk">中创建的。<br/> <em class="lk">源文件</em><strong class="kq hs"><em class="lk">(SampleApp.java)</em></strong><em class="lk">将被输入到另一个Java项目</em> <strong class="kq hs"> <em class="lk"> (Java解析器项目)</em> </strong> <em class="lk">其中</em>将执行自动化<em class="lk">到</em>修复代码气味<em class="lk">。</em></em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mv"><img src="../Images/7759ebbae9979becf1d3df58b15acc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D78wfCtmZseo3y--_GBsjg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">SampleApp.java — Before Automation</figcaption></figure><h2 id="9860" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">JavaParser项目—自动化</h2><p id="a2ff" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">d.<strong class="kq hs"><em class="lk">CheckCodeQuality.java包含以下执行自动化的方法。</em> </strong> <em class="lk"> <br/> 1。</em><strong class="kq hs"><em class="lk">createCompilationUnit()</em></strong>方法会解析(<em class="lk">)。java) </em>源文件来自<strong class="kq hs"> SampleTest项目</strong>并创建一个编译单元。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/5e5a0bfcdcd7e40080cf28cb5c26673d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQUlivrbdevFCd2qw2H8KA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">createCompilationUnit()</figcaption></figure><p id="1c5d" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">2.<strong class="kq hs"><em class="lk">runSonarScanner()</em></strong>方法以编程方式执行SonarScanner进行扫描，并将结果上传到Sonar服务器。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mx"><img src="../Images/1eacd0d3fb62615664431ac88a4f2214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYF81BTbdsVK6wyKj6T3ag.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">runSonarScanner()</em></strong></figcaption></figure><p id="0a73" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">3.<strong class="kq hs"><em class="lk">printSonarReport()</em></strong>方法将连接到声纳服务器的<strong class="kq hs"> <em class="lk">端口9000 </em> </strong>。它将使用WEB API来检索代码味道和规则结果。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/1b73f44fd6da099051c51ff2459f766d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ad0iM4n8uWP8b68qoANZlw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">printSonarReport()</em></strong></figcaption></figure><p id="4f29" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">4.<strong class="kq hs"> <em class="lk"> getClassesOfPackage("自定义访问者包的路径")</em> </strong>方法通过自动化读取专门为解决<strong class="kq hs"> <em class="lk">用例1 </em> </strong>和<strong class="kq hs"> <em class="lk">用例2 </em> </strong>而创建的不同访问者类。在这种情况下，它将读作<strong class="kq hs"><em class="lk">S1118 _ constructor visitor</em></strong>和<strong class="kq hs"><em class="lk">S106 _ logger visitor</em></strong>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mz"><img src="../Images/8b7639302f3a4c00d41e0a0d563b3c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXV6tHTFMBcrvPxj3CgBog.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">getClassesOfPackage()</em></strong></figcaption></figure><p id="f270" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">5.<strong class="kq hs">getHandler(List&lt;List&gt;List container，List【T99】Class&gt;handlers，CompilationUnit cu) <br/> </strong>该方法接受包含<strong class="kq hs"> <em class="lk"> listContainer </em> </strong>中的规则列表、<strong class="kq hs"> <em class="lk"> handlers </em> </strong>中的处理程序列表以及<strong class="kq hs"> <em class="lk">编译单元</em> </strong>的参数。<br/>它将迭代并从<strong class="kq hs"> listContainer </strong>中提取一个规则名，并从处理程序列表中获取匹配的访问者。最后创建一个visitor的实例，并将其传递给<strong class="kq hs"><em class="lk">CompilationUnit . accept</em></strong>(visitor，compilation unit)方法。这将启动自动化过程，访问者将遍历包含源代码的编译单元。java ),并寻找纠正代码味道的方法。纠正代码味道的智能在各自的visitor类中进行了检测。</p><h1 id="7006" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">规则实施</h1><h2 id="b928" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated"><strong class="ak"><em class="mf">S1118 _施工方访客</em> </strong></h2><p id="1976" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">下面的屏幕截图显示了<strong class="kq hs"> <em class="lk">用例1 </em> </strong>是如何通过自动化处理和修复的。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es na"><img src="../Images/d13182e73eb0dad5bf16f72d8367bba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf-fSr6iUD5RkvineLJ7ww.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">S1118_ConstructorVisitor.java</em></strong> — continued</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nb"><img src="../Images/79ae32463d100d780cb914329599bf4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whwDgKnbYe5ENkNTdP_eAQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">S1118_ConstructorVisitor.java</em></strong> — continued</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/d98f3764471401f228ad6cdf6191cd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ivt156PVzIIlCqnHOtWoMQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="bd jy"><em class="mf">S1118_ConstructorVisitor.java</em></strong> — continued</figcaption></figure><h2 id="ec95" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">S106_LoggerVisitor</h2><p id="faa3" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">下面的屏幕截图显示了<strong class="kq hs"> <em class="lk">用例2 </em> </strong>是如何通过自动化处理和修复的。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nd"><img src="../Images/ce79b2bc36b40d5aa6cf79b40da77c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnPdXKm1BE-vc5E6SogW8Q.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">S106_LoggerVisitor.java — continued</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ne"><img src="../Images/f6635a9a1c89a482a683d3bc3febd179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-EwD4SIFI1LAKScVhZwCw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">S106_LoggerVisitor.java — continued</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nf"><img src="../Images/3d0c22a4d97491286b1a7b95d18b8a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFR0QeSLWx3TZjyUZgASHQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">S106_LoggerVisitor.java — continued</figcaption></figure><h1 id="0fe3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">让我们执行并观察自动化的运行！！</h1><p id="5156" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">a.<strong class="kq hs"> <em class="lk">运行Spring Boot客户端<br/> </em> </strong> <em class="lk">当Rest控制器收到请求时，自动化将启动。应用程序监听端口8080。</em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/a0a4ed0c378b7f7ea48a004378c73feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkUL11KqY9RPH1pJ5AoyMA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Spring Boot Application</figcaption></figure><p id="8b45" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">b.<strong class="kq hs"> <em class="lk"> </em> </strong> <em class="lk">在</em> <strong class="kq hs"> <em class="lk">调试模式下启动浏览器</em> </strong> <em class="lk">并指向网址</em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ng"><img src="../Images/2fe289a18b17916cc5cf5c8282be74a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiMZq7eBxsZ6AgT1ejToZQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Request</figcaption></figure><p id="9fd7" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">c.<strong class="kq hs"> <em class="lk">声纳扫描仪扫描源文件并上传声纳服务器中的代码气味<br/> </em> </strong>下面的屏幕截图显示了在<strong class="kq hs"> <em class="lk"> SampleTest </em> </strong>项目中捕获的代码气味。<br/>在<strong class="kq hs"> <em class="lk">调试</em> </strong>模式中，我们正在执行代码以捕捉带有代码味道的屏幕截图，然后执行自动化来修复代码味道。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nh"><img src="../Images/cf9cad78dfe48f23f60bf3b5693419d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKs6ulErpxMsg9CD8wBNwQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">run Sonar Scanner</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ni"><img src="../Images/e7e08ced2f49a7e04d14a4a424fb0b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eN6pHt8VacPVSndxUHINrg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Code Smell -Issues shown</figcaption></figure><p id="df54" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated">d.<strong class="kq hs"> <em class="lk">岗位自动化<br/> </em> </strong> <em class="lk">你可以在下面的2个截图中看到，岗位自动化的代码是固定的，现在我们看到</em> <strong class="kq hs"> <em class="lk">的代码闻起来都是0 </em> </strong>和<strong class="kq hs"> <em class="lk">质量关</em> </strong>已经通过<strong class="kq hs"> <em class="lk">。</em>T86】</strong></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nj"><img src="../Images/147b11f670203fb21615d9ff228e5f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMTFhIJKxr4HHYn4f692WA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Code Smell — Issues fixed</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ni"><img src="../Images/110bc08447fc6dd57a134f910db3f03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWG4yzd_oMDYL55t1y8eUw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">SampleTest project — Quality Gate Passed</figcaption></figure><h1 id="913b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">最后，让我们看看我们的源文件</h1><h2 id="9899" class="lm jx hi bd jy ln lo lp kc lq lr ls kg kx lt lu ki lb lv lw kk lf lx ly km ho bi translated">SampleApp.java[自动化之后]</h2><p id="b27b" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">下面的屏幕截图显示，根据Java语言规范 <strong class="kq hs"> <em class="lk"> (JLS) </em> </strong>，遵循<strong class="kq hs"> <em class="lk">规则S1118 </em> </strong>和<strong class="kq hs"> <em class="lk">规则S106 </em> </strong> <em class="lk">，post automation代码已被修复。</em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nk"><img src="../Images/f649a60ac1684c7f64932154ba927e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-vRGqmMzkgyC2AFbhI4fg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Final Cut — Source Code fixed through Automation</figcaption></figure><h1 id="ca74" class="jw jx hi bd jy jz ka kb kc kd ke kf kg ix kh iy ki ja kj jb kk jd kl je km kn bi translated">结论</h1><p id="d50c" class="pw-post-body-paragraph ko kp hi kq b kr ks is kt ku kv iv kw kx ky kz la lb lc ld le lf lg lh li lj hb bi translated">在本文中，我们了解了抽象语法树、Java解析器框架(JAPA)和访问者设计模式。我们还看了一些与Java SE平台及其自动化实现相关的sonar规则。我们以编程方式运行Sonar Scanner来扫描Java项目源代码，并将其发布在Sonar服务器上。我们还使用WEB API将报告检索到我们的应用程序，以使用访问者模式处理和修复代码味道。</p><p id="3c63" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><strong class="kq hs"> <em class="lk">发表于2021年8月18日</em> </strong></p></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><blockquote class="ns nt nu"><p id="04af" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><strong class="kq hs"> <em class="hi">其他中等文章，</em>由<em class="hi">加内什</em> </strong>撰写</p></blockquote><p id="28f4" class="pw-post-body-paragraph ko kp hi kq b kr ma is kt ku mb iv kw kx mc kz la lb md ld le lf me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/confluent-platform-kafka-security-daec286f612d" rel="noopener">合流平台:卡夫卡安全</a></p><blockquote class="ns nt nu"><p id="f5c2" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" rel="noopener" href="/nerd-for-tech/asynchronous-websocket-messaging-middleware-and-microservices-1a50a8f14e4b">异步WebSocket消息中间件和微服务</a></p><p id="6622" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" rel="noopener" href="/geekculture/amalgamate-angular-with-spring-cloud-architecture-through-cors-7f13b5fdb98f">通过CORS将Angular与Spring Cloud建筑融合</a></p><p id="2652" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" rel="noopener" href="/geekculture/multi-broker-insights-into-apache-kafka-cluster-architecture-617b0abfc53e"> <em class="hi">多代理洞察Apache Kafka集群架构</em> </a></p><p id="2d3a" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/remote-queue-definition-ibm-mq-v9-2-c3ec4f568dab?source=user_profile---------5----------------------------" rel="noopener">远程队列定义:IBM MQ v9.2 </a></p><p id="beee" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/kubernetes-pods-docker-containers-spin-vm-using-virtual-box-in-windows-10-home-d3be783ff087?source=user_profile---------0----------------------------" rel="noopener">Kubernetes Pods&amp;Docker Containers:在Windows 10 Home中使用虚拟盒子旋转虚拟机</a></p><p id="a2bb" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/federate-okta-idp-wso2-api-manager-as-gateway-to-spring-boot-microservices-integration-ba567567e81?source=user_profile---------1----------------------------" rel="noopener">联合OKTA IdP + WSO2 API管理器作为Spring boot微服务集成的网关</a></p><p id="a986" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/integrate-ibm-business-process-manager-with-hybrid-mobilefirst-application-5aed20841bf3?source=user_profile---------2----------------------------" rel="noopener">将IBM业务流程管理器与混合MobileFirst应用程序集成</a></p><p id="4264" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/kerberos-v5-sso-authentication-in-windows-10-home-using-apache-directory-studio-fb0151899185?source=user_profile---------3----------------------------" rel="noopener"> Kerberos v5:使用Apache directory studio在Windows 10 Home中进行SSO认证</a></p><p id="bf2c" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/integrate-service-providers-sps-with-okta-identity-provider-idp-ce64a4e262ae?source=user_profile---------4----------------------------" rel="noopener">整合服务提供商(sp)和OKTA身份提供商(IdP) </a></p><p id="83e2" class="ko kp lk kq b kr ma is kt ku mb iv kw nv mc kz la nw md ld le nx me lh li lj hb bi translated"><a class="ae ll" href="https://ganeshblog.medium.com/integrate-ibm-websphere-service-registry-and-repository-with-ibm-process-server-f97eeb0e2ea?source=user_profile---------6----------------------------" rel="noopener">将IBM WebSphere Service Registry and Repository与IBM Process Server集成</a></p></blockquote></div></div>    
</body>
</html>
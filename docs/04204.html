<html>
<head>
<title>Transformers in Cheminformatics Part-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">化学信息学中的变压器第二部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/transformers-in-cheminformatics-f569ad302033?source=collection_archive---------59-----------------------#2021-06-22">https://medium.com/geekculture/transformers-in-cheminformatics-f569ad302033?source=collection_archive---------59-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/71e2cf7b6a55d8557d7e985ee91ebc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zeDgX1fECEsuO1y2S3Yvcw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Fig 1. </strong>The entire transformer block/layer (as used in the encoder) (Image by author)</figcaption></figure><p id="2d04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本系列的第1部分中，我们看了变压器层的构建模块，即。多头注意力和逐点前馈网络。我们几乎没有完成整个变形层。注意，我们互换使用术语<em class="ju">【块】</em>和<em class="ju">【层】</em>。在这一部分，我们将简要介绍变压器层的其他移动部分，即层规范化和残差连接。因为这些概念对transformer来说并不陌生，所以我尽量简短地讨论它们。一旦我们准备好了我们的transformer层，我们就发现了位置嵌入，并因此探索了transformer网络的编码器。然后，我们来看看解码器的细微差别，尽管它与编码器明显相似，但也有细微的差别。我们最终将所有这些整合在一起，形成了我们的变压器网络。</p><p id="8786" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如承诺的那样，所有的动画和代码都被编译到一个jupyter笔记本中，可以在这里访问<a class="ae jt" href="https://mohitkpandey.github.io/posts/2020/11/trfm-code/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a4d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始吧！！！</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="7e82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">transformer层使用一个<em class="ju"> AddandNorm </em>模块，跟随其中的两个子层(多头自关注、逐点前馈N/w)。图层归一化和残差连接建立了<em class="ju"> AddandNorm </em>图层。我们一个一个来看。</p><h1 id="ee5b" class="kc kd hi bd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">图层规范化</h1><p id="c6a6" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">图层规范化不是变形金刚引入的新概念。它已经在自然语言处理任务中广泛流行。它通过所有特征对每个数据点进行标准化。给定一个数据集<br/> X ={x1，x2，…..xm}，其中每个xᵢ是由k维向量表示的序列，使得xᵢ = {xᵢ,ₒ……xᵢ,ₖ}.</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es le"><img src="../Images/da06f506d130f191a382af929ed3bee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*1y835SILeBRJl0PE44AadQ.png"/></div></figure><p id="226e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后是图层图层𝑦ᵢ的输出</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/3948c3a55467f2c0389340928ba48e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*3JIyJS2EQ4ssvr6lhSo0gw.png"/></div></figure><p id="eb19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们把它转换成代码。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="9e0b" class="kc kd hi bd iu ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky bi translated">剩余连接</h1><p id="b4c4" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">本文在Add&amp;Norm块中使用了一个残差连接，后跟layerNorm。</p><pre class="lf lg lh li fd lr ls lt lu aw lv bi"><span id="f17b" class="lw kd hi ls b fi lx ly l lz ma">AddandNorm(Sublayer(x)) = LayerNorm(x+Dropout(Sublayer(x)))</span></pre><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="c132" class="kc kd hi bd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">编码器模块</h1><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/d31e51aeeeead9d8e5fd50cb2142c485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yo-Hrjs090qZ6TtMYF_ghA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Figure</strong>: An Encoder Block/Layer. These layers are the building block to the Encoder Stack</figcaption></figure><p id="ec08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了多头关注、层名和剩余连接，我们现在已经有了实现编码器层所需的一切。编码器层的输入或者是嵌入(在第一编码器层的情况下)<br/>或者是来自前一层的表示(对于第一层之后的编码器层)。我们使用<code class="du mc md me ls b">key=query=value = input (x)</code>来馈入编码器层中的多头注意力块。</p><p id="70c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照上图，实现这个并不太复杂。让我们看看如何</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="8392" class="kc kd hi bd iu ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky bi translated">位置编码</h1><p id="ee2e" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">设计的递归神经网络在学习其参数的同时结合了序列的排序。即使卷积神经网络也可以在其固定大小的内核中捕获一些排序信息。另一方面，自我注意作用于集合，使其排列不变。它对{键，查询，值}集进行操作。在当前状态下，我们的转换器无法区分序列中的随机记号分类和有意义的记号顺序。为此，Vaswani等人通过使用附加的<em class="ju">位置嵌入</em>向量来丰富令牌的嵌入，从而将这样的位置信息传递给令牌。这些位置嵌入不是作为网络训练的一部分学习的。它们是序列中记号位置的固定函数。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cb431131a17c21da529535daa8ade70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OLzUYOzBZfS06LOCSwKYqg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Updated embeddings with positional information</figcaption></figure><p id="5482" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些位置嵌入是嵌入向量中元素位置的正弦和余弦的函数。iᵗʰ令牌嵌入向量中的偶数(<em class="ju"> 2j </em>)和奇数(<em class="ju"> 2j+1 </em>)位置如下</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/0e7836cbe4a97a1d0671b34e70c42c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*PBbTQciU9JL_4eptlH18EA.png"/></div></figure><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="d0fe" class="kc kd hi bd iu ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky bi translated">解码器块</h1><p id="5507" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">详细了解编码器模块后，我们可以开始研究解码器模块了。在架构上，除了一个额外的<em class="ju">“编码器-解码器”</em>多头关注和一个<em class="ju">“添加&amp;范数”</em>块，两者非常相似。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/377aeb193f9fa419a4321c70c5100e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fF0Qh09JIpOmJxMRf-xSWA.gif"/></div></div></figure><p id="5691" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解码器层看起来只是编码器层的一个微小修改。毕竟，我们已经有了多头注意力和Add&amp;Norm的实现。虽然这种多头关注模块在功能上类似于变压器网络中其他地方使用的任何其他多头关注模块，但它的特殊之处在于它从之前的解码器层获取查询，从编码器获取<key value="">。为此，我们把这个<em class="ju">“编解码多头关注”</em>。请注意，变压器网络中的所有其他多头注意力模块摄取<code class="du mc md me ls b">key=query=value</code></key></p><h2 id="0257" class="lw kd hi bd iu mg mh mi kh mj mk ml kl jg mm mn kp jk mo mp kt jo mq mr kx ms bi translated">为什么截然不同的查询，<key-value>是合理的事情？</key-value></h2><blockquote class="mt mu mv"><p id="1cec" class="iv iw ju ix b iy iz ja jb jc jd je jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated">假设你正试图通过观看youtube上的视频来了解变形金刚。你现在已经观看了关于自我关注机制的视频，并对其有所了解。最初的多头注意力块对应于这种学习。它处理“自我关注”视频中的所有信息，并生成一个查询信号，指示接下来要观看和学习什么。它引导你接下来看《多头关注》。</p><p id="782c" class="iv iw ju ix b iy iz ja jb jc jd je jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated">在这种情况下，Youtube本身就是一个编码器。编码器输出是复杂特征的学习丰富编码，结合数据库中的相似视频、具有相同兴趣的其他人(变形金刚)观看的内容等。通过使用这些特征作为关键字和值，并使用“多头注意力”作为查询，编码器-解码器注意力块能够搜索最相似和最相关的关键字(可能是名为<em class="hi">“具有多头注意力的变形金刚”</em>并具有许多upvotes的视频)并返回与其对应的值(视频本身)。</p><p id="2cc3" class="iv iw ju ix b iy iz ja jb jc jd je jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated">同样，对于序列转换任务，这种方法有助于解码器产生更好的转换，因为它现在可以关注整个数据集上学习到的编码(来自编码器)的相关特征。</p></blockquote><p id="1984" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续我们关于解码器层的讨论…</p><p id="b132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">讨论了编码器和解码器之间的架构差异后，我们将注意力集中在实现上。将解码器与编码器区分开来的一个实现差异是在解码器中实施自回归。自回归是一种建模范例，其中模型的输入是当前时间步长之前的令牌。例如，当解码令牌<em class="ju"> j </em>时，模型的输入必须是令牌<em class="ju"> 0……j-1 </em>，而不是超过<em class="ju"> j. </em>的任何东西。这是有意义的，因为解码器在做出推断时将无法访问未来事件。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1130" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种自回归可以通过屏蔽(将所有未来输入归零)来实现。当处理<em class="ju"> j=1时，</em>只有j=0暴露给解码器。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/0c989f43d186b88c1cc69ca356f937b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*gZBXTJFVvd5mzmvBwVh7bQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Masking for a sequence of length 20.</figcaption></figure><p id="cb1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外的一切都被掩盖了。类似地，在<em class="ju"> j=2处，</em>元素在<em class="ju"> j=0，1 </em>处被暴露，以此类推。</p><p id="67e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，与验证时相比，解码器层在训练时表现不同。</p><p id="9434" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">训练时，解码器可以访问整个输出(地面实况)序列。这可能是机器翻译应用程序中目标语言的一个句子，或者是我们打算将源序列映射到的任何其他标记序列。另一方面，当进行推断(从源序列预测目标序列)时，解码器一次一步地预测记号。为了简洁起见，我跳过了这方面的详细描述。我计划单独写一篇关于<em class="ju">“使用变压器解码器的顺序推理”的文章。</em>同时，下图有助于解释推断过程中解码器每个时间步发生的情况。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/71cdb18dbae2291e2a7e2eda92f070b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9rdpLW5jK6m3pyPFFmKC6Q.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Figure: </strong>Transformer Decoder performing inference (Image by Author)</figcaption></figure><p id="abc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这些知识，让我们试着实现解码器层。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="9c6c" class="kc kd hi bd iu ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky bi translated">变压器编码器和解码器</h1><p id="bb9d" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们现在可以将编码器和解码器模块堆叠起来，分别得到transformer编码器和解码器。原始论文在编码器和解码器中都使用了6层。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a39a98840f8f10d80fcfba241b05542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rciOG13eR0VYbKir-CgpTA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><strong class="bd iu">Figure: </strong>Transformer Encoder and Decoder are stacks of encoder and decoder blocks. (Image by author)</figcaption></figure><h2 id="82b2" class="lw kd hi bd iu mg mh mi kh mj mk ml kl jg mm mn kp jk mo mp kt jo mq mr kx ms bi translated">编码器</h2><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="9510" class="lw kd hi bd iu mg mh mi kh mj mk ml kl jg mm mn kp jk mo mp kt jo mq mr kx ms bi translated">解码器</h2><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="1f58" class="kc kd hi bd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将这一切结合在一起</h1><p id="1c5d" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">变压器网络已经成型。我们只需要把编码器和解码器放在一起。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="721d" class="kc kd hi bd iu ke lm kg kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky bi translated">结论</h1><p id="abd6" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们成功地从零开始建立了强大的变压器网络。接下来，我们将对它进行测试，并欣赏它在序列建模任务中的威力。特别是，我们将应用transformer来解决药物发现中的一个关键问题，即预测药物样化合物的溶解度。</p></div></div>    
</body>
</html>
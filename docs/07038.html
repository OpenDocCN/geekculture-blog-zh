<html>
<head>
<title>NodeJS Console Logs in Docker Containers: Hidden No More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker容器中的NodeJS控制台日志:不再隐藏</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/nodejs-console-logs-in-docker-containers-hidden-no-more-d04bcfe1dc5c?source=collection_archive---------2-----------------------#2021-09-06">https://medium.com/geekculture/nodejs-console-logs-in-docker-containers-hidden-no-more-d04bcfe1dc5c?source=collection_archive---------2-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="caa0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="891f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">许多开发人员习惯于编写依赖console.log()的NodeJS程序，不管是好是坏。没有什么比运行您的Express服务器更简单的了，您可以简单地在终端上记录您想要的任何内容。毕竟，这是书中最古老的调试技巧。</p><p id="ed5c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然而，一旦他们的应用程序被容器化并部署到某个地方，许多开发人员就陷入了痛苦的深渊。您不能只是将标准输出重定向到一个文件，然后轻松地打开您的日志文件。服务器不再是您可以访问的独立机器——可能容器正在通过Docker Compose或Kubernetes运行，或者部署为其他一些基于容器的云实例，不允许您通过SSH或RDP进行访问。谁知道你是否能访问正在运行的容器本身。</p><p id="6eb9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你幸运的话，有人将基于Docker的部署配置为从其容器中捕获标准输出，并将其放在你可以看到的地方——但是说实话；当你真正需要它的时候，没有人能把它做好。</p><p id="2ef9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以让我们自己来处理它，并在容器中添加日志检索。这篇文章将带你了解它。如果你是NodeJS或Docker的新手，不要担心——下面详细说明了一切。当然，您可能会发现这种技术对其他平台也很有用。</p><h1 id="4100" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">简单的NodeJS服务器应用程序</h1><p id="7730" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，让我们从一个非常简单的NodeJS/Express服务器开始，它有一个返回时间的API。我们将一次处理一个文件，但作为参考，当我们完成时，我们将得到如下所示的文件和文件夹结构:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c75a" class="kp ig hi kl b fi kq kr l ks kt">logging-docker-example<br/>├── <strong class="kl hj">docker-compose.yaml</strong><br/>├── <strong class="kl hj">Dockerfile</strong><br/>├── logs<br/>├── node_modules<br/>├── <strong class="kl hj">package.json</strong><br/>├── package-lock.json<br/>├── <strong class="kl hj">server.js</strong><br/>└── utils<br/>    └── <strong class="kl hj">logger.js</strong></span></pre><p id="ebe3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们从<strong class="jf hj"> package.json </strong>文件开始:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b0fd" class="kp ig hi kl b fi kq kr l ks kt">{<br/>  "name": "logging-docker-example",<br/>  "version": "1.0.0",<br/>  "description": "Showcasing a logger API",<br/>  "main": "server.js",<br/>  "author": "Baruch Speiser, Cambium",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "dotenv": "^10.0.0",<br/>    "express": "^4.17.1",<br/>    "log4js": "^6.3.0"<br/>  }<br/>}</span></pre><p id="c720" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您将在我们的依赖项中看到我添加了Log4JS(稍后会有更多介绍)。用<strong class="jf hj"> npm install </strong>安装所有这些依赖项，生成您的<em class="ku"> node_modules </em>文件夹，然后我们可以开始添加代码。</p><p id="360b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们将添加一个<strong class="jf hj"> server.js </strong>文件来提供我们的API:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a7fb" class="kp ig hi kl b fi kq kr l ks kt">require("dotenv").config();<br/>const express = require('express');</span><span id="59a6" class="kp ig hi kl b fi kv kr l ks kt">const app = express();</span><span id="6bda" class="kp ig hi kl b fi kv kr l ks kt">app.get("/api/time", (request, response) =&gt; {<br/>  const today = new Date();<br/>  const now = today.toTimeString().substring(0,8);<br/>               //chop off the timezone information<br/>  const result = {<br/>    time: now<br/>  };<br/>  console.info(`Time requested at ${now}`);</span><span id="ee1f" class="kp ig hi kl b fi kv kr l ks kt">  response.set('Content-Type', 'application/json');<br/>  return response.send(result);<br/>});</span><span id="84f8" class="kp ig hi kl b fi kv kr l ks kt">const PORT = process.env.PORT || 8080;<br/>app.listen(PORT, () =&gt; {<br/>  console.info(`Started on port ${PORT}`);<br/>});</span></pre><p id="f528" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用<strong class="jf hj"> node server.js </strong>运行应用程序(假设您的端口没有被阻塞)，您应该看到它已经启动了。打开浏览器到<a class="ae kw" href="http://localhost:8080/api/time" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/time</a>，应该会看到当前时间。在您启动应用程序的终端中，您还应该看到它记录请求的位置。</p><p id="98b4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">到目前为止简单明了。现在让我们为NodeJS/Express应用程序添加一个典型的<strong class="jf hj"> Dockerfile </strong>，我们可以将它构建到一个容器中:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c27f" class="kp ig hi kl b fi kq kr l ks kt">FROM node:14-alpine</span><span id="6753" class="kp ig hi kl b fi kv kr l ks kt">WORKDIR /usr/src/app</span><span id="7f62" class="kp ig hi kl b fi kv kr l ks kt">COPY package*.json ./<br/>RUN npm ci --only=production</span><span id="8e51" class="kp ig hi kl b fi kv kr l ks kt">COPY server.js ./</span><span id="2091" class="kp ig hi kl b fi kv kr l ks kt">USER node<br/>ENV PORT=80<br/>EXPOSE 80<br/>CMD ["/bin/ash", "-c", "node server.js"]</span></pre><p id="4309" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于那些不熟悉Docker的人来说，这里有一个关于这个文件设置的基本解释:</p><ol class=""><li id="45ea" class="kx ky hi jf b jg kb jk kc jo kz js la jw lb ka lc ld le lf bi translated">从预先安装了NodeJS版本14的Alpine Linux容器开始。</li><li id="f06c" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">在容器中设置放置文件的位置。</li><li id="b4dc" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">将<em class="ku"> package.json </em>文件复制到容器中(到其<em class="ku"> /user/src/app </em>文件夹)。</li><li id="85a0" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">仅安装运行应用程序所需的相关依赖项(即不包括任何开发工具)。</li><li id="1687" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">复制我们的<em class="ku"> server.js </em>代码。</li><li id="871c" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">当容器启动时，它应该作为用户“节点”而不是根用户运行(这是一个安全最佳实践)。</li><li id="96df" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">将我们的应用程序中的端口预先配置为标准的HTTP端口80，但是允许它作为容器环境变量被覆盖。</li><li id="6945" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">默认情况下，允许外部请求访问该容器的端口80。</li><li id="e4e5" class="kx ky hi jf b jg lg jk lh jo li js lj jw lk ka lc ld le lf bi translated">当容器启动时，运行我们的代码。</li></ol><p id="6066" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们将使用一个<strong class="jf hj"> docker-compose.yaml </strong>文件来构建并运行它:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="545d" class="kp ig hi kl b fi kq kr l ks kt">version: "3.3"<br/>services:<br/>  logger-example:<br/>    build: .<br/>    ports: <br/>      - "8080:80"</span></pre><p id="70ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">确保您停止了应用程序的本地执行，以便我们可以通过Docker Compose运行它。使用命令:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6234" class="kp ig hi kl b fi kq kr l ks kt">docker-compose up --build</span></pre><p id="3845" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">(如果你是一个Linux用户，你可能需要以sudo的身份这样做。)</p><p id="9354" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">同样，使用您的浏览器来检查时间，您应该看到Docker Compose报告在您的终端中请求了时间。</p><p id="2df7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">到目前为止，一切顺利。通过以上所有内容，我们已经建立了一个基本的容器化NodeJS/Express应用程序。现在让我们把它提高一个档次，加入我们特殊的日志机制。这将允许我们从容器外部查看应用程序日志。</p><h1 id="1fed" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">升级日志记录</h1><p id="d961" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的下一步是向我们的项目添加一个新文件，<strong class="jf hj"> utils/logger.js: </strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="ccea" class="kp ig hi kl b fi kq kr l ks kt">const log4js = require("log4js");<br/>const fs = require('fs')</span><span id="6f73" class="kp ig hi kl b fi kv kr l ks kt">log4js.configure({<br/>  appenders: {<br/>    "stdout" : { type: "stdout" },<br/>    "file"   : { type: "file", filename: "logs/out.log" }<br/>  },<br/>  categories: {<br/>    default:  { appenders: [ 'stdout', 'file' ], level: 'info' }<br/>  }<br/>});</span><span id="eccb" class="kp ig hi kl b fi kv kr l ks kt">exports.logger = log4js.getLogger();</span><span id="e2b1" class="kp ig hi kl b fi kv kr l ks kt">exports.readLog = () =&gt; {<br/>  let log = fs.readFileSync('logs/out.log','utf8', <br/>    (error, content) =&gt; {<br/>      if(error) {<br/>        log4js.getLogger().error(error);<br/>        return error;<br/>      }<br/>      //otherwise<br/>      return content;<br/>    });<br/>  return log;<br/>}</span></pre><p id="0588" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们在这里做了两件事:首先，我们从Log4JS设置了一个日志记录器来代替我们的控制台日志记录。该记录器将同时将相同的文本记录到控制台<em class="ku">和</em>的一个文件<strong class="jf hj"> logs/out.log </strong>中。在日志术语中，我们称之为对日志使用多个<em class="ku">附加器— </em>不同的输出通道。其次，我们添加了一个读取日志文件的方法。</p><p id="71c1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在让我们回到我们的<strong class="jf hj"> server.js </strong>文件并修改它——既使用新的日志记录器，又添加一个将返回日志的新方法:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4812" class="kp ig hi kl b fi kq kr l ks kt">require("dotenv").config();<br/>const express = require('express');<br/><strong class="kl hj">const { logger, readLog } = require('./utils/logger');</strong></span><span id="b557" class="kp ig hi kl b fi kv kr l ks kt">const app = express();</span><span id="af98" class="kp ig hi kl b fi kv kr l ks kt">app.get("/api/time", (request, response) =&gt; {<br/>  const today = new Date();<br/>  const now = today.toTimeString().substring(0,8);<br/>               //chop off the timezone information<br/>  const result = {<br/>    time: now<br/>  };<br/>  <strong class="kl hj">logger.info</strong>(`Time requested at ${now}`);<br/>  <br/>  response.set('Content-Type', 'application/json');<br/>  return response.send(result);<br/>});<br/><strong class="kl hj">app.get("/api/logs", (request, response) =&gt; {<br/>  try {<br/>    const result = readLog();<br/>    response.set('Content-Type', 'text/plain');<br/>    return response.send(result);<br/>  } catch(e) {<br/>    return response.sendStatus(500);<br/>  }<br/>});</strong></span><span id="a9f6" class="kp ig hi kl b fi kv kr l ks kt">const PORT = process.env.PORT || 8080;<br/>app.listen(PORT, () =&gt; {<br/>  <strong class="kl hj">logger.info</strong>(`Started on port ${PORT}`);<br/>});</span></pre><p id="d567" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了确保安全，创建<strong class="jf hj"> /logs </strong>文件夹并运行程序。使用您的浏览器检查时间，您应该看到控制台记录时间——尽管现在它在日志条目中会有更多的信息，因为Log4JS为您提供了许多您可能会发现有用的附加信息。</p><p id="c1b2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您现在可以导航到<a class="ae kw" href="http://localhost:8080/api/logs," rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/logs，</a>，您应该可以在浏览器中看到所有的服务器日志。</p><p id="e2c6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下一步是更新我们的容器构建。特别是，我们需要确保它有创建和读取文件的适当权限，这样我们就不会遇到任何文件权限问题。对<strong class="jf hj"> Dockerfile </strong>进行如下修改:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6d4b" class="kp ig hi kl b fi kq kr l ks kt">FROM node:14-alpine</span><span id="1cf1" class="kp ig hi kl b fi kv kr l ks kt">WORKDIR /usr/src/app</span><span id="0d69" class="kp ig hi kl b fi kv kr l ks kt">COPY package*.json ./<br/>RUN npm ci --only=production</span><span id="c3da" class="kp ig hi kl b fi kv kr l ks kt"><strong class="kl hj">RUN mkdir utils \<br/> &amp;&amp; mkdir logs \<br/> &amp;&amp; touch logs/out.log \<br/> &amp;&amp; chmod 777 logs/out.log</strong></span><span id="63c3" class="kp ig hi kl b fi kv kr l ks kt">COPY server.js ./<br/><strong class="kl hj">COPY utils/logger.js ./utils/</strong></span><span id="682c" class="kp ig hi kl b fi kv kr l ks kt">USER node<br/>ENV PORT=80<br/>EXPOSE 80<br/>CMD ["/bin/ash", "-c", "node server.js"]</span></pre><p id="5bcd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用构建选项再次运行Docker Compose，并检查您的容器。</p><h1 id="049e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">坚持住——保安！</h1><p id="9c43" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你不可能认为向世界公开你的容器的日志是一个好主意，对吗？很好，很好——所以让我们增加一些安全性。我们将使用一个简单的访问键，它可以在容器运行时配置，这样您就可以在需要的时候修改它。</p><p id="ea52" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，让我们修改日志API，使其受到有效的密码保护:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d33d" class="kp ig hi kl b fi kq kr l ks kt">app.get("/api/logs", (request, response) =&gt; {<br/>  try {<br/>    <strong class="kl hj">const auth = "Bearer " + process.env.ACCESS_KEY;<br/>    if(request.headers.authorization == auth) {</strong><br/>      const result = readLog();<br/>      response.set('Content-Type', 'text/plain');<br/>      return response.send(result);<br/>    <strong class="kl hj">} else {<br/>      return response.sendStatus(401);<br/>    }</strong><br/>  } catch(e) {<br/>    return response.sendStatus(500);<br/>  }<br/>});</span></pre><p id="b616" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们在我们的<strong class="jf hj"> docker-compose.yaml </strong>文件中定义访问键:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="093c" class="kp ig hi kl b fi kq kr l ks kt">version: "3.3"<br/>services:<br/>  logger-example:<br/>    build: .<br/>    ports: <br/>      - "8080:80"<br/><strong class="kl hj">    environment:<br/>      ACCESS_KEY: 'VjR8vu5p3QY5cvwP'</strong></span></pre><p id="a215" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，如果您运行它并试图用浏览器打开它，您应该会得到一个401未授权错误。但是，如果您使用Postman之类的工具，您可以使用在Docker Compose中配置的访问密钥添加一个不记名令牌，然后您可以读取日志:</p><figure class="kg kh ki kj fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ll"><img src="../Images/d29257ce917d453257b963b07a083551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imk9Ui57sfxcSLAnksp3OQ.png"/></div></div></figure><p id="ccc8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，您可以在任何您想要的黑盒环境中部署您的容器，并且使用正确的访问密钥，您可以远程访问日志。</p><p id="8d45" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是处理事情的最佳方式吗？大概不会。如果您经常使用容器，您可能应该有一个好的计划来读取容器的标准输出，否则会让您了解应用程序实际上是如何运行的。不过，在紧要关头，有时提前计划并在口袋里装上这样的小把戏会很方便。</p></div></div>    
</body>
</html>
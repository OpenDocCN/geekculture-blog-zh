<html>
<head>
<title>How to Clean Data in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何清理SQL Server中的数据</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-clean-data-in-sql-server-76a4103010a?source=collection_archive---------8-----------------------#2021-04-04">https://medium.com/geekculture/how-to-clean-data-in-sql-server-76a4103010a?source=collection_archive---------8-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f359776aef556dca412babfe3380a315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MQVJPoPMwBnYrRranyT1g.png"/></div></div></figure><p id="91d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本周的博客中，我想进一步发展我的SQL技能。我想关注的一个话题是如何处理杂乱的数据，以及如何恰当地清理这些数据。维护干净的数据是数据科学过程的重要组成部分。它允许方便地导航和探索数据，以便进一步分析。</p><p id="41ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更多地了解SQL中的数据清理，我参加了DataCamp的<em class="jo">“清理SQL Server数据库中的数据”</em>课程。在课程中，我学习了如何处理不正确的字符串值、丢失或重复的值、转换数据类型等等。本课程主要使用的数据集基于2014年和2015年美国航空公司月度航班。</p><h1 id="0f2a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">清洁琴弦</h1><h2 id="1214" class="kn jq hi bd jr ko kp kq jv kr ks kt jz jb ku kv kd jf kw kx kh jj ky kz kl la bi translated">前导零</h2><p id="30bd" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我必须处理的第一个练习是用前导零填充数字。在提供的数据集中，我们有一个名为<code class="du lg lh li lj b">registration_code</code>的列，它包含不同格式的值。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/eac2a4059e0b725859de68bd347f0b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*86ogqtSeGgQgM-FeNIQFLQ.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Sample of registration_code column values</figcaption></figure><p id="6ec4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">列中的某些值只包含三位数，但正确的格式是九位数。为了修复缺少数字的值，我们需要向缺少零的值添加前导零。我们利用了<code class="du lg lh li lj b">REPLICATE()</code>和<code class="du lg lh li lj b">CONCAT()</code>函数。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="300d" class="kn jq hi lj b fi lx ly l lz ma">SELECT <br/>CONCAT(REPLICATE('0', 9 -LEN(registration_code)), registration_code) AS registration_code<br/>FROM flight_statistics</span></pre><p id="f363" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">REPLICATE()</code>函数将一个字符串重复指定的次数。对于只有三位数的值，我们需要添加六个零。通过使用<code class="du lg lh li lj b"> LEN()</code>获得值的长度，我们可以从9中减去该长度，并获得我们需要添加的前导零的数量。然后，我们将该零字符串与原始值连接起来，并且我们已经修复了该列的格式。另一种方法是使用<code class="du lg lh li lj b">FORMAT()</code>功能。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="9911" class="kn jq hi lj b fi lx ly l lz ma">SELECT FORMAT(CAST(registration_code AS INT), '000000000') AS registration_code<br/>FROM flight_statistics</span></pre><p id="7e31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">FORMAT()</code>函数将用指定的格式格式化一个值。我们将我们的<code class="du lg lh li lj b">registration_code</code>转换成一个整数，然后重新格式化它，使它由九个数字组成。任何不是九位数字的值都将被格式化为用零来填充缺失的数字。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/2479afb5c47fc6ce161d48d64eb70495.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*rNN7rt0QcETUQiO2K1x0sw.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Fixed format of registration_code column</figcaption></figure><h2 id="2c05" class="kn jq hi bd jr ko kp kq jv kr ks kt jz jb ku kv kd jf kw kx kh jj ky kz kl la bi translated">杂乱的琴弦</h2><p id="2915" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">字符串的一个常见错误是额外的前导和尾随空格。<code class="du lg lh li lj b">airport_name</code>列的一些值有多余的空格。这可以通过使用<code class="du lg lh li lj b">TRIM()</code>函数来解决，该函数从字符串的开头和结尾删除一个指定的字符。在早于2017年的SQL Server版本中，我们使用<code class="du lg lh li lj b">RTRIM()</code>和<code class="du lg lh li lj b">LTRIM()</code>，其中<code class="du lg lh li lj b">RTRIM</code>删除尾随空格，<code class="du lg lh li lj b">LTRIM </code>删除前导空格。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="5f72" class="kn jq hi lj b fi lx ly l lz ma">SELECT airport_code, TRIM(airport_name) AS airport_name, airport_city, airport_state <br/>FROM airports</span></pre><p id="609f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在某些情况下，我们可能在一个列中使用不同的字符串值来表示相同的值。假设我们想查询数据集，只找到位于芝加哥市的机场。在<code class="du lg lh li lj b">airport_city</code>列中，芝加哥被表示为<code class="du lg lh li lj b">‘Chicago’</code>或缩写，如<code class="du lg lh li lj b">‘CH’ </code>或<code class="du lg lh li lj b">‘ch’</code>。为了便于分析，我们希望找到一种方法将这些情况合并成一个单一值。</p><p id="2281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设在前面的例子中，我们只希望拼出城市名。为了替换不正确的值，我们使用了<code class="du lg lh li lj b">REPLACE()</code>函数。<code class="du lg lh li lj b">REPLACE()</code>将用我们指定的另一个子字符串替换一个子字符串的所有实例。我们的第一反应是将所有“CH”替换为“Chicago ”,但这会带来一个问题，因为这会将“Chicago”变成“Chicagoicago”。最好的方法是使用一个<code class="du lg lh li lj b">CASE</code>语句，只替换不是“Chicago”的值。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="4816" class="kn jq hi lj b fi lx ly l lz ma">SELECT airport_code, airport_name,<br/>    CASE<br/>        WHEN airport_city &lt;&gt; 'Chicago' THEN REPLACE(airport_city, 'ch', 'Chicago')<br/>        ELSE airport_city<br/>    END AS airport_city,<br/>airport_state<br/>FROM airports<br/>WHERE airport_code IN ('ORD', 'MDW')</span></pre><h1 id="aaeb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">缺失和重复的数据</h1><h2 id="8d15" class="kn jq hi bd jr ko kp kq jv kr ks kt jz jb ku kv kd jf kw kx kh jj ky kz kl la bi translated">缺失数据</h2><p id="a118" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在某些情况下，我们的列中可能会缺少值。发生这种情况有多种原因，例如故意缺少值或输入数据时出现错误。在处理丢失的数据时，您有许多选择。我们可以选择保留缺少值的行，从查询中删除它们，或者使用其他值作为替换值，例如该列的平均值。</p><p id="683a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想简单地选择列值没有丢失的所有行，我们需要在查询中添加<code class="du lg lh li lj b">WHERE column_name IS NOT NULL</code>。如果我们想找到该列中缺少值的行，我们可以使用<code class="du lg lh li lj b">IS NULL </code>。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="31f4" class="kn jq hi lj b fi lx ly l lz ma">SELECT *<br/>FROM airports<br/>WHERE airport_city IS NOT NULL</span></pre><p id="05a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果值实际上不为空，但有一个值，如空格或“未知”，该怎么办？在查询的<code class="du lg lh li lj b">WHERE</code>子句中，我们可以使用<code class="du lg lh li lj b">&lt;&gt;</code>或<code class="du lg lh li lj b">=</code>来隔离我们想要的行。如果我们知道空格被用于空值，我们可以选择airport_city不是空格的行作为<code class="du lg lh li lj b">airport_city &lt;&gt; ‘’</code>。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="a1fc" class="kn jq hi lj b fi lx ly l lz ma">-- Exclude the rows where airport_city is missing<br/>SELECT *<br/>FROM airports<br/>WHERE airport_city &lt;&gt; ''</span></pre><p id="f77e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可能不需要排除具有空值的行。然而，为了进一步进行，我们不能在这些列中有<code class="du lg lh li lj b">NULL</code>值。假设我们想使用<code class="du lg lh li lj b">‘Unknown’ </code>作为包含空值的列的占位符值。为了替换这些空值，我们使用<code class="du lg lh li lj b">ISNULL()</code>，并声明要替换的字符串是<code class="du lg lh li lj b">‘Unknown’</code>。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="723a" class="kn jq hi lj b fi lx ly l lz ma">SELECT airport_code, airport_name,<br/>ISNULL(airport_city, 'Unknown') AS airport_city,<br/>ISNULL(airport_state, 'Unknown') AS airport_state<br/>FROM airports</span></pre><p id="a732" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在假设我们想要创建一个名为<code class="du lg lh li lj b">location</code>的新列。为了生成该列中的值，我们希望从多个列中提取第一个非空值，首先从<code class="du lg lh li lj b">airport_city</code>中提取，然后从<code class="du lg lh li lj b">airport_state</code>中提取。如果两列中都有空值，我们将返回字符串‘Unknown’作为<code class="du lg lh li lj b">location</code>的值。我们将使用<code class="du lg lh li lj b">COALESCE()</code>，它将返回第一个非空的结果。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="1aa1" class="kn jq hi lj b fi lx ly l lz ma">SELECT airport_code, airport_name, airport_city, airport_state,<br/>COALESCE(airport_city, airport_state, 'Unknown') AS location<br/>FROM airports</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/6cfec1e2de91ae057529c22970eb6292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lD2o4XttrC0ydkyqs20HzQ.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Sample result from query above. Note how COALESCE works with the null columns.</figcaption></figure><h2 id="327b" class="kn jq hi bd jr ko kp kq jv kr ks kt jz jb ku kv kd jf kw kx kh jj ky kz kl la bi translated">重复数据</h2><p id="682f" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">重复数据可能以多种形式出现。它可能只是重复的行，其中所有列的值都相同。也可能有这样的行，其中大多数列或只有少数列共享相同的值。为了帮助区分不明显的重复行，我们需要识别重复组。重复组由用于标识实体的唯一实例的列组成。对于此数据集，<code class="du lg lh li lj b">airport_code</code>、<code class="du lg lh li lj b">carrier_code</code>和<code class="du lg lh li lj b">registration_date</code>被视为重复组，因为它们每月仅注册一次。</p><p id="9336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用<code class="du lg lh li lj b">ROW_NUMBER()</code>函数来帮助识别重复的行。在<code class="du lg lh li lj b">PARTITION BY</code>子句中，我们指定我们的重复组。的第一个实例的行号为1，这意味着它是重复组列的特定组合的第一个实例。如果该重复组有多个实例，则它们的行号将根据先前标识的行数依次增加。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="9c92" class="kn jq hi lj b fi lx ly l lz ma">SELECT *,<br/>ROW_NUMBER() OVER (<br/>    PARTITION BY<br/>        airport_code,<br/>        carrier_code,<br/>        registration_date<br/>            ORDER BY<br/>        airport_code,<br/>        carrier_code,<br/>        registration_date<br/>    ) row_num<br/>FROM flight_statistics</span></pre><p id="aaad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想单独识别非重复行，我们将调用前面的查询，通过只查找<code class="du lg lh li lj b">row_num</code>为1的行来排除重复行。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="b010" class="kn jq hi lj b fi lx ly l lz ma">WITH cte AS (<br/>    SELECT *,<br/>        ROW_NUMBER() OVER (<br/>            PARTITION BY<br/>                airport_code,<br/>                carrier_code,<br/>                registration_date<br/>            ORDER BY<br/>                airport_code,<br/>                carrier_code,<br/>                registration_date<br/>         ) row_num<br/>    FROM flight_statistics<br/>)<br/>SELECT * FROM cte<br/>-- Exclude duplicates<br/>WHERE row_num = 1;</span></pre><h1 id="b747" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">转换数据类型</h1><p id="65d3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">列数据类型对于确定我们可以对它执行什么操作很重要。例如，我们将不能在<code class="du lg lh li lj b">VARCHAR</code>类型的列上执行比较或使用聚合函数。通过使用<code class="du lg lh li lj b">CAST()</code>或<code class="du lg lh li lj b">CONVERT()</code>函数，我们可以指定想要将列转换成什么数据类型。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="3b9a" class="kn jq hi lj b fi lx ly l lz ma">SELECT AVG(CAST(num_ratings AS INT))<br/>FROM series<br/>WHERE CAST(num_ratings AS INT) BETWEEN 0 AND 5000<br/>---------------------------------------------------------</span><span id="2e55" class="kn jq hi lj b fi md ly l lz ma">SELECT AVG(CONVERT(INT, num_ratings))<br/>FROM series<br/>WHERE CONVERT(INT, num_ratings) BETWEEN 0 AND 5000</span></pre><h2 id="7d28" class="kn jq hi bd jr ko kp kq jv kr ks kt jz jb ku kv kd jf kw kx kh jj ky kz kl la bi translated">日期格式</h2><p id="e59b" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">根据地点和语言的不同，日期可以有多种不同的格式。月/日/年、日/月/年和年/月/日只是我们可以用来表示日期的一些格式。如果我们希望将日期格式更改为另一种格式，我们将再次需要使用<code class="du lg lh li lj b">CAST()</code>或<code class="du lg lh li lj b">CONVERT()</code>。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="502e" class="kn jq hi lj b fi lx ly l lz ma">SELECT CAST(registration_date AS DATE), 101) AS registration_date<br/>FROM flight_statistics<br/>WHERE CONVERT(VARCHAR(10), CAST(registration_date AS DATE), 101)<br/>BETWEEN '01/01/2014' AND '06/30/2014'<br/>----------------------------------------------------------------<br/>SELECT FORMAT(CAST(entry_date AS DATE), 'dd/MM/yyyy') AS entry_date<br/>from pilots</span></pre><p id="cbc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<code class="du lg lh li lj b">CONVERT()</code>，我们通过对应于特定样式的整数来表示我们希望转换的样式。例如，如果我想将日期列转换成<code class="du lg lh li lj b">mm/dd/yyyy</code>格式，我会使用<code class="du lg lh li lj b">101</code>作为样式。在这个<a class="ae me" href="https://www.w3schools.com/sql/func_sqlserver_convert.asp" rel="noopener ugc nofollow" target="_blank">链接</a>中可以找到日期可以转换成的格式列表。对于<code class="du lg lh li lj b">FORMAT()</code>，我们用特定的参数指定我们想要的格式，比如短日期/长日期、天数、月数、年数的实际期望顺序，以及一个可选的语言参数。可用格式列表可在<a class="ae me" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/format-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="8b5e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">不准确的数据</h1><p id="7a87" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我们在数据集中可能会遇到超出期望值范围的值。如果看到某人的身高被列为400英寸，或者某部电影在10分制中被评为11分，这是不正确的。如果我们知道这些值的预期范围，我们可以查询其中该列的值是范围的上限和下限的行。这同样适用于查找范围之外的行。我们可以使用关键字<code class="du lg lh li lj b">BETWEEN </code>或者任何比较操作符，比如<code class="du lg lh li lj b">&gt;, &lt;, &lt;=, &gt;=</code>。</p><pre class="ll lm ln lo fd lt lj lu lv aw lw bi"><span id="0b45" class="kn jq hi lj b fi lx ly l lz ma">SELECT * <br/>FROM series<br/>WHERE num_ratings &gt;= 0 AND num_ratings &lt;= 5000</span></pre></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="a59d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是我学习如何在Microsoft SQL Server中清理数据的一些方法。这些技术为大多数情况提供了一个合适的起点，但是每种情况都是不同的。可能存在需要更复杂的编码或其他功能的情况。与往常一样，在确定处理脏数据的最佳方法时，使用您的最佳判断是至关重要的。现在，我觉得自己更能熟练地清理SQL中的数据，并期待在未来使用我所学到的东西。感谢您的阅读！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Graph Algorithms in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的图形算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/graph-algorithms-in-c-161d2d3c245?source=collection_archive---------4-----------------------#2021-12-02">https://medium.com/geekculture/graph-algorithms-in-c-161d2d3c245?source=collection_archive---------4-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/4f99cfc8cca845a93c79e9921efc5b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmC6ui1VdfJT1I_tOFE7bg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><div class=""/><p id="5fc0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的文章介绍了基本算法，这些算法在我们对图形进行计算时经常用到。我们将从像<a class="ae js" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">深度优先搜索</strong></a><strong class="iw hy">(DFS)</strong><a class="ae js" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">广度优先搜索</strong></a><strong class="iw hy">【BFS】</strong>这样的基础知识开始。由于我对机器人领域的偏好，我也将描述路径规划中常用的算法。我们将考察<a class="ae js" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Dijkstra算法</strong> </a>和<a class="ae js" href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> A*算法</strong> </a>。</p><p id="1885" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的这些算法的C++实现可以在我的<a class="ae js" href="https://github.com/markusbuchholz/graph_algorithms_in_cpp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> GitHub </strong> </a>上找到。注意，在下面这篇文章中，我尽力描述了这些原则。请首先尝试自己实现这些算法，并最终与我的进行比较。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="ede6" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">图形介绍</strong></h1><p id="572a" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">图是一种数据结构，可以与通过边(链接)连接的顶点(使用树术语的节点)的网络类型相关联。该图类似于树数据结构，但是有独特的功能，使图形独特和非常强大的广泛应用。考虑下图中绘制图形和树的位置。这两种常见数据结构之间的主要区别可以讨论如下。<br/>除了两个结构中的每个节点都有唯一的ID之外，树还有根节点，它与树的起点相关联。树是一种从根到底的分层结构。然而，该图并不遵循这一概念，所有节点都可以是我们研究的起点。让我们考虑这个例子。城市/国家的地图逻辑上是图，它通过不同的道路、路径(图边)连接城市或家庭。使用同样的地图，我们可以寻找从A地到B地或从C城到D城的最短路径，等等。在这些情况下，起点是地点A或城市c。<br/>在使用图形时，我们可以使用循环，这意味着通过一个节点，我们可以使用不同的方式返回到该节点(如果存在)。使用树时，此功能不存在。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="1827" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> BFS和DFS算法</strong></h1><p id="98ac" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">在本节中，我们将讨论这些算法的主要原理和常见用法。我们将详细说明主要的区别并进行模拟(这些算法的实现可以在我的GitHub上找到)。请考虑下图，我希望它能帮助你使用所讨论的算法来可视化导线测量的主要原理。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/49edf76b91c3944d1166a9f93192b30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jBn5YefQSoBDZiMzMBT-g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="5dff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">BFS算法的概念</strong>与<strong class="iw hy">队列</strong>直接相连，这是一种在<a class="ae js" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> FIFO </strong> </a>上下文中操作的容器。FIFO代表:先入先出，可以与内存(容器)相关联，在内存中，项目从一侧进入，从另一侧取出。让我们考虑一个例子来说明我们的讨论。</p><p id="b75c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以认为我们需要遍历呈现的图中的所有节点。我们可以从每个节点开始，因为图不是层次结构。<br/>我们从3开始，所以3进入队列，并被标记为被访问的节点。接下来，我们从队列容器(FIFO)中删除(弹出)该节点，同时我们插入(推入)与先前弹出节点直接相连的未访问节点。在我们的例子中，我们插入节点nr 6和2。</p><p id="f2df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在重复该过程，我们将节点nr 6标记为已访问节点(从队列中弹出)并检查(推入)将直接连接到节点6的未访问节点排入队列，并将它们推入队列。节点nr 4位于队列中，并被标记为被访问。</p><p id="ccfa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您考虑队列的当前状态时，我们必须评估节点2，它已从队列中删除。</p><p id="3f1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们考虑节点2的未访问邻居。在这种情况下，我们添加节点1。节点4被访问，所以不考虑</p><p id="a2cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们检查节点4并添加未访问的邻居。节点5未被访问。此外，我们检查节点1和5，它们与未被访问的节点没有任何连接，因此该过程可以终止。我们访问了所有的节点(遍历了图形)。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es li"><img src="../Images/9580a2e24bf3d451c8a9298b45b40dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9KgMVxSjqjPj43WBbdvpA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="efd0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在两种情况下(BFS和DFS ),我将图初始化为一个列表(每个节点一个列表)。该列表(对于每个节点)包括该节点的邻居。列表提供了直接推动和弹出的机会。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8cfe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与BFS a <strong class="iw hy">相反，DFS算法</strong>使用了<strong class="iw hy"> </strong> <a class="ae js" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">栈</strong> </a>的概念。这种类型的容器作为一个<strong class="iw hy"> LIFO </strong>操作，这意味着元素作为最后一个进入，作为第一个弹出。它可以被关联为“单向门”容器。</p><p id="eafb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了理解这个概念，我们可以考虑和前面一样的图表。我们也从节点nr 3开始遍历该图，节点NR 3被插入到堆栈中并被标记为已访问(当已访问时，我们从堆栈中移除该节点)。接下来我们考虑连接到节点3的未访问节点(类似于BFS)。节点2和6进入堆栈，并在一处标记为已访问。此外(与BFS不同),我们采用并扩展位于堆栈顶部的节点。这里我们有节点6。</p><p id="77f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">应用相同的方法，我们将节点标记为已访问，并检查连接到6的未访问节点。在这种情况下，我们可以从堆栈中移除节点6，并将节点4压入。现在，节点4位于堆栈的顶部(并标记为已访问)。我们从堆栈中删除这个节点，同时通过直接链接的节点1和5进行扩展。我们不考虑2，因为该节点仍在堆栈上并被标记为已访问。在堆栈的顶部是5，它没有任何到未访问节点的链接，所以我删除了节点5，我们取堆栈中的下一个节点。还剩下一个未被访问的节点。接下来，我们从堆栈中取出节点1。由于不再有未被访问的节点，所以该节点没有被消耗。接下来，我们取栈上的剩余节点，在我们的例子中是节点2。此操作(堆栈为空)终止图形的遍历。请考虑下图。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/a4e95a2bffb1653b2c79a435e7ab7d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfZcOJ8k78nsa1VZSPG4WA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="b7dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">C++代码</p><p id="0168" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在许多应用中，这两种算法都可以使用。然而，为了记住哪种算法最适合某个应用，我们必须记住可以从其他场景(应用)推导出的两种情况。</p><p id="2c5a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> BFS </strong>主要用于应用程序，其中我们需要<strong class="iw hy">找到到该节点的最短路径</strong>，因为我们将所有邻居消耗到该节点。</p><p id="2f84" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.youtube.com/watch?v=xLyfegzK6AU&amp;t=123s" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> DFS </strong> </a> <strong class="iw hy"> </strong>主要用于下棋或决策相关游戏等场合<strong class="iw hy">。我们采取一个决定(行动)。这个决定(动作)会影响下一个动作。如果我们去节点6(从节点3；见图表)所以我们不考虑另一个选项(在这种情况下是节点2)。我们按照堆栈顺序，寻找节点4，等等。</strong></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7d21" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> Dijkstra算法</strong></h1><p id="4524" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">Dijkstra算法的主要目标是找到图中任意两个节点(顶点)之间的最短路径。然而，我们需要注意的是，当应用Dijkstra算法时，我们找到了从图中的起始节点到其他节点的最短路径。我们访问图中的所有节点，这意味着我们可以轻松地提取图中任何节点之间的最短路径。<br/>考虑下图，我们可以考虑一下。正如您所看到的，节点之间的路径包括关于距离或成本或其他有用值的信息，它提供了对节点之间转换工作的估计。</p><p id="e885" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我想提一下，对以下算法的理解将很快让你顺利理解/部署我们将在下一节讨论的A*算法。<br/>出于该算法的目的，我们必须分配一个表。为每个节点存储特定值的存储器。此外，我们需要存储关于被访问节点的信息。</p><p id="1ecb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您在下面看到的，我们已经为图形中的所有现有节点创建了表格。第二列包括从起始节点(在我们的例子中是节点0)开始的最短路径的信息。开始时，该列被初始化为无穷大值。最后一列包含关于前一个节点的信息，该信息指示到目前为止已经为其计算了从起点开始的最短路径的前一个节点的名称。请注意，表中的信息会不断更新，而算法不会终止(我们必须访问图中的所有节点)。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/cbc5906d203b7113cc220b28bfb4834a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUnV625VvhIrmXHnCj_8FQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="324d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们考虑一下我们的图表。我们从0开始。从这个节点开始，到0的最短路径等于0。<br/>从节点0我们可以过渡到节点1和7。与节点7的成本等于8相比，节点1的成本更低，等于4。现在奇迹正在发生。这是该算法的基础。<br/>我们需要看看我们如何从开始节点执行最短距离(成本)的更新。</p><p id="7ea7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">已经执行了从节点0到节点1的转换。到节点的旅行成本为0(因为有一个起始节点),但是旅行的距离(成本)等于4。到达节点1的总距离(成本)等于0 + 4 = 4。如果该计算值低于存在于初始化表中的值(对于特定节点；在我们的例子中，节点1)因此我们更新了关于最短路径和先前节点的信息。在我们的例子中，我们将距离初始化为无穷大，所以等于4的距离肯定更小。</p><p id="7870" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与节点1相似，我们计算节点7的最短路径。在这种情况下，计算也很简单。到节点7的无限距离更新为值8 = 0 + 8(见图表)。<br/>在两个预览案例中，我们都从节点0过渡，因此该信息也包含在表中。我们将节点0标记为已访问，并且我们不打算再次访问此节点(顶点)。</p><p id="017c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在要考虑的下一个节点是距离起始节点(我们的情况是0)最短的节点。在我们的例子中，节点1的距离最短。接下来，我们通过向列表中添加节点1的邻居来扩展节点1。我们添加节点2和节点7。未添加节点0，因为它被标记为已访问。</p><p id="fad2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到节点2和7的距离必须相应地更新。对于节点2，我们使用先前的公式进行更新，其中我们获取到达先前节点的距离和到我们考虑的节点的距离。对于节点2，我们从节点2中转(对于该节点，参见表格，我们计算的距离等于4)。节点1和节点2之间的实际距离等于8，因此总距离等于12 = 8 + 4。我们更新我们的表，因为先前的值是无穷大。</p><p id="4827" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">类似于节点2，我们考虑节点7。通过节点1到达节点7的开销(路径距离)为15 = 4 + 11。从表中可以看出，4是到节点1的距离以及1和7之间的距离。在这种情况下是11。现在，我们需要评估到7的距离，它(现在)可以直接从0开始或通过4到达。在第一种情况下，距离等于8(已经在我们的表中)，最后计算出15。值8小于15，因此我们不更新该表。</p><p id="b0ec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，如前所述，我们考虑从起点到终点距离最短的未访问节点。我们检查桌子。最低值是与节点2相对的节点7的值，为12。请注意，节点1被标记为已访问。</p><p id="fd09" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于节点7，我们扩展(添加)到未访问邻居列表。节点8和节点6。重复该过程，直到访问了所有节点，因此可以终止图的遍历。<br/>流程终止后，表格包含所有必要信息，以提取从起始节点到每个节点的最短路径。为了获得更多的灵感，我真的推荐在YouTube频道上观看下面的视频(文章末尾的链接)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e772" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> A*算法</strong></h1><p id="643d" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">最后一个算法，我们将要讨论的是A*算法。算法(及其衍生算法)经常用于机器人路径规划，其中机器人知道目标，感知环境(使用相机、激光雷达或其他传感器)并做出关于下一步移动的决定。在我们的例子中，我们计算静态环境的路径。</p><p id="a0de" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我想指出Dijkstra算法的某些不同之处。除了图中的所有边包括节点之间的距离之外，然而在我们开始之前，每个节点由<a class="ae js" href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)#:~:text=The%20objective%20of%20a%20heuristic,solving%20the%20problem%20at%20hand.&amp;text=Heuristics%20underlie%20the%20whole%20field,there%20are%20no%20known%20algorithms." rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">试探法</strong> </a>函数(在我们的情况下为某个值)初始化，这简化了理论，可以与提供给系统的附加信息相关联，以便加速搜索过程(算法更快地收敛到目标)。</p><p id="0c73" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用不同的方法和假设，启发式函数可以任意计算，然而对于我们的“机器人”移动的整个环境(节点)是一致的(适用的)。通常额外的信息(启发式)被计算为节点和目标之间的<a class="ae js" href="https://en.wikipedia.org/wiki/Distance" rel="noopener ugc nofollow" target="_blank">曼哈顿距离</a>。正如我们稍后展示的，启发式算法可以被认为是一种额外的知识，以便估计到目标的剩余距离(当我们的机器人通过时)。</p><p id="bb61" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，我们需要注意，Dijkstra算法计算到图中所有节点的最短路径(必须访问所有节点，算法才能终止)，然而A*计算两个特定节点之间的最短路径(不需要访问所有节点)。</p><p id="8c0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一个区别是微不足道的，因为我们需要(在软件中)模拟该表，该表像以前一样包括所有节点的列，s从开始节点的距离，启发式-从考虑的节点到目标的估计距离。此外，对于每个节点，我们必须计算(当机器人通过和探索图形时，值将被更新)函数:</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="084d" class="lq kb hx lm b fi lr ls l lt lu">f(n) = g(n) + h(n),</span><span id="0697" class="lq kb hx lm b fi lv ls l lt lu">where <em class="lw">n</em> is associated with node, <em class="lw">g</em>(<em class="lw">n</em>) is the cost of the path from the start node to <em class="lw">n</em>, and <em class="lw">h</em>(<em class="lw">n</em>) is a <a class="ae js" href="https://en.wikipedia.org/wiki/Heuristic" rel="noopener ugc nofollow" target="_blank">heuristic</a> function that estimates the cost of the shortest (cheapest) path from <em class="lw">n</em> to the goal.</span></pre><p id="8e61" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一列保存关于前一节点的信息(类似于Dijkstra算法),该信息“表示”到达该节点的最短距离。</p><p id="bb54" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">A*算法假设创建(类似于Dijkstra算法)两个列表。我们需要保存关于访问过的节点和我们考虑的当前节点的邻居的信息。</p><p id="6e13" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们来看看下图。我们将尝试找到从节点0到节点5的最短路径。考虑自然距离。还要记住，除了“自然”距离之外，距离的“成本”还可以包括其他因素，如道路类型(例如，道路可能会湿滑、上坡或完全黑暗等)。这个“特征”存在于我们的例子中。检查节点3和目标6之间的连接。费用是20。我们可以想象我们有一条湿滑的道路，我们的机器人在这种道路上行走将会比预期使用更多的能量。该算法试图“检测”异常并找到最佳解决方案。正如我们所料，最短的路径应该避开这条边。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es li"><img src="../Images/cfdd51cd01051922542ec87193445ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aagwXZ2JJ-m5BsXLBdXL3w.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">by author</figcaption></figure><p id="77ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从节点0开始。在机器人启动(机器人控制系统计算路径)之前，必须用启发式值(对于每个节点)填充该表。</p><p id="7112" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的例子中，有一个常量向量(图中节点数量的大小)。</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="74b3" class="lq kb hx lm b fi lr ls l lt lu">std::vector&lt;int&gt; heuristic{10, 8, 9, 5, 6, 3, 0};<br/>//eg. heuristic value for node 1 to goal is 8.</span></pre><p id="f8e6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们扩展节点0(我们添加到列表中)的邻居:节点1和节点2。对于这两个节点，我们计算f(n)。</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="8e44" class="lq kb hx lm b fi lr ls l lt lu"><strong class="lm hy">f(n) = g(n) + h(n); //g - current distance from start, h - heuristic</strong></span><span id="afc4" class="lq kb hx lm b fi lv ls l lt lu">f(0) = 0 + 10 = 10;</span><span id="4c43" class="lq kb hx lm b fi lv ls l lt lu">f(1) = 2 + 8 = 10; // 2 - distance from 0 to 1, h = 10 heuristic for node 1</span><span id="6a42" class="lq kb hx lm b fi lv ls l lt lu">f(2) = 10 + 9 = 19; // 10 - distance from 0 to 2, h = 9 heuristic fro node 2</span></pre><p id="daec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们将节点0标记为已访问，并选择具有最低f(n)值的节点进行进一步分析。在我们的例子中是节点1，其中f(1) = 10。我们将节点1扩展为邻居:节点3和节点4，并计算f(n)值。</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="a44b" class="lq kb hx lm b fi lr ls l lt lu">f(3) = (2 + 1) + 5 = 8; // 2 + 1 - distance from 0 to 1 and 1 to 3, h = 5 for node 3 heuristic</span><span id="c200" class="lq kb hx lm b fi lv ls l lt lu">f(4) = (2 + 5) + 6 = 13; // 2 + 5 - distance from 0 to 1 and 1 to 4, h = 6 for node 4 heuristic</span></pre><p id="b9f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">记得“更新”我们的虚拟表(通常是在软件中完成的——参见我的C++代码)。节点1作为受访者登陆。</p><p id="95a0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们再次选择已经为节点1的邻居计算的最低值。这一次，我们选择节点3，节点6、节点5和节点4的开销也是如此。请注意，节点6是我们的目标。</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="0e3f" class="lq kb hx lm b fi lr ls l lt lu">f(6) = (2 + 1 + 20) + 0 = 23; // 2 + 1 + 20 - distance from 0 to 1 and 1 to 3 and 3 to 6; h = 0 since node 6 is the goal</span><span id="4ac0" class="lq kb hx lm b fi lv ls l lt lu">f(4) = (2 + 1 + 4) + 6 = 13; // 2 + 1 + 4 - distance from 0 to 1, 1 to 3 and 3 to 4; h = 6 for node 4 heuristic</span><span id="c82a" class="lq kb hx lm b fi lv ls l lt lu">f(5) = (2 + 1 + 2) + 3 = 8; // 2 + 1 + 2- distance from 0 to 1, 1 to 3 and 3 to 5; h = 3 for node 5 heuristic</span></pre><p id="7f32" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们再次选择已经为节点3的邻居计算的最低值。这一次我们选择节点5，节点6和节点4的开销也是如此。访问节点3。由于节点6是我们的目标，我们终止了算法。我们的机器人到达目的地和节点4。</p><p id="5016" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请观看以下视频中对A*算法的精彩解释。</p><p id="0ba4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">两个推荐链接:</p><ol class=""><li id="e735" class="lx ly hx iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated"><a class="ae js" href="https://www.youtube.com/watch?v=pVfj6mxhdMw&amp;t=316s&amp;ab_channel=ComputerScience" rel="noopener ugc nofollow" target="_blank">迪杰斯特拉算法</a></li><li id="986b" class="lx ly hx iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><a class="ae js" href="https://www.youtube.com/watch?v=eSOJ3ARN5FM&amp;t=425s&amp;ab_channel=ComputerScience" rel="noopener ugc nofollow" target="_blank"> A*算法</a></li></ol><p id="3368" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我建议你去看看SOTA的YouTube频道:</p><ol class=""><li id="1e1a" class="lx ly hx iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated"><a class="ae js" href="https://www.youtube.com/c/CoffeeBeforeArch" rel="noopener ugc nofollow" target="_blank"> CoffeeBeforeArch </a></li></ol><p id="8e91" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>
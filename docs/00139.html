<html>
<head>
<title>Performance Matters: N+1 Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">性能问题:N+1问题</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/performance-matters-n-1-problem-a6a072525149?source=collection_archive---------1-----------------------#2020-07-18">https://medium.com/geekculture/performance-matters-n-1-problem-a6a072525149?source=collection_archive---------1-----------------------#2020-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b56a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">介绍<em class="jd"> N+1 </em>问题以及如何避免常见的性能陷阱。</p><h1 id="f0dc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是<em class="kc"> N+1 </em>问题？</h1><p id="5428" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><em class="jd"> N+1 </em>查询问题是一种常见的性能反模式，当代码需要从<em class="jd">一对多关系</em>中的一个父数据加载一堆子数据时就会出现这种问题。对父记录执行查询，然后对每个子记录执行一个查询。最终对数据库进行<em class="jd"> N+1 </em>查询，以获得属于父记录的每个子记录。</p><h1 id="588c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="1a2b" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">让我们假设您有一个表，调用<em class="jd"> "category" </em>来记录您的商店中可用的类别列表。每个类别可能有一个或多个产品，记录在另一个名为“<em class="jd"> product </em>”的表中。换句话说，<em class="jd">【类别】</em>【产品】<em class="jd"/><em class="jd">是一对多的关系。</em></p><p id="0953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> <em class="jd">走</em> </strong>时，通常情况下，它看起来像这些语句:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1abf" class="kr jf hi kn b fi ks kt l ku kv"><em class="jd">categories</em>, <em class="jd">_ </em>:= repository.GetCategories()<br/><strong class="kn hj">for </strong><em class="jd">_</em>, <em class="jd">category </em>:= <strong class="kn hj">range </strong><em class="jd">categories </em>{<br/>   <em class="jd">products</em>, <em class="jd">_ </em>:= repository.GetProducts(<em class="jd">category</em>.ID)<br/>   // ....<br/>}</span></pre><p id="c783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设<strong class="ih hj"><em class="jd">get categories()</em></strong>有这样一个底层实现:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d4ca" class="kr jf hi kn b fi ks kt l ku kv">SELECT * FROM "category"</span></pre><p id="a852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，<strong class="ih hj"><em class="jd">get products()</em></strong>有一个底层实现是这样的:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c920" class="kr jf hi kn b fi ks kt l ku kv">SELECT * FROM "product" WHERE category_id = ...</span></pre><p id="c4e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次执行前面的语句时，它都会发出<em class="jd"> N+1 </em>个查询，其中<em class="jd"> N </em>是类别的数量，如下所示:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/8cef57875dc2c1d1d0f546196f7fd455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eh68i-obPiQpeEk__XT0Aw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">N+1 Problem Queries Sample</figcaption></figure><h1 id="7431" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">这个例子的问题是</h1><p id="b028" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">您可以看到这些查询产生了相当多的开销。请记住，运行1个返回100个结果的查询比运行100个每个只有1个结果的查询要快。如果您从运行在不同机器上的数据库或服务中获取数据，这一点尤其正确。</p><p id="8cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设从数据库或服务中获取数据，每次查询需要100-200毫秒。如果您执行100次查询，将需要10.000–20.000毫秒来获得您需要的所有数据。</p><h1 id="424c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如何避免N+1问题？</h1><p id="b656" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">简单来说，<strong class="ih hj"> <em class="jd">批量</em> </strong>做查询。与其运行查询<em class="jd"> N+1 </em>次，不如只运行两次，一次针对父记录，一次针对子记录。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/b5912b97fbf26d011d09e30eb07bf6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-yF4okyrOkPFIvKOUtoLg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">N+1 Problem Solution Queries Example</figcaption></figure><p id="1969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧，我们完成了。现在你明白什么是N+1问题以及如何避免它们了。</p></div></div>    
</body>
</html>
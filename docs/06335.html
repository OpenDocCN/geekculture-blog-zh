<html>
<head>
<title>Refactoring Complicated Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构复杂的代码</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/refactoring-complicated-code-ad8b09a5b92b?source=collection_archive---------16-----------------------#2021-08-17">https://medium.com/geekculture/refactoring-complicated-code-ad8b09a5b92b?source=collection_archive---------16-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="41f8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从蛮力到形式优雅</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0ed367d89418eed7cb0e787f75894b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YkvLotO3yRnhXYEt"/></div></div></figure><p id="8f42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">情况是这样的:你已经花了一天左右的时间研究一个复杂的编码问题，并且你已经迭代进入了一个工作系统。任务完成了，对吧？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2bdb4dd2f864d86853ba5ed22e05a5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jtJXxOdlaEB9yBKN"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Right?</figcaption></figure><p id="975a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">慢点，朋友。在您进一步深入之前，是时候清理这些代码了。</p><p id="b9ad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">找到一个强力的解决方案并不是最终的结果。花一点时间寻找方法来简化你所创造的东西是值得的。搜索重复的代码，并可能将代码隔离到它自己的方法中。看看信息从哪里开始和停止，看看是否可以移动东西来消除依赖性。探索不同的数据结构，看看是否有一个可以帮助您避免昂贵的操作。</p><p id="faa2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天，我将对我在<a class="ae kj" rel="noopener" href="/geekculture/scripting-a-turn-based-tactical-command-system-b14b33000a0f">之前的</a> <a class="ae kj" rel="noopener" href="/geekculture/turn-based-tactical-command-system-part-2-f8c57abaec74">两篇</a>文章中概述的战术指挥系统做一些清理。最重要的是，我将重构命令执行系统，通过使用<a class="ae kj" rel="noopener" href="/nerd-for-tech/undo-redo-with-the-command-pattern-in-unity-c-d3b63beab7a4">命令模式</a>，减少传递给经理的信息。</p><p id="9c52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">淘汰旧的</strong></p><p id="a9ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们首先需要检查的是行尾。我们有两种执行动作的方法。ProcessRoundRoutine收集所有相关信息，并将其提供给一个无所不包的执行方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/cd139628bba762ab5733d9f79443398a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_B3uNDEcn7O6LHeU.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/b07f45300ae49a4c5b688f3f78eadb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o5hnS8e5RBKcYvmu.png"/></div></div></figure><p id="aec5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如你所见，这对于一个班级来说是太多的责任了。我们不需要将所有信息传递到一个位置来执行它。我们可以让已经拥有这些信息的对象执行它们自己的动作。我们只需要获得封装到单个对象中的那些动作的列表，然后传递该对象。这是命令模式的本质。所以让我们准备一个界面和一系列命令对象。</p><p id="7f25" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">在用新的</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/720858965e081d4c2d1f8766085f2cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STTLcWZv4Wnzk1fJK8F6pg.png"/></div></div></figure><p id="bc2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们为这个接口定义了契约，包括添加和删除排队的动作，以及执行和撤销它们。我们还为ExecutionTime添加了一个属性，一旦添加了动画，这个属性将变得更加相关。就目前而言，它的作用是防止动作相互重叠。</p><p id="a0a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，每种类型的操作仍然需要它自己版本的execute方法，所以我们将为每种类型创建一个命令。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es km"><img src="../Images/fec7d8b534071caec0f0d9c4745eb8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9E9BNiqPEZK6RMBUQtcwIw.png"/></div></div></figure><p id="2a22" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是<em class="kn"> MoveObjectCommand </em>脚本的一个例子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/9f0201e3d261a6bbea28deca65d2630d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hI7IPjeh3Mc16_Ys8ewrug.png"/></div></div></figure><p id="b05f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当然，我们需要一种方法来将命令添加到列表中:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/41d65fb393533033496e45f56c3f6d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OPhEiItaOzVW-ld6ASRFQ.png"/></div></div></figure><p id="5dc2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一点上，我们可以看到Turn类不再有目的。这是它曾经包含的内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/11c71f62006a5bd34abecb67fcb470c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YKmLM5axW7EOP9ye.png"/></div></div></figure><p id="608c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所有这些信息对参与者都是可用的，参与者现在负责构造和执行他们自己的动作。我们可以完全抛弃这个类，简单地使用<em class="kn"> _commandBuffer </em>作为未决动作的列表。</p><p id="f855" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，这将我们带到新翻新的<em class="kn">流程RoundRoutine </em>协程:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/ecc12098b001036969c5cd784b4ac50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAb7eJom0xDdXZcXvJlBhw.png"/></div></div></figure><p id="c2f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在更精简了。这里的大部分操作都发生在一行代码中:<em class="kn"> currentActionNode。value . Execute()；</em>太棒了。不再需要检查含糊不清的通用<em class="kn">对象</em>类型，运行更少的列表，更少的依赖关系。</p><p id="3602" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用这个通用的过程，一定要花时间清理和重构你的代码。确保你在你的库的一个安全的分支上工作——当你“修复”它的时候，很容易破坏一些东西。制定一个强力的解决方案并把它留在那里是很容易的，但是如果你这样做了，从长远来看，你可能会让事情变得更难。重构一个刚刚构建好的新系统比以后被迫使用它要好。</p><p id="7667" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天到此为止。在下一篇文章中，我们将弄清楚处于危险中的人工智能受害者在等待被拯救的时候将如何决定如何处理自己。</p></div></div>    
</body>
</html>
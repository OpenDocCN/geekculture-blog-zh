<html>
<head>
<title>Prerequisites before starting Mathematics for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始数据科学数学之前的先决条件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/prerequisites-before-starting-mathematics-for-data-science-4834420baa6b?source=collection_archive---------29-----------------------#2021-08-29">https://medium.com/geekculture/prerequisites-before-starting-mathematics-for-data-science-4834420baa6b?source=collection_archive---------29-----------------------#2021-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="9d48" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">机器学习模型需要向量微积分、概率和优化，就像美味佳肴的配料一样。应用机器学习本质上就是将这些数学成分以巧妙的方式结合起来，创造出有用的(好吃？)模特。</p></blockquote><h1 id="79b1" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">设置</h1><p id="e438" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">集合是数学中最基本的概念之一。它们是如此的基本，以至于不能用其他任何东西来定义它们。相反，数学的其他分支是用集合来定义的，包括线性代数。简单地说，<strong class="il hj">集合是对象</strong>的明确定义的集合。这样的对象被称为集合中的<strong class="il hj">元素或成员</strong>。一个板球队的球员，一个班级的学生分数列表，以及IPL球队都是集合的例子。板球队队长，分数榜第一的学生，孟买印度人队，都是他们对应集合的“成员”或“元素”的例子。我们将带有大写斜体字母的集合表示为<strong class="il hj"> A </strong>。在线性代数的上下文中，我们说一条直线是一组点，平面中所有直线的集合是一组集合。同样，我们可以说<em class="ik">向量</em>是点集，<em class="ik">矩阵</em>是向量集。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="8b99" class="jh ji hi bd jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka ky kc kd ke bi translated">归属和包容</h1><p id="3f9b" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">我们使用<strong class="il hj">隶属于</strong>的概念来构建集合。我们用希腊字母epsilon表示<em class="ik"> a属于</em>(或者是<em class="ik">元素</em>或<em class="ik">成员</em>)A<strong class="il hj"><em class="ik"/></strong>:</p><p id="a54c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">a ∈ A</p><p id="d860" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">另一个重要的想法是<strong class="il hj">包含</strong>，它允许我们构建<em class="ik">子集</em>。考虑设置<strong class="il hj"> <em class="ik"> A </em> </strong>和<strong class="il hj"> <em class="ik"> B </em> </strong>。当<strong class="il hj"> <em class="ik"> A </em> </strong>的每一个元素都是<strong class="il hj"><em class="ik"/></strong>B的一个元素时，我们说<strong class="il hj"> <em class="ik"> A </em> </strong>是<strong class="il hj"><em class="ik">【B</em></strong>的一个<em class="ik">子集，或者说<strong class="il hj"> <em class="ik"> B </em> </strong> <em class="ik">包括</em> <strong class="il hj"> <em class="ik"> A </em> </strong>。符号是:</em></p><p id="454e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">A ⊂ B <strong class="il hj">或</strong> B ⊃ A</p><p id="9419" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">归属与包含来源于<strong class="il hj">公理的扩展</strong> : <em class="ik">两个集合相等当且仅当它们有相同的元素</em>。这个公理听起来似乎很简单，但却是使归属和包含变得严格所必需的。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="a9d4" class="jh ji hi bd jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka ky kc kd ke bi translated">设置规格</h1><p id="fffe" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">一般来说，我们断言的关于集合元素的任何事情都会导致<strong class="il hj">生成子集</strong>。换句话说，断言关于集合的事情是制造子集的一种方式。以所有狗的集合为例，我将其表示为<strong class="il hj"> <em class="ik"> D </em> </strong>。我现在可以断言“<strong class="il hj"> <em class="ik"> d </em> </strong>是黑的”。这种断言对所有狗的集合中的一些成员来说是正确的，而对另一些成员来说是错误的。于是，这样一个句子，为<em class="ik">所有</em>成员<strong class="il hj">DT15】求值，生成一个子集:<em class="ik">所有黑狗</em>的集合。这表示为:</strong></p><p id="31e1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">B={ d ∈ D : d是黑的}</p><p id="7789" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">或者</p><p id="2661" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">B={ d ∈ D| d是黑的}</p><p id="fe71" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">冒号(::)或竖线(||)读作“这样”。所以我们可以把上面的表达式解读为:<em class="ik"/><strong class="il hj"><em class="ik">D</em></strong><em class="ik">在</em> <strong class="il hj"> D </strong> <em class="ik">这样</em> <strong class="il hj"> <em class="ik"> d </em> </strong> <em class="ik">的所有元素都是黑色的</em>。这就是我们如何从<strong class="il hj"> A </strong>得到集合<strong class="il hj"> B </strong>的方法。</p><p id="f4c3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">如前所述，集合生成依赖于规范的<strong class="il hj">公理:<em class="ik">对于每个集合</em><strong class="il hj"/><em class="ik">和每个条件</em> S(x) <em class="ik">都有一个对应的集合</em> <strong class="il hj"> B </strong> <em class="ik">，其元素恰好是那些元素</em> a∈A <em class="ik">，其中</em> S(x) <em class="ik">成立。</em></strong></p><p id="7adb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">条件S(x)是关于元素<strong class="il hj"> A </strong>的任意<em class="ik">句子</em>或<em class="ik">断言</em>。有效句子是属于的<em class="ik">或等于</em>的<em class="ik">。当我们用逻辑运算符(not、if、and或等)组合归属和相等断言时，我们可以构建任何合法的集合。</em></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="f7ce" class="jh ji hi bd jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka ky kc kd ke bi translated">有序对</h1><p id="684c" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">成对器械包有两种类型:<em class="ik">无序</em>和<em class="ik">有序</em>。我们关心成对的集合，因为我们需要它们来定义关系和函数的概念(从这里开始，为了方便起见，我将用小写字母来表示集合，但是请记住，我们仍然在谈论集合)。</p><p id="fd7c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">考虑一对套<strong class="il hj"> <em class="ik"> x </em> </strong>和<strong class="il hj"> <em class="ik"> y </em> </strong>。一个<strong class="il hj">无序对</strong>是其元素为<em class="ik"> x，y </em> and ( <em class="ik"> x，y)=(y，x)的集合。</em>因此，演示顺序并不重要，设置是一样的。</p><p id="17f2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">在机器学习中，我们通常会关心呈现顺序。为此，我们需要定义一个<strong class="il hj">有序对</strong>(为了避免引入太多新概念，我将在直观的层面上介绍这个)。一个<strong class="il hj">有序对</strong>记为<strong class="il hj"> <em class="ik"> (x，y) </em> </strong>，其中<strong class="il hj"> <em class="ik"> x </em> </strong>为<em class="ik">第一坐标</em>，<strong class="il hj"><em class="ik"/></strong>为<em class="ik">第二坐标</em>。一个有效的有序偶具有<strong class="il hj"> (x，y)≦(y，x) </strong>的性质。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="0aaa" class="jh ji hi bd jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka ky kc kd ke bi translated">关系</h1><p id="0118" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">从有序对中，我们可以导出集合之间或元素与集合之间的关系的概念。关系可以是二元、三元或多元的。这里我们只关心二元关系。在集合论中，<strong class="il hj">关系</strong>被定义为有序对的<em class="ik">集合，记为<strong class="il hj"> R </strong>。因此，我们可以将<strong class="il hj"> x </strong>和<strong class="il hj"> y </strong>之间的关系表示为:</em></p><p id="46a4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">x <strong class="il hj"> R </strong> y</p><p id="4cba" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">此外，对于任何z∈R，存在x和y使得z=(x，y)。</p><p id="bc42" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">从R的定义可以得到<strong class="il hj">域</strong>和<strong class="il hj">值域</strong>的概念。<strong class="il hj">域</strong>是一个集合，定义为:</p><p id="e035" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj">DOM</strong>R = { x:for some y(x R y)}</p><p id="255b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">这读作:x的值使得对于y的至少一个元素，x与y有关系。</p><p id="2b49" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj">范围</strong>是一组定义为:</p><p id="8e29" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj">冉</strong> R={y:对于某些x (x R y)}</p><p id="d285" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">意思是:由y的值形成的集合，使得x，x中至少有一个元素与y有关系。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="9d9b" class="jh ji hi bd jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka ky kc kd ke bi translated"><strong class="ak">功能</strong></h1><p id="a5ad" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it kh ki iw ix kj kk ja jb kl km je jf jg hb bi translated">考虑一对集合X和Y。我们说从X到Y的<strong class="il hj">函数</strong>是这样的关系:</p><p id="4f40" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj"> dom </strong> f= <strong class="il hj"> X </strong>并且</p><p id="85e2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">使得对于每个<strong class="il hj"> x ∈ X </strong>都有一个唯一的元素<strong class="il hj"> y ∈ Y </strong>和<strong class="il hj"> (x，y) ∈ f. </strong></p><p id="8a20" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">一个函数“<em class="ik"> transform </em>”或“<em class="ik"> maps </em>”或“<em class="ik">send</em>”x到y上，对于每个“<em class="ik">自变量</em>”x都有一个唯一值y，f“<em class="ik">取</em>”或“<em class="ik">取</em>”。</p><p id="4a9f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">我们通常将从X到Y的关系或函数或变换或映射表示为:</p><p id="ded7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj"> f : X→Y </strong></p><p id="c56a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">或者</p><p id="2c9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj"> f(x) = y </strong></p><p id="5661" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">查看这个函数定义的效果的简单方法是用图表。在图1 的<strong class="il hj">中，左窗格显示一个有效函数，即每个值f(x) <em class="ik">将</em>唯一映射到y的一个值上。右窗格不是函数，因为每个值f(x) <em class="ik">将</em>映射到y的多个值上。这也称为<em class="ik">垂直线测试。</em></strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/561bf0735371ca3d87f92ade6edd6a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYFDh7ndx2m53MOqqwPXZg.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx"><strong class="bd jj">Fig . 1</strong></figcaption></figure><p id="699d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">对于f:X→Y，f的<em class="ik">域</em>等于X，但是<em class="ik">范围</em>不一定等于Y，只要回忆一下<em class="ik">范围</em>只包括Y与X有关系的元素。</p><p id="984e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated"><strong class="il hj">机器学习的最终目标是从数据</strong>中学习函数，即从函数的<em class="ik">域</em>到<em class="ik">范围</em>的转换或映射。这听起来很简单，但却是事实。<em class="ik">域</em> X通常是<em class="ik">变量</em>或<em class="ik">特征</em>的向量(或集合)映射到<em class="ik">目标</em>值的向量上。最后，我想强调的是，在机器学习中，转换和映射这两个词可以互换使用，但两者都意味着功能。</p><p id="644b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">这就是我要讲的关于集合和函数的全部内容。我的目标只是介绍:(1) <strong class="il hj">集合的概念</strong>，(2) <strong class="il hj">基本集合符号</strong>，(3) <strong class="il hj">集合是如何产生的</strong>，(4) <strong class="il hj">集合如何允许函数的定义</strong>，(5) <strong class="il hj">函数的概念</strong>。集合论是一个不朽的领域，但没有必要学习关于集合的一切来理解线性代数。</p><p id="9d2f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it kh iv iw ix kj iz ja jb kl jd je jf jg hb bi translated">在接下来的博客中，我将涵盖数据科学所需的线性代数的所有主题。</p></div></div>    
</body>
</html>
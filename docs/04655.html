<html>
<head>
<title>How I Built a Self Driving Model Car</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何建造一辆自动驾驶模型车的</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-built-a-self-driving-model-car-b5277dee57e2?source=collection_archive---------65-----------------------#2021-06-30">https://medium.com/geekculture/how-i-built-a-self-driving-model-car-b5277dee57e2?source=collection_archive---------65-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4628" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第3部分—尝试让它行驶</h2></div><p id="603b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个系列以前的文章可以在这里找到。</p><h1 id="ae52" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">利用OpenCV进行图像预处理</h1><p id="6e9d" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我有点失望——我读过的其他博客似乎都是即插即用的。诚然，我在这里有更多的自定义代码，但我认为它应该做得更好。</p><p id="61eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对行驶直方图进行一些检查后:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es kr"><img src="../Images/4d2321be01000e47b07e4d17e58c5c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*6Y0vz7KkQ6PNA3sdgmvRcA.png"/></div></figure><p id="3ad0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切似乎都很好，所以我的下一个想法是，在其他视频中，人们有更大的房间和更清晰的道路。我的路是一些遮蔽胶带，贴在反光的木地板上，在一个有很多家具的小空间里。也许模型变得混乱，所以我想一些图像预处理会有所帮助。</p><h2 id="9a4c" class="kz jv hi bd jw la lb lc ka ld le lf ke jg lg lh kg jk li lj ki jo lk ll kk lm bi translated">HSV图像和边缘检测</h2><p id="0474" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">色调、饱和度、值图像空间对于提取特定颜色是有用的。在我的例子中，我想要道路边缘的白线。OpenCV为此提供了许多有用的功能，但我的问题是，在我的设置中，有时道路边缘太暗。这是一组图像，我首先转换到HSV色彩空间，提取“白色”，模糊它，并掩盖它，使边缘变亮。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/a4e1abddbe12581635b540079762fff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqRmHEMn5WfeIhF1IdhnsQ.png"/></div></div></figure><p id="f71d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，它不能提取右侧边缘，但边缘检测可以。在这里，我使用了一个精明的边缘检测器，然后找到轮廓并试图填充任何较小的间隙，然后将感兴趣的区域限制在离汽车更近的道路上:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/13724e05d8275dd2193ceb3e9e5f6653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-P4RfNGvrLRm0oT9Mi0Kg.png"/></div></div></figure><h2 id="fbc9" class="kz jv hi bd jw la lb lc ka ld le lf ke jg lg lh kg jk li lj ki jo lk ll kk lm bi translated">车道寻找</h2><p id="a792" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我们可以从中获得更多的乐趣，并尝试找到实际车道的平面区域。我们首先通过使用<em class="lt"> getPerspectiveTransform </em>和<em class="lt"> warpPerspective </em>函数投影图像来移除透视。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lu"><img src="../Images/343d88b904a0fe95149f789df2bb727d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*TGCZ6bTxC3Z3b3YDZ1BauQ.png"/></div></figure><p id="91dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们的道路边缘足够强，我们可以使用图像中沿着靠近汽车的x轴的强度直方图来找到每个边缘的起点。然后通过在盒子内探索并向上移动图像，我们可以沿着边缘并在每一行存储中心边缘点。然后可以对每一条曲线进行拟合和填充。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lv"><img src="../Images/5d0e511dbd27af8452fe00de83968673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYTYYfQ1WsQI-2g3qysWtg.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">The yellow boxes are the areas where we look for the road edges, starting at the bottom and moving up the image. The red and blue indicate prospective road edges. From these we fit polygons and fill to produce the lane.</figcaption></figure><p id="f098" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们有了这些，我们就可以采用反向透视，将车道叠加到原始图像上。这有时工作得相当好，但是在这种环境下是脆弱的。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ma"><img src="../Images/1577317f8baaec33a7a115ace628a681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRSLUMG4JAlCDIkxiSM9HQ.png"/></div></div></figure><p id="b107" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">鉴于急转弯，这可能会失败的壮观！</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mb"><img src="../Images/82e0cfeaddbaf1e9701f6317bede0284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INbjlruS2fNyqKOlbSuxTg.png"/></div></div></figure><h2 id="459a" class="kz jv hi bd jw la lb lc ka ld le lf ke jg lg lh kg jk li lj ki jo lk ll kk lm bi translated">用预处理的图像进行训练</h2><p id="f2cd" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我原本认为我可以使用车道搜索来“着色”实际道路，从而为机器学习获得更强的特征，但这不够一致，所以我放弃了它，但保留了图像处理。我通过预处理管道运行所有记录的图像，并保存它们用于训练，这导致了更好的损失。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es mc"><img src="../Images/edb33e9a2433a488e5d4bc51bd01482c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*qQRK5U4l5G_ipu9ccrfUNw.png"/></div></figure><h1 id="7e74" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">疯狂的</h1><p id="6e84" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">但是车还是开不动！这是我开始认为其他地方出了问题，并着手调试DonkeyCar代码的时候。在查看了驱动循环的时间后，我发现推理循环花费了大约200毫秒，这对于汽车自动驾驶来说根本不够快。在问了东奇卡话语频道之后，似乎有一个问题<a class="ae jt" href="https://github.com/autorope/donkeycar/pull/861" rel="noopener ugc nofollow" target="_blank">https://github.com/autorope/donkeycar/pull/861</a></p><p id="4b3b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用这些变化使推理循环缩短到25-30毫秒，汽车能够自动驾驶！</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="md me l"/></div></figure><h1 id="69df" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">下次</h1><p id="7957" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在下一篇文章中，我将介绍一种更大更快的汽车，它也有自己的问题！我们将利用TensorFlow Lite、最大性能模式、RC控制器，最终得到一辆可以在户外行驶的汽车。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Timeseries Prediction Using Tensor flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于张量流的时间序列预测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/timeseries-prediction-using-tensor-flow-e85aa3ab8648?source=collection_archive---------20-----------------------#2021-09-06">https://medium.com/geekculture/timeseries-prediction-using-tensor-flow-e85aa3ab8648?source=collection_archive---------20-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6b30c64cf72375780b7c80cfe1f8141d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2NHoM-Knm3LwbB_IFYdQaw.jpeg"/></div></div></figure><p id="05e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将使用神经网络对未来24小时内确诊的新冠肺炎病例总数进行预测。用于进行预测的数据已从URL<a class="ae jo" href="https://api.covid19india.org/csv/latest/case_time_series.csv" rel="noopener ugc nofollow" target="_blank">https://API . covid 19 India . org/CSV/latest/case _ time _ series . CSV</a>获得，它涉及印度新冠肺炎病例的汇编细节。本文的目的是学习使用张量流的神经网络(AI)的应用，以使用时间序列数据进行预测。</p><p id="355c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了设置环境，我们将在Google colab中打开一个新的Jupyter笔记本，并导入一些基本的包。这些被导入到环境中的基本包/库是pandas、numpy和matplotlib。这些将分别用于操纵数据框架、使用数学函数和创建数据集图形可视化的图形。为此，需要执行下面Jupyter笔记本单元中提到的代码</p><p id="adc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">导入熊猫为pd <br/>导入numpy为np <br/>导入matplotlib.pyplot为PLT<br/>% matplotlib inline</em></strong></p><p id="2dfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的下一步将是导入数据集，该数据集将用作获得预测的输入。该数据集与每天更新的印度新冠肺炎病例汇编有关。该数据集可在网站<a class="ae jo" href="https://api.covid19india.org/csv/latest/case_time_series.csv" rel="noopener ugc nofollow" target="_blank">https://API . covid 19 India . org/CSV/latest/case _ time _ series . CSV</a>上开源获得。导入后的数据集存储在工作环境中新创建的数据框(df)中。一旦数据成功导入数据框，将使用函数df.head()对数据集进行可视化分析。为此，需要执行下面Jupyter笔记本单元中提到的代码</p><p id="cb93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">URL = '</em></strong><a class="ae jo" href="https://api.covid19india.org/csv/latest/case_time_series.csv'" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="jp">https://API . covid 19 India . org/CSV/latest/case _ time _ series . CSV '</em></strong></a><strong class="is hj"><em class="jp"><br/>df = PD . read _ CSV(URL)<br/>df . head()</em></strong></p><p id="f095" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要格式化数据帧的日期列，然后指定“<strong class="is hj">日期</strong>列作为索引，此后我们将使用数据集作为时间序列数据集。此外，我们将通过删除不再需要的列来刷新数据集(这一步是可选的)。为了便于上述步骤，需要执行Jupyter notebook单元中下面提到的代码(下面的df_tail.head(7)单元用于检查现在获得的新数据集:-</p><p id="8d05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">从日期时间导入日期时间<br/> df。Date = pd.to_datetime(df。Date，format = ' % d % B % Y ')<br/>df . set _ index(' Date，in place = True)<br/>df = df . drop([' Date _ YMD '，'每日确认'，'每日恢复'，'每日死亡']，axis=1) <br/> df.tail(5) </em> </strong></p><p id="f730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是将数据集划分为训练和测试目的。这是一个时间序列数据集，我们将其分为两部分，即截至2021年4月30日的数据集，作为训练模型的数据集，以及此后2021年5月1日以后的数据集，用于测试模型。请注意，将数据集划分为时间序列数据的测试和训练数据集的这一步骤不同于划分非时间序列数据集的步骤。Jupyter笔记本单元中的下述代码就是为此目的而执行的</p><p id="b1a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">df _ train = df[' 2020–01–30 ':' 2021–05–30 ']<br/>df _ test = df[' 2021–06–01 ':]</em></strong></p><p id="c881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为在这个例子中我们会用到张量流。我们将导入张量流包，也将时间序列生成器导入到环境中。时间序列生成器接收以相等间隔收集的一系列数据点以及时间序列样本参数，并使用输入和输出组件转换样本，还通知模型将学习的内容，即进行预测所需的内容(输入)和要进行的预测(输出)。下面提到的代码一旦在Jupyter notebook cell中执行，将导入张量流，时间序列生成器:-</p><p id="0c91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">从tensorflow . keras . preprocessing . sequence导入时间序列生成器</em> </strong>导入tensor flow作为tf <br/></p><p id="13f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面提到的代码中，TimeseriesGenerator会将timeseries数据集分别转换为train和test数据集(generator_train/generator_test)。我们将尝试通过使用前六天的数据集(相应地，以参数表示的长度=6)作为tensorflow模型的输入，得出第七天“总确诊病例”的预测值。批量大小将定义在给定时间将通过网络传播的样本数量。将执行下面给出的代码，以准备将在张量流模型中使用的训练和测试数据集(发电机_训练和发电机_测试)</p><p id="360d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">generator _ train = TimeseriesGenerator(df_train['总确认']，df _ train['总确认']，length=5，batch _ size = 1)<br/>generator _ train[0]<br/>df _ train['总确认']。head(6)<br/>generator _ test = TimeseriesGenerator(df_test['总确认']，df _ test['总确认']，length=5，batch _ size = 1)<br/>generator _ test[0]<br/>df _ test['总确认']。</em>头(6)</strong></p><p id="128f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是设置random.set.seed()，它将“锁定”伪随机数生成器，以便在使用tensorflow模型(下面代码中的model_1)时帮助进行可复制的分析。张量流模型有三层，第一层是输入层(tf.keras.layers.Dense (64，activation='relu '，input_dim=6))，下一层是隐藏层(tf.keras.layers.Dense(64，activation='relu ')，最后一层是输出层(tf.keras.layers.Dense(1))。输入层中的input_dim将输入维度指定为6，因为有六个输入。此外，维度1是在输出层中指定的，因为我们将得到一个输出。此外，r个整流线性激活单元函数(‘ReLU’)将用于已经创建的模型中(<strong class="is hj"> ReLU function(f(x)=max(0，x))如果它接收到任何负输入，则返回0，但是对于任何正值x，它返回该值。因此，它给出的输出范围从0到无穷大)</strong>。上述步骤将通过执行包含以下命令的Jupyter笔记本单元来执行</p><p id="c400" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">#建立模型<strong class="is hj"><em class="jp"><br/>TF . random . set _ seed(13)<br/>Model _ 1 = TF . keras . sequential([<br/>TF . keras . layers . dense(64，activation='relu '，input_dim=5)，<br/> tf.keras.layers.Dense(64，activation='relu ')，<br/>TF . keras . layers . dense(1)<br/>)</em></strong></p><p id="3403" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了总结模型，我们将执行命令model_1.summary()。模型中共有4609个可训练参数(第一层<strong class="is hj"> 64* 6，第二层64+1* 64，第三层</strong>64+1)。下一步是编译模型。为编译给出的参数是optimizer ='adam '、loss='mse '(均方误差，即它提供了通过对数据集的平均差进行平方而提取的原始值和预测值之间的差)和metrics = 'mae '(平均绝对误差，即。它提供了原始值和预测值之间的差值，该差值是通过对数据集上的绝对差值进行平均而提取的)。Jupyter笔记本单元中的下述代码就是为此目的而执行的</p><p id="8d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">model _ 1 . summary()<br/>model _ 1 . compile(optimizer = ' Adam '，loss='mse '，metrics = 'mae') </em> </strong></p><p id="44b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是使用train(generator_train)，test(generator_test)数据集拟合模型。进一步的时期参数被给定为50，这意味着机器学习算法将在该训练期间对训练数据集进行50次遍历。如此获得的值即loss、mae和val_loss以及val_mae将被转换成数据帧(结果)并显示。为了检查有效性，我们可以在图中用图形比较损失和val_loss。loss和val_loss的值应该匹配，以获得接近完美的预测值:-</p><p id="3fcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">历史=模型_1.fit(发电机_列车，历元= 360，验证_数据=发电机_测试)<br/>历史.历史<br/>结果=pd。data frame(history . history)<br/>result . head(10)<br/>结果[['loss '，' val_loss']]。</em>剧情()</strong></p><p id="5771" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是使用训练好的模型进行预测。我们需要记住，对特定日期获得的预测值实际上是对第二天(未来)的预测。此外，该模型不会对训练数据集的前6天进行预测，因为该模型已经使用6天的值进行了训练，以达到在当前情况下对第7天的预测。在当前情况下，df_predict用于存储预测值，df_predict_df是创建的数据帧，用于存储列'<strong class="is hj"> Next_Day_Pred' </strong>中的预测值。此外，我们可以直观地比较实际值(通过绘图以图形方式显示df_test和df_predict值)。所有这些步骤都可以通过在Jypyter notebook cell中执行下面提到的命令来实现。</p><p id="6151" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">df _ predict = model _ 1 . predict(generator _ test)<br/>df _ predict = TF . squeeze(df _ predict)<br/>df _ predict . numpy()。形状<br/> df_predict_df = pd。DataFrame(df_predict，columns =[' Next _ Day _ Pred '])<br/>df _ predict _ df . head()<br/>df _ test[6:]。tail()<br/>PLT . scatter(df _ predict，df_test['已确认总数'][5:]，color='red') <br/> plt.xlabel('预测值')<br/> plt.ylabel('实际值')<br/> plt.title('Covid病例:已确认总数预测数')<br/> plt.plot(df_predict，label= '预测值')<br/> plt.plot(df_test['已死亡总数')][5:]。values，label= '实际值')<br/>PLT . legend()；</em>T25】</strong></p><p id="b079" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，为了比较预测值和实际值，我们将向预测值数据集(df_predict_df)添加日期，以创建一个时间序列数据集。为了进一步进行有意义的比较，我们将采用df_test数据帧(删除前6个值),创建一个新的数据帧(Result_df ),并将df_predict_df数据帧中的“<strong class="is hj">Next _ Day _ Pred<em class="jp">”</em></strong>添加到该数据帧中。所有这些都将通过在JupyterNotebook单元格中执行以下命令来实现。</p><p id="cb3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jp">Result _ df = df _ test[5:]<br/>df _ predict _ df . head()<br/>df _ predict _ df[' Date ']= PD . Date _ range(start = ' 2021–05–06 '，periods=len(df_predict_df)，freq='D') <br/> df_predict_df。date = PD . to _ datetime(df _ predict _ df。Date，format = ' % d % B % Y ')<br/>df _ predict _ df . set _ index(' Date '，in place = True)<br/>PD . concat([Result _ df，df_predict_df]，axis=1) </em> </strong></p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jq"><img src="../Images/531d25b91d4a685309b47646acfe5eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZmqA4t6ct0KutFx1D26NQ.png"/></div></div></figure><p id="a4b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述问题陈述和解决方案(<strong class="is hj">对未来24小时</strong>的预测)是为了学习神经网络在真实数据集中的应用。为了获得近乎完美的结果，无疑需要对模型进行细化和微调。这个模型也可以用来预测股票价格。我期待社区对此模型的改进提出建议。</p><p id="69b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong></p><p id="5e84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.<a class="ae jo" href="https://api.covid19india.org/csv/latest/case_time_series.csv" rel="noopener ugc nofollow" target="_blank">https://API . covid 19 India . org/CSV/latest/case _ time _ series . CSV</a>。<br/> 2。使用来自<strong class="is hj"> TalentEdge </strong>平台的R和Python进行财务分析时获得的知识</p></div></div>    
</body>
</html>
<html>
<head>
<title>Recursion vs Dynamic Programming — Climbing Stairs (Leetcode 70)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归与动态编程——爬楼梯(Leetcode 70)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/recursion-vs-dynamic-programming-climbing-stairs-48032b31db98?source=collection_archive---------2-----------------------#2021-10-14">https://medium.com/geekculture/recursion-vs-dynamic-programming-climbing-stairs-48032b31db98?source=collection_archive---------2-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/54e79a8b5fbb3bd1954c745eb9663e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amjqIQT6JxXoE39MVLYqZQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Pattern Plot, Image by Author</figcaption></figure><div class=""/><p id="391f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇博客中，我将使用Leetcode 70。以爬楼梯为例，说明用Python进行递归和动态编程的编码逻辑和复杂性。</p><p id="2ab3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该项目由<strong class="iw hy">马树恒</strong>建造。要查看使用的完整代码，请找到<a class="ae js" href="https://github.com/hzmsh/DynamicProgramming" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><p id="7718" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">注</strong>:如果你是递归或动态编程的新手，我强烈建议你先看看下面的博客:</p><blockquote class="jt ju jv"><p id="46fb" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated"><a class="ae js" href="https://towardsdatascience.com/dynamic-programming-i-python-8b20387870f5" rel="noopener" target="_blank">递归vs动态规划——斐波那契</a></p></blockquote><h1 id="f2e1" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第1节:递归和动态编程简介</h1><h2 id="dade" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">1.1背景</h2><p id="120f" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated"><em class="jw">让我们从什么是递归开始</em></p><p id="6721" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">递归</strong>是一个函数调用自身直到到达基本用例的过程。而且在这个过程中，复杂的情况会被递归追踪，变得越来越简单。整个流程的结构是树状的。递归<strong class="iw hy">不存储任何值</strong>，直到到达最终阶段(基本情况)。</p><p id="16f8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而<strong class="iw hy">动态编程</strong>相比简单递归主要是一种优化。主要思想是将原始问题分解成可重复的模式，然后<strong class="iw hy">将结果存储为许多子答案</strong>。因此，我们<strong class="iw hy">不必在以后需要时重新计算</strong>前一步的答案。在大O方面，这种优化方法一般将时间复杂度从指数级降低到多项式级。</p><h1 id="8ad4" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.2如何编写递归/动态编程脚本</h1><p id="5281" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated"><em class="jw">动态编程和递归非常相似</em></p><ol class=""><li id="a03e" class="lr ls hx iw b ix iy jb jc jf lt jj lu jn lv jr lw lx ly lz bi translated">递归和动态编程都是从我们初始化开始的基本情况开始的。</li></ol><p id="2fc9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.在我们写完基础案例之后，我们将试图找到问题逻辑流程所遵循的任何模式。一旦找到了，基本就完事了。</p><p id="1c2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.主要区别在于，对于递归，我们<strong class="iw hy">不存储任何中间值</strong>，而动态编程却利用了这一点。</p><p id="e6ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们爬更深一点的楼梯。</p><h1 id="385f" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第2部分:示例:Leetcode 70。爬楼梯</h1><h2 id="8e31" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">2.1问题提示</h2><blockquote class="jt ju jv"><p id="e650" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">你正在爬楼梯。到达顶端需要<code class="du ma mb mc md b">n</code>步。</p><p id="5998" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">每次你可以爬<code class="du ma mb mc md b">1</code>或<code class="du ma mb mc md b">2</code>台阶。有多少种不同的方式可以让你爬上顶峰？</p></blockquote><h2 id="ec91" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">2.2示例</h2><p id="6607" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">以下是一些易于理解的例子:</p><blockquote class="jt ju jv"><p id="69a5" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">当n = 1时，我们有<code class="du ma mb mc md b"><em class="hx">1</em></code>的方法到达那里。我们可以走一步到达n = 1。</p><p id="e299" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">当n = 2时，我们有<code class="du ma mb mc md b"><em class="hx">2</em></code>种方法可以到达那里。我们要么走1 + 1步，要么走2步就是n = 2。</p></blockquote><h1 id="0333" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第3节:两种方法</h1><h2 id="00c3" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">3.3递归方法</h2><p id="192a" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">让我们从递归方法开始。</p><h2 id="cd2e" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">递归代码</h2><figure class="me mf mg mh fd hk"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Code, Image by Author</figcaption></figure><p id="6e64" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从上面的代码中，我们可以看到，我们做的第一件事总是寻找<strong class="iw hy">基本情况。</strong></p><p id="ecc5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，基本情况是当n = 0时，不需要采取任何步骤。当n = 1时，只有一种方法:向上步进1个单位。当n =2时，为了达到这个目的，我们可以向上1 + 1或者向上2个单位，总共2个方法。</p><p id="4b21" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在基本情况之后，下一步是考虑有多少种不同的方式来达到n的一般模式。与斐波那契不同，问题提示没有给出模式。</p><p id="bdf6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们检查一个比基本情况更复杂的情况来找出模式。</p><h2 id="0edc" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">3.3.2寻找模式</h2><p id="6409" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">让我们想想，如果n = 4 <strong class="iw hy">递归</strong>，我们应该如何处理。</p><p id="0052" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了步进n = 4，我们必须步进n = 3或n =2，因为我们每次只能步进1或2个单位。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/54e79a8b5fbb3bd1954c745eb9663e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amjqIQT6JxXoE39MVLYqZQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Pattern Plot, Image by Author</figcaption></figure><p id="1996" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了踩n =3，我们可以踩n = 2或者n = 1。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/4df930623ec82e5fa53b1bca03a384ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRW3-snqEOf_y2JRQFP8AA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Pattern Plot, Image by Author</figcaption></figure><p id="d280" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是请注意，我们已经有了n = 2和n =1的基本情况。</p><p id="b07a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们知道，如果有2个方法去踩n = 2，有1个方法去踩n = 1。因此，在n = 3上总共有三种方法，因为我们必须在n = 2或n = 1上进行。换句话说，有2 + 1 = 3种方法可以得到n =3。</p><p id="4579" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于n =4，我们基本上增加了n = 3和n =2的不同方法。最终，有3 + 2 = 5种方法可以得到n = 4。</p><blockquote class="jt ju jv"><p id="380a" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">一般模式:第n级楼梯处的不同路线=路线@ (n-1) +路线@ (n-2)</p></blockquote><p id="6d3f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们仔细看看下面的可视化。</p><h2 id="a66f" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">递归程序图</h2><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ml"><img src="../Images/ebe69ab8b64827be2e0594f9b7be24fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLtHKFE3MwWAQDuVkVl59Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Procedure Plot, Image by Author</figcaption></figure><p id="3952" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从最上面开始，这里n[4] = n[3] + n[2]。然后我们会试着求n[3]的值。最终，当我们到达n[2] = 2，n[1] = 1的基本情况时，我们可以简单地从下往上求和，得到n[4] = 5。</p><h2 id="5be5" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">3.4动态规划方法</h2><h2 id="6c71" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">递归代码</h2><figure class="me mf mg mh fd hk"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Dynamic Programming Code, Image by Author</figcaption></figure><p id="d41a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从上面的代码中，我们可以看到，我们做的第一件事是再次寻找<strong class="iw hy">的基本情况。</strong></p><p id="2b3c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，基本情况将是当n =1时，distinct ways = 1，当n = 2时，distinct ways = 2，为了实现该效果，我们将这两个条件显式地写在if下。</p><p id="6cc6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们完成基础案例后，我们将创建一个预填充的动态编程数组来存储所有的中间和临时结果，以便更快地进行计算。由于我们不知道可能有多少种不同的方式，我们将<strong class="iw hy">不创建固定长度的数组</strong>，相反，我们将创建<strong class="iw hy">一个在此过程中不断增长的数组</strong>。</p><p id="b4ff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们已经知道n = 1有1路，n = 2有2路，所以让我们把这两种情况放在index = 0和index = 1的数组中。</p><p id="c2dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下一步是考虑第n级楼梯将产生多少不同路线的一般模式。幸运的是，我们已经在前面的递归部分中找出了模式。</p><blockquote class="jt ju jv"><p id="2e4b" class="iu iv jw iw b ix iy iz ja jb jc jd je jx jg jh ji jy jk jl jm jz jo jp jq jr hb bi translated">一般模式:第n级楼梯处的不同路线=路线@ (n-1) +路线@ (n-2)</p></blockquote><p id="db81" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，我们可以使用上面的公式简单地生成每一个楼梯。我们可以将每个楼梯的不同路线的数量存储到沿途的dp数组中。</p><p id="8580" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这实际上是动态编程和递归的主要区别。在递归中，我们不存储任何中间结果，而在动态编程中，我们存储所有中间步骤。</p><p id="f60e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了计算n = 4，我们会先计算n =3，<strong class="iw hy">将值存储到我们事先创建的DP列表</strong>中。</p><h2 id="cd80" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">3.4.2动态编程程序图</h2><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mm"><img src="../Images/2747cb00393370349182b9d36dca4fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYBaOb_UzA62ycdke1SWeQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Dynamic Programming Procedure Plot, Image by Author</figcaption></figure><p id="5acb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从最左边开始，这里数组[0]=1，数组[1] = 2。然后，我们将尝试查找数组[3]的值，对于n =4，我们将首先查找数组[2]的值，并将它的值存储到dp_list中。最终，当我们到达array[3] = 5的右侧时，我们可以返回最终结果。</p><h1 id="aa0a" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第四节:时间和空间复杂性</h1><h2 id="40ca" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">4.1递归的大O</h2><p id="43f7" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">对于递归，时间复杂度将是O(2^(n)，因为每个节点将分裂成两个子分支<em class="jw">(为了精确，我们可以看到它是O(2^(n-2)，因为我们已经提供了两个基本情况，但是在这一级上真的没有必要区分)</em>。</p><p id="e259" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并且空间复杂度将是O(n ),因为树的深度将与n的大小成比例</p><p id="d827" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是两者的Leetcode运行时结果:</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mn"><img src="../Images/57bb097690a67bef12155a18f55c940f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYYxk4eoNe8-LAUwNBoTvg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Leetcode Recursion Result, Image by Author</figcaption></figure><h2 id="4c3f" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">4.2动态编程的大O</h2><p id="7e16" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">对于动态编程，时间复杂度是O(n ),因为我们只循环一次。正如你在动态编程程序图中看到的，它是线性的。</p><p id="beec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并且空间复杂度将是O(N ),因为我们需要将所有中间值存储到dp_list中。所以我们需要的空间和给定的n一样。</p><p id="e25a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是两者的Leetcode运行时结果:</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/62fc436142c42086a0e8cad9032ca99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrc_8W9J0oVQj_0iqZ1nFw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Leetcode Dynamic Programming Result, Image by Author</figcaption></figure><p id="b95a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么递归方法在n = 38时会失败？</p><p id="270b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看下面的可视化</p><h2 id="f065" class="ky kb hx bd kc kz la lb kg lc ld le kk jf lf lg ko jj lh li ks jn lj lk kw ll bi translated">4.2时间复杂性的可视化</h2><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/47c04a2655dde79bb1a1909ec5c8652e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMiDmENoicIyjUWXhZ4VZg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Time Complexity Speed Comparison, Image by Author</figcaption></figure><p id="4432" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">红线代表递归的时间复杂度，蓝线代表动态编程。x轴表示n的大小，y轴表示算法计算结果所需的时间。</p><p id="8b4a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们试图计算<strong class="iw hy"> n = 38 </strong>时，它需要我们的动态编程<strong class="iw hy"> 38个单位</strong>来计算值，因为我们有O(n)用于动态编程。</p><p id="49fa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，我们将无法找到解决方案，直到<strong class="iw hy"> 2 ⁸ = 274877906944 </strong>递归可以产生一个解决方案，因为它有O(2^n).这就是为什么Leetcode给了我们运行时错误。</p><h1 id="46b6" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第五部分:总结与结论</h1><p id="d210" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">简单回顾一下，下面总结了一些要点:</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/e5a058f27aa9dd073a404eb3e4f1a537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dauP0DrTzguz76e3.png"/></div></div></figure><p id="5c31" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从上面，我们可以观察到，尽管递归和动态编程都可以处理计算爬楼梯的任务，但是它们在处理中间结果和<strong class="iw hy">时间消耗</strong>方面有很大的不同。动态编程使用同样多的空间，但是它比T4快得多。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/e0df495e2805b1626e3404bb3d5a933d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gw-v4h4cKp5BjtYVjx40HQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Real-Time Complexity Speed Plot, Image by Author</figcaption></figure><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/e88460ff8505557d19af263adc29eb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErSuNnF_dCPaBWaTRuaR9g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Recursion Method Theoretical Time Complexity Speed Plot, Image by Author</figcaption></figure><p id="d2ff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据上面的图，x轴表示n = 35到41时的情况，y轴表示递归方法根据不同n的时间消耗。很明显，时间消耗曲线<strong class="iw hy">更接近指数而非线性。</strong></p><p id="4d19" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">尽管这两种算法都需要几乎相同难度的努力来理解逻辑(我希望我的博客能对你有所帮助)，但在你掌握了算法的核心之后，这是值得的，因为大量的数组问题可以通过动态编程优雅而高效地解决。</p><p id="f2c4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你觉得你完全理解了上面的例子，并且想要更有挑战性的例子，我计划在不久的将来使用动态编程和递归来解决一系列博客中更困难和现实生活中的问题。感谢您的阅读！</p></div></div>    
</body>
</html>
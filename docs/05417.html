<html>
<head>
<title>Radix Sort. Number Magic?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基数排序。数字魔法？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/radix-sort-number-magic-694c103e11c8?source=collection_archive---------27-----------------------#2021-07-20">https://medium.com/geekculture/radix-sort-number-magic-694c103e11c8?source=collection_archive---------27-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d57f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基数排序在排序算法领域有点特殊，让我想起了麦片盒子背面的数字魔术。所以让我们来看看基数排序到底有多神奇。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2915c46a7c4e25528d229edcd265670b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nv2oJDTJwOyAps3x"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@nhillier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Hillier</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b9ae" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是基数排序？</h1><p id="34f0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">根据<a class="ae jt" href="https://en.wikipedia.org/wiki/Radix_sort" rel="noopener ugc nofollow" target="_blank">维基百科</a>。基数排序是一种非<a class="ae jt" href="https://en.wikipedia.org/wiki/Comparison_sort" rel="noopener ugc nofollow" target="_blank">比较</a> <a class="ae jt" href="https://en.wikipedia.org/wiki/Sorting_algorithm" rel="noopener ugc nofollow" target="_blank">排序算法</a>。它通过根据<a class="ae jt" href="https://en.wikipedia.org/wiki/Radix" rel="noopener ugc nofollow" target="_blank">基数</a>创建元素并将其分配到桶中来避免比较。换句话说，它利用数字的固有属性进行排序。</p><p id="7de9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基数是什么？基数只是数字系统的基础系统。对于你的标准数字系统，它是以10为基数，数字0-9或10个独特的符号。在十六进制中，它将是一个基数为16的系统，因为你有16个唯一的符号。</p><p id="ab0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一些文字桶来帮助解释发生了什么。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/cad3e3819f660d5c8b275edafbb8ae27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uY8v4zC_Yakj4kgNHq1CmQ.gif"/></div></div></figure><p id="b5e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将转向更复杂的例子，但是我想把这一点放在区分因素上。基数排序与其他排序算法的主要区别在于，它不是将项目相互比较，而是使用符号(如0，1，2，3)将它们排序到桶中。哦，还有一件事要提，因为它是不可比较的，所以它确实需要数字来排序。从技术上讲，其他数据类型的数据可以转换成它们的数字对应物。例如，您可以通过将像素的颜色转换为十六进制形式来对图像的颜色进行基数排序。</p><h1 id="ada1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">虚假的例子</h1><p id="064e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以我解释了什么是基数排序。现在是时候看看一些伪例子了。来展示这个算法是如何发挥它的魔力的。正如我之前提到的，它确实需要数字来排序，但是它的工作方式是循环遍历数字中相同位置的所有数字。举个例子，如果我们有一个数组。<code class="du ky kz la lb b">[55,21,45,8,12]</code>它将遍历每个循环的数字集合的相同位置值，以将它们分配到桶中。假设我们的循环是在一个位置值上，它将按5(5)，2(1)，4(5)，(8)，1(2)分布上面的数组。为了帮助澄清发生了什么，这里有一个可视化的表示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/a7344c73c4ca729561697184e4ebea6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k-1U9JbHopXT-uSvlp316w.gif"/></div></div></figure><p id="7ae3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，该算法根据一个位置的数字将数字分类到桶中。这将从数字的右边继续到左边，直到我们用完所有数字中的位置。</p><p id="0518" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们对12和34872这样的数字进行排序时会发生什么？基数排序会在排序中缺少的数字中插入零。所以会是000012和34872。因此，在每次迭代期间，12将继续被放入0存储桶，因为它本身没有位置值。</p><p id="ef58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是它的<em class="lc">魔法</em>的一部分秘密。就像魔术一样，一旦“秘密”被揭露，这一点往往变得非常明显。通过基数排序，从右到左将数字放入其位置值的桶中，较大的数字最终会比较小的数字出现在较大值的桶中，因为有时较大的数字在位置值中将具有值&gt; 0，而较小的数字对于该特定位置值仅为0。</p><h1 id="6779" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">放到实际的代码上</h1><p id="8052" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们已经讨论了什么是基数排序以及一个伪代码示例。现在让我们深入研究排序算法的实际代码。</p><h2 id="6303" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">首先，我们需要一些辅助方法。</h2><p id="aaa1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将需要的三个帮助器方法中的第一个是在特定的位置值计算数字的实际值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="645f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，虽然只有3行代码，但是有相当多的数学魔法在进行。所以让我们打开它。该函数需要两个参数。首先是一个数字，然后是你想要返回的值的位置。下一行看起来有点复杂，所以让我们按照操作顺序来分解它。</p><pre class="je jf jg jh fd lt lb lu lv aw lw bi"><span id="f501" class="ld jv hi lb b fi lx ly l lz ma">return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10</span><span id="152e" class="ld jv hi lb b fi mb ly l lz ma">-&gt; Math.abs(num) -- this just allows negative numbers to be retrieved<br/> <br/>-&gt; Math.pow(10, i) -- this is 10 to the i // so Math.pow(10, 2) is 10 * 10 or 100</span><span id="b37b" class="ld jv hi lb b fi mb ly l lz ma">-&gt; % 10 -- is modulo 10 // this returns the remainder of x / 10</span></pre><p id="f83e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子。</p><pre class="je jf jg jh fd lt lb lu lv aw lw bi"><span id="34ef" class="ld jv hi lb b fi lx ly l lz ma">getNum(5927, 2)</span><span id="5cf1" class="ld jv hi lb b fi mb ly l lz ma">Math.abs(num) / Math.pow(10, i) or 5927 / 100<br/>= 59.27</span><span id="c975" class="ld jv hi lb b fi mb ly l lz ma">59.27 % 10<br/>= 9.270...</span><span id="66a7" class="ld jv hi lb b fi mb ly l lz ma">Math.floor(9.270...)<br/>= 9</span></pre><blockquote class="mc md me"><p id="6996" class="if ig lc ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">作为一个旁注<!-- -->,你可以用这种抽象单个数字的方法来解决其他算法问题，比如颠倒数字的顺序。；-)</p></blockquote><p id="9ce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个helper方法是一个函数，用于获取数组中一个数字的位数。例如，数字254将返回us 3。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="0156" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们需要运行一些数学逻辑来理解这里发生了什么。也许如果你的背景和我的不同，第5行非常有意义，但是我的非数学背景需要一些解释。我们将再次按照操作的顺序来处理它。</p><pre class="je jf jg jh fd lt lb lu lv aw lw bi"><span id="2f03" class="ld jv hi lb b fi lx ly l lz ma">if (num === 0) return 1; // an exception if num = 0, just return 1 digit in javascript Math.log10(0) returns -Infinity</span><span id="98f3" class="ld jv hi lb b fi mb ly l lz ma">return Math.floor(Math.log10(Math.abs(num))) + 1;</span><span id="e818" class="ld jv hi lb b fi mb ly l lz ma">digitCount(462);</span><span id="d51b" class="ld jv hi lb b fi mb ly l lz ma">Math.abs(num) // allows for negative numbers to be calculated <br/>Math.log10 // is log base 10 // or in other words 10 to x power gives us this number</span><span id="4d83" class="ld jv hi lb b fi mb ly l lz ma">Math.log10(Math.abs(462))<br/>= 2.6646... // 10 to the 2.6646... power goes into 462 </span><span id="6f47" class="ld jv hi lb b fi mb ly l lz ma">Math.floor(2.6646...)<br/>= 2</span><span id="f922" class="ld jv hi lb b fi mb ly l lz ma">+ 1 // we need to add 1 digit since we did log10<br/>= 3</span></pre><p id="4965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要的第三个也是最后一个帮助器方法是找到数组中单个整数的最大位数。这个更简单，因为我们在函数中使用了我们早期的助手。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b06b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只需要讨论上面代码的第6行。我们将名为<code class="du ky kz la lb b">maxDigits</code>的变量初始化为<code class="du ky kz la lb b">0</code>，然后遍历数组以找到最大值。</p><pre class="je jf jg jh fd lt lb lu lv aw lw bi"><span id="cb81" class="ld jv hi lb b fi lx ly l lz ma">maxDigits = Math.max(maxDigits, digitCount(nums[i]));</span><span id="d8a6" class="ld jv hi lb b fi mb ly l lz ma">using digitCount() find the maximum amount of digits in the array<br/>then return the number</span></pre><h2 id="d1fd" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">现在是主要的方法</h2><p id="d949" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在伪部分，这是我们讨论过的函数。提醒一下，输入是一个整数数组，然后使用基数将它们分类到桶中，每10到x个值放入一个循环中。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="58d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们一行一行地讨论这里发生了什么。</p><pre class="je jf jg jh fd lt lb lu lv aw lw bi"><span id="6963" class="ld jv hi lb b fi lx ly l lz ma">let maxDigitCount = findMaxDigits(nums) <br/>// find the max number of digits</span><span id="bd48" class="ld jv hi lb b fi mb ly l lz ma">for (let k = 0; k &lt; maxDigitCount; k++)<br/>// loop through the digits based off the max number of digits</span><span id="fb6f" class="ld jv hi lb b fi mb ly l lz ma">let digitBuckets = Array.from({length: 10}, () =&gt; [])<br/>// this line creates our buckets we will use to distribute our numbers, an array with 10 sub arrays</span><span id="1b84" class="ld jv hi lb b fi mb ly l lz ma">for (let i = 0; i &lt; nums.length; i++)<br/>// loop through the individual numbers in the array</span><span id="a3ab" class="ld jv hi lb b fi mb ly l lz ma">let digit = getNum(nums[i],k);<br/>// get the individual number at k index for i in the array</span><span id="f99d" class="ld jv hi lb b fi mb ly l lz ma">digitBuckets[digit].push(nums[i]);<br/>// push the array item into the bucket of the returned value of getNum()</span><span id="3ea4" class="ld jv hi lb b fi mb ly l lz ma">nums = [].concat(...digitBuckets);<br/>// after looping through the array at the k position concat() the arrays</span><span id="aecd" class="ld jv hi lb b fi mb ly l lz ma">// now rinse and repeat until we have distributed for the maximum number of digits in the array</span><span id="8ede" class="ld jv hi lb b fi mb ly l lz ma">return nums;<br/>// return the sorted array</span></pre><h1 id="2688" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">那么基数排序的大O呢？</h1><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">嗯，通过看上面的代码，你会认为它是O(n)因为循环中的循环，但它不是互相比较项目，所以大O是O(nk)，n是元素的数量，k是数字中的位数。与此同时，关于这个大O方程也有一些争议。普遍认为比比较排序算法要快。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="357b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是了。基数排序，我想一旦你把它分解，它不是数字魔术，而是利用数字的固有属性进行非比较排序。另外，对Udemy上的<a class="ae jt" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank"> Javascript算法和数据结构主类</a>大声喊出来，它向我介绍了基数排序以及这篇文章的灵感。</p></div></div>    
</body>
</html>
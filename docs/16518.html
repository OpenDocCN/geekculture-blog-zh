<html>
<head>
<title>Chain of Responsibility Pattern — Who are taking the responsibility?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">责任链模式——谁在承担责任？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/chain-of-responsibility-pattern-who-are-taking-the-responsibility-70923b8219a2?source=collection_archive---------10-----------------------#2022-12-31">https://medium.com/geekculture/chain-of-responsibility-pattern-who-are-taking-the-responsibility-70923b8219a2?source=collection_archive---------10-----------------------#2022-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c64cc033051692069038713133b04490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hV9RQbxblOpAKfQ6IsdPbA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">P.C. <a class="ae hv" href="https://cutt.ly/52wVfxZ" rel="noopener ugc nofollow" target="_blank">https://cutt.ly/52wVfxZ</a></figcaption></figure><div class=""/><div class=""><h2 id="871d" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">一组物体如何合作完成一项单个物体无法单独完成的任务。</h2></div><p id="054c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> <em class="kj">注</em> </strong> <em class="kj">:本出版物演示了打字稿中的责任链模式。参见其他代码示例:</em> <a class="ae hv" href="https://3v4l.org/hF35E#v8.2.3" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> PHP </em> </a> <em class="kj">，</em><a class="ae hv" href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEBSD2AjaBvAUNaAHATgSwDcwAXAU2gBNTiw8QIAuaCY-AOwHM0Nph42WOAK7Bi8HAAoqNOo2as8nAJSoemYgAs8EAHTTa9aAF5K1AxB4BfbphykAjkLx2AtqTbEIEleky3qQjhs0JraemayANxWaNZooJAwAMo0wADWACLUpKLiqpgsJHjA0C4kwBoShelMgoocADSmMvS1CspMiPDwIKRgwb5+dsSBwfqyOopUAB4A8gBmValpKgB80AC0AIwxcWCIgmCivOBQ0AAS-RS9OPnYOPBkoqQUzCLApFDiTJds16Q4AA+Qj+pHmihe0UwPHm4gA7mAcBQACrwJLvT4QcQSABWSCYCEQSiYBHgeFeg0weHm0AkoV0EAxXxwSjUfnpOkZwA+zJ0GiuvVxSCUUOgcUw+0Ox35f0FeMQBOFTH6AE9onEEmcAArnLUpI5paCkaZkP4wX7-W6DPgCVgiMSSLk8rE4H4CgE+NmMrAA7yi9RaBlMl3GN7czHiUXi6Ay-5ChVwYV3Kk0iT69JZJ4OnRlYgVCQAch1WoLTXlOjsjmcpDcHi8SgbbMwAHpm9AAHKPakq6DF0wEUggeA+nAWPx+G1Y3o6IccQt99NpAsitmDiCkJshQM6WE4BFI1Ho8PM+MrzDWDWnGCwMBEJLAfBYYiLo0m9wUc3uq08Sd23KO4NvguL9PXHb1fTPdltydCNbhMGDmSjGwY3deNFSJZNoGpWlF0zHJs1zfMCxvO8HzwJ9S2gctKycVx3E8bxG3HFs207YhuzgW8wHvR9iH7QdhwBMdmMnHpSBneA52IriePIvjF2Xf0jXoDdmK3MJd33FE0UAyR5Ugi9uE1a8ZOWV9TQ-YDZQBO4f34QR7WxBCXTdayWUw8DJEggMwmcvJ4N0pCeFjOV8UTDDKSw1NcOyf8c3KSppKISjqIcWia3o+smOY1sOy7eYexIsB+KHEdhPHUTp1nQsiugBTvOU9dNw5TTEW0o9nWxfTdiMq9oAyeA2K0ThzPfT83LuELSDQ8LQL8XKBugNhHmGrgKvssSJKk5ENHIGjPj4pAcXwrCYBBKaKEUnq0FygBhflFGgeAaUJFCJqO-CLF-ShBpW+pQzYUg4X637Qk4P14nsvicVMg0AaBzi72WKRQdWldvph0jeJfExAeBorZKfRdcVh9J0ah7ANCwHGloR4ticx7iyKJ5YVxutsdr2tKDqexBjuOMRoEQcgLsh20qKQeH8aQeddUU6BcuRHAewqfoOH+zRyCIEAhHIQWtRVTR+CaAnmcO24iu4XL9RwTw3uuDXdvC3n+eINAsCpxc+VQ-TIiAA" rel="noopener ugc nofollow" target="_blank"><em class="kj">TypeScript</em></a><em class="kj">和</em><a class="ae hv" href="https://gist.github.com/unclexo/70348534f856362204ec4ed0d85b380e" rel="noopener ugc nofollow" target="_blank"><em class="kj">Java</em></a><em class="kj">。</em></p><h2 id="a6f8" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">目的</h2><blockquote class="lf"><p id="36f6" class="lg lh hy bd li lj lk ll lm ln lo ki dx translated">通过给多个对象一个处理请求的机会，避免将请求的发送方耦合到接收方。链接接收对象，并沿着链传递请求，直到有对象处理它。</p></blockquote><h2 id="9725" class="kk kl hy bd km kn lp kp kq kr lq kt ku jw lr kw kx ka ls kz la ke lt lc ld le bi translated">一个场景</h2><p id="279f" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">你知道吗？你是软件工程师/开发人员。您正在开发一个工作列表web应用程序。根据软件工程师/开发人员的<strong class="jp hz">技术堆栈</strong>，当发布新工作时，新要求将通过电子邮件发送给他们。以下生态系统会出现这种情况:PHP、JavaScript、Java生态系统相关的工作应该分别去找PHP、JavaScript、Java开发者。其他工作不会发送给任何开发人员。</p><p id="e5f8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你会怎么做？</p><h2 id="13ec" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">你的任务</h2><p id="00d5" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">假设您已经有了一个实现的算法来根据任务的需求确定任务的技术堆栈。现在，您需要做的就是创建一个可以使用堆栈检测器来处理新任务的设计。</p><h2 id="6f1b" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">责任链如何运作</h2><p id="dbd4" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">当您使用责任链模式时，通常会创建一个对象链，并沿着这个对象链传递一个请求进行检查。每个对象依次检查请求，并尝试处理它，或者如果请求失败，传递给链中的下一个对象。</p><p id="4330" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们想象一下责任链如何与我上面描述的<strong class="jp hz">场景</strong>一起工作。</p><figure class="ma mb mc md fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/e65f4184ffca8452a52e3342664383e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Eay6g8R_9nl6l5q0ItT1OQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">The UML diagram of Chain of Responsibility</figcaption></figure><p id="9255" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">链中的每个对象都充当一个处理程序，并且有一个后继对象。如果它能够处理请求，它就会处理；否则，它会将请求转发给它的后继者。</p><h2 id="82e2" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">参与者</h2><p id="b50f" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">现在，看看实现责任链模式所需的参与者。</p><p id="5c9e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">处理程序:</strong> ( <code class="du me mf mg mh b">Handler</code> —一个接口或抽象类)</p><ul class=""><li id="d23d" class="mi mj hy jp b jq jr jt ju jw mk ka ml ke mm ki mn mo mp mq bi translated">定义处理请求的接口。</li><li id="1fcb" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">实现后续链接。(可选)</li></ul><p id="52c3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">具体负责人——(<code class="du me mf mg mh b">PHPStack</code>，<code class="du me mf mg mh b">JavaScriptStack</code>)</p><ul class=""><li id="aac4" class="mi mj hy jp b jq jr jt ju jw mk ka ml ke mm ki mn mo mp mq bi translated">处理它所负责的请求。</li><li id="c340" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">可以访问它的继任者。</li><li id="e724" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">如果<code class="du me mf mg mh b">ConcreteHandler</code>能够处理请求，它就处理；否则，它会将请求转发给它的后继者。</li></ul><p id="de46" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">委托方</strong>——(<code class="du me mf mg mh b">Client</code>发起方)</p><ul class=""><li id="4d37" class="mi mj hy jp b jq jr jt ju jw mk ka ml ke mm ki mn mo mp mq bi translated">向链上的一个<code class="du me mf mg mh b">ConcreteHandler</code>对象发起请求。</li></ul><h2 id="196d" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">调查</h2><p id="20a4" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">让我们把这个场景作为责任链模式的一个例子来研究。该模式具有以下属性:</p><ul class=""><li id="2852" class="mi mj hy jp b jq jr jt ju jw mk ka ml ke mm ki mn mo mp mq bi translated">将请求的发送方与其接收方对象分开。</li><li id="087e" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">给多个对象一个处理请求的机会。</li><li id="066a" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">沿着接收对象链传递请求，直到有对象处理它。</li></ul><p id="b0ba" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意这里的<code class="du me mf mg mh b">Job</code>是请求对象。<code class="du me mf mg mh b">Client</code>是一个类/方法，它使用一个<code class="du me mf mg mh b">Job</code>对象来传递处理程序对象，如<code class="du me mf mg mh b">PHPStack</code>、<code class="du me mf mg mh b">JavaScriptStack</code>等。</p><p id="e91d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">将请求的发送者和接收者对象分开。</p><p id="7bc8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">看看UML，<code class="du me mf mg mh b">Client</code>是从请求处理程序对象如<code class="du me mf mg mh b">PHPStack</code>、<code class="du me mf mg mh b">JavaScriptStack</code>等中分离出来的。</p><p id="4992" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">给多个对象一个处理请求的机会。</p><p id="07e8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由于<code class="du me mf mg mh b">Job</code>对象正沿着<code class="du me mf mg mh b">PHPStack</code>、<code class="du me mf mg mh b">JavaScriptStack</code>和<code class="du me mf mg mh b">JavaStack</code>的链传递，因此它得到了不止一次的处理机会。</p><p id="0347" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">沿着接收对象链传递请求，直到一个对象处理它。</p><p id="79af" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du me mf mg mh b">Job</code>对象沿着链传递，直到<code class="du me mf mg mh b">PHPStack</code>、<code class="du me mf mg mh b">JavaScriptStack</code>和<code class="du me mf mg mh b">JavaStack</code>中的任何一个处理它。</p><h2 id="4e31" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">履行</h2><p id="af6a" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">我们将从<code class="du me mf mg mh b">Handler</code>抽象类开始，它定义了一个处理请求对象的接口(在本例中是<code class="du me mf mg mh b">Job</code>，并实现了一个后继链接。</p><pre class="ma mb mc md fd mw mh mx bn my mz bi"><span id="ebfc" class="na kl hy mh b be nb nc l nd ne">abstract class Handler {<br/>  protected successor: Handler|undefined;<br/>  <br/>  forwardToSuccessor(job: Job): void {<br/>    if (this.successor)<br/>      this.successor.handle(job);<br/>  }<br/><br/>  abstract handle(job: Job): any;<br/>}</span></pre><p id="94d8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du me mf mg mh b">handle()</code>方法是处理请求对象的接口，而<code class="du me mf mg mh b">forwardToSuccessor()</code>是将请求转发给后继对象的方法。</p><p id="08d6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们有一个处理<code class="du me mf mg mh b">Job</code>对象的接口。现在我们可以实现几个<code class="du me mf mg mh b">ConcreteHandler</code>类来处理这个对象。</p><pre class="ma mb mc md fd mw mh mx bn my mz bi"><span id="3a78" class="na kl hy mh b be nb nc l nd ne">class PHPStack extends Handler {<br/>  constructor(successor: Handler) {<br/>    super();<br/>    this.successor = successor;<br/>  }<br/><br/>  handle(job: Job) {<br/>    if (StackDetector.match('PHP', job.requirements()))<br/>      // Notify PHP developers<br/>      console.log('PHP Stack');<br/>    else<br/>      this.forwardToSuccessor(job);<br/>  }<br/>}</span></pre><pre class="nf mw mh mx bn my mz bi"><span id="6423" class="na kl hy mh b be nb nc l nd ne">class JavaScriptStack extends Handler {<br/>  constructor(successor: Handler) {<br/>    super();<br/>    this.successor = successor;<br/>  }<br/><br/>  handle(job: Job) {<br/>    if (StackDetector.match('JavaScript', job.requirements()))<br/>      // Notify JavaScript developers<br/>      console.log('JavaScript Stack');<br/>    else<br/>      this.forwardToSuccessor(job);<br/>  }<br/>}</span></pre><p id="3101" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里如果<code class="du me mf mg mh b">handle()</code>方法可以处理<code class="du me mf mg mh b">Job</code>请求对象，那么它就会处理；否则，如果有后继对象，它将把<code class="du me mf mg mh b">Job</code>对象转发给后继对象。</p><p id="f41c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">注意</strong>如果那些处理程序对象不能处理请求怎么办？在这种情况下，您可以保持请求对象不被处理，也可以提供默认实现。例如:</p><pre class="ma mb mc md fd mw mh mx bn my mz bi"><span id="3b87" class="na kl hy mh b be nb nc l nd ne">class DoNothing extends Handler {<br/>  handle(job: Job) {<br/>    // Do nothing<br/>    console.log('The request object is unhandled');<br/>  }<br/>}</span></pre><p id="0da0" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里是<code class="du me mf mg mh b">Job</code>请求对象:</p><pre class="ma mb mc md fd mw mh mx bn my mz bi"><span id="b2c8" class="na kl hy mh b be nb nc l nd ne">class Job {<br/>    private details: string<br/><br/>    constructor(details: string) {<br/>      this.details = details<br/>    }<br/><br/>    requirements() {<br/>        return this.details;<br/>    }<br/>}<br/><br/>class StackDetector {<br/>  static match(stack: string, details: string): boolean {<br/>    return details.indexOf(stack) &gt; -1<br/>  }<br/>}</span></pre><p id="591b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在是时候让<code class="du me mf mg mh b">Client</code>向链上的<code class="du me mf mg mh b">ConcreteHandler</code>对象发起请求对象了。</p><pre class="ma mb mc md fd mw mh mx bn my mz bi"><span id="c198" class="na kl hy mh b be nb nc l nd ne">// Chain of Job handler objects<br/>const doNothing = new DoNothing();<br/>const javaScriptStack = new JavaScriptStack(doNothing);<br/>const phpStack = new PHPStack(javaScriptStack);<br/><br/>// The request object to be handled<br/>const job = new Job('JavaScript');<br/><br/>// Starts handling the Job object<br/>phpStack.handle(job); // prints "JavaScript Stack"</span></pre><p id="9e8b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae hv" href="https://3v4l.org/hF35E#v8.2.3" rel="noopener ugc nofollow" target="_blank"> PHP </a>、<a class="ae hv" href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEBSD2AjaBvAUNaAHATgSwDcwAXAU2gBNTiw8QIAuaCY-AOwHM0Nph42WOAK7Bi8HAAoqNOo2as8nAJSoemYgAs8EAHTTa9aAF5K1AxB4BfbphykAjkLx2AtqTbEIEleky3qQjhs0JraemayANxWaNZooJAwAMo0wADWACLUpKLiqpgsJHjA0C4kwBoShelMgoocADSmMvS1CspMiPDwIKRgwb5+dsSBwfqyOopUAB4A8gBmValpKgB80AC0AIwxcWCIgmCivOBQ0AAS-RS9OPnYOPBkoqQUzCLApFDiTJds16Q4AA+Qj+pHmihe0UwPHm4gA7mAcBQACrwJLvT4QcQSABWSCYCEQSiYBHgeFeg0weHm0AkoV0EAxXxwSjUfnpOkZwA+zJ0GiuvVxSCUUOgcUw+0Ox35f0FeMQBOFTH6AE9onEEmcAArnLUpI5paCkaZkP4wX7-W6DPgCVgiMSSLk8rE4H4CgE+NmMrAA7yi9RaBlMl3GN7czHiUXi6Ay-5ChVwYV3Kk0iT69JZJ4OnRlYgVCQAch1WoLTXlOjsjmcpDcHi8SgbbMwAHpm9AAHKPakq6DF0wEUggeA+nAWPx+G1Y3o6IccQt99NpAsitmDiCkJshQM6WE4BFI1Ho8PM+MrzDWDWnGCwMBEJLAfBYYiLo0m9wUc3uq08Sd23KO4NvguL9PXHb1fTPdltydCNbhMGDmSjGwY3deNFSJZNoGpWlF0zHJs1zfMCxvO8HzwJ9S2gctKycVx3E8bxG3HFs207YhuzgW8wHvR9iH7QdhwBMdmMnHpSBneA52IriePIvjF2Xf0jXoDdmK3MJd33FE0UAyR5Ugi9uE1a8ZOWV9TQ-YDZQBO4f34QR7WxBCXTdayWUw8DJEggMwmcvJ4N0pCeFjOV8UTDDKSw1NcOyf8c3KSppKISjqIcWia3o+smOY1sOy7eYexIsB+KHEdhPHUTp1nQsiugBTvOU9dNw5TTEW0o9nWxfTdiMq9oAyeA2K0ThzPfT83LuELSDQ8LQL8XKBugNhHmGrgKvssSJKk5ENHIGjPj4pAcXwrCYBBKaKEUnq0FygBhflFGgeAaUJFCJqO-CLF-ShBpW+pQzYUg4X637Qk4P14nsvicVMg0AaBzi72WKRQdWldvph0jeJfExAeBorZKfRdcVh9J0ah7ANCwHGloR4ticx7iyKJ5YVxutsdr2tKDqexBjuOMRoEQcgLsh20qKQeH8aQeddUU6BcuRHAewqfoOH+zRyCIEAhHIQWtRVTR+CaAnmcO24iu4XL9RwTw3uuDXdvC3n+eINAsCpxc+VQ-TIiAA" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>和<a class="ae hv" href="https://gist.github.com/unclexo/70348534f856362204ec4ed0d85b380e" rel="noopener ugc nofollow" target="_blank"> Java </a>中的完整代码示例</p><h2 id="f391" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">跟我来:</h2><p id="cabb" class="pw-post-body-paragraph jn jo hy jp b jq lu iz js jt lv jc jv jw lw jy jz ka lx kc kd ke ly kg kh ki hb bi translated">中、<a class="ae hv" href="https://github.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae hv" href="https://twitter.com/unclexo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae hv" href="https://www.linkedin.com/in/unclexo" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。</p><h2 id="d120" class="kk kl hy bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">参考资料:</h2><ol class=""><li id="914a" class="mi mj hy jp b jq lu jt lv jw ng ka nh ke ni ki nj mo mp mq bi translated"><a class="ae hv" href="https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly-ebook/dp/B00AA36RZY" rel="noopener ugc nofollow" target="_blank">头先设计图案</a></li><li id="8f59" class="mi mj hy jp b jq mr jt ms jw mt ka mu ke mv ki nj mo mp mq bi translated"><a class="ae hv" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>JWT Authentication in Django, Part 2: Implementing the Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的JWT认证，第2部分:实现前端</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/jwt-authentication-in-django-part-2-implementing-the-frontend-7ea3d6e16bf4?source=collection_archive---------4-----------------------#2021-03-12">https://medium.com/geekculture/jwt-authentication-in-django-part-2-implementing-the-frontend-7ea3d6e16bf4?source=collection_archive---------4-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e4420433217922de165a7fb91d92587a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCIVOwlon1oHQ6Hm0HdY_Q.jpeg"/></div></div></figure><p id="83eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在</em> <a class="ae jp" href="https://johnckealy.medium.com/jwt-authentication-in-django-part-1-implementing-the-backend-b7c58ab9431b" rel="noopener"> <em class="jo">上一篇文章</em> </a> <em class="jo">中，我们使用</em> <code class="du jq jr js jt b"><em class="jo">django-rest-framework</em></code> <em class="jo">和</em> <code class="du jq jr js jt b"><em class="jo">dj-rest-auth</em></code> <em class="jo">库创建了一个JWT认证系统。在本文中，我们将探索如何从解耦的前端与后端进行通信。假定一些先验知识:</em></p><ul class=""><li id="5424" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><em class="jo">类似Vue或React的前端框架</em></li><li id="f648" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><em class="jo">使用@vue/cli或Nuxt等客户端服务前端app </em></li><li id="4af1" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><em class="jo">状态管理工具(如Vuex或Redux) </em></li><li id="0bd0" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated"><em class="jo">Axios http客户端</em></li></ul><p id="40db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">要看上一篇，Part 1，点击</em> <a class="ae jp" href="https://johnckealy.medium.com/jwt-authentication-in-django-part-1-implementing-the-backend-b7c58ab9431b" rel="noopener"> <em class="jo">这里</em> </a> <em class="jo">。</em></p><p id="7e93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上次，我们使用Django为JWT创建了一个可靠的后端。人们可能会认为实现一个前端来与它通信应该是微不足道的，尤其是在npm上有无数的前端认证库的情况下。然而，我在使用这些库方面还没有取得很大的成功，所以我更喜欢创建自己的自定义登录表单和API调用。</p><p id="c19e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，在处理前端客户端时，最重要的事情是尽职调查，打击像跨站脚本(XSS)和跨站请求伪造(CSRF)这样的攻击。在与JWT打交道时，前者通常比后者更危险。首先要考虑的是饼干。</p><h1 id="7704" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Cookies，以及它们存储的位置</h1><p id="5524" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">如果您遵循了上一篇教程，您应该有望通过<code class="du jq jr js jt b">django-sslserver</code>设置运行SSL的Django后端，并通过<code class="du jq jr js jt b">/etc/hosts</code>设置本地DNS名称，这允许您在如下地址访问后端</p><pre class="ll lm ln lo fd lp jt lq lr aw ls bi"><span id="113c" class="lt kj hi jt b fi lu lv l lw lx">https://api.example.com:8000</span></pre><p id="6d87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于前端，我一般用<a class="ae jp" href="https://quasar.dev/" rel="noopener ugc nofollow" target="_blank">类星体框架</a>或者<a class="ae jp" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a>。像许多包含开发服务器的前端客户端一样，Quasar在幕后使用Webpack，webpack开发服务器有一个设置<code class="du jq jr js jt b">https</code>，您可以将其设置为<code class="du jq jr js jt b">true</code>。这应该可以处理前端SSL。记得给你所有的网址加一个<code class="du jq jr js jt b">s</code>。</p><p id="5641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候在你的前端应用中添加一个端点来访问你的后端了。我将把这个交给你——我们的目标是创建一个向<code class="du jq jr js jt b">https://api.example.com:8000/login</code>端点发送的登录表单，以及一个应该只对经过身份验证的用户可用的经过身份验证的路由。</p><p id="d56e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你的浏览器中(顺便说一句，我个人支持勇敢的浏览器，Chrome的所有开发工具，没有任何间谍行为)，打开你的前端地址，在登录表单中输入你的登录信息。这将向Django发送一个<code class="du jq jr js jt b">POST</code>请求，Django将返回您的令牌(一个访问令牌和一个刷新令牌)。</p><blockquote class="ly lz ma"><p id="85db" class="iq ir jo is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">此时，奇迹发生了。</p></blockquote><p id="b8fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你打开谷歌Chrome或Brave(其他浏览器会稍有不同)的开发工具，并前往<code class="du jq jr js jt b">Application =&gt; Cookies</code>，你可能会发现那里什么也没有。这让我困惑了很久。事实证明，https的使用和我们在第1部分中实现的定制DNS现在正在开花结果，cookies确实被保存了——只是它们没有出现。然而，如果你转到<code class="du jq jr js jt b">Network</code>并点击对<code class="du jq jr js jt b">/login</code>的请求，现在在<code class="du jq jr js jt b">Headers/Preview/Timing</code>标签旁边应该有一个<code class="du jq jr js jt b">Cookies</code>标签。如果您随后检查与请求一起发出的访问头，您应该看到包含了访问令牌。</p><h1 id="463e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用状态管理控制前端认证</h1><p id="6b4b" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我更喜欢使用状态管理来编写Javascript逻辑，但这不是强制性的。从这一点开始，我的代码片段将与Vuex有关，但是如果您使用React/Redux之类的东西，这些概念应该仍然有用。我也将使用<a class="ae jp" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>，但是你也可以用<code class="du jq jr js jt b">fetch()</code>完成同样的事情。</p><p id="587f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">初始化Axios时要设置的关键是设置标志<code class="du jq jr js jt b">withCredentials: true</code>。您可以将该参数传递给任何请求，或者将其设置为默认值，如下所示:</p><pre class="ll lm ln lo fd lp jt lq lr aw ls bi"><span id="59fb" class="lt kj hi jt b fi lu lv l lw lx">import Vue from 'vue'<br/>import axios from 'axios'</span><span id="9cb2" class="lt kj hi jt b fi me lv l lw lx">export default (state) =&gt; {<br/>  <br/>  axios.defaults.withCredentials = true<br/>  axios.defaults.baseURL = process.env.API_URL<br/>  <br/>  Vue.prototype.$axios = axios<br/>  state.$axios = axios</span><span id="4482" class="lt kj hi jt b fi me lv l lw lx">}</span></pre><p id="c781" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述代码可以在引导文件、插件或其他地方找到；这取决于你的前端框架。请注意我是如何将Axios添加到状态中的，因此我现在可以在任何地方使用它。</p><p id="2003" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当<code class="du jq jr js jt b">withCredentials = true</code>时，浏览器都会在其标题中包含令牌。下面是一个放在Vuex模块中的典型Axios请求示例:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="aa9d" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">离别的思绪</h1><p id="414d" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">无论你是从头开始编写前端逻辑还是使用一个库，希望这有助于填补一些空白，让你的前端与你的JWT Django后端玩得更好。</p><p id="1af1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就下一步而言，还有很多事情要做。无论您选择如何实现前端，您都应该考虑以下几点:</p><ul class=""><li id="9d57" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">为您需要的每个后端端点添加前端表单、按钮和http请求(如<code class="du jq jr js jt b">/login</code>、<code class="du jq jr js jt b">/logout</code>、<code class="du jq jr js jt b">/password-change</code>等)。</li><li id="16ed" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">添加令牌刷新端点。登录时删除访问令牌(只需删除<code class="du jq jr js jt b">settings.py</code>中的<code class="du jq jr js jt b">JWT_AUTH_COOKIE</code>条目)并只存储刷新令牌，这也是一个好主意。然后，如果状态改变，您可以通过点击<code class="du jq jr js jt b">/refresh-token</code>端点将访问令牌添加到内存中。</li><li id="6aa6" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">在路由器逻辑中添加重定向，以便在用户未经身份验证的情况下将他们发送到登录表单。</li></ul><p id="93fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您阅读这篇文章。如果您有任何问题或意见，请随时给我写信，地址:<a class="ae jp" href="https://johnkealy.com" rel="noopener ugc nofollow" target="_blank"><em class="jo">johnckealy</em></a><em class="jo">.dev@gmail.com。</em></p></div></div>    
</body>
</html>
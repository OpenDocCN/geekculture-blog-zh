<html>
<head>
<title>Internal Working of Cassandra Driver in Springboot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cassandra驱动程序在Springboot应用程序中的内部工作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/internal-working-of-cassandra-driver-in-springboot-application-d45ce58b748b?source=collection_archive---------8-----------------------#2021-04-21">https://medium.com/geekculture/internal-working-of-cassandra-driver-in-springboot-application-d45ce58b748b?source=collection_archive---------8-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多教程或博客可以阅读如何在Springboot应用程序中使用JPA maven依赖项连接到Cassandra数据库。<a class="ae jd" href="https://docs.spring.io/spring-data/cassandra/docs/current/reference/html/#cassandra.repositories" rel="noopener ugc nofollow" target="_blank">这里的</a>是春季的教程之一。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/603218e121e8da2e70ff698d26703a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq7EGl77avgS3HXcROphrA.png"/></div></div></figure><p id="05c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用Cassandra数据库编写一个Springboot应用程序并没有太多的工作要做。有<code class="du jq jr js jt b"> 7 properties</code>需要在<code class="du jq jr js jt b">application.properties </code>文件中定义，并在扩展CassandraRepository的接口上使用<code class="du jq jr js jt b">@Repository</code>注释，我们几乎完成了Cassandra所需的实现。写这篇文章的目的是为了理解Cassandra driver使用Springboot应用程序的内部原理。</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="df57" class="jy jz hi jt b fi ka kb l kc kd">#application.properties file</span><span id="26bb" class="jy jz hi jt b fi ke kb l kc kd">cassandra.contactpoints=localhost1,localhost2,...<br/>cassandra.port=9042<br/>cassandra.keyspace=test_keyspace<br/>cassandra.username=&lt;username&gt;<br/>cassandra.password=&lt;password&gt;<br/>cassandra.clusterName=&lt;cluster_name&gt;<br/>cassandra.localDC=&lt;local_DC&gt;</span></pre></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h2 id="9150" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">应用程序如何在驱动程序的帮助下连接到数据库？</h2><p id="1f97" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">有许多beans在应用程序启动时被初始化。</p><ol class=""><li id="c286" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj"> repository </strong>:这是一个为特定的表与数据库交互的类。对于每个表，都会有一个对应的存储库，它扩展了<code class="du jq jr js jt b">CassandraRepository&lt;Entity, ID_type&gt;</code>。</li><li id="2925" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">Cassandra template:Cassandra template<em class="ly"/>构建在底层CqlTemplate之上，提供了一种简单的方法来查询域对象并将对象映射到Cassandra中的持久化数据结构。</li><li id="51ef" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj"> sessionFactory </strong>:它是查询数据库所需的所有会话的工厂。它为一个数据库的应用程序创建一次。</li><li id="568a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">时段</strong>:该时段由<code class="du jq jr js jt b">sessionFactory</code>制作。会话保持与Cassandra集群的连接，允许对其进行查询。每个会话维护到集群节点的多个连接，提供为每个查询选择使用哪个节点的策略(默认情况下在集群的所有节点上循环)，并处理失败查询的重试(当有意义时)，等等。</li><li id="7300" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">集群</strong>:这是驱动的主入口。群集对象维护与其中一个群集节点的永久连接，该连接仅用于维护有关群集状态和当前拓扑的信息。使用该连接，驱动程序将发现当前在集群中的所有节点以及随后加入集群的新节点。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lz"><img src="../Images/3652d6229971691bf25581825ec420fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*rJhrTEO_bmyGsVYD0_7qKg.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Bean creation flow for Cassandra in spring-boot application</figcaption></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h2 id="03df" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">如果任何接触点无效，应用程序会启动吗？</h2><p id="4636" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">答案是<strong class="ih hj">没有</strong>。驱动程序试图在应用程序启动时添加所有提供的接触点。如果任何联系点未找到或无效或关闭，<strong class="ih hj">应用程序不会启动。</strong>它抛出以下错误。</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="6568" class="jy jz hi jt b fi ka kb l kc kd">Caused by: java.lang.IllegalArgumentException: Failed to add contact point: <strong class="jt hj">&lt;invalid_or_down_host&gt;</strong><br/> at com.datastax.driver.core.Cluster$Builder.addContactPoint(Cluster.java:922) ~[cassandra-driver-core-3.6.0.jar:na]<br/> at com.datastax.driver.core.Cluster$Builder.addContactPoints(Cluster.java:942) ~[cassandra-driver-core-3.6.0.jar:na]<br/> at org.springframework.data.cassandra.config.CassandraClusterFactoryBean.afterPropertiesSet(CassandraClusterFactoryBean.java:174) ~[spring-data-cassandra-2.1.6.RELEASE.jar:2.1.6.RELEASE]<br/> at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1837) ~[spring-beans-5.1.6.RELEASE.jar:5.1.6.RELEASE]<br/> at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1774) ~[spring-beans-5.1.6.RELEASE.jar:5.1.6.RELEASE]<br/> ... 124 common frames omitted<br/>Caused by: java.net.UnknownHostException: <strong class="jt hj">&lt;invalid_or_down_host&gt;</strong>: nodename nor servname provided, or not known<br/> at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method) ~[na:1.8.0_191]<br/> at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:929) ~[na:1.8.0_191]<br/> at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1324) ~[na:1.8.0_191]<br/> at java.net.InetAddress.getAllByName0(InetAddress.java:1277) ~[na:1.8.0_191]<br/> at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_191]<br/> at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_191]<br/> at com.datastax.driver.core.Cluster$Builder.addContactPoint(Cluster.java:919) ~[cassandra-driver-core-3.6.0.jar:na]<br/> ... 128 common frames omitted</span></pre><h2 id="5b8e" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">Cassandra群集关闭时，应用程序是否会停止？</h2><p id="8e39" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated"><strong class="ih hj">否，</strong>当集群关闭时，应用程序继续运行。但是，应用程序将无法为数据库请求提供服务，它会收到集群面临一些问题的通知，并在延迟后开始计划重新连接。除非与群集重新建立连接，否则驱动程序会在给定时间后继续尝试重新连接。有一个<a class="ae jd" href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/policies/ReconnectionPolicy.html" rel="noopener ugc nofollow" target="_blank"> ReconnectionPolicy </a>接口，它有两个实现:</p><ol class=""><li id="7258" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><a class="ae jd" href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/policies/ConstantReconnectionPolicy.html" rel="noopener ugc nofollow" target="_blank">ConstantReconnectionPolicy</a>:在每次重新连接尝试之间等待恒定时间的重新连接策略。</li><li id="03a8" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><a class="ae jd" href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/policies/ExponentialReconnectionPolicy.html" rel="noopener ugc nofollow" target="_blank">指数重连策略</a>:一种重连策略，在每次重连尝试之间以指数方式等待更长时间(但是一旦达到最大延迟就保持恒定延迟)。</li></ol><p id="f8fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jq jr js jt b">ReconnectionPolicy</code>的默认实现是<code class="du jq jr js jt b"><a class="ae jd" href="https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/policies/ExponentialReconnectionPolicy.html" rel="noopener ugc nofollow" target="_blank">ExponentialReconnectionPolicy</a></code>，其中基本延迟是1000毫秒，最大延迟是60000毫秒(10分钟)。将生成如下重试日志:</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="f75b" class="jy jz hi jt b fi ka kb l kc kd">[Control connection] Cannot connect to any host, scheduling retry in 1000 milliseconds</span><span id="c574" class="jy jz hi jt b fi ke kb l kc kd">[Control connection] Cannot connect to any host, scheduling retry in 2000 milliseconds</span><span id="0bb8" class="jy jz hi jt b fi ke kb l kc kd">[Control connection] Cannot connect to any host, scheduling retry in 4000 milliseconds</span><span id="7472" class="jy jz hi jt b fi ke kb l kc kd">[Control connection] Cannot connect to any host, scheduling retry in 8000 milliseconds<br/>.....<br/>.....<br/>.....</span><span id="19d1" class="jy jz hi jt b fi ke kb l kc kd">[Control connection] Cannot connect to any host, scheduling retry in 600000 milliseconds<br/>[Control connection] Cannot connect to any host, scheduling retry in 600000 milliseconds<br/>[Control connection] Cannot connect to any host, scheduling retry in 600000 milliseconds</span></pre><h2 id="bebd" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">应该提供多少个接触点来进行连接？</h2><p id="bf69" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">接触点的数量不应超过必要的数量。理想情况下，我们应该为每个数据中心提供前两个联系点。驾驶员使用这些接触点只是为了进入集群。当您计划降级您的集群时，如果提供了更多的联系点，您将需要删除联系点。</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="3aaa" class="jy jz hi jt b fi ka kb l kc kd">#single DC cluster<br/>contactpoints=host1DC,host2DC</span><span id="f83d" class="jy jz hi jt b fi ke kb l kc kd">#multile DC cluster<br/>contactpoints=host1DC1,host2DC2,host1DC2,host2DC2</span></pre><h2 id="f7df" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">是否必须提供当地的DC名字？</h2><p id="9232" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated"><strong class="ih hj">不，</strong>不强制要求，但<strong class="ih hj">建议</strong>明确提及当地的DC名称。如果未提及本地DC名称，驱动程序将从用于连接到群集的contactpoints中的第一台主机分配本地DC名称。我们提供的顺序是不保证的，驱动程序会随机洗牌并从提供的列表中选择一台主机。</p><p id="aca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果所有主机都属于同一个DC，就不会有问题。但是，<strong class="ih hj">对于多DC集群，建议设置本地DC名称。</strong></p><h2 id="2cbe" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">本地数据中心(本地DC)有什么用？</h2><p id="ad3e" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">为什么驱动程序为我们设置本地数据中心，即使我们不想设置它。它带来了什么好处？它基本上防止了跨DC查询，这有助于更好的性能，因为跨DC延迟没有考虑在内。对应用程序的所有查询将仅由本地DC节点提供服务。</p><h2 id="9952" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">对于一个驱动程序，联系点和本地DC之间有任何相关性吗？</h2><p id="6a81" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">只有在没有显式设置时，驱动程序才会从用于与数据库<strong class="ih hj">建立连接的第一个接触点评估本地DC名称。</strong>如果明确设置了本地DC(这是推荐的方法)。这两者之间没有依赖关系。但是，请确保所有提供的联系点和本地DC必须属于同一个目标集群。</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="21e3" class="jy jz hi jt b fi ka kb l kc kd">contactpoints=host1DC1, host2DC1<br/>localDC=DC2</span><span id="8fe2" class="jy jz hi jt b fi ke kb l kc kd"># Here driver uses host1 and host2 of DC1 to connect to the Cassandra cluster and localDC becomes DC2 for all the queries from the application</span></pre><h2 id="9fec" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">为多区域应用程序和多DC Cassandra集群部署设置本地DC的最佳方式是什么？</h2><p id="9366" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">本地DC名称不应该与密钥空间、用户名、联系点等一起传递。它应该特定于该特定区域的应用程序实例。假设有2个区域:<code class="du jq jr js jt b">R1 and R2 </code>和2个DC:<code class="du jq jr js jt b">DC1 and DC2</code>。R1的应用程序实例应该指向DC1作为本地DC，而R2的实例应该指向DC2。现在，在DC1中断的情况下，R1实例将无法为流量提供服务。但是，R2实例将与DC2节点一起工作。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/e0ee8c7cec8be016231d97769d0c3cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmH0x1OA-_nGACZi356bHw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">DC1 outage, Traffic is served by nodes of R2 with DC2 hosts. End-user does not face any issue even in case of complete one DC outage.</figcaption></figure><h2 id="de9c" class="jy jz hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">一致性级别(CL)的作用是什么？</h2><p id="37d5" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">一致性级别是为查询设置的。对于写/读查询，我们可以有共同的/不同的CLs。<strong class="ih hj">带Spring Cassandra驱动的默认CL是</strong> <code class="du jq jr js jt b">LOCAL_ONE</code>参考此<a class="ae jd" href="https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html" rel="noopener ugc nofollow" target="_blank">页</a>阅读所有CL。</p><p id="a763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当不满足所需的一致性时，查询会失败。让我们试着用下面的例子来理解:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/c2e2b49eb4463d6a2a5e8e6c0a255f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OygC-R-cWa_NTYDCy1ygoQ.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Request 1 gets passed as 1 host is up and running in DC1 and the required CL is LOCAL_ONE. Only local DC will be checked for hosts</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/716e9ad2deb54126e6b9e9294c0509be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NXrp9t-ML5p8nBuereYzw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Request 2 gets failed as only 3 hosts are up in DC1 and the required CL is LOCAL_QUORUM. At least 4 hosts have to up to serve the query in local DC</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/50d1da0aa46043742ea1a8320e1c2a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Def4ECcUt2Olu2yFuP-puA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Request 3 gets failed as only 3 hosts are up in DC1 and the required CL is EACH_QUORUM. At least 4 hosts have to up to serve the query in both DCs</figcaption></figure><p id="e2d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
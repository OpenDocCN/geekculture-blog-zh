<html>
<head>
<title>Data structures VS Objects — Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构与对象— Swift</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/data-structures-vs-objects-swift-a57fabbed2df?source=collection_archive---------15-----------------------#2021-11-12">https://medium.com/geekculture/data-structures-vs-objects-swift-a57fabbed2df?source=collection_archive---------15-----------------------#2021-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/75362039b4bea1a4b730979b32e9b5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X34s7n3V9nCNzq6v21cDjw.jpeg"/></div></div></figure><p id="97fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在读罗伯特·c·马丁的《干净的代码》的第6章，我对对象和数据结构之间的区别感到非常困惑。我不得不多次阅读，以理解是什么使对象成为对象，是什么使数据结构成为数据结构，以及它们之间的区别。我花了不止一、二、三次阅读来更好地理解它，但可以肯定地说，我理解了它的主旨。然后我决定把它应用到我最喜欢的语言(Swift)上，分享我的理解和几个例子。</p><p id="b0f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据结构:</strong></p><p id="d120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据结构应该公开它们的数据，不需要有任何有意义的行为。它们应该作为容器，一种访问数据的方式，以便外部各方可以使用它们来创建有意义的行为。</p><p id="724f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Swift中的一个例子是Enum。枚举非常适合定义数据</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6acb" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">enum</strong> Word {</span><span id="435a" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> circle</span><span id="1e10" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> square</span><span id="047a" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> rectangle</span><span id="4ed5" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="b76b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个数据结构中，请注意只有数据是公开的，没有依赖于使用它的真正的行为或功能。这样做的好处是，使用这种数据结构，你可以有许多不同的功能。</p><p id="3f84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对象:</strong></p><p id="49b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对象通过使用抽象来隐藏它们的数据，但是会暴露行为和函数。这可以通过使它们的字段私有，同时公开将操作它们的私有数据的函数来实现。<br/>此外，对象不同于数据结构，因为它的方法或行为不应该是访问数据的方式，而是执行操作这些数据的动作。如果一个对象有一个函数只返回它的一个私有数据的值，那么它就不是一个对象，而是一个数据结构<br/>我这么说是什么意思呢？看一下这段代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="95d9" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">class</strong> Square {</span><span id="0db7" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">private</strong> <strong class="jt hj">var</strong> sideLength: Int</span><span id="6d1e" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">init</strong>(sideLength: Int) {</span><span id="6827" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">self</strong>.sideLength = sideLength</span><span id="564a" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="d3aa" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">func</strong> getSideLength() -&gt; Int {</span><span id="8c71" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">return</strong> sideLength</span><span id="fa2e" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="4d3f" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="713c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这仍然被认为是一个数据结构，因为这个类通过“getsidelongth()”公开它的数据。为了使它成为一个对象，我们需要创建一个新的行为，这个行为不会暴露它的数据，而是操纵它，从而保存抽象的概念。</p><p id="1e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像这样:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6b48" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">class</strong> Square {</span><span id="3f60" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">private</strong> <strong class="jt hj">var</strong> sideLength: Int</span><span id="c40a" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">init</strong>(sideLength: Int) {</span><span id="3d22" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">self</strong>.sideLength = sideLength</span><span id="66a1" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="35d2" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">func</strong> findArea() -&gt; Int {</span><span id="63b9" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">return</strong> sideLength * sideLength</span><span id="1b95" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="878a" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="f96f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意findArea()是如何操作数据并隐藏实现的。</p><p id="12ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用对象VS数据结构的优势和不便？</strong></p><p id="3598" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这本书通过强调对数据结构使用过程代码和使用面向对象代码的优缺点来说明这些区别。</p><p id="8f48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用数据结构的程序代码</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="904a" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">enum</strong> Word {</span><span id="76b5" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> circle</span><span id="125f" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> square</span><span id="f085" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> rectangle</span><span id="64e1" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="8255" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">class</strong> Translation {</span><span id="b37e" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">func</strong> frenchTranslation(word: Word) -&gt; String {</span><span id="acb2" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">switch</strong> word {</span><span id="8f88" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> .circle:</span><span id="2ded" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">return</strong> "rond"</span><span id="2cb1" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> .square:</span><span id="e6b2" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">return</strong> "carré"</span><span id="69a2" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">case</strong> .rectangle:</span><span id="a488" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">return</strong> "rectangle"</span><span id="6eba" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="b473" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="d685" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="57b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意,“枚举单词”是一个数据结构，frenchTranslation()函数对三个给定的单词进行操作。枚举单词没有行为，但是翻译类使用该枚举来创建行为。这种使用数据结构的过程化流程的优点是，我可以继续向翻译类添加更多的函数，而不会影响枚举字。然而，一旦我向枚举添加了一个新词，比如说<em class="ke"> case triangle </em>，我添加到翻译类的所有函数都需要更新，以考虑这个新词。<br/>因此，添加新的行为很容易，但是添加新的数据结构可能很繁琐，因为每个函数都需要适应新添加的数据结构。<br/>现在让我们来看看面向对象的方式。</p><p id="278d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">面向对象方式</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="82e1" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">protocol</strong> Shape {</span><span id="ce0a" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">func</strong> findArea() -&gt; Int</span><span id="67ca" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="aaa5" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">class</strong> Square: Shape {</span><span id="6635" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">private</strong> <strong class="jt hj">var</strong> side: Int</span><span id="16a5" class="jx jy hi jt b fi kd ka l kb kc">init(side: Int) {</span><span id="8c6b" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">self</strong>.side = side</span><span id="d4b0" class="jx jy hi jt b fi kd ka l kb kc">}</span><span id="dc9c" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">func</strong> findArea() -&gt; Int {</span></pre></div></div>    
</body>
</html>
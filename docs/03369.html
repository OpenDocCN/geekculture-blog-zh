<html>
<head>
<title>Helm Testing and Reporting with Helm v3, Newman and Juxr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Helm v3、Newman和Juxr的Helm测试和报告</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/helm-testing-and-reporting-with-helm-v3-newman-and-juxr-3d8b2909a658?source=collection_archive---------21-----------------------#2021-06-07">https://medium.com/geekculture/helm-testing-and-reporting-with-helm-v3-newman-and-juxr-3d8b2909a658?source=collection_archive---------21-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/da1f55ee15a633f9e14303f67a52713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*jIvWpGNdB-BoqXHn5AecEw.jpeg"/></div></figure><div class=""/><p id="0361" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在你的管道中运行你的<strong class="io hq"> API </strong>或者<strong class="io hq">冒烟测试</strong>的方式有很多。有时候，只需要给你部署的Kubernetes <strong class="io hq">微服务</strong>提供一组正确的curl命令。然而，根据应用程序的性质，您可能会以不同的方式来做，有几个有用的工具可以执行这些类型的活动，如运行<strong class="io hq"> Helm </strong>和<strong class="io hq"> Newman </strong>以及postman集合。</p><p id="39a4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">人们可能希望用Newman 来自动化这些系列的测试集合，并且可能对在本地运行它们感兴趣。这完全取决于你的需求和要求。这绝不是一个银弹解决方案，而只是一个概念证明，可能会有所帮助。</p><h1 id="4c37" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">先决条件</h1><ul class=""><li id="024e" class="ki kj hp io b ip kk it kl ix km jb kn jf ko jj kp kq kr ks bi translated">头盔≥ v3</li><li id="5591" class="ki kj hp io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated">码头工人</li><li id="da55" class="ki kj hp io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated">纽曼(可选)</li><li id="fc8a" class="ki kj hp io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated">邮递员UI</li><li id="bfd6" class="ki kj hp io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated">Juxr</li></ul><h1 id="52ad" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">舵</h1><div class="hh hi ez fb hj ky"><a href="https://helm.sh/" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hq fi z dy ld ea eb le ed ef ho bi translated">舵</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">Helm是查找、共享和使用为Kubernetes构建的软件的最佳方式。Helm帮助您管理Kubernetes…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">helm.sh</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm hl ky"/></div></div></a></div><p id="e55c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">管理测试套件和其他Kubernetes清单从来没有以一种好的方式被标准化过。人们可能最终会定义他们自己的结构来打包他们的应用程序。幸运的是，随着<strong class="io hq"> Helm(v3) </strong>的到来，尤其是它的最新版本，我们可以将我们的应用程序和我们的测试打包在一起，只需一个简单的<strong class="io hq"> Helm </strong>命令就可以运行它们。我们也可以相应地确定测试的范围。</p><p id="2139" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个命令基本上旋转了你在舵图中定义的任何测试舱。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="6f1a" class="lw jl hp ls b fi lx ly l lz ma">$ <!-- -->helm test microservice-application</span></pre><p id="88e0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继续看<strong class="io hq">纽曼</strong></p><figure class="ln lo lp lq fd hk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/1f7b8f9a9caa93ceb2436db69cf43560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB3ZdkTPcu9uZF-CzX-3xQ.png"/></div></div></figure><h1 id="db66" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">纽曼</h1><blockquote class="mg mh mi"><p id="9b55" class="im in mj io b ip iq ir is it iu iv iw mk iy iz ja ml jc jd je mm jg jh ji jj hb bi translated">纽曼是邮差的命令行收集亚军。它允许您直接从命令行运行和测试Postman集合。它的构建考虑了可扩展性，因此您可以轻松地将其与您的持续集成服务器集成并构建系统。</p><p id="1d4a" class="im in mj io b ip iq ir is it iu iv iw mk iy iz ja ml jc jd je mm jg jh ji jj hb bi translated">Newman保持了与Postman相同的特性，并允许您像在Postman的集合运行器中那样运行集合。</p></blockquote><p id="c948" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Newman本质上是运行Postman collection的CLI工具，它有来自其社区的各种不同的报告选项。我们只需使用这个命令就可以有效地运行它(或者使用docker命令作为更不可知的方法)</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="79d8" class="lw jl hp ls b fi lx ly l lz ma">$ newman run mycollection.json</span></pre><p id="f6c2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Docker命令</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="b69c" class="lw jl hp ls b fi lx ly l lz ma">$ docker run -t postman/newman run "https://www.getpostman.com/collections/0d0350a9a89d39fb6361"</span></pre><p id="0d3c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以运行本地收集，但这需要装载共享数据卷，稍后我们将使用我们的自定义映像演示这一点。</p><h1 id="d544" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">记者纽曼HTML号外</h1><div class="hh hi ez fb hj ky"><a href="https://github.com/DannyDainton/newman-reporter-htmlextra#readme" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hq fi z dy ld ea eb le ed ef ho bi translated">丹尼登顿/纽曼-记者-htmlextra</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">一个纽曼HTML报告器，已经扩展到包括迭代运行的分离，所以这些不再…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">github.com</p></div></div><div class="lh l"><div class="mn l lj lk ll lh lm hl ky"/></div></div></a></div><p id="37ee" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如前所述，纽曼社区提供了各种集成，纽曼-记者-htmlextra 是其中之一，它提供了一种灵活的方式来定制模板和调整出站html报告。</p><p id="0eb8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以启用完全可定制的HTML报告，而不仅仅是处理CLI输出和junit。这只是提供一种习惯的问题。hbs模板呈现出您选择的自定义参数。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="b7fd" class="lw jl hp ls b fi lx ly l lz ma">$ newman run mycollection.json <!-- -->--reporters junit,cli,htmlextra --reporter-htmlextra-template /etc/newman/dashboard-template.hbs --reporter-htmlextra-title "Smoke API Tests"</span></pre><p id="22c0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在应该一切都好了，我们可以使用自定义模板在本地运行postman集合，并对其进行相应的调整。我们甚至可以使用<strong class="io hq"> Newman </strong>建立管道来运行我们的postman集合，并呈现结果和工件。</p><p id="3725" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，这意味着我们必须绑定结构，并依赖管道来提取结果。用<strong class="io hq">掌舵</strong>的更不可知论的方法提取测试工件(甚至是本地的)出现了，这就是Juxr发挥作用的地方。</p><h1 id="5132" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Juxr</h1><div class="hh hi ez fb hj ky"><a href="https://github.com/cloudbees-oss/juxr" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hq fi z dy ld ea eb le ed ef ho bi translated">cloudbees-oss/juxr</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">帮助管理JUnit XML格式报告的命令行工具。要在本地获得工具包，只需使用Cargo:注意…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">github.com</p></div></div><div class="lh l"><div class="mo l lj lk ll lh lm hl ky"/></div></div></a></div><p id="ca84" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> JUnit XML报告工具包</strong>是一个命令行工具，用于帮助管理JUnit XML格式的报告。它管理以下问题</p><blockquote class="mg mh mi"><p id="e5be" class="im in mj io b ip iq ir is it iu iv iw mk iy iz ja ml jc jd je mm jg jh ji jj hb bi translated">作为一名开发人员，我有一些测试在一个临时的Kubernetes pod中运行，我需要提取测试结果和任何相关的<a class="ae mp" href="https://plugins.jenkins.io/junit-attachments/" rel="noopener ugc nofollow" target="_blank">附件</a></p></blockquote><p id="686e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Juxr基本上支持通过标准I/O提取文件，而不是依赖测试容器的持久卷声明。它不仅适用于JUnit。xml文件，也适用于具有不同扩展名的其他类型的文件，例如html。</p><p id="78a7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，您并不一定要使用<strong class="io hq"> Juxr </strong>来输出到标准输出。您也可以使用这个命令将其输出为Juxr格式。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="4213" class="lw jl hp ls b fi lx ly l lz ma">needle="[[juxr::stream::$RANDOM::junit-test-report::TEST-custom.xml]]"<br/># NOTE: there must be a new line before the needle<br/>echo "" <br/>echo $needle<br/>base64 &lt; TEST-custom.xml<br/>echo $needle</span></pre><h1 id="4b5f" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">经营<strong class="ak"> Juxr和纽曼</strong>邮差系列</h1><p id="799a" class="pw-post-body-paragraph im in hp io b ip kk ir is it kl iv iw ix mq iz ja jb mr jd je jf ms jh ji jj hb bi translated">Juxr将使用与扩展名匹配的文件，并通过管道将其输出到标准输出。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="b16b" class="lw jl hp ls b fi lx ly l lz ma">$ juxr exec -r *.xml --files *.html -- newman run newman-collections.json --reporters junit,cli,htmlextra --reporter-htmlextra-title "Smoke API Tests" --reporter-htmlextra-template dashboard-template.hbs</span></pre><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="2612" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">查看<strong class="io hq"> Newman </strong>输出文件夹，我们可以看到以下工件。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="f77e" class="lw jl hp ls b fi lx ly l lz ma">newman<br/>│   <!-- -->newman-run-report-2021-06-07-07-34-48-952-0.xml<br/>│   <!-- -->Helm Testing-2021-06-07-07-37-44-931-0.html</span></pre><p id="fc39" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这意味着我们可以运行我们的测试容器，让<strong class="io hq"> Juxr </strong>输出工件作为结果。让我们看一下我们将用于测试容器的图像。</p><h1 id="9651" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">与纽曼和Juxr一起运行docker</h1><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="6669" class="lw jl hp ls b fi lx ly l lz ma">$ <!-- -->docker build . -t juxrnewman:1.0.0</span></pre><p id="b54c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">运行图像应该像这样。请记住，我们必须挂载一个本地卷，其中包含我们的postman集合。我们也可以添加提供我们的客户。hbs模板，如果我们决定不将其包含在docker文件中。文件夹应包含以下内容。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="969e" class="lw jl hp ls b fi lx ly l lz ma">dir<br/>│   <!-- -->newman-collections.json<br/>|   dashboard-template.hbs (Optional)</span></pre><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="91fe" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看，不用再依赖npm或纽曼了。只需运行docker命令。让我们来看看如何用<strong class="io hq">头盔</strong>将它们打包在一起。</p><h1 id="3caa" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">带头盔的包装</h1><p id="da23" class="pw-post-body-paragraph im in hp io b ip kk ir is it kl iv iw ix mq iz ja jb mr jd je jf ms jh ji jj hb bi translated">helm v3格式的结构。</p><p id="7a6c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae mp" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank">https://helm.sh/docs/topics/charts/</a></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1342" class="lw jl hp ls b fi lx ly l lz ma">service/  <br/>  Chart.yaml              <br/>  README.md           <br/>  values.yaml         <br/>  charts/             <br/>  crds/               <br/>  templates/<br/>  templates/tests # Folder containing the helm test pod definitions<br/>  and config map<br/>  collection/newman-collections.json # Our Postman collection</span></pre><h1 id="739e" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试舱</h1><p id="d5e1" class="pw-post-body-paragraph im in hp io b ip kk ir is it kl iv iw ix mq iz ja jb mr jd je jf ms jh ji jj hb bi translated">在<em class="mj">模板/测试</em>下你的头盔图中的测试舱</p><p id="ab8b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Helm使用<strong class="io hq">钩子注释</strong>来设置Pod命令退出代码状态下钩子的结果。</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="16ee" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">配置映射</h1><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="be44" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">带舵和Juxr的运行测试容器</h1><p id="318a" class="pw-post-body-paragraph im in hp io b ip kk ir is it kl iv iw ix mq iz ja jb mr jd je jf ms jh ji jj hb bi translated">一旦使用helm安装了服务，我们就可以运行一组测试套件，并让<strong class="io hq"> Juxr </strong>导入工件，这一次，我们处于接收端，Juxr将为我们处理解析。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="48fb" class="lw jl hp ls b fi lx ly l lz ma">$ helm test --logs | juxr import -o helm-test-results/</span></pre><p id="5895" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这应该像以前一样产生本地工件</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="72a2" class="lw jl hp ls b fi lx ly l lz ma">newman<br/>│   <!-- -->newman-run-report-2021-06-07-07-34-48-952-0.xml<br/>│   <!-- -->Helm Testing-2021-06-07-07-37-44-931-0.html</span></pre><p id="8338" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很好，我们现在可以开始指南的自动化部分，将它与我们的CI/CD环境更好地集成。</p><figure class="ln lo lp lq fd hk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mv"><img src="../Images/f006879f8a1bf969116b4dc298f968ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYHhaS6FQ4cvvlkqUio4Vg.png"/></div></div></figure><p id="1507" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里有一个简短的例子，说明如何使用<strong class="io hq"> GitLab CI </strong> stage来处理管道工件，并将其用于覆盖和构建工件。目前，我已经编辑了docker文件，以便用juxr和helm v3构建docker映像。这仅仅是为了给自动化部分提供一个思路。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="e164" class="lw jl hp ls b fi lx ly l lz ma">helm_test_dev:<br/>  stage: smoke_test_helm<br/>  image:<br/>    name: &lt;image with helm v3 and juxr&gt;<br/>    entrypoint: [ "/bin/sh", "-c" ]<br/>  before_script:<br/>    - echo $KUBE_CONFIG|base64 -d&gt;helm_kubeconfig.yaml<br/>  script:<br/>    - helm --kubeconfig helm_kubeconfig.yaml test --logs my-service --timeout 300s --namespace my-name-space | juxr import -o helm-test-results/<br/>  artifacts:<br/>    expire_in: 1 day<br/>    when: always<br/>    paths:<br/>      - helm-test-results/newman<br/>    reports:<br/>      junit:<br/>        - helm-test-results/newman/*.xml</span></pre><p id="efb5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<strong class="io hq"> GitLab Pages </strong>，您可以直接从GitLab的存储库中发布静态网站。我们应该充分利用我们的工件，并将它们发布到GitLab内的静态内容目录中。艺名“pages”是GitLab CI中的一个关键字，因此是必需的。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1af3" class="lw jl hp ls b fi lx ly l lz ma">pages:<br/>  stage: publish_pages<br/>  allow_failure: true<br/>  script:<br/>    - IMAGE_VERSION=${CI_COMMIT_SHA}<br/>    - mkdir public<br/>    - cp helm-test-results/newman/newman-report-${IMAGE_VERSION}.html public/index.html<br/>  artifacts:<br/>    paths:<br/>      - public<br/>    expire_in: 30 days</span></pre><p id="94ab" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个阶段运行之后，我们可以开始在我们的存储库的主GitLab pages路径中看到新的HTML生成的报告。这总结了如何在本地和基于CI/CD的环境中提取定制报告。如果有任何不清楚的地方，请随时联系我们。祝驾驶和测试愉快！</p></div></div>    
</body>
</html>
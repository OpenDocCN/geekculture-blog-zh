<html>
<head>
<title>How To Use Configurable Module Builders in Nest.js v9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Nest.js v9中使用可配置的模块生成器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-use-configurable-module-builders-in-nest-js-v9-ae1f458fd6ca?source=collection_archive---------5-----------------------#2022-11-07">https://medium.com/geekculture/how-to-use-configurable-module-builders-in-nest-js-v9-ae1f458fd6ca?source=collection_archive---------5-----------------------#2022-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7bf4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用于定制后端服务的动态Nest.js模块</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bd584df7bd82f25f8f6cb7becb2a20e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JJ5wbYs7tU6Kuc0O"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@htroupe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hannah Troupe</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="243f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Nest.js是专门用TypeScript制作的web框架。大多数接触过Nest.js的开发人员通常会认识到一些非常熟悉的东西，这是一个强大的面向对象编程模型，其语法与另一个框架Angular非常相似。</p><p id="7bc6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Nest.js代码通常会迫使你创建一个最优的设计模式。然而，从Java或ASP.NET背景迁移到Node.js和TypeScript的开发人员将很快理解Nest.js的结构。像依赖注入、封装、类和类注释(装饰器)这样的概念在Nest.js中都有。</p><p id="81c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Nest.js中，创建一个可重用的定制模块非常简单，而且最重要的是，我们鼓励这样做。将一个模块封装成小的可重用块将有助于提高Nest.js应用程序的开发速度，如果您决定将这些模块作为开源包发布，还会给您加分。</p><h1 id="6eb6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Nest.js模块是什么？</h1><p id="be16" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">但是在继续之前，Nest.js模块是什么？</p><p id="a8be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">模块是要注入Nest.js应用程序的封装代码集。您可以使用模块来创建旨在完成特定任务的定制服务。例如，TypeORM是基于TypeScript的ORM。Nest.js团队创建了一个模块，它将注入一个开放的数据库连接，允许来自注入模块的数据库命令和查询。</p><p id="7a13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Nest.js模块是框架健壮的依赖注入机制的主干。依赖注入是一种应用程序开发模式，旨在分离两个类(或模块)之间的依赖关系。不需要为每个类严格定义依赖关系，您可以使用一个接口来对依赖关系的行为方式进行某种程度的“约定”,而不需要对依赖关系的运行方式进行字面定义。</p><p id="f2c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解耦架构支持多种应用，并为应用中的每个模块创建即插即用行为。</p><h1 id="8856" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Nest.js模块状态管理</h1><p id="6c44" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">默认情况下，Nest.js模块是单例的。您只需要启动一个模块一次。虽然从工程的角度来看，为每个模块创建单例似乎有些过分，但是Nest.js将会在组件级别上<a class="ae jn" href="https://github.com/nestjs/nest/issues/47#issuecomment-300283919" rel="noopener ugc nofollow" target="_blank">初始化单例。</a></p><h2 id="29dd" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">Nest.js中的模块范围</h2><p id="e2db" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Nest.js中有三个模块注入范围:</p><ol class=""><li id="a125" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">请求级模块</li><li id="3645" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">组件级模块(瞬态)</li><li id="2226" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">共享应用程序级模块</li></ol><p id="addc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">默认情况下，大多数Nest.js模块都是应用程序级模块，或者您也可以将它们称为全局共享模块。但不是每个模块都可以是全局模块。例如，它们中的一些需要保持瞬态/请求级别。</p><p id="df6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，如果您需要一个应用程序级的只读模块，您最好的选择是使用全局共享模块。存储在模块中的数据不会经常改变，所以它可以作为应用程序级的单例对象被延迟，以节省内存并创建一个全局可访问的类。有<code class="du mj mk ml mm b">@Global</code>装饰器的模块消除了代码和组件级的冗余，因为你不需要重新初始化模块。</p><p id="c7c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了更好地理解模块级的状态保持，如果您在具有瞬态或请求范围的模块中有一个常量，它将是一个不可变的变量，直到模块在垃圾收集时销毁它。但是，当使用跨整个应用程序的全局模块时，它只会在应用程序的生命周期结束时被销毁。</p><h2 id="2dab" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">使用单例时防止数据竞争</h2><p id="2154" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">使用单例时需要小心的另一件事是数据竞争问题。<a class="ae jn" href="https://stackoverflow.com/questions/21438207/can-node-js-code-result-in-race-conditions" rel="noopener ugc nofollow" target="_blank"> Node.js对</a>数据争用情况并不免疫，Nest.js也是如此。数据争用情况是当两个独立的进程试图同时更新同一块数据时。因为对象是全局可访问的，同时执行数据可能会导致执行时丢失数据点。避免数据竞争情况的最佳实践是创建一个全局只读模块，并对每个模块的注入范围更加谨慎。</p><p id="7f36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">全局模块最容易受到数据竞争条件的影响，使用全局模块在组件之间通信或管理状态将导致反模式。</p><p id="6766" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是为什么瞬态组件级模块不能这样说呢？</p><p id="017c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在组件级别，封装障碍只扩展到组件的需求。每个瞬态模块提供程序都有一个专用的实例。组件级的关注点分离通常更细粒度，这使得它比大规模应用程序更可预测。</p><p id="3c18" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请求级的单例也是如此，尽管规模较小。</p><h1 id="610f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">简短的摘要</h1><p id="71bf" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">总而言之，Nest.js中的模块有三个注入范围:</p><ol class=""><li id="7780" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">请求级模块</li><li id="2d57" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">组件级模块(瞬态)</li><li id="2c3a" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">共享应用程序级模块(全局)</li></ol><p id="c02d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每一种都有其优点和缺点，数据竞争是全局模块最常见的问题。大部分全局模块应该是只读的，Nest.js在初始化时只会设置一次原始状态。</p><p id="f1c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">组件级模块有更多的细微差别；更具体地说，由于它们的可预测性，您可以将它们用于较小规模的状态管理。组件级的细粒度封装单件使其成为组件级状态管理的完美选择。</p><blockquote class="mn mo mp"><p id="c2d7" class="jo jp mq jq b jr js ij jt ju jv im jw mr jy jz ka ms kc kd ke mt kg kh ki kj hb bi translated"><strong class="jq hj">注</strong>:数据竞争条件只限于每个独立模块的状态。修改数据库等外部应用程序中的数据应该不成问题，因为数据库有自己的数据竞争解决方案。</p></blockquote><h1 id="b79f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Nest.js中的可配置模块生成器</h1><p id="e238" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">默认的Nest.js模块是静态的，不可配置的。另一方面，可配置模型构建器是动态模块工厂，可以根据初始化时传递的变量生成不同的模块。</p><h2 id="9f24" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">Nest.js中的动态模块</h2><p id="7bc3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">但是在开始做可配置模块之前，您需要理解动态模块的基础。它们的用例通常围绕创建一个非静态模块，该模块可以从外部API接收参数，以改变模块的行为方式，特别是每个模块处理数据的方式。</p><p id="f9dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，您创建了一个用于从数据库中查询数据的模块，但是您不想为特定的数据库提供者进行硬编码。那么如何解决问题呢？</p><p id="f653" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，您需要创建一个具有配置功能的模块。配置函数将有一个数据库提供者接口作为参数。提供者接口具有应用程序连接和查询数据库所需的所有基本功能。因为使用接口作为参数，所以只要提供者扩展了接口，就可以注入不同的数据库提供者。</p><p id="8fa8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">底层的业务逻辑仍然是相同的，但是数据库提供者将根据您在初始化时提供的而改变。因此，你的模块将不再是静态的，而是动态的。</p><p id="abda" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是所有可配置模块都是动态模块的本质原因。</p><h2 id="be2c" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">构建一个基本的可配置Nest.js模块</h2><p id="a7b6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">例如，您将创建一个定制的Nest.js模块，该模块使用<code class="du mj mk ml mm b">dotenv</code>包中的<code class="du mj mk ml mm b">process.env</code> API从<code class="du mj mk ml mm b">.env</code>文件中读取数据。该模块将作为一个可配置的代理，您可以在您的项目中使用。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/77bd057d4c645a44c10d02b6472174ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEB5okjdHWZ32VUbu86oQA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://mermaid.live/edit#pako:eNqNkUFuwyAQRa-CZpWo8SJZWt21OUG3SAjB2EGywYIhtZX67h2FOHXTVior-P_BH2YuYIJFqMF0OqVXp9uoe-kFr1H1weYOxfNHVQn0ZzXEME43tTCPamFZMZiSYvfhqVo8meATscLQgJEmtf8Hc_jOMDKqJnuj9pvtX9Zhsa5f-1HqpZhCVCXtXiwrLdLRnzfFGDS3ZHv33h2dXoJvXPuLP68TV234CutwFTUvclmwgx5jr53lgVyvSKAT9iih5q3FRueOJEg_M5oHqwmP1lGIUFPMuAOdKbxN3iznwtzGWsT5E4s7pd8" rel="noopener ugc nofollow" target="_blank">Module architecture</a>, image by author</figcaption></figure><p id="1ebc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">代理模块的架构似乎是多余的，因为您可以直接访问<code class="du mj mk ml mm b">process.env</code>变量，而无需依赖注入。但是为了简单起见，您将使用这个架构来全面掌握Nest.js模块是如何工作的。</p><p id="c3f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您的代理模块将在初始化时检索<code class="du mj mk ml mm b">process.env</code>，并将它存储在它的<code class="du mj mk ml mm b">env</code>属性中。Nest.js模块在默认情况下是单例的，所以只需要初始化一次。您可以执行<code class="du mj mk ml mm b">getEnv</code>函数来检索您的<code class="du mj mk ml mm b">env</code>变量，它将作为动态<code class="du mj mk ml mm b">env</code>属性的获取器。</p><p id="b54d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以在初始化时添加一个函数来接受参数并创建一个动态模块，使其可配置。在这种情况下，<code class="du mj mk ml mm b">withConfig</code>函数将是可配置的init函数。</p><h2 id="ca46" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">如何创建一个基本的可配置Nest.js模块</h2><p id="1a7f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">全局安装<code class="du mj mk ml mm b">@nest/cli</code>。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="0f62" class="lh kl hi mm b fi mz na l nb nc">npm i -g @nest/cli</span></pre><p id="0699" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，生成一个新的Nest.js app。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="f140" class="lh kl hi mm b fi mz na l nb nc">nest new configurable-module-builder-examples</span></pre><p id="2346" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">选择你喜欢的任何包管理器，但是本教程主要使用Yarn。你可以到<code class="du mj mk ml mm b">step-1</code>分支<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-1" rel="noopener ugc nofollow" target="_blank">这里</a>看到你目前生成的代码。</p><p id="a7f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个新的Nest.js项目将所有模块放在一个级别上；您需要重构它，然后才能继续。将模块、控制器和服务复制到一个名为<code class="du mj mk ml mm b">api-modules</code>的文件夹中，<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-2/src/api-module" rel="noopener ugc nofollow" target="_blank">将所有文件和变量名</a>从<code class="du mj mk ml mm b">App</code>重命名为<code class="du mj mk ml mm b">Api</code>。</p><p id="0934" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建一个新的<code class="du mj mk ml mm b">AppModule</code>文件，并在导入中注入<code class="du mj mk ml mm b">ApiModule</code>。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="5a80" class="lh kl hi mm b fi mz na l nb nc">import { Module } from '@nestjs/common';<br/>import { ApiModule } from './api-module/api.module';</span><span id="5bf2" class="lh kl hi mm b fi nd na l nb nc">@Module({<br/>  imports: [ApiModule],<br/>})<br/>export class AppModule {}</span></pre><p id="a295" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你没有跟上，检查<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-2" rel="noopener ugc nofollow" target="_blank">中的<code class="du mj mk ml mm b">step-2</code>分支。</a></p><p id="0979" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，您可以开始创建<code class="du mj mk ml mm b">process.env</code>代理模块。您需要<code class="du mj mk ml mm b">dotenv</code>包来访问<code class="du mj mk ml mm b">.env</code>文件，因此通过运行以下命令来安装依赖项:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="5165" class="lh kl hi mm b fi mz na l nb nc">yarn add dotenv</span></pre><p id="8383" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">创建一个新文件夹<code class="du mj mk ml mm b">src/env-proxy-module</code>并创建两个文件<code class="du mj mk ml mm b">env-proxy.module.ts</code>:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="0237" class="lh kl hi mm b fi mz na l nb nc">import { Global, Module } from '@nestjs/common';<br/>import { EnvProxyService } from './env-proxy.service';</span><span id="02f0" class="lh kl hi mm b fi nd na l nb nc">@Global()<br/>@Module({<br/>  providers: [EnvProxyService],<br/>  exports: [EnvProxyService],<br/>})<br/>export class EnvProxyModule {}</span></pre><p id="bc0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意<code class="du mj mk ml mm b">@Global</code>装饰器用于自动将模块的输出注入到注入组件的任何子组件中。您不必在每个模块上重复导入<code class="du mj mk ml mm b">EnvProxyModule</code>。您只需要在主<code class="du mj mk ml mm b">AppModule</code>中将它添加为导入。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="92f8" class="lh kl hi mm b fi mz na l nb nc">import { EnvProxyModule } from './env-proxy-module/env-proxy.module';</span><span id="5acc" class="lh kl hi mm b fi nd na l nb nc">@Module({<br/>  imports: [ApiModule, EnvProxyModule],<br/>})<br/>export class AppModule {}</span></pre><p id="53c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，创建服务文件<code class="du mj mk ml mm b">env-proxy.service.ts</code>:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="56d7" class="lh kl hi mm b fi mz na l nb nc">import { Injectable } from '@nestjs/common';</span><span id="4698" class="lh kl hi mm b fi nd na l nb nc">require('dotenv').config(); // eslint-disable-line</span><span id="903a" class="lh kl hi mm b fi nd na l nb nc">@Injectable()<br/>export class EnvProxyService {<br/>  public readonly env: NodeJS.ProcessEnv;<br/>  constructor() {<br/>    this.env = process.env;<br/>  }<br/>}</span></pre><p id="5bff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了测试<code class="du mj mk ml mm b">EnvProxyModule</code>，您可以创建一个<code class="du mj mk ml mm b">.env</code>文件，其中包含一个<code class="du mj mk ml mm b">DATA</code>参数:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="18a8" class="lh kl hi mm b fi mz na l nb nc">DATA=Hello World</span></pre><p id="d71b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过在一个<code class="du mj mk ml mm b">GET</code>请求中返回环境变量来试用这个模块:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="ec94" class="lh kl hi mm b fi mz na l nb nc">import { EnvProxyService } from '../env-proxy-module/env-proxy.service';</span><span id="badc" class="lh kl hi mm b fi nd na l nb nc">@Injectable()<br/>export class ApiService {<br/>  constructor(private readonly envProxy: EnvProxyService) {}</span><span id="b561" class="lh kl hi mm b fi nd na l nb nc">getHello(): string {<br/>    return this.envProxy.env.DATA;<br/>  }<br/>}</span></pre><p id="7913" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行开发服务器:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="066c" class="lh kl hi mm b fi mz na l nb nc">yarn start:dev</span></pre><p id="d2f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">打开浏览器并转到<code class="du mj mk ml mm b">localhost:3000</code>。您应该得到一条<code class="du mj mk ml mm b">Hello World</code>文本作为回报。这一步的完整代码可以在<code class="du mj mk ml mm b">step-3</code>分支<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-3" rel="noopener ugc nofollow" target="_blank">这里</a>看到。</p><p id="1037" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您已经创建了一个简单的模块，但是它还不可配置。可以用<code class="du mj mk ml mm b">ConfigurationModuleBuilder</code>来做。<code class="du mj mk ml mm b">ConfigurableModuleBuilder</code>是Nest.js v9中提供的新特性，其目的是减少创建可配置动态模块所需编写的样板代码的数量。</p><p id="563c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du mj mk ml mm b">src/env-proxy-module</code>内创建一个新文件<code class="du mj mk ml mm b">env-proxy.definition.ts</code>:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="2e43" class="lh kl hi mm b fi mz na l nb nc">import { ConfigurableModuleBuilder } from '@nestjs/common';</span><span id="765d" class="lh kl hi mm b fi nd na l nb nc">export interface EnvProxyModuleOptions {<br/>  exclude: string[];<br/>}</span><span id="5480" class="lh kl hi mm b fi nd na l nb nc">export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =<br/>  new ConfigurableModuleBuilder&lt;EnvProxyModuleOptions&gt;({<br/>    moduleName: 'EnvProxy',<br/>  })<br/>    .build();</span></pre><p id="f100" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du mj mk ml mm b">EnvProxyModuleOptions</code>接口表示您在初始化时通过配置文件传递的对象。在这种情况下，您将给出一个要从模块中排除的环境变量数组。</p><p id="cd1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使<code class="du mj mk ml mm b">EnvProxyModule</code>伸出<code class="du mj mk ml mm b">ConfigurableModuleBuilder</code>:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="530f" class="lh kl hi mm b fi mz na l nb nc">@Global()<br/>@Module({<br/>  providers: [EnvProxyService],<br/>  exports: [EnvProxyService],<br/>})<br/>export class EnvProxyModule extends ConfigurableModuleClass {}</span></pre><p id="9fd3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">继续执行<code class="du mj mk ml mm b">EnvProxyService</code>类并实现以下内容:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="94a3" class="lh kl hi mm b fi mz na l nb nc">@Injectable()<br/>export class EnvProxyService {<br/>  public readonly env: NodeJS.ProcessEnv;<br/>  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: EnvProxyModuleOptions) {<br/>    this.env = process.env;<br/>    options.exclude.forEach(val =&gt; {<br/>      delete this.env[val];<br/>    });<br/>  }<br/>}</span></pre><p id="bf5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以从构造函数和<code class="du mj mk ml mm b">@Inject</code>装饰器中检索<code class="du mj mk ml mm b">EnvProxyModuleOptions</code>对象。您将把排除环境变量的主要业务逻辑添加到<code class="du mj mk ml mm b">EnvProxyService</code>构造函数中。为了测试它，您可以创建第二个环境变量<code class="du mj mk ml mm b">DATA2</code>。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="bf36" class="lh kl hi mm b fi mz na l nb nc">DATA=Hello World<br/>DATA2=Hello World2</span></pre><p id="4de6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du mj mk ml mm b">AppModule</code>导入上，添加一个<code class="du mj mk ml mm b">register</code>函数并插入一个<code class="du mj mk ml mm b">EnvProxyModuleOptions</code>。</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="3bc2" class="lh kl hi mm b fi mz na l nb nc">imports: [ApiModule, EnvProxyModule.register({<br/>  exclude: [<br/>    "DATA"<br/>  ]<br/>})],</span></pre><p id="0869" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">模块将排除<code class="du mj mk ml mm b">DATA</code>变量，检查排除是否有效，编辑<code class="du mj mk ml mm b">ApiService</code>:</p><pre class="iy iz ja jb fd mv mm mw mx aw my bi"><span id="ae11" class="lh kl hi mm b fi mz na l nb nc">getHello(): string {<br/>  return this.envProxy.env.DATA ?? this.envProxy.env.DATA2;<br/>}</span></pre><p id="24cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当你访问<code class="du mj mk ml mm b">localhost:3000</code>时，你会得到<code class="du mj mk ml mm b">Hello World2</code>。</p><p id="2cb9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">祝贺您，您已经使用可配置模块生成器创建了您的第一个可配置模块！你可以在这里查看<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-4" rel="noopener ugc nofollow" target="_blank">最终的代码库</a>。</p><p id="29a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您的配置比前一个示例更复杂，您可以依赖工厂模式:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ne nf l"/></div></figure><p id="1906" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<code class="du mj mk ml mm b">useFactory</code>允许你调用异步代码来帮助你配置你的构建器。对于最后一个异步例子，你可以在找到它。</p><h1 id="6be0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">摘要</h1><p id="57cb" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">NestJS是一个内置于TypeScript中的面向对象的web框架。NestJS使用了强大的面向对象原则，并提供了许多功能，包括依赖注入、类、通过decorators的类注释和强大的封装。</p><p id="8c08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">NestJS中的状态管理在模块级别上有所不同。大多数模块的封装仅限于组件级，而很少有模块在应用程序级具有全局共享状态。所有的NestJS模块都使用单件。如果处理不当，拥有可以全局使用的共享模块会导致数据竞争。</p><p id="d12e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">大多数共享模块应该是只读的，但是也有一些情况下共享模块是实用的，记录和连接到消息队列。否则，您将只需要组件级的模块。</p><p id="3257" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">动态模块是非静态的可配置模块。本质上，所有可配置的模块都是动态的。可配置模块使用工厂模式根据初始化期间给定的参数创建不同的模块。</p><p id="20f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编写定制的NestJS模块非常简单。您可以访问GitHub上的代码示例，并使用不同的分支来<a class="ae jn" href="https://github.com/agustinustheo/configurable-module-builder-example" rel="noopener ugc nofollow" target="_blank">导航项目</a>的每个阶段。</p><p id="af49" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望你喜欢这篇文章。如果你有任何问题，请留言。</p><p id="9554" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="76ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mq">原载于2022年9月22日</em><a class="ae jn" href="https://blog.logrocket.com/use-configurable-module-builders-nest-js-v9/" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a><em class="mq">。</em></p></div></div>    
</body>
</html>
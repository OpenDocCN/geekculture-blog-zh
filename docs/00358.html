<html>
<head>
<title>Covariance and contravariance by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明协变和逆变</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/covariance-and-contravariance-by-example-99c2bc29fd40?source=collection_archive---------1-----------------------#2021-01-23">https://medium.com/geekculture/covariance-and-contravariance-by-example-99c2bc29fd40?source=collection_archive---------1-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0799f8b4cbe8ded1a9a52843b664c859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egc_TS19wfE-5hHxzqvMoA.png"/></div></div></figure><p id="9fd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">协变和逆变是非常怪异的词。</p><p id="ea81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我想让自己听起来很聪明，我会用这些词——这通常很有效。没有人真正知道这到底是什么。</p><p id="f415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我想尽可能简单地解释这个话题(但不是更简单)，我会尽量避免这些听起来很聪明的词。</p><p id="82ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将使用泛型实现一个存储库模式来解释这个主题。</p><p id="e0f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将使用C#作为我的例子，它与Java或Kotlin等语言非常相似。</p><h1 id="579e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">你已经知道一半了！</h1><p id="7741" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们定义几个简单的类。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c80b" class="la jp hi kw b fi lb lc l ld le">record Person(string Name);<br/>record Employee(string Name) : Person(Name);<br/>record RemoteEmployee(string Name, string location) : Employee(Name);</span></pre><p id="f32e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建几个雇员，并将他们放入一个集合中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="580b" class="la jp hi kw b fi lb lc l ld le">IEnumerable&lt;Employee&gt; people = new List&lt;Employee&gt;<br/>{<br/>    new Employee("Andrew"),<br/>    new RemoteEmployee("Karen","USA")<br/>};</span></pre><p id="72fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为一个<code class="du lf lg lh kw b">Employee</code>也是一个<code class="du lf lg lh kw b">Person</code>我应该可以这样做。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f7b4" class="la jp hi kw b fi lb lc l ld le">IEnumerable&lt;Person&gt; people = new List&lt;Employee&gt; // It's not &lt;Employee&gt; anymore.<br/>{<br/>    new Employee("Andrew"),<br/>    new RemoteEmployee("Karen","USA")<br/>};</span></pre><p id="50dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以如果一个<code class="du lf lg lh kw b">Employee</code>也是一个<code class="du lf lg lh kw b">Person</code>，我可以在赋值的左边使用一个更通用的类型。又名协方差！</p><p id="2ca7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单吧？</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es li"><img src="../Images/e79c84c6585f4d6f8c417b2a1da1d57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*QzZfBAAV5cJhYo4p.gif"/></div></figure><p id="9bc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我提到了一个<em class="lj">泛型类型</em>让我们做一些可以利用泛型的东西。让我们把数据保存在数据库里。</p><p id="9ee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的事实:泛型是在2005年与Visual Studio 200一起发布的C# 2.0中引入的。</p><p id="3da7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该用MySQL，Excel，SQL Server，SQLite还是Postgres？答案是——我们不必在意。我想做的只是插入一些数据，稍后再取回。这里，存储库模式来拯救我们了！</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="30c3" class="la jp hi kw b fi lb lc l ld le">interface IRepository&lt;T&gt;     // "T" stands for "data of some type"<br/>{<br/>    void Insert(T item);     // I want to insert some data.<br/>    T Get(string id);        // and get it <br/>    IEnumerable&lt;T&gt; GetAll(); //            back later<br/>}</span></pre><p id="3e91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我实现了一个非常简单的存储库，它将对象存储在磁盘上的Json文件中。这里可以看到<a class="ae lk" href="https://filerepository.cs/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a3ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你实现这样一个库时，你会在实现<code class="du lf lg lh kw b">Insert</code>方法时遇到一个问题。<br/>如何插入数据，以便日后检索？<br/>在<code class="du lf lg lh kw b">Get</code>方法中有一个<code class="du lf lg lh kw b">id</code>，但是你会在哪个<code class="du lf lg lh kw b">id</code>下插入数据呢？</p><p id="972b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里你有多种选择。让数据库来处理它——数据库可以生成一些Guid(比如Mongo ),或者关系数据库可以生成一个主键。<br/> 2。使用对象的哈希代码或ToString但是您可能永远也不会得到对象，所以千万不要这样做。<br/> 3。在将Id添加到数据库之前对其进行强制。<br/> 4。一些其他的想法。</p><p id="5c51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你是负责人，而不是数据库或哈希函数，所以我选择第三个选项。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/3c3eff75ce3e1e9128d4874b464bc13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*mlEZgo5tWA4ZPzzY.gif"/></div></figure><p id="7f49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望我所有的持久对象都实现一个<code class="du lf lg lh kw b">Entity</code>接口。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f4cb" class="la jp hi kw b fi lb lc l ld le">interface Entity { string Id { get; } }</span><span id="624f" class="la jp hi kw b fi lm lc l ld le">record Person(string Name) : Entity { public string Id =&gt; Name; } // Name is not the best Id of course.</span></pre><p id="7169" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还必须在接口本身上实施规则。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e368" class="la jp hi kw b fi lb lc l ld le">interface IRepository&lt;T&gt; where T : Entity  // "T" stands for "data of some type" where the data also has an Id.</span></pre><p id="4921" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我可以在数据库中存储我的员工名单了！</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c8cb" class="la jp hi kw b fi lb lc l ld le">static void Main(string[] args)<br/>{<br/>    var employeesRepository = new FileRepository&lt;Employee&gt;();<br/>    AddEmployees(employeesRepository);  // Add a list of employees to a repository<br/>    ReadAndPrintRepository(employeesRepository);     // Read the repository and print users.<br/>}</span><span id="af58" class="la jp hi kw b fi lm lc l ld le">static void AddEmployees(IRepository&lt;Employee&gt; repository) <br/>    =&gt; new List&lt;Employee&gt;<br/>        {<br/>            new RemoteEmployee("Karen","Usa"),<br/>            new Employee("Karen")<br/>        }.ForEach(repository.Insert);</span><span id="7505" class="la jp hi kw b fi lm lc l ld le">static void ReadAndPrintRepository(IRepository&lt;Employee&gt; repository) <br/>    =&gt; repository<br/>        .GetAll()<br/>        .ToList()<br/>        .ForEach(Console.WriteLine);</span></pre><p id="7c53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一切都工作，这是伟大的。但是员工也是人，所以我想做些小小的改变。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1edb" class="la jp hi kw b fi lb lc l ld le">static void ReadAndPrintRepository(IRepository&lt;Person&gt; repository)</span></pre><p id="5aac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">突然你得到一个错误</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1b28" class="la jp hi kw b fi lb lc l ld le">cannot convert from 'FileRepository&lt;Employee&gt;' to 'IRepository&lt;Person&gt;'csharp(CS1503)</span></pre><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/a62db655518d42d6548c15efb12d7069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*jzVI7GvPYjUViGhF.gif"/></div></figure><p id="99c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是为什么呢？它对上面的例子起作用！</p><p id="522c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">引用我的话“所以如果一个<code class="du lf lg lh kw b">Employee</code>也是一个<code class="du lf lg lh kw b">Person</code>，我可以在赋值的左边使用一个更抽象的类型。又名协方差！</p><p id="2c71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有什么区别？如果你看看IEnumerable(或者Java中的集合)接口，它是这样定义的。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="35a0" class="la jp hi kw b fi lb lc l ld le">public interface IEnumerable&lt;out T&gt; : System.Collections.IEnumerable</span></pre><p id="2763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh kw b">out</code>这个关键词在这里至关重要。它对编译器说——使用类型<code class="du lf lg lh kw b">T</code>或更抽象/派生的类型。类型<code class="du lf lg lh kw b">T</code>是一个<em class="lj">协变</em>参数。它允许一些变化，差异。</p><p id="61e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是为什么要用<code class="du lf lg lh kw b">out</code>这个关键词呢？为什么不是<code class="du lf lg lh kw b">in</code>或者<code class="du lf lg lh kw b">covariant</code>或者<code class="du lf lg lh kw b">leave me alone and work plz</code>？</p><p id="6291" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在我们的界面上添加一个<code class="du lf lg lh kw b">out</code>关键字，让我们看看。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3205" class="la jp hi kw b fi lb lc l ld le">Invalid variance: The type parameter 'T' must be contravariantly valid on 'IRepository&lt;T&gt;.Insert(T)'. 'T' is covariant. csharp(CS1961)</span></pre><p id="3aed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">(╯°□°）╯︵ ┻━┻</p><p id="5862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">怎么了？</p><p id="610a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧。当你指定<code class="du lf lg lh kw b">out</code>关键字时，意味着接口只能<strong class="is hj">输出</strong>类型<code class="du lf lg lh kw b">T</code>。它不能像在Insert方法中那样接受类型为<code class="du lf lg lh kw b">T</code>的输入。</p><p id="aeb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将从<code class="du lf lg lh kw b">IRepository</code>接口中移除<code class="du lf lg lh kw b">Insert</code>方法，并将其移动到<code class="du lf lg lh kw b">IWriteOnlyRepository</code>。为了在代码库中保持一些对称性，我将引入一个<code class="du lf lg lh kw b">IReadOnlyRepository</code>并将它们合并到<code class="du lf lg lh kw b">IRepository</code>中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0440" class="la jp hi kw b fi lb lc l ld le">interface IWriteOnlyRepository&lt;T&gt;<br/>{<br/>    void Insert(T item);<br/>}</span><span id="d07a" class="la jp hi kw b fi lm lc l ld le">interface IReadOnlyRepository&lt;out T&gt;<br/>{<br/>    T Get(string id);<br/>    IEnumerable&lt;T&gt; GetAll();<br/>}</span><span id="afec" class="la jp hi kw b fi lm lc l ld le">interface IRepository&lt;T&gt; : IWriteOnlyRepository&lt;T&gt;, IReadOnlyRepository&lt;T&gt; where T : Entity<br/>{<br/>}</span></pre><p id="e28c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当您使用<code class="du lf lg lh kw b">IReadOnlyRepository</code>接口作为<code class="du lf lg lh kw b">ReadAndPrintRepository</code>方法中的参数时，您将不会再收到错误！</p><p id="8834" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">┬─┬ノ( º _ ºノ)</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a99a" class="la jp hi kw b fi lb lc l ld le">static void Main(string[] args)<br/>{<br/>    var employeesRepository = new FileRepository&lt;Employee&gt;();<br/>    AddEmployees(employeesRepository);<br/>    ReadAndPrintRepository(employeesRepository);<br/>}</span><span id="f3aa" class="la jp hi kw b fi lm lc l ld le">static void ReadAndPrintRepository(IReadOnlyRepository&lt;Person&gt; repository) =&gt; repository.GetAll().ToList().ForEach(Console.WriteLine);</span><span id="d808" class="la jp hi kw b fi lm lc l ld le">static void AddEmployees(IRepository&lt;Employee&gt; repository) =&gt; new List&lt;Employee&gt;<br/>    {<br/>        new Employee("Bjork"),<br/>        new RemoteEmployee("Karen","Usa")<br/>    }.ForEach(repository.Insert);</span></pre><p id="f007" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切按预期运行。生活是美好的。但是如果我添加一个只处理远程雇员的特殊方法呢？</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7410" class="la jp hi kw b fi lb lc l ld le">static void AddRemoteEmployees(IRepository&lt;RemoteEmployee&gt; repository)<br/>    {<br/>        //some operations only valid for RemoteEmployee<br/>        //OnlyRemoteEmployeeMethod(remoteEmployee)<br/>        repository.Insert(new RemoteEmployee("Andrew","Canada"));<br/>        repository.Insert(new RemoteEmployee("Carol","UK"));<br/>    }</span></pre><p id="0c59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，你会得到这个错误</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5235" class="la jp hi kw b fi lb lc l ld le">cannot convert from 'FileRepository&lt;Employee&gt;' to IRepository&lt;RemoteEmployee&gt;'</span></pre><p id="0577" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh kw b">FileRepository</code>实现了接口<code class="du lf lg lh kw b">IRepository&lt;Employee&gt;</code>，所以只有一个雇员可以被添加到存储库中。你可以说那是非常刻板的。它不允许任何变化，因此它是<strong class="is hj">不变的</strong>。</p><p id="b0b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh kw b">IWriteOnlyRepository</code>目前存在与<code class="du lf lg lh kw b">IRepository</code>相同的问题，它不允许任何差异。既然我们在<code class="du lf lg lh kw b">IReadOnlyRepository</code>上有一个<code class="du lf lg lh kw b">out</code>修改器，难道我们没有一个<code class="du lf lg lh kw b">in</code>修改器可以使用吗？</p><p id="cc4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，我们有！当您指定<code class="du lf lg lh kw b">in</code>关键字时，这意味着接口只能接受类型为<code class="du lf lg lh kw b">T</code>的<strong class="is hj">输入</strong>。因为我们只使用类型<code class="du lf lg lh kw b">T</code>作为输入，并且我们从不返回，所以我们可以使用关键字<code class="du lf lg lh kw b">in</code>将输入类型标记为逆变。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3669" class="la jp hi kw b fi lb lc l ld le">interface IWriteOnlyRepository&lt;in T&gt;<br/>{<br/>    void Insert(T item);<br/>}</span></pre><p id="2ec1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后要做的事情是改变方法中的接口。由于<code class="du lf lg lh kw b">IRepository</code>不允许任何变化，我们必须使用更灵活的接口，即<code class="du lf lg lh kw b">IWriteOnlyRepository</code>。<code class="du lf lg lh kw b">RemoteEmployee</code>比<code class="du lf lg lh kw b">Employee</code>更具体，但是因为我们的<code class="du lf lg lh kw b">IWriteOnlyRepository</code>被标记了一个<code class="du lf lg lh kw b">in</code>关键字，所以它不介意更具体的类型。又名逆变。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9cf3" class="la jp hi kw b fi lb lc l ld le">static void AddRemoteEmployees(IWriteOnlyRepository&lt;RemoteEmployee&gt; repository) =&gt; new List&lt;RemoteEmployee&gt;<br/>    {<br/>        new RemoteEmployee("Andrew","Canada"),<br/>        new RemoteEmployee("Carol","UK")<br/>    }.ForEach(repository.Insert);</span></pre><p id="e18d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有用！<br/> (☞ﾟヮﾟ)☞</p><h1 id="e974" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="db8a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当你的接口允许你使用单一类型时，它没有灵活性，没有变化，因此它是<strong class="is hj">不变的</strong>。</p><p id="77f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以浏览一份雇员名单，把他们当作<code class="du lf lg lh kw b">Person</code>的，因为他们有一个<strong class="is hj">co</strong>common trait-<em class="lj">* *协方差</em></p><p id="b500" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您不能将员工列表视为经理列表，但是您应该能够将经理添加到员工列表中。这样你就从相反的一面来处理问题了——矛盾</p><p id="8f83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望我把这个奇怪的话题说得更清楚一点！</p></div></div>    
</body>
</html>
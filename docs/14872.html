<html>
<head>
<title>React Hooks: The Dangers Probably No One Told You About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子:可能没人告诉你的危险</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hooks-the-dangers-probably-no-one-told-you-about-264fb4393e9c?source=collection_archive---------2-----------------------#2022-09-30">https://medium.com/geekculture/react-hooks-the-dangers-probably-no-one-told-you-about-264fb4393e9c?source=collection_archive---------2-----------------------#2022-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5eac" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">探索钩子带来的危险以及如何保持领先并避免它们。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c11ea0c50f6f441aad2664f9db2b090e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8RpghVYVzO0jmgfIdCJ8A.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@xodusdigitals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oscar Omondi</a> on <a class="ae jn" href="https://unsplash.com/s/photos/mentorship?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2c9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">自从React 16.8引入钩子以来，几年过去了，大多数开发者已经抛弃了旧的类结构。</p><blockquote class="kk"><p id="cdcf" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated">钩子使得提取逻辑变得容易，也是重用逻辑的一种简单方式。在最初发布后，他们席卷了前端世界。</p></blockquote><p id="e96d" class="pw-post-body-paragraph jo jp hi jq b jr ku ij jt ju kv im jw jx kw jz ka kb kx kd ke kf ky kh ki kj hb bi translated">在过去的几年里，我在自己的和审查别人的代码中发现了十几个与钩子相关的问题。我试着分享一下我使用钩子遇到的危险，这样你就不用犯同样的错误了。</p><p id="460c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们经常认为主流创新是理所当然的，很少对它们进行足够的批判。我相信新的工具也应该用引入新的bug或者创造坏的编码习惯的容易程度来衡量。</p><p id="2828" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不要误解我——钩子是老派React所缺乏的一切，因为没有简单的方法来提取和共享组件之间的逻辑。开发人员必须处理HOC(高阶组件)或渲染道具。这两种模式对大多数人来说都太难使用了。</p><blockquote class="kz la lb"><p id="33fb" class="jo jp lc jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated">如果你对钩子一无所知或者需要复习，这里有一个不错的。<a class="ae jn" rel="noopener" href="/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">丹·阿布拉莫夫——理解反应钩</a></p></blockquote><h1 id="7979" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">1.属国</h1><p id="d7a1" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">字符串、布尔值、数字和其他原语可以直接作为依赖项添加到<code class="du md me mf mg b">useEffect</code>中。但是，您不能将数组和对象用作依赖项。原因——从简单的角度来看，它们没有可比性。</p><blockquote class="kk"><p id="3dee" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated"><strong class="ak">默认情况下，数组和对象会通过引用进行比较。</strong></p></blockquote><p id="c246" class="pw-post-body-paragraph jo jp hi jq b jr ku ij jt ju kv im jw jx kw jz ka kb kx kd ke kf ky kh ki kj hb bi translated">在以下两种情况下，这些依赖关系可能会影响useEffect挂钩的执行:</p><ul class=""><li id="fc7b" class="mh mi hi jq b jr js ju jv jx mj kb mk kf ml kj mm mn mo mp bi translated">数组或对象是相同的- JS将使用不同的引用来比较它们</li><li id="4d01" class="mh mi hi jq b jr mq ju mr jx ms kb mt kf mu kj mm mn mo mp bi translated">数组或对象有不同的值- JS将使用相同的引用来比较它们。</li></ul><p id="6070" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这两种情况下，挂钩都会导致bug，它们不会正确执行。</p><p id="0fb1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有一些已知的方法和技巧可以解决这个问题。这些都不是完美的解决方案，但有时我们只需要让事情运转起来。</p><ul class=""><li id="1abc" class="mh mi hi jq b jr js ju jv jx mj kb mk kf ml kj mm mn mo mp bi translated"><strong class="jq hj">第一个选项是使用</strong> <code class="du md me mf mg b"><strong class="jq hj">JSON.stringify()</strong></code></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ul class=""><li id="0644" class="mh mi hi jq b jr js ju jv jx mj kb mk kf ml kj mm mn mo mp bi translated"><strong class="jq hj">另一个(ES6)选项是使用</strong><a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">t</strong></a><strong class="jq hj">emplate文字将它们转换成字符串。</strong>类似于<code class="du md me mf mg b">JSON.stringify()</code>，除了结果不会被包在数组里。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ul class=""><li id="d41f" class="mh mi hi jq b jr js ju jv jx mj kb mk kf ml kj mm mn mo mp bi translated"><strong class="jq hj">第三个选项，如果数组大小不变，将使用扩展操作符:</strong></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h1 id="bc39" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">2.条件式</h1><blockquote class="kk"><p id="d346" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated">钩子依赖于执行的顺序，所以不可能有条件地调用钩子。</p></blockquote><p id="5024" class="pw-post-body-paragraph jo jp hi jq b jr ku ij jt ju kv im jw jx kw jz ka kb kx kd ke kf ky kh ki kj hb bi translated">有条件的使用钩子会改变顺序，你的Linter会抱怨。这个问题减少了我们构造钩子的方法。</p><p id="40d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从技术上讲，你不能在条件句中使用钩子。然而，如果你知道它们内部是如何工作的，你可以让条件钩子为你工作。</p><p id="95c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您需要为要渲染的每个钩子创建两个或更多组件。在每个组件中，您可以添加其逻辑。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">The logic for conditional rendering</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Hook that will be conditionally rendered.</figcaption></figure><p id="088f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这样，我们可以基于<code class="du md me mf mg b">userId</code>变量呈现两个不同的钩子。</p><h1 id="f883" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">3.使用效果问题</h1><p id="e8c6" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">开发人员使用<code class="du md me mf mg b">useEffect</code>来修改状态、DOM或进行API调用。</p><blockquote class="kk"><p id="db0b" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated">我甚至想不出有多少次有人问我，“为什么useEffect被调用两次？”或者“为什么我在useEffect中有一个无限循环？”。</p></blockquote><p id="c1d8" class="pw-post-body-paragraph jo jp hi jq b jr ku ij jt ju kv im jw jx kw jz ka kb kx kd ke kf ky kh ki kj hb bi translated">那么为什么useEffect首先是不好的呢？</p><ul class=""><li id="9af3" class="mh mi hi jq b jr js ju jv jx mj kb mk kf ml kj mm mn mo mp bi translated">useEffect的好处是:你几乎可以用它做任何事情</li><li id="eee6" class="mh mi hi jq b jr mq ju mr jx ms kb mt kf mu kj mm mn mo mp bi translated">useEffect的缺点是:你几乎可以用它做任何事情</li></ul><h2 id="1357" class="mx lh hi bd li my mz na lm nb nc nd lq jx ne nf ls kb ng nh lu kf ni nj lw nk bi translated">无限循环问题</h2><blockquote class="kz la lb"><p id="c13d" class="jo jp lc jq b jr js ij jt ju jv im jw ld jy jz ka le kc kd ke lf kg kh ki kj hb bi translated"><a class="ae jn" href="https://stackoverflow.com/questions/53070970/infinite-loop-in-useeffect" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/53070970/infinite-loop-in-use effect</a>——这个问题并不是唯一的一个——在11个月前添加，被17.5万开发者看到。</p></blockquote><p id="8829" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成无限循环最直接的方法是当一些状态改变时触发效果，当它改变时，您运行代码来触发这个确切的状态改变。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="8cad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最快的解决方案是删除导致此问题的依赖关系。</p><p id="6915" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你应该始终使用多重使用效果来保持单一责任原则。依赖越少，潜在的错误就越少。</p><p id="b30b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个钩子中的代码太多可能会给你带来麻烦。花些时间提取并重构<code class="du md me mf mg b">useEffect</code>中的函数。</p><h1 id="ab71" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">4.过度使用useCallback &amp; useMemo</h1><p id="049b" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">新的React开发人员通常认为这是一种更安全的记忆函数的方法。需要时，记忆化提供了一套强大的工具来防止不必要的渲染。</p><p id="cdda" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，太好的东西都有很高的价格。通过使用useCallback和useMemo，我们增加了代码的复杂性，这会影响开发的速度，并且从长远来看会引入错误。</p><blockquote class="kk"><p id="ac52" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated">性能优化不是免费的。我们应该把useMemo和useCallback看作是对app的微调。</p></blockquote><h2 id="a728" class="mx lh hi bd li my nl na lm nb nm nd lq jx nn nf ls kb no nh lu kf np nj lw nk bi translated">何时不优化</h2><p id="9078" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">尽管它们功能强大，但你不应该对每个函数都使用useMemo或useCallback。使用前，考虑先检查app性能。在添加这些挂钩之前，开始改进您的代码通常更好。</p><p id="2097" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">大多数时候，开发人员不应该费心去优化不必要的重新呈现器。天生反应快；我不认为我在使用它时遇到过性能问题。—对于React原生和移动应用程序开发来说，情况并非如此。</p><p id="a55c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这两者不能修复有害的代码，但是如果一切都已经就绪，它可以让你的代码变得更好——很好。</p><h2 id="f022" class="mx lh hi bd li my mz na lm nb nc nd lq jx ne nf ls kb ng nh lu kf ni nj lw nk bi translated">最好进行优化的情况</h2><p id="b7b7" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">当处理输入逐渐变化的函数时，可以使用<code class="du md me mf mg b">useMemo</code>。此外，当数据大到足以导致内存问题时，或者当参数大到比较的成本不会超过包装器的使用时。</p><p id="0cfa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du md me mf mg b">useCallback</code>在每次调用都要重新编译代码的情况下工作良好。当输入随时间变化时，记忆结果可以减少反复调用函数的成本。</p><p id="96a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">用useMemo进行昂贵的计算</strong></p><p id="4dd8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du md me mf mg b">useMemo</code>的好处是你可以得到这样一个值:</p><pre class="iy iz ja jb fd nq mg nr ns aw nt bi"><span id="a664" class="mx lh hi mg b fi nu nv l nw nx">const a1 = {b: props.b}</span></pre><p id="19fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">懒洋洋地得到它:</p><pre class="iy iz ja jb fd nq mg nr ns aw nt bi"><span id="34c7" class="mx lh hi mg b fi nu nv l nw nx">const a2 = useMemo(() =&gt; ({b: props.b}), [props.b])</span></pre><p id="8ad7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下<code class="du md me mf mg b">useMemo</code>是没有用的，但是想象一个计算一个值的函数，这个值的计算是非常昂贵的。不是很多应用程序都这样做，但如果他们这样做了，useMemo是一个完美的解决方案。</p><p id="9452" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通常，如果你开始注意到渲染问题，这是优化重新渲染的最佳时机。</p></div><div class="ab cl ny nz gp oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="hb hc hd he hf"><p id="5163" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！✋</p></div></div>    
</body>
</html>
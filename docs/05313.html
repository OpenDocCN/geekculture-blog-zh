<html>
<head>
<title>MongoDB: Why Avoid Sharding, it should be kept as the last option.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB:为什么要避免分片，它应该作为最后的选择。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/mongodb-why-avoid-sharding-it-should-be-kept-as-the-last-option-cb8fdc693b66?source=collection_archive---------5-----------------------#2021-07-18">https://medium.com/geekculture/mongodb-why-avoid-sharding-it-should-be-kept-as-the-last-option-cb8fdc693b66?source=collection_archive---------5-----------------------#2021-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/11d7d67f0d9c41e2243487c26ff2fa7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7ofJjEEOQgGi90j7DYQeg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">taken from <a class="ae hv" href="https://docs.mongodb.com/manual/sharding/" rel="noopener ugc nofollow" target="_blank">https://docs.mongodb.com/manual/sharding/</a></figcaption></figure><h2 id="d1ff" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph">MongoDB分片</h2><div class=""/><div class=""><h2 id="1497" class="pw-subtitle-paragraph je ih hy bd b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dx translated">是的，分片可以横向扩展我们的数据库，分片是对MongoDB为我们处理的复杂性的简化抽象，在许多情况下，我们有更好的选择。</h2></div><blockquote class="jw jx jy"><p id="34de" class="jz ka kb kc b kd ke ji kf kg kh jl ki kj kk kl km kn ko kp kq kr ks kt ku kv hb bi translated">避免不成熟的切分，即用法/规格/型号/要求..仍在变化。</p></blockquote><h2 id="ec49" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">内容</h2><ul class=""><li id="0966" class="lt lu hy kc b kd lv kg lw lh lx ll ly lp lz kv ma mb mc md bi translated"><em class="kb">分享经验。</em></li><li id="7213" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><em class="kb">故不与夏德。</em></li><li id="2f82" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">在你去切片之前<em class="kb">。</em></li><li id="4b21" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><em class="kb">分割时要考虑什么。</em></li><li id="b47e" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><em class="kb">用例</em></li></ul><h1 id="b347" class="mj kx hy bd ky mk ml mm lc mn mo mp lg jn mq jo lk jq mr jr lo jt ms ju ls mt bi translated"><em class="mu">分享经验</em>:</h1><p id="4f2a" class="pw-post-body-paragraph jz ka hy kc b kd lv ji kf kg lw jl ki lh mv kl km ll mw kp kq lp mx kt ku kv hb bi translated">凡事都有利弊，作为一名软件工程师，我们必须找到最适合的方法。<br/> <strong class="kc ii">我们的团队已经烧坏了手指，在那里我们选择了错误的碎片键，然后修复它是一场真正的噩梦</strong>。<br/>每当面临扩展问题时，我们许多人都会说分片是显而易见的选择。<br/>是的，分片确实提供了水平扩展的能力，但也增加了复杂性，使用不当会降低性能。</p><h1 id="a481" class="mj kx hy bd ky mk ml mm lc mn mo mp lg jn mq jo lk jq mr jr lo jt ms ju ls mt bi translated">不分享的理由:</h1><ul class=""><li id="7d1a" class="lt lu hy kc b kd lv kg lw lh lx ll ly lp lz kv ma mb mc md bi translated">选择次优的<a class="ae hv" href="https://docs.mongodb.com/manual/core/sharding-shard-key/" rel="noopener ugc nofollow" target="_blank">分片键</a>很多时候会适得其反。<br/> - <strong class="kc ii">数据在碎片上的不均匀分布</strong>-导致过度使用/未充分使用的碎片。<br/> - <strong class="kc ii">分散聚集查询</strong> -必须查询多个分片，然后聚集数据集返回结果，因为要么查询不包含查询中分片键的子集，要么次优分片键将数据分布在所有分片上，这将降低查询性能。<br/>-<a class="ae hv" href="https://docs.mongodb.com/manual/core/sharding-data-partitioning/#std-label-jumbo-chunks" rel="noopener ugc nofollow" target="_blank">-<strong class="kc ii">Jumbo Chunk</strong></a>-Chunk由于次优的shard-key而过度增长，无法迁移，并且驻留在重载该shard的同一个shard上。</li><li id="445d" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">备份和恢复。<br/> -迁移/备份/恢复部分数据(数据集)很复杂。<br/> -如果配置服务器(保存块信息)丢失/损坏，可能会导致整个集群损坏。</li><li id="2376" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">块迁移开销。<br/> -后台处理必须保持跨分片的块重新平衡。</li><li id="7203" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><a class="ae hv" href="https://docs.mongodb.com/manual/faq/sharding/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc ii">不可变分片键</strong> </a> —分片键不可更改，字段值不可更新。<br/> —在MongoDB 4.2和更早版本中，分片后不能更改分片键的选择。<br/> —从MongoDB 4.4开始，您可以<a class="ae hv" href="https://docs.mongodb.com/manual/core/sharding-refine-a-shard-key/#std-label-shard-key-refine" rel="noopener ugc nofollow" target="_blank">通过向现有分片键添加一个或多个后缀字段来改进分片键</a>。<br/> —从MongoDB 5.0开始，您可以<a class="ae hv" href="https://docs.mongodb.com/manual/core/sharding-reshard-a-collection/#std-label-sharding-resharding" rel="noopener ugc nofollow" target="_blank">通过更改文档的shard键来对集合</a>进行重新散列。<br/> <strong class="kc ii"> <em class="kb">仍然更改和更新分片密钥带来的开销可能会有所不同，这取决于您正在使用的版本</em> </strong>。</li></ul><h1 id="29d9" class="mj kx hy bd ky mk ml mm lc mn mo mp lg jn mq jo lk jq mr jr lo jt ms ju ls mt bi translated"><em class="mu">去划片之前</em></h1><ul class=""><li id="408a" class="lt lu hy kc b kd lv kg lw lh lx ll ly lp lz kv ma mb mc md bi translated"><a class="ae hv" rel="noopener" href="/geekculture/full-featured-multi-tenant-tenancy-with-spring-boot-mongodb-spring-mvc-f00c98a9df70">数据库多租户</a>。—与将所有内容保存在一个数据库中不同，为每个客户端创建一个数据库操作/维护多个数据库非常高效。</li><li id="1809" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">数据建模 —对你的数据建模至关重要，这不仅有助于提高性能，还有助于控制复杂性。</li><li id="2b72" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">索引— <a class="ae hv" rel="noopener" href="/swlh/mongodb-indexes-deep-dive-understanding-indexes-9bcec6ed7aa6">理解索引</a>并选择正确的索引有助于极大地提高性能。</li><li id="e199" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">优化系统。服务器级配置可提高硬件级的性能。</li></ul><h1 id="71ce" class="mj kx hy bd ky mk ml mm lc mn mo mp lg jn mq jo lk jq mr jr lo jt ms ju ls mt bi translated">仍在考虑该考虑些什么。</h1><p id="9d2e" class="pw-post-body-paragraph jz ka hy kc b kd lv ji kf kg lw jl ki lh mv kl km ll mw kp kq lp mx kt ku kv hb bi translated">你已经用各种可能的方式优化了你的系统，但你无法处理大规模的收集，那就只能进行分片。</p><ul class=""><li id="e3dd" class="lt lu hy kc b kd ke kg kh lh my ll mz lp na kv ma mb mc md bi translated"><strong class="kc ii">分片键选择</strong>——选择分片键是最关键的任务。它有很多变量，你应该在切分之前了解它们。</li><li id="79e9" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><strong class="kc ii">数据性质</strong> -例如。不要把不同种类的数据放在一起(没有被一起查询的数据),简而言之，你会陷入分片的陷阱，并且有理由不进行分片。数据如何增长，对数据的操作(读取量大还是写入量大)..</li><li id="67b0" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated"><a class="ae hv" href="https://docs.mongodb.com/manual/core/zone-sharding/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc ii">分区分片</strong> </a> <strong class="kc ii"> - </strong>我们可以创建<strong class="kc ii">分区(</strong>组分片<strong class="kc ii"> ) </strong>，并决定每个分区上驻留的数据范围，这将有助于均匀分布数据。</li></ul><h1 id="05f9" class="mj kx hy bd ky mk ml mm lc mn mo mp lg jn mq jo lk jq mr jr lo jt ms ju ls mt bi translated">用例</h1><p id="2680" class="pw-post-body-paragraph jz ka hy kc b kd lv ji kf kg lw jl ki lh mv kl km ll mw kp kq lp mx kt ku kv hb bi translated">我遇到的几个用例/场景。</p><p id="fdfc" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">因为碎片键的不可变性质以及在碎片之间移动/平衡数据/块的开销。</p><p id="f0b1" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">何时不要分片:</p><ul class=""><li id="9244" class="lt lu hy kc b kd ke kg kh lh my ll mz lp na kv ma mb mc md bi translated">应用程序仍在发展的应用程序数据库。</li><li id="fae4" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">规范可能改变的ETL数据处理。</li><li id="a919" class="lt lu hy kc b kd me kg mf lh mg ll mh lp mi kv ma mb mc md bi translated">使用模式未知的数据湖。</li></ul><h2 id="8730" class="kw kx hy bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ie bi translated">参考资料:</h2><div class="hh hi ez fb hj nb"><a href="https://docs.mongodb.com/manual/sharding/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">分片</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">分片是一种在多台机器上分发数据的方法。MongoDB使用分片来支持部署…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">docs.mongodb.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np hp nb"/></div></div></a></div><div class="hh hi ez fb hj nb"><a href="https://docs.mongodb.com/manual/tutorial/manage-shard-zone/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">管理分片区域</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">在分片集群中，您可以创建代表一组分片的区域，并关联一个或多个分片范围…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">docs.mongodb.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np hp nb"/></div></div></a></div><div class="hh hi ez fb hj nb"><a rel="noopener follow" target="_blank" href="/geekculture/mongodb-data-modeling-matters-first-step-to-optimization-data-modeling-series-1-158be911ecb8"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">MongoDB:数据建模至关重要，优化的第一步[数据建模系列-1]</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">MongoDB带来了整个世界的数据建模，就像在SQL中预先定义模式一样，而在大多数时候…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">medium.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np hp nb"/></div></div></a></div><div class="hh hi ez fb hj nb"><a rel="noopener follow" target="_blank" href="/geekculture/full-featured-multi-tenant-tenancy-with-spring-boot-mongodb-spring-mvc-f00c98a9df70"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">采用Spring Boot Spring MVC实现的MongoDB多租户/租赁</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">MongoDB和Spring Boot，Spring MVC多租户数据库和在www.github.com推出的实现</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">medium.com</p></div></div><div class="nk l"><div class="ns l nm nn no nk np hp nb"/></div></div></a></div><div class="hh hi ez fb hj nb"><a rel="noopener follow" target="_blank" href="/swlh/mongodb-indexes-deep-dive-understanding-indexes-9bcec6ed7aa6"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">MongoDB索引:深入研究，理解索引。</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">通过了解什么是数据结构，它是如何…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">medium.com</p></div></div><div class="nk l"><div class="nt l nm nn no nk np hp nb"/></div></div></a></div><div class="hh hi ez fb hj nb"><a href="https://docs.mongodb.com/manual/faq/sharding/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd ii fi z dy ng ea eb nh ed ef ih bi translated">常见问题:使用MongoDB进行分片</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">本文档回答了关于分片的常见问题。另请参见手册中的分片部分，该部分提供了一个…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">docs.mongodb.com</p></div></div><div class="nk l"><div class="nu l nm nn no nk np hp nb"/></div></div></a></div></div><div class="ab cl nv nw gp nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hb hc hd he hf"><p id="00db" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">希望这将是有帮助的，请做评论，如果你发现有什么需要补充的地方。</p><p id="b66f" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki lh kk kl km ll ko kp kq lp ks kt ku kv hb bi translated">祝切分愉快，谢谢:)</p></div></div>    
</body>
</html>
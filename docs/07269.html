<html>
<head>
<title>Working with Spies in Angular Unit Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在角度单元测试中与间谍一起工作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/working-with-spies-in-angular-unit-test-71c1b9583208?source=collection_archive---------37-----------------------#2021-09-13">https://medium.com/geekculture/working-with-spies-in-angular-unit-test-71c1b9583208?source=collection_archive---------37-----------------------#2021-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db577e5ed8a50c96e9688eb68c06c9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M728MN0Y40_An3XbWD41Ag.jpeg"/></div></div></figure><h1 id="0421" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="6416" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在《Angular  中的<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">单元测试的上一篇教程中，我们介绍了您应该遵循的常见测试用例模式，并内置了您在编写测试用例时可以使用的匹配器。然而，随着应用程序变得越来越复杂，一个函数可能会与多个函数链接起来，这使得对单个函数进行<strong class="jq hj">单元测试</strong>变得更加困难。单元测试的思想是将应用程序分成多个单元，然后一次测试一个。这就是茉莉间谍发挥作用的地方。</strong></a></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="8a32" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">什么是间谍？</h1><p id="7a0e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">间谍是Jasmine中的一个特性，它允许你<strong class="jq hj">监视某些东西</strong>以达到以下目的:</p><ol class=""><li id="4c39" class="kz la hi jq b jr lb jv lc jz ld kd le kh lf kl lg lh li lj bi translated">监视是否调用了一个函数以及传递给它的参数</li><li id="396f" class="kz la hi jq b jr lk jv ll jz lm kd ln kh lo kl lg lh li lj bi translated">覆盖函数返回值或属性，以模拟测试期间的期望情况</li><li id="9e06" class="kz la hi jq b jr lk jv ll jz lm kd ln kh lo kl lg lh li lj bi translated">完全覆盖函数的实现</li></ol><p id="6a83" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">Spy可以用于属性和函数，包括window对象中的natvie函数、组件中定义的函数，甚至API调用。</p><p id="8218" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">尽管Spies可以用于API调用，但是您只能覆盖返回值，而不能覆盖HTTP状态代码。我们将在另一章讨论如何处理异步API调用。</p><p id="8745" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">基本上来说，只要你想在测试中覆盖函数，间谍将是你的解决方案。</p><h1 id="503d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如何使用间谍</h1><p id="65e5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于这一部分，我们将使用下面的代码来演示如何在单元测试中使用Spies。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/3701b5e4762a912d61e97d18a54f861f.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*lNotjULAIYjpjLqeOIIKXg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Person Interface</figcaption></figure><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/e4b3fbb28826542eb6ba5f829cdf4fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*GCbJR-0xa6HgGoS8HiQhuw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">serveDrink and canDrinkAlcohol function</figcaption></figure><p id="11c1" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">使用间谍的基本语法是:</p><p id="a70e" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">spyOn( <strong class="jq hj">要窥探的对象</strong>，<strong class="jq hj">要窥探的函数或属性</strong>)</p><p id="a6fd" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">间谍接受两个论点:</p><ol class=""><li id="6385" class="kz la hi jq b jr lb jv lc jz ld kd le kh lf kl lg lh li lj bi translated">你想监视的对象</li><li id="1fb8" class="kz la hi jq b jr lk jv ll jz lm kd ln kh lo kl lg lh li lj bi translated">要监视的对象的函数名或属性名</li></ol><h2 id="fad7" class="mc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">测试函数是否被调用</h2><p id="eef2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在上面的示例代码中，我们期望在调用<strong class="jq hj">served link</strong>时会调用<strong class="jq hj"> canDrinkAlcohol </strong>函数。</p><p id="3cf0" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">我们可以用下面的测试用例来测试这种行为:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/043720c4df3711586635af274a0f2163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYPDH7MvynoGJ5rltg7I7Q.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test if function is called</figcaption></figure><p id="1ba3" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">在第47行，我们设置了spy并将其保存到一个名为<strong class="jq hj"> fnc </strong>的变量中。<br/>在第53行，我们调用了<strong class="jq hj">served link</strong>函数。<br/>在第56行，我们测试我们监视的函数是否被调用了。</p><p id="0e9e" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">注意，spy必须在调用函数之前设置<strong class="jq hj">。如果我们将第53行放在第47行之前，测试将会失败，因为我们实际上是在函数已经被调用之后才窥探它的。</strong></p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/fba7ba3283d46a162952e3639eec5130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*YfWSSkUahs4CAFRyR6Vlyw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test function called result</figcaption></figure><h2 id="33a2" class="mc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">传递给函数的测试参数</h2><p id="d34b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">canDrinkAlcohol期望它的调用者传入年龄信息。我们可以用下面的测试用例来验证参数确实被传递给了它。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/c866cba557f0c39637157119da27643b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DTmJqzyEG81n7C6L3FJFw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test function is called with correct argument</figcaption></figure><p id="276b" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">测试用例与前一个非常相似。我们仅将匹配器功能更改为<strong class="jq hj">来调用</strong>匹配器。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/fead90aed40e5e705d8357fa6a915b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LG-1JXrYqOWbgFGQmbk4hw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test function argument result</figcaption></figure><h2 id="5869" class="mc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">测试函数被调用的次数</h2><p id="71be" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你想测试一个函数被调用了多少次，你可以遵循下面的测试用例。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/3ac8214ef61ec0c7333ba9c9bbdec81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89pHVnhfsuWmY1QnFh2CYg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test number of times a function is called</figcaption></figure><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/476861e0c9401e60fb09c22cec458dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*6VM5arSnNegd-FwsQEt4OQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Test number of times a function is called result</figcaption></figure><p id="f1a2" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">当您有一个循环并且函数被调用的次数与数组的大小有关时，<strong class="jq hj"> toHaveBeenCalledTimes </strong>匹配器特别有用。</p><h2 id="1495" class="mc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">覆盖被探测对象的返回值</h2><p id="3652" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在某些情况下，您希望子函数返回特定的值，以便TestSuite可以测试您想要测试的if语句路径。</p><p id="472c" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">例如</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/37745fb983bf0220f74952e30e4c200b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIxuosztkdZrNr_wiWX32w.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Override function return value test case</figcaption></figure><p id="3a79" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">在第89行，我们准备了将在这个测试用例中使用的虚拟数据。请注意，只有当输入参数age大于或等于18时，我们的<strong class="jq hj"> canDrinkAlcohol </strong>函数才会返回true。然而，在第92行，我们通过用<strong class="jq hj"> returnValue </strong>函数链接我们的spy对象来覆盖<strong class="jq hj"> canDrinkAlcohol </strong>的返回值。也就是说，不管输入参数是什么，不管这个函数是如何实现的，<strong class="jq hj"> canDrinkAlcohol </strong>函数总是在被调用时返回true。</p><p id="9d6f" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">然后在第98行，我们检查当<strong class="jq hj"> canDrinkAlcohol </strong>函数返回true时<strong class="jq hj">served link</strong>是否会返回Beer。</p><p id="ac35" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">注意。还有一个名为<strong class="jq hj"> returnValues </strong>的函数，它允许你传入多个参数。例如:</p><p id="6288" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">spyOn(component，' canDrinkAlcohol ')和. returnValues(true，false)；</p><p id="83ad" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">上面的语句意味着在第一次调用canDrinkAlcohol函数时，返回true，在第二次调用canDrinkAlcohol函数时，返回false。</p><h2 id="d993" class="mc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">测试用例中的覆盖函数</h2><p id="b7a2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设您希望完全覆盖子函数的实现，而不是返回值，您可以使用下面的方法。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/bc4b5d5b10c257c25aaf4a73b4790721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0sqFqxlulaW5YqjfdLx7g.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Override function in test case</figcaption></figure><p id="93b5" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">在第106行，我们用<strong class="jq hj"> callFake </strong>函数链接我们的spy。当指定callFake时，TestSuite将执行假函数，而不是ts文件中定义的实际函数。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es my"><img src="../Images/69aa9dd06e8793ab2e6e1c848fface40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*4-ISRQ9550kLLsj7-Fsxng.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Override function result</figcaption></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="6fce" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">结论</h1><p id="ec95" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本教程中，我们已经介绍了如何在单元测试中使用间谍。掌握Spies将允许你编写大量覆盖良好的测试。在角度 的<a class="ae km" href="https://simpleweblearning.com/tag/unit-test-in-angular" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">单元测试的下一个教程中，我们将使用本章所学内容来演示如何测试角度组件。</strong></a></p><p id="51fc" class="pw-post-body-paragraph jo jp hi jq b jr lb jt ju jv lc jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">原帖:<br/><a class="ae km" href="https://simpleweblearning.com/working-with-spies-in-angular-unit-test" rel="noopener ugc nofollow" target="_blank">https://simple web learning . com/working-with-spies-in-angular-unit-test</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Introduction to Container-Based Application Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于容器的应用程序开发简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-container-based-application-development-8ac4a7522858?source=collection_archive---------6-----------------------#2021-06-04">https://medium.com/geekculture/introduction-to-container-based-application-development-8ac4a7522858?source=collection_archive---------6-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3ac25f596d06e4bb0b3720eb172a02ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yum5cf4KycspX9YStWCGxw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig 1: Containers (Source: Google)</figcaption></figure><h1 id="5b1e" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">应用架构的演变</h1><h1 id="4c92" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">第1代:黑暗时代</h1><blockquote class="js"><p id="3d51" class="jt ju hi bd jv jw jx jy jz ka kb kc dx translated">一台物理服务器—一个应用程序</p></blockquote><figure class="ke kf kg kh ki ij er es paragraph-image"><div class="er es kd"><img src="../Images/56faf28e627b1a6b83f5ee84ae41e22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*N5FU6-vl8GrfNWDolqX-dg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx">Fig 2: 1st Generation</figcaption></figure><p id="8c6f" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">第一代系统由一个物理服务器和一个应用程序组成。物理服务器是为单个用户设计的，不能在其他用户之间共享。<strong class="kl hj">一个</strong> <strong class="kl hj">单一操作系统在物理硬件</strong>之上。应用程序运行在这个操作系统之上。这种实现有许多缺点，</p><h2 id="9281" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">不足之处</h2><ul class=""><li id="0000" class="lu lv hi kl b km lw kq lx ku ly ky lz lc ma kc mb mc md me bi translated">浪费资源。</li><li id="b9cf" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">维护成本巨大。</li><li id="9eaf" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">部署缓慢。</li><li id="28a4" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">更难扩展。</li><li id="67b3" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">难以迁移。</li></ul><h1 id="a5ad" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">第2代:基于虚拟机管理程序的虚拟化</h1><blockquote class="js"><p id="19d0" class="jt ju hi bd jv jw jx jy jz ka kb kc dx translated"><em class="mk">一台物理服务器—多台虚拟机</em></p><p id="028a" class="jt ju hi bd jv jw jx jy jz ka kb kc dx translated"><em class="mk">一个虚拟机—一个应用</em></p></blockquote><figure class="ke kf kg kh ki ij er es paragraph-image"><div class="er es ml"><img src="../Images/8858f16b6633ffc8fee5070a55500f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*WnpcoRbMJmpKVwXv6OX7mA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Fig 3: 2nd Generation</figcaption></figure><h2 id="caf3" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">重要术语</h2><ul class=""><li id="7870" class="lu lv hi kl b km lw kq lx ku ly ky lz lc ma kc mb mc md me bi translated"><strong class="kl hj">虚拟化:</strong>创建一个没有实体的虚拟版本。</li><li id="d995" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated"><strong class="kl hj">虚拟机:</strong>计算机系统的虚拟化。</li><li id="39f1" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated"><strong class="kl hj"> Hypervisor </strong>:能够创建和运行虚拟机的软件。</li></ul><p id="e938" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">这使得我们能够在一台物理服务器上运行多个虚拟机。这些虚拟机中的每一个都有一个单独的操作系统，并分配有一定数量的内存。让我们讨论一下这种实现的优缺点。</p><h2 id="59b7" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">优势</h2><ul class=""><li id="2dea" class="lu lv hi kl b km lw kq lx ku ly ky lz lc ma kc mb mc md me bi translated">更好地利用资源。</li><li id="ea9a" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">缩放相对容易。</li></ul><h2 id="4a5e" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">不足之处</h2><ul class=""><li id="07dc" class="lu lv hi kl b km lw kq lx ku ly ky lz lc ma kc mb mc md me bi translated">多个虚拟机需要多种资源。</li><li id="b417" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">便携性较差。</li><li id="a152" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">管理和配置不同的虚拟机。</li></ul><h1 id="93ab" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">第三代:容器</h1><p id="89fd" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">容器作为上述问题的解决方案出现了。容器基本上帮助软件在不同的计算环境中可靠地运行。容器和虚拟机都有类似的资源隔离和分配优势，但容器更加便携和高效。</p><figure class="mq mr ms mt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/ee7e9936f38c42c9c01c803a92930772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGBH10lQkivoaFKE2_ynbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig 4: VMs vs Containers</figcaption></figure><blockquote class="mu mv mw"><p id="1381" class="kj kk mx kl b km kn ko kp kq kr ks kt my kv kw kx mz kz la lb na ld le lf kc hb bi translated"><strong class="kl hj">容器虚拟化操作系统而不是硬件。</strong></p></blockquote><h1 id="de1d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">码头工人</h1><figure class="mq mr ms mt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/e6978cbd5f9a90b32ec121de1c69fb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-wq-xETD5giUacoLt6Z8g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Fig 5: Docker</figcaption></figure><blockquote class="js"><p id="dece" class="jt ju hi bd jv jw nc nd ne nf ng kc dx translated"><strong class="ak"> <em class="mk">一个可以用来容器化应用的工具。</em>T19】</strong></p></blockquote><p id="f5a6" class="pw-post-body-paragraph kj kk hi kl b km nh ko kp kq ni ks kt ku nj kw kx ky nk la lb lc nl le lf kc hb bi translated">Docker基本上是一个容器引擎，在Linux内核特性的帮助下，可以用来在现有操作系统之上生成容器。它是一个开源项目，为开发人员提供了一种机制，可以轻松地将应用程序从基础设施中分离出来，以便快速可靠地交付软件。开发人员可以使用或不使用docker来创建容器。然而，docker使它更容易构建，并具有许多不同的优点。</p><ul class=""><li id="5eb0" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">易于扩展。</li><li id="4ccd" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">高度可用。</li><li id="b440" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">易于部署。</li><li id="b3cd" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">易于管理的应用程序。</li></ul><p id="db33" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">其他关键方面，</p><ul class=""><li id="681a" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">Docker是轻量级的T21，因为它只包含必需的操作系统进程和依赖关系。普通的VMs容器必须支持整个操作系统实例的有效负载。</li><li id="70a7" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">Docker通过提供简单的部署、供应和重启机制，显著提高了开发人员的生产力。</li><li id="dabd" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">Docker为<strong class="kl hj">提供了巨大的资源效率</strong>，因为开发者可以在相同的硬件上运行应用程序的不同副本。</li></ul><p id="2579" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">让我们详细看看与Docker相关的一些概念。</p><h2 id="e8cd" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">Docker图像</h2><p id="a34c" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">这是docker中的关键组件之一。它基本上是一个带有一组指令的模板，可用于创建docker容器。docker图像可以包含诸如，</p><ul class=""><li id="0352" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">应用程序代码。</li><li id="bc79" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">图书馆</li><li id="f19f" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">工具</li><li id="d830" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">依赖性等等。</li></ul><p id="6097" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">Docker映像能够拥有一个或多个特定容器的实例。创建docker映像有两种主要方式。</p><ul class=""><li id="e29a" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated"><strong class="kl hj">交互</strong>:从现有的Docker映像运行一个容器。</li><li id="dc49" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated"><strong class="kl hj"> Docker文件</strong></li></ul><h2 id="443f" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">Docker文件</h2><p id="009f" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">开发人员可以从docker hub下载docker映像并使用它们。然而，在有些情况下，开发人员需要创建定制的Docker图像。docker文件是一个文本文件，它解释了自己构建Docker映像的过程。</p><h2 id="8ae3" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">码头引擎</h2><p id="475f" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">指Docker的核心产品。Docker引擎是负责使用其服务和元素构建和运行容器的主要组件。该引擎包含Docker守护程序和Docker CLI。这基本上是一种用于构建容器化应用程序的容器化技术。</p><h2 id="b7c8" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">Docker注册表</h2><p id="92d1" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">指能够存储和分发Docker图像的服务器端应用程序。这个应用程序是开源的，高度可伸缩的。</p><p id="16e8" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">何时使用docker注册表？</p><ul class=""><li id="0ca2" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">当需要控制Docker图像的存储位置时。</li><li id="ba8c" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">拥有图像分发管道的全部所有权。</li><li id="29c8" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">将图像存储集成到内部开发工作流程中。</li></ul><p id="91e6" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated"><strong class="kl hj"> Docker Hub </strong>可以作为Docker Registry的替代品。它包含零维护的现成解决方案。</p><h2 id="14be" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated">Docker编排</h2><p id="8926" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">这指的是将所有docker实例集合在一起并追求共同目标的过程。它基本上是一个工具—</p><ul class=""><li id="c6ce" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">将应用程序打包并作为容器运行。</li><li id="1196" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">查找现有的容器图像。</li><li id="e0fe" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">部署容器。</li></ul><p id="06dc" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">例如，一个应用程序可能有几个组件，如HTTP引擎、HTTP授权等。可能有几个容器来执行这些活动。Docker编排将决定容器应该放在哪里，需要什么依赖关系，等等。</p><p id="c277" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">有各种框架可以用来执行这个编排过程。</p><h2 id="4056" class="lg iv hi bd iw lh li lj ja lk ll lm je ku ln lo ji ky lp lq jm lc lr ls jq lt bi translated"><strong class="ak"> Kubernetes ( k8s ) </strong></h2><p id="13b2" class="pw-post-body-paragraph kj kk hi kl b km lw ko kp kq lx ks kt ku mm kw kx ky mn la lb lc mo le lf kc hb bi translated">一个流行的开源容器编排平台。Kubernetes自动化了容器编排中涉及的手动流程(部署、管理和扩展)。这是通过将可用的应用程序容器分组到逻辑单元中来实现的，以便于管理和发现。</p><p id="063e" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated"><strong class="kl hj">Kubernetes的特点</strong></p><ul class=""><li id="227d" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">存储协调。</li><li id="f327" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">自动推出和回滚。</li><li id="53a7" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">服务发现和负载平衡。</li><li id="ee60" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">水平缩放。</li><li id="53a5" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">批量执行。</li></ul><p id="547d" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">Docker是一项持久的技术。特定容器中的文件即使在容器停止执行后也是持久的。Docker可以用于现有的应用程序和新的应用程序。然而，为了充分利用Docker的功能，应用程序应该适合正确的架构。这意味着即使是遗留应用程序也可以使用docker。然而，它们可能无法发挥docker的全部功能。</p><h1 id="8868" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">开放集装箱倡议(OCI)</h1><figure class="mq mr ms mt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/ed5f27d6d8b67fe0834fb055588ec148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zmi8hacO-DIzMLRdaZKsUQ.jpeg"/></div></div></figure><p id="f48c" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">Docker Inc公司在2011年引入了Docker的技术。另一家公司开始使用这个docker概念，他们发现它不适合他们的架构和业务需求。因此他们实现了一个叫做Rocket的类似框架。后来，这造成了许多不同的管理和技术问题。因此，多克和火箭达成协议，成立OCI。</p><p id="da7f" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">OCI是一个开放的治理结构，其明确目的是围绕容器格式和运行时创建开放的行业标准。包含2个主要规格。</p><ul class=""><li id="8713" class="lu lv hi kl b km kn kq kr ku nm ky nn lc no kc mb mc md me bi translated">运行时规范</li><li id="3e9b" class="lu lv hi kl b km mf kq mg ku mh ky mi lc mj kc mb mc md me bi translated">图像规格</li></ul><p id="51fa" class="pw-post-body-paragraph kj kk hi kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kc hb bi translated">我使用了Krishntha Dinesh先生的以下视频来收集所需的信息。</p><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="nr ns l"/></div></figure></div><div class="ab cl nt nu gp nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hb hc hd he hf"><h1 id="9b84" class="iu iv hi bd iw ix oa iz ja jb ob jd je jf oc jh ji jj od jl jm jn oe jp jq jr bi translated">参考</h1><div class="of og ez fb oh oi"><a href="https://docs.docker.com/registry/#:~:text=The%20Registry%20is%20a%20stateless,under%20the%20permissive%20Apache%20license" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab dw"><div class="ok ab ol cl cj om"><h2 class="bd hj fi z dy on ea eb oo ed ef hh bi translated">Docker注册表</h2><div class="op l"><h3 class="bd b fi z dy on ea eb oo ed ef dx translated">这个页面包含了关于使用开源Docker注册表托管你自己的注册表的信息。供参考…</h3></div><div class="oq l"><p class="bd b fp z dy on ea eb oo ed ef dx translated">docs.docker.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow io oi"/></div></div></a></div><div class="of og ez fb oh oi"><a href="https://en.wikipedia.org/wiki/Open_Container_Initiative" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab dw"><div class="ok ab ol cl cj om"><h2 class="bd hj fi z dy on ea eb oo ed ef hh bi translated">开放容器倡议-维基百科</h2><div class="op l"><h3 class="bd b fi z dy on ea eb oo ed ef dx translated">开放容器倡议(OCI)是一个Linux基金会项目，由Docker于2015年6月启动，旨在设计开放的…</h3></div><div class="oq l"><p class="bd b fp z dy on ea eb oo ed ef dx translated">en.wikipedia.org</p></div></div></div></a></div><div class="of og ez fb oh oi"><a href="https://www.sciencedirect.com/topics/computer-science/hypervisor-based-virtualization" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab dw"><div class="ok ab ol cl cj om"><h2 class="bd hj fi z dy on ea eb oo ed ef hh bi translated">基于虚拟机管理程序的虚拟化</h2><div class="op l"><h3 class="bd b fi z dy on ea eb oo ed ef dx translated">与基于虚拟机管理程序的虚拟化相比，操作系统级虚拟化或容器具有以下区别…</h3></div><div class="oq l"><p class="bd b fp z dy on ea eb oo ed ef dx translated">www.sciencedirect.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow io oi"/></div></div></a></div><div class="of og ez fb oh oi"><a href="https://www.oracle.com/it/cloud-native/container-registry/what-is-docker/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab dw"><div class="ok ab ol cl cj om"><h2 class="bd hj fi z dy on ea eb oo ed ef hh bi translated">什么是码头集装箱注册</h2><div class="op l"><h3 class="bd b fi z dy on ea eb oo ed ef dx translated">容器是一种打包格式，它以标准格式打包应用程序的所有代码和依赖项…</h3></div><div class="oq l"><p class="bd b fp z dy on ea eb oo ed ef dx translated">www.oracle.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow io oi"/></div></div></a></div></div></div>    
</body>
</html>
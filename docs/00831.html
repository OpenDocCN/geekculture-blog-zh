<html>
<head>
<title>Watch Out for This Istio Proxy Sidecar Memory Pitfall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心这个Istio代理边车内存陷阱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d?source=collection_archive---------1-----------------------#2021-03-15">https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d?source=collection_archive---------1-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dfa38fd73a81115eda466b124153e579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*i22hmhYQw9AP6XZ8.jpg"/></div><figcaption class="im in et er es io ip bd b be z dx">Image Source: YouTube</figcaption></figure><p id="41ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们与我公司的Istio一起进行的服务网格之旅中，我们遇到了许多令人困惑的问题，其中许多问题让我们希望我们能够提前知道这些陷阱。这是在大型Kubernetes集群中使用Istio时可能会遇到的一个陷阱。通过分享我在这个问题上的经验，我希望能帮助你在自己的Istio工作中避免它。</p><h1 id="1634" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问题Istio代理边车的内存消耗过多</h1><p id="7f5f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">特使代理边车是Istio服务网状架构的基石。特使代理为网格中的服务执行所有流量管理功能，例如路由、mTLS、断路、授权、重试等。</p><p id="25f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们第一次在专门用于Istio实验的小型Kubernetes集群中部署Istio时，一切都是教科书式的。我们学习并尝试了它的功能，并建立了前进的信心。然后，我们决定在我们更大的开发Kubernetes集群中部署Istio。这个集群已经使用了一段时间，跨多个业务线的多个团队正在积极地使用它来部署和测试他们的容器化工作负载。部署在该集群中的独特服务数量约为数百个。</p><p id="0c6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们在这个集群中部署我们的测试Istio应用程序时，我们注意到在较小的集群中平均消耗700MB的每个pod中的代理sidecars现在突然在较大的集群中消耗700MB到1.2 GB！这是同一个应用程序，配置没有变化。为什么它突然消耗了这么多内存？！</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/1f63093b17d96d961de663b05ac6abfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*nJjNaSEGEuW8qJVCamWdWw.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Excessive memory consumption by Envoy proxy sidecars</figcaption></figure><p id="ee27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个pod 1GB的配额根本不可行。但更重要的是，很明显有些事情不太对劲，所以我们决定调查一下。</p><h1 id="66aa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">根本原因</h1><p id="ca85" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了执行其流量管理功能，每个代理边车需要了解集群中的服务生态系统。该信息由Istio控制平面的“pilot”组件提供给代理边车(pilot现在是Istio控制平面中单一“istiod”服务的一部分)。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/badd9a63fc3934c782f44a22f1125a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*oOYDiadbvMjIJkRDpPu9Vw.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Pilot feeds metadata about deployed cluster services to each proxy sidecar (Source: Istio.io)</figcaption></figure><p id="91d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个问题——默认情况下，pilot假设每个代理可能需要将流量路由到集群中的<em class="ky">任何</em>服务，因此它继续将集群中每个服务的<em class="ky">元数据推送到每个代理。代理将这些元数据保存在内存中。默认情况下，Istio控制平面推送的元数据量(以及每个代理保存在内存中的数据量)与集群中部署的服务数量成正比。在我们的案例中，这个数字是几百。其结果就是我们在该集群中部署第一个网格服务后立即观察到的情况——每个边柜消耗1 GB内存！</em></p><p id="1670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用istioctl工具找出特定pod中的sidecar代理加载了多少配置信息。</p><pre class="kt ku kv kw fd kz la lb lc aw ld bi"><span id="9ed7" class="le jq hi la b fi lf lg l lh li">istioctl proxy-config clusters &lt;&lt;name-of-pod&gt;&gt; -n &lt;&lt;namespace-where-pod-is-deployed&gt;&gt;</span></pre><p id="57b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的情况下，这是很多！</p><h1 id="39c9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">简单的解决方法</h1><p id="7c03" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">幸运的是，有一种简单的方法可以修复这种导致具有大量服务的集群中失控的代理边盘内存消耗问题的默认行为。使用<a class="ae jo" href="https://istio.io/latest/docs/reference/config/networking/sidecar/" rel="noopener ugc nofollow" target="_blank"> Sidecar </a>定制资源，您可以很容易地限制名称空间，Istio控制平面会将信息推送到您的代理Sidecar。在我们的案例中，我们部署了以下边车资源:</p><pre class="kt ku kv kw fd kz la lb lc aw ld bi"><span id="2406" class="le jq hi la b fi lf lg l lh li">apiVersion: networking.istio.io/v1alpha3<br/>kind: Sidecar<br/>metadata:<br/>  name: default<br/>  namespace: istio-system<br/>spec:<br/>  egress:<br/>  - hosts:<br/>    - "./*"<br/>    - "istio-system/*"</span></pre><p id="bbcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述边车将部署在集群中的istio代理边车的流量管理范围限制为仅部署在与它们相同的命名空间中的服务，以及部署在istio-system命名空间中的服务，其中部署了Istio控制平面和入口/出口网关服务。除了施加其他流量管理限制之外，这个Sidecar还限制了推送到代理和由代理缓存的配置数据量。</p><p id="22e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意,“默认”Sidecar资源需要部署在“rootNamespace”中，通过<a class="ae jo" href="https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/" rel="noopener ugc nofollow" target="_blank"> MeshConfig </a>进行配置。默认情况下，这是“istio-system”名称空间，但是如果您在集群中覆盖了这个名称空间，那么您的默认Sidecar将需要部署在您为Istio config指定的“rootNamespace”名称空间中。</p><p id="a627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们部署了这个Sidecar资源并重新部署了我们的Istio应用程序，我们立即注意到代理Sidecar在内存消耗方面的差异。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/7df37a71f6b0b9f5796e754208eed8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*RZIj179lWHjbftJvxU43dA.png"/></div><figcaption class="im in et er es io ip bd b be z dx">Reduction in proxy sidecar memory consumption after namespace restriction via “Sidecar” resource</figcaption></figure><p id="3857" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内存消耗从1GB下降到74MB左右，这是一个显著的改进。我们使用istioctl工具验证了代理，并确认它们在更改后确实只有特定于名称空间的配置信息。</p><p id="0204" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您需要特定名称空间中的代理sidecars能够与集群中的其他名称空间通信，该怎么办？这可以通过在各个名称空间中部署更好的Sidecar资源来覆盖默认的Sidecar资源来实现，这些名称空间扩展了该名称空间中代理的名称空间范围。</p><h1 id="bd88" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="6e18" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当涉及到资源消耗时，部署Istio的Kubernetes集群的特征对其行为有明显的影响。监控与各种Istio控制平面和数据平面组件相关的资源指标非常重要，尤其是当您将服务网格应用程序迁移到新集群，或者更改当前集群的架构和大小时。默认行为可能不正确。幸运的是，有一些技术和方法可以用来调整默认行为——在这种情况下，就是代理边车的资源消耗。</p><p id="afad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看克里斯蒂安·波斯塔(即将出版的书<a class="ae jo" href="https://www.manning.com/books/istio-in-action" rel="noopener ugc nofollow" target="_blank">的合著者</a>)的这个短片，它很好地解释了这个问题和解决方案:【https://www.youtube.com/watch?v=JcfLUHdntN4】的<a class="ae jo" href="https://www.youtube.com/watch?v=JcfLUHdntN4" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>
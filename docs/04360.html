<html>
<head>
<title>Design Patterns for Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务的设计模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/design-patterns-for-microservices-5362689581c4?source=collection_archive---------1-----------------------#2021-06-25">https://medium.com/geekculture/design-patterns-for-microservices-5362689581c4?source=collection_archive---------1-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/41b9aaed23c2bab18b27222d7e134deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odg1fy4dcyLuPOeVOt16Jg.png"/></div></div></figure><p id="c499" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在之前的博文中，我们介绍了从单片到微服务架构的迁移。如果你还没有阅读过<a class="ae jo" href="https://jdewapura.medium.com/monolithic-to-microservices-ce043a3be80c" rel="noopener">上一篇文章</a>，我建议你在阅读这篇文章之前先阅读一下。</p><p id="5095" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文的最后，您将了解用于微服务的三种不同的设计模式。</p><ul class=""><li id="78f0" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">聚合器模式</li><li id="829a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">断路器模式</li><li id="03c3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">代理模式</li></ul><h1 id="dd3a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">聚合器模式</h1><p id="e2e8" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我们都知道微服务是把应用设计成独立服务的集合。这些服务可能不代表应用程序的特定功能。因此，聚合器模式调用几个微服务来实现其功能。换句话说，聚合器模式用于在服务之上开发聚合器服务。</p><p id="214d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们举个例子来适当理解一下。假设我们要设计一个员工管理系统。因此，项目架构将以几个不同的服务结束，这里我考虑其中的四个。</p><ul class=""><li id="057c" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">获取员工信息</li><li id="548d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">获取出勤信息</li><li id="1d6d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">获取性能信息</li><li id="36a5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">获取项目分配信息</li></ul><p id="2468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">光靠这些服务什么都做不了。因此，这个应用程序应该有计算雇员工资的功能。它必须调用两种不同的服务，如员工信息和出勤信息。应该集成这两个服务来实现这一功能。因此，我们可以开发一个聚合服务来操作这两个服务，并将响应发送给客户端。实现聚合服务并不是一件很浪费时间的事情。假设有一天，这家公司改变了它的商业计划。所以，他们的工资计算应该与员工的表现相结合。这就是聚合模式的重要性。您可以简单地开发另一个聚合服务来获得新的功能。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/89247293c3aed64200808d4943333cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piaVmIdmcswdVLi0aj4ALw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Aggregator Pattern</figcaption></figure><p id="9de3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用聚合模式有三种不同的方式。</p><ul class=""><li id="5ca9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">链式模式</li><li id="9150" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">平行模式(分散聚集模式)</li><li id="b1da" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">分支模式</li></ul><h2 id="6062" class="lp ke hi bd kf lq lr ls kj lt lu lv kn jb lw lx kr jf ly lz kv jj ma mb kz mc bi translated">链式模式</h2><p id="5278" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">假设我们有两个服务，分别叫做A和b。在继续处理服务b的请求之前，我们需要从A的响应中获得一些信息。换句话说，A需要在启动b之前完成。这称为链接过程，它可以通过链模式来实现。</p><p id="954e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这通常发生在单片应用程序转换为微服务时。此外，一些过程应该一个接一个地发生。例如，考虑一个银行应用程序，交易应该在验证帐户余额大于交易金额后继续进行。</p><h2 id="09e7" class="lp ke hi bd kf lq lr ls kj lt lu lv kn jb lw lx kr jf ly lz kv jj ma mb kz mc bi translated">平行模式</h2><p id="b279" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在应用程序中，一些服务可以同时进行以获得单一功能。让我们假设A和B服务可以独立执行。每个服务需要10毫秒才能完成。在收到来自两个服务的每个响应后，就会发生聚合。理论上，如果我们使用并行聚合，此功能可以在10–15毫秒内完成。但是连锁模式相继进行这些服务。这意味着整个功能需要超过20毫秒。因此，微服务鼓励尽可能使用并行聚合。</p><h2 id="d1ab" class="lp ke hi bd kf lq lr ls kj lt lu lv kn jb lw lx kr jf ly lz kv jj ma mb kz mc bi translated">分支模式</h2><p id="ffc5" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">一些应用程序在执行下一个服务之前需要做出决策。让我们假设A、B和C是三种不同的服务。先A执行，然后B或C根据A的响应执行，所以，有A执行后的决策情况。这就是所谓的分支聚集。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="60f2" class="kd ke hi bd kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la bi translated">断路器模式</h1><p id="ad75" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在进入断路器模式之前，你应该知道断路器是用于电力的。断路器位于主电网和房屋内部电路之间。它保护你家的电路免受过电流/过载或短路造成的损坏。断路器模式背后的基本思想与这个过程非常相似。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/5e9e32fbf65056b8dee6ec5b4b79818f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*gEq6h3O2M2lDw69h"/></div></figure><p id="4d65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您有多个服务时，服务有可能从几个后端调用。正如我上面提到的，这些服务被聚合起来以提供应用程序功能。当服务器收到客户端的请求时，它会分配一个线程来调用后端。例如，A、B和C服务可能涉及提供P功能(聚合器服务)。有时，由于网络连接缓慢、超时等原因，这些服务(服务B)不可用。因此，这些请求将在线程池中等待，直到超时或响应到达。因此，剩余的请求将被阻塞，直到服务恢复。它被称为级联队列。但是，如果服务B被恢复，它将尝试处理队列中的那些请求。因此，服务将再次中断。断路器模式可以克服这个问题。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/9ccf2ce303b1d3543261d48b2be45e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTD3x6WYd7_J76doWCgTJg.png"/></div></div></figure><p id="7cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在断路器模式中，所有服务都有预定义的阈值，并通过响应时间对它们进行监控。假设服务B的响应时间通常不到100毫秒，超时阈值为200毫秒。在某些情况下，超过50%的请求达到了阈值上限(150–200毫秒)。那么这个服务就被标记为慢慢下降。如果出现的次数超过200毫秒，消费者认为服务B不再响应。因此，下一个想要访问服务B的请求会立即失败。这意味着它中断了聚合服务和服务b之间的连接。因此，请求不会等到超时。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/2199c7a332c94de8aed6148576242dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k467Jn_W0nDxYk-47Xm_TA.png"/></div></div></figure><p id="7594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消费者经常在后台向服务B发送ping请求。如果恢复，它将再次连接到聚合器服务。由于服务停机期间所有请求的失败，服务可以用新的请求启动。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="d5d8" class="kd ke hi bd kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la bi translated">代理模式</h1><p id="18e1" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当考虑一个典型的应用程序时，客户需求可能会经常改变。因此，服务需要随着新功能而改变。此外，应用程序可能有一些补丁更新。这是代理模式适合系统的地方。代理模式可用于管理特定服务的几个不同版本，直到消费者升级到新版本。</p><p id="bfb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们举个例子来了解一下。在我们的员工管理系统中，工资计算服务与3种不同的服务一起工作。考勤信息服务就是其中之一。随着时间的推移，公司希望以适当的方式记录出勤情况。所以，考勤服务有了新的标准。但是，喜欢工资计算服务的消费者可能不会改变他们的服务。因此，我们需要部署两个不同版本的考勤服务，直到所有消费者都迁移到新版本。</p><p id="2ac0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获得它，开发人员需要在消费者和服务的不同版本之间创建一个代理服务。如果使用者访问旧版本的服务，代理服务会将请求定向到旧版本。否则，它将指向新版本。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/71b602ea5fc3333ce240e0204dccb160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muesjIcBcHXZJqBCVJr7Hg.png"/></div></div></figure><p id="ff27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用代理模式，您可以独立地部署您的服务，而不会打扰您的消费者。将来，如果您看不到旧版本的任何流量，您可以停用该版本。</p><p id="a087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">语义版本</strong></p><p id="b88e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我上面提到的，当部署服务的几个版本时，它应该是一个类似语义版本化的标准。在语义版本控制中，有三个数字称为主要版本、次要版本和补丁。</p><p id="e859" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">主要</strong>——当开发人员添加可能破坏现有API的新特性时。</p><p id="7c39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">次要</strong>——当开发者添加新特性时，不会破坏现有的API。</p><p id="7392" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">补丁</strong>—bug修复时。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/0dc9c7927b4839ca31515de9a2c8e035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n8B3CmCVx2hF1t84.png"/></div></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="eb01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里说到本文的结尾，希望你明白设计模式在微服务中的重要性。如果我漏掉了什么，请在评论区告诉我。保持联系。快乐学习！</p><h1 id="13ca" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考</h1><p id="2532" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><a class="ae jo" href="https://www.youtube.com/watch?v=DZeXqbFvYNA&amp;list=PLD-mYtebG3X9HaZ1T39-aF4ghEtWy9-v3&amp;index=5" rel="noopener ugc nofollow" target="_blank">微服务设计模式第1部分</a></p><p id="20a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.youtube.com/watch?v=mw8W-RpvCu0&amp;list=PLD-mYtebG3X9HaZ1T39-aF4ghEtWy9-v3&amp;index=6" rel="noopener ugc nofollow" target="_blank">微服务设计模式第二部分</a></p><p id="3c9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.youtube.com/watch?v=7mBvb7nKONg&amp;list=PLD-mYtebG3X9HaZ1T39-aF4ghEtWy9-v3&amp;index=7" rel="noopener ugc nofollow" target="_blank">微服务设计模式第三部分</a></p><div class="mu mv ez fb mw mx"><a href="https://www.edureka.co/blog/microservices-design-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">微服务设计模式|微服务模式| Edureka</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">在当今的市场上，微服务已经成为构建应用程序的首选解决方案。众所周知，它们可以解决…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">www.edureka.co</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl io mx"/></div></div></a></div><div class="mu mv ez fb mw mx"><a href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">断路器</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">软件系统对运行在不同进程中的软件进行远程调用是很常见的，可能是在不同的…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">martinfowler.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl io mx"/></div></div></a></div><div class="mu mv ez fb mw mx"><a href="https://martinfowler.com/microservices/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">微服务指南</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">软件系统对运行在不同进程中的软件进行远程调用是很常见的，可能是在不同的…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">martinfowler.com</p></div></div><div class="ng l"><div class="nn l ni nj nk ng nl io mx"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Processing Large Numeric Arrays in Python — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理大型数值数组—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/processing-large-numeric-arrays-in-python-part-i-94b5fd46390f?source=collection_archive---------4-----------------------#2022-03-15">https://medium.com/geekculture/processing-large-numeric-arrays-in-python-part-i-94b5fd46390f?source=collection_archive---------4-----------------------#2022-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7b04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">在本文</em><a class="ae je" href="https://dgolovin-dev.github.io/article-processing-big-numeric-arrays-in-python/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a><em class="jd">中，他解释了如何与numpy、pandas、xarray、cython和numba合作，在</em><a class="ae je" href="http://www.quantiacs.com" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">quanti ACS</em></strong></a><em class="jd">平台上优化实现大型数值数组的操作。</em></p><p id="4cc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Python </strong>在数据科学家中非常流行，它被广泛用于处理数据。因为它是一种解释型语言，所以它不是快速数据处理的最佳选择。c、Java或任何其他编译语言通常要快得多。</p><p id="67b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想用Python达到一个可接受的性能，你<strong class="ih hj">必须</strong>使用一些<em class="jd">特殊库</em>，它们允许你使用编译语言的性能优势。</p><p id="8f62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中我将谈论<a class="ae je" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><a class="ae je" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">熊猫</strong></a><a class="ae je" href="https://docs.xarray.dev/en/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">xarray</strong></a><a class="ae je" href="https://cython.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">cyt hon</strong></a><strong class="ih hj"/>和<strong class="ih hj"/><a class="ae je" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">numba</strong></a>。我将向您展示如何正确使用它们，并将性能提高两个数量级。</p><p id="05df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该示例的源代码可在<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> github </strong> </a>上获得，您可以在那里下载代码并检查性能。</p><h1 id="a5c4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">任务</h1><p id="4898" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">任务很简单。我们从一个数组开始，该数组包含过去20年每天的2000个股票市场数据。我们要计算一个<a class="ae je" href="https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">价格的指数移动平均值</strong> </a>。</p><p id="f338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会在这里展示结果，所以你可以自己决定这篇文章对你来说是否有趣。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/240e11791d03de755288949022c88c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*gNnJ9LV72FEUJY3obeQGOA.png"/></div></figure><p id="54f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">听起来有趣吗？我希望如此。当我开始这个基准测试时，我使用每日<strong class="ih hj">市场数据</strong>，包括价格(开盘价、最高价、最低价、收盘价)、成交量、股息和拆分:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kq"><img src="../Images/00342d7706ba2547e0f5d3c9cf626509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*9h-aOnpno3HKX-KuaKwphA.png"/></div></figure><p id="7754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的目标是在以下约束条件下计算指数移动平均值:</p><ul class=""><li id="e710" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated"><strong class="ih hj">执行</strong>的时间必须比 <strong class="ih hj"> <em class="jd">小【T10秒</em></strong>；</li><li id="699f" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated"><strong class="ih hj"> RAM </strong>内存消耗<em class="jd">不得超过</em> <strong class="ih hj"> <em class="jd"> 1.5 GB </em> </strong>。</li></ul><h1 id="54b0" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">标杆管理</h1><p id="6df3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">开始之前，让我快速描述一下我是如何<em class="jd">测量</em>执行时间和RAM消耗的。</p><p id="ac24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测量执行时间和峰值内存，我使用了:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lf"><img src="../Images/6720af929fcc36fa5770c9b9397787e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*Y4-7IcN8susdWNK-OTuf7g.png"/></div></figure><p id="0748" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我使用<code class="du lg lh li lj b">timeout</code>命令来限制执行时间，因为有时处理可能需要几个小时:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lk"><img src="../Images/54e007504c5ff0b6d1b33aafc5078ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*okcg9k-fZx7OXHntpUH8UQ.png"/></div></figure><p id="b9a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在加载数据之前清除文件系统缓存，我使用:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ll"><img src="../Images/55e98a473dbf7bab93ae3e84f0a3810c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*AJXPDyRP6gK13I9mEJPfRw.png"/></div></figure><p id="0cb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载数据后，我用<code class="du lg lh li lj b">memory_profiler</code>测量当前的内存消耗:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lk"><img src="../Images/1c808b1e48ad0810348a3d6167163b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*q3nHH2N9W9K5UnjQm-ebSw.png"/></div></figure><p id="d071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我计算指数移动平均值时，我使用<code class="du lg lh li lj b">time</code>模块来测量执行时间，并且我排除了加载时间:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lm"><img src="../Images/cdacc04a67edbbc01e91789234539547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*M0kVY6hrKB5tJ4d8mQfvkg.png"/></div></figure><p id="f61c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用一个简单的<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e00_generate_test_data.py" rel="noopener ugc nofollow" target="_blank">脚本</a>生成2000个时间序列的数据。这些系列的大小约为0.5 GB。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ln"><img src="../Images/ee11f79706a1b258296ed50669061b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*KhVbzM3hehf5GRkQc_UVyA.png"/></div></figure><h1 id="7a90" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">加载数据</h1><p id="4467" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">首先，我们加载数据。在尝试了不同的方法之后，我将向您展示如何重新组织数据，并显著减少执行时间和RAM消耗。</p><h2 id="3926" class="lo jg hi bd jh lp lq lr jl ls lt lu jp iq lv lw jt iu lx ly jx iy lz ma kb mb bi translated"><strong class="ak">加载纯Python (csv) </strong></h2><p id="db07" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">使用<strong class="ih hj">纯Python </strong>加载数据可以使用下面的<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e01_load_pure_python.py" rel="noopener ugc nofollow" target="_blank">代码</a>来完成:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mc"><img src="../Images/4c1b6111824b0a1cd011c68d29cb5424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*ImEc6PX0XAc5aj7FlJIOTQ.png"/></div></figure><p id="c9e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种实现是非常低效的。执行时间为<strong class="ih hj"> 1 m 38 s </strong>，消耗内存约为<strong class="ih hj"> 4 GB </strong>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lf"><img src="../Images/55420883811c56fb7dbe17c09121d85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*dhgwD6rYdPRkNpY3WYWV_g.png"/></div></figure><h2 id="8e4d" class="lo jg hi bd jh lp lq lr jl ls lt lu jp iq lv lw jt iu lx ly jx iy lz ma kb mb bi translated"><strong class="ak">装载熊猫(csv) </strong></h2><p id="8f0a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">让我们使用<a class="ae je" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">熊猫</strong> </a>作为代码，可以从这里<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e02_load_pandas.py" rel="noopener ugc nofollow" target="_blank">下载</a>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lm"><img src="../Images/0f998c2ca649d8a44e1d8fe9888e1265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*H6vpPRlMmBa5t9z88_fgvQ.png"/></div></figure><p id="c577" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行时间为<strong class="ih hj"> 12 s </strong>，消耗内存约为<strong class="ih hj"> 1.4 GB </strong>。这是一个巨大的进步，但我们可以做得更好。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es md"><img src="../Images/3f01437bc250514ec370a363b984fe6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*lDkgS0o8uWqlj-TAcwMjrg.png"/></div></figure><p id="4b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">熊猫比纯Python消耗内存少很多。原因是pandas内部使用了基于C数组的<a class="ae je" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">【numpy】</strong></a>数组。后者对于存储数字非常有效(比python列表好得多)。然而，请注意，RAM 中的数据仍然比硬盘上的数据大大约3倍，因为pandas为每个文件创建了单独的索引。可以重新组织数据以减少文件数量。</p><h2 id="a3ca" class="lo jg hi bd jh lp lq lr jl ls lt lu jp iq lv lw jt iu lx ly jx iy lz ma kb mb bi translated"><strong class="ak">加载熊猫(csv，大文件)</strong></h2><p id="5a87" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">由于每个文件包含相同的列，我们可以加载所有数据，并通过使用这个<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e03_group_by_column.py" rel="noopener ugc nofollow" target="_blank">文件</a>对列进行分组，以重新组织的形式保存它们:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es me"><img src="../Images/b16936a2a54b554c9238785cfd16e45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*hM8c-R1U5xv_vfxaZJAmtA.png"/></div></figure><p id="ba6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新文件可以很容易地<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e04_load_pandas_7.py" rel="noopener ugc nofollow" target="_blank">加载</a>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es md"><img src="../Images/b81fc9571794deca00c3dbc85ff4a809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*vIGqmJyJoSmRZ3cudXLwHw.png"/></div></figure><p id="44f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行时间现在是<strong class="ih hj"> 8 s </strong>，消耗的内存大约是<strong class="ih hj"> 0.72 GB </strong>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mf"><img src="../Images/7455ce81bf98f43c8a020cd126a02644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*cd-oVbcIQ7Wo_F3abdLs1Q.png"/></div></figure><p id="bf69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过从CSV(文本格式)切换到任何其他<strong class="ih hj">二进制</strong>格式(netcdf或pickle ),可以显著提高性能。</p><h2 id="bd44" class="lo jg hi bd jh lp lq lr jl ls lt lu jp iq lv lw jt iu lx ly jx iy lz ma kb mb bi translated"><strong class="ak">加载xarray (netcdf，pickle) </strong></h2><p id="842c" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">熊猫在二维下工作最佳。我们使用<strong class="ih hj"/><a class="ae je" href="https://docs.xarray.dev/en/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">xarray</strong></a>，因为它本身可以处理任意维度，并将所有数据合并到一个文件中。xarray支持<strong class="ih hj"> netcdf </strong>二进制文件格式(自带scipy)。我们还测试了<strong class="ih hj"> pickle </strong>文件格式。</p><p id="f8fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e05_convert_to_nc_and_pickle.py" rel="noopener ugc nofollow" target="_blank">脚本</a>将所有数据连接到一个文件，并保存到netcdf和pickle:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mg"><img src="../Images/95b5073664eb3fd2c8863b05531c69a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*WM80xeVfiB0ozuMS6dg2Sg.png"/></div></figure><p id="9e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们可以用<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e06_load_xr_nc.py" rel="noopener ugc nofollow" target="_blank"> netcdf </a>加载数据:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mh"><img src="../Images/3f671ccfbdc5437c849480f86f7e1475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*aMOwqqc3n_0fifRgUjLb0Q.png"/></div></figure><p id="905c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有<a class="ae je" href="https://github.com/dgolovin-dev/article-processing-big-numeric-arrays-in-python/blob/master/src/e07_load_xr_pickle.py" rel="noopener ugc nofollow" target="_blank">泡菜</a>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mh"><img src="../Images/32bb7573fb03d2eb27ffb7bc4db05375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*74nNXHzr8HZod_hNTdO2ow.png"/></div></figure><p id="d841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是相似的。netcdf的执行时间为<strong class="ih hj"> 1.7秒</strong>，最终RAM为<strong class="ih hj"> 0.65 GB </strong>，峰值RAM为<strong class="ih hj"> 1.2 GB </strong>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lf"><img src="../Images/210c21fd56cef132d8b7dacaff6f52b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*HWmrMMG1CTV2DdmRKePqfg.png"/></div></figure><p id="aba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用pickle执行时间为<strong class="ih hj"> 1.3 s </strong>，最终RAM为<strong class="ih hj"> 0.65 GB </strong>，峰值RAM为<strong class="ih hj"> 1.2 GB </strong>:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lk"><img src="../Images/5518a019aab71fdfa47987e2c8f818bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*yV3t_2iRrzIdJKQPbmLSXg.png"/></div></figure><p id="e949" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在两种情况下，执行时间都小于<strong class="ih hj"> 2 s </strong>。峰值内存比pandas大(使用二进制格式，pandas在计算时间方面也非常高效)。相对于pickle，我更喜欢netcdf，因为根据我的经验，pickle更容易受到其他库的特定版本的影响。</p><p id="6b60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你学到新东西了吗？请随时在<a class="ae je" href="https://quantiacs.com/community/" rel="noopener ugc nofollow" target="_blank"> Quantiacs论坛</a>发表评论！不要错过第二部分，我会告诉你如何有效地实现指数移动平均线。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Assigning Pods to Nodes | Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将窗格分配给节点| Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/assigning-pods-to-nodes-kubernetes-aa6d22af6165?source=collection_archive---------4-----------------------#2022-10-18">https://medium.com/geekculture/assigning-pods-to-nodes-kubernetes-aa6d22af6165?source=collection_archive---------4-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c62d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入探讨节点选择器、节点亲缘性和节点名</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3f8202ed8bc9d748f6964be3d660b3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wCadrDJY5HtRZ0gv"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@qwitka?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maksym Kaharlytskyi</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6158" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<strong class="jq hj"> Kubernetes </strong>中，由Kube-scheduler在节点上调度pod。Kubernetes调度程序是一个控制平面进程，它将pod分配给节点。根据设置的约束和可用资源，确定每个pod的有效位置。然而，可能有这样的情况，我们有一个pod需要GPU按照我们的预期工作。在这种情况下，我们可能需要控制pod的调度，以将pod分配给具有可用GPU的节点。</p><p id="c000" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有几种方法可以控制调度，推荐的方法是使用<strong class="jq hj">标签选择器</strong>来帮助选择。</p><p id="bc48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了更进一步，让我们看看如何向节点添加标签并查看节点的标签:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="31c8" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">kubectl label nodes &lt;NODE-NAME&gt; &lt;KEY&gt;=&lt;VALUE&gt;<br/></strong>&gt;&gt; kubectl label nodes node01 <strong class="kl hj">gpu=yes</strong></span><span id="7606" class="kp kq hi kl b fi kv ks l kt ku"># View the labels of all nodes<br/>&gt;&gt; kubectl get nodes --show-labels</span><span id="a2fc" class="kp kq hi kl b fi kv ks l kt ku"># View the labels of a particular node<br/>&gt;&gt; kubectl get nodes <strong class="kl hj">node01 </strong>--show-labels | awk '{print $6}'</span><span id="8d03" class="kp kq hi kl b fi kv ks l kt ku">--------------------------------------------------------------------<br/>LABELS<br/>beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,<strong class="kl hj">gpu=yes</strong>,kubernetes.io/arch=amd64,kubernetes.io/hostname=node01,kubernetes.io/os=linux</span></pre><p id="ba8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">移除标签:</strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="d61b" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">kubectl label node &lt;NODE-NAME&gt; &lt;LABEL&gt;-</strong><br/>&gt;&gt; kubectl label node node01  gpu-</span></pre><h2 id="c4bf" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">节点选择器</h2><p id="8760" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated"><code class="du lu lv lw kl b">nodeSelector</code>是向节点分配窗格的最简单方法。我们可以将<code class="du lu lv lw kl b">nodeSelector</code>字段添加到Pod规范中，并指定我们假设目标节点具有的<strong class="jq hj">节点标签</strong>。Kubernetes只将Pod调度到具有我们在Pod规范中指定的每个标签的节点上。如果没有指定标签的可用节点，则pod将处于挂起状态。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="8be6" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  containers:<br/>  - name: nginx<br/>    image: nginx<br/><strong class="kl hj">  nodeSelector:<br/>    gpu: "yes"</strong></span></pre><h2 id="a652" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">演练-1</h2><p id="7728" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">让我们在pod定义文件中指定一个在节点标签中不可用的标签。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="15d6" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nginx-pod<br/>spec:<br/>  containers:<br/>  - name: nginx<br/>    image: nginx<br/><strong class="kl hj">  nodeSelector:<br/>    ssd: "yes"</strong></span></pre><p id="c95c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用上述清单创建pod，并观察pod状态:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="e17c" class="kp kq hi kl b fi kr ks l kt ku"># Create the pod<br/>&gt;&gt; kubectl create -f nginx-pod.yaml</span><span id="4bdb" class="kp kq hi kl b fi kv ks l kt ku"># Inspect the pod events<br/>&gt;&gt; kubectl describe pod nginx-pod  | grep -A5 Events</span><span id="feb0" class="kp kq hi kl b fi kv ks l kt ku">--------------------------------------------------------------------<br/>Events:<br/>  Type     Reason            Age    From               Message<br/>  ----     ------            ----   ----               -------<br/>  Warning  FailedScheduling  12m    default-scheduler  0/2 nodes are available: <strong class="kl hj">2 node(s) didn't match Pod's node affinity/selector. </strong>preemption: 0/2 nodes are available: 2 Preemption is not helpful for scheduling.</span></pre><p id="5ccc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的演示中，我们可以看到由于<strong class="jq hj">标签不匹配</strong>，nginx-pod处于<strong class="jq hj">挂起状态</strong>。因此，在pod定义文件中指定标签时，我们必须格外小心。</p><h2 id="d30b" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">nodeAffinity</h2><p id="7a03" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated"><strong class="jq hj">节点关联</strong>的功能类似于<code class="du lu lv lw kl b"><strong class="jq hj">nodeSelector</strong></code> <strong class="jq hj"> </strong>字段，但更具表现力，允许我们指定软规则。正如我们在前面的阶段中看到的，如果没有指定标签的可用节点，那么pod将处于<strong class="jq hj">挂起状态</strong>。使用<strong class="jq hj">节点关联</strong>规则，我们可以克服这个问题。因为<strong class="jq hj">节点关联</strong>支持软/首选规则。以便调度程序仍然调度Pod，即使它找不到匹配的节点。</p><p id="4e30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">节点亲和类型:</strong></p><blockquote class="lx ly lz"><p id="4eae" class="jo jp ma jq b jr js ij jt ju jv im jw mb jy jz ka mc kc kd ke md kg kh ki kj hb bi translated"><code class="du lu lv lw kl b"><strong class="jq hj"><em class="hi">requiredDuringSchedulingIgnoredDuringExecution</em></strong></code> <strong class="jq hj"> <em class="hi"> : </em> </strong>调度程序无法调度Pod，除非满足规则。</p><p id="55ca" class="jo jp ma jq b jr js ij jt ju jv im jw mb jy jz ka mc kc kd ke md kg kh ki kj hb bi translated"><code class="du lu lv lw kl b"><strong class="jq hj"><em class="hi">preferredDuringSchedulingIgnoredDuringExecution</em></strong></code> <strong class="jq hj"> <em class="hi"> : </em> </strong>调度器试图找到符合规则的节点。如果没有匹配的节点，调度程序仍会调度Pod。</p></blockquote><p id="5abf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">两个<strong class="jq hj">节点亲和</strong>类型之间的常用短语是<br/> <code class="du lu lv lw kl b"><strong class="jq hj">IgnoredDuringExecution</strong></code> <em class="ma"> — </em>它的意思是将一个pod调度成一个节点后。如果确定节点选择的标签被删除。分离舱将照常运行。pod不会受到影响。</p><p id="4448" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">节点关联</strong>的另一大优势是<strong class="jq hj"> </strong>，我们可以用<strong class="jq hj">操作符</strong>指定一个值列表。假设我们有三种类型的节点可用，每种类型都标记为<code class="du lu lv lw kl b"><strong class="jq hj">size: large</strong></code> <strong class="jq hj">、</strong> <code class="du lu lv lw kl b"><strong class="jq hj">size: medium</strong></code> <strong class="jq hj">、</strong>和<code class="du lu lv lw kl b"><strong class="jq hj">size: small</strong></code>。我们希望将pod分配在大型或中型节点上。在这种情况下，如果我们使用<code class="du lu lv lw kl b"><strong class="jq hj">nodeSelector</strong></code>，我们将能够一次指定一个标签<code class="du lu lv lw kl b"><strong class="jq hj">size: large</strong></code>或<code class="du lu lv lw kl b"><strong class="jq hj">size: medium</strong></code>。但是如果我们使用节点关联，我们将能够将<code class="du lu lv lw kl b"><strong class="jq hj">large</strong></code>和<code class="du lu lv lw kl b"><strong class="jq hj">medium</strong></code>指定为一个值列表。然后，pod将被调度到标记为<code class="du lu lv lw kl b"><strong class="jq hj">large</strong></code>的节点或标记为<code class="du lu lv lw kl b"><strong class="jq hj">medium</strong></code>的节点上。</p><h2 id="0e24" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">requiredduringschedulingignoredduringeexecution</h2><p id="1207" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">让我们使用清单中指定的节点关联性规则创建一个部署:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="bd5c" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: webserver<br/>  name: webserver<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: webserver<br/>  template:<br/>    metadata:<br/>      creationTimestamp: null<br/>      labels:<br/>        app: webserver<br/>    spec:<br/><strong class="kl hj">       affinity:<br/>         nodeAffinity:<br/>           requiredDuringSchedulingIgnoredDuringExecution:<br/>             nodeSelectorTerms:<br/>             - matchExpressions:<br/>               - key: size<br/>                 operator: In<br/>                 values:<br/>                 - large<br/>                 - medium<br/>       </strong>containers:<br/>        - image: nginx<br/>          name: webserver</span></pre><p id="36d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以使用<code class="du lu lv lw kl b">operator</code>字段为Kubernetes指定一个逻辑操作符，以便在诊断规则时使用。可以用<code class="du lu lv lw kl b">In</code>、<code class="du lu lv lw kl b">NotIn</code>、<code class="du lu lv lw kl b">Exists</code>、<code class="du lu lv lw kl b">DoesNotExist</code>、<code class="du lu lv lw kl b">Gt</code>、<code class="du lu lv lw kl b">Lt</code>。</p><blockquote class="lx ly lz"><p id="8023" class="jo jp ma jq b jr js ij jt ju jv im jw mb jy jz ka mc kc kd ke md kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">注:</em> </strong> <em class="hi">使用</em> <code class="du lu lv lw kl b"><em class="hi">NotIn</em></code> <em class="hi">和</em> <code class="du lu lv lw kl b"><em class="hi">DoesNotExist</em></code> <em class="hi">运算符我们可以指定反节点亲和规则。</em></p></blockquote><p id="8399" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<code class="du lu lv lw kl b">Exists</code>操作符创建部署。在<code class="du lu lv lw kl b">Exists</code>的情况下，不需要指定任何值，因为它只会检查密钥的存在。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="fddc" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: webserver<br/>  name: webserver<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: webserver<br/>  template:<br/>    metadata:<br/>      creationTimestamp: null<br/>      labels:<br/>        app: webserver<br/>    spec:<br/><strong class="kl hj">       affinity:<br/>         nodeAffinity:<br/>           requiredDuringSchedulingIgnoredDuringExecution:<br/>             nodeSelectorTerms:<br/>             - matchExpressions:<br/>               - key: Size<br/>                 operator: Exists<br/>       </strong>containers:<br/>        - image: nginx<br/>          name: webserver</span></pre><h2 id="f9b3" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">schedulingignoredduringeexecution期间首选</h2><p id="296c" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">在<code class="du lu lv lw kl b">preferredDuringSchedulingIgnoredDuringExecution</code> <em class="ma"> </em>规则中，我们可以为每个实例指定1到100之间的<em class="ma"> </em> <code class="du lu lv lw kl b">weight</code>。如果多个节点满足要求，调度器会将该表达式的<code class="du lu lv lw kl b">weight</code>值相加。具有最高总数的节点被赋予优先级，并且pod被调度到具有最高优先级的节点中。</p><p id="4358" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们有两个节点，一个带有<code class="du lu lv lw kl b">size: large</code>标签，另一个带有<code class="du lu lv lw kl b">size: medium</code>标签。并且两个节点都符合要求。在这种情况下，调度程序将考虑每个节点的<code class="du lu lv lw kl b">weight</code>，并将权重添加到该节点的其他得分中，并将Pod调度到最终得分最高的节点上。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="7f8f" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: webserver<br/>spec:<br/>  affinity:<br/>    nodeAffinity:<br/>      preferredDuringSchedulingIgnoredDuringExecution:<br/>       <strong class="kl hj"> - weight: 15</strong><br/>          preference:<br/>            matchExpressions:<br/>            - key: size<br/>              operator: In<br/>              values:<br/>              - large<br/>       <strong class="kl hj"> - weight: 20</strong><br/>          preference:<br/>            matchExpressions:<br/>            - key: size<br/>              operator: In<br/>              values:<br/>              - medium<br/>  containers:<br/>  - name: webserver<br/>    image: nginx</span></pre><h2 id="476a" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">演练2</h2><p id="9953" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">部署具有<code class="du lu lv lw kl b">preferredDuringSchedulingIgnoredDuringExecution</code>类型的<strong class="jq hj">节点关联</strong>的pod。和add指定节点中不可用作标签的值列表。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="16fc" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj"># webserver-pod.yaml</strong></span><span id="e655" class="kp kq hi kl b fi kv ks l kt ku">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: webserver<br/>spec:<br/>  affinity:<br/>    nodeAffinity:<br/>      preferredDuringSchedulingIgnoredDuringExecution:<br/><strong class="kl hj">        - weight: 15</strong><br/>          preference:<br/>            matchExpressions:<br/>            - key: key<br/>              operator: In<br/><strong class="kl hj">              values:<br/>              - bar<br/>              - foo</strong><br/><strong class="kl hj">        - weight: 20</strong><br/>          preference:<br/>            matchExpressions:<br/>            - key: key<br/>              operator: In<br/><strong class="kl hj">              values:<br/>              - foo<br/>              - bar</strong><br/>  containers:<br/>  - name: webserver<br/>    image: nginx</span></pre><p id="3629" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，展开吊舱并观察状态:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="5e65" class="kp kq hi kl b fi kr ks l kt ku">&gt;&gt; kubectl create -f webserver-pod.yaml<br/>&gt;&gt; kubectl get pods webserver</span><span id="705a" class="kp kq hi kl b fi kv ks l kt ku">--------------------------------------------------------------------<br/>NAME        READY   STATUS    RESTARTS   AGE<br/>webserver   1/1    <strong class="kl hj"> Running</strong>   0          4m4s</span></pre><p id="497f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与<a class="ae jn" href="#a652" rel="noopener ugc nofollow">节点选择器</a>不同的是，虽然没有匹配的标签可用，但仍然会将pod调度到节点中。因为我们使用了<code class="du lu lv lw kl b">preferredDuringSchedulingIgnoredDuringExecution</code>类型的<strong class="jq hj">节点关联</strong>。</p><h2 id="75f0" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">节点名</h2><p id="6dfb" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated"><code class="du lu lv lw kl b">nodeName</code>是将pod调度到所需节点的最直接方式。<code class="du lu lv lw kl b">nodeName</code>是Pod规范中的一个字段。如果在Pod规范中指定了<code class="du lu lv lw kl b">nodeName</code>字段，调度程序将忽略Pod，所需节点上的kubelet将尝试将Pod放置在该节点上。</p><p id="0957" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lu lv lw kl b">nodeName</code>有一些缺点:</p><p id="e09d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">●如果所需的节点不存在，Pod将不会运行。<br/> ●如果目标节点没有容纳Pod的资源，Pod将无法运行。<br/> ●云环境中的节点名称并不总是可预测或稳定的。</p><p id="bb03" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是使用<code class="du lu lv lw kl b">nodeName</code>字段的pod清单:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="6971" class="kp kq hi kl b fi kr ks l kt ku">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  containers:<br/>  - name: nginx<br/>    image: nginx<br/><strong class="kl hj">  nodeName: node01</strong></span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><blockquote class="lx ly lz"><p id="53d6" class="jo jp ma jq b jr js ij jt ju jv im jw mb jy jz ka mc kc kd ke md kg kh ki kj hb bi translated"><em class="hi">如果你觉得这篇文章很有帮助，请</em> <strong class="jq hj"> <em class="hi">别忘了</em> </strong> <em class="hi">点击</em> <strong class="jq hj"> <em class="hi">拍拍</em> </strong> <em class="hi">和</em> <strong class="jq hj"> <em class="hi">跟着</em> </strong> <em class="hi">按钮帮我写更多这样的文章。<br/>谢谢🖤 </em></p></blockquote></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h2 id="fb5d" class="kp kq hi bd kw kx ky kz la lb lc ld le jx lf lg lh kb li lj lk kf ll lm ln lo bi translated">参考</h2><div class="ml mm ez fb mn mo"><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">将窗格分配给节点</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">您可以约束一个Pod，使其被限制在特定的节点上运行，或者更喜欢在特定的节点上运行…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">kubernetes.io</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jh mo"/></div></div></a></div></div></div>    
</body>
</html>
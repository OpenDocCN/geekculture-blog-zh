<html>
<head>
<title>A Brief overview of the Sidecar Container Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">边车集装箱模式概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/a-brief-overview-of-the-sidecar-container-pattern-d6fbe49c5309?source=collection_archive---------3-----------------------#2022-10-25">https://medium.com/geekculture/a-brief-overview-of-the-sidecar-container-pattern-d6fbe49c5309?source=collection_archive---------3-----------------------#2022-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="65ca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">边车集装箱的工作原理、优缺点</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/030f2277b643c8670eba25811634cade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S8UkrXVtLxbm864r"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@dbeamer_jpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Drew Beamer</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="398a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="570a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在过去的十年里，科技公司广泛采用了微服务架构。这种采用极大地提高了服务的可用性和可靠性。容器化进一步加快了开发过程，减轻了开发人员的操作负担。</p><p id="39bb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">构建分布式系统是一项具有挑战性的任务。开发人员已经确定了在构建这些系统时会重复出现的一系列标准问题。这导致了可重用和模块化架构模式的出现。这些模式类似于面向对象编程中的设计模式。</p><p id="86db" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">架构模式帮助我们避免在开发过程中重新发明轮子。这些实践作为抽象，可以被任何服务重用。</p><p id="50b8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在本文中，我们将了解一种被称为Sidecar的架构模式。我们将理解这种模式试图解决的问题。稍后，我们将探索这种模式的工作和权衡。</p><h1 id="0d63" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">问题</h1><p id="fd86" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在我之前的一家公司，架构构成了一组使用<code class="du lh li lj lk b">HTTP</code>进行通信的遗留服务。公司目睹了一次安全事故&amp;公司发布了采用<code class="du lh li lj lk b">HTTPS</code>的指令。</p><p id="ca8e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">乍一看，我们觉得这个问题很简单。一个简单的解决方案是实现一个模块来执行SSL握手，然后将其集成到服务中。因此，在给相关的利益相关者时间表之前，我们从我们的初步分析开始。</p><p id="f902" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在分析过程中，我们发现问题没那么简单。以下是增加问题复杂性的原因</p><ol class=""><li id="087b" class="ll lm hi ki b kj lc km ld kp ln kt lo kx lp lb lq lr ls lt bi translated"><em class="lu">遗留基础架构</em> —代码是使用旧的遗留基础架构构建的。遗留服务是两年前构建的，最近没有提交。</li><li id="31c3" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb lq lr ls lt bi translated"><em class="lu">测试</em>——由于一个新的模块被引入，我们必须对服务进行彻底的测试。该项目也缺乏足够的测试覆盖率。</li><li id="764f" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb lq lr ls lt bi translated">编程语言——一个服务用C++实现，另一个用Ruby实现。因此，我们必须用两种不同的语言实现同一个模块。</li></ol><p id="c661" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们的结论是，在所有遗留服务中发布该特性的时间将超过一个月。我们希望快速发布该特性，而不是陷入处理遗留服务的复杂性。</p><p id="a61e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">因此，开发人员和架构师决定召开一次电话会议，集思广益，找出可能的解决方案。在探索不同的可能性时，一位建筑师想出了一个优雅而简单的解决方案。</p><h1 id="6846" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">解决办法</h1><p id="3b62" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">解决方案是利用现有的<code class="du lh li lj lk b">nginx</code>反向代理进行<code class="du lh li lj lk b">SSL</code>握手。<code class="du lh li lj lk b">nginx</code>将被部署为一个容器，它将拦截所有的<code class="du lh li lj lk b">https</code>请求。<code class="du lh li lj lk b">nginx</code>容器将与web服务器运行在同一台机器上。</p><p id="e3ca" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">web服务器将只侦听来自本地主机的请求。这将确保除了<code class="du lh li lj lk b">nginx</code>之外，没有其他机器可以向这个web服务器发送请求。下图说明了设置:-</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/c91fe7aeb4ff16156e131af84732ef87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1omauuoFYDeeNfw9ghsGg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jq">NGINX handling SSL termination</strong></figcaption></figure><p id="3b35" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">NGINX将终止SSL流量。此外，它会将未加密的流量发送到遗留应用程序。</p><p id="9eae" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">使用上述方法，我们不再需要修改遗留应用程序。因此，这将为我们节省大量的开发工作。</p><h1 id="94ab" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">边车集装箱</h1><p id="9ee5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">上一节描述的解决方案是边车容器的一个用例。Sidecar容器扩展了现有(主)容器的功能，而现有容器并不知道它。</p><p id="cbd0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">Sidecar容器和主容器运行在同一台机器上。因此，该模式也称为单节点模式。吊舱构成了主集装箱&amp;边车集装箱。主容器处理实际的业务逻辑。边车在不影响主容器性能的情况下执行外围任务。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/af55f8cbb828ae30bda41a2f6cae3bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0cQqjR1zr8NIgc20mYqwg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jq">Sidecar container pattern</strong></figcaption></figure><p id="14a8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">Sidecar与主容器共享大部分资源，如容量、网络、CPU、内存等。这使得该模式能够解决大量常见问题，如日志记录、监控、安全性等。</p><h2 id="9538" class="mc jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">类似</h2><p id="2780" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">摩托车的边车装在车辆的侧面。边车只有一个轮子，它增加了一个额外的座位来运载乘客或货物。边车不携带引擎，主车去哪它就去哪。</p><p id="4fa7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">您可以将主容器视为主要工具。主容器拥有业务逻辑(引擎)并做出适当的决策(控制速度和方向)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/d1e055c1e70750049b76dd3f53e7788c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GQcmRWdMzvWLFCjdvZ8Aw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Analogy with vehicle sidecar</figcaption></figure><p id="99d4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">Sidecar容器只是添加了一个额外的功能，比如SSL终止或读取主容器的日志(类似于为乘客或货物添加座位)。就其本身而言，边车是没有用的。</p><h1 id="f44b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">边车集装箱的常见使用案例</h1><h2 id="8aa8" class="mc jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">记录</h2><p id="ab48" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">日志记录在云原生应用程序中的调试和故障排除问题中起着关键作用。大多数分布式应用程序都有单独的日志管道。管道负责收集日志、处理日志并将其存储在数据源中。这是借助消息队列或直接将日志上传到blob存储(S3)来实现的。</p><p id="9a4e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">让我们考虑一个电子商务中的订单管理系统(OMS)。如果我们想要收集这个服务的日志，我们可以运行一个日志代理作为sidecar。OMS会将数据记录到文件系统中。日志代理将定期从文件系统读取数据，并将数据上传到blob存储。下图解释了日志代理的工作原理。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/f246943243b5d5db1dae8324b176cdf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBCYj3lac_SRQytM4SvwCw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jq">Logging Agent as a sidecar container</strong></figcaption></figure><p id="9bfb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">与日志记录相比，OMS业务逻辑是一项关键任务。如果我们有几分钟收不到日志也没关系。但是我们不能容忍顾客无法在网站上购物。因此，记录功能可以卸载到边车容器。</p><p id="2e4d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">Sidecar容器只知道如何读取日志文件和管理数据上传。日志记录功能已经从主容器中分离出来。</p><h2 id="3768" class="mc jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">结构管理</h2><p id="fd23" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">许多服务使用配置文件来读取属性。有时，我们需要改变某些属性，比如<code class="du lh li lj lk b">connectionPoolSize</code>或<code class="du lh li lj lk b">databaseUrl</code>。一个简单的方法是登录到服务器，更改属性并重新启动服务。</p><p id="c147" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于大量的服务器，上述任务变得非常耗时。因此，有一个集中的配置系统，它公开API来添加/修改属性。此外，为了自动重启服务，可以添加一个侧卡。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/2f604f99f737c38f716ced77acbc940e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6DRQ69h1uovj9WXQQkN_w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jq">Sidecar for configuration management</strong></figcaption></figure><p id="e19a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这个sidecar的工作是同步来自集中式服务的属性，并将其与现有属性进行比较。如果有任何差异，它会停止服务并启动它。然后，该服务读取更新的属性并重新启动。</p><p id="0040" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在上面的例子中，我们不需要在主容器中实现同步配置的逻辑。此外，我们也可以在其他微服务中使用<strong class="ki hj">配置管理器Sidecar </strong>。</p><h2 id="e135" class="mc jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">其他使用案例</h2><p id="f4a5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Sidecar容器模式可用于其他用例，如身份验证、连续部署、监控等。外围逻辑可以作为独立模块封装在边车中。</p><h1 id="a13d" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">优势</h1><ul class=""><li id="0bea" class="ll lm hi ki b kj kk km kn kp mt kt mu kx mv lb mw lr ls lt bi translated"><strong class="ki hj"> <em class="lu">可重用性</em> </strong> — Sidecars可以一次实现，在任何地方重用。主容器可以用任何选择的语言编写。我们不必每次开发新的应用程序时都重写sidecar逻辑</li><li id="6c77" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb mw lr ls lt bi translated"><strong class="ki hj"> <em class="lu">解耦</em> </strong> — Sidecar实现了关注点的分离。主容器只需要关注业务逻辑。边车和主集装箱可以独立部署。主容器不会成为单点故障。</li><li id="b7c2" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb mw lr ls lt bi translated"><strong class="ki hj"> <em class="lu">模块化</em> </strong> —外围功能可以开发成独立的边车模块。这个模块只做一件事，而且做得很好。这类似于编写一个像<code class="du lh li lj lk b">Gson</code>一样的可重用库，并在任何地方使用它。</li></ul><h1 id="ff90" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">不足之处</h1><ul class=""><li id="40a0" class="ll lm hi ki b kj kk km kn kp mt kt mu kx mv lb mw lr ls lt bi translated"><strong class="ki hj"> <em class="lu">延迟</em> </strong> —边车集装箱驻留在主集装箱的机器上。因此，延迟不会受到太大影响。然而，如果延迟是主要问题，抖动是不能容忍的，那么Sidecar不应该使用。例如:-在像高频交易这样的低延迟应用中使用Sidecar是没有意义的。</li><li id="cd42" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb mw lr ls lt bi translated"><strong class="ki hj"> <em class="lu">成本</em></strong>——如果应用程序是轻量级的和简单的，那么sidecar可能是多余的。边车需要额外的费用。使用边车的好处应该大于成本。在这种情况下，最好使用库来获得额外的功能。</li></ul><h1 id="e006" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="b60c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在本文中，我们了解了边车集装箱模式的工作原理。该模式也称为分解模式。</p><p id="4239" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">它通常用于抽象常见的功能，如日志记录、监控、SSL终止等。sidecar实现了上述功能，并且经常在用多种语言和框架编写服务时使用。</p><p id="7751" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">可重用性、模块化和解耦是该模式提供的主要优势。它避免了代码重复并促进了代码重用。该模式不能应用于简单的轻量级服务。</p><h1 id="519f" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">参考</h1><ol class=""><li id="6509" class="ll lm hi ki b kj kk km kn kp mt kt mu kx mv lb lq lr ls lt bi translated"><a class="ae jn" href="https://blog.bitsrc.io/handling-cross-cutting-concerns-in-microservices-the-sidecar-pattern-59890fe3dc0f" rel="noopener ugc nofollow" target="_blank">处理微服务中的交叉切角</a></li><li id="527d" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb lq lr ls lt bi translated"><a class="ae jn" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">图像</a></li><li id="d92c" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb lq lr ls lt bi translated"><a class="ae jn" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar" rel="noopener ugc nofollow" target="_blank">蔚蓝建筑中心——边车模式</a></li><li id="e155" class="ll lm hi ki b kj lv km lw kp lx kt ly kx lz lb lq lr ls lt bi translated"><a class="ae jn" href="https://learning.oreilly.com/library/view/designing-distributed-systems/9781491983638/ch02.html" rel="noopener ugc nofollow" target="_blank">设计分布式系统——边车模式</a></li></ol></div></div>    
</body>
</html>
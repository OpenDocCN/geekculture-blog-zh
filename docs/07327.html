<html>
<head>
<title>Hey Human, Fetch!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘿人类，去捡回来！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hey-human-fetch-9da171e62fd6?source=collection_archive---------34-----------------------#2021-09-14">https://medium.com/geekculture/hey-human-fetch-9da171e62fd6?source=collection_archive---------34-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4f20" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用CRUD和fetch &amp; JavaScript的指南</h2></div><p id="d7ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个狗主人，我教我的狗的第一件事就是如何成功地去捡一个网球。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ju"><img src="../Images/5b2a6499221a216ae8fe940f1a3e869e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Koos1hLPd0QIVsBTJmhIfQ.gif"/></div></figure><p id="4be3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于我们这些开发者来说，<em class="jt"> fetch </em>的含义略有不同。在编程中，fetch API被用作在发出请求后获取资源的一种手段。为了使用fetch()，我们传入第一个<em class="jt"> </em>参数，一个指向我们想要的数据的URL，类似于我的狗嘴里的球。</p><h1 id="1df8" class="kc kd hi bd ke kf kg kh ki kj kk kl km io kn ip ko ir kp is kq iu kr iv ks kt bi translated">接下来会发生什么？</h1><p id="ec72" class="pw-post-body-paragraph ix iy hi iz b ja ku ij jc jd kv im jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">发出请求后，fetch响应返回一个Promise对象。这基本上是一个来自异步方法的借据，<em class="jt">承诺</em>某个值要么在未来某个时间成功实现，要么被错误拒绝。发生这种情况时。然后调用()方法，获取响应并将其转换成JSON，以匹配正在使用的数据。现在，这个返回什么？如果你猜对了另一个承诺，你答对了！</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/13a8ee3571f59d7480e32bd5dc825a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-UZie-Lbiq-20rXIH855w.png"/></div></div></figure><p id="7f9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上图所示，另一个。然后()方法需要处理第二个承诺，这可以用来操纵用户认为合适的数据。</p><p id="09a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经讨论了fetch API的逻辑，让我们看看如何使用它来处理HTTP请求。</p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="92e3" class="kc kd hi bd ke kf ll kh ki kj lm kl km io ln ip ko ir lo is kq iu lp iv ks kt bi translated">什么是CRUD？</h1><p id="4a6b" class="pw-post-body-paragraph ix iy hi iz b ja ku ij jc jd kv im jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">CRUD是一个奇特的缩写词，象征着我们可以对数据存储执行的四种类型的操作。</p><p id="c4a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> C </strong> —创建→过账</p><p id="4927" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> R </strong> —读取→获取</p><p id="2d22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> U </strong> —更新→打补丁</p><p id="9c5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> D </strong> —删除→删除</p><p id="7ee5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，默认情况下，如果给定第一个必需的参数，即URL，fetch()将发出GET请求。对于其他三种类型的请求，需要第二个参数:一个控制几种设置类型的配置对象。</p><p id="3d78" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在接下来的例子中，我将从我在Flatiron的演讲中演示如何使用所有四个请求来创建和操作Pokédex web应用程序。</p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><blockquote class="lq lr ls"><p id="1a29" class="ix iy jt iz b ja jb ij jc jd je im jf lt jh ji jj lu jl jm jn lv jp jq jr js hb bi translated"><strong class="iz hj"> 1。</strong> <strong class="iz hj">搞定</strong></p></blockquote><p id="8d35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一步是<em class="jt">获取</em>项目所需的数据。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lw"><img src="../Images/c843f24eef3d74a8789389b4987927e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AC28Gwrj16ECYfUna2JpQA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">GET request</figcaption></figure><p id="0cd1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个函数<em class="jt"> getPokemons </em>中，我们首先使用fetch来获取包含关于Pokemon角色的所有信息的URL。下一个语句是第一个。then()方法处理响应参数，并在响应被转换成JSON供我们使用后返回响应。接下来，我们链另一个。then()方法将收集的数据传递到一个函数中，该函数遍历每个元素，并分别将其传递给在页面上创建物理Pokemon卡的<em class="jt"> renderPokemon </em>回调函数。当我们刷新我们的html时，我们将得到如下所示的内容:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/52567049858b3c9893fe0196c1d66c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9BBp4uw5ZVEay7H8nsBPA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Webpage after Pokemon cards are rendered</figcaption></figure></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><blockquote class="lq lr ls"><p id="9a4a" class="ix iy jt iz b ja jb ij jc jd je im jf lt jh ji jj lu jl jm jn lv jp jq jr js hb bi translated"><strong class="iz hj"> 2。帖子</strong></p></blockquote><p id="16ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们试着在我们的牌组中加入更多的牌。在页面顶部，用户可以通过输入所需角色的名称和图像URL来添加口袋妖怪卡片。我们可以通过发起POST请求来实现这一点！</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mc"><img src="../Images/595a1dc163d8308432c0579b05cf2cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NM9fFJTaJ9nR3VQ45K5fKA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">POST request</figcaption></figure><p id="f6ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的<em class="jt"> createPokemons </em>回调函数中，我们写出了在<em class="jt">‘提交’</em>事件之后发生的动作，也就是说，当用户将想要的角色信息输入到HTML表单中时。首先，我们希望防止元素的默认行为，并防止页面在新信息提交后刷新，这样用户就可以在它被添加到DOM后实际看到它停留在页面上。接下来，我们希望从用户那里收集信息，并将这些值保存到变量中，以便创建包含新细节的<em class="jt">口袋妖怪</em>对象。这就是GET请求与其他所有请求不同的地方:在我们的POST请求中，需要第二个参数来指定方法、头和主体，在这里传递的对象被转换为JSON字符串。然后一切照常——获取步骤1中显示的基本URL并链接第二个。then()方法将数据传递给<em class="jt"> renderPokemon </em>函数，并显示在dom上。现在，如果我想添加一张胖丁卡片，我可以输入它的名称和图片网址，然后…</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/c49bca86b7df93127a166ef117c6117d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHUihJWzOD70Odqh8gcJ2w.png"/></div></div></figure></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><blockquote class="lq lr ls"><p id="7788" class="ix iy jt iz b ja jb ij jc jd je im jf lt jh ji jj lu jl jm jn lv jp jq jr js hb bi translated"><strong class="iz hj"> 3。补丁</strong></p></blockquote><p id="bc0f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们希望更新每个角色的赞数，并让这些更改即使在页面刷新时也保持不变。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/919e9e438fd81fe8be739c323d7618b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qO-Bz7fRJURHRMaYSsDatg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">PATCH request</figcaption></figure><p id="c1c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的increaseLikes函数从前面的代码块中获取<em class="jt"> pokemon </em>对象，以及一个变量<em class="jt"> likesNum </em>，该变量表示<em class="jt"> pokemon </em>对象中的原始赞数。接下来，我们再次获取基本URL，但是这次使用字符串插值添加pokemon角色ID的特定端点，这样服务器就知道要修改哪个卡。对于这个对象，我们更新方法以符合补丁请求，并将数据转换成对象格式的JSON字符串，以便JSON文件可以相应地更新。让我们看看给皮卡丘一些爱会发生什么..</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/2bfb379455cdca947ce172b64b5e5972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSaiMM21t02UuvYyodHZVw.png"/></div></div></figure><p id="0038" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">皮卡丘现在有3个赞了！如果我们看一下我们的JSON文件，我们会看到那里的赞数也更新了:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/5bc1cf2489bf4e3e9155c3fe0a5c341b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNUd5P_0nhVqeha6pauR6A.png"/></div></div></figure></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><blockquote class="lq lr ls"><p id="7576" class="ix iy jt iz b ja jb ij jc jd je im jf lt jh ji jj lu jl jm jn lv jp jq jr js hb bi translated"><strong class="iz hj"> 4。删除</strong></p></blockquote><p id="38f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后但同样重要的是，让我们看看如何从我们的网页上完全删除口袋妖怪卡。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mh"><img src="../Images/837b5ccbc25d4b2d14227a2a804fe534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*wpaZWp-hOcaCrZVQQh4LoQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">DELETE request</figcaption></figure><p id="a15d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的<em class="jt"> deletePoke </em>函数像以前一样接受同一个<em class="jt"> pokemon </em>对象和需要删除的卡片，并在卡片上调用<em class="jt"> remove() </em>方法。接下来，我们获取带有ID端点的基本URL，并指定“删除”的方法您可能想知道为什么在这一点之后没有更多的代码，那是因为因为我们从我们的页面中删除了这个元素，没有必要为我们的数据指定细节，因为它现在已经不存在了。让我们看看如果我们现在从网页上删除一张卡片会发生什么…</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mi"><img src="../Images/ce574bcb31a207c0f8ee975c38d4cee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP_7wjCJtWLi7uJAOfDzqg.png"/></div></div></figure><p id="b500" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样，小火龙走了。</p><p id="3b45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐的烹饪！</p></div></div>    
</body>
</html>
<html>
<head>
<title>How Docker BuildKit and GitLab Runner fill up storage in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker BuildKit和GitLab Runner如何填充Kubernetes中的存储空间</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-docker-buildkit-and-gitlab-runner-fill-up-storage-in-kubernetes-fix-it-a839c841bf95?source=collection_archive---------0-----------------------#2022-11-30">https://medium.com/geekculture/how-docker-buildkit-and-gitlab-runner-fill-up-storage-in-kubernetes-fix-it-a839c841bf95?source=collection_archive---------0-----------------------#2022-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cdf7b649e57a8a34938243de23f394a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1NYPPOEuHsV8WEia"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@amir_v_ali?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">amirali mirhashemian</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="iv iw ix"><p id="bbfa" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Docker层就像汉堡的配料。你不想把它弄得太乱，所以总是寻找令人愉快的口味平衡。<br/>你想在你的汉堡中间拉出一种配料吗？<br/>你开始从顶部去掉几层，放下辣椒，然后浪费掉去掉的几层，重新装上汉堡。</p></blockquote><p id="a627" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在简要介绍了如何制作一个好的汉堡包之后，是时候介绍如何在您的笔记本电脑或Kubernetes集群中的worker节点上使用docker和BuildKit builder来填充磁盘了。</p><p id="2cb6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我将解释如何识别和解决问题。<br/>还有一个临时的变通方法，我将深入研究docker源代码，了解docker垃圾收集频率是如何工作的。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/082dda22ecdac3fab286f54a2cca2c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*X6F58KclJ28KAMDm6zwMMQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Worker node disk usage constantly growing</figcaption></figure><p id="5e7c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">免责声明:<br/>然而，docker中的docker会带来安全问题，而你的盒子中有更好的工具，例如Kaniko。</em></p><p id="2f1e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">非常感谢任何掌声、关注或评论！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="b524" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我是否在某处使用了docker BuildKit？</h1><p id="b205" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">要验证是否在启用BuildKit的情况下使用docker，您必须使用:</p><ul class=""><li id="b479" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">Docker ≥ 18.09 <br/> <code class="du ly lz ma mb b">$ docker version</code></li></ul><p id="9267" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">和<em class="ja">以下选项中的至少一个</em>:</p><ul class=""><li id="b25b" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">您配置环境变量<code class="du ly lz ma mb b">DOCKER_BUILDKIT=1</code></li><li id="1a7c" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated">你运行<code class="du ly lz ma mb b"><a class="ae iu" href="https://docs.docker.com/engine/reference/commandline/buildx_build/" rel="noopener ugc nofollow" target="_blank">docker buildx build</a></code>来构建你的docker文件</li><li id="abf2" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated">在守护进程配置<code class="du ly lz ma mb b">/etc/docker/daemon.json</code>中，您已经默认启用了BuildKit</li></ul><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="f639" class="ml kn hi mb b be mm mn l mo mp">{<br/>  "features": {<br/>    "buildkit" : true<br/>  }<br/>}</span></pre><ul class=""><li id="249e" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">运行<code class="du ly lz ma mb b">docker system df</code>并查看最后一排<code class="du ly lz ma mb b">Build Cache</code>并检查尺寸/可回收性</li></ul><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="7c73" class="ml kn hi mb b be mm mn l mo mp">❯ docker system df<br/>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br/>Images          177       3         46.54GB   45.69GB (98%)<br/>Containers      13        0         39.39MB   39.39MB (100%)<br/>Local Volumes   0         0         0B        0B<br/>Build Cache     660       0         177GB     130GB</span></pre><p id="c9b1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">Ref:</em><a class="ae iu" href="https://docs.docker.com/build/buildkit/#getting-started" rel="noopener ugc nofollow" target="_blank"><em class="ja">https://docs.docker.com/build/buildkit/#getting-started</em></a></p><p id="8895" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><code class="du ly lz ma mb b">buildx</code>和<code class="du ly lz ma mb b">BuildKit</code>有什么区别？</p><ul class=""><li id="7a49" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">BuildKit</code>是一种形象塑造引擎</li><li id="3f56" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">buildx</code>是控制发动机的命令。</li></ul><p id="daed" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所以<code class="du ly lz ma mb b">BuildKit</code>是发动机，<code class="du ly lz ma mb b">buildx</code>是方向盘⎈.</p><p id="ea93" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">git lab Runner如何与Kubernetes集群交互？</strong></p><p id="84d3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在下图中，我创建了一个使用Kubernetes执行器的Gitlab Runner的高级图。我故意简化了它，因为我没有详细介绍这一部分，GitLab中有很多文档。<br/><em class="ja">Ref:</em><a class="ae iu" href="https://docs.gitlab.com/runner/#runner-execution-flow" rel="noopener ugc nofollow" target="_blank"><em class="ja">https://docs.gitlab.com/runner/#runner-execution-flow</em></a>。</p><p id="f8d1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">标准步骤是:</p><ol class=""><li id="d67e" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw mq lv lw lx bi translated">Kubernetes Executor作为部署部署在Kubernetes中。</li><li id="191c" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw mq lv lw lx bi translated">executor pod不断询问特定的轮询周期，是否有挂起的作业。</li><li id="ce98" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw mq lv lw lx bi translated">如果有一个未完成的任务，它会根据之前配置的<em class="ja">容错/节点选择器/关联规则来调度一个新的pod。</em></li></ol><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/516500465a3bd0a333d37663e78b3b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*M-qMGPRKZjLHyLM07nFRMA.png"/></div></figure><p id="806c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">假设作业正在运行<code class="du ly lz ma mb b">docker build</code>，并且配置了一个环境变量<code class="du ly lz ma mb b">DOCKER_BUILDKIT=1</code>。您可以在Gitlab Runner中通过在<code class="du ly lz ma mb b">config.toml</code>中配置一个环境变量来启用它，如下所示:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="c6ee" class="ml kn hi mb b be mm mn l mo mp">config.toml<br/>...<br/>     [[runners]]<br/>      name = "Kubernetes Builder"<br/>      executor = "kubernetes"<br/>      environment = ["DOCKER_DRIVER=overlay2","DOCKER_BUILDKIT=1"]<br/>...</span></pre><p id="de36" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有了这个配置，我们将使用新的BuildKit builder。</p><h1 id="ea71" class="km kn hi bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj bi translated">如何验证一个<strong class="ak">工作节点</strong>的磁盘使用情况？</h1><p id="62c8" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">如果不配置特定的策略，Docker垃圾收集会考虑构建缓存的清理。</p><p id="648f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">要确定谁在消耗空间，您必须运行一个pod，在这里使用这个<a class="ae iu" href="http://bit.ly/3iclPhO" rel="noopener ugc nofollow" target="_blank">清单</a>，然后在<code class="du ly lz ma mb b">/host</code>下将挂载worker节点文件系统。<br/>根据磁盘已被填满的程度，您可以尝试以下命令:</p><p id="e5ef" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><code class="du ly lz ma mb b">apk add ncdu</code> → <code class="du ly lz ma mb b">ncdu</code> <em class="ja">(如果你有很多文件/文件夹就不行)</em></p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/23c6bc5b6e654a14025eb83c947fb83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*gqNMBC1WF6Mf2TFrdw7Jxw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">ncdu</figcaption></figure><ul class=""><li id="d898" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">df -hi</code>它显示了高级文件系统的使用情况。</li><li id="e564" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">du -shc /host/var/lib/docker/overlay2/*/diff | tee disk_usage.log</code></li></ul><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/d34b5fa51597d49afeb0ba189afcb112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qr7THyvV0GoK9TgE0J9y5w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">du -shc example</figcaption></figure><ul class=""><li id="d040" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">耐心点，这需要一些时间</li></ul><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es my"><img src="../Images/df983d65b97c100047434b6f3c77b721.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*ikX-48T_6zJ8Pdlem-qSbw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><code class="du ly lz ma mb b">docker buildx du</code></figcaption></figure><ul class=""><li id="43b0" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">耐心点，这需要一些时间</li></ul><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/cb9ea2c803f3c42dfde851008fdd536f.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*iHN0t5FNzVc2ZmE5gljSjA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx"><code class="du ly lz ma mb b">docker system df</code></figcaption></figure><p id="efab" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在<code class="du ly lz ma mb b">docker system df</code>的输出中，行<code class="du ly lz ma mb b">Build Cache</code>指的是BuildKit使用的空间。</p><p id="ab2a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">此时，我开始钻研BuildKit和Docker的源代码，验证<code class="du ly lz ma mb b">Build Cache</code>是如何评估的。</p><p id="237c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在moby/docker的源代码中，这个公共函数<code class="du ly lz ma mb b">DiskUsage</code>使用的<code class="du ly lz ma mb b">controlapi.DiskUsageRequest{}</code>是BuildKit包的一部分。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/cfb5ac7b683fee4d0f1493786ae59073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEd_GMtlwQUePNPrzrtuVg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://github.com/moby/moby/blob/4651269dc8466b5aa11507385ccd06883665d1e7/builder/builder-next/builder.go#L122" rel="noopener ugc nofollow" target="_blank">Link to the source code</a></figcaption></figure><h1 id="e615" class="km kn hi bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj bi translated">BuildKit正在填满磁盘</h1><p id="2979" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">磁盘正在被填满，因为<code class="du ly lz ma mb b">kubelet</code>(也称为工作节点的队长)和<code class="du ly lz ma mb b">dockerd</code>都没有清理BuildKit缓存。</p><p id="7b88" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在<code class="du ly lz ma mb b">kubelet</code>中，您可以配置两个标志来根据阈值清理docker图像:</p><ul class=""><li id="188f" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">--image-gc-high-threshold=60</code></li><li id="2146" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated"><code class="du ly lz ma mb b">--image-gc-low-threshold=50</code></li></ul><p id="044d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">但是这不会为您清理BuildKit缓存，默认情况下，BuildKit垃圾收集是禁用的。<br/> 为此，<code class="du ly lz ma mb b">dockerd</code>不打算自动清理缓存。</p><h1 id="f3a4" class="km kn hi bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj bi translated"><strong class="ak">如何配置BuildKit垃圾收集</strong></h1><p id="f7e3" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">以下内容在您的docker守护进程上启用默认GC:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="b13e" class="ml kn hi mb b be mm mn l mo mp">"builder": {<br/>    "gc": {<br/>      "enabled": true<br/>    }<br/>  }</span></pre><p id="5095" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">您必须将该零件添加到<code class="du ly lz ma mb b">/etc/docker/daemon.json</code>中，如下所示:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="bbd7" class="ml kn hi mb b be mm mn l mo mp">{<br/>  ...<br/>  "builder": {<br/>    "gc": {<br/>      "enabled": true,<br/>    }<br/>  },<br/>  "features": {<br/>    "buildkit": true<br/>  }<br/>}</span></pre><p id="0ca3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">Ref:</em><a class="ae iu" href="https://docs.docker.com/build/building/cache/garbage-collection/" rel="noopener ugc nofollow" target="_blank"><em class="ja">https://docs . docker . com/build/building/cache/garbage-collection/</em>T20】</a></p><p id="9c11" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果你想了解更多先进的政策，我建议你去<a class="ae iu" href="https://github.com/docker/docs/pull/16032" rel="noopener ugc nofollow" target="_blank">看看这个即将发布的拉动式需求</a>。</p><p id="2abc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">对于高级策略示例:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="a4b6" class="ml kn hi mb b be mm mn l mo mp">{<br/>  ...<br/>  "builder": {<br/>    "gc": {<br/>          "enabled": true,<br/>          "policy": [<br/>                {"keepStorage": "20GB", "filter": ["unused-for=168h"]},<br/>                {"keepStorage": "50GB", "all": true}<br/>            ]<br/>        }<br/>}</span></pre><p id="16e4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">上面的配置显示垃圾收集是打开的，并且它遵循两个规则。</p><ol class=""><li id="ac92" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw mq lv lw lx bi translated">如果构建缓存超过20GB，则删除超过7天(转换为天数)的每个未使用的构建缓存</li><li id="34c7" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw mq lv lw lx bi translated">如果第一个规则不足以将缓存降低到20GB，它将跳转到下一个规则，在那里它应该删除所有的构建缓存数据，直到保持存储达到50GB。</li></ol><p id="9dc2" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">对于每一个状态，一旦该条件意味着，它将终止，不会移动到另一个条件。</p><p id="bb41" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">Ref:g</em><a class="ae iu" href="https://github.com/docker/cli/pull/2864/files#diff-7b562fc47002a9f485902c4cc0ed6c0f288fe586ce9597b3c51c6e49a340c82d" rel="noopener ugc nofollow" target="_blank"><em class="ja">arbagecollection _ config . MD</em></a></p><h1 id="4bff" class="km kn hi bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj bi translated">解决Kubernetes/Laptop/VM中的问题:</h1><p id="82da" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">在您的worker节点中，您需要在<code class="du ly lz ma mb b">/etc/docker/daemon.json</code>中设置<code class="du ly lz ma mb b">builder.gc.enabled = true</code>，如下所示:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="fd70" class="ml kn hi mb b be mm mn l mo mp">{<br/>  "bridge": "xxx",<br/>  "log-driver": "xxx",<br/>  "log-opts": {<br/>    "xxxx" : "xxx"<br/>  },<br/>  "builder": {<br/>    "gc": {<br/>          "enabled": true<br/>  }<br/>  "live-restore": true<br/>}</span></pre><p id="4b4c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">不幸的是，这个参数<strong class="jb hj">需要docker守护进程重启</strong>，因为这里没有列出:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/0724ad268f68182c0376a75b6f1d6b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Sjb9nxkxWbdkdgkfsgDUg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file</em></a></figcaption></figure><p id="77c1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所以选择是:</p><ul class=""><li id="437e" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">重启docker守护进程，注意<code class="du ly lz ma mb b">live-restore</code>为真。<br/>这可能是一个颠覆性的解决方案，不是我的选择。</li><li id="a16f" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated">创建/覆盖worker节点映像，提供新的<code class="du ly lz ma mb b">/etc/docker/daemon.json</code> <br/>这里是一个EKS示例:<a class="ae iu" href="https://aws.amazon.com/premiumsupport/knowledge-center/eks-worker-nodes-image-cache/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/premium support/knowledge-center/eks-worker-nodes-image-cache/</a></li></ul><h2 id="39d0" class="nd kn hi bd ko ne nf ng ks nh ni nj kw jx nk nl la jy nm nn le jz no np li nq bi translated">鉴于第二个选项需要一点时间，在文章的最后我提供了一个快速的解决方法来缓解这个问题。</h2><p id="c3f4" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">你知道docker中垃圾收集器的周期性是哪个吗？</p><ul class=""><li id="4fa1" class="lp lq hi jb b jc jd jg jh jx lr jy ls jz lt jw lu lv lw lx bi translated">1小时？</li><li id="ae58" class="lp lq hi jb b jc mc jg md jx me jy mf jz mg jw lu lv lw lx bi translated">1分钟？</li></ul><h1 id="4a4b" class="km kn hi bd ko kp mr kr ks kt ms kv kw kx mt kz la lb mu ld le lf mv lh li lj bi translated">让我们想出频率</h1><p id="c9c6" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">为了找到垃圾收集器的频率，我启用了<code class="du ly lz ma mb b">dockerd</code>日志并设置了<code class="du ly lz ma mb b">defaultKeepStorage=1MB</code>(需要重启<em class="ja">docker来抓取那些</em>):</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="467d" class="ml kn hi mb b be mm mn l mo mp">{<br/>  "builder": {<br/>    "gc": {<br/>      "enabled": true,<br/>      "defaultKeepStorage": "1MB"<br/>    }<br/>  },<br/>  "features": {<br/>    "buildkit": true<br/>  },<br/>  "debug": true<br/>}</span></pre><p id="a973" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们用docker文件构建任何docker映像来创建大于1 MB的缓存。</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="f66b" class="ml kn hi mb b be mm mn l mo mp">$ docker buildx build .<br/>$ docker system df<br/>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br/>Images          177       3         46.54GB   45.69GB (98%)<br/>Containers      13        0         39.39MB   39.39MB (100%)<br/>Local Volumes   0         0         0B        0B<br/>Build Cache     661       0         65.23MB   65.23MB</span></pre><p id="ca48" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这个例子中，我有一个65MB的<code class="du ly lz ma mb b">Build Cache</code>。</p><p id="e40d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们根据操作系统打开存储在特定路径<a class="ae iu" href="https://docs.docker.com/config/daemon/#read-the-logs" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/config/daemon/#read-the-logs</a>中的<code class="du ly lz ma mb b">dockerd</code>日志，最多1分钟后，我们应该会看到下面的日志:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="8560" class="ml kn hi mb b be mm mn l mo mp">time="2022–11–23T21:37:05.XXXX" level=debug msg="gc cleaned up 65220352 bytes"</span></pre><p id="4665" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在我们可以再次构建，并再次等待日志来计算差异:</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="d5d6" class="ml kn hi mb b be mm mn l mo mp">time="2022-11-23T21:38:05.XXXX" level=debug msg="gc cleaned up 65220352 bytes</span></pre><p id="c4bd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">比较这两个日志，<strong class="jb hj">垃圾收集每1分钟进行一次</strong>。</p><h2 id="6ee5" class="nd kn hi bd ko ne nf ng ks nh ni nj kw jx nk nl la jy nm nn le jz no np li nq bi translated">但是为什么是1分钟？</h2><p id="e9a0" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">下面是实现链接GC的控制器的moby/docker的源代码。<br/>在第75行有一个方法<code class="du ly lz ma mb b">throttle.After(time.Minute, c.gc)</code></p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/de8592060eb9b27da6bfadbdc137a474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYhGxC8B1tUYCuHKjgMVzw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://github.com/moby/moby/blob/23a27d4c8acb9743892e27087993cfdf2667dcc3/vendor/github.com/moby/buildkit/control/control.go#L59" rel="noopener ugc nofollow" target="_blank">Reference link</a></figcaption></figure><p id="fd33" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这个方法返回一个带有互斥和实际睡眠的函数。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ns"><img src="../Images/67326bf014a97f98879ebff172ecf39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*5iGkqjJ3IXbm-mtD-u1PkQ.png"/></div></figure><p id="89ac" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><code class="du ly lz ma mb b">c.throttledGC</code>由于Defer (#77)而启动，Defer用于延迟函数或语句的执行，直到附近的函数返回。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="6b6f" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">—临时工作区—</h1><p id="e621" class="pw-post-body-paragraph iy iz hi jb b jc lk je jf jg ll ji jj jx lm jm jn jy ln jq jr jz lo ju jv jw hb bi translated">解决方法是创建一个cronJob或DaemonSet，在每个节点上运行<code class="du ly lz ma mb b">docker buildx prune</code>命令。</p><pre class="kb kc kd ke fd mh mb mi bn mj mk bi"><span id="1cfd" class="ml kn hi mb b be mm mn l mo mp">docker buildx prune --filter until=168h --verbose --force</span></pre><p id="6ca4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">上面的命令会清除超过7天的缓存，并输出每个删除的图层。</p><p id="12e0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">要在集群中运行上面的命令，这里的<a class="ae iu" href="http://bit.ly/3V43DVQ" rel="noopener ugc nofollow" target="_blank">http://bit.ly/3V43DVQ</a>有一个创建DaemonSet的舵图表。<br/>每个完成<code class="du ly lz ma mb b">docker buildx prune</code>命令的pod都将永远处于睡眠状态，以避免DaemonSet控制器的无限重启。</p><p id="f749" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">想法是在CI中启用DaemonSet等待1h —然后禁用它。这个临时的解决方法允许我在1小时内删除10tb的缓存。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/ade4c1c65b62efee0ab2c9948dc97970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1miXzvS9nN5-yIUPWA9CUg.png"/></div></div></figure><p id="a8b3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">非常感谢任何鼓掌、关注或评论！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/fd1037d97db88bcca5d26801c3a9492f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WA1EDTf-PDNIKgK8.png"/></div></div></figure><blockquote class="nv"><p id="7fc5" class="nw nx hi bd ny nz oa ob oc od oe jw dx translated"><a class="ae iu" href="https://pie-r.medium.com/" rel="noopener">关注我</a>和<a class="ae iu" href="https://pie-r.medium.com/subscribe" rel="noopener">订阅</a>来获取这个系列和下一个系列的更新！</p></blockquote></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es of"><img src="../Images/c354688c6a7fe856e037d2dbcb5affc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ES9sWYK0-DMj61d"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@pablomerchanm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pablo Merchán Montes</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Creating a Stack in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建堆栈</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-a-stack-in-javascript-6031ee8ef9a8?source=collection_archive---------12-----------------------#2021-04-28">https://medium.com/geekculture/creating-a-stack-in-javascript-6031ee8ef9a8?source=collection_archive---------12-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6440b298e463ade01ebc6fd153a36114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8FIV1EtpBrJY_R6BvpxPw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@auntneecey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Denise Johnson</a> on <a class="ae iu" href="https://unsplash.com/s/photos/stack-of-pancakes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我们将学习一种被称为<em class="jt">栈</em>的数据结构。你们有些人可能会问，“什么是数据结构？”我很高兴你问了…</p><p id="2060" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据结构是组织数据的一种特定方式。理解它们允许我们通过格式化有效的解决方案来解决编程问题。知道使用哪些数据结构(有几种)以及如何应用它们是至关重要的。为手头的任务选择错误的数据结构可能会影响我们正在编写的程序的性能。因此，我们应该学习各种数据结构以及如何正确应用它们。</p><p id="a2f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<em class="jt">数组</em>是最简单的数据结构，JavaScript天生支持它。数组存储一系列值。作为JavaScript开发人员，我们有点被宠坏了，因为我们可以在一个数组中存储不同数据类型的值。大多数其他语言只允许创建具有相同数据类型值的数组。</p><p id="f9a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈类似于数组。事实上，正如我们将在后面看到的，我们的栈实现将在内部使用一个数组来存储我们的数据。栈是遵循<strong class="ix hj"> LIFO </strong>(后进先出)原则的有序的项目集合。从同一端添加和移除项目。发生这种情况的堆栈末端称为<em class="jt">顶部</em>，相对的末端是<em class="jt">底部</em>。所以，最近增加的在顶部附近，最老的在底部附近。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/33d1700d78182dea13964191191fafe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y6gwyYXxUk-ev3wd"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@wayneshin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Wayne Low</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7ae3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈出现在许多现实环境中。通常给出的经典例子是一堆书。一叠煎饼是按后进先出顺序吃的。挤进电梯的人通常以后进先出的顺序离开(除非他们是混蛋)。在杂货店里，商品从货架上拿下来是按照后进先出法的顺序进行的。甚至流行的<em class="jt">万智牌</em>纸牌游戏也使用“堆栈”作为管理游戏的基本机制。从技术上来说，LIFO往往发生在执行递归算法的过程中，其中执行的函数按LIFO顺序发生。</p><p id="c9f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编程语言中的编译器和计算机也使用堆栈来存储变量。JavaScript有一个所谓的<em class="jt">调用栈</em>，当解释器读取程序时，我们所有的代码被一个接一个地推送和执行。</p><p id="a286" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈实现简单且高效。因此，当检索顺序根本不重要时，它们可能是正确的数据结构。我们将构建一个简单的stack类(我讨厌使用单词<em class="jt"> class </em>，因为从技术上讲JavaScript中不存在类)，然后我们将通过一些例子来演示如何使用它。最后，我们将创建一个使用堆栈来解决问题的函数。准备好了吗？开始了。</p><p id="c164" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，本文使用的是<a class="ae iu" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> node.js </em> </a>，所以在继续之前要确保已经安装。接下来，创建一个名为<em class="jt">栈</em>的项目目录(我知道，超级原创吧？).在这个目录中，让我们创建一个名为<em class="jt"> stack.js </em>的新文件。在该文件中，输入以下代码:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="a815" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哇，这里有各种各样的东西——生活，弱映射，类！但这一切意味着什么呢？</p><p id="5638" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们注意到的第一件事是，整个函数被包装在一个IIFE(立即调用的函数表达式)中，然后被赋给常量<strong class="ix hj"> Stack </strong>。通过这样做，我们在生命中创造了第二个范围——一个保护生命中一切的独立范围。这创建了一个闭包，并允许我们只从它的<em class="jt">返回我们想要的</em>，从而防止直接访问我们的<strong class="ix hj"> items </strong>变量。这叫做<em class="jt">封装。</em></p><p id="3b94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如所承诺的，在第4行我们声明了一个常量，<strong class="ix hj"> items </strong>，它将保存我们堆栈的数据。如上所述，这个变量受作用域保护，所以栈外的任何东西都不能访问它。我们正在使用WeakMap的一个实例，所以当它们引用的实例超出范围时，我们的私有属性将超出范围。否则，我们存储在堆栈实例中的数据永远不会被垃圾收集！(垃圾收集是JavaScript定期从不再需要保留的项目中回收内存的过程。更多信息，请点击<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="6703" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第6行开始了我们的类块。注意，我们甚至懒得给类命名；我们只是把它退回去。这意味着<strong class="ix hj">栈</strong>的实例实际上是这个类的实例。</p><p id="050c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第7–9行，我们设置了构造函数。这里我们使用WeakMap实例，<strong class="ix hj"> items </strong>，为这个设置一个键<em class="jt">，并将其映射到一个空数组。这样，每个实例将被映射到栈自己的<em class="jt"> this </em>对象。这个数组是我们保存所有堆栈数据的地方。</em></p><p id="7946" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们开始为我们的堆栈数据结构构建一些特定的方法。首先是第11-13行的<strong class="ix hj">按钮</strong>。调用<strong class="ix hj"> push </strong>方法将一个新项目(或几个项目)添加到堆栈顶部，而<em class="jt">只会将</em>添加到堆栈顶部。</p><p id="e205" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来是第15–17行的<strong class="ix hj">弹出</strong>方法。此方法从堆栈中移除顶部的项并将其返回。我们通过使用JavaScript的pop方法来实现这一点，因为它遵循我们所追求的LIFO原则。</p><p id="755c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第19–21行的下一个方法叫做<strong class="ix hj"> peek </strong>。当我们想要查看(但不是移除)栈顶的项目时，我们可以使用这个方法。我们通过简单地返回存储在我们的<strong class="ix hj">项目</strong> WeakMap实例中的数组的最后一个项目来实现这一点。</p><p id="0dc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">敏锐的观察者可能已经注意到了<strong class="ix hj"> items.get(this) </strong>返回了一个堆栈项目的数组。因此，我们可以像对待普通的JavaScript数组一样对待它。</p><p id="914a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们实现的下一个方法叫做<strong class="ix hj"> isEmpty </strong>，在第23–25行，它……嗯，返回堆栈是否为空。我们在这里所做的就是写一个条件来查看堆栈中的条目数组的长度是否为零。如果是，该方法返回<strong class="ix hj">真</strong>；否则<strong class="ix hj">假</strong>。</p><p id="fb7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来是第27–29行的<strong class="ix hj">大小</strong>方法。这个方法简单地返回我们的堆栈的项目数组的长度。这里没什么特别的。</p><p id="a87d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们最后的(终于！)方法是<strong class="ix hj">清除</strong>，在第31–33行。该方法将存储在我们的<strong class="ix hj"> items </strong> WeakMap实例中的数组重置为空数组。实际上，这清空了我们的堆栈。</p><p id="5b87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一句，不要忘记第35行的括号来结束我们的生活！最后，在第37行添加一个导出堆栈的方法。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="21c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们有了一个完全实现的堆栈数据结构，我们如何使用它呢？让我们来看看…</p><p id="b6c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在堆栈目录中创建一个名为<em class="jt"> useStack.js </em>的新文件，并添加以下代码:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="9cd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我知道，这里发生了很多事！别担心，我们会一起走过去的。</p><p id="df45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在文件的顶部，第3行和第5行，我们需要来自<em class="jt"> stack.js </em>的<strong class="ix hj"> Stack </strong>类，然后我们创建一个新的Stack实例，我们称之为<strong class="ix hj"> stk </strong>。接下来的几行代码只是将一些信息记录到我们的终端，我们马上就会看到。</p><p id="6bd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第12–14行开始向堆栈中添加数字，然后在第16–18行，我们查看顶部的项目是什么，检查堆栈是否为空，然后找出当前堆栈中的元素数量。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/b7c9149f2cb52e2512af8ec5b99c28cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf2Eou0F0fkIxH_A97xJ9g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Going from an empty stack to one with three items</figcaption></figure><p id="1c38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一节中，我们从堆栈中移除顶部的条目，并将其存储在变量<strong class="ix hj"> x </strong>中。然后，我们使用该变量来报告哪个项目被删除(第24行)，然后检查新的顶部项目是什么，并再次报告其大小(第26–27行)。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/46508d7baab1d5ef087d2aa86c5602eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*n18R5Unuz-H_capQdVLsVQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Popping off the top item</figcaption></figure><p id="6284" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们完全清空堆栈，然后检查堆栈是否为空(第31–33行)。</p><p id="24b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们将一个新的项目压入堆栈，然后查看它是什么(第37–39行)，然后我们记录我们完成了堆栈的测试。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/cbaffade499b2bb79599eb5b1d2bd123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*O2DkRpMb5af9WUUopkTiiw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Clearing the stack, then pushing a new item onto it</figcaption></figure><p id="ef91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了测试所有这些，我们需要将终端导航到我们的<em class="jt">堆栈</em>目录，并运行以下命令:</p><pre class="jv jw jx jy fd kl km kn ko aw kp bi"><span id="2607" class="kq kr hi km b fi ks kt l ku kv">node useStack</span></pre><p id="71e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果成功，您的终端应该有以下输出:</p><pre class="jv jw jx jy fd kl km kn ko aw kp bi"><span id="eafe" class="kq kr hi km b fi ks kt l ku kv">Testing the stack...</span><span id="7e91" class="kq kr hi km b fi kw kt l ku kv">========================================</span><span id="63d8" class="kq kr hi km b fi kw kt l ku kv">Pushing 5, 6, and 7 onto the stack...</span><span id="133d" class="kq kr hi km b fi kw kt l ku kv">The top items is: 7</span><span id="9590" class="kq kr hi km b fi kw kt l ku kv">The stack is empty: false</span><span id="8eb9" class="kq kr hi km b fi kw kt l ku kv">Number of items in the stack: 3</span><span id="419c" class="kq kr hi km b fi kw kt l ku kv">========================================</span><span id="cd37" class="kq kr hi km b fi kw kt l ku kv">Removing the top item from the stack...</span><span id="9598" class="kq kr hi km b fi kw kt l ku kv">Item removed from top: 7</span><span id="3b23" class="kq kr hi km b fi kw kt l ku kv">The new top item is: 6</span><span id="f859" class="kq kr hi km b fi kw kt l ku kv">The new stack size is: 2</span><span id="8db9" class="kq kr hi km b fi kw kt l ku kv">========================================</span><span id="e434" class="kq kr hi km b fi kw kt l ku kv">Clearing the stack...</span><span id="e1c4" class="kq kr hi km b fi kw kt l ku kv">The stack is cleared: true</span><span id="5522" class="kq kr hi km b fi kw kt l ku kv">========================================</span><span id="edcf" class="kq kr hi km b fi kw kt l ku kv">Pushing 8 onto the stack...</span><span id="909c" class="kq kr hi km b fi kw kt l ku kv">The top item is: 8</span><span id="0d7b" class="kq kr hi km b fi kw kt l ku kv">========================================</span><span id="04d5" class="kq kr hi km b fi kw kt l ku kv">Finished testing the stack!</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="ef82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们知道我们的堆栈工作正常。但你可能会问，“这有什么好处？我们能用它做什么样的酷东西呢？”你问了最好的问题…</p><p id="1177" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实证明，堆栈可以帮助解决各种问题。我们要看的是一个基极转换器。作为人类，我们使用以10为基数的数字系统，因为我们(大多数人)有10个手指。在计算机科学中，我们也看到使用其他一些基数，主要是二进制(基数2)，但也有八进制(基数8)和十六进制(基数16)。这些数字的位置需要一点数学(我知道！)来计算，但都是基于以下模式:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/032bbf2e7f87750cf35d8a92fb9b09cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*ZxVrTm1hH-11iakOjXk6eA.png"/></div></figure><p id="5605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果我们看到八进制(八进制)数字247，我们必须做一些数学运算将其转换为十进制(人类友好的)数字。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/eb780929e65fd982fc4f19a73e03af67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*5FdbpWy_nHucJudXE8uAVw.png"/></div></div></figure><p id="fb7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，八进制247相当于十进制167。看，那不是很容易吗？好吧，所以手动转换数字真的很痛苦！幸运的是，我们将编写一个函数来完成这项工作，特别是从数学角度来说，将十进制数从十进制数转换到另一个基数有点困难。</p><p id="18a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的<em class="jt">栈</em>项目目录中，让我们创建一个名为<em class="jt"> baseConverter.js </em>的新文件，并添加以下代码:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="430b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数提供了一个将十进制数转换成任意基数的算法。只要除法结果不为零，我们就将除法的余数推到堆栈中，然后通过除以基数来更新十进制数。然后，我们从堆栈中弹出元素，直到它为空，通过从<strong class="ix hj"> digits </strong>字符串中检索它们的值来转换数字，然后连接所有从堆栈中移除并转换为字符串的元素。</p><p id="786c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了了解当生命转换到其他基础时，它的意义是什么，让我们将终端导航到我们的项目目录并运行</p><pre class="jv jw jx jy fd kl km kn ko aw kp bi"><span id="c87a" class="kq kr hi km b fi ks kt l ku kv">node baseConverter</span></pre><p id="58be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它应该提供以下输出</p><pre class="jv jw jx jy fd kl km kn ko aw kp bi"><span id="b16f" class="kq kr hi km b fi ks kt l ku kv">The binary meaning of life is 101010</span><span id="e5b2" class="kq kr hi km b fi kw kt l ku kv">The octal meaning of life is 52</span><span id="0cd7" class="kq kr hi km b fi kw kt l ku kv">The hexadecimal meaning of life is 2A</span></pre><p id="b520" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将把创建一个将不同基数的数转换为十进制数的函数作为读者的练习。</p><p id="d941" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许这个例子会帮助你想到使用栈数据结构可以解决的其他问题。作为一个额外的挑战，尝试使用堆栈来解决经典的河内塔问题。为了让你开始，记住在解谜时有三个塔(即，栈)。</p><p id="fee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢跟随和快乐编码！</p></div></div>    
</body>
</html>
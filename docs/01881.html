<html>
<head>
<title>Optimization Techniques for ML Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML模型的优化技术</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/optimization-techniques-for-ml-models-bd500c8398ce?source=collection_archive---------13-----------------------#2021-04-27">https://medium.com/geekculture/optimization-techniques-for-ml-models-bd500c8398ce?source=collection_archive---------13-----------------------#2021-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于许多机器学习算法和深度学习网络，我们可以优化两个主要领域。一个是超参数，第二个是神经网络架构。</p><p id="3c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超参数的选择有时对确定模型的收敛性至关重要。优化技术用于确定学习算法的最佳超参数。选择对应于用户定义的度量的最佳超参数。通常优化是为了最小化模型的损失或最大化精度。这一过程被称为<strong class="ih hj">超参数优化(HPO)。</strong></p><p id="521f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超参数优化是在固定的架构上完成的，但我们也可以执行一种称为<strong class="ih hj">网络架构搜索(NAS) </strong>的技术，如果模型在单独HPO之后似乎仍然不收敛，则在ML模型或深度学习网络的架构空间上执行搜索。很多时候，寻找最佳架构需要领域专业知识，并且考虑到训练和评估被测试的ML模型的多个版本，这可能是耗时的。例如，确定是通过添加更多隐藏节点来扩展网络的宽度，还是通过添加更多层来增加网络的深度，这是NAS可以解决的问题。</p><p id="3e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HPO和NAS算法可以使用白盒和黑盒方法来找到最佳的超参数和架构。白盒方法使用内部梯度进行优化，因此它们通常只能用于具有连续超参数空间的模型。黑盒方法探索超参数/架构空间，而不关心内部梯度，因此它们可以用于任何超参数或架构空间。下面介绍的两种黑盒方法是<a class="ae jd" href="https://arxiv.org/abs/1206.2944" rel="noopener ugc nofollow" target="_blank">贝叶斯优化</a>和<a class="ae jd" href="https://arxiv.org/pdf/1905.07350.pdf" rel="noopener ugc nofollow" target="_blank"> DeepSwarm </a>。</p><h1 id="6835" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">贝叶斯优化</strong></h1><p id="0ac4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下面是<a class="ae jd" href="https://papers.nips.cc/paper/2012/file/05311655a15b75fab86956663e1819cd-Paper.pdf" rel="noopener ugc nofollow" target="_blank">实用贝叶斯优化机器学习算法</a>的总结。</p><p id="db9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶斯优化的目标是找到机器学习模型的最优超参数。简单地说，这是找到损失函数<em class="kh"> f(x)的最小值的唯一方法。</em></p><p id="7078" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该学习算法的泛化性能被建模为来自高斯过程(GP)的样本。每个GP由内核和超参数指定，并且它还考虑了可变成本和运行时间，以用于将来的计算并行化。</p><p id="4170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶斯优化对于调整具有高计算成本的算法的参数是有用的。</p><p id="c1d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶斯优化的目标是使用概率模式找到<em class="kh"> f(x) </em>的最小值，使用<em class="kh"> f(x) </em>的所有先前评估来确定接下来评估的位置，而不是局部梯度，因为<em class="kh"> f(x) </em>的评估是昂贵的。</p><p id="cb5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要选择的两个组件是高斯先验和采集函数。</p><h2 id="4ea6" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">高斯过程</h2><p id="afec" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们选择一个损失函数</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es kw"><img src="../Images/daa9e53e840cbb6ffbf5786087b22f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:168/0*cWg7dXtYcdqQ7JyQ"/></div></figure><p id="5ab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中X是超参数设置的集合。</p><p id="a526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们在有限的N个点的集合上定义多元高斯分布:</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es le"><img src="../Images/281a0b70560fdb779365fba74f2e4b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:190/0*2i5x3aaCAWoJrbYs"/></div></figure><p id="45d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这导致分布在</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lf"><img src="../Images/1daa795e113eb6f7f612fc9cad58f458.png" data-original-src="https://miro.medium.com/v2/resize:fit:50/0*oGzaWUgqpkhu9dy3"/></div></figure><p id="d5cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由均值函数和正定协方差函数确定。</p><h2 id="78c9" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">获取功能</h2><p id="0360" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于采集功能，我们假设数据点来自</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lg"><img src="../Images/7119bf2e0f01b9d08dd64c7a7dcccbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:170/0*J6vzSLtL1ZJBdXrT"/></div></figure><p id="92a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<em class="kh"> y </em>由正态分布得到</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lh"><img src="../Images/2d5ae86ae86a506724c003bb580e9a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/0*8-SgRk_UNxSaNUR5"/></div></figure><p id="0247" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es li"><img src="../Images/0e523a7f5136cc9779b39b0484540ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:18/0*rpY0_ep6df_hsqCp"/></div></figure><p id="7a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是函数值的方差。为了找到下一个数据点以计算最小值f(x ),我们定义</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lj"><img src="../Images/448b100681d42fb3847e30d835d0721e.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/0*2weJMZycv7QUlZBO"/></div></figure><p id="84f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> a </strong>代表采集功能。</p><p id="5d9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">采集功能有多个选项可供选择，例如</p><ul class=""><li id="4e39" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj">改进概率— </strong>最大化获得比最佳当前值更好的值的概率</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lt"><img src="../Images/a8c6aecc476e28be4e736469ef648f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*9mz9vFNGV2XCEGfDVadsyw.png"/></div></figure><ul class=""><li id="82bd" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj">预期改进— </strong>在当前最佳水平的基础上最大化预期改进</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lu"><img src="../Images/4be5617666c96c730865d7e524c8ddda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*q-_u1lbZTkPY7Jk-3QRa4Q.png"/></div></figure><ul class=""><li id="b15d" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">伽马被定义为</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lv"><img src="../Images/6e00cd8f380051472b0b60a65e8bcdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*JqDWftsCGoUibdk42rCMEg.png"/></div></figure><h2 id="5c2b" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">建模成本</h2><p id="1d63" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们需要快速找到超参数的最佳设置——我们更关心挂钟时间，而不是函数进度。</p><p id="1515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用<strong class="ih hj">每秒的预期改进</strong>进行优化——这些点可能是好的，并且可能被快速评估(例如，从一组较快的学习速率中选择，而不是较慢的)</p><h2 id="1ca0" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">用于并行贝叶斯优化的蒙特卡罗获取</h2><p id="7742" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">不仅仅是并行化批处理，我们还想弄清楚x_next是什么。</p><p id="546c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种顺序策略利用高斯过程来计算待定位置上的采集函数的蒙特卡罗估计。评估的数据是</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lg"><img src="../Images/48d53aaed2e038f1d04f1be2f0d6358e.png" data-original-src="https://miro.medium.com/v2/resize:fit:170/0*YeeVEnBZJVH47L0p"/></div></figure><p id="8b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未决数据是</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lw"><img src="../Images/04442549dd34d8410765c9293be94818.png" data-original-src="https://miro.medium.com/v2/resize:fit:112/0*fhK9xDHdi7fbeKxp"/></div></figure><p id="d9ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用基于J维高斯分布来表征<strong class="ih hj"> a </strong>的期望的采集函数。</p><h1 id="4ec3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">深虫群</strong></h1><p id="52e3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">以下是<a class="ae jd" href="https://arxiv.org/pdf/1905.07350.pdf" rel="noopener ugc nofollow" target="_blank"> DeepSwarm的总结:利用群体智能</a>优化卷积神经网络。</p><h2 id="5149" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">使用ACO的动机</h2><ul class=""><li id="1774" class="lk ll hi ih b ii kc im kd iq lx iu ly iy lz jc lp lq lr ls bi translated">像ACO这样的群体智能算法由于容错性、分散性、可伸缩性以及知识共享和组合而适合于神经架构搜索</li><li id="a18c" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated">ACO擅长解决具有图形表示的离散问题，并能适应动态变化的图形</li><li id="54bb" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated">神经网络是一种图形，这是使用ACO背后的直觉</li></ul><h2 id="87d2" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">深水群</h2><ol class=""><li id="f062" class="lk ll hi ih b ii kc im kd iq lx iu ly iy lz jc mf lq lr ls bi translated">创建开始时有1个输入节点的内部图</li></ol><p id="1e02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.放在输入节点上的每只蚂蚁</p><p id="ef6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.用蚁群系统选择规则为下一层神经网络选择节点</p><ul class=""><li id="9029" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">边上的信息素值(r，u)= 1</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es mg"><img src="../Images/24ac520224921e3c1b251a783542f3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:98/0*2mr3UOHRlDjKgyxq"/></div></figure><ul class=""><li id="0d40" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">边上的启发式值(r，u)= 1</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es mh"><img src="../Images/86f361573604cdad344c9709f3b74aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/0*Jwmndc42sGSUk5uK"/></div></figure><ul class=""><li id="f90f" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">Jk(r) =可从r访问的节点</li><li id="d3fb" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated"><em class="kh"> q </em> = random # from [0，1]</li><li id="c2a9" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated"><em class="kh"> q0 </em> in (0，1] =控制算法的贪婪性</li><li id="a38a" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated"><em class="kh"> Beta </em> in (0，inf) =启发式信息的相对重要性</li><li id="3d30" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated"><strong class="ih hj">选择规则如下:</strong></li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es mi"><img src="../Images/b02f0ace4a8834e8df18db04b00f5045.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/0*LFG-VYN8eAIOqpJ9"/></div></figure><ul class=""><li id="e0c9" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">其中S是选自以下分布的随机变量:</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es mj"><img src="../Images/872236dc204e3c6dda58620ff8759d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/0*IguUKmttPEqrFTuR"/></div></figure><ul class=""><li id="5bd5" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">如果该节点是一个新的节点，并且在图上不存在，则将其添加为邻居</li></ul><p id="ddec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.在为节点选择规则后，每个蚂蚁将使用相同的规则选择节点属性，如过滤器大小、内核大小等</p><p id="55a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.两次选择后，节点被添加到该蚂蚁的路径中</p><p id="ed37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.当蚂蚁到达最大深度时，评估神经网络架构</p><p id="844d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.<strong class="ih hj">局部信息素更新</strong>——每只蚂蚁完成一次行走后，更新其路径上的每一条边</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es mk"><img src="../Images/94e12aafe43e2af2757586963ecbe5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/0*aDGfNonD-RD92sAa"/></div></figure><ul class=""><li id="db11" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">Rho是信息素衰减因子——当rho为1时，100%衰减，因此仅基于起始值；当ρ为0时，信息素不断增加，使得最强路径更强。</li><li id="95b3" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated">这条规则允许腐烂，这鼓励蚂蚁寻找其他路径</li></ul><p id="28b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8。全局信息素更新</strong></p><ul class=""><li id="dd7d" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">在所有蚂蚁(评估神经网络)之后，找到最佳蚂蚁(最佳神经网络准确度)</li><li id="e5a0" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated">通过以下方式增加最佳路径/路线中的信息素值:</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es ml"><img src="../Images/779a74ffca58a2a531b7a8af7c0ec316.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*sGZrGXQgiuk8RDCv"/></div></figure><ul class=""><li id="d38c" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">α是来自(0，1)的信息素蒸发率</li><li id="b059" class="lk ll hi ih b ii ma im mb iq mc iu md iy me jc lp lq lr ls bi translated">Cgb是最佳旅行的成本=最佳模型精确度</li></ul><p id="3333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9.当前最大深度增加后，新的蚂蚁群体产生了</p><ul class=""><li id="f1e6" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">重复这个过程，直到达到全局最大深度</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mm"><img src="../Images/aafef42f04012adac6473472fb770b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ku7boz46gya9EiPs"/></div></div></figure></div></div>    
</body>
</html>
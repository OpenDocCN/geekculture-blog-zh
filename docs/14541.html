<html>
<head>
<title>Storage | Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">储物| Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/storage-kubernetes-92eb3d027282?source=collection_archive---------1-----------------------#2022-09-08">https://medium.com/geekculture/storage-kubernetes-92eb3d027282?source=collection_archive---------1-----------------------#2022-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="855d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深入了解Kubernetes储物件</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/03c17b1f712cee6e1734f41666edb022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSqS3nVQBwoDjHAyujph4w.png"/></div></div></figure><h2 id="d468" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">卷</h2><p id="27ee" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Kubernetes卷是一个目录，其中包含可由Pod中的容器访问的数据。卷提供了一种插件机制，将临时容器与其他地方的持久数据存储连接起来。</p><p id="1c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，您将了解到:</p><blockquote class="kp kq kr"><p id="a4cd" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> ● </strong> <a class="ae kw" href="#c842" rel="noopener ugc nofollow"> <strong class="ih hj">卷类型</strong></a><strong class="ih hj"><br/>●</strong><a class="ae kw" href="#7456" rel="noopener ugc nofollow"><strong class="ih hj">持久卷</strong></a><strong class="ih hj"><br/>●</strong><a class="ae kw" href="#d3b6" rel="noopener ugc nofollow"><strong class="ih hj">持久卷索赔</strong></a><strong class="ih hj"><br/>●</strong><strong class="ih hj">卷的动态预配置</strong> </p></blockquote><h2 id="c842" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">卷的类型—</h2><h2 id="252a" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">主机路径卷:</strong></h2><p id="fa88" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">挂载一个目录<code class="du kx ky kz la b"><strong class="ih hj">/var/local/data</strong></code>作为从<em class="ks">主机</em>到一个pod的<strong class="ih hj"> <em class="ks"> nginx </em> </strong>容器的<code class="du kx ky kz la b"><strong class="ih hj">/usr/share/nginx/html</strong></code>位置的卷。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/2884950c968b540c739b3502db1b3267.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*sWc3tpFGXSwKpInULjPyGA.jpeg"/></div><figcaption class="lc ld et er es le lf bd b be z dx">hostPath Volume</figcaption></figure><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="db5e" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj">#pod definition file with a volume </strong></span><span id="dd67" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: webserver<br/>spec:<br/>  containers:<br/>  - image: nginx:latest<br/>    name: nginx-container<br/><strong class="la hj">    volumeMounts:<br/>    - mountPath: /usr/share/nginx/html<br/>      name: test-vol</strong></span><span id="f367" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">  volumes:<br/>  - name: test-vol<br/>    hostPath:<br/>      path: /var/local/data<br/>      type: DirectoryOrCreate</strong></span></pre><p id="8ebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">nginx-container</strong></code> <strong class="ih hj"> </strong>在<code class="du kx ky kz la b"><strong class="ih hj">/usr/share/nginx/html</strong></code> <strong class="ih hj"> </strong>位置写入的任何数据都将持久保存在<em class="ks">主机</em>的<code class="du kx ky kz la b"><strong class="ih hj">/var/local/data</strong></code>位置。如果pod终止，数据将在<code class="du kx ky kz la b"><strong class="ih hj">/var/local/data</strong></code>位置保持安全。</p><p id="ff79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，来自<em class="ks">主机</em>的一个目录被用作卷。它被称为<code class="du kx ky kz la b"><strong class="ih hj">hostPath</strong></code>体积。但是有一个重要的事实需要记住，<code class="du kx ky kz la b"><strong class="ih hj">hostPath</strong></code>量产级应用不建议使用volume。</p><p id="791e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">hostPath</strong></code>卷仅在单节点集群中运行良好。但不在多节点群集中。因为<em class="ks">部署/复制集</em>下的单元将使用所有节点上的<code class="du kx ky kz la b"><strong class="ih hj">/var/local/data</strong></code>目录，并期望所有节点包含相同的数据。但这是不可能的，因为它们是不同的节点。</p><p id="0121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题的解决方案是为Kubernetes集群使用一个共享存储系统。如NFS和AWS EFS。</p><p id="fa35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes还支持多种类型的标准存储解决方案，如NFS、glusterFS或公共云解决方案，如AWS EBS、AWS EFS、Azure Disk或file、Google的持久磁盘等等。</p><h2 id="3a4f" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak"> NFS分享为一卷</strong></h2><p id="a137" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">使用<strong class="ih hj"> NFS共享</strong> <em class="ks"> </em>目录创建一个卷，并将其附加到一个pod。使用NFS，数据可以在pod之间共享，尽管它们在不同的工作节点或可用性区域中运行。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="195e" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj">#Pod definiton with nfs share directory</strong></span><span id="3a8b" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: webserver<br/>spec:<br/>  containers:<br/>  - image: nginx:latest<br/>    name: nginx-container<br/>    volumeMounts:<br/>    - mountPath: /usr/share/nginx/html<br/>      name: test-vol<br/><strong class="la hj">  volumes:<br/>  - name: test-vol<br/>    nfs:<br/>      server: 10.3.97.250          </strong> # nfs server ip or dns<strong class="la hj"><br/>      path: /var/local/nfs-share   </strong> # nfs share directory</span></pre><h2 id="e846" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak"> AWS EBS卷</strong></h2><p id="9a0b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">使用AWS-CLI创建一个卷，并记下“<strong class="ih hj">VolumeId”</strong>以将该卷连接到pod。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="e522" class="jp jq hi la b fi lk ll l lm ln">aws ec2 create-volume \<br/> <strong class="la hj"> --availability-zone</strong> ap-northeast-1d \<br/>  <strong class="la hj">--size</strong> 10 \<br/>  <strong class="la hj">--volume-type</strong> gp2 \<br/> <strong class="la hj"> --query "VolumeId"</strong> --output text</span></pre><blockquote class="kp kq kr"><p id="0278" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">注意:</em> </strong>由于EBS卷只锁定到特定的AZ。因此，EBS卷和将运行pod的工作节点应该在同一个AZ中。</p></blockquote><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="0bf2" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj">#Pod definition with node affinity </strong></span><span id="d017" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: webserver<br/>spec:<br/><strong class="la hj">  affinity:<br/>    nodeAffinity:</strong><br/>      requiredDuringSchedulingIgnoredDuringExecution:<br/>        nodeSelectorTerms:<br/>        - matchExpressions:<br/>          - key: topology.kubernetes.io/zone<br/>            operator: In<br/>            values:<br/>            <strong class="la hj">- ap-northeast-1d</strong><br/>  containers:<br/>  - image: nginx:latest<br/>    name: nginx-container<br/>    volumeMounts:<br/>    - mountPath: /usr/share/nginx/html<br/>      name: test-volume<br/><strong class="la hj">  volumes:<br/>  - name: test-volume<br/>    awsElasticBlockStore: </strong> # This AWS EBS Volume must already exist<strong class="la hj"> <br/>      volumeID: "vol-0b067ed35227a1bff"  </strong># Volume-id<strong class="la hj"><br/>      fsType: ext4</strong></span></pre><p id="3c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于EBS卷是在"<strong class="ih hj"> ap-northeast-1d" </strong> AZ中创建的，因此为了将该卷附加到一个pod，该pod应该在同一个AZ上。这就是为什么使用节点关联性在与EBS卷位于同一AZ的节点上部署pod。</p><h2 id="71f4" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">配置映射为卷</h2><p id="cb51" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">现有的配置图可以作为卷注入到pod中。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="ff22" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj"><em class="ks">#Pod-definition with configmap mounted as a volume into the pod</em></strong></span><span id="4c8f" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: web-server<br/>spec:<br/>  containers:<br/>  - name: wordpress<br/>    image: wordpress<br/><strong class="la hj">    volumeMounts:<br/>    - name: config-volume<br/>      mountPath: /etc/config  </strong><em class="ks">#Directory where files will be mounted</em><strong class="la hj"><br/>  volumes:<br/>    - name: config-volume<br/>      configMap:<br/>        name: user-config</strong></span></pre><h2 id="7c29" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak"> <em class="lp">秘作卷</em> </strong></h2><p id="76ae" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">现有的秘密可以作为一个卷注入到吊舱中。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="9f85" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj"><em class="ks">#Pod-definition with secret mounted as a volume into the pod</em></strong></span><span id="1b18" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: frontend<br/>spec:<br/>  containers:<br/>    - name: wordpress<br/>      image: wordpress<br/>      volumeMounts:<br/>      - name: secret-vol01<br/>        mountPath: /etc/secret    #files - mounted in this location<br/>        readOnly: true<br/> <strong class="la hj"> volumes:<br/>    - name: secret-vol01<br/>      secret:<br/>        secretName: app-secret</strong></span></pre><p id="874f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多关于k8s <a class="ae kw" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷<strong class="ih hj">卷</strong>卷</a></p><h2 id="7456" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">永久卷</h2><p id="54c9" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">持久卷是管理员在集群中提供的一块存储区。它是集群中的资源，就像节点是集群一样。永久卷是一种卷插件，其生命周期独立于使用永久卷的任何单独pod。</p><h2 id="d3b6" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">持续量声明(PVC)</h2><p id="aba8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">PersistentVolumeClaim (PVC)是用户对存储的请求。它类似于一个豆荚。Pods消耗节点资源，PV消耗PV资源。简而言之，PV是由PVC声明的，PV和PVC之间是一对一的关系。通过指定永久卷所需的最小大小和访问模式来配置PVC。</p><p id="9b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不存在匹配的卷，PVC将无限期保持未绑定状态。只要有匹配的PV可用，就会绑定索赔。</p><p id="75e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建一个持久卷(PV) </strong></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="bf70" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj"><br/>&gt; </strong>kubectl create -f &lt;pv-manifest-file&gt;.yaml</span><span id="f8ca" class="jp jq hi la b fi lo ll l lm ln">---</span><span id="5154" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">#PV using host directory</strong></span><span id="6cd1" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/><strong class="la hj">kind: PersistentVolume</strong><br/>metadata:<br/>  name: pv-volume01<br/>  labels: <br/>    storage-tier: standard<br/>spec:<br/>  <strong class="la hj">capacity</strong>:<br/>    storage: 50Mi<br/>  <strong class="la hj">accessModes</strong>:<br/>    - ReadWriteMany<br/>  <strong class="la hj">persistentVolumeReclaimPolicy:</strong> Retain <br/>  <strong class="la hj">hostPath:</strong><br/>      path: /var/local/data</span><span id="26c8" class="jp jq hi la b fi lo ll l lm ln">---</span><span id="060e" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">#PV using NFS-Share directory</strong></span><span id="ed13" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: pv-nfs<strong class="la hj"><br/></strong>spec:<br/>  capacity:<br/>    storage: 20Gi<br/>  accessModes:<br/>    - ReadWriteOnce<br/><strong class="la hj">  nfs:<br/>    path: /var/nfs_server/kubernetes_data<br/>    server: 10.25.96.6     </strong>#IP or DNS of nfs server</span></pre><p id="f08a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">Capacity</strong></code> <strong class="ih hj"> — </strong> PV会有一个特定的存储容量。这是使用PV的<em class="ks">容量</em>属性设置的。</p><p id="ac63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">accessModes</strong></code><strong class="ih hj">——</strong></p><blockquote class="kp kq kr"><p id="0ea6" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> ReadWriteOnce </strong> —卷可以通过单个节点以读写方式装载。<strong class="ih hj">read write only</strong>—<strong class="ih hj"/>卷可以由许多节点以只读方式装载。<br/> <strong class="ih hj">读写多</strong> —卷可以由许多节点以读写方式装载。<br/><strong class="ih hj">ReadWriteOncePod</strong>—<strong class="ih hj"/>卷可以通过单个Pod以读写方式挂载。</p></blockquote><p id="14a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">persistentVolumeReclaimPolicy</strong></code><strong class="ih hj">——</strong></p><blockquote class="kp kq kr"><p id="1c5b" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj">保留</strong> —关联pod终止后，卷将被保留。<br/> <strong class="ih hj">删除</strong> —关联pod终止后，卷将被删除。<br/> <strong class="ih hj">回收</strong> —卷将被回收以备将来使用。</p></blockquote><p id="ada9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，只有NFS和主机路径支持回收。AWS EBS、GCE PD、Azure Disk和Cinder卷支持删除。</p><p id="15d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">Volume Type</strong></code> — <br/>对卷类型有巨大的支持，比如<code class="du kx ky kz la b"><strong class="ih hj">hostPath</strong></code><strong class="ih hj"/><code class="du kx ky kz la b"><strong class="ih hj">nfs</strong></code><strong class="ih hj"/><code class="du kx ky kz la b"><strong class="ih hj">aws ebs</strong></code><strong class="ih hj"/><code class="du kx ky kz la b"><strong class="ih hj">azureDisk</strong></code><strong class="ih hj"/>等等。<a class="ae kw" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes" rel="noopener ugc nofollow" target="_blank">关于卷类型的更多信息</a></p><h2 id="ed1f" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak"> <em class="lp">创建一个持久的卷索赔(PVC) </em> </strong></h2><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="055b" class="jp jq hi la b fi lk ll l lm ln">---</span><span id="3273" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj"><em class="ks">#PVC without selector</em></strong></span><span id="5516" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/><strong class="la hj">kind: PersistentVolumeClaim</strong><br/>metadata:<br/>  name: myclaim<br/>spec:<br/>  <strong class="la hj">accessModes</strong>:<br/>    - ReadWriteMany<br/>  <strong class="la hj">resources</strong>:<br/>    requests:<br/>      storage: 50Mi</span><span id="9271" class="jp jq hi la b fi lo ll l lm ln">---</span><span id="6b88" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj"><em class="ks">#PVC with selector</em></strong></span><span id="9621" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: myclaim<br/>spec:<br/> <strong class="la hj"> accessModes:</strong><br/>    - ReadWriteMany<br/>  <strong class="la hj">resources:</strong><br/>    requests:<br/>      storage: 70Mi<br/> <strong class="la hj"> selector:</strong><br/>   <strong class="la hj"> matchLabels:</strong><br/>      storage-tier: standard</span></pre><p id="3e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">accessModes</strong></code> <strong class="ih hj"> — </strong> <a class="ae kw" href="#f08a" rel="noopener ugc nofollow">同PV。</a></p><p id="abf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">resources</strong></code> <strong class="ih hj"> — </strong>在这个字段中，pod <strong class="ih hj"> </strong>可以请求特定数量的存储资源。</p><p id="6c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">selector</strong></code> <strong class="ih hj"> — </strong>带有<code class="du kx ky kz la b"><strong class="ih hj">selector</strong></code>的索赔试图匹配现有的、无人认领的和可用的PV。带<code class="du kx ky kz la b"><strong class="ih hj">selector</strong></code>的PVC总是声称有<code class="du kx ky kz la b"><strong class="ih hj">matchLabels</strong></code> <strong class="ih hj"> </strong>和<code class="du kx ky kz la b"><strong class="ih hj">accessModes</strong></code>精确匹配的PV。</p><h2 id="bb7f" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">有约束力的</h2><p id="2dd4" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">用户创建一个PersistentVolumeClaim，其中包含请求的特定存储量和某些访问模式。主节点中的控制循环总是监视新的PV，找到匹配的PV(如果可能)，并将它们绑定在一起。</p><p id="9054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">绑定标准:</strong></p><p id="8925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">●<code class="du kx ky kz la b"><strong class="ih hj">accessMode</strong></code>PV和PVC之间必须匹配。</p><p id="735f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PVC请求的<code class="du kx ky kz la b"><strong class="ih hj">storage</strong></code>必须等于或小于PV的<code class="du kx ky kz la b"><strong class="ih hj">storage</strong></code>容量。平等的匹配将总是获得优先权。但是如果没有完全匹配，那么PVC将要求PV具有比PVC所要求的更大的存储容量。</p><blockquote class="kp kq kr"><p id="3da8" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><em class="hi"> 50Gi PV将匹配请求50Gi的PVC<br/>50Gi PV将匹配请求40Gi的PVC(如果不存在精确匹配)<br/> 50Gi PV将</em> <strong class="ih hj"> <em class="hi">而非</em> </strong> <em class="hi">匹配请求100Gi的PVC</em></p></blockquote><p id="094a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">●带有<code class="du kx ky kz la b"><strong class="ih hj">selector</strong></code>的PVC总是声称与<code class="du kx ky kz la b"><strong class="ih hj">labels</strong></code>和<code class="du kx ky kz la b"><strong class="ih hj">accessModes</strong></code>匹配的PV和存储容量匹配标准保持不变。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/402582d484045a680448f4aac14a0710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*SD8vXj5Tf9BmdMOTiHxzCw.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx">PV binding with PVC- Image-1</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/c6d7629bc39d892edf27561da6805602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*TErI6e8JGG-fxR-6B3V82w.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx">PV binding with PVC- Image-2</figcaption></figure><h2 id="acc9" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">用于PV和PVC的命令:</h2><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="48d4" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj"># For creating PV and PVC</strong></span><span id="b9bf" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">host~$ </strong> kubectl create -f &lt;file-name&gt;.yaml<br/><strong class="la hj">host~$ </strong> kubectl create -f pv.yaml<br/><strong class="la hj">host~$ </strong> kubectl create -f pvc.yaml<br/></span><span id="2d4e" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj"># For listing PV and PVC</strong></span><span id="e7d5" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">host~$ </strong> kubectl get pv<br/><strong class="la hj">host~$ </strong> kubectl get pvc<br/></span><span id="509d" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj"># For viewing details of PV and PVC</strong></span><span id="dfd1" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">host~$ </strong> kubectl describe pv &lt;pv-name&gt;<br/><strong class="la hj">host~$ </strong> kubectl describe pvc &lt;pvc-name&gt;<br/></span><span id="207b" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj"># For deleting PV and PVC (PVC should be deleted first)</strong></span><span id="d6b9" class="jp jq hi la b fi lo ll l lm ln"><strong class="la hj">host~$ </strong> kubectl delete pvc &lt;pvc-name&gt;<br/><strong class="la hj">host~$ </strong> kubectl delete pv &lt;pv-name&gt;<br/></span></pre><h2 id="b723" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">阶段</h2><p id="3193" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">PV将处于以下阶段之一:</p><blockquote class="kp kq kr"><p id="5933" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj">可用</strong> —尚未绑定到声明的自由资源。<br/> <strong class="ih hj">装订</strong> —该卷装订成册。<br/> <strong class="ih hj">发布</strong> —索赔已删除，但资源尚未回收。<br/> <strong class="ih hj">失败</strong> —卷的自动回收失败。</p></blockquote><h2 id="925a" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">使用PVC作为卷</strong></h2><p id="7b87" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">pod可以通过将声明用作卷来访问存储。声明必须与使用声明的Pod位于同一命名空间中。集群在Pod的名称空间中找到声明，搜索合适的匹配项并绑定它们。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="f566" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj"><em class="ks">#Usage of PVC as a Volumes</em></strong></span><span id="5532" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: web-server<br/>spec:<br/>  containers:<br/>    - name: nginx-webserver<br/>      image: nginx<br/>      volumeMounts:<br/>       - name: webserver-vol01<br/>         mountPath: "/usr/share/nginx/html"<br/>  volumes:<br/>    - name: webserver-vol01<br/>      <strong class="la hj">persistentVolumeClaim:</strong><br/><strong class="la hj">        claimName: myclaim</strong></span></pre><p id="4aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">概述— PV、PVC和PVC作为一个卷</strong></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="505a" class="jp jq hi la b fi lk ll l lm ln">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: pv-volume01<br/>spec:<br/><strong class="la hj">  capacity:<br/>    storage: 50Mi<br/>  accessModes:<br/>    - ReadWriteMany</strong><br/>  persistentVolumeReclaimPolicy: Retain<br/>  hostPath:<br/>      path: /var/local/data</span><span id="7ffc" class="jp jq hi la b fi lo ll l lm ln">---<br/> <br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/><strong class="la hj">  name: myclaim</strong><br/>spec:<br/><strong class="la hj">  accessModes:<br/>    - ReadWriteMany<br/>  resources:<br/>    requests:<br/>      storage: 50Mi</strong></span><span id="bd08" class="jp jq hi la b fi lo ll l lm ln">---</span><span id="fdf5" class="jp jq hi la b fi lo ll l lm ln">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: web-server<br/>spec:<br/>  containers:<br/>    - name: nginx-webserver<br/>      image: nginx<br/>      volumeMounts:<br/>       - name: webserver-vol01<br/>         mountPath: "/usr/share/nginx/html"<br/>  volumes:<br/>    - name: webserver-vol01<br/><strong class="la hj">      persistentVolumeClaim:<br/>        claimName: myclaim</strong></span></pre></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="eb82" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">动态预配置</strong></h2><p id="45fb" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">直到现在，PV都是我们自己从现有的存储中创造出来的。这就是所谓的静态供应。但是想象一下我们使用AWS-EBS作为存储解决方案的生产环境。每当一个pod需要存储时，我们都需要在AWS上手动提供EBS卷，然后使用该EBS卷配置一个PV。</p><p id="de69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在pod需要时自动配置卷会更方便，这就是<strong class="ih hj">存储类</strong>进入映像的原因。使用<strong class="ih hj">存储类</strong>，我们可以在AWS上动态配置EBS卷，并在提出索赔时将其附加到pod。</p><h2 id="2caa" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">存储类</strong></h2><p id="6d02" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Kubernetes存储类是一种Kubernetes存储机制，它允许我们在Kubernetes集群中动态地提供持久性卷(PV)。使用存储类，pod可以根据需求动态请求特定类型的存储。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/c47b126642deeffc9bd7de51dc23f229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBu97RZLzQ4KtQFHWa9ZWQ.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Dynamic Provisioning</figcaption></figure><p id="39d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个StorageClass都包含字段<code class="du kx ky kz la b">provisioner</code>、<code class="du kx ky kz la b">parameters</code>和<code class="du kx ky kz la b">reclaimPolicy</code>，当属于该类的持久卷需要动态配置时会用到这些字段。</p><p id="db2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">AWS EBS卷的存储类别(使用内部资源调配器)——</strong></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="7e66" class="jp jq hi la b fi lk ll l lm ln">apiVersion: storage.k8s.io/v1<br/><strong class="la hj">kind: StorageClass</strong><br/>metadata:<br/>  name: gp2-standard<br/><strong class="la hj">provisioner: kubernetes.io/aws-ebs </strong>  # Internal-provisioner<br/><strong class="la hj">parameters</strong>:<br/>  type: gp2<br/><strong class="la hj">reclaimPolicy</strong>: Retain<br/><strong class="la hj">volumeBindingMode</strong>: Immediate</span></pre><p id="7f34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">provisioner:</strong></code>storage class对象包含一个<code class="du kx ky kz la b"><strong class="ih hj">provisioner</strong></code>，它决定哪个卷插件将用于提供PV。Kubernetes提供<strong class="ih hj"> <em class="ks">内部</em> </strong>和<strong class="ih hj"> <em class="ks">外部</em> </strong> provisioners。<em class="ks">内部</em>置备程序也称为<em class="ks">“In-tree”</em>卷插件，这意味着它们的代码是核心Kubernetes代码的一部分，与核心Kubernetes二进制文件一起导入。我们还可以指定并运行一个<em class="ks">外部</em> provisioner，它也被定义为容器存储接口(CSI)。</p><p id="86db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">parameters:</strong></code>表示底层存储系统的属性。</p><p id="33ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">parameters:</strong></code>表示底层存储系统的属性。</p><p id="fd91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">reclaimPolicy:</strong></code> <strong class="ih hj"> </strong>可以是<code class="du kx ky kz la b">Delete</code>也可以是<code class="du kx ky kz la b">Retain</code>。默认为<code class="du kx ky kz la b">Delete</code></p><p id="693f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><strong class="ih hj">volumeBindingMode:</strong></code> <strong class="ih hj"> </strong>可以是<code class="du kx ky kz la b">Immediate</code>也可以是<code class="du kx ky kz la b">WaitForFirstConsumer</code></p><blockquote class="kp kq kr"><p id="de20" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><em class="hi">Immediate</em></code> <em class="hi"> —创建PVC后立即配置PV。<br/> </em> <code class="du kx ky kz la b"><em class="hi">WaitForFirstConsumer</em></code> <em class="hi"> —将延迟PV的供应，直到创建了使用PVC的Pod。</em></p></blockquote><p id="bcd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">AWS EBS卷的存储类别(使用CSI)——</strong></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="5fea" class="jp jq hi la b fi lk ll l lm ln">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  name: ebs-sc<br/><strong class="la hj">provisioner: ebs.csi.aws.com  </strong>#EBS CSI as provisioner<br/>volumeBindingMode: WaitForFirstConsumer</span></pre><p id="ff26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<a class="ae kw" href="https://kubernetes.io/docs/concepts/storage/storage-classes/" rel="noopener ugc nofollow" target="_blank">存储类</a>的更多信息</p><p id="a74e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储类不仅可以动态调配PV，还允许我们使用底层存储系统的不同参数创建不同类型的存储类。例如对于AWS EBS，有各种类型的EBS卷(<code class="du kx ky kz la b">gp2</code>、<code class="du kx ky kz la b">gp3</code>、<code class="du kx ky kz la b">io1</code>、<code class="du kx ky kz la b">io2</code>等)。此外，还可以进行各种配置，例如，为EBS卷启用加密、指定最小IOPS和最小吞吐量。</p><p id="76e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">具有不同参数的存储类示例— </strong></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="1456" class="jp jq hi la b fi lk ll l lm ln">---</span><span id="89d4" class="jp jq hi la b fi lo ll l lm ln">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/><strong class="la hj">  name: gp2-standard</strong><br/>provisioner: <!-- -->ebs.csi.aws.com<br/>parameters:<br/><strong class="la hj">  type: gp2</strong><br/>volumeBindingMode: Immediate<br/>reclaimPolicy: Retain</span><span id="cdf3" class="jp jq hi la b fi lo ll l lm ln">---</span><span id="66b3" class="jp jq hi la b fi lo ll l lm ln">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/><strong class="la hj">  name: io2-encrypted</strong><br/>provisioner: ebs.csi.aws.com   <br/>parameters:<br/><strong class="la hj">  type: io2<br/>  </strong><strong class="la hj">iopsPerGB</strong>: <strong class="la hj">"3000"</strong><br/>  <strong class="la hj">encrypted: "true"<br/></strong>volumeBindingMode: WaitForFirstConsumer<br/>reclaimPolicy: Delete</span></pre><p id="d7ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将测试EBS卷的动态资源调配。遵循以下步骤—</p><p id="1f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用下面的<a class="ae kw" href="https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/Demo-storageClass.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="ks">清单文件</em> </a>创建一个<em class="ks">存储类</em></p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="5975" class="jp jq hi la b fi lk ll l lm ln">k create -f <a class="ae kw" href="https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/Demo-storageClass.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/Demo-storageClass.yaml</a></span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="0acc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随后，创建一个<em class="ks">持久卷声明</em> (PVC)并将PVC作为一个卷附加到pod中。使用下面的<a class="ae kw" href="https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/pvc-pod.yaml" rel="noopener ugc nofollow" target="_blank">清单</a>文件—</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="8cb3" class="jp jq hi la b fi lk ll l lm ln">kubectl create -f <a class="ae kw" href="https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/pvc-pod.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/shamimice03/AWS_EKS-EBS_CSI/main/pvc-pod.yaml</a></span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><blockquote class="kp kq kr"><p id="949f" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">注意:</em> </strong>由于EBS卷只锁定到特定的AZ。因此，EBS卷和将运行pod的工作节点应该在同一个AZ中。</p></blockquote><p id="11ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">验证<br/> </strong>现在，验证我们之前部署的存储级、PVC和pod是否按预期工作。</p><pre class="je jf jg jh fd lg la lh li aw lj bi"><span id="bdc6" class="jp jq hi la b fi lk ll l lm ln"><strong class="la hj">&gt;</strong> kubectl get storageclass<br/><strong class="la hj">&gt;</strong> kubectl get pvc<br/><strong class="la hj">&gt;</strong> kubectl get pods</span></pre></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="4976" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><em class="hi"> Kubernetes存储是一个有点棘手的话题。我试图尽可能简单地解释，希望这篇文章能帮助你更清楚地了解Kubernetes储物。如果你觉得这篇文章有帮助，请不要忘记点击</em> <strong class="ih hj"> <em class="hi">点击</em> </strong> <em class="hi">和</em> <strong class="ih hj"> <em class="hi">点击</em> </strong> <em class="hi">按钮，帮助我写更多这样的文章。<br/>谢谢🖤 </em></p></blockquote></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="a7bb" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">参考</h2><div class="mc md ez fb me mf"><a href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">卷</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">容器中的磁盘上的文件是短暂的，这给运行在…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">kubernetes.io</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jn mf"/></div></div></a></div></div></div>    
</body>
</html>
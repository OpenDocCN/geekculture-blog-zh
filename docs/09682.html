<html>
<head>
<title>Implementing JSON Web Token (JWT) Authentication using Spring Security | A Detailed Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Security实现JSON Web Token (JWT)身份验证|详细演练</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-json-web-token-jwt-authentication-using-spring-security-detailed-walkthrough-1ac480a8d970?source=collection_archive---------0-----------------------#2021-12-23">https://medium.com/geekculture/implementing-json-web-token-jwt-authentication-using-spring-security-detailed-walkthrough-1ac480a8d970?source=collection_archive---------0-----------------------#2021-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bfbfc805c327e20b436bce950532c027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_zKqjikwDHSSSVZD"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">FLY:D</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="aa50" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="9417" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在本教程中，您将学习使用Spring Boot和Spring Security实现Json Web Token ( JWT)认证。首先，您将了解一些关于JWTs的基本理论，然后您将切换到动手模式，并在您的Spring应用程序中实现它。我会详细解释每一步，所以坚持到最后。</p><blockquote class="kr ks kt"><p id="34b1" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated"><strong class="jv hj">必读:</strong>如果你是JWTs新手，那就继续读下去。然而，如果你已经使用过jwt或者对它们有所了解，并且想要开始实现，那么点击<a class="ae iu" href="#b0bf" rel="noopener ugc nofollow">这里</a>。</p></blockquote><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/20a04054d7ffad8ebf0c1c975961cf36.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/0*TLC36VtogEVQs-8N"/></div></figure><h1 id="cf90" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><span class="l li lj lk bm ll lm ln lo lp di">W</span>JWT的帽子是什么？</h1><p id="0f74" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">JSON Web Token (JWT)是一个开放的互联网标准，用于在双方之间共享安全信息。这个令牌包含一个JSON“有效负载”,它使用加密算法进行了数字签名(使用私有秘密或公共/私有密钥)。数字签名使令牌不会被篡改，因为被篡改的令牌会失效。</p><p id="80d2" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">JWT看起来像这样</p><p id="50bd" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated"><strong class="jv hj">eyjhbgcioijiuzi 1 NII SINR 5 CCI 6 ikpxvcj 9 . eyjzdwiiixmjm 0 nty 3 odkwiiwibmftzsi 6 ikpvag 4g rg 9 liiwiawf 0 ijo xnte 2 mjm 5 mdiyfq . fgk 5 PCL 49k 3 jfncq 6 wztn 6t-ug 9 dv 4 hoyim 55 xtux8w</strong></p><p id="01b1" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">一段令人畏惧的文字，是吧？</p><p id="3a8b" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">如果你仔细观察，你会注意到两个句号(。)JWT中的符号。这些周期符号将JWT分成三个部分— <strong class="jv hj">报头、有效载荷和签名</strong>。</p><p id="caa6" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">JWT的一般形式是-&gt;<strong class="jv hj">header . payload . signature .</strong></p><h2 id="f0d0" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">页眉</h2><p id="0cc8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">令牌的第一部分，头是一个JSON对象，包含两个属性，<strong class="jv hj"> typ </strong>(表示令牌的类型，即JWT)和<strong class="jv hj"> alg </strong>(用于签名的算法)。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="3389" class="lq iw hi mf b fi mj mk l ml mm">{<br/>"typ": "JWT",<br/>"alg": "HS256"<br/>}</span></pre><p id="c3fd" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">这个JSON对象是Base64Url编码的，构成字符串的第一部分。</p><h2 id="b152" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">有效载荷</h2><p id="ae36" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">令牌的第二部分，即有效载荷，包含您希望使用此JWT传输的数据或“声明”。有一些明确的声明，如</p><ul class=""><li id="958f" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq ms mt mu mv bi translated"><strong class="jv hj">子</strong> —令牌的主题</li><li id="8be4" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated"><strong class="jv hj"> iss </strong> —令牌的发行者</li><li id="9d1e" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated"><strong class="jv hj"> exp </strong> —令牌的到期时间</li><li id="35db" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated"><strong class="jv hj"> aud </strong> —代币的受众</li></ul><p id="d467" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">您还可以添加两端都同意的自定义声明，并提供有关令牌的共享额外信息。在下面的例子中，“角色”是一个自定义声明。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="68b3" class="lq iw hi mf b fi mj mk l ml mm">{   <br/>  "sub": "john.doe@gmail.com",   <br/>  "iss": "ABC Pvt Ltd",   <br/>  "role": "ADMIN"<br/>}</span></pre><h2 id="d71e" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">签名</h2><p id="8184" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">签名是通过获取前两部分的编码字符串并将其与您的秘密一起传递给签名算法来创建的。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="37d7" class="lq iw hi mf b fi mj mk l ml mm">HMACSHA256(   <br/> base64UrlEncode(header) + "." + base64UrlEncode(payload),   <br/> secret<br/>)</span></pre><p id="0975" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">输出是您之前看到的JWT</p><h1 id="b0bf" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">JWT认证流程</h1><p id="90f6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">下图显示了JWT认证的流程。正如您在下图中看到的，服务器端没有存储任何东西。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/df8a130cab1f8f9c2bbc8844a92391d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkxbBKA58IAPVdiqm2A2ug.png"/></div></div></figure><h1 id="8986" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">行动（或活动、袭击）计划</h1><p id="7371" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">您将构建一个公开三个端点的REST API</p><ol class=""><li id="ae14" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq nc mt mu mv bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">/api/auth/register</strong></code> —创建并保存一个<code class="du nd ne nf mf b">User</code>实体对象，并使用使用该实体构建的JWT进行响应。</li><li id="5734" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq nc mt mu mv bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">/api/auth/login</strong></code> —验证用户凭证并生成JWT</li><li id="75c9" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq nc mt mu mv bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">/api/user/info</strong></code> —受保护的路由，为认证用户响应用户信息</li></ol><blockquote class="kr ks kt"><p id="86d4" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated"><strong class="jv hj">必读:在这里</strong>  <strong class="jv hj">可以找到这个GitHub资源库中完整的文档化代码- &gt; </strong> <a class="ae iu" href="https://github.com/senshiii/Spring-Security-JWT-Authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">。我建议您下载该项目，并仔细阅读几乎与每一行相关的注释，因为这些注释提供了“一切”的详细解释(包括作为先决条件您应该知道的基本内容)。你可以在上面分享的GitHub链接中找到下载和使用源代码的说明。</strong></a></p></blockquote><h1 id="c2be" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">设置项目</h1><p id="33e4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">是时候动手做一些事情了，看看所有这些都是如何操作的。要设置您的Spring Boot项目，请访问<a class="ae iu" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">入门网站</a>。确保您已经选择了<strong class="jv hj"> Maven </strong>项目和最新版本的Spring Boot(没有快照)。</p><p id="f396" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">添加以下依赖项:-</p><ol class=""><li id="5329" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq nc mt mu mv bi translated"><strong class="jv hj"> Spring Web </strong>:用于构建Web应用</li></ol><p id="42ac" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">2.<strong class="jv hj"> Spring Security </strong>:为您的应用程序增加安全性</p><p id="25e5" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">3.春季数据JPA :持续性</p><p id="992e" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">4.<strong class="jv hj"> H2数据库</strong>:内存数据库，用于存储我们的应用程序数据</p><p id="cce4" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">5.<strong class="jv hj"> Lombok </strong>:使用注释帮助减少样板代码</p><p id="060e" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">您可以随意填写<strong class="jv hj">神器</strong>、<strong class="jv hj">名称</strong>和<strong class="jv hj">描述</strong>字段。最后，它应该看起来像这样。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/eb864c817260e18af5c387d86505a556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xq1u5i-rg_DylyXIWFgjDA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Setting up Spring Boot project</figcaption></figure><p id="a518" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">点击Generate，它会下载一个包含启动文件的档案。提取文件，并在您喜欢的IDE中打开它们。这将是项目的文件结构</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="2863" class="lq iw hi mf b fi mj mk l ml mm">com<br/>    └───example<br/>        └───springsecurityjwttutorial<br/>            │   SpringSecurityJwtTutorialApplication.java<br/>            │<br/>            ├───controllers<br/>            │       AuthController.java<br/>            │       UserController.java<br/>            │<br/>            ├───entity<br/>            │       User.java<br/>            │<br/>            ├───models<br/>            │       LoginCredentials.java<br/>            │<br/>            ├───repository<br/>            │       UserRepo.java<br/>            │<br/>            └───security<br/>                    JWTFilter.java<br/>                    JWTUtil.java<br/>                    MyUserDetailsService.java<br/>                    SecurityConfig.java</span></pre><h1 id="e264" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">计划的执行</h1><h2 id="4f25" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">实体</h2><p id="b1fe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">首先让我们创建我们的用户实体。创建一个新的包<code class="du nd ne nf mf b"><strong class="jv hj">entity</strong></code>和一个类<code class="du nd ne nf mf b"><strong class="jv hj">User</strong></code>。这个类用id、email和密码字段定义了<code class="du nd ne nf mf b"><strong class="jv hj">User</strong></code> POJO。<code class="du nd ne nf mf b"><strong class="jv hj">@Entity</strong></code>注释将该类标记为一个实体，其他注释是Lombok注释，以减少样板代码(例如添加getters、setters、constructors等。).</p><blockquote class="kr ks kt"><p id="795e" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated"><strong class="jv hj">注意:</strong><code class="du nd ne nf mf b"><strong class="jv hj">@JsonProperty(access = JsonProperty.Access.WRITE<em class="hi">_ONLY</em>)</strong></code><strong class="jv hj"/>防止密码字段包含在JSON响应中。</p></blockquote><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="8f20" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.entity;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/>import lombok.Getter;<br/>import lombok.NoArgsConstructor;<br/>import lombok.Setter;<br/>import lombok.ToString;<br/><br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.GenerationType;<br/>import javax.persistence.Id;<br/><br/>@Entity<br/>@Getter<br/>@Setter<br/>@ToString<br/>@NoArgsConstructor<br/>public class User {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="ku">AUTO</em>)<br/>    private Long id;<br/><br/>    private String email;<br/><br/>    @JsonProperty(access = JsonProperty.Access.WRITE<em class="ku">_ONLY</em>)<br/>    private String password;<br/><br/>}</span></pre><h2 id="9b85" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">贮藏室ˌ仓库</h2><p id="3a71" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在我们有了实体，让我们创建一个持久化它的方法。新建一个<code class="du nd ne nf mf b"><strong class="jv hj">repository</strong></code> <strong class="jv hj"> </strong>包，新建一个<code class="du nd ne nf mf b"><strong class="jv hj">UserRepo</strong></code> <strong class="jv hj">接口。</strong>我们定义了一个自定义方法<code class="du nd ne nf mf b"><strong class="jv hj">findByEmail(String email)</strong></code> <strong class="jv hj"> </strong>，它根据用户的电子邮件来检索用户实体。(有点不言自明，嗯？\_(*.*)_/ )</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="f2ad" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.repository;<br/><br/>import com.example.springsecurityjwttutorial.entity.User;<br/>import org.springframework.data.jpa.repository.JpaRepository;<br/><br/>import java.util.Optional;<br/><br/>public interface UserRepo extends JpaRepository&lt;User, Long&gt; {<br/>    public Optional&lt;User&gt; findByEmail(String email);<br/>}</span></pre><p id="54fa" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">现在让我们转到最重要的部分—安全性</p><h2 id="8bf1" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">安全性</h2><p id="18c7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在我们做任何与安全相关的事情之前，让我们首先创建一个类来处理jwt的创建和验证。创建一个<code class="du nd ne nf mf b"><strong class="jv hj">security</strong></code> <strong class="jv hj"> </strong>包，并在其中创建一个<code class="du nd ne nf mf b"><strong class="jv hj">JWTUtil</strong></code> <strong class="jv hj"> </strong>类。要执行与JWT相关的操作，我推荐您使用<strong class="jv hj"> java-jwt </strong>包。要将包包含在您的项目中，请将以下依赖项添加到您的<code class="du nd ne nf mf b"><strong class="jv hj">pom.xml</strong></code>文件中，然后重新构建项目。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="e230" class="lq iw hi mf b fi mj mk l ml mm">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.auth0&lt;/groupId&gt;<br/>    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;<br/>    &lt;version&gt;3.18.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><blockquote class="kr ks kt"><p id="6f7d" class="jt ju ku jv b jw kv jy jz ka kw kc kd kx ky kg kh kz la kk kl lb lc ko kp kq hb bi translated"><strong class="jv hj">注意:</strong>最好从github站点复制依赖项，因为在您阅读本文时，最新版本可能会有所不同。你可以在这里  <strong class="jv hj">找到包<a class="ae iu" href="https://github.com/auth0/java-jwt" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">的github站点。</strong></a></strong></p></blockquote><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="971f" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.security;<br/><br/>import com.auth0.jwt.JWT;<br/>import com.auth0.jwt.JWTVerifier;<br/>import com.auth0.jwt.algorithms.Algorithm;<br/>import com.auth0.jwt.exceptions.JWTCreationException;<br/>import com.auth0.jwt.exceptions.JWTVerificationException;<br/>import com.auth0.jwt.interfaces.DecodedJWT;<br/>import org.springframework.beans.factory.annotation.Value;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.Date;<br/><br/>@Component<br/>public class JWTUtil {<br/><br/>    @Value("${jwt_secret}")<br/>    private String secret;<br/><br/>    public String generateToken(String email) throws IllegalArgumentException, JWTCreationException {<br/>        return JWT.<em class="ku">create</em>()<br/>                .withSubject("User Details")<br/>                .withClaim("email", email)<br/>                .withIssuedAt(new Date())<br/>                .withIssuer("YOUR APPLICATION/PROJECT/COMPANY NAME")<br/>                .sign(Algorithm.<em class="ku">HMAC256</em>(secret));<br/>    }<br/><br/>    public String validateTokenAndRetrieveSubject(String token)throws JWTVerificationException {<br/>        JWTVerifier verifier = JWT.<em class="ku">require</em>(Algorithm.<em class="ku">HMAC256</em>(secret))<br/>                .withSubject("User Details")<br/>                .withIssuer("YOUR APPLICATION/PROJECT/COMPANY NAME")<br/>                .build();<br/>        DecodedJWT jwt = verifier.verify(token);<br/>        return jwt.getClaim("email").asString();<br/>    }<br/><br/>}</span></pre><p id="0ae7" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">generateToken</strong></code>方法创建一个带有主题、发布者、发布时间和自定义声明“电子邮件”的令牌，第二种方法验证该令牌并提取电子邮件。为了让这个工作，你需要提供一个秘密。秘密是一个字符串(专用于您的项目/团队/公司),用于签署您的令牌。永远不要分享你的秘密。打开<code class="du nd ne nf mf b"><strong class="jv hj">resources/application.properties</strong></code>文件，添加以下属性。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="b237" class="lq iw hi mf b fi mj mk l ml mm">jwt_secret=REPLACE_THIS_WITH_YOUR_SECRET</span></pre><p id="4ad8" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">确保您选择一个随机的长字符串作为您的密码，以确保您的令牌的安全。一个行之有效的方法是让你的猫在键盘上跑(开个玩笑；p)</p><p id="1a32" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">现在让我们创建用户详细信息服务。使用一个<code class="du nd ne nf mf b"><strong class="jv hj">UserDetailsService</strong></code>来提供定制的实现，以获取试图在应用程序中进行身份验证的用户的详细信息。这在<code class="du nd ne nf mf b"><strong class="jv hj">loadUserByUsername</strong></code>方法中完成。如果没有找到这样的用户，就会抛出一个<code class="du nd ne nf mf b"><strong class="jv hj">UsernameNotFoundException</strong></code>。创建一个类<code class="du nd ne nf mf b"><strong class="jv hj">MyUserDetailsService</strong></code> <strong class="jv hj"> </strong>，它将实现<code class="du nd ne nf mf b"><strong class="jv hj">UserDetailsService</strong></code> <strong class="jv hj"> </strong>接口。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="564c" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.security;<br/><br/>import com.example.springsecurityjwttutorial.entity.User;<br/>import com.example.springsecurityjwttutorial.repository.UserRepo;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.security.core.authority.SimpleGrantedAuthority;<br/>import org.springframework.security.core.userdetails.UserDetails;<br/>import org.springframework.security.core.userdetails.UserDetailsService;<br/>import org.springframework.security.core.userdetails.UsernameNotFoundException;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.Collections;<br/>import java.util.Optional;<br/><br/>@Component<br/>public class MyUserDetailsService implements UserDetailsService {<br/><br/>    @Autowired private UserRepo userRepo;<br/><br/>    @Override<br/>    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {<br/>        Optional&lt;User&gt; userRes = userRepo.findByEmail(email);<br/>        if(userRes.isEmpty())<br/>            throw new UsernameNotFoundException("Could not findUser with email = " + email);<br/>        User user = userRes.get();<br/>        return new org.springframework.security.core.userdetails.User(<br/>                email,<br/>                user.getPassword(),<br/>                Collections.<em class="ku">singletonList</em>(new SimpleGrantedAuthority("ROLE_USER")));<br/>    }<br/>}</span></pre><p id="afdd" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">如果你想了解更多关于<code class="du nd ne nf mf b"><strong class="jv hj">UserDetailsService</strong></code>是如何工作的，以及Spring Security中的一般身份验证是如何工作的，请查看这里的&gt;<a class="ae iu" rel="noopener" href="/geekculture/spring-security-authentication-process-authentication-flow-behind-the-scenes-d56da63f04fa"/>。</p><p id="ea98" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">接下来让我们创建一个<code class="du nd ne nf mf b"><strong class="jv hj">JWTFilter</strong></code>。通过实现<code class="du nd ne nf mf b"><strong class="jv hj">OncePerRequestFilter</strong></code>接口，<code class="du nd ne nf mf b"><strong class="jv hj">JWTFilter</strong></code>将为每个请求运行，并检查授权头中是否存在承载令牌。如果令牌存在，将验证令牌，并通过使用<code class="du nd ne nf mf b"><strong class="jv hj">SecurityContextHolder</strong></code> <strong class="jv hj"> </strong>设置<code class="du nd ne nf mf b"><strong class="jv hj">SecurityContext</strong></code> <strong class="jv hj"> </strong>的认证属性，为该请求的用户设置认证数据。这就是JWT发挥作用的地方，它确保您已经过身份验证，并且可以访问需要您登录/身份验证的受保护资源。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="51ba" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.security;<br/><br/>import com.auth0.jwt.exceptions.JWTVerificationException;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br/>import org.springframework.security.core.context.SecurityContextHolder;<br/>import org.springframework.security.core.userdetails.UserDetails;<br/>import org.springframework.stereotype.Component;<br/>import org.springframework.web.filter.OncePerRequestFilter;<br/><br/>import javax.servlet.FilterChain;<br/>import javax.servlet.ServletException;<br/>import javax.servlet.http.HttpServletRequest;<br/>import javax.servlet.http.HttpServletResponse;<br/>import java.io.IOException;<br/><br/>@Component<br/>public class JWTFilter extends OncePerRequestFilter {<br/><br/>    @Autowired private MyUserDetailsService userDetailsService;<br/>    @Autowired private JWTUtil jwtUtil;<br/><br/>    @Override<br/>    protected void doFilterInternal(HttpServletRequest request,<br/>                                    HttpServletResponse response,<br/>                                    FilterChain filterChain) throws ServletException, IOException {<br/>        String authHeader = request.getHeader("Authorization");<br/>        if(authHeader != null &amp;&amp; !authHeader.isBlank() &amp;&amp; authHeader.startsWith("Bearer ")){<br/>            String jwt = authHeader.substring(7);<br/>            if(jwt == null || jwt.isBlank()){<br/>                response.sendError(HttpServletResponse.<em class="ku">SC_BAD_REQUEST</em>, "Invalid JWT Token in Bearer Header");<br/>            }else {<br/>                try{<br/>                    String email = jwtUtil.validateTokenAndRetrieveSubject(jwt);<br/>                    UserDetails userDetails = userDetailsService.loadUserByUsername(email);<br/>                    UsernamePasswordAuthenticationToken authToken =<br/>                            new UsernamePasswordAuthenticationToken(email, userDetails.getPassword(), userDetails.getAuthorities());<br/>                    if(SecurityContextHolder.<em class="ku">getContext</em>().getAuthentication() == null){<br/>                        SecurityContextHolder.<em class="ku">getContext</em>().setAuthentication(authToken);<br/>                    }<br/>                }catch(JWTVerificationException exc){<br/>                    response.sendError(HttpServletResponse.<em class="ku">SC_BAD_REQUEST</em>, "Invalid JWT Token");<br/>                }<br/>            }<br/>        }<br/><br/>        filterChain.doFilter(request, response);<br/>    }<br/>}</span></pre><p id="0687" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">要将这些放在一起并配置应用程序的安全性，创建一个类<code class="du nd ne nf mf b"><strong class="jv hj">SecurityConfig</strong></code></p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="33ac" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.security;<br/><br/>import com.example.springsecurityjwttutorial.repository.UserRepo;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.security.authentication.AuthenticationManager;<br/>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br/>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br/>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br/>import org.springframework.security.config.http.SessionCreationPolicy;<br/>import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br/>import org.springframework.security.crypto.password.PasswordEncoder;<br/>import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;<br/><br/>import javax.servlet.http.HttpServletResponse;<br/><br/>@Configuration<br/>@EnableWebSecurity<br/>public class SecurityConfig extends WebSecurityConfigurerAdapter {<br/><br/>    @Autowired private UserRepo userRepo;<br/>    @Autowired private JWTFilter filter;<br/>    @Autowired private MyUserDetailsService uds;<br/><br/>    @Override<br/>    protected void configure(HttpSecurity http) throws Exception {<br/>        http.csrf().disable()<br/>                .httpBasic().disable()<br/>                .cors()<br/>                .and()<br/>                .authorizeHttpRequests()<br/>                .antMatchers("/api/auth/**").permitAll()<br/>                .antMatchers("/api/user/**").hasRole("USER")<br/>                .and()<br/>                .userDetailsService(uds)<br/>                .exceptionHandling()<br/>                    .authenticationEntryPoint(<br/>                            (request, response, authException) -&gt;<br/>                                    response.sendError(HttpServletResponse.<em class="ku">SC_UNAUTHORIZED</em>, "Unauthorized")<br/>                    )<br/>                .and()<br/>                .sessionManagement()<br/>                .sessionCreationPolicy(SessionCreationPolicy.<em class="ku">STATELESS</em>);<br/><br/>        http.addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class);<br/>    }<br/><br/>    @Bean<br/>    public PasswordEncoder passwordEncoder() {<br/>        return new BCryptPasswordEncoder();<br/>    }<br/><br/>    @Bean<br/>    @Override<br/>    public AuthenticationManager authenticationManagerBean() throws Exception {<br/>        return super.authenticationManagerBean();<br/>    }<br/>}</span></pre><p id="bd9d" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">在配置中，需要注意的重要部分是</p><ul class=""><li id="97be" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq ms mt mu mv bi translated">“auth”路由请求被所有人授予访问权(这是很明显的，因为您需要访问登录和注册路由)</li><li id="04aa" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">“用户”路由请求只能由<code class="du nd ne nf mf b"><strong class="jv hj">MyUserDetailsService</strong></code>中设置的“用户”角色的认证用户访问</li><li id="782c" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">UserDetailsService是用定制的<code class="du nd ne nf mf b"><strong class="jv hj">MyUserDetailsService</strong></code> bean配置的</li><li id="6d2f" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">服务器被配置为在到达入口点时以未授权为由拒绝请求。如果达到这一点，则意味着当前请求需要身份验证，并且没有发现附加到当前请求的授权头的JWT令牌。</li><li id="cebf" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">JWTFilter被添加到过滤器链中，以便处理传入的请求。</li><li id="5a76" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">为密码编码器创建bean</li><li id="0f53" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq ms mt mu mv bi translated">在<code class="du nd ne nf mf b"><strong class="jv hj">AuthController</strong></code>中暴露将用于运行认证过程的认证管理器的bean</li></ul><h2 id="6750" class="lq iw hi bd ix lr ls lt jb lu lv lw jf ke lx ly jj ki lz ma jn km mb mc jr md bi translated">模型</h2><p id="75b3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">创建一个包<code class="du nd ne nf mf b"><strong class="jv hj">models</strong></code> <strong class="jv hj"> </strong>和创建一个类<code class="du nd ne nf mf b"><strong class="jv hj">LoginCredentials</strong></code> <strong class="jv hj"> </strong>。该类将用于接受来自请求主体的登录数据。这个类有两个简单的属性——email和password以及相关的Lombok注释。</p><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="6e6a" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.models;<br/><br/>import lombok.*;<br/><br/>@Getter<br/>@Setter<br/>@AllArgsConstructor<br/>@NoArgsConstructor<br/>@ToString<br/>public class LoginCredentials {<br/><br/>    private String email;<br/>    private String password;<br/><br/>}</span></pre><p id="87ac" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">最后，让我们一起来看看。创建一个<code class="du nd ne nf mf b"><strong class="jv hj">controllers</strong></code> <strong class="jv hj"> </strong>包。在包中，创建两个类</p><ul class=""><li id="c705" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq ms mt mu mv bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">AuthController</strong></code> —处理授权路由注册和登录。</li></ul><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="3302" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.controllers;<br/><br/>import com.example.springsecurityjwttutorial.entity.User;<br/>import com.example.springsecurityjwttutorial.models.LoginCredentials;<br/>import com.example.springsecurityjwttutorial.repository.UserRepo;<br/>import com.example.springsecurityjwttutorial.security.JWTUtil;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.security.authentication.AuthenticationManager;<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br/>import org.springframework.security.core.AuthenticationException;<br/>import org.springframework.security.crypto.password.PasswordEncoder;<br/>import org.springframework.web.bind.annotation.PostMapping;<br/>import org.springframework.web.bind.annotation.RequestBody;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>import java.util.Collections;<br/>import java.util.Map;<br/><br/>@RestController<br/>@RequestMapping("/api/auth")<br/>public class AuthController {<br/><br/>    @Autowired private UserRepo userRepo;<br/>    @Autowired private JWTUtil jwtUtil;<br/>    @Autowired private AuthenticationManager authManager;<br/>    @Autowired private PasswordEncoder passwordEncoder;<br/><br/>    @PostMapping("/register")<br/>    public Map&lt;String, Object&gt; registerHandler(@RequestBody User user){<br/>        String encodedPass = passwordEncoder.encode(user.getPassword());<br/>        user.setPassword(encodedPass);<br/>        user = userRepo.save(user);<br/>        String token = jwtUtil.generateToken(user.getEmail());<br/>        return Collections.<em class="ku">singletonMap</em>("jwt-token", token);<br/>    }<br/><br/>    @PostMapping("/login")<br/>    public Map&lt;String, Object&gt; loginHandler(@RequestBody LoginCredentials body){<br/>        try {<br/>            UsernamePasswordAuthenticationToken authInputToken =<br/>                    new UsernamePasswordAuthenticationToken(body.getEmail(), body.getPassword());<br/><br/>            authManager.authenticate(authInputToken);<br/><br/>            String token = jwtUtil.generateToken(body.getEmail());<br/><br/>            return Collections.<em class="ku">singletonMap</em>("jwt-token", token);<br/>        }catch (AuthenticationException authExc){<br/>            throw new RuntimeException("Invalid Login Credentials");<br/>        }<br/>    }<br/><br/><br/>}</span></pre><p id="987f" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">register</strong></code> <strong class="jv hj"> </strong>方法持久化实体，然后用JWT响应，<code class="du nd ne nf mf b"><strong class="jv hj">login</strong></code> <strong class="jv hj"> </strong>方法验证登录凭证，然后用JWT响应。</p><ul class=""><li id="874b" class="mn mo hi jv b jw kv ka kw ke mp ki mq km mr kq ms mt mu mv bi translated"><code class="du nd ne nf mf b"><strong class="jv hj">UserController</strong></code> —处理用户路线</li></ul><pre class="le lf lg lh fd me mf mg mh aw mi bi"><span id="120c" class="lq iw hi mf b fi mj mk l ml mm">package com.example.springsecurityjwttutorial.controllers;<br/><br/>import com.example.springsecurityjwttutorial.entity.User;<br/>import com.example.springsecurityjwttutorial.repository.UserRepo;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.security.core.context.SecurityContextHolder;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/><br/>@RestController<br/>@RequestMapping("/api/user")<br/>public class UserController {<br/><br/>    @Autowired private UserRepo userRepo;<br/><br/>    @GetMapping("/info")<br/>    public User getUserDetails(){<br/>        String email = (String) SecurityContextHolder.<em class="ku">getContext</em>().getAuthentication().getPrincipal();<br/>        return userRepo.findByEmail(email).get();<br/>    }<br/><br/><br/>}</span></pre><p id="9130" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">请注意，用户的电子邮件不作为输入。从<code class="du nd ne nf mf b"><strong class="jv hj">SecurityContext</strong></code> <strong class="jv hj"> </strong>中提取，作为<code class="du nd ne nf mf b"><strong class="jv hj">JWTFilter</strong></code>中设置的邮件</p><h1 id="c848" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">执行时间</h1><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/3eddf5c8dda3f93b77f344f8bbe683af.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*aef_brfFSjE_3M5VP4QnwQ.jpeg"/></div></figure><p id="df4a" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">在<a class="ae iu" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">上运行应用程序时，IntelliJ IDEA </strong> </a>，这是我得到的输出。看起来一切都很好。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/4a46f5afdbeba4643ea0e9ec093be924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ypE7PJ8YyenJXNni5W4BA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Starting the Spring Boot App</figcaption></figure><p id="f470" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">现在让我们提一些要求。为了发出请求，我将使用<a class="ae iu" href="https://www.postman.com/downloads/?utm_source=postman-home" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">邮递员</strong> </a>。</p><p id="5441" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">首先，让我们走登记路线。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/fa326d3bf6b0496514c24d3e779e9e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVb8PedoWgwPOX7RTzbojQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">HTTP Request for Registering a User and generating JWT</figcaption></figure><p id="33a1" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated"><strong class="jv hj">万岁！！您刚刚使用Spring Security生成了您的第一个JWT。现在让我们测试受保护的端点- &gt;用户端点。复制这个令牌，因为你很快就会需要它。</strong></p><p id="49c7" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">让我们在一个新的选项卡中创建一个对用户端点的请求，而不添加令牌。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/42b6e74d8d5fa0e34070c7894196dec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjiti5Utx_q9LVnTz_lDSA.png"/></div></div></figure><p id="4a93" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">如您所见，请求被拒绝，状态为“<strong class="jv hj">未授权</strong>”。</p><p id="d259" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">现在让我们添加令牌。为此，请转到“授权”选项卡，从下拉列表中选择“不记名令牌”,然后将复制的令牌粘贴到提供的框中。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/1b2280dbcebaaf76575bf7628bafb1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFViKYqM7foml1Vi7D86pw.png"/></div></div></figure><p id="a669" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">现在，如果您再次发送请求，您将看到以下内容</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/03549f325ea0bcd34f33f289ae6e1e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1O3UddJXRCyJM9TnQIdTw.png"/></div></div></figure><p id="2b48" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke ky kg kh ki la kk kl km lc ko kp kq hb bi translated">瞧吧！！现在你得到了用户数据。可以自行测试登录路径。</p><h1 id="ea1d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="9c73" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj">原来如此</strong>。现在，您可以使用Spring Boot安全性和Spring Boot完全实现JWT认证流程。</p><h1 id="1476" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">支持</h1><p id="4bc9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果你喜欢这篇文章，请跟随并鼓掌👏🏻因此，如果这篇文章对你有所帮助，请考虑给我买杯咖啡来支持我。这将帮助我写更多与技术和编码相关的文章，并尽我所能回馈社区。</p><h1 id="0b8c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">那么…再见…下次见！！🙋🏻‍♂️</h1><h1 id="60b1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">我的更多文章</h1><ol class=""><li id="be73" class="mn mo hi jv b jw jx ka kb ke nn ki no km np kq nc mt mu mv bi translated"><a class="ae iu" rel="noopener" href="/swlh/demystifying-the-folder-structure-of-a-react-app-c60b29d90836">揭秘React应用的文件夹结构</a> ( 58k+视图)</li><li id="4a00" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq nc mt mu mv bi translated"><a class="ae iu" rel="noopener" href="/geekculture/spring-security-authentication-process-authentication-flow-behind-the-scenes-d56da63f04fa"> Spring安全认证流程</a></li><li id="83cb" class="mn mo hi jv b jw mw ka mx ke my ki mz km na kq nc mt mu mv bi translated"><a class="ae iu" href="https://javascript.plainenglish.io/react-redux-deep-dive-state-management-in-react-with-redux-b9af8b039bcc" rel="noopener ugc nofollow" target="_blank"> React Redux深潜</a></li></ol></div></div>    
</body>
</html>
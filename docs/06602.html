<html>
<head>
<title>Event-driven cache service using Hasura Triggers and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hasura触发器和Redis的事件驱动缓存服务</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/event-driven-cache-service-using-hasura-triggers-and-redis-9a3eb7192808?source=collection_archive---------28-----------------------#2021-08-24">https://medium.com/geekculture/event-driven-cache-service-using-hasura-triggers-and-redis-9a3eb7192808?source=collection_archive---------28-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b72745089cf9ae13cbce993fe5d8dc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcAcEkBPPsATylmcZC18cg.png"/></div></div></figure><p id="974f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据维基百科，缓存是，</p><p id="2c94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">"缓存是一个存储数据的软件组件，以便将来对该数据的请求可以得到更快的服务；存储在缓存中的数据可能是早期计算的结果，也可能是存储在其他地方的数据的副本。当请求的数据可以在缓存中找到时，发生<em class="jo">缓存命中</em>，而当不能找到时，发生<em class="jo">缓存未命中</em>。通过从缓存中读取数据来服务缓存命中，这比重新计算结果或从较慢的数据存储中读取要快；因此，缓存可以处理的请求越多，系统的运行速度就越快。”</p><p id="0f89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们将使用Node.js、Redis和Hasura (Graphql)构建一个缓存解决方案。我们正在创建一个简单的API端点，它将通过连接两个或多个表来返回一些结果。</p><p id="7826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们使用Haura作为我们的后端服务器。尽管我们使用Hasura作为后端，但我们不会在这里使用Hasura Graphql端点。我们将使用express创建一个单独的API端点，用于为将要缓存的数据提供服务。Graphql缓存超出了本文的范围。</p><blockquote class="jp jq jr"><p id="d5fe" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">在这里，我们将探索如何扩展hasura触发器的功能来创建缓存服务。</p></blockquote><p id="c4f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Nodejs服务器包含我们将要缓存的API端点。API是两个表连接的结果，这两个表由客户独立修改。</p><blockquote class="jv"><p id="a691" class="jw jx hi bd jy jz ka kb kc kd ke jn dx translated">我们没有使用任何基于TTL的缓存策略，因为我们需要一个事件驱动的解决方案来使缓存无效。总是推荐你的缓存使用TTL。它将确保密钥总是无效的。</p></blockquote><p id="66e6" class="pw-post-body-paragraph iq ir hi is b it kf iv iw ix kg iz ja jb kh jd je jf ki jh ji jj kj jl jm jn hb bi translated">因此，只要连接表达式中的表发生变化，缓存就需要失效。否则，我们将提供陈旧的数据。所以我们的失效必须依赖于数据库模型。作为CRUD操作的一部分，我们可以编写几乎所有的失效代码。但是这使得我们的代码分散，几乎无法调试。所以这里我们把复杂的任务交给了Hasura。这意味着无论何时数据库表级别发生CRUD，我们都将使用Hasura来通知我们。Hasura有一个特性叫做<strong class="is hj">触发器</strong>，它可以通过监听一个表的创建、删除和更新操作来扩展你的业务逻辑。</p><p id="1b1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很好，因为我们可以创建单独的路由/服务来使缓存无效，并在那里写入所有与缓存相关的逻辑。可扩展的清洁解决方案。</p><p id="8c24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以让我们开始吧。假设您已经根据下面的模式设置了Hasura和Postgres。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/58a3c60bfedfae3ff7a00ef27ea9621b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjQpkhQSG1X75sd_RUatXw.png"/></div></div></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/df976dbb4b641a4e7000ebbbd210d940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXorcskTxS_fcVtY5GOJuQ.png"/></div></div></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/2cc8e90028c00db5d21f6de649a1255d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzfJyxnjWqQcHpWF-v5kkQ.png"/></div></div></figure><p id="3837" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面给出的是我们正在使用的模式的截图。这是非常基本的，不用担心索引和触发器。它们是在使用Hasura控制台生成表时自动创建的。</p><p id="3d02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用下面的查询来执行我们将要缓存的API端点。这个查询连接了<code class="du kr ks kt ku b">author, books and publisher</code>表。基本的东西。</p><pre class="kl km kn ko fd kv ku kw kx aw ky bi"><span id="d66b" class="kz la hi ku b fi lb lc l ld le">SELECT athrs.id as authorid,athrs.name as authorname, athrs.email as authoremail,bks.name as bookname,pbrs.publish_id as publisherid,pbrs.email as publisheremail from authors athrs  inner join books bks ON athrs.id=bks.authorid INNER JOIN publisher pbrs ON bks.publisherid=pbrs.id WHERE athrs.id=:authorId;</span></pre><p id="9de4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们编写一个中间件，它在收到请求时检查缓存数据，当出现未命中时，它会将请求转发给从数据库获取数据的中间件。</p><blockquote class="jp jq jr"><p id="8df3" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">在这个实现中，我们将缓存层创建为应用服务器的一部分，而不是一个单独的服务。但是我们可以很容易地把它取出来，作为一个单独的服务进行部署。</p></blockquote><p id="cfe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定下面的中间件代码，</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f1d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在为我们将要监听的表创建触发器。转到Hasura控制台，单击events选项卡并创建触发器。每当表上发生插入、更新和删除操作时，我们都可以创建一个触发器。选择您的业务逻辑所依赖的事件。在下面的截图中，我勾选了更新和删除触发操作。在示例中，我只在<code class="du kr ks kt ku b">author</code>表上添加了<code class="du kr ks kt ku b">author_update</code>触发器。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/798b7fb3ca9ee543612580c586f831fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2Q2QHPx4KVISYRPmQ98cA.png"/></div></div></figure><p id="b4e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前往chrome，打开网址和控制台。现在在网络选项卡上检查标题。在初始加载时，我们可以通过检查标头<code class="du kr ks kt ku b">x-cache: miss</code>来查看缓存未命中，如下图所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/2ea0d1c102621a0c086c372f17bde2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBqFg0ma2q8Eo78MHEQC8w.png"/></div></div></figure><p id="ba04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在再次重新加载，您可以看到标题指示缓存命中，<code class="du kr ks kt ku b">x-cache: hit</code>。当缓存未命中发生时，从数据库中提取数据，并将其添加到Redis中。下面给出的是截图。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/bd0991edb5fc6331c646e7f533de0017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1qdFLnRSCCCv6aNbXuUtQ.png"/></div></div></figure><p id="2814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们的缓存正在工作，让我们检查失效策略。更新作者表中的条目。我们可以通过Hasura控制台/使用SQL update语句进行更新，也可以使用控制台中的编辑功能。将表头更新到Hasura控制台后，单击event选项卡并选择您已经创建的触发器。在那下面，你可以看到<code class="du kr ks kt ku b">Invocation Logs</code>标签页如下图所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/0030187295b763942a38ce88983cd6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaDrSFqy1rL5qga0J2j-BQ.png"/></div></div></figure><p id="9330" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击它，您可以看到所有到我们配置的端点的交付尝试。然后到浏览器那里重新加载。现在检查一下，我们可以发现缓存已经失效，再次重新加载时，我们可以看到缓存命中。</p><p id="deb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的缓存失效工作得很好。这个实现看起来简洁高效。您可以根据自己的业务逻辑修改实现。每当创建新条目并预填充缓存时，您都可以运行复杂的查询。此外，您可以完全创建一个单独的缓存失效服务，并将所有逻辑移到那里。</p><p id="1f7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个教程有点啰嗦，需要哈苏拉的知识。Hasura是一个很棒的平台，它可以提高你的生产力，并将你的开发成本降低一半。如果你还没查过哈苏拉。请看这里的<a class="ae lk" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="8d61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果你喜欢我的工作并想支持它，</em> <a class="ae lk" href="https://www.buymeacoffee.com/sujesht" rel="noopener ugc nofollow" target="_blank"> <em class="jo">请我喝杯咖啡吧！</em> </a>回购的代码可以在<a class="ae lk" href="https://github.com/sujeshthekkepatt/hasura-redis-express-cache/tree/main" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>
<html>
<head>
<title>S.O.L.I.D Principle 5: Dependency inversion principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">南原则5:依赖性倒置原则</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/s-o-l-i-d-principle-5-dependency-inversion-principle-238276db379f?source=collection_archive---------22-----------------------#2021-10-16">https://medium.com/geekculture/s-o-l-i-d-principle-5-dependency-inversion-principle-238276db379f?source=collection_archive---------22-----------------------#2021-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c0c2f7d508e5d7fba908b353d25188b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hH3pwntwZ9H3fnf9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lukas Blazek</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0aa9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高级模块不应依赖低级模块:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="ad67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码示例中，我们有两个类:<code class="du jz ka kb kc b">AppComponent</code>，它是高级模块，依赖于<code class="du jz ka kb kc b">MySqlDBClass</code>。这个应用程序可能看起来工作正常，而且在很多情况下也确实如此。然而，低级类与高级类紧密耦合。这种情况会导致问题。</p><p id="d7a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有新的需求出现。例如，当我们必须用MongoDB服务器替换MySQL服务器时。有一个风险是，我们将不得不更改高级组件(在构造函数方法中，我们将不得不更改DB类定义),从而增加编码时间。</p><p id="421c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案是使两个模块的连接成为松耦合连接:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="cb67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可以看到<code class="du jz ka kb kc b">AppCompoent </code>不是直接连接到<code class="du jz ka kb kc b">MySqlDBClass </code>的，而是通过IDBClass接口连接的。在这种情况下，如果需要更改数据库并用MongoDBClass类替换MySqlDBClass，我们不需要更改<code class="du jz ka kb kc b">AppComponent </code>中的任何内容。</p><p id="7906" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以对整个模块执行单元测试。我们可以在一个场景中编写两个测试，而不需要修改<code class="du jz ka kb kc b">AppCompoent </code>类。</p></div></div>    
</body>
</html>
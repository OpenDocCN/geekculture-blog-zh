<html>
<head>
<title>Developing .NET Isolated Process Azure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发展中。NET隔离进程Azure函数</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/developing-net-isolated-process-azure-functions-5a1ff4acee46?source=collection_archive---------6-----------------------#2021-06-22">https://medium.com/geekculture/developing-net-isolated-process-azure-functions-5a1ff4acee46?source=collection_archive---------6-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="36cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用。NET隔离的进程函数，我们可以将。我们希望从Azure Functions运行时使用的. NET版本。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e925a26894a716d2ddb16062748a3dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*lAaftVU-whKgP1EK.png"/></div></figure><p id="670b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在一个独立的进程中运行我们的C# Azure函数，将。NET，我们在函数中使用的运行时版本是在⚡上开发的</p><p id="6a10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之前，我们必须开发具有彼此紧密集成的类库和宿主的函数。这意味着我们必须运行我们的。与Azure Functions运行时版本相同的. NET进程内。Azure Functions Runtime v3上的NET Core 3.x)。通过进程外函数，我们能够使用。NET 5和Azure Functions runtime的v3。</p><p id="39d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了在进程外运行函数的能力，我们可以在以下方面受益。</p><ul class=""><li id="2872" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">我们可以完全控制整个过程，从如何启动应用程序，到控制我们的功能配置。</li><li id="dfde" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">使用这个控件，我们可以使用电流。DI和中间件的. NET行为。</li><li id="221a" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">我们还将受益于更少的冲突，因此我们的程序集不会与宿主进程使用的不同版本的程序集冲突。</li></ul><h1 id="6eec" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">创建我们的功能</h1><p id="5010" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">为了从函数运行时创建一个进程外运行的函数，我们需要以下内容:</p><ul class=""><li id="236f" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">。安装了. NET 5.0</li><li id="de44" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">安装了Visual Studio 2019版本16.10或更高版本(确保您安装了Azure开发或ASP.NET和web开发工作负载)</li></ul><p id="9075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你安装了这些，在Visual Studio中创建一个新的Azure Function项目。创建项目时，请确保选择。NET 5(独立的),就像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/8178ed4093381cabdcc71f1e948f2503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HodNaH6yddxX3vK1.png"/></div></div></figure><p id="1ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个演示，我将创建一个简单的函数，它触发HTTP POST请求，并将一个项目插入Azure Cosmos DB容器。不完全改变我所知道的世界，但这里的目的是向你展示与Azure函数相比，隔离函数是如何工作的，Azure函数是作为一个<a class="ae lh" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-your-first-function-visual-studio" rel="noopener ugc nofollow" target="_blank"> C#类库函数</a>构建的。</p><h1 id="943b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">盒子里出来的是什么？</h1><p id="3de7" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">本质上，一个. NET独立功能项目是一个控制台应用程序。NET 5.0。您的解决方案资源管理器应该如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/bd62b8e0a1f2aaf86eaa87247771ea24.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/0*Gl-y3hcK9FAG0P6P.png"/></div></figure><p id="4c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里添加了几个文件，但是这些文件是为您生成的:</p><ul class=""><li id="8f8b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">。csproj文件</strong>。该文件将定义项目及其依赖项。</li><li id="768d" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> local.settings.json </strong>。这将存储应用程序设置、连接字符串和用于本地开发的设置。</li><li id="a3da" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> host.json文件</strong>。该文件包含函数应用程序中所有函数的全局配置选项。</li><li id="0a8b" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> Program.cs文件</strong>。这将是我们应用程序的入口点。</li></ul><h1 id="3607" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">启动和配置</h1><p id="01b0" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">通过Program.cs文件，我们可以启动我们的函数应用程序。我们现在可以直接访问主机实例，从而能够直接在主机上设置任何配置和依赖项，而不必创建单独的启动类来完成这项工作。</p><p id="f952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="0081" class="lo ka hi lk b fi lp lq l lr ls">using Microsoft.Azure.Cosmos;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.Extensions.Hosting;<br/>using System.IO;<br/><br/>namespace DemoIsolatedFunction<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main()<br/>        {<br/>            var host = new HostBuilder()<br/>                .ConfigureFunctionsWorkerDefaults()<br/>                .ConfigureAppConfiguration(config =&gt; config<br/>                    .SetBasePath(Directory.GetCurrentDirectory())<br/>                    .AddJsonFile("local.settings.json")<br/>                    .AddEnvironmentVariables())<br/>                .ConfigureServices(services =&gt;<br/>                {<br/>                    services.AddSingleton(sp =&gt;<br/>                    {<br/>                        IConfiguration configuration = sp.GetService&lt;IConfiguration&gt;();<br/>                        return new CosmosClient(configuration["CosmosDBConnectionString"]);<br/>                    });<br/>                })<br/>                .Build();<br/><br/>            host.Run();<br/>        }<br/>    }<br/>}</span></pre><p id="e21d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们使用一个新的HostBuilder对象来创建我们的主机实例，该对象将返回一个IHost实例，该实例异步运行以启动我们的函数。</p><p id="7cc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.workerhostbuilderextensions.configurefunctionsworkerdefaults?view=azure-dotnet&amp;preserve-view=true#Microsoft_Extensions_Hosting_WorkerHostBuilderExtensions_ConfigureFunctionsWorkerDefaults_Microsoft_Extensions_Hosting_IHostBuilder_" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">ConfigureFunctionsWorkerDefaults</strong></a>方法用于添加在进程外运行我们的函数应用程序所需的设置。这做了几件事，比如提供与Azure函数日志的集成，以及提供默认的gRPC支持。</p><p id="dac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用了<a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.hostbuilder.configureappconfiguration?view=dotnet-plat-ext-5.0&amp;preserve-view=true" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">ConfigureAppConfiguration</strong></a>方法来添加我们的函数应用程序所需的配置。在这里，我用它来使用我的<strong class="ih hj"> local.settings.json </strong>文件进行本地调试。</p><p id="f48e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.hostbuilder.configureservices?view=dotnet-plat-ext-5.0&amp;preserve-view=true" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">configure services</strong></a>方法允许我们在应用程序中注入我们需要的服务。在这里，我用它来注入我的Cosmos客户机的一个单体实例。</p><h1 id="5885" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我们的函数应用程序</h1><p id="e3ec" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们现在准备开始编写函数代码。这里，我只是在我的函数和POST请求中注入了我需要的服务，将Todo项插入到我的Cosmos DB容器中:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="49b2" class="lo ka hi lk b fi lp lq l lr ls">using DemoIsolatedFunction.Models;<br/>using Microsoft.Azure.Cosmos;<br/>using Microsoft.Azure.Functions.Worker;<br/>using Microsoft.Azure.Functions.Worker.Http;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.Logging;<br/>using Newtonsoft.Json;<br/>using System;<br/>using System.IO;<br/>using System.Net;<br/>using System.Threading.Tasks;<br/><br/>namespace DemoIsolatedFunction.Functions<br/>{<br/>    public class InsertTodo<br/>    {<br/>        private readonly IConfiguration _configuration;<br/>        private readonly CosmosClient _cosmosClient;<br/>        private readonly Container _todoContainer;<br/><br/>        public InsertTodo(<br/>            IConfiguration configuration,<br/>            CosmosClient cosmosClient)<br/>        {<br/>            _configuration = configuration;<br/>            _cosmosClient = cosmosClient;<br/>            _todoContainer = _cosmosClient.GetContainer(_configuration["DatabaseName"], _configuration["ContainerName"]);<br/>        }<br/><br/>        [Function("InsertTodo")]<br/>        public async Task&lt;HttpResponseData&gt; Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "Todo")] HttpRequestData req,<br/>            FunctionContext executionContext)<br/>        {<br/>            HttpResponseData response;<br/>            var logger = executionContext.GetLogger("InsertTodo");<br/>            logger.LogInformation("C# HTTP trigger function processed a request.");<br/><br/>            try<br/>            {<br/>                var request = await new StreamReader(req.Body).ReadToEndAsync();<br/><br/>                var todo = JsonConvert.DeserializeObject&lt;TodoItem&gt;(request);<br/>                todo.Id = Guid.NewGuid().ToString();<br/><br/>                await _todoContainer.CreateItemAsync(<br/>                    todo,<br/>                    new PartitionKey(todo.Id));<br/><br/>                response = req.CreateResponse(HttpStatusCode.OK);<br/>            }<br/>            catch (Exception ex)<br/>            {<br/>                logger.LogError($"Exception thrown: {ex.Message}");<br/>                response = req.CreateResponse(HttpStatusCode.InternalServerError);<br/>            }<br/><br/>            return response;<br/>        }<br/>    }<br/>}</span></pre><p id="5102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数使用HTTP触发器向Cosmos DB写入记录。独立函数中的HTTP触发器不同于旧版本的运行时，因为我们必须使用<a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.functions.worker.http.httprequestdata?view=azure-dotnet&amp;preserve-view=true" rel="noopener ugc nofollow" target="_blank"> HttpRequestData </a>和<a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.functions.worker.http.httpresponsedata?view=azure-dotnet&amp;preserve-view=true" rel="noopener ugc nofollow" target="_blank"> HttpResponseData </a>来访问请求和响应数据。</p><p id="9d0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进程外函数中，我们不能访问原始的HTTP请求和响应对象。进程外函数中发生的事情是，传入的HTTP请求消息被转换为HttpRequestData对象。从这里开始，数据由请求提供。</p><p id="32a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的帖子请求:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/f54fd8c7b021c4d5e58821b0564e537a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oQcznBTQyP_IPWyz.png"/></div></div></figure><p id="139d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个请求向HttpRequestData对象中的Body属性提供数据。</p><h1 id="e507" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">日志记录和执行上下文</h1><p id="c73c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们可以写入日志。NET独立函数。独立函数通过FunctionContext对象传递，该对象提供有关函数执行的信息。这里，我们可以调用GetLogger()方法，像这样传递函数名:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="4025" class="lo ka hi lk b fi lp lq l lr ls">var logger = executionContext.GetLogger("InsertTodo");<br/>logger.LogInformation("C# HTTP trigger function processed a request.");</span></pre><h1 id="f314" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">想了解更多？</h1><p id="8df4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">还有一些工作要做。NET隔离函数。与。NET 6将在11月的某个时候发布，那个版本可能是LTS版本，你可以开始使用了。NET 6与Azure Functions v4 (它处于早期预览，所以预计会有bug)。</p><p id="1970" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我对。NET隔离函数！🙌随着……的增加。NET版本的cadence，具有。NET版本与Azure运行时版本将提供的功能相分离。网络发展👩‍💻👨‍💻更灵活地使用中的最新功能。NET，而不是被运行库强加的限制所约束。</p><p id="2128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想了解更多关于。NET隔离进程作品，查看本文:<a class="ae lh" href="https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-guide#logging" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/azure-functions/dot NET-isolated-process-guide # logging</a></p><p id="cd70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你更喜欢亲自动手做代码，就按照这个教程:<a class="ae lh" href="https://docs.microsoft.com/en-us/azure/azure-functions/dotnet-isolated-process-developer-howtos?tabs=browser&amp;pivots=development-environment-vs" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/azure-functions/dot net-isolated-process-developer-how tos？tabs =浏览器&amp;pivots =开发-环境-vs </a></p><p id="0596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！💻☕</p></div></div>    
</body>
</html>
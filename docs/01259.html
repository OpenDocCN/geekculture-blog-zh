<html>
<head>
<title>Consistent Hashing | Distributing the server load</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致散列|分配服务器负载</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/consistent-hashing-99ea4caaa24d?source=collection_archive---------16-----------------------#2021-04-03">https://medium.com/geekculture/consistent-hashing-99ea4caaa24d?source=collection_archive---------16-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ec9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一致哈希是一种特殊的哈希，它使用的哈希函数随着哈希函数范围的变化而最小化变化。</p><p id="0a84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从哈希开始，然后我们将看到分布式哈希，它面临的问题是什么，以及一致哈希如何解决这些问题。</p><h1 id="0594" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">哈希是什么？</h1><p id="14ec" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">哈希是通过使用哈希函数将给定的键值转换为另一个值的过程。一个<strong class="ih hj">散列函数</strong>用于根据数学算法生成新值。散列函数的结果被称为<strong class="ih hj">散列值</strong>或<strong class="ih hj">散列值</strong>。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/9193cd7378942a044163173a2e904a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*4aVwVq4E_Ly5IhDO.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Hashing</figcaption></figure><p id="a735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的散列函数是使用<strong class="ih hj">单向</strong>散列算法的函数，或者换句话说，散列不能被转换回原始密钥。</p><h1 id="86a9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">分布式散列</h1><p id="22e1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是一种在给定资源之间分配任务的策略。假设在一个循环队列中有M个服务器和N个块。M个服务器被放置在M个不同点的环形队列中。</p><p id="bd75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要将服务器放置在M个不同的点，服务器id将被传入哈希函数以获得哈希值。在哈希值中执行mod操作，并将服务器放在块中(hash%N=server_block)。</p><p id="2de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当一个任务来了，它的键值在散列函数中传递，我们得到散列值，现在我们对这个散列值执行模运算(hash%N=i)，在模运算之后，我们得到I值。所以任务会加在第I块。现在这个任务将由最近的服务器按顺时针方向执行。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kw"><img src="../Images/f6035856daef794a216d12824353c7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7bGMpsvDWcCaOPvH8vICQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Distributed Hashing</figcaption></figure><p id="2a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这种方法有一个问题。假设其中一个服务器由于某种原因关闭了，那么会发生什么？</p><p id="1089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果其中一个服务器出现故障，那么按照建议的方法，顺时针方向寻找下一个最近的服务器。这导致该服务器的负载增加，这意味着负载分布不均匀。</p><p id="c44c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，一致性哈希开始发挥作用。</p><h1 id="166f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">一致散列法如何解决这个问题？</h1><p id="d5f3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该策略建议在分布式散列中在它们之间添加虚拟服务器。添加虚拟服务器并不意味着添加更多的服务器。这些虚拟服务器的工作是将任务重定向到其他服务器。</p><p id="9e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像分布式散列服务器id将在散列函数中传递，而虚拟服务器将在不同的块中传递。这里的不同之处在于，我们有多个散列函数。</p><p id="1725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有2个散列函数，M个服务器将被放置在2*M个不同的点上。这降低了在其中一个服务器出现故障的情况下使特定服务器过载的风险。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kx"><img src="../Images/5a06f3d0a23546ed62c865c9e03c86e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*mUO6SwgTRKKwpjUL"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Consistent Hashing</figcaption></figure><p id="baa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其余同<strong class="ih hj">分布式哈希</strong>所述，任务放在循环队列中，任务将由顺时针方向最近的虚拟服务器执行。</p><p id="d32f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>一致性哈希在很多地方使用，如<a class="ae ky" rel="noopener" href="/nerd-for-tech/all-about-database-sharding-scaling-up-the-database-3b6172491cd"> <strong class="ih hj"> <em class="kz">数据库分片(缩放数据库)</em> </strong> </a> <em class="kz">或</em> <strong class="ih hj"> <em class="kz">负载平衡器(在多个服务器中分配负载)</em> </strong></p></div></div>    
</body>
</html>
<html>
<head>
<title>RealityKit 911 — Custom Material with Metal shaders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RealityKit 911 —带有金属着色器的自定义材质</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/realitykit-911-custom-material-with-metal-shaders-e7e1f7077e69?source=collection_archive---------5-----------------------#2022-02-25">https://medium.com/geekculture/realitykit-911-custom-material-with-metal-shaders-e7e1f7077e69?source=collection_archive---------5-----------------------#2022-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c52738bc2946839779badc028d958ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcQFVYXwcc69P_hz2-psLw.png"/></div></div></figure><p id="0f54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RealityKit的可编程素材，名为<a class="ae jo" href="https://developer.apple.com/documentation/realitykit/custommaterial?changes=_5" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> CustomMaterials </em> </a>，在iOS 15及以后的版本中都有。这类材质使用两个特殊的金属函数来管理模型的<strong class="is hj"> <em class="jp">顶点_位置</em> </strong>和<strong class="is hj"> <em class="jp">像素_数据</em> </strong>。Apple Metal是用于与3D图形硬件交互的原生低级API。作为一名开发人员，你能够创建用金属着色器语言(MSL)编写的代码块，这实际上是C++的精简版本，它极大地改变了任何AR/VR材料的外观和感觉。</p><blockquote class="jq jr js"><p id="b9fe" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">根据苹果定义</em> </strong>:</p><p id="1abf" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">自定义材质允许您利用RealityKit的现有着色器管线来渲染支持自定义金属着色器功能的基于物理的或无光的材质。这些函数修改RealityKit呈现实体的方式。自定义材质支持两种不同类型的自定义金属着色器功能:几何体修改器和曲面着色器。</p><p id="d41d" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">RealityKit的第一种金属着色器是内置的片段着色器，它为每个屏幕像素触发一次。RealityKit的片段着色器调用您的表面着色器，这意味着表面着色器也为实体的每个片段(像素)调用一次。</p><p id="8a4f" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">RealityKit使用的另一种金属着色器是顶点着色器。顶点着色器为实体中的每个顶点触发一次。如果在创建自定义材质时提供几何体修改器，RealityKit的顶点着色器会调用它。几何体修改器为实体中的每个顶点触发一次。</p></blockquote><p id="b997" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，有了理论一切都清楚了，让我们继续实践吧。我们有一个默认的现实作曲家的场景与臭名昭著的钢铁盒子。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/af43c49ef277efe2b8066fd02e85120c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdmjSDeMBacFXFDkQBKOuA.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">Steel box in Reality Composer’s default scene</figcaption></figure><h2 id="4ee4" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">着色器.金属</h2><p id="e48c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">从Xcode 11开始，模拟器应用程序中添加了金属开发支持，因此我们不必每次进行微小的更改时都在真实的iOS设备上运行我们的RealityKit应用程序。</p><p id="9652" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们必须在金属中创建一个表面着色器。表面着色器与几何体修改器一样，必须在具有<em class="jp"> [[visible]] </em>属性的函数内部。</p><p id="1908" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“<em class="jp"> basicShader </em>”函数的意思很简单:我希望纹理的颜色随着时间不断变化。为了做到这一点，我使用了三角函数<strong class="is hj"> <em class="jp"> sin() </em> </strong>和<strong class="is hj"> <em class="jp"> cos() </em> </strong>，这两个函数都形成了一个正弦波，但是有90度的偏移。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/cdc28837dc3e4e3d33e3abf4b138b91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cj48xMPHHMIuD2HUfrMD5A.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">Sinusoidal waveforms with negative and positive half waves</figcaption></figure><p id="c980" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查代码。对于<strong class="is hj"> <em class="jp">红色</em> </strong>和<strong class="is hj"> <em class="jp">绿色</em> </strong>通道，我取了这些函数返回的绝对值(只是正值)。<strong class="is hj"> <em class="jp">蓝色</em> </strong>通道的值是简单数学运算的结果。</p><pre class="jx jy jz ka fd lg lh li lj aw lk bi"><span id="d67c" class="kf kg hi lh b fi ll lm l ln lo"><strong class="lh hj">#include</strong> &lt;metal_stdlib&gt;<br/><strong class="lh hj">#include</strong> &lt;RealityKit/RealityKit.h&gt;</span><span id="74fc" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj">using namespace </strong>metal;</span><span id="b97f" class="kf kg hi lh b fi lp lm l ln lo">[[<strong class="lh hj">visible</strong>]]<br/><strong class="lh hj">void</strong> basicShader(realitykit::surface_parameters shader)<br/>{<br/>    realitykit::surface::surface_properties ssh = shader.surface();<br/>    <strong class="lh hj">float</strong> time = shader.uniforms().time();</span><span id="eacf" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj">    half</strong> r = abs(cos(time * 2.5));<br/>    <strong class="lh hj">half</strong> g = abs(sin(time * 5.0));<br/>    <strong class="lh hj">half</strong> b = abs(r - (g * r));</span><span id="aa1e" class="kf kg hi lh b fi lp lm l ln lo">    ssh.set_base_color(<strong class="lh hj">half3</strong>(r, g, b));</span><span id="bca0" class="kf kg hi lh b fi lp lm l ln lo">    ssh<!-- -->.set_metallic(<strong class="lh hj">half</strong>(<!-- -->1.0));<br/>    <!-- -->ssh<!-- -->.set_roughness(<strong class="lh hj">half</strong>(<!-- -->0.0));<br/>    <!-- -->ssh.set_clearcoat(<strong class="lh hj">half</strong>(1.0));<br/>    ssh.set_clearcoat_roughness(<strong class="lh hj">half</strong>(0.0));<br/>}</span></pre><p id="cff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看图表，找出数学是如何影响正弦波的。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/19659cbd47f1353b7fd4a63b3f09696e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RSZhkvShm0Hfq9qJ9UC-Q.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">Resulted graphs for Red, Green and Blue channels</figcaption></figure><p id="f4a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在www.desmos.com<a class="ae jo" href="https://www.desmos.com/calculator" rel="noopener ugc nofollow" target="_blank">实验任何三角函数。</a></p><p id="70c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个金属功能是关于定位。这里数学背后的一般思想是让顶点改变它们的位置，所以我们可以移动模型的一部分或整个模型。酷吗？</p><p id="1b94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码是geometry modifier，所有的参数都是不言自明的，因为我们使用了与前面的函数相同的原理。</p><p id="65fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你唯一要记住的是，金属的<strong class="is hj"> <em class="jp">规格化设备坐标</em> </strong> (NDC)从负1.0到正1.0(对于X和Y轴)，其中原点<strong class="is hj"> <em class="jp"> (0.0，0.0) </em> </strong>是模型的中心，对于Z轴，范围是0.0到+1.0(所以，正的Z值远离相机)。</p><p id="8708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">由此可见，NDC的中心是(0.0，0.0，0.5) </em>。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/7d0e889fe7f5b19d594c98e4ef7b08c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tb6t2g88oxVWYkW3fT77Mw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">Left-handed NDC coordinate system of Apple Metal</figcaption></figure><p id="87a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用<strong class="is hj"> <em class="jp">偏移</em> </strong>属性为立方体模型应用椭圆轨道。</p><pre class="jx jy jz ka fd lg lh li lj aw lk bi"><span id="2bf4" class="kf kg hi lh b fi ll lm l ln lo">[[<strong class="lh hj">visible</strong>]]<br/><strong class="lh hj">void</strong> basicModifier(realitykit::geometry_parameters modifier)<br/>{<br/>    <strong class="lh hj">float3</strong> pose = modifier.geometry().model_position();<br/>    <strong class="lh hj">float</strong> time = modifier.uniforms().time();<br/>    <strong class="lh hj">float</strong> speed = 1.5f;<br/>    <strong class="lh hj">float</strong> amplitude = 0.1f;<br/>    <strong class="lh hj">float</strong> offset = 0.05f;</span><span id="b2d4" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj">    float</strong> cosTime = (cos(time * speed)) * amplitude;<br/>    <strong class="lh hj">float</strong> sinTime = (sin(time * speed)) * (amplitude + offset);</span><span id="2114" class="kf kg hi lh b fi lp lm l ln lo">    modifier.geometry().set_model_position_offset(<br/>        <strong class="lh hj">float3</strong>(cosTime, sinTime, pose.z + 0.1)<br/>    );<br/>}</span></pre><h2 id="fa6f" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">ViewController.swift</h2><p id="5451" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">迅捷的部分并不复杂。首先，我们声明MTLDevice的一个实例。它可以被认为是我们与GPU的直接连接。然后我们声明两个着色器函数所在的金属库的实例。代码的另一部分你很熟悉，因为它是RealityKit材料的常规赋值。顺便说一句，我用物理方法实现了永久旋转，而不是动画。</p><pre class="jx jy jz ka fd lg lh li lj aw lk bi"><span id="2492" class="kf kg hi lh b fi ll lm l ln lo"><strong class="lh hj">import</strong> UIKit<br/><strong class="lh hj">import</strong> RealityKit<br/><strong class="lh hj">import</strong> Metal</span><span id="eff6" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj">class</strong> ViewController: UIViewController {</span><span id="c92b" class="kf kg hi lh b fi lp lm l ln lo">    <strong class="lh hj">@IBOutlet var</strong> arView: ARView!</span><span id="903b" class="kf kg hi lh b fi lp lm l ln lo">    <strong class="lh hj">override func</strong> viewDidLoad() {<br/>        <strong class="lh hj">super</strong>.viewDidLoad()</span><span id="d07f" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">self</strong>.arView.environment.background = .color(.darkGray)</span><span id="81ce" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">let</strong> boxScene = <strong class="lh hj">try</strong>! Experience.loadBox()<br/>        boxScene.children[0].scale *= 5.0</span><span id="6173" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">let</strong> box = boxScene.steelBox!.children[0] <strong class="lh hj">as</strong>! ModelEntity</span><span id="6266" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj"><em class="jp">// Metal device and library</em></strong><br/>        <strong class="lh hj">let</strong> device = MTLCreateSystemDefaultDevice()</span><span id="e3e5" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">guard let</strong> defaultLibrary = device!.makeDefaultLibrary()<br/>        <strong class="lh hj">else</strong> { <strong class="lh hj">return</strong> }</span><span id="0f75" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">let</strong> shader = CustomMaterial.SurfaceShader(<br/>                                           named: "<em class="jp">basicShader</em>",<br/>                                              in: defaultLibrary)</span><span id="8bb5" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">let</strong> modifier = CustomMaterial.GeometryModifier(<br/>                                           named: "<em class="jp">basicModifier</em>",<br/>                                              in: defaultLibrary)</span><span id="67c8" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj">        do</strong> {<br/>            box.model?.materials[0] = <strong class="lh hj">try</strong> CustomMaterial(<br/>                                            surfaceShader: shader,<br/>                                         geometryModifier: modifier,<br/>                                            lightingModel: <strong class="lh hj">.lit</strong>)<strong class="lh hj"><br/>        </strong>} <strong class="lh hj">catch</strong> {<br/>            print("<em class="jp">Can't find Custom material</em>")<br/>        }</span><span id="f365" class="kf kg hi lh b fi lp lm l ln lo">        <strong class="lh hj">self</strong>.arView.scene.anchors.append(boxScene)</span><span id="5c9a" class="kf kg hi lh b fi lp lm l ln lo"><strong class="lh hj"><em class="jp">        //</em></strong> <strong class="lh hj"><em class="jp">Rotation about Y axis</em></strong> <br/>        box.components[PhysicsBodyComponent.<strong class="lh hj">self</strong>] = .init()<br/>        box.components[PhysicsMotionComponent.<strong class="lh hj">self</strong>] = .init()<br/>        box.physicsBody?.massProperties.mass = 0.0<br/>        box.physicsMotion?.angularVelocity.y = 1.0<br/>        box.generateCollisionShapes(recursive: <strong class="lh hj">true</strong>)<br/>    }<br/>}</span></pre><h1 id="9538" class="ls kg hi bd kh lt lu lv kl lw lx ly kp lz ma mb ks mc md me kv mf mg mh ky mi bi translated">结果</h1><p id="e404" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们有什么？我们有三种颜色的动画循环——现代绿、芥末金和高贵紫，金属表面有透明涂层。我们得到了一个平行六面体沿着椭圆轨道的运动。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/d7541a7ee69d728d5c03ee123115bd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieK9Kc4f2sNz4HR4WBF3Tg.png"/></div></div></figure><h1 id="897a" class="ls kg hi bd kh lt lu lv kl lw lx ly kp lz ma mb ks mc md me kv mf mg mh ky mi bi translated">捐赠给作者</h1><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/c0650a189c6fb3281d999d5e2342f8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79QZO5t3vV-z7yeDjw2dvQ.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">Click on the picture to make the QR code bigger</figcaption></figure><pre class="jx jy jz ka fd lg lh li lj aw lk bi"><span id="aebd" class="kf kg hi lh b fi ll lm l ln lo">addr1q9w70n62nu8p7f9ukfn66gzumm9d9uxwppkx7gk7vd7gy0ehfavj97gkncwm8t8l8l8x9e4adzmw2djh4y5gd9rmtewqr99zr3</span></pre><p id="57de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前就这些。</p><p id="3541" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这篇帖子对你有用，请按下<strong class="is hj"> <em class="jp">拍</em> </strong>按钮，按住<strong class="is hj"><em class="jp"/></strong>即可。在Medium上，每个帖子最多可以拍50次<strong class="is hj"><em class="jp"/></strong>。</p><p id="4624" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在我在<a class="ae jo" href="https://stackoverflow.com/users/6599590/andy-fedoroff" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上的帖子中找到更多关于ARKit、RealityKit和SceneKit的信息。</p><p id="26a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后会有期！</p></div></div>    
</body>
</html>
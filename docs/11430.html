<html>
<head>
<title>Simple &amp; Performant State Management without an External Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单高效的状态管理，无需外部库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simple-performant-state-management-without-an-external-library-786f5d2b34a8?source=collection_archive---------4-----------------------#2022-03-22">https://medium.com/geekculture/simple-performant-state-management-without-an-external-library-786f5d2b34a8?source=collection_archive---------4-----------------------#2022-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5e8f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Flutter的继承通知程序</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b6ffc96e741e903100b767229c8c6387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlC8RmbUWYphqE0UNcPvDg.jpeg"/></div></div></figure><h1 id="8681" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="fcaf" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">颤振中的状态管理很好玩！好吧，如果你有任何在Flutter中实现状态管理的经验，或者如果你目前正试图学习这个主题，你可能不同意这种说法。我不怪你！虽然我确实喜欢挑战，但这个挑战有时看起来相当令人畏惧和乏味。</p><p id="dd39" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">幸运的是，有几个很棒的包可以让管理大型应用程序的状态变得更加容易。(向<a class="ae lc" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">供应商</a> / <a class="ae lc" href="https://pub.dev/packages/riverpod" rel="noopener ugc nofollow" target="_blank"> riverpod </a>和<a class="ae lc" href="https://pub.dev/packages/bloc" rel="noopener ugc nofollow" target="_blank"> bloc </a>喊出！)它们还提供了支持可测试性的强大功能。如果你还不熟悉的话，<code class="du ld le lf lg b">provider</code> is基于<code class="du ld le lf lg b">InheritedWidget</code> s，这是Flutter处理状态的内置方法，它允许我们在<em class="lh">窗口小部件树</em>中找到更高的对象，而不是一个窗口小部件一个窗口小部件地向下传递。<code class="du ld le lf lg b">riverpod</code>是对需要重写的<code class="du ld le lf lg b">provider</code>的改进，因此是一个新的包，<code class="du ld le lf lg b">bloc</code>是一种状态管理方法，有助于实现<em class="lh"> BLoC </em>设计模式，代表<em class="lh">业务逻辑组件</em>。是围绕<code class="du ld le lf lg b">Stream</code> s打造的。</p><p id="ffff" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">同样，所有这些包都很棒，它们肯定对大型项目非常有用，尤其是它们提供的测试功能。<code class="du ld le lf lg b">bloc</code>特别是，根据我的经验，集成了许多其他可以使开发过程更容易的包，例如，<a class="ae lc" href="https://pub.dev/packages/hydrated_bloc" rel="noopener ugc nofollow" target="_blank"> hydrated_bloc </a>，它处理对磁盘的持久状态更改。然而，对于固态管理解决方案来说，这些功能强大的软件包实际上并不是必需的。特别是，它们对于较小的项目来说是多余的，而且恰好Flutter已经具备了创建一个强大的状态管理解决方案所需要的一切。</p><p id="e12f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们当然会使用<code class="du ld le lf lg b">InheritedWidget</code> s来管理我们应用的状态。<strong class="kd hj">等等！不要关闭标签页！如果您找到了这篇文章，我相信您已经对这种方法有了一些非常强烈的看法。<em class="lh">“太复杂了。”“可维护性差。”“样板文件太多了！”</em>我明白你的意思，但是如果我告诉你，用<code class="du ld le lf lg b">InheritedWidget</code>的子类，我们要用<em class="lh"> 40行或更少的代码</em>编写一个<strong class="kd hj"> <em class="lh">高性能的、适应性强的&amp;可重用的</em> </strong>状态管理解决方案呢？回来了？很好！希望你在这个过程中也能学到一些很酷的东西。我们开始吧！</strong></p><h1 id="b0d1" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">InheritedWidget</h1><p id="c2e3" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先，让我们谈一点关于<code class="du ld le lf lg b">InheritedWidget</code>的事情。这些只是专门的<code class="du ld le lf lg b">Widget</code>，它们被设计用来保存数据，并使其容易被<em class="lh">小部件树</em>中<code class="du ld le lf lg b">InheritedWidget</code>下面的任何<code class="du ld le lf lg b">Widget</code>访问。这避免了我们必须通过20个<code class="du ld le lf lg b">Widget</code>构造函数来传递数据，这样树中的第21个<code class="du ld le lf lg b">Widget</code>才能访问它。相反，使用<code class="du ld le lf lg b">InheritedWidget</code> s，我们可以通过遍历小部件树直接从第21个<code class="du ld le lf lg b">Widget</code>开始查找数据。然而，<code class="du ld le lf lg b">InheritedWidget</code> s是<em class="lh">不可变的</em>，这意味着变量必须是<em class="lh"> final </em>，所以考虑如何更新树中更下面的小部件的数据可能会很棘手。这意味着我们实际上必须将数据存储在<code class="du ld le lf lg b">InheritedWidget</code>之上的<code class="du ld le lf lg b">Widget</code>中，并且如果需要更改的话，以允许<em class="lh">可变性</em>的方式提供对它的访问。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="df3d" class="lm jk hi lg b fi ln lo l lp lq"><strong class="lg hj">NOTE:</strong> The conventional method used to provide access to InheritedWidget data throughout the tree is via a <em class="lh">static of(BuildContext) </em>method, as seen by Theme.of(context).</span></pre><p id="6e48" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我不打算进入实现一个<code class="du ld le lf lg b">InheritedWidget</code>的复杂过程，在这个过程中我们可以从它的依赖项中更新数据。这篇文章是关于一个更好(也更容易！)方法。但是我应该指出，当数据不会从下面改变时，<code class="du ld le lf lg b">InheritedWidget</code>非常适合向后代提供数据。例如，向复杂的<code class="du ld le lf lg b">Dialog</code>提供数据，或者定义一个主题供后代使用。我们都在Flutter中与<code class="du ld le lf lg b">Theme</code>合作过，它实际上是一个做后者的<code class="du ld le lf lg b">InheritedWidget</code>。如果您感兴趣，这里的<a class="ae lc" href="https://gist.github.com/theLee3/760ea404aea307cb4daf4f8aa692fc40" rel="noopener ugc nofollow" target="_blank"/>是一个简单的<code class="du ld le lf lg b">InheritedWidget</code>示例，它近似于<code class="du ld le lf lg b">Theme</code>的行为。它与本文的其余部分没有关系。</p><p id="0c1d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果我们希望为后代提供更新主题的能力，我们有两个同样难看的选项:</p><ol class=""><li id="00b8" class="lr ls hi kd b ke kx kh ky kk lt ko lu ks lv kw lw lx ly lz bi translated">我们向<code class="du ld le lf lg b">InheritedWidget</code>传递一个回调，允许它调用<code class="du ld le lf lg b">setState</code>，同时编写一堆额外的样板文件来处理数据的设置/获取。更糟糕的副作用是，我们必须从静态<code class="du ld le lf lg b">of</code>函数返回<code class="du ld le lf lg b">InheritedWidget</code>，而不是实际数据。</li><li id="19b9" class="lr ls hi kd b ke ma kh mb kk mc ko md ks me kw lw lx ly lz bi translated">我们将<code class="du ld le lf lg b">State</code>作为数据传递给<code class="du ld le lf lg b">InheritedWidget</code>，从<code class="du ld le lf lg b">of</code>函数返回，并在整个应用程序中直接操作它。啊！</li></ol><p id="c1e0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这两种方法都意味着访问数据的代码更难看、更冗长。还好有一个好得多的解决方案！</p><h1 id="8908" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">继承通知程序</h1><p id="2421" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><code class="du ld le lf lg b">InheritedNotifier</code>是<code class="du ld le lf lg b">InheritedWidget</code>的一个子类，专门用于存储一个<code class="du ld le lf lg b">Listenable</code>对象，并在数据改变时更新其依赖对象。它的效率也很高。如果在两个帧之间发生多次更改，从属对象仍然只重建一次。至于我们的<code class="du ld le lf lg b">Listenable</code>，我们可以用一个<code class="du ld le lf lg b">ValueNotifier</code>来表示单个值，用一个<code class="du ld le lf lg b">ChangeNotifier</code>来表示更复杂的数据类，甚至用一个<code class="du ld le lf lg b">Animation</code>来同步多个对象之间的共享动画。后者的一个例子可以在Flutter文档<a class="ae lc" href="https://api.flutter.dev/flutter/widgets/InheritedNotifier-class.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们将扩展<code class="du ld le lf lg b">ChangeNotifier</code>来创建我们的应用程序状态数据类。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="b55e" class="lm jk hi lg b fi ln lo l lp lq"><strong class="lg hj">NOTE:</strong> ValueNotifier is a subclass of ChangeNotifier, so our solution will accommodate both.</span></pre><h2 id="813c" class="lm jk hi bd jl mf mg mh jp mi mj mk jt kk ml mm jv ko mn mo jx ks mp mq jz mr bi translated">表演</h2><p id="71d0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果你在迄今为止的状态管理研究中听说过<code class="du ld le lf lg b">ChangeNotifier</code>，你可能已经遇到过与其他方法相比的性能讨论。<code class="du ld le lf lg b">Listenable</code>的工作方式是存储一个<code class="du ld le lf lg b">Listener</code>列表，并在发生变化时逐个通知它们。通知<code class="du ld le lf lg b">Listener</code> s为O(N)。在我们的方法中，唯一被通知的<code class="du ld le lf lg b">Listener</code>是<code class="du ld le lf lg b">InheritedNotifier</code>，因此，我们的通知实际上是O(1)。从一个后代访问一个<code class="du ld le lf lg b">InheritedNotifier</code>也是O(1 ),所以你可以看到，我们的方法当然是高性能的。下面我们来看看如何实现。</p><h1 id="2655" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">履行</h1><p id="0203" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先，让我们制作我们的<code class="du ld le lf lg b">MyInheritedNotifier</code>类。它非常简单，只需将其构造函数参数传递给它的超类<code class="du ld le lf lg b">InheritedWidget</code>，并定义它将接受的<code class="du ld le lf lg b">Listenable</code>类型。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="d23f" class="lm jk hi lg b fi ln lo l lp lq">class MyInheritedNotifier&lt;T extends ChangeNotifier&gt;<br/>    extends InheritedNotifier&lt;T&gt; {<br/>  const MyInheritedNotifier(<br/>      {Key? key, required T notifier, required Widget child})<br/>      : super(key: key, notifier: notifier, child: child);<br/>}</span></pre><p id="9bfc" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们使用<em class="lh">泛型</em>来使我们的解决方案具有适应性&amp;可重用性。如果您不熟悉泛型，它们允许我们编写类和函数来处理一系列数据类型。在这里，我们定义<code class="du ld le lf lg b">MyInheritedNotifier</code>与<code class="du ld le lf lg b">ChangeNotifier</code>一起工作，以及它的任何子类与<code class="du ld le lf lg b">&lt;T extends ChangeNotifier&gt;</code>一起工作。每当我们在下面使用<code class="du ld le lf lg b">T</code>时，我们声明它将是<em class="lh">类型</em> <code class="du ld le lf lg b">T</code>所代表的任何东西。当在我们的代码中使用它时，我们可以指定期望的类型，例如<code class="du ld le lf lg b">MyInheritedNotifier&lt;AppState&gt;</code>，但是通过将<code class="du ld le lf lg b">notifier</code>定义为<em class="lh">类型</em> <code class="du ld le lf lg b">T</code>，它实际上是在调用构造函数时隐含的。因此，当使用我们的解决方案时，我们将自动成为类型安全的。</p><p id="7ee8" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在，让我们用一个<code class="du ld le lf lg b">StatefulWidget</code>来包装我们的<code class="du ld le lf lg b">MyInheritedNotifier</code>。这是我们的数据将被存储的地方。它必须是有状态的，因为<code class="du ld le lf lg b">Listenable</code> s应该被释放。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="ac49" class="lm jk hi lg b fi ln lo l lp lq">class MyProvider&lt;T extends ChangeNotifier&gt; extends StatefulWidget {<br/>  const MyProvider(<br/>      {Key? key, required this.create, required this.child})<br/>      : super(key: key);</span><span id="03f6" class="lm jk hi lg b fi ms lo l lp lq">  final Widget child;<br/>  final T Function() create;</span><span id="04bc" class="lm jk hi lg b fi ms lo l lp lq">  @override<br/>  State&lt;MyProvider&lt;T&gt;&gt; createState() =&gt; _MyProviderState&lt;T&gt;();<br/>}</span><span id="8729" class="lm jk hi lg b fi ms lo l lp lq">class _MyProviderState&lt;T extends ChangeNotifier&gt; extends<br/>    State&lt;MyProvider&lt;T&gt;&gt; {</span><span id="b53a" class="lm jk hi lg b fi ms lo l lp lq">  late final T _notifier = widget.create();</span><span id="8af8" class="lm jk hi lg b fi ms lo l lp lq">  @override<br/>  void dispose() {<br/>    _notifier.dispose();<br/>    super.dispose();<br/>  }</span><span id="910e" class="lm jk hi lg b fi ms lo l lp lq">  @override<br/>  Widget build(BuildContext context) =&gt;<br/>    _MyInheritedNotifier&lt;T&gt;(<br/>       notifier: _notifier, child: widget.child);<br/>}</span></pre><p id="7469" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这里，我们简单地提供了一个小部件来存储我们的应用程序状态数据对象。我们使用create函数来实例化对象，因为这个类负责处理对象。因此，它也应该是创建它的人。关键字<code class="du ld le lf lg b">late</code>允许我们在实例化时访问<code class="du ld le lf lg b">widget</code>。行<code class="du ld le lf lg b">late final T _notifier = widget.create()</code>相当于</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="1d09" class="lm jk hi lg b fi ln lo l lp lq">late final T _notifier;</span><span id="27f3" class="lm jk hi lg b fi ms lo l lp lq">_MyStateProvider() {<br/>  _notifier = widget.create();<br/>}</span></pre><p id="d904" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这就是我们的<code class="du ld le lf lg b">InheritedNotifier</code>设置！没那么糟吧。在大约30行代码中，我们创建了一个高性能的&amp;可重用状态管理解决方案！要使用它，我们只需定义一个扩展<code class="du ld le lf lg b">ChangeNotifier</code>的类，并定义我们的应用程序状态。</p><p id="a068" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">作为一个例子，我将为典型的颤动计数器应用程序定义一个<code class="du ld le lf lg b">AppState</code>类。我不仅会存储计数，还会存储随着计数而变化的背景和文本颜色。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="7752" class="lm jk hi lg b fi ln lo l lp lq">class AppState extends ChangeNotifier {</span><span id="4cd0" class="lm jk hi lg b fi ms lo l lp lq">  int _count = 0;<br/>  int get count =&gt; _count;</span><span id="5896" class="lm jk hi lg b fi ms lo l lp lq">  void incrementCounter() {<br/>    _count++;<br/>    _backgroundColor = _colors[count % 5];<br/>    notifyListeners();<br/>  }</span><span id="e079" class="lm jk hi lg b fi ms lo l lp lq">  Color _backgroundColor = Colors.blue;<br/>  Color get backgroundColor =&gt; _backgroundColor;</span><span id="2dbd" class="lm jk hi lg b fi ms lo l lp lq">  Color get textColor =&gt; _backgroundColor == Colors.yellow<br/>      ? Colors.black87<br/>      : Colors.white;</span><span id="19d5" class="lm jk hi lg b fi ms lo l lp lq">  static AppState of(BuildContext context) {<br/>    final result = context.dependOnInheritedWidgetOfExactType&lt;MyInheritedNotifier&lt;AppState&gt;&gt;()!;<br/>    assert(result != null, 'No MyInheritedWidget&lt;AppState&gt; in context');<br/>    result.notifier!;</span><span id="9904" class="lm jk hi lg b fi ms lo l lp lq">}</span></pre><p id="ea10" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如前所述，惯例是提供一个静态的<code class="du ld le lf lg b">of</code>函数来访问<code class="du ld le lf lg b">InheritedWidget</code>。这里，我们在应用程序状态数据类中这样做。它通过<code class="du ld le lf lg b">BuildContext</code>的<code class="du ld le lf lg b">dependOnInheritedWidgetOfExactType</code>方法找到正确的<code class="du ld le lf lg b">InheritedNotifier</code>。我们检查在我们的小部件树的更高层确实有一个<code class="du ld le lf lg b">MyInheritedNotifier</code>。如果没有，我们很可能忘记创建它，或者没有将它传递给当前的<code class="du ld le lf lg b">context</code>。然后，我们从<code class="du ld le lf lg b">MyInheritedNotifier</code>返回<code class="du ld le lf lg b">AppState</code>通知符。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="3ade" class="lm jk hi lg b fi ln lo l lp lq"><strong class="lg hj">NOTE:</strong> MyProvider, _MyProviderState, and MyInheritedNotifier can be defined in the same file (library) and never touched again once we are done.</span></pre><p id="9f27" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然后，我们可以在应用程序中使用它来访问其中的变量和方法。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="7a52" class="lm jk hi lg b fi ln lo l lp lq">@override<br/>Widget build(BuildContext context) {<br/>  final appState = AppState.of(context);<br/>  return Scaffold(<br/>    AppBar(<br/>      title: Text(title,<br/>          style: TextStyle(color: appState.textColor)),<br/>      backgroundColor: appState.backgroundColor,<br/>    ),<br/>    body: Center(<br/>      Column(<br/>        mainAxisAlignment: MainAxisAlignment.center,<br/>        children: &lt;Widget&gt;[<br/>          const Text('You have pushed the button this many times:'),<br/>          Text(appState.count.toString(),<br/>              style: Theme.of(context).textTheme.headline4,<br/>          ),<br/>        ],<br/>      ),<br/>    ),<br/>    floatingActionButton: FloatingActionButton(<br/>      onPressed: appState.incrementCounter,<br/>      tooltip: 'Increment',<br/>      backgroundColor: appState.backgroundColor,<br/>      child: Icon(Icons.add, color: appState.textColor,<br/>    ),<br/>  );<br/>}</span></pre><p id="bea6" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在你知道了！如您所见，一切都如预期的那样运行。我们可以扩展<code class="du ld le lf lg b">AppState</code>类来处理任意数量的状态，例如身份验证，或者我们可以嵌套<code class="du ld le lf lg b">Provider</code>来提供有作用域的状态管理，将各种状态划分到它们自己的类中(例如<code class="du ld le lf lg b">Counter</code>、<code class="du ld le lf lg b">Auth</code>、<code class="du ld le lf lg b">Layout</code>等)，每个状态只包含一个新的数据类。</p><p id="7c55" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我不知道你怎么想，但我不想为每个数据类编写一个<code class="du ld le lf lg b">of</code>方法。随着项目的增长，我也不喜欢通过一遍又一遍地调用<code class="du ld le lf lg b">of</code>来访问我的数据。是时候做一个专业的动作了…</p><h1 id="e8f0" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">扩展方法</h1><p id="9568" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Dart 2.7中引入的<em class="lh">扩展方法</em>允许我们为现有类提供新的功能，这再简单不过了。与其将<code class="du ld le lf lg b">BuildContext</code>传递给静态的<code class="du ld le lf lg b">of</code>方法，不如让我们添加一个<code class="du ld le lf lg b">extension</code><em class="lh"/><code class="du ld le lf lg b"><em class="lh">on</em></code><em class="lh"/><code class="du ld le lf lg b">BuildContext</code>来为我们处理这个问题。我们可以使用<em class="lh">泛型</em>使它对于我们想要访问的任何数据类型都是可重用的。在与我们的类相同的库中定义一个<code class="du ld le lf lg b">extension</code>。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="d755" class="lm jk hi lg b fi ln lo l lp lq">extension ReadContext on BuildContext {<br/>  T watch&lt;T extends ChangeNotifier&gt;() =&gt; dependOnInheritedWidgetOfExactType&lt;MyInheritedNotifier&lt;T&gt;&gt;()!.notifier!;<br/>}</span></pre><p id="3d9c" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在，我们可以不叫<code class="du ld le lf lg b">final appState = AppState.of(context);</code>而叫<code class="du ld le lf lg b">context.watch&lt;AppState&gt;();</code>。这也允许我们通过将<code class="du ld le lf lg b">MyInheritedNotifier</code>重命名为<code class="du ld le lf lg b">_MyInheritedNotifier</code>来使其私有，防止它在库之外被使用。漂亮！但是，如果我们想在应用程序的某个地方访问<code class="du ld le lf lg b">AppState</code>一次，而不是每次更新都重新构建，那该怎么办呢？也许在一个<code class="du ld le lf lg b">onPressed</code>函数中。我们可以通过向我们的扩展添加以下功能:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="ebe6" class="lm jk hi lg b fi ln lo l lp lq">T read&lt;T extends ChangeNotifier&gt;() =&gt; findAncestorWidgetOfExactType&lt;MyInheritedNotifier&lt;T&gt;&gt;()!.notifier!;</span></pre><p id="6e58" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这里，不是<em class="lh">依赖于</em>依赖于<code class="du ld le lf lg b">MyInheritedNotifier</code>意味着我们想要在数据改变时重建，我们只是简单地查找一次。完美！三个类，一个扩展，仅仅40行之后，我们就完成了！</p><h1 id="1cac" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="ccf2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">干得好！我们已经编写了一个非常优雅的状态管理解决方案，它简洁、适应性强、高性能。它非常适合单一的应用程序状态类、较小范围的状态类，以及(我个人最喜欢的)处理用户认证。在您的下一个项目中尝试一下吧！</p><p id="dc5b" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">虽然将这一小段代码复制/粘贴到每个项目中非常简单，但是为什么不创建一个包来使用呢？更好的是，克隆<a class="ae lc" href="https://github.com/theLee3/simple_state_management.git" rel="noopener ugc nofollow" target="_blank">简单状态管理</a>回购。它包括一些不错的附加功能，比如数据对象的惰性加载&amp;有用的文档。其他特性也计划在未来的更新中实现，比如一个<code class="du ld le lf lg b">MultiProvider</code>类来避免嵌套共享相同作用域的<code class="du ld le lf lg b">Provider</code>的需要。如果你发现这个项目有益，不要忘了启动它！😃</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="78ac" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一如既往的感谢阅读！掌声是受欢迎的，提问和评论也是。请关注我的专注于Flutter的文章，包括我的<em class="lh"> Flutter案例研究</em>系列，其中我们研究了其他Flutter开发者遇到的问题。<em class="lh">案例分析</em>欢迎提出建议！</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to implement linked lists from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始实现链表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-implement-linked-lists-from-scratch-14a2416053b6?source=collection_archive---------26-----------------------#2021-07-22">https://medium.com/geekculture/how-to-implement-linked-lists-from-scratch-14a2416053b6?source=collection_archive---------26-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0a55" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">单向和双向链表的语言无关指南</h2></div><p id="f525" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链表是最基本的数据结构之一。在本文中，我们将定义与链表相关的术语，探索单链<em class="jt"/>和双链<em class="jt"/>链表之间的区别，并看看我们如何从头开始实现它们。</p><h1 id="2cb9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">内容</h1><ol class=""><li id="a7f8" class="km kn hi iz b ja ko jd kp jg kq jk kr jo ks js kt ku kv kw bi translated">定义、操作和术语；</li><li id="fadf" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js kt ku kv kw bi translated">单链表:实现与分析:</li><li id="03e8" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js kt ku kv kw bi translated">双向链表:操作，实现，异或链接。</li></ol><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/2152e474f76ca44b083977f8d66c7b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*le1MFLyCPL2ax5cGu3AQqA.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Photo credit: John Barkiple on Unsplash</figcaption></figure><h1 id="9f0c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">定义和术语</h1><p id="d65e" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">类型为<code class="du lv lw lx ly b">T</code>的<em class="jt">单链表</em>(通常简称为<em class="jt">链表</em>，甚至<em class="jt">链表</em>)可以定义为一个二元组(<em class="jt"> h </em>，<em class="jt"> t </em>)，其中<em class="jt"> h </em>是类型为<code class="du lv lw lx ly b">T</code>的元素，<em class="jt"> t </em>是指向另一个类型为<code class="du lv lw lx ly b">T</code>的链表的指针。<em class="jt"> h </em>被称为列表的头部——这是它的第一个值——t被称为它的尾部。t 可以是null(或者指向一个空列表)，在这种情况下，列表只有一个元素:它的头。链表中节点的数量可以称为它的长度或大小。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lz"><img src="../Images/9a907105c7c8f06720ccdb186fd86824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLOYlfFvvyocNeDCoF1rhw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Figure A | Representation of a list of length 5.</figcaption></figure><p id="2f15" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与数组不同，列表不是连续存储在内存中的:这就是为什么我们需要跟踪每个节点的后继节点。</p><p id="2567" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表通常支持以下操作:</p><ul class=""><li id="0578" class="km kn hi iz b ja jb jd je jg ma jk mb jo mc js md ku kv kw bi translated">遍历，即以正确的顺序将列表的每个值传递给例程，</li><li id="54ea" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">前置，即在列表的开头插入一个新节点，</li><li id="27c3" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">追加，即在列表末尾插入一个新节点，</li><li id="ad68" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">插入，即在某个任意节点之后插入，</li><li id="756c" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">索引，即检索给定索引的值，</li><li id="1332" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">斩首，即删除列表中的第一个元素，</li><li id="175a" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">移除，即移除任意节点。</li><li id="e142" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">连接，即附加另一个列表A的所有元素，保持A的节点的排序，</li><li id="4c2f" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">反转，即从<em class="jt"> A </em>创建一个新的列表<em class="jt">A’</em>，使得<em class="jt">A’</em>包含与<em class="jt"> A </em>出现次数完全相同的值，如果<em class="jt"> y </em>是<em class="jt"> A </em>中<em class="jt"> x </em>的后继，那么<em class="jt"> x </em>是<em class="jt">中<em class="jt"> y </em>的后继</em></li></ul></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="2a74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<em class="jt">双向链表</em>是一个三元组(<em class="jt"> p </em>，<em class="jt"> v </em>，<em class="jt"> n </em>)，其中<em class="jt"> p </em>表示前一个元素，<em class="jt"> v </em>表示值，<em class="jt"> n </em>表示下一个元素:它有两个指针，而不是一个，这在某些应用中可能很方便。</p><h1 id="19a1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">实现单链表</h1><p id="1c45" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">我们将使用受函数启发的伪代码来实现列表及其操作。</p><p id="818c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我们的列表结构:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/cf9f295c6a07d13dc8305e07c06249fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eTw1Ny9IvaTZD7AFUIRiA.png"/></div></div></figure><p id="39c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它被实现为依赖于类型t的有区别的联合。它可以取两个不同值中的一个:空，表示一个空列表，或者一对(Head，Tail)适当的类型。头部和尾部可以在恒定时间内立即被检索，例如使用从面向对象语言继承的点语法:<code class="du lv lw lx ly b">myBeautifulList.Head</code>、<code class="du lv lw lx ly b">myBeautifulList.Tail</code>。单链表通常由其第一个节点来表征。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="fd76" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最简单的操作是那些只处理列表头的操作，因为它们不需要遍历列表。</p><p id="b320" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从<em class="jt">前置</em>开始:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/88b69b0e78e7c225faaec6129150f540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBL204aAryIMk07ItdALbQ.png"/></div></div></figure><p id="baae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它创建一个新列表，列表头是新值，列表尾是原始列表。这个函数相对于列表的长度明显地在θ(1)时间内运行。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="2329" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">斩首</em>更简单:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/bdb5adba01980c384c7644de85d75168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnp-26BSUdd-RJDbew0c2g.png"/></div></div></figure><p id="4a9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这又需要θ(1)时间。在实际应用中，我们可能需要在检索尾部之前检查列表是否为非空，如果不是，则失败。但是这太特定于语言和范式了，不值得在这里讨论。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="1868" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">在给定节点后插入</em>类似于<em class="jt">前置</em>。它获取一个列表的节点<em class="jt"> X </em>以及一个新值，创建一个包含新值的节点，并将其设置为<em class="jt"> X </em>的后继节点。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/aca6324e688b686a92ff459d21b50054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIxLebYCvjj2JQhZvsUtPw.png"/></div></div></figure><p id="7571" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lv lw lx ly b">node</code>的先前后继者成为新节点的后继者，并且新节点成为<code class="du lv lw lx ly b">node</code>的后继者，从而列表保持连接。一切仍在不变的时间里发生。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="8000" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们报道的下一个行动是<em class="jt">穿越</em>。它采用一个例程<code class="du lv lw lx ly b">f</code>和一个列表<code class="du lv lw lx ly b">list</code>并遍历<code class="du lv lw lx ly b">list</code>，从头到尾将每个值传递给<code class="du lv lw lx ly b">f</code>。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/48f4422de81935c313747b893c6680ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-5NvoVzWWzC29cvq9dMFg.png"/></div></div></figure><p id="e0a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只要列表非空，该函数就会运行，检索头部以将其传递给例程，并递归调用列表的尾部。当我们消耗完所有节点后，我们只需通过返回某个常量值来终止。</p><p id="dcf0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遍历相对于列表的长度在θ(N)时间内运行。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="188c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用相同的原理实现<em class="jt">索引</em>:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/3d218e60e0a8707d51d2ad1348e3d935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1lWCbMnDXggVo8iMTVinw.png"/></div></div></figure><p id="160d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们递归地检查列表中的每个元素，从0开始，只要列表中还有元素，并且我们还没有到达目标索引，就递增。如果索引超出范围，则函数失败，如果存在，则返回第(<code class="du lv lw lx ly b">index</code> + 1)个节点。</p><p id="1bae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相对于列表的长度，该函数在O( <em class="jt"> N </em>)时间内运行。如果指数在范围内，那么<code class="du lv lw lx ly b">getAtIndex</code>在θ(<code class="du lv lw lx ly b">index</code>)时间内运行。这就是为什么当你经常需要索引元素时，依靠列表不是一个好主意。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="25f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">追加</em>实现如下:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/51879a0f41901b1ac19024afc436251a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aj6zhboUW_wgT0C87InD2A.png"/></div></div></figure><p id="e09e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先创建我们想要添加的节点，<code class="du lv lw lx ly b">new</code>。然后我们检查列表是否为空。如果是，那么更新后的列表只有一个节点，即第2行中创建的节点。如果不是，我们遍历列表，直到找到最后一个节点，即尾部为空的第一个节点。当我们找到它时，我们更新它，使它现在指向<code class="du lv lw lx ly b">newNode</code>，它成为列表的最后一个节点。最后，我们返回初始列表，<code class="du lv lw lx ly b">l</code>。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="eec6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">删除</em>一个节点也需要O(N)时间。这是因为我们需要更新节点的前身，这需要使用类似于我们在前面的线性时间操作中采用的方法来检索。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/9abb2addb74999162f03ee61648248a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJQJj-Os6XzOxI1-T1Atcw.png"/></div></div></figure><p id="be4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们递归地遍历列表，直到找到我们想要删除的节点的前身。一旦我们找到了它(即当第5行中的条件评估为<code class="du lv lw lx ly b">true</code>，我们通过将<code class="du lv lw lx ly b">node.Tail</code>赋值给<code class="du lv lw lx ly b">list.Tail</code>将节点的尾部连接到它的前一个节点的尾部。在某些语言中，我们会将节点从内存中删除，如第8行所示。</p><p id="ea2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以考虑另一种实现方式，其中我们取想要删除的节点的值(即头),而不是对该节点的引用。在这种情况下，我们需要检查<code class="du lv lw lx ly b">List.Tail</code>是否非空，然后检查<code class="du lv lw lx ly b">List.Tail.Head</code>是否对应于我们想要删除的值。如果我们想要删除某个值的所有出现，我们将递归调用被删除节点尾部的循环，继续遍历列表，直到它被全部消耗掉。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="1296" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">串联</em>实际上与追加几乎相同，相对于第一个列表的长度，花费线性时间。它归结为将第二个列表的第一个节点附加到第一个列表，这给出了以下可能的实现:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/841d0968443f924ed8fc88199ab22a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAIMkzQf0BcLId40IxDNCw.png"/></div></div></figure><p id="9824" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们递归搜索<em class="jt"> X </em>的最后一个元素，并将<em class="jt"> Y </em>的第一个节点(即<em class="jt"> Y </em>本身)赋给它的尾部。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="81c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现<em class="jt">反转</em>比前面的操作要稍微复杂一点。没什么特别难的，但是它以一种乍一看很令人费解的方式操纵引用。可以这样做:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/13f8e998cca622b2bf972da9078240d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iux4cwv3enkYlqPV5QAb_A.png"/></div></div></figure><p id="ed98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们维护一个列表<code class="du lv lw lx ly b">reversedList</code>，它被初始化为一个空列表，当函数终止时对应于反向列表。递归函数<code class="du lv lw lx ly b">loop</code>接受一个列表和当前版本的反向列表。如果<code class="du lv lw lx ly b">list</code>为空，那么我们已经完成了对<code class="du lv lw lx ly b">reversedList</code>的计算，我们可以返回它。否则，我们执行以下操作:</p><ol class=""><li id="6e58" class="km kn hi iz b ja jb jd je jg ma jk mb jo mc js kt ku kv kw bi translated">第5行:记住列表的尾部。它将在下一次递归调用中对应于<code class="du lv lw lx ly b">list</code>的值。</li><li id="8294" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js kt ku kv kw bi translated">第6行:相当于把<code class="du lv lw lx ly b">{Head: list.Head, Tail: reversedList}</code>赋给<code class="du lv lw lx ly b">list</code>。</li><li id="a98b" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js kt ku kv kw bi translated">第7行:<code class="du lv lw lx ly b">reversedList</code>变成<code class="du lv lw lx ly b">{Head: list.Head, Tail: reversedList}</code>:这相当于把<code class="du lv lw lx ly b">list.Head</code>前置到<code class="du lv lw lx ly b">reversedList</code>。</li></ol><p id="ab6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，递归调用消耗列表的头部，将它添加到反向列表中，并在列表的尾部递归调用。当它已经消耗了整个列表时，<code class="du lv lw lx ly b">reversedList</code>显然对应于预期的解决方案。</p><h1 id="b304" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">双向链表</h1><h2 id="1b12" class="mm jv hi bd jw mn mo mp ka mq mr ms ke jg mt mu kg jk mv mw ki jo mx my kk mz bi translated">首次实现和一些特殊操作</h2><p id="4dd9" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">我们递归地定义双向链表，使用两个公理:存在一个空双向链表，<code class="du lv lw lx ly b">Empty</code>，如果<em class="jt"> X </em>和<em class="jt"> Y </em>是相同类型的双向链表<em class="jt"> T </em>和<em class="jt"> v </em>是类型<em class="jt"> T </em>那么三元组(<em class="jt"> X </em>，<em class="jt"> v </em>，<em class="jt"> Y </em>)是双向链表。这给出了以下实现:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/97c06da3c077c47deae4ee37ec519611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QKA1bhTrMmHTdOVW6t8LQ.png"/></div></div></figure><p id="05f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">双向链表通常有两个引用:一个指向第一个节点，另一个指向最后一个节点。例如，这允许在不反转列表的情况下以相反的顺序遍历列表。<code class="du lv lw lx ly b">reversed-traversal</code>的实现与单链表遍历几乎相同:唯一的区别是它引用最后一个节点而不是第一个节点，并且它在<code class="du lv lw lx ly b">list.Previous</code>而不是<code class="du lv lw lx ly b">list.Tail</code>上递归。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="76ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以想出一个<em class="jt">反转</em>的新实现。它并不比我们看到的单链表更有效，但从技术角度来看很有趣。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/32ea341a6a4e3e7599b2da909e47d7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HfQMiIaLJViWZdQgOM6mw.png"/></div></div></figure><p id="a7e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lv lw lx ly b">loop</code> enables的第二个参数是对我们访问过的最后一个元素的引用。特别地，当列表为空时，前一个元素是列表的最后一个元素，即反转列表的头部。它是函数返回的值。</p><p id="ebc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第5行交换列表的两个引用:前一个节点成为下一个，前一个节点成为前一个。</p><p id="c7ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我鼓励你试着用一个小样本列表在心里运行这个算法，以确保你理解它做什么，并给你一些直觉，为什么它是正确的。</p><p id="20b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图B显示了列表[1；2;3].</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es na"><img src="../Images/beaf20e9af9225dde095addcd49003c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAod8TzuwTeQbZCToxNcJw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Figure B</figcaption></figure><p id="8572" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第<code class="du lv lw lx ly b">n-th call</code>行显示了循环第<em class="jt"> n </em>次调用结束时的列表。突出显示的部分对应于参数<code class="du lv lw lx ly b">list</code>。在第三次调用之后，<code class="du lv lw lx ly b">last</code>是值为3的节点。它对应于倒序列表的头部:3的后继者是2，2的后继者是1，1没有后继者。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="b0b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">双向链表的一个很大的优点是我们可以在常数时间内删除任意节点，而不是线性的。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/f273925263aa58b4d5bc073def3b10d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMaLCZrpFl-x9wy1wi4pdQ.png"/></div></div></figure><p id="5611" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是因为我们可以直接访问包含对<code class="du lv lw lx ly b">nodeToRemove</code>的引用的所有节点。这允许我们在恒定的时间内修改那些引用:<code class="du lv lw lx ly b">nodeToRemove</code>的继任者成为其前任的继任者，其前任成为其继任者的前任。</p><p id="2519" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图C显示了在<code class="du lv lw lx ly b">nodeToRemove</code>、其前任和其继任者上执行的操作。红色指针对应于运行函数之前的状态，绿色指针对应于中间节点从列表中删除后的状态。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es nb"><img src="../Images/b882c67e57d46efb013363f1d3bd8454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OODDZFNRDmfpDY7i4siOkQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Figure C</figcaption></figure><h2 id="41a9" class="mm jv hi bd jw mn mo mp ka mq mr ms ke jg mt mu kg jk mv mw ki jo mx my kk mz bi translated">异或链接</h2><p id="5e23" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">XOR链接是一种用于实现双向链表而不存储两个指针的方法。顾名思义，它利用了按位<em class="jt">异或</em>运算符XOR。</p><p id="1fe3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个节点都包含一个地址字段，而不是包含对其前任的引用和对其继任者的引用。地址字段的值为<code class="du lv lw lx ly b">pred XOR next</code>:这是两个引用的异或运算。</p><p id="afae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用伪代码定义一个XOR链表，如下所示:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/3149a714aaaae7f72f578f45ebe0ff44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4QXuI7boBTS6ZaXWzXiPw.png"/></div></div></figure><p id="047f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">XOR链接能够节省内存，但是使得实现操作更加困难和不直观。在这一节中，我们将看到一个操作是如何实现的:遍历。使用类似的规则可以导出其他实现。</p><p id="3496" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们继续之前，您需要了解XOR的四个属性:</p><ul class=""><li id="32d6" class="km kn hi iz b ja jb jd je jg ma jk mb jo mc js md ku kv kw bi translated">它是对称的，即对于所有的<em class="jt"> x </em>、<em class="jt">y</em>:<em class="jt">x</em>XOR<em class="jt">y</em>=<em class="jt">y</em>XOR<em class="jt">x</em>；</li><li id="4087" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">0是单位元，即对于所有的<em class="jt"> x </em> : <em class="jt"> x </em>异或0 =<em class="jt">x</em>；</li><li id="af06" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">它是关联式的，即对于所有的<em class="jt"> x </em>、<em class="jt"> y </em>、<em class="jt">z</em>:<em class="jt">x</em>XOR(<em class="jt">y</em>XOR<em class="jt">z</em>)=(<em class="jt">x</em>XOR<em class="jt">y</em>XOR<em class="jt">z</em>；</li><li id="39da" class="km kn hi iz b ja kx jd ky jg kz jk la jo lb js md ku kv kw bi translated">对于所有的<em class="jt"> x </em>，<em class="jt"> x </em>异或<em class="jt"> x </em> = 0。</li></ul><p id="240c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试着设计一个XOR链表遍历的算法。我们考虑一个有节点A，B，C，…的列表。</p><p id="e6c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从指向列表头部的指针开始，用<code class="du lv lw lx ly b">&amp;A</code>表示(在本节中，我们将对指针使用与号符号)。A的地址字段是<code class="du lv lw lx ly b">0 XOR &amp;B = &amp;B</code>。这使我们可以访问列表的第二个节点b。</p><p id="5e47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在想得到一个指向节点c的指针。因为<code class="du lv lw lx ly b">B.Address = &amp;A XOR &amp;C</code>，<code class="du lv lw lx ly b">&amp;A XOR B.Address = &amp;A XOR &amp;A XOR &amp;C = 0 XOR &amp;C = &amp;C</code>:我们可以移动到c</p><p id="ae9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更一般地，指向第<em class="jt"> n </em>个节点的指针是指向第(<em class="jt"> n </em> -2)个节点的指针和第(<em class="jt"> n </em> -1)个节点的<code class="du lv lw lx ly b">Address</code>字段的内容的异或。这使得能够实现如下遍历:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ml"><img src="../Images/d0f79daf25a6a5595e9ea6e49079d728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQjLEAXTLLLHHckjwOqKqw.png"/></div></div></figure><p id="5ef6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们对指针使用C语法，即,“与”来获取指针，星号来取消引用。</p><p id="3325" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先使用前面导出的公式检索当前元素。基本情况是当它为0时，这表示我们已经访问了列表中的所有节点。</p><p id="6cbe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果当前节点不为零，我们将它指向的节点传递给一个函数(不要忘记解引用！)并用<code class="du lv lw lx ly b">minusOne</code>和<code class="du lv lw lx ly b">minusTwo</code>的更新值递归调用。</p></div></div>    
</body>
</html>
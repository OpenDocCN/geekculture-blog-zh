<html>
<head>
<title>Implementing Android 12's Overscroll Indicator Effect in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中实现Android 12的过卷指示器效果</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-android-12s-overscroll-indicator-effect-in-flutter-b8e558d8566c?source=collection_archive---------2-----------------------#2022-05-02">https://medium.com/geekculture/implementing-android-12s-overscroll-indicator-effect-in-flutter-b8e558d8566c?source=collection_archive---------2-----------------------#2022-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8b387c22420ee09ed821a83d4d4331d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHRte03eLR4sMhcPbykL_w.jpeg"/></div></div></figure><p id="428b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新:</strong>这个方法在Flutter 3中已经被弃用。请阅读我的新<a class="ae jo" href="https://lp3.medium.com/properly-implementing-android-12s-overscroll-indicator-in-flutter-a1f1a11ce249" rel="noopener">文章</a>来了解实现这个特性的更新方法。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="dde3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能知道也可能不知道，Android 12将过度滚动指示器从<em class="jw">发光</em>效果改为<em class="jw">拉伸</em>效果。区别可以从下面看出来。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/210af7e920c8fdf2f974b05e0516fd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LNdVz-OmxAU8eKUZgDOOiA.gif"/></div></div></figure><p id="0484" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，当使用Flutter时，框架处理我们所有的UI外观和行为。这意味着我们享受不到Android版本(或iOS，或Windows等)之间自动行为更新的好处。).因此，当操作系统版本之间的默认外观或行为发生变化时，我们必须更新我们的应用程序，使其行为适当。幸运的是，Flutter有一个解决方案。</p><p id="fcc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以在我们的<code class="du kc kd ke kf b">Theme</code>中定义Android过度滚动行为。</p><pre class="jy jz ka kb fd kg kf kh ki aw kj bi"><span id="8b84" class="kk kl hi kf b fi km kn l ko kp">ThemeData(<br/>  androidOverscrollIndicator: AndroidOverscrollIndicator.stretch,<br/>)</span></pre><p id="2d51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你提供了浅色和深色主题，请确保为这两种主题都定义了过度滚动指示器。</p><p id="7fd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，虽然这很容易实现，但有一个小问题…这将在所有版本的Android上应用<em class="jw"> stretch </em>行为，而不仅仅是在Android 12+上。为了让我们的应用程序在每个Android版本上都感觉自在，我们需要首先确定版本，然后根据这些信息定义overscroll指示器。我们将使用<code class="du kc kd ke kf b">device_info_plus</code>包来查找Android版本，所以将下面的内容添加到<code class="du kc kd ke kf b">pubspec.yaml</code>中并运行<code class="du kc kd ke kf b">pub get</code>。</p><pre class="jy jz ka kb fd kg kf kh ki aw kj bi"><span id="c958" class="kk kl hi kf b fi km kn l ko kp">device_info_plus: any</span></pre><p id="64b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，将以下代码添加到<code class="du kc kd ke kf b">main</code>方法中。我们需要让<code class="du kc kd ke kf b">main</code> <em class="jw">异步</em>并检测Android版本，因为这样做的方法是异步的。</p><pre class="jy jz ka kb fd kg kf kh ki aw kj bi"><span id="417c" class="kk kl hi kf b fi km kn l ko kp">void main() async {<br/>  WidgetsFlutterBinding.ensureInitialized();<br/>  final androidInfo = await DeviceInfoPlugin().androidInfo;<br/>  final sdkVersion = androidInfo.version.sdkInt ?? 0;<br/>  final androidOverscrollIndicator = sdkVersion &gt; 30<br/>      ? AndroidOverscrollIndicator.stretch<br/>      : AndroidOverscrollIndicator.glow;</span><span id="bf06" class="kk kl hi kf b fi kq kn l ko kp">  runApp(MyApp(<br/>    androidOverscrollIndicator:androidOverscrollIndicator,<br/>  ));<br/>}</span><span id="8b06" class="kk kl hi kf b fi kq kn l ko kp">class MyApp extends StatelessWidget {<br/>  const MyApp({<br/>    Key? key,<br/>    this.androidOverscrollIndicator =<br/>            AndroidOverscrollIndicator.glow,<br/>  }) : super(key: key);</span><span id="1f01" class="kk kl hi kf b fi kq kn l ko kp">final AndroidOverscrollIndicator androidOverscrollIndicator;</span><span id="a65a" class="kk kl hi kf b fi kq kn l ko kp">...</span><span id="ca45" class="kk kl hi kf b fi kq kn l ko kp">  theme: ThemeData(<br/>    androidOverscrollIndicator:androidOverscrollIndicator,<br/>  ),</span><span id="b2a9" class="kk kl hi kf b fi kq kn l ko kp">...</span></pre><p id="7a91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要注意的事项:</p><ul class=""><li id="4c98" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated"><code class="du kc kd ke kf b">WidgetsFlutterBinding</code>需要在使用<code class="du kc kd ke kf b">DeviceInfoPlugin</code>前初始化。</li><li id="ded9" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><code class="du kc kd ke kf b">androidInfo.version.sdkInt</code>可以返回<code class="du kc kd ke kf b">null</code>如果应用运行在Android以外的东西上(即iOS)。如果是，我们将该值设置为<code class="du kc kd ke kf b">0</code>。</li><li id="0f21" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">Android 12的SDK版本是31，因此我们使用<em class="jw"> stretch </em>来处理30以上的内容。</li><li id="6afd" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">这里，我们通过构造函数将指示器作为参数传递给我们的根小部件<code class="du kc kd ke kf b">MyApp</code>。您可以使用您喜欢的任何方法在小部件之间传递数据。(查看我关于简单国家管理的<a class="ae jo" rel="noopener" href="/geekculture/simple-performant-state-management-without-an-external-library-786f5d2b34a8">文章</a>，或者相关的<a class="ae jo" href="https://github.com/theLee3/simple_state_management" rel="noopener ugc nofollow" target="_blank">回购</a>，寻找一个可能的解决方案。)</li></ul><p id="9651" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是全部了！现在，在所有版本的Android上滚动你的应用程序都会感觉很舒服。</p><p id="cca0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读！如果你喜欢这篇文章，请鼓掌并跟随。</p></div></div>    
</body>
</html>
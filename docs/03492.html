<html>
<head>
<title>Create a Video Chat/Video Steaming App using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python创建视频聊天/视频流应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-video-chat-app-using-python-9da0a9c386ba?source=collection_archive---------2-----------------------#2021-06-09">https://medium.com/geekculture/creating-video-chat-app-using-python-9da0a9c386ba?source=collection_archive---------2-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于疫情，通过互联网保持联系的唯一方式。但是由于广告部的活动如此之大，数据泄露和数据隐私是一个大问题。为了克服数据隐私问题，让我们创建自己的视频聊天应用程序，以便与我们亲爱的人保持联系，并避免被任何广告公司跟踪。之前我们创建了一个文本聊天应用程序，现在让我们向前迈出一步，创建一个视频聊天应用程序。</p><blockquote class="jd"><p id="b9d7" class="je jf hi bd jg jh ji jj jk jl jm jc dx translated">继续之前，请参考我的聊天应用程序:<a class="ae jn" href="https://python.plainenglish.io/chat-app-using-udp-5b486241748c" rel="noopener ugc nofollow" target="_blank">使用UDP创建Python聊天应用程序| gur simar Singh | Python简明英语版</a></p></blockquote><p id="c93b" class="pw-post-body-paragraph if ig hi ih b ii jo ik il im jp io ip iq jq is it iu jr iw ix iy js ja jb jc hb bi translated">让我们看看代码，</p><p id="2047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用OpenCV库的CV2模块来捕捉视频。</p><blockquote class="jd"><p id="6783" class="je jf hi bd jg jh ji jj jk jl jm jc dx translated">了解有关CV2的更多信息:<a class="ae jn" href="https://python.plainenglish.io/image-processing-using-opencv-in-python-857c8cb21767" rel="noopener ugc nofollow" target="_blank">使用Python中的OpenCV进行图像处理|作者Gursimar Singh | Jun，2021 |用简明英语讲述Python</a></p></blockquote><p id="daba" class="pw-post-body-paragraph if ig hi ih b ii jo ik il im jp io ip iq jq is it iu jr iw ix iy js ja jb jc hb bi translated">建议创建一个单独的环境来安装所需的库，以便在出现任何错误时不会干扰默认环境</p><p id="bdd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Server.py </strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dcd7" class="kc kd hi jy b fi ke kf l kg kh">from pyfiglet import Figlet</span><span id="9c20" class="kc kd hi jy b fi ki kf l kg kh">os.system("clear")<br/>pyf = Figlet(font='puffy')<br/>a = pyf.renderText("Video Chat App without Multi-Threading")<br/>b = pyf.renderText("Server")<br/>os.system("tput setaf 3")<br/>print(a)</span><span id="5fdf" class="kc kd hi jy b fi ki kf l kg kh">import socket, cv2, pickle,struct</span><span id="6e12" class="kc kd hi jy b fi ki kf l kg kh"># Socket Create<br/>server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br/>host_name  = socket.gethostname()<br/>host_ip = socket.gethostbyname(host_name)<br/>print('HOST IP:',host_ip)<br/>port = 9999<br/>socket_address = (host_ip,port)</span><span id="ba10" class="kc kd hi jy b fi ki kf l kg kh"># Socket Bind<br/>server_socket.bind(socket_address)</span><span id="2a5a" class="kc kd hi jy b fi ki kf l kg kh"># Socket Listen<br/>server_socket.listen(1)<br/>print("Listening at:",socket_address)</span><span id="5ada" class="kc kd hi jy b fi ki kf l kg kh"># Socket Accept<br/>while True:<br/> client_socket,addr = server_socket.accept()<br/> print('Connected to:',addr)<br/> if client_socket:<br/>  vid = cv2.VideoCapture(0)<br/>  <br/>  while(vid.isOpened()):<br/>   ret,image = vid.read()<br/>   img_serialize = pickle.dumps(image)<br/>   message = struct.pack("Q",len(img_serialize))+img_serialize<br/>   client_socket.sendall(message)<br/>   <br/>   cv2.imshow('Video from Server',image)<br/>   key = cv2.waitKey(10) <br/>   if key ==13:<br/>    client_socket.close()</span></pre><p id="7222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Client.py </strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e274" class="kc kd hi jy b fi ke kf l kg kh">from pyfiglet import Figlet</span><span id="f3b5" class="kc kd hi jy b fi ki kf l kg kh">os.system("clear")<br/>pyf = Figlet(font='puffy')<br/>a = pyf.renderText("Video Chat App without Multi-Threading")<br/>b = pyf.renderText("Client")<br/>os.system("tput setaf 3")<br/>print(a)</span><span id="c315" class="kc kd hi jy b fi ki kf l kg kh">import socket,cv2, pickle,struct</span><span id="5575" class="kc kd hi jy b fi ki kf l kg kh"># create socket<br/>client_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><span id="0c61" class="kc kd hi jy b fi ki kf l kg kh">#  server ip address here<br/>host_ip = '&lt;IP&gt;' <br/>port = 9999<br/>client_socket.connect((host_ip,port)) <br/>data = b""<br/>metadata_size = struct.calcsize("Q")</span><span id="19f9" class="kc kd hi jy b fi ki kf l kg kh">while True:<br/> while len(data) &lt; metadata_size:<br/>  packet = client_socket.recv(4*1024) <br/>  if not packet: break<br/>  data += packet<br/> packed_msg_size = data[:metadata_size]<br/> data = data[metadata_size:]<br/> msg_size = struct.unpack("Q",packed_msg_size)[0]<br/> <br/> while len(data) &lt; msg_size:<br/>  data += client_socket.recv(4*1024)<br/>  frame_data = data[:msg_size]<br/>  data  = data[msg_size:]<br/>  frame = pickle.loads(frame_data)<br/>  cv2.imshow("Receiving Video ",frame)<br/>  key = cv2.waitKey(10) <br/>  if key  == 13:<br/>   break</span><span id="43cb" class="kc kd hi jy b fi ki kf l kg kh">client_socket.close()</span></pre><p id="c26d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们运行server.py，然后我们尝试运行client.py，图片传输速度惊人，因此创建了一个视频流。</p><p id="6357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们首先点击图片，然后使用pickle模块将其从数组格式转换为字节格式</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3c24" class="kc kd hi jy b fi ke kf l kg kh">#Converting this image to bytes format <br/>import pickle<br/>photo_serialize=pickle.dumps(photo)</span></pre><p id="96e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要提供缓冲区大小，以便客户端可以接收数据。为此，我们使用Python中的struct模块。这里“Q”是我们可以在参数中传递的值，因此它提供了8个字节。</p><p id="2350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用struct模块中的pack()函数打包数据，前8个字节对应于文件的大小。</p><p id="9e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用unpack函数来解包打包的数据。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="23c7" class="kc kd hi jy b fi ke kf l kg kh">import struct<br/>size = struct.calcsize("Q")</span><span id="83d9" class="kc kd hi jy b fi ki kf l kg kh">message = struct.pack("Q",len(img_serialize))+img_serialize</span><span id="fb33" class="kc kd hi jy b fi ki kf l kg kh">msg_size = struct.unpack("Q",packed_msg_size)[0]</span></pre><h2 id="5056" class="kc kd hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">相反，我们也可以使用flatten()和tostring()函数。</h2><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ac33" class="kc kd hi jy b fi ke kf l kg kh">def recordVideo():<br/>    time.sleep(5)    <br/>    while True:<br/>        ret, frame = cap.read()<br/>        d = frame.flatten()<br/>        video = d.tostring()<br/>        c.sendall(video)<br/>        time.sleep(0.2)</span><span id="a394" class="kc kd hi jy b fi ki kf l kg kh">def rcvVideo():<br/>     while True:<br/>          data, addr = s.recvfrom(230400)<br/>          frames = ""<br/>          frames += data<br/>          if len(frames) == (230400):</span><span id="cfc4" class="kc kd hi jy b fi ki kf l kg kh">frame = numpy.fromstring (frames,dtype=numpy.uint8)<br/>              frame = frame.reshape (240,320,3)<br/>              cv2.imshow('frame',frame)<br/>              frames=""<br/>              cv2.waitKey(1)<br/>          else:<br/>              frames=""</span></pre></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="cf97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在，让我们使用多线程创建一个流畅的视频聊天应用程序。我们将在客户端A和客户端B中同时启动4个线程(2个线程用于视频流和接收，2个线程用于音频流和收听)。一个线程将发送视频，另一个线程将接收视频。</strong></p><p id="25af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用PyAudio库进行音频传输。现在，安装它可能是棘手的，所以只使用下面的命令安装它，否则你可能会打破你的头，仍然无法找到一个稳定的版本。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3062" class="kc kd hi jy b fi ke kf l kg kh">$ conda install -c anaconda pyaudio</span></pre><p id="3d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们需要安装Anaconda发行版。Anaconda有一个更新的无bug版本的PyAudio库。</p><h2 id="f73a" class="kc kd hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">客户A</h2><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5bf3" class="kc kd hi jy b fi ke kf l kg kh">import os<br/>from pyfiglet import Figletos.system("clear")<br/>pyf = Figlet(font='puffy')<br/>a = pyf.renderText("UDP Chat App with Multi-Threading")<br/>os.system("tput setaf 3")<br/>print(a)</span><span id="2520" class="kc kd hi jy b fi ki kf l kg kh">import socket, cv2, pickle, struct, threading, time</span><span id="1352" class="kc kd hi jy b fi ki kf l kg kh"># Socket Create<br/>s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><span id="8506" class="kc kd hi jy b fi ki kf l kg kh"># Socket Accept<br/>def sender():<br/> time.sleep(15)<br/> host_name  = socket.gethostname()<br/> host_ip = socket.gethostbyname(host_name)<br/> print('Host IP:',host_ip)<br/> port = 9999<br/> socket_address = (host_ip,port)</span><span id="264d" class="kc kd hi jy b fi ki kf l kg kh"># Socket Bind<br/> s.bind(socket_address)</span><span id="9015" class="kc kd hi jy b fi ki kf l kg kh"># Socket Listen<br/> s.listen(5)<br/> print("Listening at:",socket_address)<br/> while True:<br/>  client_socket,addr = s.accept()<br/>  print('Connection to:',addr)<br/>  if client_socket:<br/>   vid = cv2.VideoCapture(0)<br/>  <br/>   while(vid.isOpened()):<br/>    ret,image = vid.read()<br/>    img_serialize = pickle.dumps(image)<br/>    message = struct.pack("Q",len(img_serialize))+img_serialize<br/>    client_socket.sendall(message)<br/>   <br/>    cv2.imshow('Video from server', image)<br/>    key = cv2.waitKey(10) <br/>    if key ==13:<br/>     client_socket.close()</span><span id="fdd2" class="kc kd hi jy b fi ki kf l kg kh">#Audio<br/>chunk = 1024<br/>FORMAT = pyaudio.paInt16<br/>CHANNELS = 1<br/>RATE = 44100</span><span id="b378" class="kc kd hi jy b fi ki kf l kg kh">p = pyaudio.PyAudio()</span><span id="2362" class="kc kd hi jy b fi ki kf l kg kh">stream = p.open(format = FORMAT,<br/>                channels = CHANNELS,<br/>                rate = RATE,<br/>                input = True,<br/>                frames_per_buffer = chunk)</span><span id="d2dc" class="kc kd hi jy b fi ki kf l kg kh">#Audio Socket Initialization<br/>audioSocket = socket.socket()<br/>port1 = 5000<br/>audioSocket.bind((&lt;IP&gt;,port1))<br/>audioSocket.listen(5)<br/>cAudio, addr = audioSocket.accept()</span><span id="92bc" class="kc kd hi jy b fi ki kf l kg kh">def recordAudio():<br/>    time.sleep(5)<br/>    while True:<br/>        data = stream.read(chunk)<br/>        if data:<br/>            cAudio.sendall(data)</span><span id="0750" class="kc kd hi jy b fi ki kf l kg kh">def rcvAudio():<br/>     while True:<br/>          audioData = audioSocket.recv(size)<br/>          stream.write(audioData)</span><span id="5ee2" class="kc kd hi jy b fi ki kf l kg kh">def connect_server():<br/> host_ip = '&lt;IP&gt;' <br/> port = 1234<br/> s.connect((host_ip,port)) <br/> data = b""<br/> metadata_size = struct.calcsize("Q")<br/> while True:<br/>  while len(data) &lt; metadata_size:<br/>   packet = s.recv(4*1024) <br/>   if not packet: break<br/>   data+=packet<br/>  packed_msg_size = data[:metadata_size]<br/>  data = data[metadata_size:]<br/>  msg_size = struct.unpack("Q",packed_msg_size)[0]<br/> <br/>  while len(data) &lt; msg_size:<br/>   data += s.recv(4*1024)<br/>  frame_data = data[:msg_size]<br/>  data  = data[msg_size:]<br/>  frame = pickle.loads(frame_data)<br/>  cv2.imshow("Receiving Video",frame)<br/>  key = cv2.waitKey(10) <br/>  if key  == 13:<br/>   break<br/> s.close()</span><span id="3b1a" class="kc kd hi jy b fi ki kf l kg kh">x1 = threading.Thread(target = sender)<br/>x2 = threading.Thread(target = connect_server)<br/>x3 = threading.Thread(target = recordAudio)<br/>x4 = threading.Thread(target = rcvAudio)</span><span id="bdae" class="kc kd hi jy b fi ki kf l kg kh"># start a thread<br/>x1.start()<br/>x2.start()<br/>x3.start()<br/>x4.start()</span></pre><h2 id="2c12" class="kc kd hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">客户B</h2><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="27d6" class="kc kd hi jy b fi ke kf l kg kh">import os<br/>from pyfiglet import Figletos.system("clear")<br/>pyf = Figlet(font='puffy')<br/>a = pyf.renderText("UDP Chat App with Multi-Threading")<br/>os.system("tput setaf 3")<br/>print(a)</span><span id="d43d" class="kc kd hi jy b fi ki kf l kg kh">import socket, cv2, pickle, struct, time, threading</span><span id="df1e" class="kc kd hi jy b fi ki kf l kg kh"># create socket<br/>s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><span id="494c" class="kc kd hi jy b fi ki kf l kg kh">def connect_server():<br/> time.sleep(15)<br/> host_ip = '192.168.99.1' <br/> port = 9999<br/> s.connect((host_ip,port)) <br/> data = b""<br/> metadata_size = struct.calcsize("Q")<br/> while True:<br/>  while len(data) &lt; metadata_size:<br/>   packet = s.recv(4*1024) <br/>   if not packet: break<br/>   data+=packet<br/>  packed_msg_size = data[:metadata_size]<br/>  data = data[metadata_size:]<br/>  msg_size = struct.unpack("Q",packed_msg_size)[0]<br/> <br/>  while len(data) &lt; msg_size:<br/>   data += s.recv(4*1024)<br/>   frame_data = data[:msg_size]<br/>   data  = data[msg_size:]<br/>   frame = pickle.loads(frame_data)<br/>   cv2.imshow("Receiving Video", frame)<br/>   key = cv2.waitKey(10) <br/>   if key  == 13:<br/>    break<br/> s.close()</span><span id="c2f6" class="kc kd hi jy b fi ki kf l kg kh">def sender():<br/> host_name  = socket.gethostname()<br/> host_ip = socket.gethostbyname(host_name)<br/> print('Host IP:',host_ip)<br/> port = 1234<br/> socket_address = (host_ip,port)<br/> # Socket Bind<br/> s.bind(socket_address)<br/> # Socket Listen<br/> s.listen(5)<br/> print("Listening at:",socket_address)<br/> while True:<br/>  client_socket,addr = s.accept()<br/>  print('Connected to:',addr)<br/>  if client_socket:<br/>   vid = cv2.VideoCapture(1)<br/>  <br/>   while(vid.isOpened()):<br/>    ret,image = vid.read()<br/>    img_serialize = pickle.dumps(image)<br/>    message = struct.pack("Q",len(img_serialize))+img_serialize<br/>    client_socket.sendall(message)<br/>   <br/>    cv2.imshow('Video from server',image)<br/>    key = cv2.waitKey(10) <br/>    if key ==13:<br/>     client_socket.close()</span><span id="b7e8" class="kc kd hi jy b fi ki kf l kg kh">#Audio<br/>chunk = 1024<br/>FORMAT = pyaudio.paInt16<br/>CHANNELS = 1<br/>RATE = 44100</span><span id="3ef2" class="kc kd hi jy b fi ki kf l kg kh">p = pyaudio.PyAudio()</span><span id="4958" class="kc kd hi jy b fi ki kf l kg kh">stream = p.open(format = FORMAT,<br/>                channels = CHANNELS,<br/>                rate = RATE,<br/>                input = True,<br/>                frames_per_buffer = chunk)</span><span id="63cf" class="kc kd hi jy b fi ki kf l kg kh">#Audio Socket Initialization<br/>audioSocket = socket.socket()<br/>port1 = 5000<br/>audioSocket.bind((&lt;IP&gt;,port1))<br/>audioSocket.listen(5)<br/>cAudio, addr = audioSocket.accept()</span><span id="2d2e" class="kc kd hi jy b fi ki kf l kg kh">def recordAudio():<br/>    time.sleep(5)<br/>    while True:<br/>        data = stream.read(chunk)<br/>        if data:<br/>            cAudio.sendall(data)</span><span id="f219" class="kc kd hi jy b fi ki kf l kg kh">def rcvAudio():<br/>     while True:<br/>          audioData = audioSocket.recv(size)<br/>          stream.write(audioData)</span><span id="4353" class="kc kd hi jy b fi ki kf l kg kh">x1 = threading.Thread(target = connect_server)<br/>x2 = threading.Thread(target = sender)<br/>x3 = threading.Thread(target = recordAudio)<br/>x4 = threading.Thread(target = rcvAudio)</span><span id="3541" class="kc kd hi jy b fi ki kf l kg kh">x1.start()<br/>x2.start()<br/>x3.start()<br/>x4.start()</span></pre><p id="3613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在PyAudio库中，我们需要指定格式、通道、速率、输入和帧/缓冲区。</p><p id="993f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为音频创建了一个单独的套接字，这样它就不会干扰视频流。</p><p id="d825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以在不同的计算机上运行ClientA.py和ClientB.py，玩得很开心。</p></div></div>    
</body>
</html>
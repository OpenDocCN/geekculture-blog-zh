<html>
<head>
<title>Demystifying Python Dictionaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Python字典的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/demystifying-python-dictionaries-91dc98bca87e?source=collection_archive---------15-----------------------#2021-09-30">https://medium.com/geekculture/demystifying-python-dictionaries-91dc98bca87e?source=collection_archive---------15-----------------------#2021-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cce11566099ef6040c6f7efc095a95ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X2waJd5v_EjFxvNU"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément Hélardot</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="43b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你曾经在Python中有过某种需要字典参与的任务，那么你可能已经在Google上找到了很多信息。我知道这一点，因为我也曾和你处于同样的位置。问题是你很少能找到为什么你应该以这样或那样的方式使用字典的详细解释，所以我决定把所有的部分放在这里，并展示在Python中使用字典时你可以有哪些选择，以及如何更好地理解它们。</p><h1 id="1168" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Python中的字典是什么？</h1><p id="22fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">简单明了地说，字典是一种数据结构，它由<strong class="ix hj">键:值</strong>对<strong class="ix hj">和</strong>组成，要求字典中的每个键都必须是唯一的。字典中不可能有两个不同的条目具有相同的键。这些<strong class="ix hj">键:值</strong>对必须用逗号分隔。<strong class="ix hj"> </strong>你得用大括号<strong class="ix hj"> {} </strong>。例如，要创建第一个空字典，您可以编写:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e3b0" class="lf ju hi lb b fi lg lh l li lj">my_first_dict = {}<br/>print(my_first_dict)<br/>print(type(my_first_dict))</span></pre><p id="286d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ce05" class="lf ju hi lb b fi lg lh l li lj">{}<br/>&lt;class 'dict'&gt;</span></pre><p id="3bd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，如果我们打印出字典的类型，您会看到这个用空括号<strong class="ix hj"> {} </strong>创建的对象属于<strong class="ix hj"> dict </strong>类。这意味着我们将有很多方法可以在字典中使用，但是以后会有更多。</p><p id="05b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不管怎样，你也可以使用<strong class="ix hj"> dict </strong>构造函数创建一个字典:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a07f" class="lf ju hi lb b fi lg lh l li lj">my_second_dict = dict()<br/>print(my_second_dict)<br/>print(type(my_second_dict))</span></pre><p id="8c68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5c06" class="lf ju hi lb b fi lg lh l li lj">{}<br/>&lt;class 'dict'&gt;</span></pre><p id="8d72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，输出与使用方括号<strong class="ix hj"> {} </strong>创建字典是一样的。从功能的角度来看，没有。两个字典的行为是一样的，但是方括号<strong class="ix hj"> {} </strong>的方法更快。问题是为什么？要回答这个问题，你需要从<strong class="ix hj"> dis </strong>模块中获得一些帮助。它是Python字节码的反汇编器。官方文档可在以下官方网站上找到:</p><div class="lk ll ez fb lm ln"><a href="https://docs.python.org/3/library/dis.html" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">Python字节码的反汇编器——Python 3 . 9 . 7文档</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">该模块通过反汇编来支持对CPython的分析。这个模块将CPython字节码作为…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">docs.python.org</p></div></div></div></a></div><p id="ac8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我不会深入讨论dis模块，因为这值得在另一篇文章中讨论。现在，我们已经知道<strong class="ix hj"> dis </strong>模块有一个分析功能，也叫做<strong class="ix hj"> dis </strong>，所以要使用它，我们可以定义如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4c03" class="lf ju hi lb b fi lg lh l li lj">from dis import dis</span></pre><p id="13dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以使用这个<strong class="ix hj"> dis </strong>函数并传递一串将被反编译的源代码。所以让我们将它与<strong class="ix hj"> {} </strong>和<strong class="ix hj"> dist()一起使用。为了更好的可视化，我添加了一个空的print语句。</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e635" class="lf ju hi lb b fi lg lh l li lj">dis("{}")<br/>print("")<br/>dis("dict()")</span></pre><p id="1e16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9567" class="lf ju hi lb b fi lg lh l li lj">1           0 BUILD_MAP                0<br/>            2 RETURN_VALUE</span><span id="9f58" class="lf ju hi lb b fi lw lh l li lj">1           0 LOAD_NAME                0 (dict)<br/>            2 CALL_FUNCTION            0<br/>            4 RETURN_VALUE</span></pre><p id="5b35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们在上面看到了什么？让我们从左边的数字开始，它在两种情况下都是<strong class="ix hj"> 1 </strong>。这是被分析代码的行号。因为我们的代码只有一行，所以显示的是1。如果你反编译一个函数或者有更多行的东西，你会看到每一行产生更多的数字和指令。</p><p id="85fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在可以看到，在python中调用<strong class="ix hj"> {} </strong>只生成了两条指令:<strong class="ix hj"> <em class="lx"> BUILD_MAP </em> </strong>和<strong class="ix hj"> <em class="lx"> RETURN_VALUE。</em> </strong>什么<strong class="ix hj"> <em class="lx"> BUILD_MAP </em> </strong>指令它基本上会从堆栈中存储的元素构建一个字典对象。然后<strong class="ix hj"> <em class="lx"> RETURN_VALUE </em> </strong>会简单的将结果返回给函数的调用者。所以这只是两条指令。现在，在使用<strong class="ix hj"> dict() </strong>的情况下我们可以看到第一条指令是<strong class="ix hj"> <em class="lx"> LOAD_NAME。</em> </strong>该指令将传递给<strong class="ix hj"> <em class="lx"> dict() </em> </strong>构造函数的参数推送到堆栈上。接下来，<strong class="ix hj"><em class="lx">CALL _ FUNCTION</em></strong>指令将弹出所有被推入堆栈的值，然后它将使用这些值作为自变量，并将调用可调用对象。结果将被推回堆栈。请注意，从Python 3.6版本开始，此指令仅用于带有位置参数的调用。最后一条指令是<strong class="ix hj"> <em class="lx"> RETURN_VALUE </em> </strong>，我们已经讨论过了。所以，如你所见，使用<strong class="ix hj"> <em class="lx"> dict() </em> </strong>构造函数创建字典会反编译intro三条指令，<strong class="ix hj"> <em class="lx"> {} </em> </strong>会反编译成两条。</p><p id="9c43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您可以使用相同的方法通过传递一个<strong class="ix hj"> <em class="lx">键:值</em> </strong>对来尝试:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5852" class="lf ju hi lb b fi lg lh l li lj">dis("{\"One\":1}")<br/>print("")<br/>dis("dict(One=1)")<br/>print("")</span></pre><p id="3566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6ae4" class="lf ju hi lb b fi lg lh l li lj">1           0 LOAD_CONST               0 ('One')<br/>            2 LOAD_CONST               1 (1)<br/>            4 BUILD_MAP                1<br/>            6 RETURN_VALUE</span><span id="44e4" class="lf ju hi lb b fi lw lh l li lj">1           0 LOAD_NAME                0 (dict)<br/>            2 LOAD_CONST               0 (1)<br/>            4 LOAD_CONST               1 (('One',))<br/>            6 CALL_FUNCTION_KW         1<br/>            8 RETURN_VALUE</span></pre><p id="033a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你大概看到了，几乎所有的指令都是一样的，除了<strong class="ix hj"> <em class="lx"> LOAD_CONST </em> </strong>指令是为了将参数压入堆栈而生成的。还有，生成<strong class="ix hj"><em class="lx">CALL _ FUNCTION _ KW</em></strong>而不是<strong class="ix hj"> <em class="lx"> CALL_FUNCTION。</em> </strong>当关键字参数作为而不是位置参数传递给对象时，生成该指令。无论如何，你可以看到用<strong class="ix hj"> <em class="lx"> {} </em> </strong>语法创建字典总是比使用<strong class="ix hj"> <em class="lx"> dict()少编译成一条指令。</em>T71】</strong></p><p id="e768" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我不确定在python中是否有可能测量单独指令的执行速度(如果你知道如何做，请在评论中分享)，但肯定我们可以使用python中的<strong class="ix hj"> <em class="lx"> timeit </em> </strong>模块来测量各种函数或一段源代码的执行时间。我也不会深入这个模块，因为这不是本文的范围，但我可以说，这个模块有<strong class="ix hj"> <em class="lx"> timeit </em> </strong>函数<strong class="ix hj"> <em class="lx">，</em> </strong>，您可以向其传递要测量的源代码和一个计数器，它将显示代码片段将被执行多少次。首先，让我们从<strong class="ix hj"> <em class="lx"> timeit </em> </strong>模块中导入<strong class="ix hj"> <em class="lx"> timeit </em> </strong>函数</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3e07" class="lf ju hi lb b fi lg lh l li lj">from timeit import timeit</span></pre><p id="26da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，让我们用<strong class="ix hj"> <em class="lx"> {} </em> </strong>和<strong class="ix hj"> <em class="lx"> dict() </em> </strong>方法创建一个字典1000万次。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2e0a" class="lf ju hi lb b fi lg lh l li lj">print(timeit("{}", number=10**7))<br/>print(timeit("dict()", number=10**7))</span></pre><p id="88fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fc57" class="lf ju hi lb b fi lg lh l li lj">0.5059882<br/>1.6348104</span></pre><p id="9e1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这显示了用这两种方式创建字典一千万次需要多少秒。可以看到，<strong class="ix hj"> <em class="lx"> {} </em> </strong>方法大约快三倍。当然，请记住，这将因机器而异，您将在这里看到不同的结果(即使您运行此代码10次，您可能也不会得到相同的结果，因为这取决于您的CPU负载。但总的来说，你应该能看到明显的区别。</p><p id="4903" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以现在我们知道，使用<strong class="ix hj"> <em class="lx"> {} </em> </strong>语法创建字典比使用<strong class="ix hj"> <em class="lx"> dict() </em> </strong>更快。那么我们是否应该停止使用<strong class="ix hj"> <em class="lx"> dict() </em> </strong>？如果你的演唱会是速度和速度只有那么我会说是，但使用<strong class="ix hj"> <em class="lx"> dict() </em> </strong>你可以实现一些事情更容易，使代码看起来更干净。例如，您可以拥有一个由带有<strong class="ix hj"> <em class="lx">键、值</em> </strong>对的列表组成的列表，如下例所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6204" class="lf ju hi lb b fi lg lh l li lj">sample_list = [["One", 1], ["Four", 4], ["Six", 6]]</span></pre><p id="430d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，您可以简单地将这个列表传递给<strong class="ix hj"><em class="lx">dict()</em></strong>construct，它将为您构建一个字典:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bbdc" class="lf ju hi lb b fi lg lh l li lj">my_dict_v1 = dict(sample_list)<br/>print(my_dict_v1)</span></pre><p id="574f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c9ec" class="lf ju hi lb b fi lg lh l li lj">{'One': 1, 'Four': 4, 'Six': 6}</span></pre><p id="b6b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果您想使用<strong class="ix hj"> <em class="lx"> {} </em> </strong>构造来做同样的事情，您将不得不遍历list对象并将新的键及其值添加到空字典中:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bad6" class="lf ju hi lb b fi lg lh l li lj">sample_list = [["One", 1], ["Four", 4], ["Six", 6]]</span><span id="9337" class="lf ju hi lb b fi lw lh l li lj">my_dict_v2 = {}<br/>for key, value in sample_list:<br/>    my_dict_v2[key] = value<br/><br/>print(my_dict_v2)</span></pre><p id="dae3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lx">输出:</em> </strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9cd7" class="lf ju hi lb b fi lg lh l li lj">{'One': 1, 'Four': 4, 'Six': 6}</span></pre><p id="fb2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，如果你了解字典理解，你可以这样做:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8bb5" class="lf ju hi lb b fi lg lh l li lj">my_dict_v3 = {key: value for (key, value) in sample_list}<br/>print(my_dict_v3)</span></pre><p id="f71c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b634" class="lf ju hi lb b fi lg lh l li lj">{'One': 1, 'Four': 4, 'Six': 6}</span></pre><p id="11c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到这三种情况下的输出是相同的，但我个人认为<strong class="ix hj"> <em class="lx"> dict() </em> </strong>方法最容易阅读和理解，因为在看到一个单词<strong class="ix hj"> dict </strong>后，我立即知道我们要在这里创建一个dictionary对象。其他构造需要通读代码，看看发生了什么。当然，这只是我的个人观点，但我的目标不是说哪种方法是最好的，而是展示在使用字典时你有哪些选择，以便你可以决定哪种选择更适合你。顺便说一下，如果你不理解字典理解的例子，不要担心。只要稍加练习，这是有意义的。</p><p id="50d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论如何，关于使用<strong class="ix hj"> <em class="lx"> dict() </em> </strong>构造函数创建字典，我还想分享一件事——你可以将关键字参数传递给构造函数，它会创建一个字典:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a361" class="lf ju hi lb b fi lg lh l li lj">kwargs_dict = dict(position=4, name="Peter", Color="Blue", id=25663)<br/>print(kwargs_dict)<br/>print(type(kwargs_dict))</span></pre><p id="4fcd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="00b5" class="lf ju hi lb b fi lg lh l li lj">{'position': 4, 'name': 'Peter', 'Color': 'Blue', 'id': 25663}<br/>&lt;class 'dict'&gt;</span></pre><p id="5a65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用字典的<strong class="ix hj"> <em class="lx"> {} </em> </strong>构造无法做到这一点。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="fd48" class="jt ju hi bd jv jw mf jy jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq bi translated">字典方法</h1><p id="a744" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这一节中，我想快速回顾一下使用词典时需要用到的一些最常见的方法。首先，让我们创建一个示例字典。为了简单起见，让我们使用与上一个例子中相同的字典，就叫它example_dict:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7c6d" class="lf ju hi lb b fi lg lh l li lj">example_dict = dict(position=4, name="Peter", Color="Blue", id=25663)</span></pre><p id="7b5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么有了这本字典，你可以用什么方法呢？最常见的事情之一是知道你的字典的所有键。您可以通过使用<strong class="ix hj"> <em class="lx"> keys() </em> </strong>方法来实现:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e6ed" class="lf ju hi lb b fi lg lh l li lj">print(example_dict.keys())</span></pre><p id="4de8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="137a" class="lf ju hi lb b fi lg lh l li lj">dict_keys(['position', 'name', 'Color', 'id'])</span></pre><p id="3999" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么需要字典键之类的东西呢？好吧，也许你想遍历你的字典并通过键访问它的值:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="164c" class="lf ju hi lb b fi lg lh l li lj">for key in example_dict.keys():<br/>    print(f"key:{key}, value:{example_dict[key]}")</span></pre><p id="b9aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3941" class="lf ju hi lb b fi lg lh l li lj">key:position, value:4<br/>key:name, value:Peter<br/>key:Color, value:Blue<br/>key:id, value:25663</span></pre><p id="41dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一件很常见的事情是获取字典中的所有值。可以通过调用<strong class="ix hj"> <em class="lx"> values() </em> </strong>方法来实现。当您对字典值感兴趣，但对键不感兴趣时，可以使用这个方法。例如，假设您有一个字典，其中的键是某种问题跟踪系统中的票证id，值是程序员或其他任何人在该问题上花费的小时数。因此，如果您想知道在这些问题上花费了多少时间(忽略问题本身)，您可以使用<strong class="ix hj"> <em class="lx"> values() </em> </strong>方法。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0986" class="lf ju hi lb b fi lg lh l li lj">example_dict_v1 = {"Ticket-1": 8, "Ticket-2": 20, "Ticket-3": 36}<br/>print(example_dict_v1.values())<br/><br/>for value in example_dict_v1.values():<br/>    print(f"Hours spent:{value}")</span></pre><p id="5094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dc24" class="lf ju hi lb b fi lg lh l li lj">dict_values([8, 20, 36])<br/>Hours spent:8<br/>Hours spent:20<br/>Hours spent:36</span></pre><p id="a421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用字典的另一个非常有用的方法是<strong class="ix hj"> get() </strong>。您必须将一个键名传递给<strong class="ix hj"> get() </strong>方法，它返回与该键相关的值，但是这个方法的好处是，如果字典中不存在该键，那么它返回<strong class="ix hj"> <em class="lx"> None </em> </strong>。所以举个例子，如果我们有和上例一样的字典<strong class="ix hj"> <em class="lx"> example_dict_v1，</em> </strong>那么下面的尝试会导致异常(因为<strong class="ix hj"><em class="lx">【Ticket-6】</em></strong>键在字典中不存在):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4338" class="lf ju hi lb b fi lg lh l li lj">hours_on_issue = example_dict_v1["Ticket-6"]</span></pre><p id="8db6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="eaac" class="lf ju hi lb b fi lg lh l li lj">Traceback (most recent call last):<br/>  File "C:/python_projects/dictionaries_review/main.py", line 70, in &lt;module&gt;<br/>    hours_on_issue = example_dict_v1["Ticket-6"]<br/>KeyError: 'Ticket-6'</span></pre><p id="4d49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是一件好事，因为它会导致你的程序崩溃。因此，为了避免这种情况，您必须添加try/catch块来处理任何意外的异常，但是我们实际上并不需要这样做，因为我们已经有了<strong class="ix hj"><em class="lx"/></strong>方法——如果关键字不在字典中，它就简单地返回None。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ac92" class="lf ju hi lb b fi lg lh l li lj">hours_on_issue = example_dict_v1.get("Ticket-6")<br/>print(hours_on_issue)</span></pre><p id="f557" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d65b" class="lf ju hi lb b fi lg lh l li lj">None</span></pre><p id="4acd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果你想用新值更新我们的字典，该怎么做呢？例如，添加一个新的票证问题及其花费的时间？嗯，我们有<strong class="ix hj"><em class="lx"/></strong>更新()<strong class="ix hj"> <em class="lx"> : </em> </strong>的方法</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8e51" class="lf ju hi lb b fi lg lh l li lj">example_dict_v1.update({"Ticket-13": 48})<br/>example_dict_v1.update(Ticket16=28)<br/>print(example_dict_v1)</span></pre><p id="b589" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7025" class="lf ju hi lb b fi lg lh l li lj">{'Ticket-1': 8, 'Ticket-2': 20, 'Ticket-3': 36, 'Ticket-13': 48, 'Ticket16': 28}</span></pre><p id="e827" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我在这里展示了两种方式:您可以添加新元素，就像添加另一个带有<strong class="ix hj"> <em class="lx"> {} </em> </strong>构造的字典一样，或者您可以通过关键字参数语法添加带有值的新键。无论如何，您可以看到我们的字典已经用新的键成功更新了。</p><p id="9f6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我窟讨论的最后两个方法是<strong class="ix hj"><em class="lx"/></strong>copy()和<strong class="ix hj"> <em class="lx"> pop()。</em> </strong>我认为在一个例子中谈论它们是一个好主意，因为如果你将你的字典分配给另一个字典而没有<strong class="ix hj"> <em class="lx"> copy() </em> </strong>并对其执行操作，就有可能产生一些相当严重的错误。所以，让我们假设你想把你当前的字典分配给另一个对象，并从中删除一些键。因此，您可以通过使用<strong class="ix hj"> <em class="lx"> pop() </em> </strong>方法并提供您想要移除的键来移除任何<strong class="ix hj"> <em class="lx"> key:value </em> </strong>对。但是这里有一个问题——您的新对象实际上会保存对原始dictionary对象的引用，因此通过对新对象进行操作，您也将对原始对象执行操作。考虑下面的例子:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8a1e" class="lf ju hi lb b fi lg lh l li lj">example_dict_v1_copy = example_dict_v1<br/>print(hex(id(example_dict_v1)))<br/>print(hex(id(example_dict_v1_copy)))<br/>example_dict_v1_copy.pop("Ticket-13")<br/>print(example_dict_v1)<br/>print(example_dict_v1_copy)</span></pre><p id="a6f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5a04" class="lf ju hi lb b fi lg lh l li lj">0x101a4e0<br/>0x101a4e0<br/>{'Ticket-1': 8, 'Ticket-2': 20, 'Ticket-3': 36, 'Ticket16': 28}<br/>{'Ticket-1': 8, 'Ticket-2': 20, 'Ticket-3': 36, 'Ticket16': 28}</span></pre><p id="12db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，我想在不影响原有内容的情况下，从我的名为<strong class="ix hj"><em class="lx">example _ dict _ v1 _ copy</em></strong>的新字典中删除一个键，但事实并非如此。你可以看到<strong class="ix hj"> <em class="lx"> Ticket-13 </em> </strong>键从两个字典中都被删除了。正如我所说，这是因为您的新dictionary对象只是对原始对象的引用(指向原始dictionary所在的内存位置)。通过使用<strong class="ix hj"> <em class="lx"> id() </em> </strong>函数打印我们的对象在内存中驻留的地址来证明这一点。这就是<strong class="ix hj"> <em class="lx"> copy() </em> </strong>方法的用武之地。如果您在将它分配给新字典对象时将其用于原始字典对象，将在内存中创建一个新对象，并且在操作新字典时不会影响原始字典:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3e63" class="lf ju hi lb b fi lg lh l li lj">example_dict_v1_true_copy = example_dict_v1.copy()<br/>print(hex(id(example_dict_v1)))<br/>print(hex(id(example_dict_v1_true_copy)))<br/>example_dict_v1_true_copy.pop("Ticket-1")<br/>print(example_dict_v1)<br/>print(example_dict_v1_true_copy)</span></pre><p id="f0c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9f0f" class="lf ju hi lb b fi lg lh l li lj">0x101a4e0<br/>0x101a4b0<br/>{'Ticket-1': 8, 'Ticket-2': 20, 'Ticket-3': 36, 'Ticket16': 28}<br/>{'Ticket-2': 20, 'Ticket-3': 36, 'Ticket16': 28}</span></pre><p id="e8a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，这一次原始字典没有受到影响，它们现在是不同的对象，您实际上可以看到，通过再次使用<strong class="ix hj"> <em class="lx"> id() </em> </strong>函数打印对象驻留在内存中的位置。</p><p id="ce3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后我想说的是，这与字典无关，但它可以帮助你检查Python中的任何对象。所以Python内置了名为<strong class="ix hj"> <em class="lx">的函数help() </em> </strong>。您可以将任何想要的对象传递给这个函数，Python将显示它所知道的关于所请求对象的所有信息。您可以在此了解更多信息:</p><div class="lk ll ez fb lm ln"><a href="https://docs.python.org/3/library/functions.html#help" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">内置函数- Python 3.9.7文档</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">Python解释器内置了许多始终可用的函数和类型。它们被列出…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">docs.python.org</p></div></div></div></a></div><p id="a302" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果你想了解更多关于字典的知识，你可以这样写:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="eb77" class="lf ju hi lb b fi lg lh l li lj">help(dict)</span></pre><p id="25a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4b71" class="lf ju hi lb b fi lg lh l li lj">Help on class dict in module builtins:</span><span id="00e9" class="lf ju hi lb b fi lw lh l li lj">class dict(object)<br/> |  dict() -&gt; new empty dictionary<br/> |  dict(mapping) -&gt; new dictionary initialized from a mapping object's<br/> |      (key, value) pairs<br/> |  dict(iterable) -&gt; new dictionary initialized as if via:<br/> |      d = {}<br/> |      for k, v in iterable:<br/> |          d[k] = v<br/> |  dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs<br/> |      in the keyword argument list.  For example:  dict(one=1, two=2)<br/> |  <br/> |  Methods defined here:</span><span id="f95d" class="lf ju hi lb b fi lw lh l li lj">....</span></pre><p id="a3dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不打算在这里添加完整的输出，因为它很长，但我希望你得到的想法。</p><h1 id="a90b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="9827" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在Python中使用字典可能有点棘手。我希望本文不仅能帮助您理解字典，还能帮助您探索其他python对象并更快地了解它们。</p><p id="b47b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有示例代码都位于我的github库下面:<a class="ae iu" href="https://github.com/vycart/python_dictionaries" rel="noopener ugc nofollow" target="_blank">https://github.com/vycart/python_dictionaries</a></p><p id="6cb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有任何问题，我很乐意回答。</p><p id="463c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Find Missing Number: using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查找缺失的数字:使用Python</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/find-missing-number-using-python-c3ae99b78f4c?source=collection_archive---------6-----------------------#2021-11-28">https://medium.com/geekculture/find-missing-number-using-python-c3ae99b78f4c?source=collection_archive---------6-----------------------#2021-11-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="451d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们利用这个介绍性的问题来发展算法思维</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/cc54231108e114aef6ecaafa99d5160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*3hw1X_YLE9wBa1zOxnej-w.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx"><a class="ae jj" href="https://github.com/keon/algorithms" rel="noopener ugc nofollow" target="_blank">https://github.com/keon/algorithms</a></figcaption></figure><p id="5ec8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这是一个简单的水平问题，但我们试图用多种方法来解决它。这个例子是为那些试图提高解决问题能力的初学者准备的。</p><p id="bef6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">问题陈述:</strong></p><blockquote class="kg kh ki"><p id="2548" class="jk jl kj jm b jn jo ij jp jq jr im js kk ju jv jw kl jy jz ka km kc kd ke kf hb bi translated">给定一个包含范围<code class="du kn ko kp kq b"><em class="hi">[0, n]</em></code>中的<code class="du kn ko kp kq b"><em class="hi">n</em></code>个不同数字的数组<code class="du kn ko kp kq b"><em class="hi">nums</em></code>，返回数组中唯一缺少的数字<em class="hi">。</em></p><p id="fff5" class="jk jl kj jm b jn jo ij jp jq jr im js kk ju jv jw kl jy jz ka km kc kd ke kf hb bi translated">测试用例示例:<br/> <strong class="jm hj">输入:</strong> nums = [3，0，1] <br/> <strong class="jm hj">输出:</strong> 2 <br/> <strong class="jm hj">输入:</strong> nums = [0，1] <br/> <strong class="jm hj">输出:</strong> 2 <br/> <strong class="jm hj">输入:</strong> nums = [0] <br/> <strong class="jm hj">输出:</strong> 1</p></blockquote><p id="10e4" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在开始实现之前，我们应该通过理解问题陈述来发展我们的直觉。</p><p id="3ef8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们有一个大小为6(数组长度)的数组，由[3，2，1，0，6，5]组成。任务是从给定的数组中找到缺失的值。一看就可以说少了4，对。我们将开发一种算法来找到这个丢失的数字。</p><p id="a99f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">方法#1: </strong> <a class="ae jj" href="https://www.freecodecamp.org/news/brute-force-algorithms-explained/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj">蛮力</strong> </a> <strong class="jm hj"> </strong> <br/>算法:<br/> 1。在数组长度范围内线性扫描数组(含)<br/> 2。检查迭代值是否在数组<br/> 3中。如果不在数组中，则返回值</p><pre class="iy iz ja jb fd kr kq ks kt aw ku bi"><span id="4ae8" class="kv kw hi kq b fi kx ky l kz la">def missingNumber(self, nums):<br/>    n = len(nums)<br/>        for num in range(length+1):#traversing through range of n<br/>            if num not in nums:   #searching for the number in array<br/>                return num        #returning the missing number</span></pre><p id="aec5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">时间复杂度:O(n ) <br/>空间复杂度:O(1)</p><p id="d7d2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在数组中搜索的时间复杂度是O(n ),并且因为它是在线性扫描的循环中，所以时间复杂度是O(n)。因此，总时间复杂度是n*n或n，即，对于每次迭代，它查看n个项目(在最坏的情况下)。由于除了长度(取O(1))之外，我们没有使用任何空间来存储，所以空间复杂度保持不变，为O(1)。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="bacf" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">方法#2:修改蛮力使用</strong> <a class="ae jj" href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj">设置</strong> </a> <br/>算法同上，略有修改。我们使用<em class="kj"> set </em>来存储数组值，然后搜索帮助我们大幅提高性能的元素。<br/>T49】算法:T51】1。扫描通过<strong class="jm hj"> <em class="kj">设置</em> </strong>在数组长度范围内线性(含)<br/> 2。检查迭代值是否在集合<br/> 3中。如果不在集合中，则返回值</p><pre class="iy iz ja jb fd kr kq ks kt aw ku bi"><span id="e762" class="kv kw hi kq b fi kx ky l kz la">def missingNumber(self, nums):<br/>        nums_set = set(nums)    #inserting array elements into a set<br/>        length = len(nums)<br/>        for num in range(length+1):#traversing through the array<br/>            if num not in nums_set: #searching for the number in set<br/>                return num</span></pre><p id="d359" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">时间复杂度:O(n) <br/>空间复杂度:O(n)</p><p id="4e31" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就有意思了！仅仅通过实现set，我们就能够将时间复杂度从O(n)降低到O(n)，<strong class="jm hj">怎么做？</strong> <br/> —在一个集合中搜索的时间复杂度平均为O(1)，其中as for和since是线性扫描的循环，时间复杂度为O(n)。所以总的时间复杂度是O(n)。<br/>由于我们创建了一个长度等于array的集合，使用的空间大小为n，所以空间复杂度为O(n)。</p><p id="32c6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在这种方法中，我们能够以空间复杂度为代价降低时间复杂度。这叫做<em class="kj">取舍。</em></p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="6ea8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">方法#3:高斯公式<br/> </strong>你应该听说过n个自然数之和即n*(n+1)/2的公式。这就是著名的高斯公式。我们将使用这种技术来解决我们的问题。</p><p id="7351" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">算法:<br/> 1。计算n(给定数组的长度)个数的和。设这个为sum_n <br/> 2。计算数组中元素的和，设这个为sum_ele <br/> 3。返回sum_n和sum_ele之差</p><pre class="iy iz ja jb fd kr kq ks kt aw ku bi"><span id="0c06" class="kv kw hi kq b fi kx ky l kz la">def missingNumber(self, nums: List[int]) -&gt; int:<br/>        n = len(nums)<br/>        sum_of_n = ((n*(n+1))/2)  #sum of n numbers<br/>        sum_of_elems = 0<br/>        for num in nums:<br/>            sum_of_elems += num    #total sum of elements in array<br/>            <br/>        return int(sum_of_n - sum_of_elems) #return missing number</span></pre><p id="0a22" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">时间复杂度:O(n) <br/>空间复杂度:O(1)</p><p id="6c09" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们线性遍历数组，即O(n)时间复杂度。<br/>我们还没用过</p><p id="97c3" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这看起来是一个最佳解决方案。但这不能应用于长的长数字，因为n*(n+1)的计算导致一个<a class="ae jj" href="https://en.wikipedia.org/wiki/Integer_overflow" rel="noopener ugc nofollow" target="_blank"> <em class="kj">整数溢出</em> </a> <em class="kj">。</em></p><p id="9e41" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们可以使用位操作来解决这个约束。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="698d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">方法#4:使用位操作</strong></p><p id="b9a3" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这需要对<a class="ae jj" href="https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/" rel="noopener ugc nofollow" target="_blank">位操作</a>有一点了解，算法和上面一样简单。这比上面的方法效率高得多。</p><pre class="iy iz ja jb fd kr kq ks kt aw ku bi"><span id="55b8" class="kv kw hi kq b fi kx ky l kz la">def missingNumber(self, nums):<br/>        missing_num = len(nums)<br/>        for i, num in enumerate(nums):<br/>            missing_num ^= i^ num<br/>        return missing_num</span></pre><p id="ab58" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">时间复杂度:O(n) <br/>空间复杂度:O(1)</p><p id="3aad" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">随意评论。请补充/建议其他方法。</p></div></div>    
</body>
</html>
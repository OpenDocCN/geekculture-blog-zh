<html>
<head>
<title>Distributed Transactions &amp; Two-phase Commit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式事务和两阶段提交</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/distributed-transactions-two-phase-commit-c82752d69324?source=collection_archive---------1-----------------------#2021-03-24">https://medium.com/geekculture/distributed-transactions-two-phase-commit-c82752d69324?source=collection_archive---------1-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ed63" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">剖析两阶段提交</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6aa9d63b1ed1920617df506209c78e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-XFmTrshmrxp9c6e04nBg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Disk</strong></figcaption></figure><h1 id="b66c" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="0817" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在当今世界，数据正以惊人的速度增长。企业已经构建了创新的解决方案来处理海量数据。数据分布在许多机器或数据库中并不罕见。这种技术被称为'<strong class="kh hj"> <em class="lb">分片</em> </strong>'，有助于构建可扩展的&amp;可靠系统。</p><p id="52f9" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">科技公司也在采用微服务架构。在这种类型的架构中，每个微服务管理自己的数据库。为了在不同的数据库中添加或修改数据，它调用负责的微服务。</p><p id="075e" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在多台机器上分发数据会带来一系列挑战。单片非分片系统的数据管理非常简单。Postgres、MySQL等关系数据库。提供现成的A.C.I.D属性。</p><p id="f28b" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">这不适用于分片数据库或分布在微服务中的数据。在本文中，我们将了解处理分布式事务时的原子性。我们将了解一个称为两阶段提交的协议，它可以帮助我们实现同样的目标。那么，我们开始吧。</p><h1 id="5a84" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">整体系统和非分片数据库</h1><p id="221a" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们举一个简单的整体银行应用程序的例子。该系统与管理多个表的单个数据库服务器进行交互。假设数据库正在管理用户的余额。该应用程序负责处理用户的银行交易。</p><p id="d5ca" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">当用户<code class="du lh li lj lk b">A</code>向用户<code class="du lh li lj lk b">B</code>转账时，我们需要确保以下事项:-</p><ol class=""><li id="502e" class="ll lm hi kh b ki lc kl ld ko ln ks lo kw lp la lq lr ls lt bi translated">如果交易成功，系统必须贷记用户<code class="du lh li lj lk b">B's</code>账户&amp;借记用户<code class="du lh li lj lk b">A's</code>账户</li><li id="caa0" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la lq lr ls lt bi translated">事务完成后，数据库服务器可能会崩溃。然而，它必须回到崩溃前的状态</li><li id="ae04" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la lq lr ls lt bi translated">交易失败可能有多种原因。例如:-用户<code class="du lh li lj lk b">A </code>可能没有足够的余额。在这种情况下，两个用户的帐户都不应该更新</li><li id="976d" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la lq lr ls lt bi translated">事务完成后，数据库需要处于一致的状态。例如:-用户<code class="du lh li lj lk b">B</code>不应该在用户<code class="du lh li lj lk b">A </code>没有获得借记的情况下获得贷记</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/27e275bb5083a634b15b21f7aaad11cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lN25U6kp6K1MJxEzEY-RhQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Transaction of 20$</strong></figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/a3bd29e5d6961c71882bc86e07eff05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqf5xElJq4vpZQYOHTTdTw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Possible states after the transaction</strong></figcaption></figure><p id="16c5" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">如果你用关系数据库，它会保证以上四点。关系数据库使用事务来实现同样的目的。事务是一种抽象&amp;它封装了一个工作单元。事务保证数据库中的原子性。因此，要么所有操作都成功完成，要么都不执行。</p><p id="d53a" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">简而言之，事务是数据库可以执行的一组SQL语句。数据库执行每个SQL语句。如果出现故障，它将中止事务。当事务中止时，底层数据不会发生任何变化。从状态的角度来看，这相当于不执行任何语句。</p><p id="3dce" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">如果所有语句都执行了，则提交事务。一旦事务被提交，底层数据就被修改和持久化。</p><p id="ef1d" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">对于上面的示例，数据库事务将由以下语句组成:</p><pre class="iy iz ja jb fd mb lk mc md aw me bi"><span id="7a4c" class="mf jp hi lk b fi mg mh l mi mj"><strong class="lk hj">Begin</strong></span><span id="4bda" class="mf jp hi lk b fi mk mh l mi mj"><strong class="lk hj">update set balance = balance + 20 where user = ‘B’;</strong></span><span id="c7bf" class="mf jp hi lk b fi mk mh l mi mj"><strong class="lk hj">update set balance = balance - 20 where user = ‘A’;</strong></span><span id="867f" class="mf jp hi lk b fi mk mh l mi mj"><strong class="lk hj">Commit</strong></span></pre><p id="32ed" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">假设用户<code class="du lh li lj lk b">A</code>和<code class="du lh li lj lk b">B</code>的初始余额分别为40 $ &amp; 60。以下是执行上述交易的可能性:-</p><ul class=""><li id="567a" class="ll lm hi kh b ki lc kl ld ko ln ks lo kw lp la ml lr ls lt bi translated"><strong class="kh hj">成功</strong>——在这种情况下，事务将被提交。用户<code class="du lh li lj lk b">A's</code>的余额将是20美元&amp;用户<code class="du lh li lj lk b">B's</code>的余额将是80美元。如果数据库在此之后崩溃，它将在恢复后回到相同的状态。</li><li id="0d03" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><strong class="kh hj">失败</strong> -如果在更新用户<code class="du lh li lj lk b">A's</code>余额时出现失败，数据库将中止交易。它将回滚所有的更改。用户的余额不会受到影响。</li></ul><h1 id="63d8" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">分割银行数据库</h1><p id="a4d1" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们现在决定扩展我们的数据库，以满足不断增长的客户。数据分布在多个数据库服务器上。因此，用户A和用户B的数据库记录可能位于不同的碎片中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/70d8862d5d9c3241bf566dff4bf1e9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVIBuAyXu6xBzNAXeKP5HA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Sharded Database</strong></figcaption></figure><p id="3ef9" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在分片数据库的情况下，我们还能保证原子性吗？不，因为只有一个数据库服务器保证原子性。在处理许多数据库服务器时，应用程序有责任使事务原子化。我们将看到我们需要解决哪些不同的错误场景。</p><p id="2022" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们将不得不在两台独立的服务器上执行这两个SQL查询。如果任何一个SQL查询失败，都会导致不一致的状态。我们希望防止这种不一致的状态。</p><p id="1d30" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">我们必须确保事务要么成功完成，要么失败。我们不想让事务中途处于不一致的状态。两阶段提交使得分布式事务本质上是原子的。</p><h1 id="3870" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">两阶段提交</h1><p id="f282" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们现在来看看2阶段协议的工作原理。我们引入一个名为<code class="du lh li lj lk b">Transaction Coordinator</code>的新实体。这个实体编排事务的提交部分。管理单个事务的其他服务器被称为<code class="du lh li lj lk b">Participants</code>。</p><p id="f156" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在我们的例子中，我们有两个事务<code class="du lh li lj lk b">Txn Credit</code> &amp; <code class="du lh li lj lk b">Txn Debit</code>。<code class="du lh li lj lk b">Txn Credit</code>分别运行于<code class="du lh li lj lk b">Shard A</code> &amp; <code class="du lh li lj lk b">Txn Debit</code>运行于<code class="du lh li lj lk b">Shard B</code>。客户端启动两个事务，并将它们发送给两个碎片。下图说明了这一过程。两个数据库服务器都开始执行事务。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/755bb68ee1dc2b364dbb172a8335c49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dK5qkPOHM8V_i-rjIpefKA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Client submits both the transactions</strong></figcaption></figure><p id="30ba" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">稍后，客户端向<code class="du lh li lj lk b">Transaction Coordinator</code>发送提交消息。事务提交现在被<code class="du lh li lj lk b">Transaction Coordinator</code>分成两个阶段。</p><p id="b2e4" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在第一阶段，消息被发送到所有的参与服务器。每个服务器都必须用一个<code class="du lh li lj lk b">OK</code>或<code class="du lh li lj lk b">FAIL</code>消息来响应这个消息。如果能够成功执行交易，服务器会回复一个<code class="du lh li lj lk b">OK</code>。如果在执行过程中出现任何错误，将返回一条<code class="du lh li lj lk b">FAIL</code>消息。例如:-如果在借记交易中账户余额为负。</p><p id="77dd" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated"><code class="du lh li lj lk b">Transaction Coordinator</code>等待所有服务器的响应。一旦收到响应，它将决定提交或中止事务。这成为提交的第二阶段。只有当每个服务器都回复了一个<code class="du lh li lj lk b">OK</code>消息时，事务才会被提交。如果至少有一个服务器以<code class="du lh li lj lk b">FAIL</code>消息响应，事务将被中止。</p><p id="4c74" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">下图显示了每个服务器回复一条<code class="du lh li lj lk b">OK</code>消息的情况。每隔一个服务器从协调器接收一个提交，事务就成功了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/7a149da355baafffdd6dd5b213d78ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRrSqsBKTIS6dvNlUhQCBA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Commit Txn after receiving OK from both the servers</strong></figcaption></figure><p id="f2a2" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在<code class="du lh li lj lk b">FAIL</code>消息的情况下，<code class="du lh li lj lk b">Transaction Coordinator</code>向所有参与者发送中止消息。因此，参与者回滚各个事务。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/37682ecefb5f3f9a20910faf8ff0c6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxQQkQpIoXOmHyxistt2LQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><strong class="bd jn">Rollback the transaction in case of failure</strong></figcaption></figure><p id="138d" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">上述过程确保了分布式事务的原子性。事务要么在所有服务器上提交，要么在所有服务器上回滚。但是，它不会中途处于不一致的状态。不会出现一个账户被贷记而另一个账户没有被借记的情况，反之亦然。</p><h1 id="75ab" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">两阶段提交的缺点</h1><p id="defc" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们现在将探讨两阶段提交的缺点。以下是在分布式系统中使用2-PC的主要缺点</p><ul class=""><li id="ff94" class="ll lm hi kh b ki lc kl ld ko ln ks lo kw lp la ml lr ls lt bi translated"><strong class="kh hj">延迟:</strong>正如我们看到的，事务协调器等待来自所有参与服务器的响应。只有这样，它才能继续第二阶段的提交。这增加了等待时间，并且客户端可能会经历执行缓慢。因此，2-PC不是性能关键型应用的理想选择。</li><li id="5fc0" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><strong class="kh hj">事务协调器:</strong>事务协调器有时会成为单点故障。事务协调器可能会在向所有参与者发送提交消息之前关闭。在这种情况下，在参与者上运行的所有事务都将处于阻塞状态。只有当协调器出现时，它们才会提交&amp;发送提交信号。</li><li id="3f0c" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><strong class="kh hj">参与者依赖:</strong>慢热的参与者会影响其他参与者的表现。总事务时间与最慢的服务器所用的时间成正比。如果事务在一台服务器上失败，它必须在所有其他服务器上回滚。这可能导致资源浪费。</li></ul><p id="b25e" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">使用Saga模式可以克服2PC的所有上述缺点。Saga模式依赖于最终的一致性来处理分布式事务。我们将在另一篇博文中探讨这种模式。</p><h1 id="fbd3" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">参考</h1><ul class=""><li id="9797" class="ll lm hi kh b ki kj kl km ko mq ks mr kw ms la ml lr ls lt bi translated"><a class="ae mt" href="http://Handling Distributed Transactions in the Microservice world | by Sohan Ganapathy | The Startup | Medium" rel="noopener ugc nofollow" target="_blank">在微服务中处理分布式事务</a></li><li id="8b3d" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><a class="ae mt" href="https://timilearning.com/posts/mit-6.824/lecture-12-distributed-transactions/" rel="noopener ugc nofollow" target="_blank">分布式交易</a></li><li id="5723" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><a class="ae mt" href="https://www.youtube.com/watch?v=aDp99WDIM_4" rel="noopener ugc nofollow" target="_blank">麻省理工学院讲座——分布式交易</a></li><li id="73b4" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><a class="ae mt" href="https://unsplash.com/images/stock/png" rel="noopener ugc nofollow" target="_blank">封面图片</a></li><li id="7fa2" class="ll lm hi kh b ki lu kl lv ko lw ks lx kw ly la ml lr ls lt bi translated"><a class="ae mt" href="https://microservices.io/patterns/data/saga.html" rel="noopener ugc nofollow" target="_blank">传奇&amp;微服务</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>What I Built (3) — Browser Extension for Intercept and Detect Requests’ Country of IP Address</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我构建了什么(3) —用于拦截和检测请求的IP地址所在国家/地区的浏览器扩展</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-i-built-3-browser-extension-for-intercept-and-detect-requests-country-of-ip-address-5fa843186097?source=collection_archive---------13-----------------------#2021-03-13">https://medium.com/geekculture/what-i-built-3-browser-extension-for-intercept-and-detect-requests-country-of-ip-address-5fa843186097?source=collection_archive---------13-----------------------#2021-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="319e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是关于我可以用浏览器扩展做什么的学习之一，这个扩展现在只是Firefox，因为我利用了Chrome(还)不支持的DNS解析功能。</p><div class="jd je ez fb jf jg"><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/dns/resolve#browser_compatibility" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">dns.resolve()</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">将给定的主机名解析为DNS记录。这是一个返回. string的异步函数。的主机名…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">developer.mozilla.org</p></div></div></div></a></div><h1 id="419f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">意图和背景</h1><p id="64ad" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">由于数据隐私更受关注(至少我确实关注)，我想知道当我在互联网上浏览时(用我的浏览器)下面是什么样的请求。有一种手动方式来检查这些请求，例如，使用浏览器开发工具检查网络，然后nslookup IP地址，然后从一些提供商/API请求来源以解析国家来源。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/1e60695f85ec618a13ef246a6b4d5da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qKbgY4-SMNTd-wEXuX3YA.png"/></div></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/bcfc8b4611d40eecda03d0fc3b61cac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfCx91GMU6cSDMWwZjwIyA.png"/></div></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lf"><img src="../Images/5a2ebb9360e3697406f938a6e2578fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4R7ZSkeLdgWGcyWQ2qBdg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">the developer.mozilla.org is hidden behide cloudfront and the IP in above nslookup does not resolve in this API, this is a failed example…so using 8.8.8.8 to screen capture</figcaption></figure><h1 id="d488" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我建造的东西</h1><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lk"><img src="../Images/7e93aafbe294d0e8056565e6b31e5d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXLAW06Qce8SJi7wG502UQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Notification pop up when a site make request to some county code</figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ll"><img src="../Images/c15477e923ceeabaad27a46029dc6995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6gvET2tt9WAPGsuQhUkkg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Zoom in notification (sample from yet another site)</figcaption></figure><h1 id="4376" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">开始吧</h1><p id="be89" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我遵循的参考是MDN文档:</p><div class="jd je ez fb jf jg"><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Intercept_HTTP_requests" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">拦截HTTP请求</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">要拦截HTTP请求，请使用webRequest API。这个API使您能够为不同的制作阶段添加监听器…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">developer.mozilla.org</p></div></div></div></a></div><p id="5c98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的manifest.json如下:</p><pre class="kt ku kv kw fd lm ln lo lp aw lq bi"><span id="20c4" class="lr jq hi ln b fi ls lt l lu lv">{<br/>  "description": "Checking webRequests geo location",<br/>  "manifest_version": 2,<br/>  "name": "check_geo",<br/>  "version": "1.0",</span><span id="cd15" class="lr jq hi ln b fi lw lt l lu lv">  "permissions": [<br/>    "webRequest",<br/>    "webRequestBlocking",<br/>    "dns",<br/>    "storage",<br/>    "unlimitedStorage",<br/>    "notifications",<br/>    "&lt;all_urls&gt;"<br/>  ],</span><span id="8295" class="lr jq hi ln b fi lw lt l lu lv">  "background": {<br/>    "scripts": ["background.js"]<br/>  }<br/>}</span></pre><p id="c683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于权限:</p><ul class=""><li id="87a6" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">拦截web请求的核心项是“web request”和“webRequestBlocking”。</li><li id="0292" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">“dns”是使用dns.resolve()的权限</li><li id="f1d9" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">因为我添加了通知功能，所以我需要“通知”权限</li><li id="9646" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">最后，我需要减少对location API的访问，因此每当域被访问时，它都被缓存在本地存储中，因此我需要“storage”权限，而“unlimitedStorage”实际上并不需要(取决于我想要存储什么)</li><li id="651b" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">我希望插件适用于所有的URL，所以添加了<all_urls/></li></ul><p id="24ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">background.js中的核心代码逻辑是注册一个事件侦听器:</p><pre class="kt ku kv kw fd lm ln lo lp aw lq bi"><span id="84f1" class="lr jq hi ln b fi ls lt l lu lv">browser.webRequest.onBeforeRequest.addListener(<br/>  logURL,<br/>  {urls: ["&lt;all_urls&gt;"]},<br/>  ["blocking"]<br/>);</span></pre><p id="01f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码在所有web请求之前添加事件侦听器，并调用一个处理程序“logURL”并使其应用于所有URL，配置处于“阻塞”模式，这意味着在处理程序调用完成之前不会发送请求，我使用阻塞方法是因为:</p><ol class=""><li id="19d7" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc ml md me mf bi translated">如果这不是我想要的请求，我会拒绝它</li><li id="80e8" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc ml md me mf bi translated">即使我允许它通过，我也想缓存我做了位置API检查的所有域，因为所有这些API每分钟/每月的点击率都是有限的，一个现代网站即使看起来闲置也会有很多请求(例如，为了跟踪或改善UX目的，比如记录你上次停止阅读/查看的地方)</li></ol><p id="3804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">logURL处理程序应该很简单(这里跳过localstorage代码和异常处理):</p><pre class="kt ku kv kw fd lm ln lo lp aw lq bi"><span id="aace" class="lr jq hi ln b fi ls lt l lu lv">async function logURL(requestDetails){<br/>  // Get hostname from requestDetails object<br/>  const hostname = (new URL(requestDetails.url)).hostname;</span><span id="5732" class="lr jq hi ln b fi lw lt l lu lv">  // DNS resolve<br/>  const ip = await browser.dns.resolve(hostname);</span><span id="1742" class="lr jq hi ln b fi lw lt l lu lv">  // check location API<br/>  const ipapiUrl = `<a class="ae mm" href="https://ipapi.co/${ipAddress}/json/`" rel="noopener ugc nofollow" target="_blank">https://ipapi.co/${ipAddress}/json/`</a>;<br/>  const response = await fetch(ipapiUrl);<br/>  const result = await response.json();<br/>  const country_code = result.country_code;<br/>  <br/>  // if country_code = "XX", notify<br/>  if (country_code === "XX"){<br/>    browser.notifications.create("XX", {<br/>      type:"basic",<br/>      title: "XX site",<br/>      message: `Origin Url: ${requestDetails.originUrl}\n\nUrl: ${requestDetails.url}`<br/>    })<br/>  }<br/>}</span></pre><h1 id="e316" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">棘手的部分</h1><p id="347e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">棘手的是，因为事件侦听器应用于所有URL，所以对ipapi.co的调用以获取位置信息也是事件的一部分，这就形成了创建ipapi.co调用和检查ipapi.co调用的无限循环。</p><p id="2d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我的解决方案(我不确定这是否是最佳实践)是在上面的核心代码之前使用正则表达式检查URL，调用如下函数:</p><pre class="kt ku kv kw fd lm ln lo lp aw lq bi"><span id="6f92" class="lr jq hi ln b fi ls lt l lu lv">function excludeUrl(requestDetails){<br/>  if(/ipapi.co/.test(requestDetails.url)) {<br/>    return true;<br/>  } //else<br/>  return false;<br/>}</span></pre><h1 id="6585" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="343f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这个插件的实现离完美还很远，我认为它还不能解决以下问题:</p><ol class=""><li id="76b0" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc ml md me mf bi translated">ipapi.co不需要注册，是免费的，但不能太频繁(官方规定每天1000个电话，但如果太频繁，就会被拒绝访问)，可以使用这种API的付费版本，还有更多选择，付费计划可以执行批量查找。</li><li id="c26b" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc ml md me mf bi translated">大多数流行的域名在你的国家周围都有本地服务器，所以dns解析的IP可能是本地的(对你的国家来说)，为了解决这个问题，你可以扩展它来匹配域名黑名单，但是我打赌有很多扩展可以帮助你管理它。</li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Indexing in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres中的索引</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/indexing-in-postgres-db-4cf502ce1b4e?source=collection_archive---------1-----------------------#2021-05-06">https://medium.com/geekculture/indexing-in-postgres-db-4cf502ce1b4e?source=collection_archive---------1-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5103" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是索引？</h1><p id="5db4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">索引通过创建指向数据库中数据存储位置的指针来加快列的查询速度。</p><p id="1bc1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">假设您想在一个大型数据库中查找一条信息。为了从数据库中得到这些信息，计算机将检查每一行，直到找到为止。如果您要查找的数据接近末尾，这个查询将需要很长时间来运行。</p><p id="a3f1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">寻找最后一个条目的可视化</em>:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/3bb1587f70e174dc3e23b8e0c099e2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*3rLVc_Ue5uYlGemu.gif"/></div></figure><p id="6507" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果表是按字母顺序排序的，搜索名字会快得多，因为我们可以跳过在某些行中查找数据。如果我们想搜索“Zack ”,并且我们知道数据是按字母顺序排列的，我们可以跳到数据的中间，看看Zack是在那一行之前还是之后。然后，我们可以将剩下的行减半，进行同样的比较。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/21a010f2ec0b9b7da51af605ea689e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*rVphtD415-7x9qTG.gif"/></div></figure><p id="36f8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这需要3次比较才能找到正确的答案，而不是在无索引数据中的8次。</p><p id="8079" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">索引允许我们创建排序列表，而不必创建所有新的排序表，这将占用大量的存储空间。</p><h1 id="b1ce" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">指数到底是什么？</h1><p id="896b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">索引是一种结构，它保存索引排序的字段和一个指针，该指针从每个记录指向实际存储数据的原始表中相应的记录。索引用于类似联系人列表的东西，其中数据可能按照您添加联系人信息的顺序进行物理存储，但如果按照字母顺序列出，则更容易找到联系人。</p><p id="5033" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看上一个示例中的索引，看看它是如何映射回原始的Friends表的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/b17e0145be581e32134d990625e4274e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F4_IqT0j_iZUAfDM.png"/></div></div></figure><p id="c039" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们在这里可以看到，表中存储的数据是按照基于数据添加顺序的递增id排序的。索引中的名字是按字母顺序存储的。</p><h1 id="315c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">索引的类型</h1><p id="3efe" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有两种类型的数据库索引:</p><ol class=""><li id="81a8" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka kz la lb lc bi translated"><strong class="jf hj">集群</strong></li><li id="c1f9" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">非集群</strong></li></ol><p id="9223" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">聚集和非聚集索引都作为B树存储和搜索，B树是一种类似于<a class="ae li" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>的数据结构。B树是一种“自平衡的树数据结构，它维护分类的数据，并允许在对数时间内进行搜索、顺序访问、插入和删除。”基本上，它创建了一个树状结构，对数据进行排序以便快速搜索。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lj"><img src="../Images/c7b26105d49e0e4ef682c045058babd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ghU70U-LhjyO4ahu.png"/></div></div></figure><p id="6b7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是我们创建的索引的B树。最小的条目在最左边，最大的条目在最右边。所有查询都将从顶部节点开始，并沿着树向下进行，如果目标条目小于当前节点，则遵循左侧路径，如果大于当前节点，则遵循右侧路径。在我们的案例中，先是马特，然后是托德，然后是扎克。</p><p id="6e1d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了提高效率，许多B树会限制输入条目的字符数。B树会自己完成这项工作，不需要限制列数据。在上面的示例中，下面的B树将条目限制为4个字符。</p><h1 id="09cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">聚集索引</h1><p id="fe13" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">聚集索引是每个表的唯一索引，它使用主键来组织表中的数据。聚集索引确保主键以递增的顺序存储，这也是表在内存中的顺序。</p><ul class=""><li id="766e" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka lk la lb lc bi translated">对于Postgres，聚集索引必须显式声明。</li><li id="64ed" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated">在创建表时创建。</li><li id="460f" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated">使用按升序排序的主键。</li></ul><h2 id="abef" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">创建聚集索引</h2><p id="e6a9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">定义主键时，将自动创建聚集索引:</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="f5e7" class="ll ig hi ma b fi me mf l mg mh"><strong class="ma hj">CREATE</strong> <strong class="ma hj">TABLE</strong> friends (id INT <strong class="ma hj">PRIMARY</strong> <strong class="ma hj">KEY</strong>, name VARCHAR, city VARCHAR);</span></pre><p id="0226" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦填写完毕，该表将如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mi"><img src="../Images/1cda6952c50aac8d4f117c7d90378111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0e7czWc77ZvlCUy6.png"/></div></div></figure><p id="3f8f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建的表“friends”将有一个自动创建的聚集索引，该索引是围绕名为“friends_pkey”的主键“id”组织的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mj"><img src="../Images/82e509a60cb526491e6dda072da49d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nmZQapTL2dgL67ya.png"/></div></div></figure><p id="b7ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当按“id”搜索表格时，列的升序允许执行最佳搜索。因为数字是有序的，所以搜索可以在B树中导航，允许在对数时间内进行搜索。</p><p id="64a5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是，为了在表中搜索“名称”或“城市”,我们必须查看每个条目，因为这些列没有索引。这是非聚集索引非常有用的地方。</p><h1 id="2b1f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">非聚集索引</h1><p id="5f20" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">非聚集索引是对主表中特定字段的排序引用，它保存指向表原始条目的指针。我们展示的第一个示例是非聚集表的示例:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/6043d509e6a266dcc9b8f4c54bf8ac31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4W8c1ne0Ny0Myy1f.png"/></div></div></figure><p id="32b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它们通过创建更容易搜索的列来提高表的查询速度。在创建和填充表之后，数据分析师/开发人员可以创建非聚集索引。</p><p id="f54e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">非聚集索引指向内存地址，而不是存储数据本身。这使得它们的查询速度比聚集索引慢，但通常比非索引列快得多。</p><p id="fa73" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以创建许多非聚集索引。截至2008年，SQL Server中最多可以有999个非聚集索引，PostgreSQL中没有限制。</p><h2 id="663d" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">创建非集群数据库(PostgreSQL)</h2><h2 id="c24e" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">部分索引</h2><p id="b175" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">部分索引只覆盖表数据的一个子集。这是一个带有WHERE子句的索引。这个想法是通过减少索引的大小来提高索引的效率。较小的索引占用较少的存储空间，更易于维护，并且扫描速度更快。</p><p id="80de" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如，假设您允许用户在您的站点上标记评论，这反过来会将<code class="du mk ml mm ma b">flagged</code>布尔值设置为true。然后，您可以成批处理标记的注释。您可能希望创建如下所示的索引:</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="1c6e" class="ll ig hi ma b fi me mf l mg mh">CREATE INDEX articles_flagged_created_at_index ON articles(created_at) WHERE flagged IS TRUE;</span></pre><p id="1d29" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个索引将保持相当小，并且还可以与其他索引一起用于可能需要它的更复杂的查询。</p><h2 id="cf94" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">表达式索引</h2><p id="c806" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">表达式索引对于匹配某些函数或数据修改的查询非常有用。Postgres允许您对该函数的结果进行索引，从而使搜索变得与通过原始数据值进行搜索一样高效。例如，您可能要求用户存储他们的电子邮件地址以便登录，但是您想要不区分大小写的身份验证。在这种情况下，可以原样存储电子邮件地址，但在<code class="du mk ml mm ma b">WHERE lower(email) = '&lt;lowercased-email&gt;'</code>进行搜索。在这种查询中使用索引的唯一方法是使用表达式索引，如下所示:</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="6cd2" class="ll ig hi ma b fi me mf l mg mh">CREATE INDEX users_lower_email ON users(lower(email));</span></pre><p id="933f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一个常见的例子是查找给定日期的行，其中我们在datetime字段中存储了时间戳，但希望通过date casted值来查找它们。包含<code class="du mk ml mm ma b">WHERE date(articles.published_at) = date('2011-03-07')</code>的查询可以使用像<code class="du mk ml mm ma b">CREATE INDEX articles_day ON articles ( date(published_at) )</code>这样的索引。</p><h2 id="b94d" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">唯一索引</h2><p id="2778" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">唯一索引保证了表中不会有多个具有相同值的行。创建唯一索引的好处有两个:数据完整性和性能。对唯一索引的查找通常非常快。</p><p id="ef8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就数据完整性而言，在ActiveModel类上使用<code class="du mk ml mm ma b">validates_uniqueness_of</code>验证并不能真正保证唯一性，因为可能会有并发用户创建无效记录。因此，您应该始终在数据库级别创建约束——要么使用索引，要么使用唯一约束。</p><p id="a45c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">唯一索引和唯一约束之间几乎没有区别。唯一索引可以被认为是较低的级别，因为表达式索引和部分索引不能被创建为唯一约束。甚至表达式上的部分唯一索引也是可能的。</p><p id="2e91" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">多栏索引</strong></p><p id="4ce0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">虽然Postgres能够创建多列索引，但是理解何时这样做是有意义的是很重要的。通过执行位图索引扫描，Postgres查询规划器能够在多列查询中组合和使用多个单列索引。一般来说，您可以在包含查询条件的每一列上创建一个索引，并且在大多数情况下Postgres都会使用它，所以在创建多列索引之前，请确保对其进行基准测试和论证。与往常一样，索引是有代价的，多列索引只能优化以相同顺序引用索引中的列的查询，而多个单列索引为大量查询提供了性能改进。</p><p id="fdf2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是，在某些情况下，多列索引显然是有意义的。包含<code class="du mk ml mm ma b">WHERE a = x AND b = y</code>的查询或仅使用<code class="du mk ml mm ma b">WHERE a = x</code>的查询可以使用列<code class="du mk ml mm ma b">(a, b)</code>上的索引，但是使用<code class="du mk ml mm ma b">WHERE b = y</code>的查询不会使用该索引。因此，如果这与应用程序的查询模式相匹配，那么多列索引方法是值得考虑的。还要注意，在这种情况下，单独为<code class="du mk ml mm ma b">a</code>创建一个索引是多余的。</p><h1 id="1e49" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">查看索引</h1><p id="1077" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在PostgreSQL中，“\d”命令用于列出表的详细信息，包括表名、表列及其数据类型、索引和约束。</p><p id="a78f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的朋友表的详细信息现在如下所示:</p><p id="3857" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询提供好友表详情</strong> : \d好友；</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mn"><img src="../Images/64f708f1033d95f4a13036fd2e50b11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LfBQv5PpMUMZZIVX.png"/></div></div></figure><p id="0929" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">看上面的图像，“friends_name_asc”现在是“friends”表的关联索引。这意味着<a class="ae li" href="https://dataschool.com/sql-optimization/what-is-a-query-plan/" rel="noopener ugc nofollow" target="_blank">查询计划</a>，即SQL在确定执行查询的最佳方式时创建的计划，将在进行查询时开始使用索引。请注意,“friends_pkey”被列为一个索引，尽管我们从未将其声明为一个索引。这就是本文前面提到的基于主键自动创建的<strong class="jf hj">聚集索引</strong>。</p><p id="97c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们还可以看到有一个“朋友_城市_desc”索引。该索引的创建类似于names索引:</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="f325" class="ll ig hi ma b fi me mf l mg mh"><strong class="ma hj">CREATE</strong> <strong class="ma hj">INDEX</strong> friends_city_desc <strong class="ma hj">ON</strong> friends(city <strong class="ma hj">DESC</strong>);</span></pre><p id="9c03" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个新的索引将用于对城市进行排序，并且将按照相反的字母顺序进行存储，因为关键字“DESC”被传递了，它是“降序”的缩写。这为我们的数据库提供了一种快速查询城市名称的方法。</p><h1 id="9ca6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">搜索索引</h1><p id="1dd0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">创建非聚集索引后，可以开始使用它们进行查询。索引使用一种被称为<a class="ae li" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>的最佳搜索方法。二进制搜索的工作方式是不断将数据切成两半，并检查您要搜索的条目是在当前数据部分中间的条目之前还是之后。这在B树中工作得很好，因为它们被设计成从中间入口开始；要在树中搜索条目，您知道左侧路径中的条目会较小或在当前条目之前，右侧的条目会较大或在当前条目之后。在表格中，它看起来像这样:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/3f6d20d6320d4ead9c8239accb3728a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Akyr8I4z0VZ8WtP0.gif"/></div></figure><p id="6165" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将这种方法与本文开头的非索引表的查询进行比较，我们能够将搜索总数从八个减少到三个。使用这种方法，在一个二分搜索法中搜索100万个条目可以减少到20次。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mo"><img src="../Images/1ae02003a18a75972c6783813b8d208e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5R_U0ZetpFTpwFMk.png"/></div></div></figure><h1 id="7777" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">何时使用索引</h1><p id="5fc0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">索引旨在提高数据库的性能，因此只要索引能显著提高数据库的性能，就使用索引。随着数据库变得越来越大，您越有可能从索引中受益。</p><h1 id="5f87" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">何时不使用索引</h1><p id="e55f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当数据写入数据库时，首先更新原始表(聚集索引),然后更新该表的所有索引。每次对数据库进行写入时，索引在更新之前都是不可用的。如果数据库不断接收写操作，那么索引将永远无法使用。这就是为什么索引通常应用于数据仓库中按计划(非高峰时间)更新新数据的数据库，而不是可能一直接收新写入的生产数据库。</p><p id="43a4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意:Postgres的最新版本(目前在测试中)将允许你在更新索引的同时查询数据库。</p><h1 id="afba" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">测试索引性能</h1><p id="a8c5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">若要测试索引是否会开始减少查询时间，可以在数据库上运行一组查询，记录完成这些查询所需的时间，然后开始创建索引并重新运行测试。</p><p id="da9b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为此，请尝试在PostgreSQL中使用EXPLAIN ANALYZE子句。：</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="8610" class="ll ig hi ma b fi me mf l mg mh"><strong class="ma hj">EXPLAIN</strong> <strong class="ma hj">ANALYZE</strong> <strong class="ma hj">SELECT</strong> <strong class="ma hj">*</strong> <strong class="ma hj">FROM</strong> friends <strong class="ma hj">WHERE</strong> name <strong class="ma hj">=</strong> 'Blake';</span></pre><p id="c071" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我的小数据库里产生了:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mp"><img src="../Images/331d111851b38fbb4bee327ee74e70fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lRQ7vEIonOFjyTYW.png"/></div></div></figure><p id="6378" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个输出将告诉您选择了查询计划中的哪种搜索方法，以及查询的计划和执行花费了多长时间。</p><p id="85ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一次只创建一个索引，因为并非所有索引都会减少查询时间。</p><ul class=""><li id="ce9b" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka lk la lb lc bi translated">PostgreSQL的查询规划非常高效，因此添加新索引可能不会影响查询的执行速度。</li><li id="7d34" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated">添加索引总是意味着存储更多的数据</li><li id="9530" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated">添加索引会增加写操作后数据库完全更新所需的时间。</li></ul><p id="ed7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果添加索引不能减少查询时间，可以简单地从数据库中删除它。</p><p id="e0ed" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要删除索引，请使用DROP INDEX命令:</p><pre class="ki kj kk kl fd lz ma mb mc aw md bi"><span id="79fb" class="ll ig hi ma b fi me mf l mg mh"><strong class="ma hj">DROP</strong> <strong class="ma hj">INDEX</strong> friends_name_asc;</span></pre><p id="3177" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">数据库的轮廓现在看起来像这样:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mq"><img src="../Images/82a62bffe18d66bf048d340870e8a82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Gdh37lXWsbC2cJ3.png"/></div></div></figure><p id="1da7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这表明成功地移除了用于搜索姓名的索引。</p><p id="43fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">指数类型</strong></p><ul class=""><li id="071e" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka lk la lb lc bi translated"><strong class="jf hj"> <em class="kg"> B树</em> </strong>是你做<code class="du mk ml mm ma b">CREATE INDEX</code>时得到的默认。几乎所有的数据库都有一些B树索引。b树试图保持平衡，树的每个分支中的数据量大致相同。因此，为了找到行而必须遍历的级别数总是大致相同。b树索引可以有效地用于等式和范围查询。它们可以对所有数据类型进行操作，也可以用于检索空值。b树被设计成可以很好地进行缓存，即使只是部分缓存。</li><li id="9395" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated"><strong class="jf hj"> <em class="kg">散列索引</em> </strong> pre-Postgres 10只对等式比较有用，但你几乎不会想使用它们，因为它们不是事务安全的，需要在崩溃后手动重建，并且不能复制到追随者，所以相对于使用B树的优势相当小。在Postgres 10和更高版本中，散列索引现在被预写记录并复制到跟随者。</li><li id="301a" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated"><a class="ae li" href="http://www.postgresql.org/docs/current/static/gin.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> <em class="kg">广义倒排索引(GIN) </em> </strong> </a>当一个索引必须将多个值映射到一行时很有用，而B树索引针对一行只有一个键值的情况进行了优化。gin适用于索引数组值以及实现全文搜索。</li><li id="5bbb" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka lk la lb lc bi translated"><a class="ae li" href="http://www.postgresql.org/docs/current/static/gist.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> <em class="kg">广义搜索树(GiST) </em> </strong> </a>索引允许您构建通用的平衡树结构，并可用于等式和范围比较之外的操作。它们用于索引几何数据类型，以及全文搜索。</li></ul><h2 id="b26c" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">是什么让索引如此有效？</h2><p id="b1ed" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">索引不会改变它所应用的现有文档/表格(除非它是聚集索引，我将在后面的博客中讨论)，相反，它会创建一个新的数据结构，每个条目有两个块。这两个模块是:</p><ol class=""><li id="c0af" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka kz la lb lc bi translated">创建索引的数据字段</li><li id="7e0d" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">指向数据库中存储数据字段的行/文档的指针(地址)</li></ol><h2 id="7921" class="ll ig hi bd ih lm ln lo il lp lq lr ip jo ls lt it js lu lv ix jw lw lx jb ly bi translated">实现索引后搜索如何提升？</h2><ol class=""><li id="1d83" class="ku kv hi jf b jg jh jk jl jo mr js ms jw mt ka kz la lb lc bi translated">现在，不是线性地搜索数据库中的所有字段，而是以二分搜索法方式进行搜索。[这将搜索从N减少到(Log N)]。因此，拯救我们电脑。</li><li id="5979" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">通过存储器中的连接块的顺序流也减少到只有2个，因为在索引之后，在创建的新数据结构中只有两个字段。</li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的组件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/components-in-react-7f447263a8e6?source=collection_archive---------31-----------------------#2021-03-12">https://medium.com/geekculture/components-in-react-7f447263a8e6?source=collection_archive---------31-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d4e9ec1b3761e083516df615f69d1b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJveX8kmQj8cZhvR367wpw.png"/></div></div></figure><p id="c035" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React组件是独立的、可重用的代码。React组件接受一个可选输入，并返回一个呈现在屏幕上的<em class="jo"> React元素</em>。</p><p id="693e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React组件有两种主要类型:</p><ol class=""><li id="82d8" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">功能组件是无状态的。</li><li id="5300" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">类组件是有状态的。</li></ol><h1 id="bc63" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">功能组件</h1><blockquote class="lb lc ld"><p id="3c17" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">一个<!-- -->功能组件只是一个普通的javascript函数，<strong class="is hj">将props作为参数</strong>并返回一个react元素。功能组件不需要来自其他组件的数据，并且<strong class="is hj">不与任何其他组件</strong>交互。</p></blockquote><p id="537e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能组件可以做什么:</p><ol class=""><li id="2930" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">接受和使用道具</li><li id="ead3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">以某种形式显示数据(返回一个react元素)</li></ol><p id="59ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哪些功能组件不能做:</p><ol class=""><li id="afca" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用<code class="du lh li lj lk b">this.state</code></li><li id="c976" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用生命周期方法(例如<code class="du lh li lj lk b">componentDidmount</code>)。</li><li id="461e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用渲染方法</li></ol><p id="2af7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能组件的示例:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="5ea4" class="lt ke hi lk b fi lu lv l lw lx">import React from "react"<br/><br/>const Welcome = props =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="9e78" class="lt ke hi lk b fi ly lv l lw lx"><br/>export default Welcome<!-- --> </span></pre><h1 id="2590" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">类别组件</h1><blockquote class="lb lc ld"><p id="f4f0" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">这些组件是使用ES6的类语法创建的。它们有一些额外的特性，例如包含逻辑的能力(例如处理onClick事件的方法)、本地状态(下一章将详细介绍)以及本书后面部分将探讨的其他功能。</p></blockquote><p id="418d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类组件可以做什么:</p><ol class=""><li id="4e40" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">利用ES6类并扩展React中的<code class="du lh li lj lk b">Component</code>类</li><li id="3d65" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用<code class="du lh li lj lk b">this.state</code></li><li id="3618" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用生命周期方法(例如<code class="du lh li lj lk b">componentDidmount</code>)。</li><li id="7aed" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用渲染方法</li><li id="7001" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">接受通行证道具，用<code class="du lh li lj lk b">this.props</code>进入</li></ol><p id="3187" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个类组件的示例:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="346c" class="lt ke hi lk b fi lu lv l lw lx">import React, {Component} from "react"<br/><br/>class Welcome extends Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="b5c0" class="lt ke hi lk b fi ly lv l lw lx">export default Welcome</span></pre><h1 id="a28c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用哪种组件类型？</h1><p id="af58" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated"><strong class="is hj">除非需要，否则始终使用功能组件:</strong></p><ol class=""><li id="2e03" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">管理状态</li><li id="3307" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">向组件添加生命周期方法</li><li id="b2ee" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">为事件处理程序添加逻辑</li></ol></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="3ac3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，还有另一种基于行为逻辑来区分组件的方法。</p><h1 id="5f45" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">表象成分</h1><p id="1d3a" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">表示组件通常被称为无状态功能组件，它接受道具并呈现UI。与功能组件一样，表示性组件不能:</p><ol class=""><li id="0123" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用<code class="du lh li lj lk b">this.state</code></li><li id="6ec5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用生命周期方法(例如<code class="du lh li lj lk b">componentDidmount</code>)。</li><li id="6e33" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用渲染方法</li></ol><p id="2e90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">演示组件的一个示例:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="34b5" class="lt ke hi lk b fi lu lv l lw lx"><strong class="lk hj">import</strong> React from 'react'<br/><br/><strong class="lk hj">const</strong> Book <strong class="lk hj">=</strong> ({ title, img_url }) <strong class="lk hj">=&gt;</strong> (<br/>  <strong class="lk hj">&lt;</strong>div className<strong class="lk hj">=</strong>"book"<strong class="lk hj">&gt;</strong><br/>    <strong class="lk hj">&lt;</strong>img src<strong class="lk hj">=</strong>{ img_url } alt<strong class="lk hj">=</strong>{title}/&gt;<br/>    <strong class="lk hj">&lt;</strong>h3<strong class="lk hj">&gt;</strong>{ title }<strong class="lk hj">&lt;</strong>/h3&gt;<br/>  <strong class="lk hj">&lt;</strong>/div&gt;<br/>)<br/><br/><strong class="lk hj">export</strong> <strong class="lk hj">default</strong> Book</span></pre><h1 id="4586" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">容器组件</h1><p id="a693" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">容器组件将处理行为部分。容器组件告诉表示组件应该使用道具呈现什么。它不应该包含有限的DOM标记和样式。如果您使用Redux，容器组件包含将动作分派给存储的代码。或者，这是您应该放置API调用并将结果存储到组件状态的地方。</p><p id="eb6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是容器组件模式的简明定义:</p><ul class=""><li id="29e2" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ml jv jw jx bi translated">容器组件主要关心事情如何工作</li><li id="d4d2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ml jv jw jx bi translated">除了包装之外，他们很少有自己的HTML标记</li><li id="03c2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ml jv jw jx bi translated">它们通常是有状态的</li><li id="046d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ml jv jw jx bi translated">他们负责向他们的孩子提供数据和行为(通常是表示组件)。</li></ul><p id="a2fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">容器组件的示例:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="b850" class="lt ke hi lk b fi lu lv l lw lx"><strong class="lk hj">class</strong> BookList <strong class="lk hj">extends</strong> Component {<br/>  constructor(props) {<br/>    <strong class="lk hj">super</strong>(props);<br/><br/>    <strong class="lk hj">this</strong>.state <strong class="lk hj">=</strong> {<br/>      books: []<br/>    };<br/>  }<br/><br/>  componentDidMount() {<br/>    fetch('https://learn-co-curriculum.github.io/books-json-example-api/books.json')<br/>      .then(response <strong class="lk hj">=&gt;</strong> response.json())<br/>      .then(bookData <strong class="lk hj">=&gt;</strong> <strong class="lk hj">this</strong>.setState({ books: bookData.books }))<br/>  }<br/><br/>  renderBooks <strong class="lk hj">=</strong> () <strong class="lk hj">=&gt;</strong> {<br/>    <strong class="lk hj">return</strong> <strong class="lk hj">this</strong>.state.books.map(book <strong class="lk hj">=&gt;</strong> {<br/>      <strong class="lk hj">return</strong> (<br/>        <strong class="lk hj">&lt;</strong>div className<strong class="lk hj">=</strong>"book"<strong class="lk hj">&gt;</strong><br/>          <strong class="lk hj">&lt;</strong>img src<strong class="lk hj">=</strong>{ book.img_url } /&gt;<br/>          <strong class="lk hj">&lt;</strong>h3<strong class="lk hj">&gt;</strong>{ book.title }<strong class="lk hj">&lt;</strong>/h3&gt;<br/>        <strong class="lk hj">&lt;</strong>/div&gt;<br/>      )<br/>    })<br/>  }<br/><br/>  render() {<br/>    <strong class="lk hj">return</strong> (<br/>      <strong class="lk hj">&lt;</strong>div className<strong class="lk hj">=</strong>"book-list"<strong class="lk hj">&gt;</strong><br/>        { <strong class="lk hj">this</strong>.renderBooks() }<br/>      <strong class="lk hj">&lt;</strong>/div&gt;<br/>    )<br/>  }<br/>}</span></pre><blockquote class="lb lc ld"><p id="3c00" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">这里要记住的主要事情是容器组件和表示组件是一起的。事实上，您可以将它们视为同一个设计模式的一部分。表示组件不管理状态，容器组件管理状态。在组件层次结构中，表示组件通常是从属的“子组件”，而容器组件几乎在所有情况下都是表示组件的“父组件”。</p></blockquote></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="890c" class="kd ke hi bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">纯组件</h1><blockquote class="lb lc ld"><p id="357a" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">纯组件主要用于提供优化。它们是我们能编写的最简单和最快的组件。它们不依赖或修改其范围之外的变量的状态。因此，为什么纯组件可以取代简单的功能组件。</p></blockquote><p id="8717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，常规的<code class="du lh li lj lk b">React.Component</code>和<code class="du lh li lj lk b">React.PureComponent</code>之间的一个主要区别是，纯组件在状态变化时执行<strong class="is hj"> <em class="jo">浅层比较</em> </strong>。纯组件自行照顾<code class="du lh li lj lk b">shouldComponentUpdate()</code>。如果前一个<code class="du lh li lj lk b">state</code>和/或<code class="du lh li lj lk b">props</code>与下一个相同，组件不会被重新渲染。</p><p id="bb81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lh li lj lk b">React.PureComponent</code>用于优化性能，除非遇到某种性能问题，否则没有理由考虑使用它。</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="9a03" class="lt ke hi lk b fi lu lv l lw lx">import React from ‘react</span><span id="d8b9" class="lt ke hi lk b fi ly lv l lw lx"><strong class="lk hj">class</strong> Welcome extends React.PureComponent{<br/>  render(){<br/>    <strong class="lk hj">return</strong> (<br/>      &lt;div&gt;<br/>        <!-- -->&lt;h1&gt;Welcome!&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="9586" class="lt ke hi lk b fi ly lv l lw lx">export default <!-- -->Welcome</span></pre><p id="418f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，在使用任何类型之前，请始终考虑应用程序中的组件角色。</p><div class="mr ms ez fb mt mu"><a href="https://learn.co/lessons/react-container-components" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">反应容器组件-Learn.co</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在本课中，我们将学习React“容器组件”本课结束时，你将能够…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">learn.co</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni io mu"/></div></div></a></div></div></div>    
</body>
</html>
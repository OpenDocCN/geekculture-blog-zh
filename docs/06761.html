<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-a-type-safe-object-builder-in-typescript-e973f5ecfb9c?source=collection_archive---------1-----------------------#2021-08-29">https://medium.com/geekculture/implementing-a-type-safe-object-builder-in-typescript-e973f5ecfb9c?source=collection_archive---------1-----------------------#2021-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c41f" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">在TypeScript中实现类型安全的对象生成器</h2><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/174a88bca47f5dff72b5692fe279374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmOHozA5zVPgM4x1H6MEeQ.png"/></div></div></figure><p id="722e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">本文通过实现一个类型安全的对象生成器来演示TypeScript的类型系统是多么灵活。</p><p id="7b21" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">首先，让我们来看看构建器模式是什么，它的用途是什么。构建器模式本质上允许您将对象的构造与其表示分离开来。换句话说，它提供了一种方法，可以方便地创建用您需要的数据初始化的特定类的实例。</p><p id="8770" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">让我们看一个用Java编写的例子，它使用了<a class="ae jm" href="https://projectlombok.org/features/Builder" rel="noopener ugc nofollow" target="_blank"> Lookbook </a>的<code class="du jn jo jp jq b">@Builder </code>注释:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="da9e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><code class="du jn jo jp jq b">ResponseEntry</code>是一个有两个私有字段的类，可以按如下方式初始化和实例化:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="46e2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">Lombok自动定义初始化类中每个字段的方法。这种方法非常适合创建测试数据，因为您可以在一行中定义一个类的实例。</p><p id="c2a5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">然而，这种方法有一个缺陷—它不是完全类型安全的。即使Java是一种强静态类型的语言，也没有办法<strong class="it jt"/>“静态地”确保通过其构建器构建的对象不会有任何未初始化的字段。让我们来看一个例子:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="20da" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">对象<code class="du jn jo jp jq b">r1</code>初始化了两个字段，而<code class="du jn jo jp jq b">r2</code>只初始化了<code class="du jn jo jp jq b">status</code>字段，并使<code class="du jn jo jp jq b">payload</code>等于<code class="du jn jo jp jq b">null</code>。结果，我们在第5行得到<code class="du jn jo jp jq b">NullPointerException</code>,因为Java没有静态发现这种错误的能力。</p><p id="abaf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">Java和TypeScript有完全不同的类型系统:第一个是名义类型系统(允许更好的类型安全)，第二个是结构类型系统(允许更大的灵活性)。然而，TypeScript的类型系统具有许多独特的功能，这些功能使得实现类型安全版本的生成器模式成为可能，而不会出现上述问题，并且能够在编译时静态地发现未初始化的数据。</p><p id="2c11" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">我们将使用下面的API实现builder模式的类型安全版本:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="5924" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这是我们将要实现的结果的一个小演示:</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ju"><img src="../Images/c305b62222d5b00a39982fac06e76c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vu4UR4NiniDShf0h5gVr0Q.gif"/></div></div></figure><p id="b422" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">有几件事值得一提:</p><ul class=""><li id="7ecd" class="jv jw hi it b iu iv iy iz hs jx hw jy ia jz jl ka kb kc kd bi translated">方法<code class="du jn jo jp jq b">with</code>根据已经传递给它的键，缩小了可以作为第一个参数传递的键的列表</li><li id="9d5f" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated">方法<code class="du jn jo jp jq b">with</code>根据键推断第二个参数的类型，因此对于第一个键“foo ”,它期望第二个参数是类型<code class="du jn jo jp jq b">string</code>,对于第二个<code class="du jn jo jp jq b">bar</code>,它期望第三个是类型<code class="du jn jo jp jq b">number</code>,对于第三个<code class="du jn jo jp jq b">boolean</code></li><li id="38d0" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated">方法<code class="du jn jo jp jq b">build</code>不可用，除非来自<code class="du jn jo jp jq b">TestEntity</code>的所有字段都被初始化</li><li id="4696" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><code class="du jn jo jp jq b">entity</code>的类型被推断为<code class="du jn jo jp jq b">TestEntity</code>(这是示例中构造的对象的类型)</li></ul><p id="9083" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">实现如下所示:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="2cb4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这看起来很棘手，事实也的确如此。当我终于让它工作的时候，我的大脑快要开始融化了。让我们来分解一下在构建器模式的这种类型安全实现中使用的TypeScript的特性:</p><ul class=""><li id="296c" class="jv jw hi it b iu iv iy iz hs jx hw jy ia jz jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/classes.html" rel="noopener ugc nofollow" target="_blank">类</a> —它是创建对象的“蓝图”。本质上，类是在一个“容器”中存储数据和操作数据的方法的一种方式在我们的实现中，我们将使用静态方法<code class="du jn jo jp jq b">new</code>定义一个类，作为我们的构建器实现的入口点。</li><li id="4b30" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a> —这是任何静态类型语言的核心特性，允许编写能够处理多种数据类型的代码。泛型可以与类、函数、方法、接口和类型别名一起使用。</li><li id="c0ba" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank">接口</a> —描述类、对象甚至函数的形状/结构。接口的主要用途是在不提供实现细节的情况下为实体定义契约，这样一个接口可以由十几个类实现，每个类都有自己独特的行为，但都符合同一契约。</li><li id="755b" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html?#type-assertions" rel="noopener ugc nofollow" target="_blank">类型断言</a> —是一种将特定类型转换为其或多或少特定版本的方法。这在处理TypeScript不够全面的概念时很有帮助。换句话说，它有助于告诉TypeScript的编译器应该如何细化某些类型。</li><li id="4f46" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases" rel="noopener ugc nofollow" target="_blank">类型别名</a> —允许给现有类型分配一个新名称。也可用于引用<a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" rel="noopener ugc nofollow" target="_blank">联合</a>或<a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types" rel="noopener ugc nofollow" target="_blank">交集类型</a>。与操作器的<a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#the-keyof-type-operator" rel="noopener ugc nofollow" target="_blank">键配合使用时很方便。</a></li><li id="9c63" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types" rel="noopener ugc nofollow" target="_blank">文字类型</a> —允许JavaScript文字用作类型。当用作与其他文字类型的联合时很有帮助。这样，您就可以定义一个精确而严格的字符串或数字列表，允许将它们赋给特定的变量。</li><li id="97aa" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><code class="du jn jo jp jq b"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#the-keyof-type-operator" rel="noopener ugc nofollow" target="_blank">keyof</a></code> <a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#the-keyof-type-operator" rel="noopener ugc nofollow" target="_blank">操作符</a> —接受一个对象类型(别名或接口)并返回其键的字符串联合。</li><li id="2ef8" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><code class="du jn jo jp jq b"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">Partial</a></code>实用程序类型—获取一个对象类型<code class="du jn jo jp jq b">T</code>并返回<code class="du jn jo jp jq b">T1</code>，其中所有字段都是可选的</li><li id="bb1c" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><code class="du jn jo jp jq b"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank">Omit</a></code>实用程序类型——获取一个对象类型<code class="du jn jo jp jq b">T</code>和键<code class="du jn jo jp jq b">K</code>,并从该对象类型中移除该键</li><li id="51e1" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><code class="du jn jo jp jq b"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys" rel="noopener ugc nofollow" target="_blank">Pick</a></code>实用程序类型——获取一个对象类型<code class="du jn jo jp jq b">T</code>和一组键，并通过从<code class="du jn jo jp jq b">T</code>中“挑选”一组键来返回一个新类型</li><li id="2760" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated"><a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a> —这是TypeScript中最复杂、最难解释的概念。它允许您根据表示为类型关系测试的条件的结果，声明一个指向两个其他类型之一的类型。这听起来很奇怪(看起来确实令人困惑)，但这是我们所追求的实现的核心。本质上，这个特性允许您以“命令式”的风格描述一个静态类型(这个表达式看起来就像JavaScript中的一个条件操作符)。所以根据某种条件，类型<code class="du jn jo jp jq b">T</code>要么是类型<code class="du jn jo jp jq b">Foo</code>要么是类型<code class="du jn jo jp jq b">Bar</code>。</li></ul><p id="3887" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">既然所有的概念都已概述，让我们来分解实现。它有四个部分:</p><ol class=""><li id="7136" class="jv jw hi it b iu iv iy iz hs jx hw jy ia jz jl kj kb kc kd bi translated"><code class="du jn jo jp jq b">IBuild</code>界面</li></ol><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="ec99" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这个接口描述了一个实体，该实体有一个名为<code class="du jn jo jp jq b">build</code>的方法，该方法返回类型<code class="du jn jo jp jq b">Target</code>。我们的<code class="du jn jo jp jq b">Builder</code>类将使用它来实现一个方法，该方法返回一个完全初始化的对象(所有字段都已设置)。</p><p id="170c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">2.<code class="du jn jo jp jq b">IWith</code>界面</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="4b76" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这个接口有两个类型参数:<code class="du jn jo jp jq b">Target</code>(这是我们想要创建的对象类型)和<code class="du jn jo jp jq b">Supplied</code>(这是我们到目前为止创建的对象——它由来自方法<code class="du jn jo jp jq b">with</code>的键值对填充。这种类型随着对<code class="du jn jo jp jq b">with</code>的每次调用而更新。</p><p id="7149" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">该接口描述了一个名为<code class="du jn jo jp jq b">with</code>的函数，它有两个参数:<code class="du jn jo jp jq b">key</code>(第3行)和<code class="du jn jo jp jq b">value</code>(第4行)。</p><p id="2be2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">第一个参数<code class="du jn jo jp jq b">key</code>的类型<code class="du jn jo jp jq b">K</code>具有约束<code class="du jn jo jp jq b">K extends keyof T</code>。这意味着<code class="du jn jo jp jq b">key</code>必须是与类型<code class="du jn jo jp jq b">Target</code>的字段之一匹配的字符串。因此，如果我们要构建一个类型为<code class="du jn jo jp jq b">type Foo = { bar: number }</code>的对象，函数将只接受一个值作为第一个参数，它将是一个字符串“bar”</p><p id="226c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">第二个参数<code class="du jn jo jp jq b">value</code>的类型为<code class="du jn jo jp jq b">T[K]</code>。这意味着<code class="du jn jo jp jq b">value</code>指的是对象<code class="du jn jo jp jq b">T</code>中字段<code class="du jn jo jp jq b">K</code>的数据类型。如果我们要从前面的例子中构建一个类型为<code class="du jn jo jp jq b">Foo</code>的对象，那么第二个参数的类型将是“number ”,因为<code class="du jn jo jp jq b">Foo['bar']</code>是<code class="du jn jo jp jq b">number</code>。</p><p id="3248" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">此外，该函数有两个类型参数:<code class="du jn jo jp jq b">T</code>和<code class="du jn jo jp jq b">K</code>。类型<code class="du jn jo jp jq b">T</code>是描述类型<code class="du jn jo jp jq b">Target</code>和类型<code class="du jn jo jp jq b">Supplied</code>区别的类型。这很重要，因为这种类型定义了函数<code class="du jn jo jp jq b">with</code>将接受哪些键。虽然类型<code class="du jn jo jp jq b">Target</code>保持不变，但每次调用<code class="du jn jo jp jq b">with</code>后<code class="du jn jo jp jq b">Supplied</code>都会改变。看看下面的例子，它显示了每次调用<code class="du jn jo jp jq b">with</code>后<code class="du jn jo jp jq b">Supplied</code>类型的内容:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="51c4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">正如你所看到的，每次调用<code class="du jn jo jp jq b">with</code>函数后<code class="du jn jo jp jq b">Supplied</code>类型都会改变，这就是为什么每当<code class="du jn jo jp jq b">with</code>被调用时，它会缩小允许传递给函数的键的列表。</p><p id="64e9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">现在让我们来分解实现中最复杂的部分——<code class="du jn jo jp jq b">with</code>函数的返回类型:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="6d64" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这段代码实现了类似于JavaScript中的三元运算符，但是它适用于<strong class="it jt">类型</strong>。这个特性叫做<a class="ae jm" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#conditional-types" rel="noopener ugc nofollow" target="_blank">条件类型</a>，它允许你定义一个基于你的条件选择的类型。</p><p id="f197" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这里的想法是，如果所有应该在对象中的字段都已经通过方法<code class="du jn jo jp jq b">with</code>提供，则返回类型<code class="du jn jo jp jq b">IBuild</code>。否则，我们应该返回<code class="du jn jo jp jq b">IWith</code>。</p><p id="46b2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><code class="du jn jo jp jq b">keyof Omit&lt;Omit&lt;Target, keyof Supplied&gt;, K&gt; extends never</code> —在这一行中，我们检查<code class="du jn jo jp jq b">K</code>是否是应该提供的最后一个密钥，以及它是否是类型安全的，允许通过<code class="du jn jo jp jq b">build</code>方法构建对象。</p><p id="2980" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><code class="du jn jo jp jq b">Omit&lt;Target, keyof Supplied&gt;</code> —从<code class="du jn jo jp jq b">Target</code>类型中删除<code class="du jn jo jp jq b">Supplied</code>类型的所有按键。所以如果<code class="du jn jo jp jq b">type Target = { status: number, payload: string }</code>和<code class="du jn jo jp jq b">type Supplied = { status: number }</code><code class="du jn jo jp jq b">Omit&lt;Target, keyof Supplied&gt;</code>的结果是<code class="du jn jo jp jq b">{ payload: string}</code>。</p><p id="5242" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">在我们的例子中，<code class="du jn jo jp jq b">keyof T extends never</code>检查<code class="du jn jo jp jq b">T</code>是否是一个描述空对象的类型。在<code class="du jn jo jp jq b">type T = keyof {} extends never ? true : false</code>中——<code class="du jn jo jp jq b">T</code>具有类型<code class="du jn jo jp jq b">true</code>，因为<code class="du jn jo jp jq b">keyof {} extends never</code>返回<code class="du jn jo jp jq b">true</code>。</p><p id="9d5c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这听起来有点棘手，但是这个返回类型基本上决定了对象是否已经完全构建好并准备好通过函数<code class="du jn jo jp jq b">build</code>返回，或者它仍然缺少一些字段，因此函数<code class="du jn jo jp jq b">with</code>必须被调用几次。</p><p id="d2e0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">3.类别<code class="du jn jo jp jq b">Builder</code></p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="5c6c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这是实现接口<code class="du jn jo jp jq b">IBuild</code>和<code class="du jn jo jp jq b">IWith</code>的类。这两种方法的实现都非常简单。 <code class="du jn jo jp jq b">build</code>简单的返回私有字段<code class="du jn jo jp jq b">target</code>，是正在构造的对象。<code class="du jn jo jp jq b">with</code>接受键和值参数，并将它们放到新的<code class="du jn jo jp jq b">target</code>对象中。唯一值得仔细研究的是第7行:</p><pre class="ig ih ii ij fd kk jq kl km aw kn bi"><span id="2390" class="hg hh hi jq b fi ko kp l kq kr">return new Builder&lt;Target, Supplied &amp; Pick&lt;T, K&gt;&gt;(target)</span></pre><p id="0f1d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">我们不重用构建器的单个实例，而是在每次调用<code class="du jn jo jp jq b">with</code>后创建一个新实例。这是为了用正确的类型参数重新初始化<code class="du jn jo jp jq b">Builder</code>。请参见下面的细分:</p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="c4aa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">4.类别<code class="du jn jo jp jq b">ObjectBuilder</code></p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="afe8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这个类是一个“入口点”,它将实现细节隐藏在一个简单的接口后面，这样消费者就不必担心用正确的类型初始化<code class="du jn jo jp jq b">IWith</code>接口。</p><p id="d43b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果我们最终将所有这些部分联系在一起，我们将得到以下逻辑:</p><ul class=""><li id="c280" class="jv jw hi it b iu iv iy iz hs jx hw jy ia jz jl ka kb kc kd bi translated">如果类型<code class="du jn jo jp jq b">Target</code>的所有字段都已通过<code class="du jn jo jp jq b">with</code>函数添加——使用<code class="du jn jo jp jq b">IBuild</code>作为返回类型。这意味着方法<code class="du jn jo jp jq b">build</code>变得可用，我们可以得到我们正在构建的对象。</li><li id="bac3" class="jv jw hi it b iu ke iy kf hs kg hw kh ia ki jl ka kb kc kd bi translated">否则，返回<code class="du jn jo jp jq b">IWith</code>,这意味着对象还没有完全初始化，需要再调用几次<code class="du jn jo jp jq b">with</code>。</li></ul></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="ddf0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果你已经看完了这篇文章，并且理解了我试图解释的概念，我会很高兴。这些概念相当复杂，实现类型安全的对象构建器模式有点令人费解。</p><p id="add0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果你对这个话题感兴趣，可以考虑在github.com的<a class="ae jm" href="https://github.com/anton-kravchenko/ObjectBuilder" rel="noopener ugc nofollow" target="_blank">查看更高级的实现(它考虑了可选字段等等)。该实现也可以作为一个名为</a><a class="ae jm" href="https://www.npmjs.com/package/typescript-object-builder" rel="noopener ugc nofollow" target="_blank">typescript-object-builder</a>的npm包。</p><p id="b33a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">感谢您阅读文章，祝您编码愉快！</p></div></div>    
</body>
</html>
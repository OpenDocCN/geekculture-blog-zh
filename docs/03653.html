<html>
<head>
<title>[How it Works] Memory and Performance. Part 1.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[工作原理]内存和性能。第一部分。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-it-works-memory-and-performance-part-1-83cf3bc167a7?source=collection_archive---------3-----------------------#2021-06-13">https://medium.com/geekculture/how-it-works-memory-and-performance-part-1-83cf3bc167a7?source=collection_archive---------3-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ef2bba27859d8a95650d02afd0ceb84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZuYsN5L-_0q9zcJq"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Dziedzic</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2a61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您是一名软件工程师，并且关心性能，那么本文适合您。你更喜欢哪种语言并不重要，C、C++、Java、Python、GO等等。我在这里尝试介绍的内容应该会让你对你的计算机内存有所了解。因为基本上每个程序都与内存交互，所以很好地了解它是至关重要。</p><p id="846a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将尝试深入讨论它，并提供一些真实世界中的例子，但是不要期望这是“最佳实践”和建议的集合。看完这个你会是给建议的人:)。力量在于知识，而不在于盲目的遵守规则。</p><p id="fe56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你是一个初学者，不要担心，我会确保我们正在覆盖的基础。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6f93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好，我们从基础开始。电脑内存意味着很多东西，我们先按易失性分类。</p><p id="6ee9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有两种类型，易失性和非易失性(别烦了，请忽略半易失性)。</p><p id="37a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">非易失性存储器</strong></p><p id="7a3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非易失性存储器是即使不通电也能保留存储信息的计算机存储器。在本文中，我们将简要介绍HDD和SSD。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/61aa3a5ed17d6ec3d9fc13f29cdf9f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CUoAsXHB7tyUiG3D"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">HDD. Hard Disk Drive.</figcaption></figure><p id="c504" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">硬盘</strong>。你很可能听说过HDD(硬盘驱动器),它是一种“磁盘”,旋转速度非常快，可以读取/写入你的宝贵信息。与其他非易失性存储类型相比，其主要优势在于容量和成本之间的平衡。</p><p id="78be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要读一些东西，你需要用磁头在磁盘表面寻找你的文件，并开始把磁场转换成字节。你可能会问，如果我的文件很大，并且遍布磁盘表面(也称为<strong class="ix hj">碎片</strong>)怎么办？嗯，你会花更多的时间。因为我们等待磁盘旋转到下一个文件碎片的时间是浪费时间。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/309d057057bda6b3ded5849db5284989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gWFJVkSw6HlLvUeP"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">On left. High fragmentation, 5 spins required. | On Right. No fragmentation, less than 1 spin required.</figcaption></figure><p id="c2bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于这种设计，我们具有以下特点:</p><p id="997f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">快速顺序操作</strong> —查找文件会浪费时间，但如果文件不是分散的，你可以一口气读完！</p><p id="9281" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">缓慢的随机操作</strong> —在磁盘表面的随机位置读/写文件会增加很大的开销，因为磁头通常需要多次旋转才能到达每个位置。</p><p id="cd30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一下，磁头移动到所需位置所需的时间也称为<strong class="ix hj">访问时间</strong>。其他类型的内存没有磁头，但仍然有访问时间的惩罚，记住这一点。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/284c29920b331a25507be90dd26b9d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UGmDeQbunwQxreGJ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">SSD<strong class="bd kh">.</strong> Solid State Drive.</figcaption></figure><p id="52d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> SSD </strong>(固态硬盘)。这一款没有任何物理旋转磁盘或移动部件，因此您可以期待更好的<strong class="ix hj">访问时间</strong>，从而实现卓越的随机读/写操作。一般来说，固态硬盘通常比硬盘快10倍左右。当然，这个速度有点昂贵，同样的钱，你将有更少的容量相比，硬盘。</p><p id="c132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你知道吗，有些电脑游戏必须复制数据(通常是纹理)，以确保硬盘能够连续读取数据？了解这件小事有助于开发人员显著提高性能。然而，这种技术对于SSD来说并不是最佳的，因为访问时间的开销很小。</p><p id="fd2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">易失性记忆</strong></p><p id="9b6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">易失性存储器是需要电力来维持存储信息的计算机存储器。我们会经常谈到RAM。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/04286204d0cf2efce479b56c5b1c0c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PTRyWiiZ2ULlzmIf"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">RAM. Random Access Memory.</figcaption></figure><p id="3e9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">撞锤</strong>。(随机存取存储器)顾名思义，这种存储器允许在几乎相同的时间内读取或写入信息，而不管数据在存储器中的物理位置。通常，它比SSD/HDD快1000倍。如果与HDD/SSD相比，它也非常昂贵，并且容量会少一百倍。</p><p id="16b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们回顾一下记忆特征:</p><p id="1fdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">容量</strong> —关于我们可以存储多少数据。</p><p id="5f32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">易失性</strong> —没电时内存如何表现。</p><p id="ab94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">访问时间</strong> —我们需要多少时间来找到数据的物理位置。</p><p id="254f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">碎片化</strong> —我们的数据有多少被分解成许多物理上并不靠近的碎片。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="d6e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更进一步，我们将需要在视觉上表示记忆的方法上达成一致。<strong class="ix hj">平面内存模型</strong>或<strong class="ix hj">线性内存模型</strong>是最常见的内存寻址模式，我们在此基础上构建了许多抽象层，但是请耐心等待，我们将在后面介绍。在现代计算机体系结构中，一个内存地址指向一个字节的数据。这是它的样子:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/1c8b9f68b0685d92c94efdb154e4382c.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/0*bi_smBM6KTajoAFX"/></div><figcaption class="iq ir et er es is it bd b be z dx">Linear memory model.</figcaption></figure><p id="9627" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等一下！如果一个字节的信息与一个地址相关联，那么地址本身应该会占用你的内存空间，对吗？如果我们用1个字节存储地址，然后用1个字节存储信息本身，那么我们将浪费50%的内存来跟踪地址。简直是疯了！</p><p id="6d5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，它是！这就是为什么没人这么做的原因:)。与之相反，现代计算机只是“计数”每次“记忆细胞”。内存地址只是CPU从内存开始处跳过的字节数，以到达它所寻找的位置。例如:</p><ul class=""><li id="4d38" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">要访问第一个字节，它必须跳过0个字节，所以第一个字节的地址是0。</li><li id="f774" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">为了访问第二个字节，它必须跳过1个字节，所以它的地址是1。</li><li id="d9ef" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">(以此类推……)</li></ul><p id="6d99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你明白了，对吧？</p><p id="1c3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，但是我听说了一些限制，比如32位CPU不能有超过4GB的内存，为什么？</p><p id="f021" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哦，我喜欢你的问题。事情是这样的，当你指示你的CPU做某事时，你将不得不调用一个带有参数的特殊函数。假设我们正在调用“goto 1000”，这意味着转到内存地址1000。CPU必须将这个数字存储在某个地方，然后获取指令并执行。这个存储单元被称为CPU寄存器，并且该寄存器的容量被限制为32位。32位中可以存储的最高数字是2 <strong class="ix hj"> </strong>(或4294967296)，也就是4Gb。这意味着你不能告诉你的CPU去一个高于这个数字的内存地址。你可以有更多的内存，但是CPU将不能读/写超过这个限制的任何东西。幸运的是，大多数现代计算机现在都有64位架构(但并不总是64位寄存器)，这意味着它将能够与16艾字节(2 <strong class="ix hj"> ⁶⁴ </strong>字节)的RAM一起工作(遗憾的是，这将花费很多，不要指望在你的普通家用电脑中有这种东西)。</p><p id="d3a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ki">知道就好。从CPU的角度来看，对RAM的内存访问相对较慢，可能需要几个时钟周期才能完成。存储器对寄存器的访问非常快(通常是一个时钟周期)。为了克服这个问题，现代CPU将使用内存缓存。</em></p><p id="87e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果我的程序需要使用大于255 (1字节)的数字呢？这将如何存储在内存中？</p><p id="1c0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没问题！你只需要知道你的整数开始的内存地址和需要多少字节。在下图中，你可以看到一个2字节的整数是如何存储在内存中的。我们将从地址0x6000开始读取数据，并在地址0x6001处停止。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/26eaf60cca2f57ec23b56217ffc75c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/0*4daeUiD0cMcwfc2D"/></div></figure><p id="3397" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太好了！现在我们知道了基本知识。我们知道不同的记忆类型和记忆的主要特征。此外，我们学习了一些关于线性内存模型和CPU如何访问它。让我们转到程序上。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="b765" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从程序的基本工作流程开始，从内存的角度来看它是如何工作的。但在此之前，我们如何制作这些程序？一般来说，你有简单的文本文件，我们称之为<strong class="ix hj">源文件</strong>，然后使用你的特定语言编译器把它编译成<strong class="ix hj">可执行文件</strong>。</p><p id="35ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哎，我是程序员，我明明知道！</p><p id="1331" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，好的……可执行文件包含你的操作系统和CPU可读的指令。可执行文件中主要有两块:<strong class="ix hj">数据</strong>(包含全局变量、常量、其他静态数据)，和<strong class="ix hj">代码</strong>(包含你编译的函数)。</p><p id="f428" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，明白了…但是我的程序怎么会在内存里呢？</p><p id="7ed0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很高兴你问了！这部分工作由操作系统<strong class="ix hj">加载器</strong>处理。当用户执行可执行文件时，“加载器”会确保为你的程序分配内存，然后将它复制到你的<em class="ki">操作内存</em> (RAM)中。但这一切都没那么简单！我们需要更深入！通常，操作系统加载程序会将分配的内存分成几个<strong class="ix hj">内存段</strong>。</p><p id="d1cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将涵盖四个内存段:<strong class="ix hj">代码</strong>(显然是您编译的函数)<strong class="ix hj">静态</strong>(来自可执行文件的数据部分)<strong class="ix hj">堆栈</strong>和<strong class="ix hj">堆</strong>。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es la"><img src="../Images/7d132a636675f79f15d4d87320d85cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*sspk9QZb_bc_vdypUx3ojw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Program Memory Segments.</figcaption></figure><ul class=""><li id="6858" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated"><strong class="ix hj">代码段</strong>:通常被加载程序标记为只读(该特性依赖于操作系统)，这样CPU将无法覆盖该地址范围。如果试图改变这个程序段，操作系统可能会检测到并立即中止程序。</li><li id="e035" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated"><strong class="ix hj">静态段</strong>:这个段的大小是固定的，当程序运行时，它会一直存在内存中。不管你是否使用它。与上一段不同，这一段可以在执行过程中更改。</li><li id="d926" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated"><strong class="ix hj">栈段</strong>(又名调用栈):如果静态段包含全局变量和常量，这个包含局部变量。该段被分成许多<strong class="ix hj">堆栈帧。</strong>堆栈帧在函数运行前加入堆栈，执行后移除。</li></ul><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/89c81ea9f72f61bc065bc1a17e4616f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/0*tSHS-iuukzgExVfq"/></div><figcaption class="iq ir et er es is it bd b be z dx">Call stack/Stack segment</figcaption></figure><p id="2431" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈帧包含一个函数调用所需的所有信息。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/d05b0c1a034b44833e9b0ef41265b9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/0*cRXaODqg26mvBNq2"/></div><figcaption class="iq ir et er es is it bd b be z dx">Stack frame contains function arguments, local variables and return address</figcaption></figure><p id="3149" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数调用被分成几条指令:</p><ul class=""><li id="e702" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">为堆栈帧分配内存</li><li id="b2b3" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">将堆栈帧推入调用堆栈</li><li id="2e39" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">运行堆栈框架中声明的函数</li><li id="e6bb" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">弹出已执行的堆栈帧</li></ul><p id="a728" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，程序员对此不会太在意。内存将被自动释放和分配。请注意，帧的大小是固定的！</p><p id="39ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，这是不是意味着调用函数比把所有东西写成一个单独的指令流更昂贵？</p><p id="2d3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，它有一点开销，但是不要害怕把你的逻辑分解成小函数，现代编译器很聪明，通常会“内联”函数。开销可能为零或最小。但是要意识到“抽象”对于性能来说是不可忽视的。(<em class="ki">也许有一天，我会写一篇文章，介绍如何设计您的代码来利用CPU缓存和其他高级技术，如无分支编程，但现在，我们正在讨论内存</em></p><ul class=""><li id="439f" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">堆段(Heap segment):这部分是为程序员需要分配大的、可动态调整大小的数据结构的情况而设计的。在堆栈或静态段中不可能实现的东西。我们可以控制数据的生命周期，并决定何时释放和分配内存。堆管理是一个非常复杂的话题。编程语言将实现不同的<strong class="ix hj">内存管理器。</strong>这些通常试图分配一个连续的内存块，当你请求内存预留时，这个内存块会被分割成更小的块。简而言之，它跟踪哪些块被使用，哪些没有被使用。如果在程序执行过程中，内存管理器以一种不恰当的顺序分配和释放内存块，那么您可能会得到一个非常零碎的堆段。</li></ul><p id="64ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嘿，碎片不应该是一个问题，我们有快速访问内存的时间，对不对？</p><p id="d8c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯……是的，也不尽然。下面是一个RAM碎片可能成为问题的例子。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/6262becc9663eb59b7630404fd4cfb3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*m4mZuNXHf6A4dtLUAS1MQA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">High memory fragmentation</figcaption></figure><p id="2144" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们总共有400 kB的已用内存和400 kB的未用内存。现在，假设你的程序需要一个200kB的数组。即使你总共有400 kB的空闲内存，你也找不到200kB或更大的块，你会得到一个内存分配失败。解决这个问题的方法是<strong class="ix hj">内存压缩。</strong>记忆什么？<strong class="ix hj">内存压缩！</strong>这个<strong class="ix hj"> </strong>是为了最大化可用空闲空间而对主存储器中的信息块进行重定位的过程。但是请记住，要做到这一点，您必须执行一些malloc()和free()操作。你的程序必须停止执行并重组内存块。显然，从性能的角度来看，这是相当昂贵的。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/1d840adbd8c3b38ed0f06c9028daf586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*1u_ijopCpnTamqboNQJgDQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Memory after compaction.</figcaption></figure><p id="d4e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，您的程序可能会遭受严重的<strong class="ix hj">堆碎片</strong>问题，导致内存利用率低、性能下降，以及由于内存耗尽而导致的应用程序故障。</p><p id="6af4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是否意味着“不可变性”会导致非常高的碎片化，并且会给内存管理人员带来很大的压力？</p><p id="6227" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很可能是的，所以试着合理地使用它，它是多线程的一个很好的解决方案，原因有很多，但是过多的内存分配会有很大的影响。</p><p id="7ef1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ki">还记得之前提到的CPU内存缓存吗？从CPU的角度来看，内存查找是很昂贵的，可以从缓存中进行，但是缓存本身的容量有限。RAM碎片过多可能会耗尽高速缓存。当我们学习内存页面的时候，我们会再讨论这个问题。</em></p><p id="d630" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像Java、Go和Python这样的语言都有垃圾收集器，它们循环压缩内存。像C/C++这样的语言有不同的内存分配器/管理器来解决相同的问题。即使看起来问题被内存管理器和垃圾收集器神奇地解决了，您也需要记住压缩内存涉及到额外的复制操作、扫描和长时间的暂停！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="d6e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一部分到此为止。在接下来的部分中，我们将学习内存对齐、内存分页、内存映射、缓存和一些性能技巧。如果你对第二部分感兴趣，请在评论中告诉我。你认为细节的层次如何？是太肤浅还是太复杂难懂？我会考虑你对第二部分的反馈。另外，如果你对某样东西感兴趣，可以随意提出下一个话题。</p><p id="6e90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您阅读本文！</p></div></div>    
</body>
</html>
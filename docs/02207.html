<html>
<head>
<title>How to Create a Messaging App With Twilio Chat &amp; React JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Twilio Chat &amp; React JS创建消息应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-a-messaging-app-with-twilio-chat-react-js-7fd93f75842c?source=collection_archive---------4-----------------------#2021-05-07">https://medium.com/geekculture/how-to-create-a-messaging-app-with-twilio-chat-react-js-7fd93f75842c?source=collection_archive---------4-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/24297db9b847040c989c75e6b66da357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oy6Mn0Cm13SrPEwB.png"/></div></div></figure><div class=""/><h1 id="3e99" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们使用Twilio的聊天API来构建一个多用户消息应用程序。</h1><p id="48c8" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="km">在这篇文章中，学习如何实现Twilio对话API来创建一个基本的聊天室应用程序。你可以用这些方法创建一个类似Slack </em>的app</p><h1 id="c23d" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">您需要什么:</h1><ul class=""><li id="b1a6" class="kn ko ht jq b jr js jv jw jz kp kd kq kh kr kl ks kt ku kv bi translated">Twilio免费试用</li><li id="66d9" class="kn ko ht jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated"><a class="ae lb" href="https://www.twilio.com/console/chat/services" rel="noopener ugc nofollow" target="_blank"> Twilio聊天API </a></li><li id="bb94" class="kn ko ht jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">初级反应知识</li><li id="7c27" class="kn ko ht jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">NodeJS(和首选的包管理器，我将使用yarn)</li></ul><h1 id="0429" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">我们开始吧</h1><h2 id="fd21" class="lc ir ht bd is ld le lf iw lg lh li ja jz lj lk je kd ll lm ji kh ln lo jm lp bi translated">首先，让我们用create-react-app设置我们的应用程序。</h2><p id="8d5b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">继续创建您的项目目录。我通常会进入我所有项目的文件夹，找到与我正在处理的内容相关的特定文件夹，因此对于这个示例，我将位于我的React文件夹中，在那里我保存了使用React创建的所有项目。</p><p id="e00b" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated"><em class="km">例如桌面/项目/反应/反应聊天</em></p><p id="6689" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">然后，我将创建我的文件夹，右键单击并在代码中打开。</p><p id="108b" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">您也可以打开终端，<em class="km"> mkdir dirNam </em> e并运行<em class="km">。代码</em></p><p id="f773" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">但是我喜欢在VSCode上使用内置终端。</p><p id="4bff" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">现在运行以下命令:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="fbe4" class="lc ir ht ma b fi me mf l mg mh">npx create-react-app frontend<br/>cd frontend<br/>yarn add axios react-router-dom twilio-chat @material-ui/core</span></pre><p id="909a" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated"><em class="km">或npm安装，具体取决于您的软件包管理器首选项</em></p><h2 id="e1ac" class="lc ir ht bd is ld le lf iw lg lh li ja jz lj lk je kd ll lm ji kh ln lo jm lp bi translated">后端设置</h2><p id="826b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">前端大部分都设置好了，让我们继续设置我们的后端。</p><p id="987a" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">让我们导航回主目录。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="1289" class="lc ir ht ma b fi me mf l mg mh">cd ..</span></pre><p id="ea20" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">在reactjs-chat(或您的主目录)中，让我们运行以下代码:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="71be" class="lc ir ht ma b fi me mf l mg mh">git clone <a class="ae lb" href="https://github.com/TwilioDevEd/sdk-starter-node.git" rel="noopener ugc nofollow" target="_blank">https://github.com/TwilioDevEd/sdk-starter-node.git</a><br/>cd sdk-starter-node<br/>yarn install <br/>yarn add cors</span></pre><p id="eef7" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">基本上，我们想要克隆repo Twilio为他们的服务创建的一个简单的开始，这使我们能够访问通知处理和令牌生成等内容。令牌生成是我们需要它的原因。</p><p id="3bcd" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">接下来，导航到VSCode上的app.js并找到以下代码行:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="092f" class="lc ir ht ma b fi me mf l mg mh">const app = express();</span></pre><p id="97d8" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">复制以下代码，并将其直接粘贴到上面一行的下方。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="c45f" class="lc ir ht ma b fi me mf l mg mh">const cors = require('cors');<br/>app.use(cors());</span></pre><p id="540d" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这代表<strong class="jq hu">跨产地资源共享。</strong></p><p id="5c93" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">它允许服务器指示除了它自己以外的任何其它来源，浏览器应该允许从这些来源加载资源。基本上，我们需要它来访问外部API。</p><h2 id="b7f6" class="lc ir ht bd is ld le lf iw lg lh li ja jz lj lk je kd ll lm ji kh ln lo jm lp bi translated">Twilio Keys</h2><p id="007f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你还没有Twilio帐户，请到这里免费试用。</p><p id="1000" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">在您的<strong class="jq hu"> sdk-start-node </strong>目录中，您应该会看到一个名为<code class="du mi mj mk ma b">.env.example</code>的文件，我们将其重命名为<code class="du mi mj mk ma b">.env</code></p><p id="9e52" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">它将有一个预填充的例子，为您需要获得的所有密钥。</p><p id="6aa3" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">第一个在你的<strong class="jq hu">账户仪表盘上</strong>，<a class="ae lb" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank">这里</a>，你会看到<strong class="jq hu">账户SID </strong>，把它复制到<code class="du mi mj mk ma b">TWILIO_ACCOUNT_SID</code>里。环境文件。</p><p id="dc28" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">接下来，您需要一个API密钥来进行身份验证。转到工具条中的<strong class="jq hu">设置&gt; API密钥</strong>并点击<strong class="jq hu">创建API密钥。</strong></p><p id="68ce" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">复制<strong class="jq hu"> SID </strong>和<strong class="jq hu"> SECRET </strong>并将它们作为<code class="du mi mj mk ma b">TWILIO_API_KEY</code>和<code class="du mi mj mk ma b">TWILIO_API_SECRET</code>的值粘贴到您的<code class="du mi mj mk ma b">.env</code>中</p><p id="4f41" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">至此，我们已经完成了一般的帐户设置。我们需要去<a class="ae lb" href="https://www.twilio.com/console/chat/services" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="e526" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">创建聊天服务。您需要单击加号按钮并命名您的服务。</p><p id="a563" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">为您的服务复制<strong class="jq hu">服务SID </strong>，并将其粘贴为<code class="du mi mj mk ma b">TWILIO_CHAT_SERVICE_SID</code>环境变量的值。</p><p id="9f7b" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">现在，我们可以在sdk-starter-node目录中运行以下内容:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="da00" class="lc ir ht ma b fi me mf l mg mh">yarn start</span></pre><p id="714a" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">服务器将从<code class="du mi mj mk ma b">localhost:3000</code>开始，看起来像这样:</p><h2 id="c38d" class="lc ir ht bd is ld le lf iw lg lh li ja jz lj lk je kd ll lm ji kh ln lo jm lp bi translated">“登录”和聊天屏幕</h2><p id="ed87" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们的后端已经完成，所以让我们的应用程序功能和外观漂亮。</p><p id="7132" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我为这个应用程序创建了一个非常简单和基本的前端，你可以随心所欲地设计你的风格。</p><p id="12b9" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这个想法将是首先提示用户一个电子邮件，然后让用户选择一个聊天室。</p><p id="b0af" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">让我们回到前端目录，找到您的index.js并将<App/>组件包装在路由器中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="7c92" class="lc ir ht ma b fi me mf l mg mh">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;Router&gt;<br/>      &lt;App /&gt;<br/>    &lt;/Router&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);<br/>​</span></pre><p id="ed33" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">当然，不要忘记导入路由器</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="32c1" class="lc ir ht ma b fi me mf l mg mh">import { BrowserRouter as Router } from 'react-router-dom'</span></pre><p id="8447" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这就是你需要对index.js做的所有事情，继续并关闭它。</p><p id="88e5" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">转到App.js，删除主容器和App的类名之间的所有内容。移除内容后，将其包在一条路线中并进行切换。</p><p id="9cdc" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">下面我将我的应用程序div包装在一个默认路径中，并添加了我将用于聊天屏幕的路径。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="a3a7" class="lc ir ht ma b fi me mf l mg mh">return (<br/>    &lt;Switch&gt;<br/>      &lt;Route path="/:room" component={Chat} /&gt;<br/>      &lt;Route path="/"&gt;<br/>        &lt;div className="App"&gt;<br/>        <br/>      	&lt;/div&gt;<br/>      &lt;/Route&gt;<br/>    &lt;/Switch&gt;<br/>  );</span></pre><p id="2755" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">您的导入应该如下所示:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="fc03" class="lc ir ht ma b fi me mf l mg mh">import './App.css';<br/>import React, { useState } from "react";<br/>import { Route, Switch, useHistory } from "react-router-dom"; <br/>import Chat from './components/Chat';</span></pre><p id="812d" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们将使用自定义钩子进行状态维护。</p><p id="4e89" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">在您的<strong class="jq hu"> src </strong>目录中，创建一个名为<strong class="jq hu"> components </strong>的文件夹。然后创建一个名为Chat.js的文件，并立即输入<code class="du mi mj mk ma b">_rfce</code>。(你需要<a class="ae lb" href="https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets" rel="noopener ugc nofollow" target="_blank">这个</a>插件，否则只需输入你的函数)</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="7e76" class="lc ir ht ma b fi me mf l mg mh">function Chat() {<br/>    <br/>    return (<br/>        &lt;div className="chatScreen"&gt;<br/>            <br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="7089" class="lc ir ht ma b fi ml mf l mg mh">export default Chat</span></pre><p id="a94a" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">好了，让我们回到App.js并获取用户的电子邮件。</p><p id="5222" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这是我的布局:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="fba1" class="lc ir ht ma b fi me mf l mg mh">return (<br/>    &lt;Switch&gt;<br/>      &lt;Route path="/:room" component={Chat} /&gt;<br/>      &lt;Route path="/"&gt;<br/>        &lt;div className="container"&gt;<br/>        &lt;main className="main"&gt;<br/>          &lt;h1 className="title"&gt;<br/>            Welcome<br/>          &lt;/h1&gt;</span><span id="9135" class="lc ir ht ma b fi ml mf l mg mh">          &lt;section className="loginSection"&gt;<br/>            &lt;input type="email" onChange={(e)=&gt;updateEmail(e.target.value)} placeholder="Email" /&gt;<br/>            {<br/>              emailWarning&amp;&amp;<br/>              &lt;span className="warning"&gt;You need to enter your email.&lt;/span&gt;<br/>            }<br/>            &lt;button onClick={login}&gt;Continue&lt;/button&gt;<br/>          &lt;/section&gt;<br/>          <br/>        &lt;/main&gt;<br/>      &lt;/div&gt;<br/>      &lt;/Route&gt;<br/>    &lt;/Switch&gt;<br/>  );</span></pre><p id="8517" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我正在用一个自定义钩子更新email变量；我们马上就知道了。首先让我们设计这些元素的样式:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="7e19" class="lc ir ht ma b fi me mf l mg mh">.container {<br/>  min-height: 100vh;<br/>  padding: 0 0.5rem;<br/>  display: flex;<br/>  flex-direction: column;<br/>  justify-content: center;<br/>  align-items: center;<br/>}</span><span id="ec9d" class="lc ir ht ma b fi ml mf l mg mh">.main {<br/>  padding: 5rem 0;<br/>  flex: 1;<br/>  display: flex;<br/>  flex-direction: column;<br/>  justify-content: center;<br/>  align-items: center;<br/>  max-height: 100vh;<br/>  overflow: hidden;<br/>}</span><span id="64ee" class="lc ir ht ma b fi ml mf l mg mh">.loginSection{<br/>  margin-top: 20px;<br/>  height: 70vh;<br/>  width: 70vw;</span><span id="4015" class="lc ir ht ma b fi ml mf l mg mh">  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>}<br/>.loginSection input{<br/>  margin-top: 30px;<br/>  width: 500px;<br/>  padding: 10px;<br/>  border: 2px solid transparent;<br/>  outline: none;<br/>  border-radius: 10px;<br/>}<br/>.loginSection input:focus{<br/>  border: 2px solid grey;<br/>}<br/>.loginSection button{<br/>  margin-top: 30px;<br/>  width: 500px;<br/>  padding: 15px;<br/>  background-color: rgba(74, 146, 74, 0.4);<br/>  border: 2px solid rgba(103, 175, 103, 0.4);<br/>  outline: none;<br/>  color: white;<br/>  border-radius: 10px;<br/>  cursor: pointer;<br/>}<br/>.loginSection button:hover{<br/>  background-color: rgb(74, 146, 74);<br/>  border: 2px solid rgb(103, 175, 103);<br/>}</span><span id="3fda" class="lc ir ht ma b fi ml mf l mg mh">.warning{<br/>  color: rgb(211, 63, 63);<br/>}</span></pre><p id="a51e" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">一旦我们开始工作，我们将有一个非常基本的欢迎屏幕:</p><p id="0b6f" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">接下来让我们创建钩子。我还将电子邮件保存在localStorage中，我们将使用react-router-dom的useHistory钩子将页面推送到聊天屏幕。</p><p id="fadf" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">当用户键入时，每个变化将运行<code class="du mi mj mk ma b">updateEmail()</code>这运行我们的定制钩子:<code class="du mi mj mk ma b">setEmail()</code>。它还将emailWarning设置为false，以防在用户没有首先输入电子邮件就点击continue时它被更改为true。</p><p id="a54a" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这里没有电子邮件验证，但是如果你愿意，你可以很容易地实现它。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="a1c1" class="lc ir ht ma b fi me mf l mg mh">const [email, setEmail] = useState('')<br/>  const [emailWarning, setEmailWarning] = useState(false);<br/>  <br/>  let history = useHistory();<br/>  function login() {<br/>    if (email) {<br/>      localStorage.setItem('email', email);<br/>      history.push("chat");<br/>    }<br/>    else if(!email){<br/>      setEmailWarning(true)<br/>    }<br/>  }</span><span id="3ced" class="lc ir ht ma b fi ml mf l mg mh">  const updateEmail = (e) =&gt; {<br/>    setEmail(e)<br/>    setEmailWarning(false)<br/>  }</span></pre><p id="2026" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">一旦我们有了用户的电子邮件，我们就将我们的域推送到聊天屏幕，这样App.js就完成了，让我们来构建聊天屏幕。</p><h2 id="c715" class="lc ir ht bd is ld le lf iw lg lh li ja jz lj lk je kd ll lm ji kh ln lo jm lp bi translated">聊天屏幕</h2><p id="2ae3" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，这是我们的进口货</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="c909" class="lc ir ht ma b fi me mf l mg mh">import { useHistory } from "react-router-dom"; <br/>import axios from "axios";<br/>import ChatItem from "./ChatItem";<br/>import React, { useRef } from "react";<br/>import { useEffect, useState } from "react";<br/>const ChatAPI = require("twilio-chat");</span></pre><p id="d278" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们将使用<strong class="jq hu"> axios </strong>从我们自己的后端获取令牌，并使用<strong class="jq hu"> useRef </strong>访问聊天内容，将它们滚动到底部。</p><p id="a102" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">继续在组件目录中创建ChatItem.js。</p><p id="b3bc" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">以下是我的Chat.js回复:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="cc49" class="lc ir ht ma b fi me mf l mg mh">return (<br/>        &lt;div className="chatScreen"&gt;<br/>            &lt;div className="sidebar"&gt;<br/>                &lt;h4&gt;{email}&lt;/h4&gt;<br/>                &lt;h2&gt;Rooms&lt;/h2&gt;<br/>                {<br/>                    roomsList.map((room) =&gt;(<br/>                        &lt;p key={room} onClick={()=&gt;changeRoom(room)}&gt;	{room}&lt;/p&gt;<br/>                    ))<br/>                }<br/>            &lt;/div&gt;</span><span id="d8ae" class="lc ir ht ma b fi ml mf l mg mh">            &lt;div className="chatContainer" ref={scrollDiv}&gt;<br/>                &lt;div className="chatHeader"&gt;<br/>                    {room === "chat" ? "Choose A Room" : room}<br/>                &lt;/div&gt;</span><span id="6312" class="lc ir ht ma b fi ml mf l mg mh">                &lt;div className="chatContents"&gt;</span><span id="4421" class="lc ir ht ma b fi ml mf l mg mh">                {(messages &amp;&amp; room !== "chat") &amp;&amp;<br/>                messages.map((message) =&gt; <br/>                  &lt;ChatItem<br/>                    key={message.index}<br/>                    message={message}<br/>                    email={email}/&gt;<br/>                )}</span><span id="bf1f" class="lc ir ht ma b fi ml mf l mg mh">                &lt;/div&gt;</span><span id="8e79" class="lc ir ht ma b fi ml mf l mg mh">                {<br/>                    room !== "chat" &amp;&amp;<br/>                &lt;div className="chatFooter"&gt;<br/>                    &lt;input type="text" placeholder="Type Message" onChange={(e)=&gt;updateText(e.target.value)} value={text} /&gt;<br/>                    &lt;button onClick={sendMessage} &gt;Send&lt;/button&gt;<br/>                &lt;/div&gt;<br/>                }</span><span id="bb7e" class="lc ir ht ma b fi ml mf l mg mh">            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    )</span></pre><p id="8ec4" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我有一个侧边栏，让所有的房间都在边上，比如Slack。点击一个将重新路由到每个房间的动态URI。聊天容器有一个标题部分，显示您所在的房间名称，底部是输入字段。</p><p id="425e" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">继续定义所有的常量和自定义挂钩:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="356f" class="lc ir ht ma b fi me mf l mg mh">const email = localStorage.getItem('email');<br/>    const room = window.location.pathname.split('/')[1];</span><span id="fad4" class="lc ir ht ma b fi ml mf l mg mh">    const [loading, setLoading] = useState(false);<br/>    const [messages, setMessages] = useState([]);<br/>    const [channel, setChannel] = useState(null);<br/>    const [text, setText] = useState("");<br/>        <br/>    const roomsList = ["general"];<br/>    let scrollDiv = useRef(null);</span></pre><p id="b829" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们从动态路径中收集房间名，并去掉正斜杠。电子邮件在本地存储中，因此我们可以从那里轻松访问它。</p><p id="a290" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">然后，我们创建用于加载的钩子、消息列表、通道(由Twilio创建)和文本(用户输入)。房间列表可用于本地目的，但您也可以将它存储在数据库中，以便以更动态的方式创建更多房间。</p><p id="34dd" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">最后一个变量scrollDiv将创建一个我们已经绑定到chatContainer div的引用。</p><p id="9ae5" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们侧边栏中的每个房间都有一个onClick事件来改变房间，功能很简单:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="932a" class="lc ir ht ma b fi me mf l mg mh">let history = useHistory();<br/>const changeRoom = room =&gt; history.push(room);</span></pre><p id="a8ca" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">让我们也在onChange上更新用户输入:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="dc45" class="lc ir ht ma b fi me mf l mg mh">const updateText = e =&gt; setText(e);</span></pre><p id="e910" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这些都是简单的方法。真正重要的部分是得到一个令牌:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="2f27" class="lc ir ht ma b fi me mf l mg mh">const getToken = async (email) =&gt; {<br/>        const response = await axios.get(`http://localhost:3000/token/${email}`);<br/>        const { data } = response;<br/>        return data.token;<br/>      }</span></pre><p id="7dcf" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这将访问我们的后端api，它基本上是由Twilio提供的，并返回一个令牌。</p><p id="e06f" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">接下来，我们将构建其余的函数。页面加载后，<code class="du mi mj mk ma b">joinChannel</code>将接收我们创建的一个通道，我们将在一个<code class="du mi mj mk ma b">useEffect</code>钩子中添加。</p><p id="d802" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">在我们的JavaScript中，我们会看到类似<code class="du mi mj mk ma b">messageAdded</code>的通道监听器。这些是由Twilio提供的。下面我们还有<code class="du mi mj mk ma b">handleMessageAdded</code>，它运行在前面提到的监听器上，获取与您当前房间相关的返回消息，并将它们添加到我们的消息数组中。</p><p id="2191" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">然后，我们创建我们的<code class="du mi mj mk ma b">sendMessage</code>函数，当用户点击发送时，这个函数被调用。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="1d1b" class="lc ir ht ma b fi me mf l mg mh">const joinChannel = async (channel) =&gt; {<br/>        if (channel.channelState.status !== "joined") {<br/>         await channel.join();<br/>       }<br/>     <br/>       setChannel(channel);<br/>       setLoading(false)<br/>     <br/>       channel.on('messageAdded', function(message) {<br/>        handleMessageAdded(message)<br/>      });<br/>    	scrollToBottom();<br/>     };<br/>const handleMessageAdded = message =&gt; {<br/>        setMessages(messages =&gt;[...messages, message]);<br/>        scrollToBottom();<br/>      };<br/>      <br/>      const scrollToBottom = () =&gt; {<br/>        const scrollHeight = scrollDiv.current.scrollHeight;<br/>        const height = scrollDiv.current.clientHeight;<br/>        const maxScrollTop = scrollHeight - height;<br/>        scrollDiv.current.scrollTop = maxScrollTop &gt; 0 ? maxScrollTop : 0;<br/>      };</span><span id="1f8b" class="lc ir ht ma b fi ml mf l mg mh">      const sendMessage = () =&gt; {<br/>        if (text) {<br/>            console.log(String(text).trim())<br/>            setLoading(true)<br/>            channel.sendMessage(String(text).trim());<br/>            setText('');<br/>            setLoading(false)<br/>        }<br/>      };</span></pre><p id="a499" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们的Chat.js的最后一部分是useEffect钩子，它将在页面加载完成时触发频道创建:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="d52d" class="lc ir ht ma b fi me mf l mg mh">useEffect(async() =&gt; {<br/>        let token = "";</span><span id="7ddc" class="lc ir ht ma b fi ml mf l mg mh">        if (!email) {<br/>            history.push("/");<br/>        }</span><span id="b898" class="lc ir ht ma b fi ml mf l mg mh">        setLoading(true)</span><span id="5e6b" class="lc ir ht ma b fi ml mf l mg mh">        try {<br/>          token = await getToken(email);<br/>        } catch {<br/>          throw new Error("Unable to get token, please reload this page");<br/>        }</span><span id="7acb" class="lc ir ht ma b fi ml mf l mg mh">        const client = await ChatAPI.Client.create(token);</span><span id="e7c8" class="lc ir ht ma b fi ml mf l mg mh">        client.on("tokenAboutToExpire", async () =&gt; {<br/>            const token = await getToken(email);<br/>            client.updateToken(token);<br/>        });</span><span id="5677" class="lc ir ht ma b fi ml mf l mg mh">        client.on("tokenExpired", async () =&gt; {<br/>            const token = await getToken(email);<br/>            client.updateToken(token);<br/>        });</span><span id="5ffd" class="lc ir ht ma b fi ml mf l mg mh">        client.on("channelJoined", async (channel) =&gt; {<br/>            const newMessages = await channel.getMessages();<br/>            console.log(newMessages)<br/>            setMessages(newMessages.items || []);<br/>            scrollToBottom();<br/>          });<br/>        <br/>          try {<br/>            const channel = await client.getChannelByUniqueName(room);<br/>              console.log(channel)<br/>              joinChannel(channel);<br/>              setChannel(channel)<br/>          } catch(err) {<br/>            try {<br/>              const channel = await client.createChannel({<br/>                uniqueName: room,<br/>                friendlyName: room,<br/>              });<br/>          <br/>              joinChannel(channel);<br/>            } catch {<br/>              throw new Error("Unable to create channel, please reload this page");<br/>            }<br/>          } <br/></span><span id="069a" class="lc ir ht ma b fi ml mf l mg mh">    }, [])</span></pre><p id="6308" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">首先，我们确保有一封电子邮件，如果没有，我们会把用户送回欢迎页面。然后，我们使用电子邮件来获取一个令牌，我们使用这个令牌来创建ChatAPI客户端。然后，客户端被用来创建一个存储大量信息的通道，比如附加到所述通道或房间的消息对象。消息对象包含它们自己的创建日期、作者等。</p><p id="19ca" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">在我们的JSX中，我们将消息对象传递到ChatItem组件中，从那里，我们可以使用存储在每个对象中的信息来创建我们的聊天气泡。</p><p id="62cf" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">让我们来看看ChatItem.js。</p><p id="6d19" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们的进口:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="ccb6" class="lc ir ht ma b fi me mf l mg mh">import React from "react";<br/>import { ListItem } from "@material-ui/core";</span></pre><p id="0bac" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">这里有一些可以使用的样式，我们将把它们添加到react文件中，而不是css文件中，这样我们就可以轻松地为用户响应和传入响应创建动态样式，而无需创建多个类。两个选项都有效。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="7363" class="lc ir ht ma b fi me mf l mg mh">const styles = {<br/>  listItem: (userMsg) =&gt; ({<br/>    flexDirection: "column",<br/>    alignItems: userMsg ? "flex-end" : "flex-start",<br/>  }),<br/>  container: (userMsg) =&gt; ({<br/>    maxWidth: "75%",<br/>    borderRadius: 10,<br/>    padding: 10,<br/>    color: "white",<br/>    fontSize: 12,<br/>    backgroundColor: userMsg ? "#F36E65" : "#9ea1a8",<br/>  }),<br/>  author: { fontSize: 10, color: "gray" },<br/>  timestamp: { fontSize: 8, color: "white", textAlign: "right", paddingTop: 5 },<br/>};</span></pre><p id="b481" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">我们只需要几个常量，我们从道具中得到它们:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="951c" class="lc ir ht ma b fi me mf l mg mh">function ChatItem(props) {<br/>  <br/>    const message = props.message;<br/>    const email = props.email;<br/>    const userMsg = message.author === email;</span></pre><p id="338d" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">最后，JSX:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="0191" class="lc ir ht ma b fi me mf l mg mh">return (<br/>      &lt;ListItem style={styles.listItem(userMsg)}&gt;<br/>        &lt;div style={styles.author}&gt;{message.author}&lt;/div&gt;<br/>        &lt;div style={styles.container(userMsg)}&gt;<br/>          {message.body}<br/>          &lt;div&gt;<br/>            {new Date(message.dateCreated.toISOString()).toLocaleString()}<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/ListItem&gt;<br/>    );</span></pre><p id="61cd" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated">此时，您应该能够运行<code class="du mi mj mk ma b">yarn start</code>并使用您的电子邮件登录。</p><h1 id="32ff" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="5714" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我复习了实现Twilio API的所有基础知识，得到了一个可以工作的消息应用程序。我希望它对你有所帮助，你可以随时查阅这些文档以获得更深入的信息，<a class="ae lb" href="https://www.twilio.com/docs/chat" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/docs/chat</a>。</p><p id="09a4" class="pw-post-body-paragraph jo jp ht jq b jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh lu kj kk kl hb bi translated"><a class="ae lb" href="https://github.com/tannerkc/TwilioReactChatApp" rel="noopener ugc nofollow" target="_blank">项目回购</a></p></div></div>    
</body>
</html>
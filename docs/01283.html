<html>
<head>
<title>ISP: The Interface Segregation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ISP:接口隔离原则</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/isp-the-interface-segregation-principle-44f1631ecd?source=collection_archive---------17-----------------------#2021-04-04">https://medium.com/geekculture/isp-the-interface-segregation-principle-44f1631ecd?source=collection_archive---------17-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cb94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们讨论的是<a class="ae jd" href="https://onloadcode.com/design-principles/" rel="noopener ugc nofollow" target="_blank">设计原则的子主题，</a> <strong class="ih hj"> ISP:接口隔离原则</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ab0a05e1166c739a30a9f6a2ab8ca859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uC-4nXwxNmoLJIE-.png"/></div></div></figure><p id="6e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jq translated"><span class="l jr js jt bm ju jv jw jx jy di"> T </span>这是<a class="ae jd" href="https://onloadcode.com/category/architecture/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">系统设计与软件架构</strong> </a>系列的第11篇文章。在本文中，我们讨论的是<a class="ae jd" href="https://onloadcode.com/design-principles/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">设计原则</strong>，</a> <strong class="ih hj"> ISP的子主题:接口隔离原则。</strong></p><h1 id="2304" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">以前的文章</h1><div class="kx ky ez fb kz la"><a href="https://jaya-maduka.medium.com/introduction-to-system-design-and-architecture-onload-code-9cdfb14635e9" rel="noopener follow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">系统设计和架构介绍—加载代码</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">本文是系统设计和软件架构系列的第一篇文章。在本文中，我们…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">jaya-maduka.medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jo la"/></div></div></a></div><div class="kx ky ez fb kz la"><a href="https://jaya-maduka.medium.com/introduction-to-system-design-and-architecture-onload-code-9cdfb14635e9" rel="noopener follow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">系统设计和架构介绍—加载代码</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">本文是系统设计和软件架构系列的第一篇文章。在本文中，我们…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">jaya-maduka.medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jo la"/></div></div></a></div><h1 id="3ff3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是界面分离原理？</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/3bfd65c7f320691a994ff89c8d7bab4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OK2cCI1UfQng4rkp.png"/></div></div></figure><p id="383e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口隔离原则规定客户端不应该强制运行他们不使用的接口。基于这种方法，许多较小的接口比单个的大接口更好，每个接口服务于一个子模块。</p><p id="71de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP将非常大的接口分成更小、更专业的接口，以便客户只执行他们感兴趣的方法。</p><p id="d5fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP的目的是方便系统的拆卸和重新激活、修改和重新部署。因为一个系统是在不同的层次上连接的，如果不需要任何额外的改变，就不能在一个地方进行改变。这些副作用可以通过使用接口或抽象类来防止。</p><p id="473b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP的目的是方便系统的拆卸和重新激活、修改和重新部署。因为一个系统是在不同的层次上连接起来的，如果不需要任何额外的改变，就不可能在一个地方进行改变。这些副作用有能力通过使用接口或抽象类来防止。</p><h2 id="da4c" class="lq ka hi bd kb lr ls lt kf lu lv lw kj iq lx ly kn iu lz ma kr iy mb mc kv md bi translated">准确的总结是界面分离原则的关键</h2><p id="3413" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">找到正确的摘要不仅仅是一门艺术。当然，你必须探索你的领域，经常创建解释网，并提交用户系列。此外，绘制交互图——所有这些都不会引导您进行正确的抽象。错误的抽象比抽象更糟糕，所以不要忘记第三条规则。</p><p id="a970" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你认为你已经完成了一些抽象，把它们描绘成接口。上面提到的技术使它们成为地面接口。使用这种方法，具体的类只在那些抽象所必需的范围内起作用。所以我们最终满意而归，却不知道界面分离原理的存在。</p><h1 id="e94a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">违反界面分离原则</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/10fe53745b8753805a4a5f8eae6ccebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QzNOr3DW2CADWzE1.png"/></div></div></figure><p id="cb3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当客户端依赖不使用它的方法时。说明你的抽象是错误的。Martin Fowler的接口角色示例(它是ISP应用程序的自然百科全书)揭示了不正确的初始对象分解。它不需要一个独立的政策来表达它。代码显然不够紧凑。所以不要沉思你的代码是否违背了接口分离的原则，想想你的总结是否正确。</p><h1 id="03bf" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">重要</h1><p id="6fdd" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">在面向对象的设计中，代码简化并创建了抽象层接口，这些接口创建了一个屏障，阻止它与依赖项进行交互。</p><p id="529a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据许多签署了软件技术政策声明的软件专家所说。此外，编写设计良好且自我解释的软件与编写工作软件同样重要。使用界面来进一步解释软件的意图通常是一个好主意。</p><p id="397a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为一个系统是在多个层次上连接的，所以在一个地方不需要任何额外的改变就不能进行任何改变。这些副作用有能力通过使用接口或抽象类来防止。</p><h1 id="bdb1" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">ISP违规代码以及如何修复它们</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/2a77f4db2f3a3b978f80b41fa52b59d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xFwhpqswLXK0fvtE.png"/></div></div></figure><p id="e293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论是单独工作还是在大型团队中工作，它都有助于提前识别代码中的问题。因此，让我们讨论一些可以表明ISP侵权贷款的代码顺序。</p><h2 id="fc32" class="lq ka hi bd kb lr ls lt kf lu lv lw kj iq lx ly kn iu lz ma kr iy mb mc kv md bi translated">伟大的界面</h2><p id="8bf3" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">在大型接口中，操作太多，但是对于大多数对象来说，这些操作并没有被用到。ISP告诉我们，我们需要一个接口中的大多数或所有方法，而在一个大型接口中，我们通常只需要其中的几个方法。此外，当测试大型接口时，我们需要确定哪些依赖项需要模拟，哪些可能需要庞大的测试设置。</p><h2 id="daba" class="lq ka hi bd kb lr ls lt kf lu lv lw kj iq lx ly kn iu lz ma kr iy mb mc kv md bi translated">未使用的依赖项</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/49bd2ff394246fbb15c7dd5306356882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lgt4ggOLjA3kQixD.png"/></div></div></figure><p id="0948" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP违约的另一个含义是，我们必须给一个系统零或等值的价值。在我们的例子中，我们可以使用Odercombo()来下一个汉堡订单，绕过0作为fries参数。这个客户端不需要依赖薯条，所以我们必须有一个单独的界面来订购薯条。</p><h2 id="4862" class="lq ka hi bd kb lr ls lt kf lu lv lw kj iq lx ly kn iu lz ma kr iy mb mc kv md bi translated">特殊的投掷方法</h2><p id="4541" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">就像在我们的汉堡例子中，如果我们遇到一个非操作性的异常。和未实现的异常或类似的异常，可能感觉像是ISP相关的设计问题。这是重新设计这些类的好时机。</p><h1 id="02b8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">那么，接口应该总是只有一个方法吗？</h1><p id="ae0f" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">应用到ISP端也会产生一个称为接口的单模接口。</p><p id="5974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个解决方案将解决ISP违约的问题。然而，它也可能破坏接口的一致性。因此很难维护分散的代码库。比如在Java中，add-on接口有很多模式，比如size()和is Empty()，这两种模式经常一起使用，所以只有一个接口是有意义的。</p><p id="ce85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP是将代码对象缩减到最小执行量，并删除对象正常运行所不需要的依赖项。一般来说，实现这个原则的效果是拥有许多小型的、集中的接口，这些接口只定义实现它们所需的东西。</p><h1 id="9e47" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">值得吗？</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/ea1dc44bd7060c192926b6007a878bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O2Uk0k5euNyZ379S.png"/></div></div></figure><p id="0390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候是值得的。这是唯一可靠的原则。一方面，通过积极地遵循这一原则，你可以得到一个更加灵活和可变的代码，我是一个大粉丝，它对现实世界的项目非常有用。</p><h1 id="5591" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="1df8" class="pw-post-body-paragraph if ig hi ih b ii me ik il im mf io ip iq mg is it iu mh iw ix iy mi ja jb jc hb bi translated">ISP是一个简单明了的原则，通过逐渐添加到客户端不需要的现有接口，可以轻松超越它。ISP还与其他坚实的原则密切相关。</p><p id="2803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多代码气味可以帮助我们识别和纠正ISP违规。然而，我们需要记住，任何原则的过分激进的实现都可能导致代码库中的其他问题。</p><p id="5109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LSP教会了我们为什么现实不能被表现为与编程对象的一对一关系。以及子类别如何尊重它们的父母。让我们也考虑一下我们已经知道的其他原则。</p><p id="79fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ISP教会我们比我们想象的更尊重我们的客户。尊重他们的需求会让我们的代码更好，让我们程序员的生活更轻松。</p><p id="936c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读文章<strong class="ih hj"> ISP:接口隔离原则</strong>作为<strong class="ih hj">系统设计和架构</strong>中的重要组成部分。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="e093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mq">原载于2021年4月4日https://onloadcode.com</em><a class="ae jd" href="https://onloadcode.com/interface-segregation-principle/" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a><em class="mq">。</em></p></div></div>    
</body>
</html>
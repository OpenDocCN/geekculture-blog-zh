<html>
<head>
<title>Concurrent Program Modelling-FSP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行程序建模-FSP</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/concurrent-program-modelling-fsp-7a530d3dcbb?source=collection_archive---------3-----------------------#2021-01-19">https://medium.com/geekculture/concurrent-program-modelling-fsp-7a530d3dcbb?source=collection_archive---------3-----------------------#2021-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="157b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用<em class="ix">有限状态进程(FSP)——</em>对简单并发程序建模的初始步骤一个自动售货机的例子</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/6b13b3c0f118d7dfc772e7d89f549d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZcjTKwZmJgturFkKANpJg.jpeg"/></div></div></figure><p id="6152" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">嗨，我是拉莎拉。这篇文章是关于并发编程建模背后的基本概念，以及我们应该知道的开始的初始步骤。</p><h1 id="14e0" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">这几乎是一个并行的世界…</h1><p id="98ad" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">并发程序由一组子程序组成。当并发程序执行时，每个单独的子程序都由一个单独的进程执行。这些进程通常同时执行。因此，并发程序的执行由同时执行的多个进程组成。</p><p id="0482" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果我们举一个真实世界的例子，它们都有一组简单的活动或任务。例如，房屋建筑的执行包括许多子任务，如布线、盖屋顶、木工、砌砖、管道，以及制作5个茶杯，每个茶杯都有两个糖勺。一些过程严格地按顺序发生，但是大多数可以重叠并同时发生。所以，这就是为什么我们说<em class="ld">我们几乎处于一个并行的世界。</em></p><h1 id="7ac4" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">为什么我们需要建模方法来开发并发程序？</h1><p id="65b4" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">就以下几点而言，开发一个满足特定需求并以安全方式运行的并发程序是一个非常复杂的过程。</p><ul class=""><li id="721b" class="le lf hi jm b jn jo jq jr jt lg jx lh kb li kf lj lk ll lm bi translated">测试这样的软件是困难的，有太多的场景。</li><li id="67b4" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">不知道我们什么时候做了足够多的测试。</li><li id="ad0c" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">测试非常困难，因为它依赖于执行特定的事件序列&amp;导致问题的动作。</li><li id="0f34" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">因为并发事件可能以任何顺序发生，或者可能不总是发生，所以问题序列可能永远不会被测试。</li></ul><p id="5e7f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">所以，<strong class="jm hj">方案</strong>需要一种更好的方法来设计、检查&amp;构造并发程序。这就是<strong class="jm hj">建模方法</strong>发挥作用的地方。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es ls"><img src="../Images/0e2920ef21bfa73d1b267da3336abbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHB5fJHQvFe1bbSPfAH-aw.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 1: Test pass rate probability of Concurrent programs with &amp; without Modelling</figcaption></figure><h1 id="ce52" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">建模并发系统</h1><p id="efe5" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">正如我们已经看到的<em class="ld">模型</em>是对<em class="ld"/>某物<em class="ld"/>的简化表示。但是在我们的例子中，我们想要建模的“某物”是一个<em class="ld">并发系统</em>。</p><p id="ade0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，我们的模型必须包括以下内容的简化表示:</p><ul class=""><li id="f459" class="le lf hi jm b jn jo jq jr jt lg jx lh kb li kf lj lk ll lm bi translated">一个独立的过程，</li><li id="c330" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">并发程序(并发执行的进程的集合)，</li><li id="7565" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">流程集合之间的交互<em class="ld"> </em>，</li><li id="2cf1" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">进程&amp;并发系统的动态行为和属性<em class="ld"> </em>。</li></ul><p id="5c4e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果我们的型号<strong class="jm hj">没有</strong>具备这些特征，那么它就不是<strong class="jm hj"/>！</p><h1 id="a7a6" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">什么是FSP？</h1><p id="153c" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">有限状态流程(FSP)是一种抽象语言，用于通过建模方法开发并发流程系统。以下几个方面正在实现上述对并发编程的需求。</p><p id="0f93" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">1.<strong class="jm hj">设计</strong>一个并发系统</p><p id="99b2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">2.<strong class="jm hj">型号</strong>设计系统</p><p id="236c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">3.<strong class="jm hj">分析</strong>建模系统</p><p id="2a97" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">稍后让我们逐一研究一下与此相关的一个简单场景。</p><h1 id="c2fb" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">概括地说，FSP、密克罗尼西亚、LTS和LTSA</h1><ul class=""><li id="4b4f" class="le lf hi jm b jn ky jq kz jt lx jx ly kb lz kf lj lk ll lm bi translated">并发系统是抽象进程的集合。</li><li id="6fa7" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">这些抽象过程可以用<strong class="jm hj"> FSP </strong>语言来定义。</li><li id="6446" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">由<strong class="jm hj">有限状态机(FSM)表示或建模的FSP过程。</strong></li><li id="d8e9" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">FSM模型抽象出了真实程序的细节。FSM由一个<strong class="jm hj">标记的过渡系统(LTS)实现。</strong></li><li id="f6ec" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">每个FSP过程都有相应的FMS/LTS描述。</li><li id="bf49" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated"><strong class="jm hj"> LTS分析器(LTSA) </strong>是FSP的建模工具，用于动画制作和分析。</li></ul><p id="20a8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在，让我们试着用一个简单的例子来理解这些概念，一台售货机。在此之前，您需要设置一个LTSA工具来制作动画和分析场景。</p><h2 id="b2be" class="ma kh hi bd ki mb mc md km me mf mg kq jt mh mi ks jx mj mk ku kb ml mm kw mn bi translated">LTSA工具的使用</h2><p id="2a1d" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">以下是ltsa工具的基本组件。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mo"><img src="../Images/789ff3ed5ddcbfca7dba72d302a905a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F9-mXCuPN0w-64XUh79TQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 2: Basic components of ltsa tool</figcaption></figure><p id="711a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">但是，如果您在ltsa中没有看到字母、过渡和绘图窗口，请按如下步骤进入窗口选项卡，并逐个添加它们。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mp"><img src="../Images/4e0d48d7c501edda693a63a4334129e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otJ6mV-DRjuB1kBXpUjG2w.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 3: Windows tab in ltsa tool</figcaption></figure><p id="000e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在，一切都准备好了，可以试用一个简单的并发系统。🙃</p><h1 id="fd85" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">一台自动售货机</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mu"><img src="../Images/3981a60154de00136c38ccd0a240dd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*NRx1Yp66tgChaU3nfbjwIw.jpeg"/></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 4: Vender machine</figcaption></figure><p id="221a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">使用一个例子将使解释概念和模型变得更容易。让我们分析并模拟一个FSP过程，它描述了饮料分配机，</p><ul class=""><li id="c531" class="le lf hi jm b jn jo jq jr jt lg jx lh kb li kf lj lk ll lm bi translated">热<strong class="jm hj">咖啡</strong>如果按下<strong class="jm hj">红色</strong>按钮&amp;</li><li id="2666" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">如果按下<strong class="jm hj">蓝色</strong>按钮，冰镇<strong class="jm hj">茶</strong>。</li></ul><h2 id="67c8" class="ma kh hi bd ki mb mc md km me mf mg kq jt mh mi ks jx mj mk ku kb ml mm kw mn bi translated">首先，让我们设计系统...</h2><p id="420a" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">作为第一步，我们需要了解所需的需求并设计系统。在这种情况下，需要考虑流程及其动作、同步要求以及流程之间的交互。</p><p id="c5ec" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">根据给定的场景，</p><ul class=""><li id="5d53" class="le lf hi jm b jn jo jq jr jt lg jx lh kb li kf lj lk ll lm bi translated">我们应该设计一个有茶和咖啡两种选择的通用流程。它们的动作应该分别是茶的<strong class="jm hj">红色</strong>和咖啡的<strong class="jm hj">蓝色</strong>。</li><li id="6b51" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">然后我们需要设计<code class="du mq mr ms mt b">COFFEE_CUSTOMER</code>和<code class="du mq mr ms mt b">TEA_CUSTOMER </code>两个单独的客户流程，谁将使用这台机器。</li><li id="e9e3" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">随后，应该定义复合执行，即<code class="du mq mr ms mt b">VendingSystem</code>，以及同步需求。</li></ul><h2 id="f5d0" class="ma kh hi bd ki mb mc md km me mf mg kq jt mh mi ks jx mj mk ku kb ml mm kw mn bi translated">接下来是为<strong class="ak">型号</strong>设计的系统…</h2><p id="ee35" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">以下是给定场景的设计模型，这应该使用FSP语言的有限状态机建模。这应该添加到LTSA的编辑窗口。</p><pre class="iz ja jb jc fd mv mt mw mx aw my bi"><span id="7da6" class="ma kh hi mt b fi mz na l nb nc">set VMOptions = { red, coffee, blue, tea }<br/><br/>set Customers = { cc, tc }<br/><br/>DRINKS = (   red -&gt;  coffee -&gt; DRINKS<br/>           | blue -&gt; tea -&gt;    DRINKS ) .<br/><br/><br/>COFFEE_CUSTOMER = ( choose_coffee -&gt; red -&gt; coffee <br/>                 -&gt; pickup_coffee -&gt; drink_coffee -&gt; COFFEE_CUSTOMER <br/>		   ) +VMOptions.<br/><br/>TEA_CUSTOMER = ( choose_tea -&gt; blue -&gt; tea <br/>                 -&gt; pickup_tea -&gt; drink_tea -&gt; TEA_CUSTOMER <br/>		   ) +VMOptions.<br/><br/><br/>|| VendingSystem = (    Customers :: DRINKS || cc: COFFEE_CUSTOMER || tc: TEA_CUSTOMER ) .</span></pre><p id="cd22" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这将允许一个用户获取资源，另一个用户释放资源。因此，当<code class="du mq mr ms mt b">DRINKS</code>由<code class="du mq mr ms mt b">USER</code>进程组成时，这种组成确保了只有获得资源的同一用户才能释放它。现在将测试系统，以检查需求是否与设计的模型兼容。</p><h2 id="6402" class="ma kh hi bd ki mb mc md km me mf mg kq jt mh mi ks jx mj mk ku kb ml mm kw mn bi translated">最后，分析建模系统的时间…</h2><p id="1ac7" class="pw-post-body-paragraph jk jl hi jm b jn ky ij jp jq kz im js jt la jv jw jx lb jz ka kb lc kd ke kf hb bi translated">在制作动画之前，你必须编译你写的代码，然后你必须导航到<strong class="jm hj"> draw </strong>标签。它向您展示了所有单个和复合流程的图形表示。</p><p id="0a3d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">图形表示</strong></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nd"><img src="../Images/4560e39c2f0548d3307673c8479d8f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjG_wnjBIow-D0y-lwwRUA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 5: graphical representation of processes</figcaption></figure><p id="f9ca" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">然后你必须制作动画，并通过检查来分析代码，</p><ul class=""><li id="58ed" class="le lf hi jm b jn jo jq jr jt lg jx lh kb li kf lj lk ll lm bi translated">系统的<strong class="jm hj">字母</strong> <em class="ld"> </em>正确，</li><li id="36f1" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">系统执行正确的，是<strong class="jm hj">动作</strong>和<strong class="jm hj">转换。</strong></li><li id="837a" class="le lf hi jm b jn ln jq lo jt lp jx lq kb lr kf lj lk ll lm bi translated">是否避免<strong class="jm hj">死锁</strong> <em class="ld"> </em> &amp;维护<strong class="jm hj">互斥</strong>。</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ne"><img src="../Images/be178bb8364989906885cf3689a3cebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*OnGYuW4DFyW4-KAlVPa5WQ.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx">Figure 6: Animator of ltsa tool</figcaption></figure><p id="2f45" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">通过所有这些，您可以对将要开发的系统有一个适当的概念，并且您还知道在开发之前有死锁和其他并发问题的能力。</p><p id="babb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，这种建模概念确实是并发编程的基本需求。</p><p id="185f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我希望这对你的并发编程学习有所帮助。干杯。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Add Dependency Injection to a React/Typescript project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向React/Typescript项目添加依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/add-dependency-injection-to-a-react-typescript-project-fbc34110d4d6?source=collection_archive---------9-----------------------#2021-09-15">https://medium.com/geekculture/add-dependency-injection-to-a-react-typescript-project-fbc34110d4d6?source=collection_archive---------9-----------------------#2021-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77a655bea242ceeec51f962a235c9b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-tnkii1AZGyxzuFd"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3141" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我成为专业开发人员已经有一段时间了，主要从事后端开发并使用。NET框架的大部分时间。这是我开始修补的地方，也是我获得军衔的地方。几年前微软发布了。NET Core，一个与以往不可思议的轻薄对应物。NET完整框架。它只包含运行一个程序的基本必需品，并把包含必需的软件包留给了软件的作者。用软件写的。NET Core也可以在任何操作系统上运行，您不必再受限于Windows来运行您的。NET应用程序。这些都是非常酷的东西，但我最喜欢的是包含了依赖注入，这是控制反转的一个实际应用，在这里你让框架为你管理你的依赖(服务，存储等)。).你不再需要在你的软件中“新建”一个类的实例，取而代之的是，你向DI容器注册了这个依赖关系，只要框架发现需要这个依赖关系，它就会为你注入这个依赖关系。</p><p id="1061" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些年来，我越来越喜欢这一点，因为它将您的实现逻辑从您的依赖项中分离出来，使得独立于它们可能具有的依赖项来测试您的代码变得更加容易，因为您可以非常容易地注册一个模拟依赖项。只需修改一行代码就可以切换出一个依赖项，这样就万事大吉了。你根本不用碰你的应用逻辑！不用说，当我开始为一家公司工作时，我错过了这一点，我的任务之一是在React/TypeScript中从头创建一个新的前端。所以我决定自己融入一些这种行为，并与你分享我是如何做到的。令人惊讶的是，它只需要很少的代码就能运行起来！</p><h2 id="d52c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">服务定位器</h2><p id="54e2" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我的前端需要的依赖项是所有服务，它们遵循一个接口并执行对我的一个或多个React组件有用的特定任务。我想把从这些组件获取服务实例的责任拿走，只使用一个定制的React钩子来请求他们需要的服务，基于一个抽象。所以我创建了一个服务定位器来处理这个问题以及注册依赖关系。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/6c73dc74f3028696f5213450c2558b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCVvPtpC3Pp9ATyJi_yRzQ.png"/></div></div></figure><p id="2478" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们先浏览一下<strong class="ix hj"> ServiceLocator </strong>类。这是一个非常小的类，只有一个属性和两个函数。我一会儿会谈到导入和<strong class="ix hj"> dependencyStore </strong>中的值，但是现在你需要知道的是，当组件请求它们的抽象时，这些是定位器将提供的实际服务。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/d6d95f335d09bc6f335ee3b775f4d81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOH1BuRV9Wfwlr_UczEfDQ.png"/></div></div></figure><p id="5f6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">鉴于TypeScript实际上只是一堆编译成JavaScript的语法糖，一旦代码编译完成，就没有真正的接口或类型，所以需要一些技巧来注册一个服务，以便可以通过它的接口找到它。这个<strong class="ix hj"> serviceMap </strong>基本上将抽象名称映射到类的名称，当请求抽象时，应该实例化并返回该类。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/c2c8a3b02902ab00e67dd17e4c61e262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9D9-cGkAoZzu517yVNokQ.png"/></div></div></figure><p id="06bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个简单的函数，只是向<strong class="ix hj"> serviceMap </strong>添加一个条目，将抽象映射到实现。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/dc13ef8abdd2079b1d1c05e77fec5081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ClOHr1GIqPHSqA2iof7LQ.png"/></div></div></figure><p id="5e1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是奇迹发生的地方。<strong class="ix hj"> resolve </strong>函数将一个泛型类型参数(请求的抽象类型)和这个抽象的字符串表示作为参数。从我们的<strong class="ix hj"> serviceMap </strong>中获取实现名称需要字符串版本。如你所见，我首先检查了<strong class="ix hj"> serviceMap </strong>是否列出了给定的抽象。如果是的话，我获取实现名并将其存储在<strong class="ix hj">类型的</strong>变量中。再检查一下，看看<strong class="ix hj"> dependencyStore </strong>中是否有这个名称的依赖项，如果有，我动态地创建该类的一个实例并返回它，将它转换成作为参数提供的抽象。</p><p id="643e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我答应过要回到<strong class="ix hj">依赖商店</strong>。这里列出的类来自我的rest-api.ts:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/cf389c2e080fd6745d7453deb5993624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fMom0AxRXycCvEIxuWiBA.png"/></div></div></figure><p id="1b7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它包含了两个实现相同接口的类，相同的抽象:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/53ff717ef4ac9b8b72b91ddd0cebbe5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4cDebbMI4j_nW24ZLaKAg.png"/></div></div></figure><p id="c3f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们的服务定位器已经处理好了，让我们转到React的上下文API，并使用上下文钩子使这个定位器对我们所有的组件可用。</p><h2 id="3b12" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">解耦器提供商</h2><p id="beac" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了确保我的React应用程序中的所有组件都可以访问定位器，我将把我的整个应用程序包装在一个DecouplerProvider元素中，我称之为这个元素，因为它将我的应用程序与其依赖项分离，并充当它的上下文提供者，上下文就是定位器。这是我的<strong class="ix hj">解耦器提供商。tsx </strong>:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/5b6d29a1034fbc0041973f4f54f5e7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGYZLfkz1sJjV4QD3K9N0w.png"/></div></div></figure><p id="78b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样没有很多代码。让我们看一看，并浏览一下那里有什么。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/cb905ba371229efc81c230d83fa6179d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juHljjz1Ejz8K_WUXFQ22g.png"/></div></div></figure><p id="05da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用React的<strong class="ix hj"> createContext() </strong>方法来创建上下文。我们需要它作为钩子和我们将要返回的元素。正如您所看到的，我显式地添加了ServiceLocator类型，因为我真的喜欢在输入时显式。这就是为什么我首先喜欢TypeScript。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/871d5252e9e1680393a46dc349f94da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*maRj7RWsR_FkcAEMJSKKHQ.png"/></div></figure><p id="ee3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们提供给组件的React钩子。稍后，您将看到任何组件请求依赖项是多么容易。这个<strong class="ix hj"> useService </strong>钩子接受一个泛型类型参数，使用<strong class="ix hj"> useContext </strong>钩子和<strong class="ix hj"> DecouplerContext </strong>来获取我们全局可用的定位器，并使用提供的类型调用它的resolve方法。然后，它将实例返回给调用者，非常简单。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/4069cfaf669f663c4b357298a5009976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*s6iV6dLHmNw774WRUsJoZA.png"/></div></figure><p id="ba33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是您的标准功能反应组件。我非常喜欢结合React钩子的功能组件方法。这里唯一特别的是我为道具创建的显式接口，以及我返回的元素。我们之前创建的<strong class="ix hj"> DecouplerContext </strong>有一个<strong class="ix hj"> Provider </strong>属性，我们可以用它来创建一个元素。它接受一个值，该值必须是我们在创建上下文时提供的类型的实例，在本例中是一个<strong class="ix hj"> ServiceLocator </strong>。</p><p id="482e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们的解耦器！现在让我们把所有东西绑在一起。</p><h2 id="c972" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">布线</h2><p id="c251" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">现在我们已经有了注册和解析依赖项所需的东西，让我们看看如何使用它们。首先，我们的<strong class="ix hj"> App.tsx </strong>:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/91aa4ff8eb86a82c8b302741bf8d1473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2bruYkpDM58inh7aVaO6w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">There are more imports above this, but those were omitted for brevity</figcaption></figure><p id="b7b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有两件事要注意，所以你知道该怎么做。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es li"><img src="../Images/e22fa8ab36b293711ad4c5e831f2b366.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*5_lK5B0QtcXL0svtl_QszQ.png"/></div></figure><p id="632d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在初始化我们的应用程序之前，我们创建了一个<strong class="ix hj"> ServiceLocator </strong>并注册了一个依赖项。我的公司有一个名为<strong class="ix hj"> RestAPI </strong>的服务，但是在我实际去和后端通信之前，我想测试一下我的前端是否可以正确地处理这些调用和它们的返回值。所以现在我注册了我的<strong class="ix hj"> RestApiFromMockData </strong>，它只是以我的前端所期望的形式发回一些本地数据。因为我们在这里必须使用字符串，所以我在抽象中使用了一个常量，因为我将在多个地方使用这个相同的值，而在代码库中散布神奇的字符串是你不想做的事情。我在一个<strong class="ix hj"> constants.ts </strong>文件中定义了它:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/618523873de8bfce078815140230eed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*Atzg-396lmPGtT6sYFDlFQ.png"/></div></figure><p id="5587" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个字符串是依赖项的名称，在本例中是<strong class="ix hj"> RestApiFromMockData </strong>类。我使用name属性，因为这将确保我总是得到正确的拼写，并且它应该总是完美地映射到我们前面看到的<strong class="ix hj"> dependencyStore </strong>中的同一个类。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/37bcfad3b256ea1bddbe13bc7c827c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKcERAb9u3Mbh-lHE_puOg.png"/></div></div></figure><p id="4ebb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们只需将应用程序返回的内容包装在我们创建的<strong class="ix hj"> DecouplerProvider </strong>组件中，并将定位器传递给它。以上是对<strong class="ix hj"> App.tsx </strong>的介绍，现在让我们转到一个想要获得依赖关系的组件，在我的例子中是<strong class="ix hj"> step-1-email.tsx </strong>，我想要在有人提供电子邮件地址时创建一个非活动用户:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/e2a2db8a9ef6e5719a258b8eab0ea1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*rX1UALlCZSUvkBcj2St2ww.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Rest of the code omitted for brevity</figcaption></figure><p id="c4a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用之前定义的<strong class="ix hj"> useService </strong>钩子，以及抽象类型(<strong class="ix hj"> IRestApi </strong>)和抽象名称(<strong class="ix hj"> RestApi </strong>常量)来获取我们注册的依赖项。在<strong class="ix hj"> onButtonClick </strong>方法中，我们使用我们获得的依赖来执行在<strong class="ix hj"> IRestApi </strong>接口上定义的动作。这就是这个组件应该感兴趣的:抽象，而不是实现。这种逻辑和依赖的解耦使生活变得更加容易。想象一下，如果我们在任何需要的地方都创建一个RestApiFromMockData对象，并且在本地测试之后，你现在想要与你后端的RestApi进行通信。你必须检查每一个组件，将<strong class="ix hj"> RestApiFromMockData </strong>改为<strong class="ix hj">restapifrombend</strong>。使用这种服务定位器方法，这变得像更改一样简单</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/69389a20fcd87ce74bfbcf86851ab90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*CU2xJhLVFu-8gBMVJPUX0w.png"/></div></figure><p id="702f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/43a537452c0b625b2276f0309c430ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*5FwMNwOtKqZfDoEU2aLXlA.png"/></div></figure><p id="7617" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样了。您的应用程序保持不变，但是所有需要一个<strong class="ix hj"> IRestApi </strong>的组件现在将接收一个<strong class="ix hj"> RestApiFromBackend </strong>的实例并继续工作。</p><h2 id="1a48" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">包裹</h2><p id="27c0" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当涉及到依赖管理时，依赖注入是一个很大的帮助，这就是我如何在React/TypeScript中实现它的。我绝不是打字专家，我想有相当多的人是打字专家。对于那些我想问的人，请评论我在这里的方法中可以做得更好的任何事情，或者从类型脚本的角度来看，是否有更聪明的方法来实现这一点。例如，我想在不添加太多代码的情况下，为<strong class="ix hj"> dependencyStore </strong>去掉<strong class="ix hj"> any </strong>类型。</p><p id="2add" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论如何，感谢你的阅读，我希望这能帮到你！</p></div></div>    
</body>
</html>
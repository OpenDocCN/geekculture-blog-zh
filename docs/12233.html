<html>
<head>
<title>Beginners guide to Docker and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和Kubernetes初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-i-introduction-e9904fbc27ac?source=collection_archive---------2-----------------------#2022-05-03">https://medium.com/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-i-introduction-e9904fbc27ac?source=collection_archive---------2-----------------------#2022-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/116cf53f23a317834939aabca2686693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v7BNkz3kcPkvJjc4"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Towfiqu barbhuiya</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ce46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之前我们已经用AWS CodeDeploy、GitHub Actions和AWS Auto Scaling Groups (ASG)解决了CI/CD和伸缩的问题。只要有几项服务需要管理，这种方法就能很好地工作，随着服务的增长，服务器也会增长，管理大量的ASG需要更好的协调，而不是每次需要为用户添加新服务时简单地创建一个新的ASG。</p><p id="16b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始之前，我建议你访问我之前的博客，在这里看看我们是如何解决扩展问题的<a class="ae iu" href="https://ansukumari.medium.com/auto-deploy-and-auto-scale-servers-using-aws-codedeploy-and-github-actions-cb85edb3da4e" rel="noopener">，这样你就可以比较发生了什么变化以及原因。</a></p><p id="211f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，我们将实例放在ASG后面，以便在流量激增的情况下自动扩展，然后我们在GitHub Actions工作流中运行AWS CodeDeploy，以将GitHub上推送的代码自动部署到ASG后面的所有实例。</p><p id="c424" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着时间的推移，我们不断添加新的服务，因此每个服务都有新的ASG，不同类型的实例在每个ASG中运行不同的代码。我们现在有50多个助理秘书长，管理这些助理秘书长是一项艰巨的任务。</p><h2 id="f50e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">进入KUBERNETES..</h2><p id="c43a" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了理解我们是如何设置Kubernetes的，我们需要理解它所基于的组件。我将在下面对每一个进行简单的解释，如果你已经知道这些组件是如何工作的，可以随意跳到<a class="ae iu" rel="noopener" href="/geekculture/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-ii-implementation-46c628124e94">第二部分</a>，在那里我将通过代码示例讲述我们如何使用这些组件来解决上述问题。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="b4b1" class="la ju hi bd jv lb lc ld jz le lf lg kd lh li lj kg lk ll lm kj ln lo lp km lq bi translated">Docker、docker图像和容器</h1><p id="f279" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Docker只是一种容器化应用程序的方式。当你在本地机器上编写应用程序时，你可以将代码传输到互联网上，让其他人使用，但这并不能保证它在你的机器上就能完全正常工作，甚至根本不能工作。这是因为您的应用程序可能有依赖关系，如模块、框架、数据库等，这在其他用户的机器上可能不会得到满足。</p><p id="77ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们可以将您的应用程序放在一个容器中，该容器不仅包含您的代码，还包含它的所有依赖项以及所有模块的指定版本。这叫做<strong class="ix hj">集装箱化</strong>。如果我们使用docker容器，它被称为<strong class="ix hj">docker化</strong>。</p><p id="cd3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了对你的应用程序进行dockerize，你需要在你的库中添加一个名为<strong class="ix hj"> Dockerfile的文件(</strong>这个文件不能被命名为其他任何名称，D应该是大写的，其余的应该是小写的，没有任何扩展名<strong class="ix hj"> ) </strong>，当它运行时，会为你的应用程序构建一个可共享的映像。这个映像可以被推送到网上的注册表中，并与任何人共享，以便在他们的系统中的容器中运行。下面是一个节点应用程序的示例<strong class="ix hj"> Dockerfile </strong>。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="097d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="ix hj">容器</strong>是一个轻量级环境，它将你的应用程序与系统中的其他应用程序分开。从概念上讲，它类似于虚拟机，但与虚拟机不同的是，它没有位于机器操作系统之上的来宾操作系统，因此更加轻量级和易于管理。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/d5fb5aca3ac41aa0af9c128d985006de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hezOFEFv08IkqkQLlqvqYg.png"/></div></div></figure></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="635e" class="la ju hi bd jv lb lc ld jz le lf lg kd lh li lj kg lk ll lm kj ln lo lp km lq bi translated">如何在Docker上运行应用程序</h1><p id="0d62" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Docker有一些运行应用程序所需的组件/对象，下面是与它们相关的常用命令:</p><h2 id="41ab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">a.图像—</h2><p id="faca" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">图像是打包在文件中的应用程序的模板，当执行该模板时，将运行应用程序。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/13069641b2b0679f4eb46cb20953f405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*pIOhRXLedob9f6oKTcSJHg.jpeg"/></div></figure><p id="a940" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker run &lt;image_id/image_name&gt;</code>:你可以使用这个命令来创建你的图像的一个运行实例。如果映像存在于您的本地，docker将使用它，否则它将在执行相同的命令时从DockerHub注册表中提取映像。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/5e5cc7e8fb8dd2b240508f8f9575436c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmVLp4Udi0Q6-WlcRBrdbA.png"/></div></div></figure><p id="91a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker images</code>:使用该命令列出本地机器中存在的所有图像。</p><p id="b142" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker rmi &lt;image_id/image_name&gt;</code>:从本地删除一张图片。</p><h2 id="b002" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">b.容器—</h2><p id="ea0c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">容器就是在Docker中运行的所有独立的应用程序。</p><p id="9ab7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker ps</code>:列出当前正在运行的所有容器。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/8e09011dd9f6ab1e08b108f688dc05c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXvAYkHlew2XA4-Qd_RiUA.png"/></div></div></figure><p id="5d0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker ps --all</code>:列出各种状态下的所有集装箱，即正在运行、已退出、已完成等。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/fcee3370ebf1e2fce07a2060953486d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8yuefwXgIbIWqMJDRlSdg.png"/></div></div></figure><p id="fbf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker container start/stop/kill &lt;container_id/container_name&gt;</code>:启动已列出但当前未运行的容器，停止正在运行的容器，终止容器而不允许进程分别完成。</p><p id="d060" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="mf">注意</em> </strong> <em class="mf">:当写容器或图像id时你不必写完整的hash，只需使用唯一的首字母即可。</em></p><p id="5304" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker exec -it &lt;container_id/container_name&gt; bash</code>:进入你的容器应用。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/b73369a4d13f8b7dce7a3865ba8cae79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6pvBAIEl4JKIclbng8SKA.png"/></div></div></figure><p id="44dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ docker rm &lt;container_id/container_name&gt;</code>:删除容器。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/5a7cf8567f05b951d99b4cf52a252027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFizDcz7bnlN7YMTqWGi9w.png"/></div></div></figure></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="76c3" class="la ju hi bd jv lb lc ld jz le lf lg kd lh li lj kg lk ll lm kj ln lo lp km lq bi translated">库伯内特斯</h1><p id="84c0" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">AKA k8s，我找到的了解k8s的最好资源是官方手把手教程，这里的<a class="ae iu" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener ugc nofollow" target="_blank">是它的链接。在这篇博客中，我将简要介绍k8s和它的对象，我们需要熟悉它们，了解我们的系统，在k8s上设置和使用我们的infra。</a></p><p id="77f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes是一种管理所有容器及其相关图像和其他资源的方法。</p><blockquote class="mg mh mi"><p id="d1e0" class="iv iw mf ix b iy iz ja jb jc jd je jf mj jh ji jj mk jl jm jn ml jp jq jr js hb bi translated">Kubernetes为您提供了一个灵活运行分布式系统的框架。它负责应用程序的伸缩和故障转移，提供部署模式等等。例如，Kubernetes可以轻松地为您的系统管理canary部署。</p></blockquote><h2 id="88cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">库伯内特星团</h2><p id="204e" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">k8s集群是一个生态系统，由<strong class="ix hj">高度可用的计算机集群组成，这些计算机作为一个单元</strong>连接在一起，运行您的应用程序和绑定您的应用程序的服务。</p><p id="bb37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是查看和切换集群/上下文的一些命令:</p><p id="7658" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl config get-clusters</code>:列出您系统中配置的所有集群</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/07e08e944677f2664b0063f7f9cfdb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hd1MKD11RIREAnK5ScwJLA.png"/></div></div></figure><p id="a86d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl config get-contexts</code>:列出您系统中配置的所有上下文。具有经过身份验证的用户的集群形成一个上下文。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/8a3784adfaa4f597545e5ebf3b178428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbbqUx4K5lT6eQ0rEJ-2Aw.png"/></div></div></figure><p id="c685" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl config current-context</code>:要检查您当前正在哪个上下文中工作，您所做的任何更改都将应用到该上下文中。</p><p id="ab74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl config use-context &lt;context_name&gt;</code>:切换上下文。</p><h2 id="0d5f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结节</h2><p id="32db" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">它是运行您的应用程序的底层物理或虚拟机。一堆这样的节点组成了k8s集群。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/fd182a2bb0e3e4f3a5f1bc7b97581cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oSJoLH3hY--IKXem3ZqLQ.png"/></div></div></figure><h2 id="d89d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">豆荚</h2><p id="3c9c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">pod是运行容器化应用程序的抽象概念。理想情况下，一个pod只运行一个容器，尽管您可以指定k8s在一个pod中运行多个容器，但是只推荐用于非常紧密耦合的应用程序。多个单元在一个节点上运行。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/a5bc02af810446e5f96d775218d9d766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lixji6vxS0DIFa1q7gpUUQ.png"/></div></div></figure><p id="9f1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="mf">使用pod时需要了解的常用命令:</em> </strong></p><p id="62ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl get po</code>:列出当前上下文中默认名称空间中的所有窗格。</p><p id="8b8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl exec -it &lt;pod_name&gt; -- bash</code>:进入吊舱内部</p><p id="08cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl logs -f &lt;pod_name&gt;</code>:获取pod的控制台日志</p><h2 id="f41e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">部署</h2><p id="5acd" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">k8s部署是以yaml格式编写的k8s对象之一，包含应用程序pod管理的所有规范，例如，应用程序应该具有的副本数量、应用程序pod应该使用的图像、需要在pod容器中设置的任何环境变量等。下面是一个示例部署文件。</p><pre class="lr ls lt lu fd mq mc mr ms aw mt bi"><span id="11bd" class="jt ju hi mc b fi mu mv l mw mx"><strong class="mc hj">apiVersion</strong>: apps/v1<br/><strong class="mc hj">kind</strong>: Deployment<br/><strong class="mc hj">metadata</strong>:<br/>  <strong class="mc hj">name</strong>: nginx-deployment<br/>  <strong class="mc hj">labels</strong>:<br/>    <strong class="mc hj">app</strong>: nginx<br/><strong class="mc hj">spec</strong>:<br/>  <strong class="mc hj">replicas</strong>: 3<br/>  <strong class="mc hj">selector</strong>:<br/>    <strong class="mc hj">matchLabels</strong>:<br/>      <strong class="mc hj">app</strong>: nginx<br/>  <strong class="mc hj">template</strong>:<br/>    <strong class="mc hj">metadata</strong>:<br/>      <strong class="mc hj">labels</strong>:<br/>        <strong class="mc hj">app</strong>: nginx<br/>    <strong class="mc hj">spec</strong>:<br/>      <strong class="mc hj">containers</strong>:<br/>      - <strong class="mc hj">name</strong>: nginx<br/>        <strong class="mc hj">image</strong>: nginx:1.14.2<br/>        <strong class="mc hj">ports</strong>:<br/>        - <strong class="mc hj">containerPort</strong>: 80</span></pre><p id="2426" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用<code class="du lz ma mb mc b">kubectl create</code>命令在命令中创建一个默认的部署提供映像，或者编写一个<em class="mf">类</em>部署的yaml文件，如上所示，然后运行<code class="du lz ma mb mc b">kubectl apply</code>命令来创建该部署。</p><p id="27c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建默认部署，请运行以下命令:</p><pre class="lr ls lt lu fd mq mc mr ms aw mt bi"><span id="5472" class="jt ju hi mc b fi mu mv l mw mx">$ kubectl create deployment &lt;deployment_name&gt; --image=&lt;image_name/image_id&gt;</span><span id="b0ca" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">Eg: </strong><br/>kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</span></pre><p id="1cc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用上述部署文件创建部署，请运行以下命令:</p><pre class="lr ls lt lu fd mq mc mr ms aw mt bi"><span id="497c" class="jt ju hi mc b fi mu mv l mw mx">$ kubectl apply -f &lt;path_to_deployment_yaml_file&gt;</span><span id="5efc" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">Eg:</strong><br/>kubectl apply -f <a class="ae iu" href="https://k8s.io/examples/controllers/nginx-deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://k8s.io/examples/controllers/nginx-deployment.yaml</a></span></pre><p id="8c3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">部署</strong>是使用最多的对象之一，详细了解可以参考<a class="ae iu" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">这个</a>官方文档。</p><h2 id="e00a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">进入</h2><p id="0e4c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">k8s ingress是一个允许集群外部的用户访问您的应用程序和服务的对象。它主要通过HTTP/HTTPS提供路由规则，也充当负载平衡器。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/ca9a6f2590407c0526ed3b23e7fa4ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfZ0lku-b0t-Xa3UIiW1Jg.png"/></div></div></figure><p id="575e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个示例入口yaml文件。</p><pre class="lr ls lt lu fd mq mc mr ms aw mt bi"><span id="432b" class="jt ju hi mc b fi mu mv l mw mx"><strong class="mc hj">apiVersion</strong>: networking.k8s.io/v1<br/><strong class="mc hj">kind</strong>: Ingress<br/><strong class="mc hj">metadata</strong>:<br/>  <strong class="mc hj">name</strong>: minimal-ingress<br/>  <strong class="mc hj">annotations</strong>:<br/>    <strong class="mc hj">nginx.ingress.kubernetes.io/rewrite-target</strong>: /<br/><strong class="mc hj">spec</strong>:<br/>  <strong class="mc hj">ingressClassName</strong>: nginx-example<br/>  <strong class="mc hj">rules</strong>:<br/>  - <strong class="mc hj">http</strong>:<br/>      <strong class="mc hj">paths</strong>:<br/>      - <strong class="mc hj">path</strong>: /testpath<br/>        <strong class="mc hj">pathType</strong>: Prefix<br/>        <strong class="mc hj">backend</strong>:<br/>          <strong class="mc hj">service</strong>:<br/>            <strong class="mc hj">name</strong>: test<br/>            <strong class="mc hj">port</strong>:<br/>              <strong class="mc hj">number</strong>: 80</span></pre><p id="729b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用带有yaml文件路径的<code class="du lz ma mb mc b">kubectl create</code>命令或<code class="du lz ma mb mc b">kubectl apply</code>命令创建一个类似于部署文件的入口文件。</p><h2 id="41fa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">其他对象和常用命令</h2><p id="1963" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">k8s有许多对象，记住每个对象的命令是不可行的，因此它遵循一个在大多数情况下都有用的通用模式。</p><p id="f542" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="mf">k8s的一些天体有:</em> </strong></p><ul class=""><li id="2606" class="na nb hi ix b iy iz jc jd jg nc jk nd jo ne js nf ng nh ni bi translated">部署</li><li id="ebbf" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">分离舱</li><li id="24c1" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">服务</li><li id="f3ec" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">名称空间</li><li id="7742" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">进入</li><li id="4562" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">复制集</li><li id="bd4c" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">配置映射</li><li id="a2fe" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">达蒙塞特</li><li id="0e99" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">水平Pod自动缩放器(HPA)</li><li id="bfe6" class="na nb hi ix b iy nj jc nk jg nl jk nm jo nn js nf ng nh ni bi translated">等等</li></ul><p id="c1e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="mf">与上述对象一起使用的常用命令:</em> </strong></p><p id="431d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl get &lt;object_type&gt;</code>:列出同一类别的所有对象。例如，要列出所有正在运行的pod或查看当前上下文中的所有部署，您可以分别使用<code class="du lz ma mb mc b">kubectl get pods</code>或<code class="du lz ma mb mc b">kubectl get deployments</code>。</p><p id="1128" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数对象也有一个与command一起使用的简写，例如:</p><pre class="lr ls lt lu fd mq mc mr ms aw mt bi"><span id="dd53" class="jt ju hi mc b fi mu mv l mw mx"><strong class="mc hj">pods</strong>: kubectl get pods/po</span><span id="94d7" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">deployments</strong>: kubectl get deployments/deploy</span><span id="fae9" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">services</strong>: kubectl get services/svc</span><span id="6b61" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">namespaces</strong>: kubectl get namespaces/ns</span><span id="c9e0" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">HPA</strong>: kubectl get horizontalpodautoscaler/hpa</span><span id="d994" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">ConfigMaps</strong>: kubectl get configmaps/cm</span><span id="ef90" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">DaemonSets</strong>: kubectl get daemonsets/ds</span><span id="b852" class="jt ju hi mc b fi my mv l mw mx"><strong class="mc hj">Ingress</strong>: kubectl get ingress/ing</span></pre><p id="d5e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl edit &lt;object_type&gt; &lt;object_name&gt;</code>:要动态编辑任何对象，您可以使用该命令，这将在<code class="du lz ma mb mc b">vi</code>编辑器中打开yml文件，您可以使用<code class="du lz ma mb mc b">i</code>命令插入更改，使用<code class="du lz ma mb mc b">esc</code> + <code class="du lz ma mb mc b">:wq!</code>保存这些更改。</p><p id="265a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl describe &lt;object_type&gt; &lt;object_name&gt;</code>:获取对象的详细描述/配置。</p><p id="630d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl get &lt;object_type&gt; &lt;object_name&gt; -o yaml</code>:查看yaml文件形式的对象配置。</p><p id="3a76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ kubectl delete &lt;object_type&gt; &lt;object_name&gt;</code>:删除任何对象及其依赖关系。例如，如果您删除一个部署，该部署应该运行/创建的任何pod也将被删除。</p><p id="6e85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb mc b">$ &lt;any_of_above_command&gt; -n &lt;namespace_name&gt;</code>:默认情况下，如果您使用上述任何命令，它将仅对默认名称空间有效，要在不同的名称空间中使用该命令，您可以使用<code class="du lz ma mb mc b">-n</code>标志。比如说，<code class="du lz ma mb mc b">$ kubectl get po -n test</code>。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="abc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们对先决条件的介绍到此结束，现在让我们在下一部分讨论如何使用k8s解决最初的问题，链接<a class="ae iu" rel="noopener" href="/@ansukumari/setup-kubernetes-for-your-infra-and-add-ci-cd-using-github-actions-part-ii-implementation-46c628124e94">这里</a>。</p></div></div>    
</body>
</html>
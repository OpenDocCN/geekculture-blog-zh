<html>
<head>
<title>4-) Prototype Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4-)原型设计模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/4-prototype-design-pattern-cfbec82052fe?source=collection_archive---------48-----------------------#2021-08-03">https://medium.com/geekculture/4-prototype-design-pattern-cfbec82052fe?source=collection_archive---------48-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7dda805541b99f35de159182349594b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Khj7X47C2aIspm_yZS17TQ.png"/></div></div></figure><p id="7ce6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将解释第四个创造性的设计模式原型。在继续之前，我将讨论“栈-堆内存、值-引用类型、可变-不可变对象、浅-深复制”主题，以便更好地理解。</p><h1 id="cf3b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">堆栈存储器</h1><p id="977c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在开发应用程序时，内存是根据任何软件开发语言中使用的对象和变量来分配的。在运行时，在方法范围内创建的对象，连续存在。当到达方法末尾时，删除已创建的对象并释放内存。存储器变得可重复使用。</p><p id="c1c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更有效地使用，内存分为两部分。不同的变量类型以不同的类型存储在这些部分。</p><h1 id="5406" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">值引用类型</h1><p id="ddfb" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在点网络中有两种变量类型值引用。值类型派生自结构类型。bool、byte、char、decimal、double、enum、float、int、long、sbyte、short、struct、uint、ulong、ushort都是值类型的例子。当它们单独使用时，存储在堆栈存储器中。除了它们之外，枚举也存储在堆栈中。value1、value2、value3和value4存储在堆栈中，代码如下。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="1e56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从系统继承的类型。类、接口、委托、记录、动态、对象等对象是引用类型，存储在堆内存中。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="8569" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Int是一个值类型，但在这段代码中，它被用作类属性，并被转换为引用类型。为此，它存储在堆内存中。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/c0d75eb3a9059952f9ea6a27945d277b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*gYi4zb4R-f_Aemf2usGqkw.png"/></div></div></figure><p id="5d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当引用类型相互赋值时，堆栈内存中的指针变得不同，但堆内存中的值变得相同。如果改变其中一个值，就会影响另一个值。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="4994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了一个名为Numbers的类。在获得名为group1的实例后，我设置了值。我从名为group2的Number类中创建了一个新实例。我用“=”操作符将group2分配给group1。在这个阶段，堆栈内存中有两个不同的字段指向堆内存中的同一个值。当我更改组1的值时，这会影响组2。对象。Equals(group1，group2)方法返回true。另一方面，我创建了两个int值类型，并用“=”运算符互相赋值。然后我改变了第一个int值，但没有改变其他值。因为彼此存储在堆栈内存的不同字段中。Equals(a，b)返回false。我运行控制台应用程序。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/2ac0f9426f80e167de540130e5d37617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*yz1bT64AUnMjobzBP-jJhw.png"/></div></figure><h1 id="2a85" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">可变-不可变对象</h1><p id="0bd7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">可变的意思是可变的，不可变的意思是不可变的。当我们在一个不可变对象的字符串中做任何改变时，就变成了内存中新的分配。稍后GC会清除旧字段。如果使用了一个循环并在此循环中更改了字符串值，则创建的新字符串与循环中的条目数一样多。而是使用StringBuilder。StringBuilder允许改变字符串而不是新的内存分配。</p><p id="441f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建一个控制台应用程序，然后检查使用字符串更改和StringBuilder时的内存。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/806cb6b7fb8d5aef5e856eff599265f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFpQN6SzgFEJ8rHRYj19gg.png"/></div></div></figure><p id="afce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我使用了StringBuilder。调试应用程序时，诊断工具中显示内存使用量为8.6 Mb。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/b7184bc483d9206ad3231431b1f683ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJ1j6qGs6A_uSRV4CAbY6A.png"/></div></div></figure><p id="b062" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我注释了StringBuilder并运行了字符串更改。这一次看到了12 Mb的内存使用。此外，GC在1.2秒内工作了数千次。第一次编译器到达控制台。Writeline线在200毫秒内，但第二次是1000毫秒。性能差异显而易见。</p><p id="41a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类也可以被创建为不可变的对象</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/05aff2054ac9189ee565ebf39fe750c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkvZcoNVaXQ0M5kxHi9ryQ.png"/></div></div></figure><p id="8506" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Value仅在通过构造函数获取实例时设置NumberClass。之后，可以用GetNumber方法获取值。</p><h1 id="8350" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">浅-深拷贝</h1><p id="6f9a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当我们得到一个类的副本时，我们有两个选择，浅副本和深副本。仅浅复制类的值类型属性。如果有子对象，它们不会被复制，只会在堆栈中创建一个新地址，指向堆中对象的字段。深度复制对象包含创建的新实例的所有成员。我将在原型设计模式标题下给出一个例子。</p><h1 id="f600" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">原型设计模式</h1><p id="36a4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这种设计模式关注对象复制。</p><p id="d539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了BlogPost和Category类。BlogPost具有类型为值和引用的属性。有浅层和深层复制方法。我打印了用override ToString()方法筛选类属性值。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2d1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在控制台应用程序的Main方法中，我获得了BlogPost的一个实例，然后填充了属性值。我用ShallowCopy和DeepCopy方法得到了两个副本。在这个阶段，我有BlogPost类的3个实例。在用ToString方法打印了值之后，我第一次修改了值。当再次打印属性值时，我们可以看到ShallowCopy和DeepCopy之间的区别。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="e2f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当运行应用程序输出将是这样的。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/fdaa0adadf3ab40c2ff401a6808918e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrWIirPTo_JqysUvesiQ6A.png"/></div></div></figure><p id="d64e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我改变了blog1的所有属性。在ShallowCopy原型标头CreateTime中，状态属性没有更改。但是作为子对象的BlogCategory随原始实例发生了变化。DeepCopy原型没有改变任何属性。</p><p id="c642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当需要复制类时，我们可以使用原型设计模式。此外，根据我们要复制的类结构，我们可以选择浅复制或深复制。</p><p id="03ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以查看我的github知识库中关于设计模式的内容。</p><p id="7856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ld" href="https://github.com/orhanrecep90/DesignPatterns" rel="noopener ugc nofollow" target="_blank">https://github.com/orhanrecep90/DesignPatterns</a></p></div></div>    
</body>
</html>
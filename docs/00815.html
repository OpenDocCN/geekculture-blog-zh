<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/geekculture/intro-to-optimizing-react-application-performance-using-react-apollo-client-a818b3e9ac72?source=collection_archive---------9-----------------------#2021-03-14">https://medium.com/geekculture/intro-to-optimizing-react-application-performance-using-react-apollo-client-a818b3e9ac72?source=collection_archive---------9-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3f05" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">使用React Apollo客户端优化React应用程序性能简介</h2><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/bdc8cafc9b73d3a04baf2a5639decfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_WIThLgDWGi2xW0iTftCyg.png"/></div></div></figure><p id="b11f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">围绕React性能优化的解决方案可能是一个令人眼花缭乱的话题。我想使用React Apollo客户端库提供的解决方案，根据特定用例优化应用程序性能，以控制和减少昂贵的客户端网络请求。</p><p id="7f82" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">根据其<a class="ae jm" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">文档</a>，Apollo optimizations目前致力于:</p><ul class=""><li id="5aea" class="jn jo hi it b iu iv iy iz hs jp hw jq ia jr jl js jt ju jv bi translated"><strong class="it jw">使用GraphQL对本地和远程数据进行状态管理</strong></li><li id="953d" class="jn jo hi it b iu jx iy jy hs jz hw ka ia kb jl js jt ju jv bi translated"><strong class="it jw">查询申请数据</strong></li><li id="6314" class="jn jo hi it b iu jx iy jy hs jz hw ka ia kb jl js jt ju jv bi translated"><strong class="it jw">修改申请数据</strong></li><li id="5ca2" class="jn jo hi it b iu jx iy jy hs jz hw ka ia kb jl js jt ju jv bi translated"><strong class="it jw">缓存数据</strong></li></ul><p id="cba2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">与Axios等其他客户端HTTP库相比，我欣赏Apollo Client的一个有价值的方面是对应用程序如何处理网络请求的控制增加了。让我们讨论优化客户端请求的3种方法(请注意，这不是Apollo特性的完整列表):</p><ul class=""><li id="df2d" class="jn jo hi it b iu iv iy iz hs jp hw jq ia jr jl js jt ju jv bi translated"><strong class="it jw">使用useQuery的动态和粒度提取操作</strong></li><li id="1e7b" class="jn jo hi it b iu jx iy jy hs jz hw ka ia kb jl js jt ju jv bi translated"><strong class="it jw">组件事件监听器和useLazyQuery </strong></li><li id="e639" class="jn jo hi it b iu jx iy jy hs jz hw ka ia kb jl js jt ju jv bi translated"><strong class="it jw">使用fetchPolicy微调客户端缓存</strong></li></ul><p id="1734" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">假设您有一个组件需要查询一个非常昂贵的网络请求，以便呈现正确的数据。理想情况下，您可能只希望组件<em class="kc"> </em>重新获取<em class="kc"> </em>数据<em class="kc">，如果</em>:</p><p id="0b80" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况1 </strong>:请求本身已经改变</p><p id="46ed" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况2 </strong>:用户发起了一些动作</p><p id="d350" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况3 </strong>:数据响应发生变化</p><p id="6579" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果你是一个前端工程师，你会遇到这个问题。以下是使用Apollo解决优化问题的一些方法。</p><p id="6d93" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况1 </strong>:如果只有当<strong class="it jw">请求</strong> <strong class="it jw">已经改变</strong>时，才应该进行提取，则尝试使用带有<strong class="it jw">跳过</strong>变量的<strong class="it jw">使用查询</strong>。Apollo允许我们监听组件中的变量更新，这些更新可以作为参数传递，以更新主体、头、查询参数等。在我们的请求中。同样，一个<strong class="it jw">跳过</strong>变量来指定条件提取。</p><p id="78c6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">例如</strong>:这里我们可以动态地将名称状态值传递给我们的<strong class="it jw"> FETCH_ADDRESS </strong>查询。另外，如果名称不存在，一个<strong class="it jw"> skip </strong>变量允许我们<em class="kc">跳过fetch </em>，减少不必要的请求。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es kd"><img src="../Images/31fa86ee99926f088c2d7ad64631b884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qugeSbZuFr_xqR5c4GSFcQ.png"/></div></div></figure><p id="24fd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况2 </strong>:如果每次组件挂载时都不需要<strong class="it jw">而不是</strong>进行获取，并且只基于<strong class="it jw">事件</strong>或<strong class="it jw">用户交互</strong>才需要获取，则尝试<strong class="it jw"> useLazyQuery </strong>。</p><p id="3e85" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw"> Ex </strong>:这里的<strong class="it jw"> useLazyQuery </strong>只会基于一个<em class="kc"> </em> onClick <strong class="it jw">事件</strong>进行提取，该事件会将一个动态语言变量传递给<strong class="it jw"> getGreeting </strong>。Apollo很方便地给了我们一个名为的<strong class="it jw">，或者说<strong class="it jw"> loading </strong>变量，以便根据<strong class="it jw">有条件地呈现组件，如果已经进行了获取，或者如果数据仍然在加载</strong>。这有助于减少不必要的组件渲染。</strong></p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ke"><img src="../Images/13234ae55933f260547556b222adfe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhO2w3hw66pfTlFqAEfARg.png"/></div></div></figure><p id="a459" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">情况3 </strong>:如果仅在<strong class="it jw">响应数据中的某些内容已经改变</strong>时才需要进行提取，则尝试实现<strong class="it jw">提取策略</strong>。默认情况下，<strong class="it jw"> useQuery </strong>钩子检查<strong class="it jw"> Apollo客户端缓存</strong>以查看您请求的数据是否已经在本地可用。如果所有数据都在本地可用，<strong class="it jw"> useQuery </strong>返回该数据，而<em class="kc">不会查询您的GraphQL服务器。有多种提取策略来支持正确的缓存操作。其他<strong class="it jw"> </strong>提取策略包括:</em></p><pre class="ig ih ii ij fd kf kg kh ki aw kj bi"><span id="59ae" class="hg hh hi kg b fi kk kl l km kn">{<br/>  fetchPolicy: "cache-first"; // default<br/>  /* <br/>    cache-and-network<br/>    cache-first<br/>    cache-only<br/>    network-only<br/>    no-cache<br/>    standby<br/>  */<br/>}</span></pre><p id="313f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it jw">例如:</strong>使用<strong class="it jw">缓存优先</strong>获取策略<strong class="it jw">，</strong><strong class="it jw">GET _ DOGS</strong>查询将首先使用应用缓存中的数据。如果响应不存在或过期，那么它从网络获取响应。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ko"><img src="../Images/8842e6fc7cb3e0970464af02b70cfc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mESwXLhTbqu078m0fv5jtQ.png"/></div></div></figure><p id="1881" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">本文只建议了Apollo fetch查询在组件级可用的几个选项。<a class="ae jm" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">此处阅读更多</a>。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to handle Categorical variables?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理分类变量？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-handle-categorical-variables-7c1ee198c55c?source=collection_archive---------9-----------------------#2021-05-24">https://medium.com/geekculture/how-to-handle-categorical-variables-7c1ee198c55c?source=collection_archive---------9-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1ed8cdacaaf4fc06495ac8d6a2e778b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7JF23MObaWlxzveo-G7qQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@daniellanner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Daniel Lanner</a> on <a class="ae iu" href="https://unsplash.com/s/photos/binary-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据科学是解决现实世界问题和做出数据驱动的决策的艺术和科学。它主要处理各种结构化或非结构化数据。从广义上讲，数据可以分为两种类型，即数值型和分类型。大多数数据科学模型都配备了处理数字数据的功能；然而，当我们必须处理分类数据时，事情变得有趣了。</p><h2 id="9632" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">什么是分类数据？</h2><p id="4a0f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">分类数据是一种在有限的离散类集合中取值的数据形式。很难用数字来计算或测量分类数据，因此它们被分成不同的类别。分类数据的一个例子是人的性别。它只能接受男性、女性和其他人之间的值。</p><p id="25aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种类型的分类变量:</p><p id="a611" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一.序数变量</p><p id="1d63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二。名义可变因素</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/8f8cffc0aae70172edc255f6f12d6140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nUzMbYAJTDPK-ypIdorkg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@martinsanchez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Martin Sanchez</a> on <a class="ae iu" href="https://unsplash.com/s/photos/level?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="f132" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">一.序数变量:</h2><p id="7399" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这些变量在其值的类别中保持自然顺序。如果我们考虑教育水平，那么我们可以很容易地根据他们的教育标签按照高中的顺序对他们进行排序</p><h2 id="fd2a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">1-序数编码:</h2><p id="8c03" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">序数编码主要是将序数类别编码成有序的数值。序号编码根据顺序或等级将每个唯一的类别值映射到特定的数值。考虑给定数据框中的教育列。这里，我们定义了使用sklearn创建顺序编码器时类别的排序。因此，在本例中，我们将类别中的顺序排列为一个升序列表。首先，我们有<em class="li">高中</em>接着是<em class="li">副学士</em>、<em class="li">硕士、</em>然后是<em class="li">博士</em>。最后。</p><h2 id="02c7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">[OrdinalEncoder( <strong class="ix hj">类别</strong> =[['HS '，' AS '，' M.S '，' ph . d . ']]]]</h2><p id="c9be" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">序数编码器是对序数变量进行编码的最合适的选择。它帮助机器学习模型建立分类列和目标列之间的关系。例如，如果我们想预测一个雇员的工资，这将取决于不同的特征，而教育水平将是这些特征之一。现在，从逻辑上讲，拥有博士学位的人会比拥有高中学历的人薪水更高。因此，模型将了解到数据框中值为3的博士比值为0的高中学历的博士权重更大。通过这种方式，模型将了解到，当教育水平提高时，工资也会增加，反之亦然。</p><p id="8adc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.一个热门编码:</p><p id="0477" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果分类变量之间没有顺序关系，那么顺序编码可能会误导模型。这是因为顺序编码器会试图强制变量之间的顺序关系采用自然排序，从而导致性能下降。</p><p id="5030" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，应该使用一个热编码器来处理我们的分类变量。它将通过将N个类别转换成N个特征/列来创建虚拟变量。考虑到<strong class="ix hj"> <em class="li">性别</em> </strong>再列。如果我们在第一行有一个男性，那么它的值是1。同样，如果我们在第二行有一个女性，那么它的值是0。每当类别存在时，其值为1，不存在时为0。我们可以用两种方法一次性编码分类变量。第一，在熊猫中使用<strong class="ix hj"> get_dummies </strong>，第二，使用sklearn的<strong class="ix hj">onehotencode</strong>。</p><p id="1554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再比如婚姻状况。这里，我们有三个不同的类别:已婚:M、离婚:D和单身:s。我们可以通过使用:"<strong class="ix hj"> drop_first=True </strong>"来减少一列的维数，这意味着列的数量将比类别的数量少一。</p><p id="c979" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上表的第二行，我们用零表示已婚和单身，这实际上意味着已经离婚。</p><p id="4374" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们指定drop_first =False，那么我们仍然有三列:已婚、单身和离婚。</p><p id="6c34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所述，我们也可以通过sklearn的<strong class="ix hj"> OneHotEncoder </strong>实现一键编码。</p><p id="6080" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们在一个列中有大量的分类变量，那么我们应该避免使用一次性编码。这将导致相应列的数量增加，这将引起称为“维数灾难”的问题。</p><p id="7e56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3标签编码:</strong></p><p id="26a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">标签编码器会将每个类别转换成唯一的数值。如果使用Sklearn实现，则该编码器应该用于编码输出值，即y，而不是输入x。它类似于顺序编码器，只是这里的数值是自动分配的，不遵循任何自然顺序。通常，分类值的字母顺序用于确定哪个数值先出现。考虑到我们的目标变量“工作状态”列有四个不同的类别。对该列应用标签编码后，四个不同的类别被映射成整数0:全职，1:实习生，2:兼职，3:失业。由此，可以解释为，在训练模型时，失业人员比兼职人员、全职人员和实习生具有更高的优先级，而这些状态之间没有这种优先级或关系。我们不能用标签编码技术定义标签的顺序。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="26e1" class="jt ju hi kz b fi ld le l lf lg">df.head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/fbbc36c98f11020d26ff2a2ec77017ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_qhjoqZbYlo_ieocMNg2w.png"/></div></div></figure><h2 id="1bde" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">标签编码的缺点是它给出了分类值的顺序，这可能不适合一些机器学习算法，如线性回归，因为它们对值太敏感；在这种情况下，一个热编码提供更好的结果。<br/>另一方面，标签编码适用于决策树和随机森林算法，因为它们不依赖于分类变量的值。</h2><p id="d5b8" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">结论</p><p id="41d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们了解了分类数据，以及在将数据输入模型之前必须如何处理它们。我们看到了不同类型的分类数据，以及将这些分类特征转换成数字特征的多种编码技术。理解什么时候使用哪种分类技术是很重要的。事实证明，好的编码技术对模型的性能至关重要。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b2fa" class="jt ju hi kz b fi ld le l lf lg">df['Education'].unique()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/e3f466262606d1d35ba9ccd758389723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czxm9FyA2plOqx245Oo7jA.png"/></div></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3888" class="jt ju hi kz b fi ld le l lf lg">from sklearn.preprocessing import OrdinalEncoder<br/>ordinal = OrdinalEncoder(categories=[['HS', 'AS', 'M.S','Ph.D']])<br/>df['Education'] = ordinal.fit_transform(df[['Education']])<br/>df.head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/7a2b84c5c9913da8a239d4b6ee4cebae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sjMr6tx97u1nD-t5glGmA.png"/></div></div></figure><p id="0534" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p><h2 id="209f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi">2. One Hot Encoding:</h2><p id="822d" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi">If there is no ordinal relationship between the categorical variables then ordinal encoding might mislead the model. This is because the ordinal encoder will try to force an ordinal relationship on the variables to assume a natural ordering, thus resulting in poor performance.</p><p id="226e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">In this case, One Hot encoder should be used to treat our categorical variables. It will create dummy variables by converting N categories into N features/columns. Considering the <strong class="ix hj"><em class="li">gender</em></strong> column again. If we have a male in the first row, then its value is 1. Also if we have a female in the second row then its value is 0. Whenever the category exists its value is 1 and 0 where it does not. We can one-hot encode categorical variables in two ways. One, by using <strong class="ix hj">get_dummies</strong> in pandas and two, by using <strong class="ix hj">OneHotEncoder</strong> from sklearn.</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6e56" class="jt ju hi kz b fi ld le l lf lg">pd.get_dummies(df['Gender']).head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/6a7b442c9269e2c3474f225626c9dc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*TZoIlCeOvLUElTV7rvg0Cg.png"/></div></div></figure><p id="b079" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">Another example is Marital Status. Here, we have three different categories Married: M, Divorced: D, and Single: S. we can reduce the dimensionality by one column by using: “<strong class="ix hj">drop_first=True</strong>” meaning the number of columns will be one less than the number of categories.</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ae69" class="jt ju hi kz b fi ld le l lf lg">pd.get_dummies(df['Marital Status'],drop_first=True).head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/c892d2f9ca491203f6e30bb4f2d5692c.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*YPnlMsRlBepMC5e6c8eDHQ.png"/></div></figure><p id="8883" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">In the second row of the table above, we have zero for married and single, which effectively means that it is Divorced.</p><p id="28bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">If we assign drop_first =False, then we still have three columns: Married, Single, and Divorced.</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="233b" class="jt ju hi kz b fi ld le l lf lg">pd.get_dummies(df['Marital Status'],drop_first=False).head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/1e6467c9e9bad531224ccee3acdf229f.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*8PnuRqkjSikvAU4_C3HiJA.png"/></div></figure><p id="fa15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">As mentioned, we can also implement one-hot encoding through <strong class="ix hj">OneHotEncoder</strong> from sklearn.</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="64b8" class="jt ju hi kz b fi ld le l lf lg">from sklearn.preprocessing import OneHotEncoder<br/>ohe = OneHotEncoder(sparse=False)<br/>ohe.fit_transform(df0[['Marital Status']])</span></pre><p id="d1dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">If we have a high number of categorical variables in a column, then we should avoid using one-hot encoding. It will result in an increase in the number of corresponding columns which will give rise to a problem called “Curse of Dimensionality”.</p><p id="e8a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi"><strong class="ix hj">3- Label Encoding:</strong></p><p id="12c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">The label encoder will convert each category into a unique numerical value. If implemented with Sklearn, then this encoder should be used to encode output values, i.e. y, and not the input X. It is similar to the ordinal encoder except, here the numeric values are assigned automatically without following any sort of natural order. Generally, the alphabetical order of the categorical values is used to determine which numerical value comes first. Considering our target variable “Job Status” column has four different categories. After applying label encoding to this column the four different categories are mapped into integers 0: Full Time, 1: Intern, 2: Part-Time, and 3:Unemployed. With this, it can be interpreted that Unemployed have a higher priority than Part-Time, Full Time, and Intern while training the model, whereas, there is no such priority or relation between these statuses. We can’t define the order of labels with the label encoding technique.</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5dc5" class="jt ju hi kz b fi ld le l lf lg">from sklearn.preprocessing import LabelEncoder <br/>lbe = LabelEncoder()<br/>df['Employment Status']= lbe.fit_transform(df['Employment Status']) <br/>df.head()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/87474d52495d493cfc64b9f920d51224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJchMjlJlBSizEl82WY6wg.png"/></div></div></figure><p id="0112" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">The disadvantage to label encoding is that it gives an order to the categorical value, which might not be suitable to some machine learning algorithms such as Linear Regression, as they are too sensitive to the values; in such case, one hot encoding provides better results.<br/>On the other hand, label encoding is suitable with Decision Tree and Random Forest algorithms because they don’t depend on the values of the categorical variables.</p><h2 id="98d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi">Conclusion</h2><p id="3be1" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi">We learned about the categorical data and how we must treat them before feeding it to a model. We saw different types of categorical data and also multiple encoding techniques to convert those categorical features into numerical features. It is important to understand which categorical technique to be used and when. A good encoding technique proves vital to the performance of your model.</p><p id="1f87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">Thanks for reading!</p></div></div>    
</body>
</html>
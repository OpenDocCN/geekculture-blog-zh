<html>
<head>
<title>Visualising Schema Registry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化模式注册表</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/visualising-schema-registry-9cbafe89e56?source=collection_archive---------34-----------------------#2021-07-04">https://medium.com/geekculture/visualising-schema-registry-9cbafe89e56?source=collection_archive---------34-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dc912caae5bdef163a5ae5bb672b7a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sLupsMnc0MQksT3B.png"/></div></div></figure><p id="6b96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果您想在Kafka集群中使用模式，Schema Registry是一个很好的工具。它跟踪不同的版本，允许模式之间的兼容性，支持不同的格式类型(json、avro、protobuf等等)。</p><p id="44cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在这一点上，所有这些对你来说都是一个大问号，那么在继续之前，查看一下汇合文档<a class="ae jo" href="https://docs.confluent.io/platform/current/schema-registry/index.html" rel="noopener ugc nofollow" target="_blank">第</a>页。</p><p id="99a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，为什么还要可视化模式注册呢？好问题。该项目结合了一些技术乐趣和在Schema Registry中可视化依赖关系的需求。在当前的项目中，我们已经决定使用<a class="ae jo" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>作为模式提供者的选择。我们创建了一个“公共”Protobuf库，描述了与业务词汇相匹配的基本和复杂类型。有了这些类型，每个团队都可以在他们的领域内根据需要构建更复杂的模式。开始的时候一切都很好，直到它变成一只有更多依赖的野兽。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/9c2819e7682c8082e33c10f6c7878cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VEvcmYIOH4r3_lGO"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Where does it start and end right ?</figcaption></figure><p id="56f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“那又怎么样？”我听到你在想。现在到了棘手的部分，一个开发人员走到您的办公桌前(或邮件中),说他/她想删除一个模式，但是存在依赖关系，现在卡住了。由你来纠缠这个烂摊子。</p><h1 id="3b91" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">你好图表</h1><p id="a075" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">上述问题可以作为一个<a class="ae jo" href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)#:~:text=In%20computer%20science%2C%20a%20graph,of%20graph%20theory%20within%20mathematics." rel="noopener ugc nofollow" target="_blank">图形</a>问题来解决。Schema Registry中的每个条目都可以看作一个节点，它们之间的关系可以看作一条边。</p><p id="5f5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了可视化这种情况，我选择使用<a class="ae jo" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3.js </a>，它有一些很好的方式来可视化你的图表。</p><p id="2469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，我们有问题，我们有解决问题的方法，让我们建立我们的API。</p><h1 id="fcac" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Python API</h1><p id="f77d" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我决定用python来构建解决方案，因为我可以利用<a class="ae jo" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank"> NetworkX </a>来解决我的绘图问题。API本身是用<a class="ae jo" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>编写的，这是一个用于编写REST API的现代框架。</p><p id="e8d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将看到两个端点。第一个端点将创建图形并以JSON格式返回结构。</p><p id="910d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个端点仅用于演示目的，但允许您在本地webbrowser中可视化图形，而无需编写任何前端代码。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="58e4" class="lg jz hi lc b fi lh li l lj lk">@app.post("/viz_topic", response_class=JSONResponse)<br/>async def viz_topic(viz_subject_name: VizTopicSubjectInput):      result = viz_sr_topic(subject_name=viz_subject_name, sr_base_url=schema_registry_base_url)    <br/>return result  </span><span id="ab34" class="lg jz hi lc b fi ll li l lj lk">@app.get("/show/{graph_id}", response_class=HTMLResponse)<br/>return templates.TemplateResponse("graphd3.html", {"request": request, "graph_id": graph_id})</span></pre><p id="edf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我们有了终点，让我们开始解决实际问题。</p><h2 id="5040" class="lg jz hi bd ka lm ln lo ke lp lq lr ki jb ls lt km jf lu lv kq jj lw lx ku ly bi translated">Python与模式注册中心的交互</h2><p id="9c66" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">虽然Schema Registry有java和scala的本地库，但它没有python的本地库。这意味着我们完全停留在使用API调用模式注册表上。为了尽可能保持简洁，我构建了一个类，它公开了我需要的端点。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="3635" class="lg jz hi lc b fi lh li l lj lk">class SchemaRegistry():<br/>    def __init__(self, base_url):<br/>        self.base_url = base_url<br/>        self.protocol = urlparse(self.base_url).scheme</span><span id="bb33" class="lg jz hi lc b fi ll li l lj lk">def get_protocol(self):<br/>        """<br/>        Returns the protocol of a given URL<br/>        :return: str: Protocol<br/>        """<br/>        return self.protocol</span><span id="6990" class="lg jz hi lc b fi ll li l lj lk">def get_subject_versions_url(self, subject_name):<br/>        """<br/>        Creates the URL to retrieve the subject versions<br/>        :param subject_name: str: Name of the subject<br/>        :return: str<br/>        """<br/>        return self.base_url + "/subjects/{}/versions/".format(subject_name)<br/>...</span></pre><h2 id="6d7d" class="lg jz hi bd ka lm ln lo ke lp lq lr ki jb ls lt km jf lu lv kq jj lw lx ku ly bi translated">已经建立了图表</h2><p id="d5f5" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">对吗？！好了，现在我们已经有了一些辅助组件，我们可以开始构建我们的图表了。这个想法是，开发人员提供一个主题，我们希望显示该主题的所有依赖关系。首先，我们初始化一个NetworkX图形组件。虽然NetworkX支持<a class="ae jo" href="https://networkx.org/documentation/stable/auto_examples/index.html" rel="noopener ugc nofollow" target="_blank">不同类型的</a>图，但我还是选择了标准类型。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="7ae1" class="lg jz hi lc b fi lh li l lj lk">def viz_sr_topic(subject_name, sr_base_url):<br/>    """<br/>    This function will, for a given subject, query schema registry and generate a networkx graph from it.<br/>    :param subject_name: str: Name of the subject as in SR<br/>    :param sr_base_url: str: Full URL of SR<br/>    :return: none<br/>    """<br/>    G = nx.Graph()<br/>    versions = None<br/>    subject = subject_name.subjectname<br/>    persist_uuid = uuid.uuid4() if subject_name.persist else None</span><span id="b060" class="lg jz hi lc b fi ll li l lj lk">try:<br/>        if len(subject) == 0:<br/>            raise MissingSubjectNameException()<br/>        else:<br/>            G.add_node(subject)</span></pre><p id="3b34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本节点将被设置为我们指定的主题，因此接下来我们将检索依赖项。为了实现这一目标，我们必须做几件事:</p><ul class=""><li id="cc09" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated">检索给定主题的所有版本</li><li id="16a2" class="lz ma hi is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">对于所有版本，获取模式引用id</li><li id="3661" class="lz ma hi is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">如果我们已经找到一个有效的模式引用id，解析附加到它的模式并添加名称作为引用。边缘将是参考和主题之间的链接</li></ul><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="f03c" class="lg jz hi lc b fi lh li l lj lk">for version in json.loads(versions.text):<br/> version_response = do_url_request(<br/>  request_url=sr.get_references_url(subject_name=subject, version_id=version),<br/>  sr_protocol=sr.get_protocol())<br/> if version_response.status_code == 200:<br/>  for refId in json.loads(version_response.text):<br/>   schema_response = do_url_request(request_url=sr.get_schema_by_id_url(schema_id=refId),<br/>            sr_protocol=sr.get_protocol())<br/>   if schema_response.status_code == 200:<br/>    result = json.loads(schema_response.text)<br/>    for ref in result["references"]:<br/>     G.add_edge(subject, ref["name"])<br/>     G.add_node(ref["name"])</span></pre><h2 id="ce47" class="lg jz hi bd ka lm ln lo ke lp lq lr ki jb ls lt km jf lu lv kq jj lw lx ku ly bi translated">最后一步:想象它</h2><p id="18b4" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">如前所述，这只是为了演示的目的而添加的，我坚信这种类型的工作应该在一个适当的前端框架中完成。</p><p id="48da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经注意到，我们允许用户向API提供一个标志来持久化解决方案，这在我们的例子中意味着在后端保存json对象。</p><p id="4b71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当所有的处理完成后，我们最终返回结果，这是一个包含所有边和依赖节点的JSON结构。如果设置了persist标志，我们还将输出一个ID作为有效负载的一部分，并将这个ID作为文件名保存在json对象中。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="1f73" class="lg jz hi lc b fi lh li l lj lk">data = json_graph.node_link_data(G)<br/>if persist_uuid is None:<br/> return {"data": data, "uuid": ""}<br/>else:<br/> with open('static/' + str(persist_uuid) + '.json', 'w') as f:<br/>  json.dump(data, f, indent=4)</span><span id="6448" class="lg jz hi lc b fi ll li l lj lk">return {"data": data, "uuid": persist_uuid}</span></pre><p id="6050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在是时候使用我们的第二个端点了。进入你的浏览器，输入以下网址“http://localhost/show/ <uuid from="" first="" endpoint=""/></p><p id="6651" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FastAPI允许您使用“TemplateResponse”，它可以返回一个html页面。在我们的例子中，这意味着我们首先需要创建一个包含D3.js库的html页面来可视化数据。</p><p id="29d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用d3.json函数从保存在第一个API调用中的文件中加载数据。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="48f8" class="lg jz hi lc b fi lh li l lj lk">d3.json("{{ url_for('static',path='.') }}/{{ graph_id }}.json", function(error, graph)</span></pre><p id="c1ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当调用结束时，浏览器将呈现您的输出。最终产品是一个动态图形，您可以在其中拖动不同的节点。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/2f96e0fba3ffa39ad4e804cf370d44ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oLVk8IDP7MofjH1r"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Static screenshot of d3.js visualization</figcaption></figure><h1 id="fe41" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">HTTPS启用的模式注册表</h1><p id="ad8d" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在大多数情况下，您的模式注册中心将启用HTTPS(如果没有，请确保它是启用的😱).因为我们使用请求包来调用模式注册中心端点，所以可以将证书指定为调用的一部分。</p><p id="8194" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在函数“do_url_request”中，我们将检查url是否使用HTTPS，如果是，我们将检查环境变量“CERT_FILE_PATH”是否包含证书。如果您在没有这个环境变量的情况下进行HTTPS调用，我们将引发一个自定义错误，因为我们知道这将永远不会导致成功的调用。</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="d267" class="lg jz hi lc b fi lh li l lj lk">def do_url_request(request_url, sr_protocol):<br/>    """<br/>    Helper function to handle requests for Schema registry. If https is used, a valid cerificate must be present<br/>    :param request_url: str: URL endpoint you are trying to reach<br/>    :param sr_protocol: str: Protocol (http or https)<br/>    :return: requests.Response<br/>    """<br/>    if sr_protocol == "http":<br/>        return requests.get(url=request_url, headers={'content-type': 'application/json'})<br/>    else:<br/>        if "CERT_FILE_PATH" in os.environ:<br/>            return requests.get(url=request_url, headers={'content-type': 'application/json'},verify=os.getenv("CERT_FILE_PATH"))<br/>        else:<br/>            raise MissingCertFilePath()</span></pre><h1 id="b3d9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">想在Docker上运行这个吗？</h1><p id="47c6" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我把它作为解决方案的一部分。如果您想将整个设置作为Docker解决方案运行，您可以。从项目的根目录，您可以运行以下命令</p><pre class="jq jr js jt fd lb lc ld le aw lf bi"><span id="c0b7" class="lg jz hi lc b fi lh li l lj lk">docker build -t schema_registry_visualizer -f Docker/Dockerfile .</span></pre><h1 id="a736" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="8232" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">这个项目是一个商业问题的一部分，但结合了一些技术方面，使它对开发者来说也很有趣。像往常一样，整个解决方案可以在我的<a class="ae jo" href="https://github.com/Ycallaer/schema_registry_viz" rel="noopener ugc nofollow" target="_blank"> github页面</a>上找到，文档在README.md和代码中。希望你喜欢这个小故事，并在这个过程中学到了一些东西。</p></div></div>    
</body>
</html>
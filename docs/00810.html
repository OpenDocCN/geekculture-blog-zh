<html>
<head>
<title>True RESTful API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">真正的RESTful API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/true-restful-api-b675aaf72c32?source=collection_archive---------4-----------------------#2021-03-14">https://medium.com/geekculture/true-restful-api-b675aaf72c32?source=collection_archive---------4-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="36d1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">REST架构约束</h2></div><p id="7bae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">在过去的几十年里，我们已经看到SOAP失宠了，因为酷孩子把他们的服务转移到了REST或GraphQl范式，或者表面上看起来是这样。2000年，Roy Fielding博士提出了表述性状态转移，或简称为REST，作为设计web服务的架构方法。既然义务介绍(？)说完了，我们来潜进内容。这篇文章纯粹是为了解释Fielding博士为了让API成为RESTful而提出的六个基本原则；它必须遵守以下六个约束。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kc"><img src="../Images/1d06bb285c1b63ddec4b40b80eaa0e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*L4dv4N_o57JiSUNkLQGPiw.jpeg"/></div><figcaption class="kk kl et er es km kn bd b be z dx">source: <a class="ae ko" href="https://geek-and-poke.com/" rel="noopener ugc nofollow" target="_blank">Geek and Poke</a></figcaption></figure><h1 id="dfee" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">无国籍的</h1><p id="17ad" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">无状态意味着服务器不记得任何关于使用API的用户的信息。将每个请求视为新的，没有会话，没有历史。从客户端发送到服务器的每个请求都将包含使服务器理解从客户端发送的请求所需的所有信息。这可以是URL的一部分、查询参数、正文，甚至是标题。一旦服务器处理了请求，就会通过主体、状态或头向客户机发送响应。</p><h1 id="72cc" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">客户端-服务器</h1><p id="9719" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">基本上，客户机和服务器各自独立工作。客户机-服务器体系结构支持统一的接口，并将服务器与客户机分开。优点是这提高了服务器组件的可伸缩性，并增强了跨多个平台的可移植性。</p><h1 id="be95" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">统一界面</h1><p id="e930" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">在REST中，为了在整个应用程序中获得统一的接口，我们实现了四个关键的接口约束，</p><ul class=""><li id="8ea8" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">资源标识，其中对服务器的请求必须包括资源标识符。我们使用URI标准来识别资源。</li><li id="ada9" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">使用表示的资源操作，其中我们使用HTTP标准来描述通信。</li><li id="dafc" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">自描述性消息，其中对API的每个请求都包含服务器执行请求所需的所有信息。</li><li id="ff8d" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">作为应用程序状态引擎的超媒体。使用超链接和可能的URI模板将客户端从特定于应用程序的URI结构中分离出来。</li></ul><p id="7542" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们所说的一旦一个开发者熟悉了你的一个API，这个开发者应该能够对其他API采用类似的方法。一致性。</p><h1 id="7170" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">可缓冲的</h1><p id="658b" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">为了提供更好的性能，应用程序通常是可缓存的。这是信息在服务器外部的临时存储。如果响应被定义为可缓存的，那么客户机缓存可以在将来为等效的响应重用响应数据。缓存为客户端带来了性能提升，并降低了服务器的负载。但也有不利的一面，数据可能会过时，作为一种解决方案，我们所做的是刷新缓存，服务器决定何时刷新缓存数据，管理缓存的实体执行它。</p><h1 id="e4eb" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">分层系统</h1><p id="33f1" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">分层系统架构通过限制组件行为，使应用程序更加稳定。由于客户端和服务器之间可能存在缓存层、负载平衡层或其他功能，这些层不应该影响请求或响应。这种类型的架构有助于增强应用程序的安全性，因为每一层中的组件只知道下一层，而不会知道更多，这促进了关注点的分离。</p><h1 id="e364" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">按需编码</h1><p id="29f3" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">这是一个可选约束，使用最少。客户端可以向服务器请求代码，然后服务器的响应将包含一些要下载并在应用程序中使用的代码或小程序。本质上，它通过创建一个不依赖于自己的代码结构的应用程序来简化客户端。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="158d" class="kp kq hi bd kr ks mh ku kv kw mi ky kz io mj ip lb ir mk is ld iu ml iv lf lg bi translated">结论</h1><p id="e3c2" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">REST是一种支持API设计的架构风格。虽然得到了广泛的应用，但也有一些缺点，比如缺少状态或有状态机制，以及大量无用数据在请求中穿梭的可能性。另一个API架构GraphQL解决了这个问题。这有助于以一种迎合您的查询的方式从API端点检索信息。</p><p id="273a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，REST架构是目前使用最广泛的架构之一，它的简单性促进了快速开发、集成、测试和部署。</p></div></div>    
</body>
</html>
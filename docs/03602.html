<html>
<head>
<title>Verilog Reg Datatype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Verilog Reg数据类型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/reg-types-handling-5b7c91a534aa?source=collection_archive---------15-----------------------#2021-06-11">https://medium.com/geekculture/reg-types-handling-5b7c91a534aa?source=collection_archive---------15-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗨，伙计们，</p><p id="b543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一本很长的读物。我正在报道Verilog的reg和integer关键字。这两个题目都是相当庞大的，但是我在这里总结了使用最多的方式。我建议你在阅读时打字并练习来确定你自己。如果您有任何问题，请在下面的评论中提出，我们将会解答。</p><p id="20e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐阅读，</p><p id="871f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Verilog中处理“reg”类型</p><p id="6847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Verilog中的“reg”类型之一是“integer”。如果你理解处理整数，同样的原则可以应用于所有的reg类型。Verilog中的注册类型列表如下，供快速参考:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2d2755f96d31bb84997c387921ca5291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cOwUnSZSsvQxYpyo6MW8g.jpeg"/></div></div></figure><p id="390c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文更侧重于前两种类型。我会再写一篇关于后三者的博客。</p><p id="4321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Verilog中的整数可以有大小也可以无大小，它们是4态变量。Verilog整数的默认大小是32位。有大小的整数值的一个例子是8'd10。未调整大小的整数值的一个例子是“hF44”。</p><p id="695b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Verilog允许您以任何支持的基数指定值——十进制、二进制、八进制或十六进制。Verilog中典型的整数运算是–</p><ol class=""><li id="634e" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">将整数值赋给整数变量</li><li id="f11c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将一个整数变量赋给另一个整数变量</li></ol><p id="91e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先考虑这两个用例，然后进一步探索。让我们从一个例子开始——</p><p id="2491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">整数I；</strong></p><p id="3b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">I = 1；</strong></p><p id="5cf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Verilog中，如果你没有指定基数，它会认为你是在说十进制。在上面的例子中，我们将decimal 1的值赋给一个32位的整数。该值以32位格式存储在Verilog运行时内核中。存储值为–</p><p id="e333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">0000_0000_0000_0000_0000_0000_0000_0001</p><p id="5223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看更多的例子来理解绝对值是如何存储在内存中的</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/2e25536ff8e1e76563177d51b2ff6279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4MInak3X5nKwrnwLEmEMw.jpeg"/></div></div></figure><p id="d562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用这个值并不重要；用什么基数指定值并不重要；储物永远像上面那样。事实上，不管模拟器实现如何处理这种存储，最好是像上表所示的那样理解它。</p><p id="0c23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过一些例子来看看这种整数的一个非常简单的用法</p><blockquote class="ke kf kg"><p id="dc75" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">整数I；</strong></p><p id="45d2" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">I = 10；</strong></p><p id="3771" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> $display("十进制中I的值为%0d "，I)；</strong></p><p id="8e5f" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> $display("六进制中I的值是%x "，I)；</strong></p></blockquote><p id="c7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会注意到‘I’可以用任何你想要的格式打印出来。但是，这会改变I的绝对值存储在内存中的机制吗？不要！因此，首先要理解的是，不管值被转换成什么基数(当使用值或变量时)，该值都被称为绝对值，如上所示。</p><p id="6b73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种用法是这样的</p><blockquote class="ke kf kg"><p id="393d" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">整数I；reg[3:0]r；</strong></p><p id="7bcc" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">r = 10；</strong></p><p id="8514" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">I = r；</strong></p><p id="3730" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">$ display(" I的值为%b "，I)；</strong></p></blockquote><p id="a186" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们在RHS上有一个4位值，它被分配给一个32位变量。如果运行这段代码，控制台上显示的I的值是000000000000000000000000000001010。这是为什么呢？</p><p id="9c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个位宽较小的向量被分配给一个位宽较大的向量时，模拟器执行以下步骤(假设块分配如上述代码所示):</p><ol class=""><li id="9025" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">对RHS进行评估。这里，RHS值是4位二进制1010(如上面存储方法中所述)</li><li id="cf2e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">比较了LHS和RHS的大小。在我们上面的例子中，LHS位宽更大。</li><li id="6974" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果位宽较大，RHS的绝对值会填充足够的位，使其等于LHS的位宽。在这个例子中，4位二进制1010的值必须用28个附加的MS位来填充</li><li id="5202" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这种填充位必须被赋予一个不会影响我们原始绝对值的值。因此，填充的最终值是0000000000000000000000000000001010</li><li id="d346" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这个新导出的值(正好等于原始值)被分配给LHS</li></ol><p id="5fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你这样做了，情况也没什么不同</p><p id="70fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">I = 4’D10；</strong></p><p id="6bd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想试试吗？</p><p id="ad97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在这里尝试一些奇怪的东西会发生什么？让我们检查下面的代码</p><blockquote class="ke kf kg"><p id="ad2e" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">整数I；reg[3:0]r；</strong></p><p id="1ca9" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">I = 32 ' bx 110；</strong></p><p id="4ef9" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">$ display(" I的值为%b "，I)；</strong></p></blockquote><p id="94cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">猜测产量？我已经把它贴在下面了——</p><p id="afdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x 110</p><p id="9612" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们该如何推理？Verilog规范规定:如果一个位向量必须向最高有效端填充，填充规则如下</p><ol class=""><li id="0e7c" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">如果要扩展的向量的MS位具有逻辑1或逻辑0的值，则新填充的位将携带逻辑0的值</li><li id="160f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果要扩展的向量的MS比特具有值x或z，则新填充的比特将分别携带值x或z</li></ol><p id="bf3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，如果<value>必须左扩展，扩展位的值取决于<value>的最高有效位。如果<value>的最高有效位携带1或0，则<value>用零向左扩展。事实上，这是处理这种情况的绝对正确的方法。如果你想保持<value>不变，你必须在左边加零。</value></value></value></value></value></p><p id="2f66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，另一种情况是最高有效位携带1'bx。在这种情况下，Verilog指定您应该将x的值分配给所有向左扩展的位。类似地，对于具有z值的MS比特的情况，新填充的比特将携带z。</p><p id="91db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正确理解了这一点，那么将窄向量分配给宽向量就没有什么新东西可学了。在将较宽的向量分配给较窄的向量的情况下，RHS的额外最高有效位被截断。这不需要太多解释。</p><h1 id="d06e" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">岔路</h1><p id="9b79" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">想知道Verilog模拟器如何模拟4态值吗？如果您打开一个PLI头文件(该文件的名称和位置特定于模拟器)，您将会发现如下定义:</p><blockquote class="ke kf kg"><p id="c797" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> /*向量值的数据结构*/ </strong></p><p id="3fa1" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> typedef结构t_vecval </strong></p><p id="30a3" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> { </strong></p><p id="03ee" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">int avalbits；/*向量每个比特的比特编码:*/ </strong></p><p id="53e7" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj">int bvalbits；/* ab: 00=0，10=1，11=X，01=Z */ </strong></p><p id="e891" class="if ig kh ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated"><strong class="ih hj"> } s_vecval，* p _ vecval</strong></p></blockquote><p id="1281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您不知道在哪里可以找到它，只需在模拟器安装文件夹中grep for t_vecval，您就可以找到该文件。</p><p id="5240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是返回Verilog模拟器内核中每个位的4态逻辑值的数据结构。当然，我们还没有力量等属性。它只是存储值。当您使用PLI TF例程在Verilog和C/C++世界之间交换数据时，您将使用这个结构来实现目标。本文的目的不是讨论PLI或数据交换，我只是认为了解这些是有帮助的。祝大家学习愉快！</p><p id="c2b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">科技酒吧，</p><p id="69f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lo" href="https://proxelera.com" rel="noopener ugc nofollow" target="_blank"> Proxelera </a></p></div></div>    
</body>
</html>
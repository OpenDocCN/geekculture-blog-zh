<html>
<head>
<title>React Hook to Allow Undo/Redo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">允许撤销/重做的反应挂钩</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-hook-to-allow-undo-redo-d9d791c5cd94?source=collection_archive---------2-----------------------#2021-11-18">https://medium.com/geekculture/react-hook-to-allow-undo-redo-d9d791c5cd94?source=collection_archive---------2-----------------------#2021-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de5980a82873bffc348e7e051fbf70f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hvA5ZGL1anqr-Bpx-gweQ.jpeg"/></div></div></figure><p id="5195" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想构建像<a class="ae jo" href="https://formblob.com/" rel="noopener ugc nofollow" target="_blank"> FormBlob </a>这样的无代码工具，一个<em class="jp">必须具备的</em>特性是撤销和重做动作的能力。为什么？假设您正在使用一个图像编辑软件，并且对画布进行了多次修改。过了一段时间，你意识到你以前拥有的比你现在拥有的要好得多。你会撤销你的原路返回，直到你到达你满意的阶段。</p><p id="1029" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果软件没有撤销/重做功能，你很可能会使用一些华丽的语言，永远放弃这个软件。</p><p id="98ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们如何实现撤销/重做功能，防止用户放弃我们的应用程序呢？</p><h1 id="21e0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">先决条件</h1><p id="2017" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">如果你不熟悉React钩子，我建议你在这里阅读一下它们。最基本的挂钩之一是React内置的useState挂钩。这允许您将组件状态存储在一个变量中，并根据需要管理它。在本教程中，我们将编写一个钩子来扩展useState钩子，以允许撤销/重做功能。</p><h1 id="c41e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">代码</h1><p id="ecad" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们从代码开始，然后我会在下面解释。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="48f0" class="lc jr hi ky b fi ld le l lf lg">import { useMemo, useState } from "react";<br/>// If you're only working with primitives, this is not required<br/>import isEqual from "lodash/isEqual";</span><span id="5f8c" class="lc jr hi ky b fi lh le l lf lg">export default function useUndoableState(init) {<br/>  const [states, setStates] = useState([init]); // Used to store history of all states<br/>  const [index, setIndex] = useState(0); // Index of current state within `states`</span><span id="0645" class="lc jr hi ky b fi lh le l lf lg">  const state = useMemo(() =&gt; states[index], [states, index]); // Current state</span><span id="0934" class="lc jr hi ky b fi lh le l lf lg">const setState = (value) =&gt; {<br/>    // Use lodash isEqual to check for deep equality<br/>    // If state has not changed, return to avoid triggering a re-render<br/>    if (isEqual(state, value)) {<br/>      return;<br/>    }<br/>    const copy = states.slice(0, index + 1); // This removes all future (redo) states after current index<br/>    copy.push(value);<br/>    setStates(copy);<br/>    setIndex(copy.length - 1);<br/>  };</span><span id="e3ae" class="lc jr hi ky b fi lh le l lf lg">  // Clear all state history<br/>  const resetState = (init) =&gt; {<br/>    setIndex(0);<br/>    setStates([init]);<br/>  };</span><span id="042c" class="lc jr hi ky b fi lh le l lf lg">  // Allows you to go back (undo) N steps<br/>  const goBack = (steps = 1) =&gt; {<br/>    setIndex(Math.max(0, Number(index) - (Number(steps) || 1)));<br/>  };</span><span id="a1c9" class="lc jr hi ky b fi lh le l lf lg">  // Allows you to go forward (redo) N steps<br/>  const goForward = (steps = 1) =&gt; {<br/>    setIndex(Math.min(states.length - 1, Number(index) + (Number(steps) || 1)));<br/>  };</span><span id="be33" class="lc jr hi ky b fi lh le l lf lg">  return {<br/>    state,<br/>    setState,<br/>    resetState,<br/>    index,<br/>    lastIndex: states.length - 1,<br/>    goBack,<br/>    goForward,<br/>  };<br/>}</span></pre><h1 id="1180" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">概念</h1><p id="9330" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">与useState一样，useUndoableState只接受1个参数，即初始值。在幕后，钩子使用两个主要变量来确定状态— <code class="du li lj lk ky b">index</code>(数字)和<code class="du li lj lk ky b">states</code>(数组)。<code class="du li lj lk ky b">states</code>存储状态的历史值，而<code class="du li lj lk ky b">index</code>通过指示数组中的当前位置来确定当前状态。</p><p id="751b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以通过使用钩子发出的<code class="du li lj lk ky b">goBack</code>和<code class="du li lj lk ky b">goForward</code>函数来浏览历史状态。但是，如果您调用了<code class="du li lj lk ky b">setState</code>并且<code class="du li lj lk ky b">index</code>不在<code class="du li lj lk ky b">states</code>数组的末尾，那么<code class="du li lj lk ky b">index</code>之后的所有状态都将被擦除，而<code class="du li lj lk ky b">index</code>将返回到<code class="du li lj lk ky b">states</code>数组的末尾。也就是说，一旦调用了<code class="du li lj lk ky b">setState</code>，就不能再重做了。</p><p id="a366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面试图对钩子返回的对象提供更详细的解释:</p><ul class=""><li id="d809" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">属性|类型|用途|描述</li><li id="912c" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">state | <code class="du li lj lk ky b">any</code> | |当前状态，用传递的参数初始化</li><li id="09cb" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">setState | <code class="du li lj lk ky b">func</code> | <code class="du li lj lk ky b">setState(value)</code> |将状态设置为<code class="du li lj lk ky b">value</code>。电流<code class="du li lj lk ky b">index</code>被擦除后的所有值</li><li id="2af9" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">resetState | <code class="du li lj lk ky b">func</code> | <code class="du li lj lk ky b">resetState(value)</code> |删除历史状态并重置为值</li><li id="0dc9" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">index |<code class="du li lj lk ky b">number</code>|<code class="du li lj lk ky b">states</code>数组中的当前索引</li><li id="b764" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">lastIndex | <code class="du li lj lk ky b">number</code> | |数组<code class="du li lj lk ky b">states</code>中的最后一个索引。可用于确定是否可以<code class="du li lj lk ky b">goForward</code>。<code class="du li lj lk ky b">canGoForward = index &lt; lastIndex</code></li><li id="99c0" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">goBack | <code class="du li lj lk ky b">func</code> | <code class="du li lj lk ky b">goBack(2)</code> |返回经过的步数</li><li id="069f" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">goForward | <code class="du li lj lk ky b">func</code> | <code class="du li lj lk ky b">goForward(3)</code> |前进经过的步数</li></ul><h1 id="7027" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用</h1><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b3fe" class="lc jr hi ky b fi ld le l lf lg">import React from "react";<br/>import useUndoableState from "path/to/hook";</span><span id="dbed" class="lc jr hi ky b fi lh le l lf lg">const init = { text: "The quick brown fox jumps over the lazy dog" };</span><span id="54e7" class="lc jr hi ky b fi lh le l lf lg">export default function Document() {<br/>  const {<br/>    state: doc,<br/>    setState: setDoc,<br/>    resetState: resetDoc,<br/>    index: docStateIndex,<br/>    lastIndex: docStateLastIndex,<br/>    goBack: undoDoc,<br/>    goForward: redoDoc<br/>  } = useUndoableState(init);</span><span id="71f3" class="lc jr hi ky b fi lh le l lf lg">  const canUndo = docStateIndex &gt; 0;<br/>  const canRedo = docStateIndex &lt; docStateLastIndex;</span><span id="67eb" class="lc jr hi ky b fi lh le l lf lg">  return (<br/>    &lt;div style={{ display: "block" }}&gt;<br/>      &lt;textarea<br/>        style={{ margin: "16px" }}<br/>        onChange={(event) =&gt; setDoc({ text: event.target.value })}<br/>        rows="5"<br/>        value={doc.text}<br/>      /&gt;<br/>      &lt;div&gt;<br/>        &lt;button<br/>          onClick={() =&gt; undoDoc()}<br/>          disabled={!canUndo}<br/>          style={{ marginRight: "8px" }}<br/>        &gt;<br/>          Undo<br/>        &lt;/button&gt;<br/>        &lt;button<br/>          onClick={() =&gt; redoDoc()}<br/>          disabled={!canRedo}<br/>          style={{ marginRight: "8px" }}<br/>        &gt;<br/>          Redo<br/>        &lt;/button&gt;<br/>        &lt;button onClick={() =&gt; resetDoc(init)}&gt;Reset&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="b289" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结束语</h1><p id="3323" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">凭借撤销/重做功能，<a class="ae jo" href="https://formblob.com/" rel="noopener ugc nofollow" target="_blank"> FormBlob </a>是为数不多的无代码表单构建器之一，它可以让您灵活地编辑表单，而不必担心丢失之前的状态。作为一个无代码工具，FormBlob允许任何人在2分钟内构建和发布令人惊叹的表单和调查。<a class="ae jo" href="https://build.formblob.com/builder" rel="noopener ugc nofollow" target="_blank">立即免费试用！</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Introduction to Docker and Container based development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和基于容器的开发简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-docker-and-container-based-development-6b04d249ea9?source=collection_archive---------31-----------------------#2021-06-03">https://medium.com/geekculture/introduction-to-docker-and-container-based-development-6b04d249ea9?source=collection_archive---------31-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5903830fe8cb24937315d9b598afc3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouEeCWzm2SILY-K82mGuoA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by Thinkstock</figcaption></figure><p id="8ef6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在早期，任何应用程序都将部署在物理服务器上。例如，我们有一个应用服务器、web服务器和数据库服务器，就像三个不同的服务器。那时，我们使用三个物理硬件箱。说到这一点，将会面临很多问题。我们必须维护它，需要空间，需要单独的网络，操作系统维护，成本，以及更多的浪费。因为我们的应用服务器或我们的web服务器和数据库服务器可能不会使用该机器100%的处理能力和该机器100%的内存。同样，这也是一种浪费。</p><p id="38f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以下一代(第二代)是虚拟机管理程序。</p><h2 id="5353" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">什么是Hypervisor？</h2><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/5d41d854e5967cd2a6ce5cf82669518a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YDsE7Y_ont_t5nyXNPUmQ.png"/></div></div></figure><p id="45b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虚拟机管理程序是能够创建虚拟机，然后管理和分配资源给它们的硬件、软件或固件。虚拟机是为使用主机资源而设置的机器。您可以任意多次划分这些资源，以容纳必要的虚拟机“来宾”(如果您听说过术语“虚拟机监视器”，您可能会对虚拟机监视器和虚拟机管理程序之间的区别感到好奇。它们是一样的。)</p><p id="9de0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，你可能有一台安装了8GB内存和Windows操作系统的电脑。如果您想运行需要Linux的程序，您可以创建一个运行Linux的虚拟机，然后使用一个管理程序来管理它的资源——例如，给它分配2GB的RAM。主机的一些资源将运行Windows操作系统，一些资源将分配给运行Linux的虚拟机。</p><p id="4c22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是更好的解决方案吗？ <br/>没有，因为它还有些问题。</p><p id="d177" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="ks">问题1 </em> —这里我们有一个不同的操作系统。所以现在有很多成本(许可成本)，路径那些，需要维护，需要更新像很多管理工作要做。</p><p id="b25e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问题2  —假设我们需要另一台网络服务器。因此，我们需要创建另一个虚拟机。我们需要安装另一个操作系统和另一个网络服务器。所以完成这个过程需要很多时间。</p><p id="6a73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于所有这些问题，有一个解决方案叫做容器化应用程序(Docker)。这是第三代。</p><p id="3d90" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在我们开始使用Docker/Container之前，您必须首先了解Docker和虚拟机之间的区别。那么，我们开始吧。</p><h1 id="8c69" class="kt jt hi bd ju ku kv kw jy kx ky kz kc la lb lc kf ld le lf ki lg lh li kl lj bi translated">Docker与虚拟机</h1><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/9144285779f347f31df96564e07dda32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snINBI0HUIYa0BWKyCO3Xg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Docker Container vs Virtual Machine</figcaption></figure><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/b1e224e750f403a37eb2d4a14eef7465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*5g5O5ePVl0JsKpAkLoQnbQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">Differences between these two</figcaption></figure><p id="778e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图像中，您会注意到一些主要差异，包括:</p><ul class=""><li id="c371" class="lm ln hi iw b ix iy jb jc jf lo jj lp jn lq jr lr ls lt lu bi translated">虚拟环境有一个管理程序层，而Docker有一个Docker/容器引擎层。</li><li id="506f" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">对于虚拟机，内存使用率非常高，而在Docker环境中，内存使用率非常低。</li><li id="ee9a" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">就性能而言，当您开始构建虚拟机时，特别是当您在一台服务器上有多个虚拟机时，性能会变得更差。有了Docker，由于单Docker引擎，性能总是很高。</li><li id="94fd" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">就可移植性而言，虚拟机并不理想。它们仍然依赖于主机操作系统，当您为了可移植性而使用虚拟机时，会发生许多问题。相比之下，Docker是为便携性而设计的。实际上，您可以在Docker容器中构建解决方案，无论托管在哪里，解决方案都保证像您构建的那样工作。</li><li id="4481" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">与Docker环境的启动时间相比，虚拟机的启动时间相当慢，在Docker环境中，启动几乎是瞬时的。</li></ul><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7280733f972498387c852c3dd4e9e277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfavJ-At5BlbHOGo4FKDhw.png"/></div></div></figure><ul class=""><li id="9796" class="lm ln hi iw b ix iy jb jc jf lo jj lp jn lq jr lr ls lt lu bi translated">使用虚拟机的另一个挑战是，如果环境中有未使用的内存，您无法重新分配它。如果您设置了一个有9gb内存的环境，其中有6gb是空闲的，那么您就不能对这些未使用的内存做任何事情。使用Docker，如果您有空闲内存，您可以在Docker环境中使用的其他容器之间重新分配和重用它。</li><li id="29ed" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">虚拟机的另一个挑战是，在单个环境中运行多个虚拟机会导致不稳定和性能问题。另一方面，Docker被设计为在同一个环境中运行多个容器——在托管的单个Docker引擎中运行更多的容器实际上会变得更好。</li><li id="2aad" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">虚拟机存在可移植性问题；该软件可以在一台机器上运行，但是如果您将该虚拟机移动到另一台机器上，突然有些软件将无法运行，因为有些依赖关系将无法正确继承。Docker被设计成能够跨多种环境运行，并且可以很容易地跨系统部署。</li><li id="1395" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">虚拟机的启动时间约为几分钟，而Docker环境的启动时间为几毫秒。</li></ul><p id="4cc2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在你已经知道了虚拟机和docker之间的区别，让我们通过理解Docker实际上是什么，从Docker的简要说明开始。</p><h1 id="0219" class="kt jt hi bd ju ku kv kw jy kx ky kz kc la lb lc kf ld le lf ki lg lh li kl lj bi translated">Docker是什么？</h1><p id="1685" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">Docker是一个操作系统虚拟化软件平台，它允许IT组织在Docker容器中轻松创建、部署和运行应用程序，Docker容器中包含所有依赖项。容器本身实际上只是一个非常轻量级的包，其中包含所有的指令和依赖项——比如框架、库和bin。</p><h1 id="7db7" class="kt jt hi bd ju ku kv kw jy kx ky kz kc la lb lc kf ld le lf ki lg lh li kl lj bi translated">Docker的优势</h1><ol class=""><li id="9933" class="lm ln hi iw b ix mb jb mc jf mg jj mh jn mi jr mj ls lt lu bi translated">投资回报和成本节约</li><li id="5c9d" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">标准化和生产力</li><li id="9240" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">兼容性和可维护性</li><li id="5371" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">简单快捷的配置</li><li id="c238" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">快速部署</li><li id="53cb" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">持续部署和测试</li><li id="9bd4" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">多云平台</li><li id="c9a9" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">隔离</li><li id="c57c" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">安全性</li></ol><h1 id="c46e" class="kt jt hi bd ju ku kv kw jy kx ky kz kc la lb lc kf ld le lf ki lg lh li kl lj bi translated">Docker是如何工作的？</h1><p id="2862" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">Docker通过Docker引擎工作，该引擎由两个关键元素组成:服务器和客户端；两者之间的通信是通过REST API进行的。服务器将指令传送给客户端。在较旧的Windows和Mac系统上，您可以利用Docker工具箱，它允许您使用Compose和Kitematic控制Docker引擎。</p><h1 id="f97d" class="kt jt hi bd ju ku kv kw jy kx ky kz kc la lb lc kf ld le lf ki lg lh li kl lj bi translated">Docker的组件</h1><ol class=""><li id="3d45" class="lm ln hi iw b ix mb jb mc jf mg jj mh jn mi jr mj ls lt lu bi translated">Docker客户端和服务器</li><li id="da2b" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">Docker图像</li><li id="ddba" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">Docker注册表</li><li id="04d6" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr mj ls lt lu bi translated">码头集装箱</li></ol><p id="6abc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们讨论每一个组成部分。</p><h2 id="5dad" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">Docker客户端和服务器</h2><p id="2edb" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">这是一个命令行指导的解决方案，您可以在Mac或Linux系统上使用终端从Docker客户机向Docker守护进程发出命令。Docker客户机和Docker主机之间的通信是通过REST API进行的。您可以发出类似的命令，比如Docker Pull命令，它会向守护进程发送一条指令，并通过与其他组件(映像、容器、注册表)进行交互来执行操作。Docker守护进程本身实际上是一个与操作系统交互并执行服务的服务器。正如您所想象的，Docker守护进程不断地监听REST API，看它是否需要执行任何特定的请求。如果您想要触发并启动整个过程，您需要在Docker守护进程中使用Dockered命令，这将启动您的所有表演。然后您有一个Docker主机，它允许您运行Docker守护进程和注册表。</p><h2 id="e01a" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">Docker图像</h2><p id="7fe0" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">Docker图像是包含Docker容器说明的模板。这个模板是用一种叫做YAML的语言编写的，它代表“又一种标记语言”。</p><p id="50fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Docker映像构建在YAML文件中，然后作为文件托管在Docker注册表中。图像有几个关键层，每个层都依赖于它下面的层。图像层是通过执行Dockerfile文件中的每个命令创建的，并且是只读格式。您从基础层开始，它通常包含您的基础映像和基础操作系统，然后在基础层之上还有一层依赖关系。这些指令包含在一个只读文件中，这个文件将成为你的docker文件。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/48c383156666ab6d17aeeac1f7ca6cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3j7_J3BDyBas07sZWc4UQ.png"/></div></div></figure><p id="1a98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们有四层指令:From、Pull、Run和CMD。它实际上看起来像什么？From命令基于Ubuntu创建一个层，然后我们将Docker存储库中的文件添加到该基础层的base命令中。</p><ul class=""><li id="e074" class="lm ln hi iw b ix iy jb jc jf lo jj lp jn lq jr lr ls lt lu bi translated">Pull:从Docker存储库中添加文件</li><li id="a908" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">运行:构建您的容器</li><li id="be14" class="lm ln hi iw b ix lv jb lw jf lx jj ly jn lz jr lr ls lt lu bi translated">CMD:指定在容器中运行哪个命令</li></ul><p id="d033" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，命令是运行Python。当我们设置多个容器时，将会发生的事情之一是，每个新的容器都在Docker环境中添加一个包含新图像的新层。每个容器都与Docker环境中的其他容器完全分离，因此您可以在每一层中创建自己独立的读写指令。有趣的是，如果你删除一个层，它上面的层也会被删除。</p><p id="ae95" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当你拉进一个层，但核心图像发生了变化，会发生什么？有趣的是，主图像本身是不能修改的。复制图像后，您可以在本地对其进行修改。您永远不能修改实际的基础映像。</p><h2 id="7e81" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">Docker注册表</h2><p id="e709" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">Docker registry是存放各种类型图像的地方，也是分发图像的地方。存储库本身只是Docker图像的集合，这些图像建立在用YAML语言编写的指令上，非常容易存储和共享。您可以给Docker图像命名标签，这样人们就可以很容易地在Docker注册表中找到并共享它们。开始管理注册中心的一种方法是使用任何人都可以访问的Docker hub注册中心。您也可以创建自己的注册表供内部使用。</p><p id="b240" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您在内部创建的注册表可以包含您创建的公共和私有映像。用于连接注册表的命令是Push和Pull。使用Push命令将您从本地管理器节点创建的新容器环境推送到Docker注册表，使用PullL命令检索从Docker注册表创建的新客户机(Docker映像)。同样，Pull命令从Docker注册表中拉出并检索Docker映像，Push命令允许您获取您创建的新命令，并将其推送到注册表，无论它是Docker hub还是您自己的私有注册表。</p><h2 id="7de8" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">码头集装箱</h2><p id="085c" class="pw-post-body-paragraph iu iv hi iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">Docker容器是捆绑在一起的应用程序及其依赖项的可执行包；它给出了您希望运行的解决方案的所有说明。由于内置的结构冗余，它非常轻便。该容器本身也是便携的。另一个好处是它完全独立运行。即使您运行的是容器，也保证不会受到任何主机操作系统安全性或独特设置的影响，这与虚拟机或非容器化环境不同。Docker环境的内存可以跨多个容器共享，这非常有用，尤其是当您有一个虚拟机，并且每个环境都有一个确定的内存量时。</p><p id="70f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Linux容器促进了高可用性计算的巨大转变，有许多工具集可以帮助您在容器中运行服务(甚至是整个操作系统)。Docker是众多选项中的一个，由开放容器倡议(OCI)定义，这是一个行业标准组织，旨在鼓励创新，同时避免供应商锁定的危险。他们可以选择容器工具链，包括Docker、OKD、Podman、rkt、OpenShift等等。</p><p id="4d06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您决定在容器中运行服务，那么您可能需要为托管和管理这些容器而设计的软件。这就是广为人知的容器编排。Kubernetes为各种容器运行时提供容器编排。</p><p id="0c3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参考资料:</p><div class="ml mm ez fb mn mo"><a href="https://opensource.com/resources/what-docker" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">Docker是什么？</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">Docker是一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。容器…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">opensource.com</p></div></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://www.redhat.com/en/topics/automation/what-is-orchestration" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">什么是编排？</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">编排是计算机系统、应用程序和…的自动化配置、管理和协调</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.redhat.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc io mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://blog.iron.io/what-is-a-docker-image/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">什么是Docker图像？(还有一个用IronWorker怎么用？)| The Iron.io博客</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">不管你喜不喜欢，容器已经成为运行几乎所有东西的基础设施的一部分。来自…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">blog.iron.io</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc io mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://www.infoworld.com/article/3204171/what-is-docker-the-spark-for-the-container-revolution.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">Docker是什么？容器革命的火花</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">Docker是一个基于容器构建应用程序的软件平台——小型轻量级执行…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.infoworld.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc io mo"/></div></div></a></div></div></div>    
</body>
</html>
<html>
<head>
<title>Part 4 of Building Workflow Driven .NET Applications with Elsa 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建工作流驱动的第4部分。使用Elsa 2的. NET应用程序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/part-4-of-building-workflow-driven-net-applications-with-elsa-2-d6699a6a247e?source=collection_archive---------4-----------------------#2021-08-02">https://medium.com/geekculture/part-4-of-building-workflow-driven-net-applications-with-elsa-2-d6699a6a247e?source=collection_archive---------4-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="63e4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">设置持久性和文件上传</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e6772d9958e27fe7c6cf77354749f520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDcj0rEH9P102mdrS9RaBQ.png"/></div></div></figure><p id="d089" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-3-of-building-workflow-driven-net-applications-with-elsa-2-ea930acb3fe2" rel="noopener">上一部分</a>中，我们学习了如何配置Elsa来提供来自JSON文件的工作流。</p><p id="f937" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一部分，我们将回到手头的演示应用程序，实现文档上传屏幕。这篇文章几乎没有什么是专门针对Elsa的，但它将为下一部分调用工作流提供一个良好的起点。</p><p id="aeee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们开始吧。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="408f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了存储上传的文件以便通过工作流进行处理之外，我们还希望存储一些关于这些文件的元数据。因此，我们将引入一个名为<code class="du kn ko kp kq b">Document</code>的领域模型。</p><p id="7619" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了存储文档实体，我们需要一个数据库。我们已经为Elsa使用了一个SQLite数据库，所以使用相同的数据库可能是有意义的。这就是我们将要做的。</p><p id="0662" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这部分的计划如下:</p><ul class=""><li id="577f" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">实现文件上传屏幕。</li><li id="d827" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">实现文档域模型。</li><li id="1f8c" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">实现数据库持久性。</li><li id="b644" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">使用存储实现本地文件存储。网</li></ul><p id="3c4d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦我们了解了这个基本的管道，在下一部分中，我们将会看到一些好的东西，在下一部分中，我们将执行处理上传文件的工作流。</p><h1 id="0399" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">文件上传屏幕</h1><p id="ad8a" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">为了实现文件上传功能，我们将重用主页(在<code class="du kn ko kp kq b">Index.cshtml</code>和<code class="du kn ko kp kq b">Index.cshtml.cs</code>中实现)</p><h2 id="c992" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">Index.cshtml</h2><p id="6e82" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">让我们从用以下内容替换<code class="du kn ko kp kq b">Index.cshtml</code>的全部内容开始:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div><figcaption class="ms mt et er es mu mv bd b be z dx">Index.cshtml</figcaption></figure><p id="1145" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将显示一个简单的表单，只有两个字段和一个提交按钮。然而，在编译之前，我们接下来需要更新<code class="du kn ko kp kq b">Index.cshtml.cs</code>文件。</p><h2 id="dfb5" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">index . cs</h2><p id="fd7b" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">打开<code class="du kn ko kp kq b">Index.cshtml.cs</code>,将其内容一次性替换为以下内容:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div><figcaption class="ms mt et er es mu mv bd b be z dx">Index.cshtml.cs</figcaption></figure><p id="1280" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里有几件值得注意的事情:</p><ul class=""><li id="8844" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">该类依赖于两个尚未定义的服务:<code class="du kn ko kp kq b">IDocumentTypeStore</code>和<code class="du kn ko kp kq b">IDocumentService</code>。</li><li id="6f14" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">在GET上，我们选择一个由<code class="du kn ko kp kq b">IDocumentTypeStore</code>提供的可用<em class="mw">文档类型</em>的列表，这是对尚未实现的数据访问的抽象。</li><li id="bf9b" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">在POST中，我们打开上传文件的流并调用<code class="du kn ko kp kq b">IDocumentService</code>服务上的<code class="du kn ko kp kq b">SaveDocumentAsync</code>。</li><li id="6279" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">然后我们重定向到一个叫做<code class="du kn ko kp kq b">"FileReceived"</code>的页面。</li></ul><h2 id="ff31" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">FileReceived.cshtml</h2><p id="77bd" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">该页面向用户显示一条简单的消息，表明文档已成功接收，并显示生成的文档ID。</p><p id="6ed1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<code class="du kn ko kp kq b">Pages</code>文件夹中创建该文件，内容如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="963a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建如下所示的“代码隐藏”文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="ec86" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们将简单地接收文档ID，从数据库中加载它，并返回一个HTTP 404-Not Found响应，以防提供未知的ID。未来的更新可能会实际显示文档的详细信息，比如它的状态，可能还会显示上传文件的下载链接。但是对于本教程来说，我们不需要这些。</p><p id="2e38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦我们实现了缺失的模型、服务和数据访问，该页面将允许用户选择文档类型、文件并提交表单。</p><p id="f63b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来让我们解决缺失的模型、服务和数据访问。</p><h1 id="9904" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">领域模型</h1><p id="bc06" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">领域模型和服务将主要由<code class="du kn ko kp kq b">DocumentManagement.Core</code>项目提供和实现。我说“大部分”，因为一些抽象，尽管由核心项目提供，将在<code class="du kn ko kp kq b">DocumentManagement.Persistence</code>中实现，正如我们将看到的。</p><h2 id="363c" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">文件</h2><p id="f924" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">创建一个名为<code class="du kn ko kp kq b">Models</code>的新文件夹，并创建一个名为<code class="du kn ko kp kq b">Document</code>的新类，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="8f46" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">文档状态</h2><p id="cfdd" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">在同一文件夹中，创建一个名为<code class="du kn ko kp kq b">DocumentStatus</code>的枚举，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="4487" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">文档类型</h2><p id="b42f" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">在同一个文件夹中，创建以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="2e60" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">域服务</h1><p id="02a9" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">域服务将提供抽象和一些具体的实现来处理持久化文档和存储文件。其中一些抽象在核心项目中实现，而其他的在其他地方实现，比如<code class="du kn ko kp kq b">IDocumentStore</code>的实现。</p><blockquote class="mx my mz"><p id="169e" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">这里设置的架构是我自己对洋葱架构的松散解释。重要的部分是我们将基础设施方面，如数据访问和IO从业务领域层中分离出来。</p></blockquote><h2 id="341d" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">IDocumentStore</h2><p id="5d49" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">创建一个名为Services的新文件夹，并添加以下C#接口:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="5530" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文档存储服务只有两个职责:</p><ul class=""><li id="5f46" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">将<code class="du kn ko kp kq b">Document</code>实体保存到数据库。</li><li id="56ee" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">通过ID从数据库加载<code class="du kn ko kp kq b">Document</code>实体。</li></ul><h2 id="b9db" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">IDocumentTypeStore</h2><p id="b0a6" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">用下面的代码创建<code class="du kn ko kp kq b">IDocumentTypeStore</code>接口:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="f32c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文档类型存储也有两个职责，即:</p><ul class=""><li id="d8f6" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">列出所有文档类型</li><li id="f20a" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">通过ID获取单个文档类型</li></ul><p id="7128" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们不会实现文档类型管理，所以不需要添加写操作。相反，我们将设置EF Core，用一组默认的文档类型作为数据库的种子。</p><h2 id="d211" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">ISystemClock &amp;系统时钟</h2><p id="cfc1" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">这个接口抽象了对<code class="du kn ko kp kq b">DateTime.UtcNow</code>的访问，它被认为是域的外部资源，这意味着我们应该将其抽象掉。当一个人想要写一些单元测试时，这也是有帮助的，允许我们提供一个接口的模拟实现。</p><p id="ce55" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建<code class="du kn ko kp kq b">ISystemClock.cs</code>文件并添加以下内容:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="179c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在同一文件夹中创建具体的实现:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="86e0" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">IFileStorage &amp;文件存储</h2><p id="fe59" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">文件存储服务负责将文件存储在某个地方。实现将依赖于Storage.NET抽象，因此我们的领域逻辑不直接依赖于具体的实现。相反，应该由我们的主机应用程序来配置文件访问。</p><p id="9c9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建如下<code class="du kn ko kp kq b">IFileStorage</code>接口:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="6caf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文件存储服务负责将数据流写入指定的目标(由文件名指定)，并从给定的文件名读取数据流。这由实现来处理。</p><p id="0346" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">按如下方式创建实现:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="27f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，我们依赖<code class="du kn ko kp kq b">DocumentStorageOptions</code>为我们提供一个工厂方法来创建一个<code class="du kn ko kp kq b">IBlobStorage</code>实例。</p><p id="344f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kn ko kp kq b">IBlobStorage</code>接口由<a class="ae kf" href="https://github.com/aloneguid/storage" rel="noopener ugc nofollow" target="_blank">Storage.Net</a>包提供，请务必安装:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="b854" class="mc lg hi kq b fi nh ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Core/DocumentManagement.Core.csproj package Storage.Net</span></pre><p id="f2ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还需要安装微软的<a class="ae kf" href="https://www.nuget.org/packages/Microsoft.Extensions.Options/6.0.0-preview.6.21352.12" rel="noopener ugc nofollow" target="_blank">。扩展选项</a>包以便使用<code class="du kn ko kp kq b">IOptions</code>:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="e54a" class="mc lg hi kq b fi nh ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Core/DocumentManagement.Core.csproj package <a class="ae kf" href="https://www.nuget.org/packages/Microsoft.Extensions.Options/6.0.0-preview.6.21352.12" rel="noopener ugc nofollow" target="_blank">Microsoft.Extensions.Options</a></span></pre><h2 id="8896" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">文档存储选项</h2><p id="aa96" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">创建一个名为Options的新文件夹，并添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="acdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">稍后我们将从<code class="du kn ko kp kq b">Startup</code>开始配置这些选项。</p><h2 id="63fb" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">IDocumentService &amp; DocumentService</h2><p id="2eff" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">文档服务只有两个职责:</p><ul class=""><li id="3b02" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">在磁盘上存储一个给定的文件流，创建一个文档实体，并将它存储在数据库中。</li><li id="7719" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">发布一个名为<code class="du kn ko kp kq b">NewDocumentReceived</code>的域事件</li></ul><p id="47e7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">按如下方式创建接口:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="0f56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">并使用以下代码创建实现:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="9b54" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kn ko kp kq b">IMediator</code>接口是MediatR包提供的，我们来安装一下:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="0056" class="mc lg hi kq b fi nh ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Core/DocumentManagement.Core.csproj package MediatR</span></pre><h2 id="e4ac" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">接收的新文档</h2><p id="4da1" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">每次创建新文档时，文档服务都会发布“收到新文档”事件。</p><p id="efe3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这允许应用程序执行某些任务。例如，我们可能想给某人发送一封关于新文档的电子邮件以供审阅。</p><blockquote class="mx my mz"><p id="403e" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">正如本系列的介绍部分所概述的，我们将使用工作流来实现这一点，但是通过使用这种中介模式，我们也可以简单地实现一个处理程序并做一些有趣的事情。这一切的美化是可扩展性，而不必污染核心领域库。相反，我们可以实现单独的类库，作为插入系统的“模块”。</p></blockquote><p id="3419" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为<code class="du kn ko kp kq b">Events</code>的新文件夹，并添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="f1e2" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">IsExternalInit</h2><p id="f789" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">由于我们在一个. NET标准项目中使用了一个名为“records”的<a class="ae kf" href="https://devblogs.microsoft.com/dotnet/c-9-0-on-the-record/" rel="noopener ugc nofollow" target="_blank"> C# 9特性，您可能会看到一个如下所示的编译器错误:</a></p><p id="b1be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mw">预定义类型'系统。必须定义或导入“runtime . compiler services . isexternalInit ”,才能声明仅限init的setter。</em></p><p id="23c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要解决这个问题，我们必须遵循提供的建议并定义<code class="du kn ko kp kq b">IsExternalInit</code>。为此，在<code class="du kn ko kp kq b">DocumentManagement.Core</code>项目文件夹的根目录下创建以下文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="560c" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">注册域服务</h2><p id="269c" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">在我们继续构建持久层之前，让我们首先创建一个扩展方法，以便于向服务容器注册我们的域服务。</p><p id="06ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为Extensions的新文件夹，并添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="dad2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">稍后，在我们完成持久层之后，我们将从web项目的<code class="du kn ko kp kq b">Startup</code>类中调用<code class="du kn ko kp kq b">AddDomainServices</code>。</p><h1 id="8e91" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">坚持</h1><p id="6868" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我们将在<code class="du kn ko kp kq b">DocumentManagement.Persistence</code>项目中实现持久层。</p><p id="35d4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更具体地说，我们将使用<a class="ae kf" href="https://docs.microsoft.com/en-us/ef/core/" rel="noopener ugc nofollow" target="_blank">实体框架核心</a>。</p><p id="3579" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们要做的是:</p><ul class=""><li id="a246" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">定义一个数据库上下文类。</li><li id="8240" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">定义一个设计时数据库上下文工厂类(用于生成迁移)。</li><li id="44d3" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">生成迁移。</li><li id="6b91" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">执行<code class="du kn ko kp kq b">IDocumentStore</code>和<code class="du kn ko kp kq b">IDocumentTypeStore</code></li><li id="2914" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">实施托管服务，在应用程序启动时自动运行迁移。</li><li id="e32d" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">提供一个扩展方法，向服务容器注册EF核心和域服务。</li></ul><p id="28ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在使用EF Core(及其SQLite provider)和托管服务之前，我们需要首先安装以下软件包:</p><ul class=""><li id="6c1b" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">微软。实体框架工作核心设计</li><li id="21f4" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">微软。EntityFrameworkCore.Sqlite</li><li id="f80e" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">微软。扩展.托管.抽象</li></ul><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="4090" class="mc lg hi kq b fi nh ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Persistence/DocumentManagement.Persistence.csproj package Microsoft.EntityFrameworkCore.Design</span><span id="cacb" class="mc lg hi kq b fi nl ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Persistence/DocumentManagement.Persistence.csproj package Microsoft.EntityFrameworkCore.Sqlite</span><span id="4b34" class="mc lg hi kq b fi nl ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Persistence/DocumentManagement.Persistence.csproj package Microsoft.Extensions.Hosting.Abstractions</span></pre><p id="1433" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还将添加一个对<code class="du kn ko kp kq b">DocumentManagement.Core</code>的项目引用，因为我们将实现几个接口:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="f2bf" class="mc lg hi kq b fi nh ni l nj nk">dotnet add DocumentManagement/src/DocumentManagement.Persistence/DocumentManagement.Persistence.csproj reference DocumentManagement/src/DocumentManagement.Core/DocumentManagement.Core.csproj</span></pre><p id="2d52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在持久性项目的根目录下创建一个新的<code class="du kn ko kp kq b">DocumentDbContext</code>类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="d384" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，我们用3种文档类型植入数据库:</p><ul class=""><li id="4a94" class="kr ks hi jl b jm jn jp jq js kt jw ku ka kv ke kw kx ky kz bi translated">"变更请求"</li><li id="6761" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">"离开请求"</li><li id="312f" class="kr ks hi jl b jm la jp lb js lc jw ld ka le ke kw kx ky kz bi translated">“身份验证”</li></ul><blockquote class="mx my mz"><p id="0ef6" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">我们可以潜在地添加额外的文档类型，并将它们与工作流相关联，而不必接触任何应用程序代码来引入新的文档类型。</p></blockquote><h2 id="53ca" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">文档数据库上下文设计工厂</h2><p id="7dd0" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">为了让<code class="du kn ko kp kq b">dotnet ef</code>工具生成迁移，我们应该实现一个DB context工厂类，工具可以用它来实例化DB context的新实例。</p><p id="4825" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们继续创建下面的类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="4129" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">生成迁移</h2><p id="fc42" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">现在我们已经有了DB上下文和工厂，让我们通过执行以下命令来生成迁移(确保从项目所在的目录运行该命令):</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="bff9" class="mc lg hi kq b fi nh ni l nj nk">dotnet ef migrations add Initial</span></pre><blockquote class="mx my mz"><p id="d821" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">确保文档管理。持续性项目目标<code class="du kn ko kp kq b"><em class="hi">net5.0</em></code> : <code class="du kn ko kp kq b"><em class="hi">&lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;</em></code></p></blockquote><p id="b6a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">应用迁移</p><p id="5c5b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">迁移就绪后，我们现在可以使用<code class="du kn ko kp kq b">dotnet ef</code>工具手动应用迁移，这样就可以了。事实上，在使用生产数据库时，这可能是最明智的做法。</p><p id="6881" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是在应用程序开发期间，尤其是在编写教程时，在应用程序启动时自动运行迁移会更方便。更不用说它也很酷！</p><p id="1aa5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，让我们创建一个托管服务来为我们解决这个问题。</p><p id="35eb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为<code class="du kn ko kp kq b">HostedServices</code>的新文件夹，并添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="5df5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">托管服务不仅是实现后台作业的好方法，而且非常适合执行使用<code class="du kn ko kp kq b">async/await</code>的应用程序启动代码，就像以编程方式应用迁移一样。以这种方式使用时，迁移将在应用程序准备好开始处理请求之前执行。</p><h2 id="ac9d" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">实现存储(又名存储库)</h2><p id="ea34" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">接下来让我们实现<code class="du kn ko kp kq b">IDocumentStore</code>和<code class="du kn ko kp kq b">IDocumentTypeStore</code>接口。</p><p id="f400" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为<code class="du kn ko kp kq b">Services</code>的新文件夹，并添加以下两个类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="7426" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里没什么特别的。这些类是一些EF核心操作的简单包装器。有趣的部分可能是我们正在注入一个数据库上下文<em class="mw">工厂</em>，而不是直接注入一个实际的数据库上下文。虽然这两种选择都可行，但我更喜欢工厂策略，以便尽可能保持DB上下文的短暂性，从而大大简化包含后台任务的异步应用程序(此处未显示)。</p><blockquote class="mx my mz"><p id="8e9a" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">一个可以考虑的改进是通过在服务器端而不是客户端执行一个upsert操作，使<code class="du kn ko kp kq b"><em class="hi">EFCoreDocumentStore</em></code>类的<code class="du kn ko kp kq b"><em class="hi">SaveAsync</em></code>方法成为线程安全的。现在，如果两个线程试图同时保存一个具有相同ID的文档对象，很有可能在数据库中得到两个记录。</p><p id="bffe" class="jj jk mw jl b jm jn ij jo jp jq im jr na jt ju jv nb jx jy jz nc kb kc kd ke hb bi translated">要做服务器端的upsert操作，你可以考虑使用第三方软件包，比如<a class="ae kf" href="https://github.com/borisdj/EFCore.BulkExtensions" rel="noopener ugc nofollow" target="_blank"> EFCore。BulkExtensions </a>，<a class="ae kf" href="https://github.com/artiomchi/FlexLabs.Upsert" rel="noopener ugc nofollow" target="_blank"> FlexLabs。向上插入</a>或<a class="ae kf" href="https://entityframework-extensions.net/" rel="noopener ugc nofollow" target="_blank">实体框架扩展</a>。</p></blockquote><h2 id="9d4c" class="mc lg hi bd lh md me mf ll mg mh mi lp js mj mk lr jw ml mm lt ka mn mo lv mp bi translated">注册持久性服务</h2><p id="4eb3" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">现在，让我们创建一个扩展方法，以便于向服务容器注册我们的持久性服务。</p><p id="c19b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为<code class="du kn ko kp kq b">Extensions</code>的新文件夹，并添加以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="9ad9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当被调用时，它将负责注册EF核心、我们的商店实现，当然还有我们的迁移运行器。</p><h1 id="80e2" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">启动</h1><p id="5883" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">我们已经做了所有的工作，现在剩下的就是调用注册域和持久性服务的两个扩展方法，并配置前面介绍的文件存储选项。</p><p id="7068" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将以下私有方法添加到<code class="du kn ko kp kq b">Startup</code>类的底部:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="e6ba" class="mc lg hi kq b fi nh ni l nj nk">private void AddDomainServices(IServiceCollection services)<br/>{<br/>    services.AddDomainServices();<br/>    <br/>    // Configure Storage for DocumentStorage.<br/>    services.Configure&lt;DocumentStorageOptions&gt;(options =&gt; options.BlobStorageFactory = () =&gt; StorageFactory.Blobs.DirectoryFiles(Path.Combine(Environment.ContentRootPath, "App_Data/Uploads")));<br/>}</span><span id="19d2" class="mc lg hi kq b fi nl ni l nj nk">private void AddPersistenceServices(IServiceCollection services, string dbConnectionString)<br/>{<br/>    services.AddDomainPersistence(dbConnectionString);<br/>}</span></pre><p id="6cf3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后在我们调用<code class="du kn ko kp kq b">AddworkflowServices</code>的那一行之后调用这些方法:</p><pre class="iy iz ja jb fd nd kq ne nf aw ng bi"><span id="7bee" class="mc lg hi kq b fi nh ni l nj nk">// Domain services.<br/>AddDomainServices(services);</span><span id="e8b4" class="mc lg hi kq b fi nl ni l nj nk">// Persistence.<br/>AddPersistenceServices(services, dbConnectionString);</span></pre><h1 id="37a7" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">尝试一下</h1><p id="aa22" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">此时，我们应该能够运行应用程序，上传文件，并确认文件已保存且文档记录已创建，如下面的屏幕记录所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/501f723a4ad9d38f822b8acfb8d6adfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G5utUVPgLzCPyY2QyCYKfg.gif"/></div></div></figure><h1 id="d45c" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">然后</h1><p id="746c" class="pw-post-body-paragraph jj jk hi jl b jm lx ij jo jp ly im jr js lz ju jv jw ma jy jz ka mb kc kd ke hb bi translated">这一部分不一定引入任何与Elsa相关的新内容，但是我们确实建立了一个相当不错的基础，现在我们可以在这个基础上开始挂接自定义逻辑来处理上传的文档。通过发布“收到新文档”域事件，这变得很容易。</p><p id="05a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-5-of-building-workflow-driven-net-applications-with-elsa-2-8c1f36f7b720" rel="noopener">的下一部分</a>中，我们将通过在<code class="du kn ko kp kq b">DocumentManagement.Workflows</code>项目中实现一个处理程序来很好地利用这个事件，这个处理程序将依次调用与文档类型相关联的适当的工作流(如果有的话)。</p></div></div>    
</body>
</html>
# 如何使用 Node 从头开始认证？JS 和 MongoDB

> 原文：<https://medium.com/geekculture/how-to-authenticate-from-scratch-using-node-js-and-mongodb-505bdd05eec9?source=collection_archive---------4----------------------->

## 了解 auth 如何工作的基本知识，并制作一个没有 passport 或其替代品的基本系统。

![](img/0cf1361b0ca89e40b16dd0e7dc63d635.png)

Photo by [AltumCode](https://unsplash.com/@altumcode?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

有大量的库可用于在每个框架和数据库系统中实现身份验证。虽然其中一些完全能够满足任何一般的身份认证需求，但在某些情况下，我们可能希望对用户登录我们产品的方式进行更高级别的控制，在这种情况下，我们希望从头开始。

然而，在我们开始之前，请注意，如果您的需求是基本的，那么最好是使用像 passport 这样的库。JS，它由在 web 安全领域知识渊博的人不断更新。阅读本文将有助于您理解基础知识，但是让您的站点免受攻击是一个完全不同的话题。

## 一些重要的观点

1.  每一步给出的代码也包含前一步的代码。所以最好的方法是理解文章的所有内容，并最终在最后一步使用代码。但是，如果您希望并排编写代码，这也完全没问题。
2.  假设您具备 Node 的基本知识。JS 和 MongoDB。虽然我会在后面解释一切，但是很难在一篇文章中介绍节点和身份验证。

话虽如此，让我们继续这篇文章的目的。然而，在我们跳到代码之前，让我们把问题分成更小的子问题，我们可以一个一个地解决，最终解决所有问题。

1.  注册新用户
2.  让用户登录
3.  注销用户。
4.  保持用户登录会话。

这里的前 3 点相当直接，它们的意义不需要太多的解释。然而，为了理解我们为什么需要第四点，我需要你想一想当你在笔记本电脑上登录脸书的时候。它是如何工作的？你每次刷新页面或者转到脸书境内的其他页面时都会被注销吗？如果你在新标签页打开脸书，你需要重新登录吗？不。那是那个点将帮助我们做的。这将有助于浏览器记住我们是否登录，并使用它直到会话过期。

# 代码

我们现在可以开始逐一解决以上几点。但在此之前，让我们添加第 0 个步骤。

0.设置项目，并建立一个数据库，用户数据将被存储。

当然，我们将需要一个数据库，在那里登录的细节被使用。让我们先这样做。

## 设置项目和数据库

注意默认情况下，以下步骤适用于 Mac 和 Linux 系统。如果您希望在 Windows 上运行它，请使用 [Gitbash](https://git-scm.com/downloads) 来代替默认的 PowerShell。

对于项目设置，请遵循以下步骤:

1.  打开系统上的终端。
2.  移动到您想要创建项目的目录。
3.  运行`mkdir authDemo; cd authDemo.`这将在这里创建一个名为‘auth demo’的目录，并将我们移至其中。
4.  运行`npm init -y.`这将在目录中创建节点所需的强制性 package.json 文件。
5.  跑`npm i -S mongoose express bcrypt express-session`。所有在-S 后面的名字都是我们项目需要的包。我们正在安装它们。
6.  运行`touch app.js`。这将创建一个 app.js 文件，其中包含我们所有的代码。在你最喜欢的代码编辑器中打开这个文件。

现在我们的项目已经立项了。我们可以开始建立数据库了。在 app.js 文件中，编写以下代码:

让我们明白我们做了什么:

1.  Require 语句:第 1 行和第 2 行简单地将我们需要的包包含到我们的文件中。
2.  mongoose.connect:这将我们连接到我们的数据库，该数据库目前命名为“myapp”。
3.  Schema:在 mongo 中，我们需要定义一个结构来定义集合中的条目的外观。这是模式。在这里，对于一个用户，我们已经说过我们将有一个`username`，它将是一个字符串，和`hashedPw`，它将是一个字符串。这两个字段都是必需的，即不能为空。我们为什么使用 hashedPw(散列密码)而不仅仅是密码，这将在本文的后面部分解释清楚。
4.  模型:在 MongoDB 中，我们使用模型通过代码完成所有的工作。因此，我们在第 15 行创建模型，并将其存储在`User`中。
5.  App.listen:这一行告诉我们的代码在终端上运行`node app.js`来运行节点文件时，在端口 3000 上运行服务器。因此，现在我们将能够访问我们在 localhost:3000/上创建的路由

好了，现在我们的数据库也建立好了。让我们进入第一步，即注册。

## 注册新用户

要添加注册路径，请将 app.js 文件更改为:

让我们在这里检查一下修改过的行:

1.  第 3 行:我们需要一个新模块 bcrypt。这将是我们将使用的哈希算法。我们将讨论更多关于散列的内容，但是让我们先了解所有其他的要点。
2.  第 22–30 行:这是我们注册用户的 POST 路径。这里，我们对用户名和密码的值进行了硬编码，这些值通常可以从表单中获得。接下来，我们生成散列密码，这将在后面讨论。一旦我们有了这两样东西，我们就用这些细节创建一个用户，并把它添加到我们的数据库中。我们现在返回刚刚创建的用户，作为来自路由的响应。

## 散列法

好的，现在让我们来理解什么是哈希，以及我们为什么要这么做。如果我们试图在这里完全详细地理解散列，这将花费大量的时间，而且在我们非常有限的场景中是不相关的。因此，散列简而言之就是对你的密码进行加密。我们为什么需要它？当然是安全。我知道我提到过我们不会处理安全问题，但是散列已经成为 auth 本身的基础之一，因此忽略它不是一个明智的决定。

回到它是什么，散列只是一些文本的单向加密。那是什么意思？这意味着它将我们给它的一组字符转换成一个很长的随机字符串，这有两个你需要知道的主要特征:

1.  相同的字符串总是被转换成相同的随机字符串。
2.  原始字符串不能从哈希后的字符串重新跟踪。

以散列形式存储密码是常见的做法，绝对没有一家好公司会将密码存储为纯文本。如果你想了解更多关于哈希的知识，你可以点击查看[。](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)

也就是说，现在我们可以安全地进入下一步，即登录。

## 让用户登录

要添加登录路由，请将您的文件更改为:

如果您看到这里，只添加了第 33–46 行。最初，我们采用用户名和密码的硬编码值，这与我们在注册路由中采用的值相同。然后，我们从我们的数据库中找到一个具有该用户名的用户，并将其存储在`user.` 中。接下来，我们将给定用户的密码与我们收到的密码进行比较。请记住，我们存储的密码是哈希版本，因此我们不能直接比较这两个字符串的值。我们将使用`bcrypt.compare()`，它是库中用于比较的内置函数。

> 注意:不要试图手动散列你收到的密码，然后比较字符串，这是行不通的。要理解为什么，请阅读上面链接中的盐的概念。

接下来，我们在`matchstatus`变量中接收 true 或 false，这告诉我们密码是否正确。我们根据它做我们的行动。

> 注意:目前，我们只是在做 console.log 或 res.send。这实际上并不是让我们登录。这只是检查细节对错的代码。当我们讨论会话时，实际的日志部分实际上发生在下面。发生这种情况时，我们将更新此路线。

现在我们已经完成了登录路径，让我们转到会话。请注意，我们在登出之前讨论会话，因为没有它登出将没有任何意义。

## 向站点添加会话

首先，可能有许多人不知道什么是会议，以及我们需要他们做什么。会话基本上就是这个词所暗示的。当您离开一个长时间登录而不使用它的网站时，您可能已经多次看到类似“会话到期”的短语。这就是我们正在进行的课程。

作为一种基本的理解，你可以把它理解为浏览器保存我们浏览的记忆。一般来说，HTTP 请求没有内存。因此，即使您正确登录，也无法让网站的其他人知道您已经成功登录。这是会话在 auth 中出现的地方。由于会话内存是由浏览器存储的，所以无论我们将访问站点内的哪个 URL，会话内的数据都将始终存在。

因此，我们让某人登录的方法可能是这样的:我们在会话中创建一个名为`user` 的变量(当然，您可以有任何变量名)。当用户输入正确的详细信息进行身份验证时，我们可以将会话中的`user`变量设置为用户详细信息。如果未登录，它将保持为空。因此，在任何时候，如果我们需要检查用户是否登录，我们只需要检查这个变量是否为空或是否有有效值。

现在让我们看看代码:

虽然解释让它看起来像是我们在做非常非常复杂的事情，但实际上它很容易编码。让我们看看上面代码的补充内容:

1.  第 4-10 行:我们需要并配置 express-session，这是我们用来创建和维护会话的库。这些行将在浏览器中配置会话，并使我们非常容易访问它，正如我们现在将看到的。
2.  第 47 行:`req.session.user = user;`:如上所述，我们在会话中设置了一个名为`user`的变量(我们通过`req.session)`对刚刚登录的用户进行访问)。

这成功地让我们登录，我们现在可以在以后访问登录用户的详细信息，无论我们在哪个页面上。

现在让我们看看最后也是最简单的路线，注销路线。

## 将用户注销

如上所述，要注销用户，我们可以将 req.session.user 设置为 null。同样的代码如下:

这里，我们刚刚在第 55-58 行添加了注销路线。我们将`req.session.user`设置为空，然后返回响应。

## 包扎

好了，这就完成了基本认证的所有代码。现在，您可以(希望)轻松地从头开始实现注册、登录和注销功能。就像我前面提到的，这个设计本来可以有很多改进，主要是在安全性方面。请注意，这个系统在攻击面前一点也不安全，这当然是不可取的。然而，这完全是另外一个话题，改天再说。目前，这是我所能提供的一切。感谢您抽出时间阅读这篇文章，希望对您有所帮助。干杯！
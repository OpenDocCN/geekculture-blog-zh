<html>
<head>
<title>Building a Linked List System From Scratch in C#, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中从头开始构建一个链表系统，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/building-a-linked-list-system-from-scratch-in-c-part-1-51aa6c68ea19?source=collection_archive---------5-----------------------#2021-09-17">https://medium.com/geekculture/building-a-linked-list-system-from-scratch-in-c-part-1-51aa6c68ea19?source=collection_archive---------5-----------------------#2021-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="efba" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">练习变戏法变量引用的有趣练习</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/345d6ddba9ce2e8dd6e00cdc310300a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXCvVVXGoJaJyoa4qllo7Q.png"/></div></div></figure><p id="ad7e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我过去曾经写过关于链表的<a class="ae kf" rel="noopener" href="/geekculture/roll-initiative-part-2-d7ab2d82ef27">用处。今天，我想通过创建我自己的链表功能实现来深入了解链表是如何工作的。</a></p><p id="9c59" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意:链表<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-5.0" rel="noopener ugc nofollow" target="_blank">已经在C#中实现</a>。本练习将复制该功能，但是您完全没有必要为您的工作实现您自己的版本。我这样做是为了理解一些特性是如何工作的，是为了教育目的，而不是为了实用目的。</p><h2 id="6786" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">什么是链表？</h2><p id="8cff" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">标题图像给出了链表如何操作的要点。链表不是简单的值列表，而是维护对其他值的引用。这形成了价值之间的“链接”链。上图代表了一个“双向链表”，因为每个值节点都引用了它之前和之后的节点，使得双向遍历变得简单。单向链表(只指向链中的下一个节点)和循环链表(最后一个节点指向第一个节点，形成一个圈)是另外两种链表。</p><p id="62c5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于引用链，很容易在列表中间插入或删除值，而不会增加复杂性。对传统链表的类似操作需要遍历整个链表，但是使用链表，我们不需要任何迭代就可以得到相同的结果。</p><h2 id="143a" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">双向链表</h2><p id="0560" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">在接下来的几篇文章中，我们将创建一个双链接列表<t>类。目标是对C#的<em class="lg"> LinkedList &lt; T &gt; () </em>类的每个公共方法和属性进行逆向工程。即:</t></p><ul class=""><li id="23ed" class="lh li hi jl b jm jn jp jq js lj jw lk ka ll ke lm ln lo lp bi translated"><em class="lg">第一个</em>和<em class="lg">最后一个</em>属性分别指向链的两端。</li><li id="075b" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> Count </em>属性引用链中的链接数。</li><li id="1440" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> AddFirst(T t) </em>和<em class="lg"> AddLast(T t) </em>方法，在链的两端添加新的节点。</li><li id="2136" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> AddBefore(Node node) </em>和<em class="lg"> AddAfter(Node node) </em>方法，在链的两端之间的某处添加节点。</li><li id="c922" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> Remove(Node node) </em>、<em class="lg"> RemoveFirst() </em>和<em class="lg"> RemoveLast() </em>方法，这些方法使对链中特定节点的引用无效，并在必要时封闭链中的间隙。</li><li id="4606" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> Contains(T t) </em> bool返回方法，用于查找某个值是否存在于链中。</li><li id="107b" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> Find(T t) </em>和<em class="lg"> FindLast(T t) </em>从链的任意一端进行搜索的方法。</li><li id="f78f" class="lh li hi jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated"><em class="lg"> CopyTo(T[] array，int index) </em>方法将每个节点的值复制到一个数组中的特定索引处。</li></ul><h2 id="7f17" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">节点类</h2><p id="f3d1" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们从<em class="lg">节点</em>类开始。这个类定义了链表中元素的必要属性，并提供了创建新节点的构造函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/a935ff1e6dc2652c1258a07a1034abae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hrjwSbmBSwKCIKfDNx7zw.png"/></div></div></figure><p id="5d16" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个类放在<em class="lg">double linked list&lt;T&gt;T5】类中，以便于引用。构造函数接受一个表示节点预期值的参数。相邻节点引用属性(<em class="lg">上一个</em>和<em class="lg">下一个</em>)以null开始。</em></p><h2 id="af03" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">double linked list<t>类</t></h2><p id="f822" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">既然我们已经定义了节点，我们可以在<em class="lg">doublelinkedlist&lt;T&gt;</em>类本身中创建一些属性和字段。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/56a7dd3125b84e6e50ecf24dc5952e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtUvY14PX_iV_fn_954sLg.png"/></div></div></figure><p id="01df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们首先定义列表的前面是一个名为<em class="lg"> _head的节点变量。</em><em class="lg">第一个</em>属性自然需要指向这个字段。找到最后一个节点需要一些逻辑，我们将在下一节讨论(现在，我们可以容忍一些红色的曲线)。</p><p id="2313" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，该类中的<em class="lg">下一个</em>和<em class="lg">上一个</em>属性被设置为指向头节点的<em class="lg">下一个</em>和<em class="lg">上一个</em>属性。</p><p id="b788" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们定义一个<em class="lg"> _count </em>字段，其对应的属性包含将计数限制在0以上的逻辑。我们只希望这个类实例设置它的计数值，所以我们将setter设置为私有。</p><h2 id="2bcc" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated"><strong class="ak">GetLastNode()方法</strong></h2><p id="2902" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">为了让<em class="lg">最后的</em>属性工作，让我们从<em class="lg"> GetLastNode() </em>方法开始。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/c4ef101dbb0ba2352953709df6f9dbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uv3eH1N_o35_Lzr7ZQQfmA.png"/></div></div></figure><p id="8ba9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们简单地从_head开始，一次向前移动一个节点，直到下一个节点为空(意味着链中不再有节点)。一旦我们有了它，我们就返回节点。轻松点。</p><h2 id="2063" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated"><strong class="ak">add first(T T)和AddLast(T t)方法</strong></h2><p id="e192" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">现在，我们实际创建一些节点怎么样？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/b06d888ea7c154776a8de7e43f9972c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWGiufCavReXrM-x2AUAEA.png"/></div></div></figure><p id="7f24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要添加一个节点，我们将方法的参数传递到<em class="lg">节点</em>构造函数中，并增加<em class="lg">计数</em>属性。</p><p id="554b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果这个节点是新的头，我们首先检查当前头是否为空。如果不是，我们将新节点的<em class="lg">下一个</em>属性指向头节点，头节点的<em class="lg">上一个</em>属性指向新节点。最后，不管头部是否为空，我们都将新节点作为头部。</p><p id="1b12" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果这个节点是新的尾部，我们首先检查头部是否为空——如果是，那么列表是空的，我们只需要将新节点指定为头部。否则，我们需要运行<em class="lg"> GetLastNode() </em>方法。一旦我们有了最后一个节点，我们可以将新节点分配给最后一个节点的<em class="lg"> Next </em>属性，然后将最后一个节点分配给新节点的<em class="lg"> Previous </em>属性。这实际上使新节点成为最后一个节点。</p><h2 id="cc26" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">测试到目前为止的类</h2><p id="f23f" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们现在有足够的基本功能来运行一些单元测试，并确保一切正常。如果你需要知道如何在Unity中设置单元测试，一定要看看我的文章。</p><p id="6642" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我知道我将测试所有的双向链表方法，所以我将从创建一个助手方法来构建测试数据开始。该方法将创建一个由10个整数组成的数组，取值范围为0-9。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/122250c92d738043d466ac929ed3b3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYY1jDWSdWt8k2S7dEACwQ.png"/></div></div></figure><p id="294b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于第一个测试方法，我们将测试<em class="lg"> AddLast(T t) </em>、<em class="lg"> Count、</em>和<em class="lg"> Next </em>，因为它们在创建新列表时都会用到。我将创建一些测试数据，然后尝试<em class="lg"> AddLast(T t) </em>直到数组中的所有数据都在链表中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/3e9aa2106b23f4c97aa3ff8117318b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6Y6V6n4fP7D71MxUgj_UA.png"/></div></div></figure><p id="fc31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个过程中，我们将检查增加的价值是否与期望值相匹配。我们还将比较Count属性和数组的长度，以确保我们在添加节点时正确地跟踪它们。</p><p id="f9f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们将再调用一个helper方法来比较测试数据数组和测试列表。我们将在未来的测试中使用这种方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/58da2df80535d67c5b226509dead05b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DDHRMOLzKztTIs5yE8a5w.png"/></div></div></figure><p id="2eee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们遍历索引时，我们将检查是否在数组结束前到达了一个意外的空节点。如果一切顺利，我们将比较当前索引和当前节点的测试数据。如果它们匹配，我们移动到下一个节点并迭代索引。否则<em class="lg"> Assert() </em>方法会告诉我们哪里的数据不匹配。</p><p id="52c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还将制作一个类似的测试方法来检查<em class="lg"> AddFirst(T t) </em>类和<em class="lg"> Previous </em>属性是否工作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/78a7efa7e0e6658876e2daf163a0ebdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfIra6VYhMimwqeEtvrfew.png"/></div></div></figure><p id="c6a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们再次构建测试数据，并使用它来填充一个列表。我们这样做是为了确保数据符合我们的预期。我们不需要使用前面创建的向前推进助手，而是需要向后推进这个列表来确认数据匹配。当我们遍历索引时，我们确保列表也在快速遍历。最后，我们确认节点的值匹配数组的相应索引，并且<em class="lg"> Previous </em>属性按预期工作。</p><p id="3f11" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们看看这些测试结果如何:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/589f33eabd24123ddd9138b94c34f6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*xX0JBs0FcUkzq399EuFtvA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Hooray!</figcaption></figure><p id="9cc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是第一部分。在下一篇文章中，我们将处理<em class="lg"> AddBefore(Node node)、AddAfter(Node node) </em>和我们的三个搜索方法:<em class="lg"> Contains(T t)、Find(T t)、</em>和<em class="lg"> FindLast(T t)。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Let's Decide if React-Redux is a Thing of the Past after React Context API.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们来决定React-Redux是不是React Context API之后的过去式。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lets-decide-if-react-redux-is-a-thing-of-the-past-after-react-context-api-182409a762bf?source=collection_archive---------6-----------------------#2022-05-07">https://medium.com/geekculture/lets-decide-if-react-redux-is-a-thing-of-the-past-after-react-context-api-182409a762bf?source=collection_archive---------6-----------------------#2022-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="626d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">对于所有的react-redux，让我们来理解react提供的上下文钩子。严格来说是一篇技术文章。</h2></div><p id="5922" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React-Redux现在已经成为前端开发的恐龙了。大多数为他们的前端开发者使用React JS库的应用程序/组织都使用Redux进行状态管理。在引入上下文挂钩之前，如果我们在不使用任何状态管理工具的情况下向任何人询问复杂React应用程序的开发人员，这将是一个有趣的妙语。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/066bb718d5379f6047ff888beef2c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v45bHgGSjKzcALny"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Photo by <a class="ae kj" href="https://unsplash.com/@joeel56?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicole Wolf</a> on <a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="2a37" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">Table of content<br/></strong>· <a class="ae kj" href="#cab1" rel="noopener ugc nofollow">Basic Introduction</a><br/>· <a class="ae kj" href="#9b29" rel="noopener ugc nofollow">Let's create the counterpart using useContext.</a><br/>  ∘ <a class="ae kj" href="#5090" rel="noopener ugc nofollow">1. Create a Basic folder structure.</a><br/>  ∘ <a class="ae kj" href="#13bd" rel="noopener ugc nofollow">2. Adding createContext.</a><br/>  ∘ <a class="ae kj" href="#9433" rel="noopener ugc nofollow">3. Adding React Context Provider</a><br/>  ∘ <a class="ae kj" href="#6332" rel="noopener ugc nofollow">4. Wrapping the child components</a><br/>  ∘ <a class="ae kj" href="#f01b" rel="noopener ugc nofollow">5. Creating Consumer.</a><br/>  ∘ <a class="ae kj" href="#2f6a" rel="noopener ugc nofollow">6. Expected Result</a><br/>  ∘ <a class="ae kj" href="#4085" rel="noopener ugc nofollow">7. Start the application</a><br/>· <a class="ae kj" href="#ad24" rel="noopener ugc nofollow">React Context Provider vs Consumer</a><br/>· <a class="ae kj" href="#b73c" rel="noopener ugc nofollow">Redux vs Context API</a><br/>· <a class="ae kj" href="#ff55" rel="noopener ugc nofollow">Closing Thoughts.</a><br/>· <a class="ae kj" href="#0e44" rel="noopener ugc nofollow">About The Author</a></span></pre><h1 id="cab1" class="kv kq hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">基本介绍</h1><p id="18b9" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">Redux可以说是状态管理用的最多的库了。现在，为了将Redux与React JS应用程序连接起来，我们必须使用一些中间件，如React saga或React thunk。这个中间件帮助实现业务逻辑、API调用，并根据条件更新缩减器。</p><p id="c205" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，对于那些没有使用过redux的人来说，它只是一个全球商店，被认为是事实的唯一来源。总是有一个过程来更新状态，即从组件分派一个动作。此外，我们必须使用另一个模块，即react-redux来连接ReactJS组件和redux存储。</p><p id="1713" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都增加了React JS应用程序的包大小。包的大小是我们一直试图减少的。考虑一个场景，我们不必使用所有这些库。总括来说，我们将取消大约3个主要模块，如redux、react-redux、react-thunk等。</p><p id="6477" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些模块/库是重载的，不是你的常规库。因此，让系统在不使用所有这些东西的情况下工作似乎是另一种选择。React团队引入了上下文作为将值从父传递给子的替代方式。我们将通过存储当前状态的上下文直接传递数据，而不是通过道具钻取将道具传递给嵌套的孩子。</p><p id="2a25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们更新之前使用react-redux编写的示例应用程序，并尝试使用useContext转换它。我们不会在本教程中讨论react-redux部分，因为这超出了本教程的范围。</p><p id="3144" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果你有兴趣探索用redux设置的react saga，你可以参考这个系列教程，它会帮助你理解相同的东西。<a class="ae kj" href="https://www.mindroast.com/post/redux-saga-tutorial-setup-with-react-redux" rel="noopener ugc nofollow" target="_blank">点击这里。</a></p><h1 id="9b29" class="kv kq hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">让我们使用useContext来创建副本。</h1><h2 id="5090" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">1.创建一个基本的文件夹结构。</h2><p id="9e86" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">首先，我们将创建一个名为context的文件夹，其中包含所有与我们将要创建的不同类型的上下文相关的代码。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es me"><img src="../Images/bb4ff136679d635147c62908b5cad563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*toOHzyO74aOW8FOMvihyFA.gif"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">React Context vs Redux</figcaption></figure><p id="b4b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在该文件夹中，我们将创建两个名为globalContext.js和globalState.js的文件。这两个文件都将是我们的全局上下文的包装。我们将从每个想要直接共享数据的组件导入全局上下文。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mf"><img src="../Images/1e29b28fab7f66e0a7c0d4a48009c0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5RriqdJXAi3Xu3xKrH58g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">The folder structure of React createContext.</figcaption></figure><h2 id="13bd" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">2.正在添加创建上下文。</h2><p id="dbcd" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">让我们深入研究一下global context.js文件。以下是代码，可以随意复制试试。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="3ea9" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">// context/globalContext.js</strong></span><span id="dae7" class="kp kq hi kl b fi mg ks l kt ku">import {createContext} from 'react';</span><span id="ac3f" class="kp kq hi kl b fi mg ks l kt ku">const GlobalContext = createContext();</span><span id="a90f" class="kp kq hi kl b fi mg ks l kt ku">export default GlobalContext;</span></pre><p id="97be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个文件只是创建了一个名为全局上下文的上下文。这将提供子组件的值。</p><h2 id="9433" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">3.添加React上下文提供程序</h2><p id="dc33" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">另一个文件是我们的provider文件，它将保存将在其他组件中共享的上下文的状态。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="5230" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">// context/globalState.js</strong></span><span id="87cf" class="kp kq hi kl b fi mg ks l kt ku">import { useState } from "react";<br/>import GlobalContext from "./globalContext";</span><span id="2525" class="kp kq hi kl b fi mg ks l kt ku">const GlobalState = (props)=&gt;{</span><span id="e3eb" class="kp kq hi kl b fi mg ks l kt ku">const [title, setTitle] = useState('This from Context')</span><span id="bdfe" class="kp kq hi kl b fi mg ks l kt ku">return(<br/>        &lt;GlobalContext.Provider value={{title, setTitle}}&gt;<br/>            {props.children}<br/>        &lt;/GlobalContext.Provider&gt;<br/>);<br/>}</span><span id="f92d" class="kp kq hi kl b fi mg ks l kt ku">export default GlobalState;</span></pre><p id="cf6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在全局状态文件中，我们使用了globalContext提供程序，并将值向下传递。</p><p id="6ab3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还使用了useState钩子，它的初始值是“This from context”。和setTitle方法，该方法将用于更新子组件的状态。就像普通的父子函数通过props来更新父组件的值一样。</p><h2 id="6332" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">4.包装子组件</h2><p id="687e" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">现在需要将值向下传递，所以我们需要将子组件放在全局状态组件下。</p><p id="aa43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将在我们的App.js文件中完成。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="a35c" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">// App.js</strong></span><span id="f49d" class="kp kq hi kl b fi mg ks l kt ku">import './App.css';</span><span id="85ec" class="kp kq hi kl b fi mg ks l kt ku">./container/FunctionBasedComponent';</span><span id="b82f" class="kp kq hi kl b fi mg ks l kt ku">import FunctionBasedContextComponent from './container/FunctionBasedContextComponent';</span><span id="d8f7" class="kp kq hi kl b fi mg ks l kt ku">import GlobalState from './context/globalState';</span><span id="d6ad" class="kp kq hi kl b fi mg ks l kt ku">function App() {<br/>return (<br/>    &lt;div className="App"&gt;<br/>        &lt;GlobalState&gt;<br/>            &lt;FunctionBasedContextComponent /&gt;<br/>        &lt;/GlobalState&gt;<br/>    &lt;/div&gt;<br/> );<br/>}</span><span id="ce28" class="kp kq hi kl b fi mg ks l kt ku">export default App;</span></pre><p id="9e31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们导入了全局状态，并包装了所有可能需要数据的子组件。因为我们已经将它创建为一个全局上下文，所以我们已经将所有组件包装在状态下，但是我们也可以在粒度级别上这样做。</p><p id="f1bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这是由你来决定，什么最适合你的应用。</p><h2 id="f01b" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">5.创造消费者。</h2><p id="d87d" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">最后一步是创建一个组件，它将使用这个全局状态，就像我们在任何react redux应用程序中所做的那样。对于redux，我们通常使用react-redux库提供的connect方法，但是这里我们将使用react上下文API提供的消费者API。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="8769" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">// container/FunctionBasedContextComponent.js</strong></span><span id="ffe5" class="kp kq hi kl b fi mg ks l kt ku">import React, { useEffect, useContext } from 'react';</span><span id="93fb" class="kp kq hi kl b fi mg ks l kt ku">import GlobalContext from '../context/globalContext';</span><span id="5e31" class="kp kq hi kl b fi mg ks l kt ku">function FunctionBasedContextComponent(props) {<br/>const {title, setTitle} = useContext(GlobalContext);</span><span id="b394" class="kp kq hi kl b fi mg ks l kt ku">useEffect(() =&gt; {<br/>    setTimeout(() =&gt; {<br/>        setTitle('Title updated after 4 Seconds of timeout.')<br/>    }, 4000);<br/>}, []);</span><span id="525d" class="kp kq hi kl b fi mg ks l kt ku">return &lt;h1&gt;{title}&lt;/h1&gt;;<br/>}</span><span id="11d6" class="kp kq hi kl b fi mg ks l kt ku">export default FunctionBasedContextComponent;</span></pre><p id="194b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个功能组件中，我们没有做什么特别的事情，而是使用useContext钩子来导入全局上下文提供的值。</p><p id="566c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以析构这个值，这里的标题是out状态，setTitle是可以用来更新标题状态值的方法。</p><h2 id="2f6a" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">6.预期结果</h2><p id="6eaf" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">此外，我们还使用了一个useEffect挂钩，它会在4秒钟后将标题的值更新为“4秒钟超时后标题更新”。来自“这来自上下文”。</p><h2 id="4085" class="kp kq hi bd kw lr ls lt la lu lv lw le jg lx ly lg jk lz ma li jo mb mc lk md bi translated">7.启动应用程序</h2><p id="0373" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">现在，我们可以开始实现并运行代码了。只需遵循以下命令。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="bd8d" class="kp kq hi kl b fi kr ks l kt ku">&gt; npm install.<br/>&gt; npm start </span></pre><p id="6fa4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到类似下面的屏幕。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mh"><img src="../Images/29a0f29d9fbc1705a6881a3136c5679d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*IXiD_Fj3fZGNOOCpG5otww.gif"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Final application rendering using react context API</figcaption></figure><h1 id="ad24" class="kv kq hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">对上下文提供者和消费者做出反应</h1><p id="a0bf" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">此外，上下文提供者是向上下文提供状态的一种方式。它存储的值可用于将值下钻到所需的组件。无论何时任何组件被包装在提供者中，我们都可以使用这个范围。</p><p id="e8e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，顾名思义，消费者是用来消费上下文的。提供者提供的值可以在嵌套的子组件中使用，无需任何钻取。</p><p id="f2d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常有两种方法来使用上下文。使用useContext的方法之一，我们在上面的教程中已经讨论过了。useContext通常在有多个消费者需要消费时使用。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="750c" class="kp kq hi kl b fi kr ks l kt ku">const {title, setTitle} = useContext(GlobalContext);</span></pre><p id="7e71" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是另一方面，下面的方法通常在类内组件中使用，因为我们在基于类的组件中不使用钩子。这两种方法在最终结果中几乎是相似的，但是如果我们订阅了各种上下文，使用useContext会使您的代码更整洁一些。休息永远是开发者的选择。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="926c" class="kp kq hi kl b fi kr ks l kt ku">&lt;GlobalContext.Consumer&gt;<br/>    {value =&gt; { }}<br/>&lt;/GlobalContext.Consumer&gt;</span></pre><h1 id="b73c" class="kv kq hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">Redux vs上下文API</h1><p id="afac" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">Redux被业界广泛接受，因为许多组织已经在使用它。Redux应用程序的代码结构非常简洁。你把所有具体的东西都放在正确的位置上。例如，你有动作，异步动作，减速器等。</p><p id="e7cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但恰恰相反，上下文API的依赖性非常小。您不必依赖外部包来运行您的应用程序。如果你能够用Context API破解完美架构的代码，我会称之为双赢。因为包的大小将会减小，因为我们不必像Redux那样创建设置。</p><p id="f64d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，使用其中任何一种方法都没有什么做不到的。此外，上下文API没有像Redux这样的浏览器扩展，因为这在调试解决方案时非常有用。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mi"><img src="../Images/069a8f1e3fdbd0b024cf70ab3323ce48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOmX-X0RzNxE6Z3TZhQbfQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Screenshot of Redux DevTool</figcaption></figure><h1 id="ff55" class="kv kq hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">关闭思路。</h1><p id="b3ee" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">React上下文API是React生态系统的新成员。他们已经习惯了这个系统，但是和两个Redux相比，还没有那么普遍。</p><p id="28db" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管redux需要一点复杂的实现，但是一旦基本的设置完成，这个项目就会变得很顺利。之后我们没有太多的重构。只要加上条件，它就会继续下去。Redux非常适合大型复杂的应用程序。</p><p id="f24a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Context API可以称为开箱即用的解决方案，Redux可以定义为一个强大的状态管理工具。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="0e44" class="kv kq hi bd kw kx mq kz la lb mr ld le io ms ip lg ir mt is li iu mu iv lk ll bi translated">关于作者</h1><p id="60b8" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">Apoorv Tomar是一名软件开发人员，也是Mindroast的一员。你可以在<a class="ae kj" href="https://twitter.com/apoorvtomar_" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae kj" href="https://www.linkedin.com/in/apoorvtomar/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae kj" href="https://t.me/ApoorvTomar" rel="noopener ugc nofollow" target="_blank">电报</a>和<a class="ae kj" href="https://www.instagram.com/apoorvsinghtomar/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上和他联系。订阅<a class="ae kj" href="https://www.mindroast.com/newsletter" rel="noopener ugc nofollow" target="_blank">简讯</a>获取最新策划内容。不要犹豫在任何平台上说“你好”,只需说明你在哪里找到我的资料</p></div></div>    
</body>
</html>
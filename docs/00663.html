<html>
<head>
<title>De-duping the Duplication in Services Featuring: Swagger/OpenAPI and AJV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消除服务中的重复:Swagger/OpenAPI和AJV</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/de-duping-the-duplication-in-services-featuring-swagger-openapi-and-ajv-abd22c8c764e?source=collection_archive---------10-----------------------#2021-03-09">https://medium.com/geekculture/de-duping-the-duplication-in-services-featuring-swagger-openapi-and-ajv-abd22c8c764e?source=collection_archive---------10-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f289c93b1540d84c98c643f9f0c6cf08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdlzEW8cPHvAk-dqaFJhMQ.jpeg"/></div></div></figure><p id="b6ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的设计更容易改变。然而，当涉及到API文档和服务验证时，ETC的这一原则往往会被忽略。在这里，不要重复你自己[干]的租户经常被忽略，留下了具有多个文件的服务，这些文件可能跨越数百甚至数千行代码，具有大量的重复。</p><p id="1c65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">带有整体验证引擎和华而不实的文档的服务开发变成了一种技术债务。由于这些引擎和文档经常位于正在改变的代码表面区域之外，它们变得不同步的可能性增加了。</p><h1 id="777e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">那么解决办法是什么？</strong></h1><p id="b67a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我提出了一种新的设计模式来开发您的swagger文档，然后让您的OpenAPI规范驱动您的验证。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="b9c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了上面的使命陈述，让我们确保我们都在工具链的同一页上。NodeJS和JavaScript生态系统是什么，这是理解我们最终目标的重要一步。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="9ab9" class="lh jp hi ld b fi li lj l lk ll"><strong class="ld hj">Service Documentation</strong>: Swagger 3.0 -- OpenAPI</span><span id="6924" class="lh jp hi ld b fi lm lj l lk ll"><strong class="ld hj">Service Validation Engine</strong>: AJV</span><span id="b02d" class="lh jp hi ld b fi lm lj l lk ll"><strong class="ld hj">node-modules</strong>: swagger-jsdoc, openapi-validator-middleware</span><span id="0356" class="lh jp hi ld b fi lm lj l lk ll"><strong class="ld hj">NodeJS Framework</strong>: Express</span></pre><p id="4738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我承认存在其他验证引擎(JOI和express-validator，仅举几个例子),但AJV提供了一个简单的JSON feed，而且人们已经为它编写了OpenAPI包装器！至于NodeJS框架，我选择使用express，因为那是我更熟悉的。没有理由不支持koa，因为这个包甚至支持koa！</p><h1 id="39ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">那么，您具体是如何消除重复的呢？</h1><p id="d588" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">以上每个包都有一个具体的目标。</p><p id="5950" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<code class="du ln lo lp ld b">swagger-jsdoc</code>,我们将坚持早先的说法，即更容易改变。我们将把我们的swagger定义放在路由文件中。这将允许未来的开发人员看到与代码共存的规范，使他们更清楚地知道，当他们在途中更改代码时，要更改那个规范。</p><p id="025c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ln lo lp ld b">openapi-validator-middleware</code>能够消费生成的OpenAPI Swagger文档，并将其用于验证引擎。这个包是AJV的一个包装器，它允许我们对大量的重复删除进行最小的代码修改。</p><h1 id="4728" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">那么这看起来像什么？</h1><p id="f37b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">因此，让我们从验证部分开始，为此，我们看一下描述我们的express应用程序的文件<code class="du ln lo lp ld b">app.js</code>。</p><p id="a21a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那就先做最重要的事；让我们导入我们的模块</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="3df4" class="lh jp hi ld b fi li lj l lk ll">const swaggerValidation = require(‘openapi-validator-middleware’);</span></pre><p id="e261" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在导入之后，我们只需要将它指向我们的Swagger文档来配置它。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="3d81" class="lh jp hi ld b fi li lj l lk ll">swaggerValidation.init('swagger.yml');</span></pre><p id="c38e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了用我们的swagger配置的验证引擎，我们只需要在我们的路由定义中将它作为中间件来实施。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="c4df" class="lh jp hi ld b fi li lj l lk ll">api.get('/simple', swaggerValidation.validate, getSimple)</span></pre><p id="3d4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这3行代码，我们已经配置了我们的验证引擎，根据我们的swagger规范对它进行了调整，现在它正在针对<code class="du ln lo lp ld b">/simple</code>路线执行它的规则。你不再需要维护一个单独的文件Joi/AJV文件来维护你的服务验证——酷吧？</p><h1 id="869b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">好吧，但是关于斯瓦格的文件？那不是很可怕吗？</h1><p id="efbf" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">答案是肯定的；因为您的swagger文件现在必须包含所有的验证逻辑，所以它会很大——但是它应该已经包含了这些信息。考虑到这一点，我们将让我们的另一个包<code class="du ln lo lp ld b">swagger-jsdoc</code>来负责维护swagger文件。我们的目标更容易改变，记得吗？因此，我们将把我们的swagger定义与我们的路由文件逻辑放在一起。由于代码和文档都放在一个地方，当开发人员进行更改时，他们有望更积极地保持一切同步。更不用说任何改变参数/请求体的验证需求的需求也会立即反映在swagger文档中。</p><p id="b7da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们之前定义的<code class="du ln lo lp ld b">get-simple.js</code></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="f07f" class="lh jp hi ld b fi li lj l lk ll">/**<br/> * <a class="ae lq" href="http://twitter.com/openapi" rel="noopener ugc nofollow" target="_blank">@openapi</a><br/> *  /v1/acme:<br/> *    get:<br/> *      description: a simple get route that returns the `foo` query param<br/> *      parameters:<br/> *        - in: query<br/> *          name: foo<br/> *          schema:<br/> *            type: string<br/> *            minimum: 3<br/> *      responses:<br/> *        200:<br/> *          description: a object witth the echoed query param.<br/> *          content:<br/> *            type: object<br/> *            properties:<br/> *              foo:<br/> *                type: string<br/> *                minimum: 3<br/> */<br/>const getSimple = (req, res) =&gt; {<br/>  const { foo } = req.query;</span><span id="169a" class="lh jp hi ld b fi lm lj l lk ll">return res.status(200).json({ foo });<br/>};</span><span id="493d" class="lh jp hi ld b fi lm lj l lk ll">module.exports = getSimple;</span></pre><h1 id="8d3d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">等等，我有一些问题！</h1><blockquote class="lr ls lt"><p id="92cc" class="iq ir lu is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">一个4行的路由文件有20行注释吗？为什么foo是重复的？我以为我们在消除重复？</p></blockquote><p id="723f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要回答这些问题，是的，你会有一大堆文档。这是不可避免的，因为我们需要有swagger的外壳，但它应该有助于新开发人员查看该文件，了解请求和响应的期望。</p><p id="27ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于你看到的复制品，我马上就要讲到了！这是为了方便显示复制。利用YAML的特点，我们实际上可以消除一些重复，同时进一步划分我们的定义。</p><h1 id="8b60" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">好的——开始吧，你是怎么做的？</h1><p id="4408" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">利用YAML锚，我们可以为我们的字段创建类似变量的原子定义。但是首先，让我们把我们的服务做得更好一些，创建一些文件/目录。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="49ee" class="lh jp hi ld b fi li lj l lk ll">mkdir swagger<br/>touch swagger/first-name.yml<br/>touch swagger/last-name.yml<br/>touch swagger/user-id.yml</span></pre><p id="fe70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，这个swagger文件夹将包含我们所有的swagger组件定义。这将确保我们的定义在各种途径中使用时保持一致，同时消除重复，因为它们现在可以共享一个真实的来源——这个文件夹。</p><p id="7ef2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">档案</strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2cec" class="lh jp hi ld b fi li lj l lk ll"><em class="lu"># swagger/first-name.yml</em><br/>x-template:<br/>  firstName: &amp;firstName<br/>    type: string<br/>    minimum: 1<br/>    maximum: 30<br/>    description: the first name of our acme user</span><span id="1dcb" class="lh jp hi ld b fi lm lj l lk ll"># swagger/last-name.yml<br/>x-template:<br/>  lastName: &amp;lastName<br/>    type: string<br/>    minimum: 1<br/>    maximum: 30<br/>    description: the last name of our acme user</span><span id="60ce" class="lh jp hi ld b fi lm lj l lk ll"># swagger/user-id.yml<br/>x-template:<br/>  userId: &amp;userId<br/>    type: string<br/>    minimum: 4<br/>    maximum: 4<br/>    pattern: '[0-9]{4}'<br/>    description: the unique identifier of our acme user</span></pre><p id="096e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着我们的大摇大摆领域的组成部分创建，让我们自旋一些新的路线使用我们的新领域！</p><p id="8d09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lu"> put-create.js </em> </strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="3a7e" class="lh jp hi ld b fi li lj l lk ll">/**<br/> * <a class="ae lq" href="http://twitter.com/openapi" rel="noopener ugc nofollow" target="_blank">@openapi</a><br/> *  /v1/acme/create:<br/> *    put:<br/> *      description: creates a fake user of the acme service<br/> *      requestBody:<br/> *        content:<br/> *          application/json:<br/> *            schema:<br/> *              type: object<br/> *              required:<br/> *                - firstName<br/> *                - lastName<br/> *              properties:<br/> *                firstName: *firstName<br/> *                lastName: *lastName<br/> *      responses:<br/> *        200:<br/> *          description: a object with the echoed firstName, lastName and a random userId.<br/> *          content:<br/> *            type: object<br/> *            properties:<br/> *              firstName: *firstName<br/> *              lastName: *lastName<br/> *              userId: *userId<br/> */<br/>const putCreate = (req, res) =&gt; {<br/>  const { firstName, lastName } = req.body;<br/>  const userId = Math.floor(1000 + Math.random() * 9000);</span><span id="4fb9" class="lh jp hi ld b fi lm lj l lk ll">return res.status(200).json({ firstName, lastName, userId: `${userId}` });<br/>};</span><span id="c5e7" class="lh jp hi ld b fi lm lj l lk ll">module.exports = putCreate;</span></pre><p id="64ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看，我们已经创建了一个更复杂的请求/响应对象，注释的总行数增加了3行！最重要的是，即使你对这个文件没有经验，你也可以通过阅读第一个注释来确定它的用例以及请求/响应契约。看到更容易改变的福利了吗？假设您有允许60个字符姓氏的需求，您可以简单地更改swagger文件<code class="du ln lo lp ld b">last-name.yml</code>,您将得到更新的Swagger文档以及执行它的验证规则！</p><h1 id="9625" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">好吧——我被说服了，但是你如何把这些评论变成一个狂妄自大的医生呢？</h1><p id="0522" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><em class="lu"> swagger-generator.mjs </em></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="3b6c" class="lh jp hi ld b fi li lj l lk ll">import fs from 'fs';<br/>import swaggerJsdoc from 'swagger-jsdoc';<br/>import { dirname } from 'path';<br/>import { fileURLToPath } from 'url';<br/>import packageJson from './package.json';</span><span id="8582" class="lh jp hi ld b fi lm lj l lk ll">const __dirname = dirname(fileURLToPath(import.meta.url));</span><span id="3aa1" class="lh jp hi ld b fi lm lj l lk ll">const options = {<br/>  format: '.yml',<br/>  definition: {<br/>    openapi: '3.0.0',<br/>    info: {<br/>      title: packageJson.name,<br/>      version: packageJson.version,<br/>    },<br/>  },<br/>  apis: ['./src/routes/*.js', './swagger/**/**.yml'], // files containing annotations<br/>};</span><span id="e68d" class="lh jp hi ld b fi lm lj l lk ll">const runtime = async () =&gt; {<br/>  try {<br/>    const openapiSpecification = await swaggerJsdoc(options);<br/>    fs.writeFileSync(`${__dirname}/swagger.yml`, openapiSpecification);<br/>  } catch (e) {<br/>    console.log('broke', e);<br/>  }<br/>};</span><span id="3cbe" class="lh jp hi ld b fi lm lj l lk ll">runtime();</span></pre><p id="2868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的脚本将生成OpenAPI规范，并生成验证引擎将使用的<code class="du ln lo lp ld b">swagger.yml </code>。为了帮助实施良好的实践，并且因为所有的开发人员(包括我自己)都不善于记住事情，所以我个人利用Husky来确保生成这个文件。这将作为一个预提交钩子来完成，它将运行上面的脚本，后跟一个<code class="du ln lo lp ld b">git add swagger.yml</code>命令。</p><h1 id="07b2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">但是你怎么能强制执行呢？</h1><p id="0e37" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">CI CI CI！因为我们只有一个预提交钩子来生成我们的swagger.yml，所以有一个合理的担心。毕竟，比没有文档更糟糕的是糟糕的/过时的文档。</p><blockquote class="lr ls lt"><p id="f994" class="iq ir lu is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">如果开发人员用<code class="du ln lo lp ld b">-n</code>提交或者只是从web-ui提交，会怎么样</p></blockquote><p id="deca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，让我先说他们是一个怪物(特别是如果他们和<code class="du ln lo lp ld b">-n</code>在一起的话)！).但是为了帮助实施这一点，在创建/捆绑您的应用程序时，这应该是一个构建步骤。对于测试用例，我们可以重新运行<code class="du ln lo lp ld b">swaggerJsDoc</code>命令，并直接将其输出与<code class="du ln lo lp ld b">swagger.yml</code>输出进行比较。任何差异并停止执行。</p><h1 id="e636" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">示例/参考</h1><h2 id="2704" class="lh jp hi bd jq ly lz ma ju mb mc md jy jb me mf kc jf mg mh kg jj mi mj kk mk bi translated">回购展示了这一过程:</h2><div class="ml mm ez fb mn mo"><a href="https://github.com/goldsziggy/ms-acme-openapi-ajv" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">goldsziggy/ms-acme-openapi-ajv</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">本报告的目的是为媒体文章提供帮助。本回购中的代码不代表…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc io mo"/></div></div></a></div><h2 id="9b2e" class="lh jp hi bd jq ly lz ma ju mb mc md jy jb me mf kc jf mg mh kg jj mi mj kk mk bi translated">swagger-jsdoc</h2><div class="ml mm ez fb mn mo"><a href="https://www.npmjs.com/package/swagger-jsdoc" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">swagger-jsdoc</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">这个库读取JSDoc注释的源代码，并生成一个OpenAPI (Swagger)规范。想象一下拥有…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.npmjs.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc io mo"/></div></div></a></div><h2 id="687c" class="lh jp hi bd jq ly lz ma ju mb mc md jy jb me mf kc jf mg mh kg jj mi mj kk mk bi translated">open API-验证器-中间件</h2><div class="ml mm ez fb mn mo"><a href="https://www.npmjs.com/package/openapi-validator-middleware" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">open API-验证器-中间件</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">该软件包根据Swagger/OpenAPI定义在Express、Koa或Fastify应用程序中提供数据验证…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">www.npmjs.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc io mo"/></div></div></a></div></div></div>    
</body>
</html>
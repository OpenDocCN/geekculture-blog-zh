<html>
<head>
<title>Machine Learning Pipeline for Beginners -Retail Returns Dataset Part-I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的机器学习管道——零售退货数据集第一部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-i-2132cfcc9e6a?source=collection_archive---------11-----------------------#2021-05-01">https://medium.com/geekculture/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-i-2132cfcc9e6a?source=collection_archive---------11-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/08b35d1dca0b54cc091808276c9767df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*az0eLms286TQ__19_tI-Ew.jpeg"/></div></div></figure><div class=""/><p id="43e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能听说过<em class="jo">机器学习，</em>考虑到它在过去十年中是多么著名和有影响力。许多人可能对它的工作原理没有足够的了解，但仍然认为它是“神奇的”,我们使用数据准确地预测将会发生什么。随着该领域的应用越来越多，没有该领域经验的人发现这很有趣，并希望探索幕后真正发生的事情。在本文中，我们将探索这种魔力，并学习在给定一些数据的情况下构建一个机器学习(ML)模型。它将帮助初学者理解基本的ML管道。</p><p id="6ab4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们谈谈我们的数据集。我们的数据集来自一家在线零售商店，该商店希望了解哪些客户会退回他们购买的商品。在商品被退回的情况下，商店不得不面对运费方面的损失，因为大多数商店提供免费送货。为了减少这种损失，商店旨在发现消费者退货的可能性，以便采取一些应对措施。您可以从第2部分文章底部的Github链接下载数据集和完整的代码。让我们看看我们正在处理的数据集内部:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="812f" class="jy jz ht ju b fi ka kb l kc kd">#Reading the dataset<br/>df=pd.read_csv("training_set.csv")</span><span id="c573" class="jy jz ht ju b fi ke kb l kc kd">#finding total rows and columns<br/>print ("Columns in the dataset: ", df.shape[1])<br/>print ("Rows in the dataset   : ", df.shape[0])</span><span id="0efb" class="jy jz ht ju b fi ke kb l kc kd">df.head()</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kf"><img src="../Images/f8da165831e63b8036aab22025aac91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gm4vTwGmO2YEf87JYn4hoQ.png"/></div></div></figure><p id="a99e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们注意到我们总共有14列。在这14个变量中，<em class="jo"> return </em>列是目标变量，其中值1表示客户将返回一个项目，值0表示客户不会返回。我们在数据集中总共有100，000行。让我们看看目标特性中的值的比率:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b5f6" class="jy jz ht ju b fi ka kb l kc kd">df['return'].value_counts()</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es kg"><img src="../Images/11cf956c0842f92598b1e2596b0cc690.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*CIrm2hsQiGT5MCnf5kyXCw.png"/></div></figure><p id="fec5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们注意到在我们的数据集中有几乎相等数量的<em class="jo"> 1的</em>和<em class="jo"> 0的</em>。这方面否定了阶级不平衡，给了我们一个平衡的数据集。</p><p id="3e15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们的目标是讨论整个ML管道，我们不能直接进入建模。我们首先要使我们的数据集适合建模。这包括数据清理、预处理、特征工程和特征选择。让我们从数据清理步骤开始。</p><h2 id="4c20" class="jy jz ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">数据清理和预处理:</h2><p id="84d6" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们的首要任务是寻找空值或缺失值，因为它们与我们的模型无关。我们可以在每一列中搜索它们，如下所示:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="11ce" class="jy jz ht ju b fi ka kb l kc kd">#checking the count of null values in each column<br/>df.isna().sum()</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/6e3b9098178305a2686b76bdf0e21372.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*uUPYxLRx1x13jAzepWHqYA.png"/></div></figure><p id="0c79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，大多数列都有0个空值，但是有2列有几个空值。有一些方法可以恰当地处理这些价值观。我将解释如下3个基本方法:</p><ol class=""><li id="9d9c" class="lg lh ht is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">从数据集中完全删除这两列。然而，由于只有大约10 %的值丢失，这看起来不是一个有利的选择。此外，这些列似乎对以后的使用很有用。</li><li id="45c4" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">删除缺少值的行。如果存在可以忽略不计数量的空值，这种方法可以工作，但是在这种情况下，我们可能会丢失大约18，000条数据记录，这是完全不可接受的。</li><li id="303e" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">用相应列的平均值或中值替换缺失的数据值。这个步骤也被称为<em class="jo">数据输入。</em>它包括计算已知值的平均值或中值，并用它代替空值。这是一种很好的做法，因为它不会丢失数据。不幸的是，在我们的例子中，我们无法计算平均日期并替换它，因此我们将不得不稍后执行特征工程。</li></ol><p id="34c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们继续上面的选项3，并继续进行所述的特征工程步骤，如下所示:</p><h2 id="bed0" class="jy jz ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">特征工程:</h2><p id="fc39" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在本节中，我们将格式化几个特性(列)，使它们对我们更有用。我们看到日期/时间格式有几个特性。要从中提取有意义的信息，我们先从<em class="jo"> user_dob说起。</em>为了使这个特性简单易懂，我们通过从当前日期中减去出生日期来提取客户的年龄。此外，因为我们知道这个列有空值，所以我们稍后用计算出的年龄的中值替换它们。相关的代码看起来会像这样:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3afc" class="jy jz ht ju b fi ka kb l kc kd"><em class="jo">#function to convert date to speicif format</em><br/><strong class="ju hu">def</strong> __datetime(date_str):<br/>    <br/>    <em class="jo">#for null values set dob as current date to identify them as their age will be 0</em><br/>    <strong class="ju hu">if</strong> date_str<strong class="ju hu">!=</strong>date_str:<br/>        date_str<strong class="ju hu">=</strong>str(date<strong class="ju hu">.</strong>today())<br/><br/>    <strong class="ju hu">return</strong> datetime<strong class="ju hu">.</strong>strptime(date_str, '%Y-%m-%d')<br/><br/><em class="jo">#subtracting dob with current date and converting to years.</em><br/>df['Age']<strong class="ju hu">=</strong>(__datetime(str(date<strong class="ju hu">.</strong>today()))<strong class="ju hu">-</strong>df<strong class="ju hu">.</strong>user_dob<strong class="ju hu">.</strong>apply(__datetime))<strong class="ju hu">/</strong>365<br/>df['Age']<strong class="ju hu">=</strong>df<strong class="ju hu">.</strong>Age<strong class="ju hu">.</strong>apply(<strong class="ju hu">lambda</strong> x: int(str(x)<strong class="ju hu">.</strong>split(" ")[0]) )</span></pre><p id="358a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码计算所有消费者的年龄。为了执行数据输入，一个好的做法是找到每个类的平均值或中值，并用这个新计算的值替换每个空值。我发现中间值通常比平均值好，并在本文中使用了它。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e658" class="jy jz ht ju b fi ka kb l kc kd">#function to impute 0 values<br/>def imputing_age(x,y):<br/>    x0=x[x['return']==1] # subset comprising of return<br/>    x1=x[x['return']==0] # subset comprising of non-return<br/>    x0[y] =x0[y].map( lambda x : x0[y].median() if x == 0 else x) #replacing returns 0s with returns median<br/>    x1[y] =x1[y].map( lambda x : x1[y].median() if x == 0 else x) #replacing non-returns 0s with non-returns median<br/>    return pd.concat([x0,x1])</span><span id="4eab" class="jy jz ht ju b fi ke kb l kc kd">#Imputing 0 values with median for each class<br/>df=imputing_age(df,'Age')</span></pre><p id="c718" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，我们已经成功地将日期/时间数据转换为数字数据。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/ee8ce46d8e540903c0f9d5fea7524138.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*Uwj3mRZgOyuRmSsCloMxcg.png"/></div></figure><p id="4c6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以对交付和订单日期执行类似的步骤。我们可以通过从交付日期中减去订单日期来计算订单交付所需的时间。这可能是一个可行的功能，因为如果他们的交付花费了大量的时间，消费者可能会退货。此外，我们可以从日期中找到交付月份或工作日，因为周一交付的项目有更高的退货机会，或者在复活节或圣诞节期间订购的项目更有可能被保留。请在第2部分文章底部提到的Github链接上找到这一步的完整代码。</p><p id="7fb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算完这些特征后，我们可以像以前一样对<em class="jo">交货时间</em>、<em class="jo">月份</em>、<em class="jo">工作日</em>进行类似的数据输入。我们可以做类似的步骤，比如为<em class="jo"> user_reg </em>计算年龄。提取有用的特征后，我们可以如下移除原始列:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9e46" class="jy jz ht ju b fi ka kb l kc kd">df.drop(['order_date','delivery_date','user_reg_date','user_dob'], axis=1,inplace=True)</span></pre><h2 id="a792" class="jy jz ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">分类列:</h2><p id="8473" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">机器学习模型是基于数学输入的。他们只理解数值，并对其执行计算以产生结果。由于我们的数据集包含非数值数据，也称为分类数据，我们必须对其进行处理，以使其可用。让我们看看我们的分类数据列:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="10b7" class="jy jz ht ju b fi ka kb l kc kd">#getting total columns<br/>cols=df.columns<br/>print("Total Columns in dataset are: ",list(cols))</span><span id="b736" class="jy jz ht ju b fi ke kb l kc kd">#getting only numerical columns<br/>numerical_cols=df._get_numeric_data().columns<br/>print("Numerical Columns in dataset are: ",list(numerical_cols))</span><span id="fc53" class="jy jz ht ju b fi ke kb l kc kd">#getting categorical columns by subtracting numerical columns from total columns<br/>categorical_cols=set(list(cols))-set(list(numerical_cols))<br/>print("Categorical Columns in dataset are: ",list(categorical_cols))</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/24a2cd0a42b95efd18b6e27f503bd108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogvd9eISYgvw39Kjz5e_zg.png"/></div></div></figure><p id="5497" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们观察到有多个分类列。对于月份和工作日，我们可以很容易地将它们转换成数字格式，1–12表示月份，0–6表示工作日。对于其他列，我们有多种方法，也就是说，我们可以一次性编码，或者只给一个值分配一个数字标签。在这个初学者教程中，我倾向于通过使用内置库来使用标签编码。让我们对<em class="jo"> user_title </em>进行标签编码:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e0b7" class="jy jz ht ju b fi ka kb l kc kd">le = preprocessing.LabelEncoder()<br/>print ("Before Encoding: ",df['user_title'].unique())</span><span id="5a9e" class="jy jz ht ju b fi ke kb l kc kd">#encoding user_title to numerical values<br/>df['user_title'] = le.fit_transform(df.user_title.values)</span><span id="ffed" class="jy jz ht ju b fi ke kb l kc kd">print ("After Encoding:  ",df['user_title'].unique())</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lw"><img src="../Images/47b82a7da3659aae7216b95b02d984b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*vG9DvtjIHAk8JHPjkeWolg.png"/></div></figure><p id="bdc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，在编码之前，我们有5个不同值的分类数据，但现在编码之后，我们有数字数据。我们不需要为月/工作日使用库，因为我们可以为它分配我们自己的编码。<em class="jo"> Item_size </em>是下一个重要的分类变量。让我们看看它的价值:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lx"><img src="../Images/c77df8727ea4fd2104bbaba68da54c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*MdMdJl892wmtRaeaXG0quw.png"/></div></figure><p id="1883" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，项目大小混合了非数值和数值。这个方面很有趣，因为我们只需要转换几个值。一个问题出现了，因为我们没有任何关于xl、l和xxl在数值上的含义的映射，所以我们不能简单地替换它们。基于真实世界的场景，我们可以有把握地假设xxl &gt; xl &gt; l等等。因此，我们可以根据分类值的数量将数字数据分成5-6组，然后将每组分配给一个值类别。我们可以很容易地用分位数做到这一点，分位数根据值将数据分成组。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="676a" class="jy jz ht ju b fi ka kb l kc kd">def item_map(x):<br/>    #removing + sign from sizes<br/>    x=x.replace("+","")<br/>    <br/>    #if size is categorical replace it with nan<br/>    if x.isnumeric()==False:  <br/>        x=np.nan<br/>    return float(x)<br/>df['item_size_numerical']=df.item_size.apply(item_map)<br/>df.item_size_numerical.quantile([0.02,0.08,.12, .3,.6, .8,0.98])</span></pre><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es ly"><img src="../Images/82af4592e1faec9d3a39ae00918c8117.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*80CVcd3Cuaxi-aNAOUkz7g.png"/></div></figure><p id="176e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有6个分位数，0.98表示位于数据的98%以上的值，0.02表示位于2%的值。因此，我们可以说48大于98%的值，所以我们可以将xxxl赋给它，并对其他分位数进行类似的迭代。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b02d" class="jy jz ht ju b fi ka kb l kc kd">def item_map_category(x):<br/>    x=x.replace("+","")<br/>    if x.isnumeric()==False:  <br/>        if x=='xxxl':<br/>            x=48<br/>        elif x=='xxl':<br/>            x=42<br/>        elif x=='xl':<br/>            x=40<br/>        elif x=='l':<br/>            x=38<br/>        elif x=='m':<br/>            x=29<br/>        elif x=='s':<br/>            x=10<br/>        elif x=='xs':<br/>            x=6<br/>        else: #for non-reported size we choosing mid value<br/>            x=40<br/>    return int(x)<br/>df['item_size_fixed']=df.item_size.apply(item_map_category)<br/>df.item_size_fixed.value_counts()</span></pre><p id="079e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这会将我们所有的非数字大小转换为数字值，如下所示:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/7ed37ded710d12564d2677d8e7f118cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*oyhRLktcveV_NkXGMQ27qw.png"/></div></figure><p id="f80d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了固定的项目大小，接下来的两个分类变量是颜色和状态。我们可以有把握地推断，颜色和状态对回报率几乎没有影响，因此它们对模型没有用处。此外，我们还可以删除其他冗余列，如id。我们最终清理的数据集现在已准备好进行建模，如下所示:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/8991411cd8602a2bed07e3f8447b1f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YabF43EDm4num3R_cUNxuQ.png"/></div></div></figure><p id="f985" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">结论:</strong></p><p id="c50b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就完成了我们的预建模阶段。我们已经详细完成了所有需要的步骤，并对我们的数据集进行建模充满信心。您可以在此处查看如何对上述预处理数据集进行预测:</p><p id="7234" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae mb" href="https://wahabaftab.medium.com/machine-learning-pipeline-for-beginners-retail-returns-dataset-part-ii-57cd8b8a0743" rel="noopener">https://wahabaftab . medium . com/machine-learning-pipeline-for-初学者-retail-returns-dataset-part-ii-57 CD 8 b 8 a 0743</a></p><p id="846b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你认为有些地方是错误的或者需要一些改变，请随时添加任何评论，反馈是非常感谢的。</p></div></div>    
</body>
</html>
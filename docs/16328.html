<html>
<head>
<title>How to not to be a Telegram Bot with GramJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不成为格兰姆斯的电报机器人</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-not-to-be-a-telegram-bot-with-gramjs-21ef5fb01822?source=collection_archive---------8-----------------------#2022-12-22">https://medium.com/geekculture/how-to-not-to-be-a-telegram-bot-with-gramjs-21ef5fb01822?source=collection_archive---------8-----------------------#2022-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/41f9acc938815fff37f2a26873676fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EpR-tbnNZsVnQij9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@yuyeunglau?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Yuyeung Lau</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b425" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于如何制作电报机器人的文章不少。Telegram还有一个优秀的API，可以为Telegram创建一个客户端。让我们在Node.js中实现一个控制台应用程序，它将接收来自chat的图片，并熟悉面向客户端的库GramJS和Telegram API。</p><h1 id="5218" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">准备</h1><p id="b7e0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将使用GramJS库来处理Telegram API。</p><p id="c987" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们首先为我们的应用程序创建一个基本的包装器:</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="b1ed" class="lf ju hi lb b be lg lh l li lj">npm init -y &amp;&amp; npm install telegram</span></pre><p id="3721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们将创建一个新的模块，在这里我们将进行开发，同时，安装所需的库来使用Telegram API。</p><h1 id="1b5d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">批准</h1><p id="aa9a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">授权电报中的申请。我们希望以用户身份登录，而不是以机器人身份登录，因为机器人还有另一个API，我们不需要它。</p><p id="774e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们的应用程序并不大，所以我们不使用库来处理配置，而是将我们的秘密apiID和apiHash数据保存在config.js文件中，内容如下:</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="9ce4" class="lf ju hi lb b be lg lh l li lj">const config = {<br/>  telegram_credentials: {<br/>    apiId: &lt;your apiId&gt;,<br/>    apiHash: &lt;your apiHash&gt;,<br/>  },<br/>  chatName: &lt;your desired chat name&gt;,<br/>};<br/>module.exports = config;</span></pre><p id="199d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们使用示例中稍加修改的代码登录Telegram。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="76b3" class="lf ju hi lb b be lg lh l li lj">const config = require('./config');<br/>const {<br/>  telegram_credentials: { apiId, apiHash },<br/>  chatName,<br/>} = config;<br/>const stringSession = new StringSession("");<br/>async function authorize() {<br/>  const client = new TelegramClient(stringSession, apiId, apiHash, {<br/>    connectionRetries: 5,<br/>  });<br/>  await client.start({<br/>    phoneNumber: async () =&gt; await input.text('number ?'),<br/>    password: async () =&gt; await input.text('password?'),<br/>    phoneCode: async () =&gt; await input.text('Code ?'),<br/>    onError: (err) =&gt; console.log(err),<br/>  });<br/>  console.log('You should now be connected.');<br/>}</span></pre><h1 id="2b6a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">持久授权</h1><p id="bed2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了避免每次登录，我们需要保存会话。我们将会话保存在同一个文件夹中，并在必要时进行检查和覆盖。我们已经在图书馆里得到了支持。是的，如果你为长期跑步实现了一个不同的机制，这将会有所帮助，但是对于我们的目的来说，它作为一个游戏场是很好的。</p><p id="0e0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们重写授权代码以使用文件存储。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="279a" class="lf ju hi lb b be lg lh l li lj">const storeSession = new StoreSession('my_session'); // This will save the session in a folder named my_session<br/><br/>async function authorize() {<br/>  const client = new TelegramClient(storeSession, apiId, apiHash, {<br/>    connectionRetries: 5,<br/>  });<br/>  // same function as above<br/>}</span></pre><p id="4bd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了检查授权，让我们细化我们的授权函数。让它首先尝试加入电报服务器，如果它不起作用，请再次引导我们通过授权流程。</p><p id="2c2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，让我们添加以下代码，而不是立即开始授权</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="5d6e" class="lf ju hi lb b be lg lh l li lj">await client.connect();<br/>if (await client.checkAuthorization()) { <br/>	// We are logged here<br/>}</span></pre><p id="f851" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">授权函数的完整代码将在本文末尾的清单中提供。</p><h1 id="db67" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">图像下载</h1><p id="23da" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">出于演示目的，我们希望从配置中指定的聊天中获取图片的所有图片。为了下载图像，我们将使用API方法。为了避免多次下载相同的照片，让我们检查一下它们是否已经存在于我们电脑的文件夹中。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="7624" class="lf ju hi lb b be lg lh l li lj">const fs = require('fs');<br/>const path = require('path');<br/><br/>async function checkAndDownload(client, photo) {<br/>  const filename = path.join('images', photo.id + '.jpg'); // Most of images in telegram in JPG<br/>  try {<br/>    await fs.promises.access(filename); // Check existance of file on the disk<br/>    console.log(`File has already exist ${filename}`);<br/>  } catch (error) {<br/>    const buffer = await client.downloadMedia(photo, {<br/>      progressCallback: console.log,<br/>    });<br/>    if (buffer !== undefined) {<br/>      await fs.promises.writeFile(filename, buffer);<br/>    }<br/>  }<br/>}</span></pre><h1 id="72e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">并行接收所有图像</h1><p id="4e55" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果图像很少，并且我们准备好立刻获取它们——就这么做吧。为此，使用必要的过滤器和聊天名称调用getMessages方法。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="3788" class="lf ju hi lb b be lg lh l li lj">const images = await client.getMessages(chatName, {<br/>    filter: new Api.InputMessagesFilterPhotos(),<br/>  });</span></pre><p id="3485" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法是合适的，因为它在一个请求中获得我们想要的所有消息，但是如果我们有超过1000条消息，它就不起作用了。</p><h1 id="fdab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">顺序接收图像</h1><p id="2847" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">还有一种方法允许遍历所有消息。我们用它来得到所有的照片。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="8de1" class="lf ju hi lb b be lg lh l li lj">async function receiveMessages() {<br/>  console.log('Start receive messages');<br/><br/>const client = await authorize();<br/>  for await (const photo of client.iterMessages(chatName, {<br/>    filter: new Api.InputMessagesFilterPhotos(),<br/>  })) {<br/>    try {<br/>      await checkAndDownload(client, photo);<br/>    } catch (error) {<br/>      console.log(error);<br/>    }<br/>  }<br/>  console.log('Finish download');<br/>  return;<br/>}</span></pre><h1 id="bb14" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="370b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们创建了一个控制台应用程序，它可以从控制台接收参数，作为客户端连接到Telegram，并保存和检索会话，这样您就不必每次都登录。与此同时，我们想出了如何避免电报服务器因不必要的请求而过载，并实现了一个处理大量图像的解决方案。我们获得了使用Telegram API和GramJS库的经验，允许我们在未来创建更复杂的应用程序。</p><h1 id="1d99" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">资源</h1><p id="c04a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://gram.js.org/" rel="noopener ugc nofollow" target="_blank">https://gram.js.org/</a></p><p id="4ecf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">https://core.telegram.org/api<a class="ae iu" href="https://core.telegram.org/api" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="f4a6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">列表</h1><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="ae6b" class="lf ju hi lb b be lg lh l li lj">const telegram = require('telegram');<br/>const input = require('input');<br/>const path = require('path');<br/>const fs = require('fs');<br/>const config = require('./config');<br/><br/>const {<br/>    telegram_credentials: { apiId, apiHash },<br/>    chatName,<br/>} = config;<br/>const storeSession = new telegram.sessions.StoreSession('my_session');<br/>async function authorize() {<br/>    const client = new telegram.TelegramClient(storeSession, apiId, apiHash, {<br/>        connectionRetries: 5,<br/>    });<br/>    await client.connect();<br/>    if (await client.checkAuthorization()) {<br/>        console.log('I am logged in!');<br/>    } else {<br/>        console.log(<br/>            "I am connected to telegram servers but not logged in with any account. Let's autorize"<br/>        );<br/>        await client.start({<br/>            phoneNumber: async () =&gt; await input.text('number ?'),<br/>            password: async () =&gt; await input.text('password?'),<br/>            phoneCode: async () =&gt; await input.text('Code ?'),<br/>            onError: (err) =&gt; console.log(err),<br/>        });<br/>        client.session.save();<br/>        console.log('You should now be connected');<br/>    }<br/>    return client;<br/>}<br/>async function checkAndDownload(client, photo) {<br/>    const filename = path.join('images', photo.id + '.jpg');<br/>    try {<br/>        await fs.promises.access(filename);<br/>        console.log(`File has already exist  ${filename}`);<br/>    } catch (error) {<br/>        const buffer = await client.downloadMedia(photo, {<br/>            progressCallback: console.log,<br/>        });<br/>        if (buffer !== undefined) {<br/>            await fs.promises.writeFile(filename, buffer);<br/>        }<br/>    }<br/>}<br/>async function receiveMessages() {<br/>    console.log('Start receive messages');<br/>    const client = await authorize();<br/>    for await (const photo of client.iterMessages(chatName, {<br/>        filter: new telegram.Api.InputMessagesFilterPhotos(),<br/>    })) {<br/>        try {<br/>            await checkAndDownload(client, photo);<br/>        } catch (error) {<br/>            console.log(error);<br/>        }<br/>    }<br/>    console.log('Finish download');<br/>    return;<br/>}<br/>(async () =&gt; {<br/>    return await receiveMessages();<br/>})();</span></pre></div></div>    
</body>
</html>
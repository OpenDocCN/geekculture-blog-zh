<html>
<head>
<title>Android Touch Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android触摸框架</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/android-touch-framework-b5cc5a9926ed?source=collection_archive---------6-----------------------#2021-05-11">https://medium.com/geekculture/android-touch-framework-b5cc5a9926ed?source=collection_archive---------6-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fdc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理解触摸框架的概念</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a4f7f6ae65edf7e466caf96cbf15da9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ftxfvtDPNf0nfy6"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Android Touch</figcaption></figure><p id="1a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">各位开发者好，在这篇文章中，我将讨论Android触摸框架，触摸如何在应用程序中流动，以及Android如何处理所有这些事件。</p><h1 id="fc4c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Android如何处理触摸</h1><p id="9fc4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">应用程序中的每个触摸事件都被包装成一个<strong class="ih hj">运动事件</strong>。这些<strong class="ih hj">动作事件</strong>包含动作的描述和一些元数据，例如屏幕上触摸事件的位置。一些行动如下:</p><ul class=""><li id="1f75" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><strong class="ih hj"> ACTION_DOWN </strong>:手指触摸屏幕时</li><li id="3c81" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj"> ACTION_UP </strong>:手指离开屏幕时</li><li id="6697" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">动作_指针_向下</strong></li><li id="e8ce" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">动作_指针_向上</strong></li><li id="3a75" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">动作_移动</strong>:在屏幕上移动手指时</li><li id="9b51" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">动作_取消</strong></li></ul><p id="771a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手势被定义为以<strong class="ih hj">动作_向下</strong>开始，以<strong class="ih hj">动作_向上</strong>结束。</p><ol class=""><li id="3478" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lk lc ld le bi translated">事件从带有<code class="du ll lm ln lo b">dispatchTouchEvent()</code>的活动开始</li><li id="5ec7" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lk lc ld le bi translated">事件通过视图从上到下流动</li></ol><ul class=""><li id="0a1a" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">父母(视图组)将事件发送给他们的孩子</li><li id="00a5" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">可以随时拦截事件。</li></ul><p id="ec55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.事件沿层次结构向下流动，然后向上流动，直到被消费</p><blockquote class="lp lq lr"><p id="f6d0" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">当处理事件的调度时，层次结构的顶部位置起主导作用，但是当处理触摸时，使用onTouchEvent的子视图总是第一个，然后它继续向ViewGroups移动。</p><p id="dea8" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><strong class="ih hj">触摸事件的工作方式类似于事件的分派，但从子到父的顺序相反。</strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/f5ec921b3619f3fdadae37c90f1f2011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdpExcEVpMWj2Geb35Kjcw.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/417fee0b6a225b3c2bd89554c259fdb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFQ6rz15Kh_ZJbcQwuSB5A.png"/></div></div></figure><p id="fa62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当拦截时，如果我们返回<code class="du ll lm ln lo b">true</code>，那么触摸事件是<strong class="ih hj">而不是</strong>传递给它的孩子，如果我们传递<code class="du ll lm ln lo b">false</code>，Android生态系统得到通知，视图组想要将事件分派给它的孩子，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/42c0089afd346778d853d8b9ae29d274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypX6FPO5g4z7YTPvPPveng.png"/></div></div></figure><p id="3711" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">孩子可以调用<code class="du ll lm ln lo b">requestDisallowTouchIntercept()</code>在当前手势持续期间阻止<code class="du ll lm ln lo b">onInterceptTouchEvent()</code>。例如Scrollview中的一些滚动视图。我们希望在滚动子级时停止父级滚动。<em class="ls">该标志由框架在新手势(ACTION_DOWN)时重置</em></p><h1 id="a7be" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">场景1—当没有视图正在使用事件时</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/c07b7f1b118721f52f10522472e2706e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf4Auq6xX3AbxcqPiH_shg.png"/></div></div></figure><h1 id="ac08" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">场景2 —当一个视图正在消费事件时</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/cd3294e32d3ea8e9a870c1d5994bb809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C35AS1HF3oSZBw0LC4jToA.png"/></div></div></figure><h1 id="d1c3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">场景3 —</h1><p id="0d6b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在<code class="du ll lm ln lo b">ScrollView</code>内的按钮的情况下，按钮在被点击时消耗触摸事件，但是如果手势被改变为拖动，则<code class="du ll lm ln lo b">ScrollView</code>的<code class="du ll lm ln lo b">onInterceptTouchEvent</code>被调用，<code class="du ll lm ln lo b">ScrollView</code>开始处理触摸，并且按钮接收<code class="du ll lm ln lo b">ACTION_CANCEL</code>事件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/a89e01487929f5d42e41f2a9f5a75c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1uxwHAute-ZO1W47zYkOA.png"/></div></div></figure><ul class=""><li id="0342" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">一切都取决于<code class="du ll lm ln lo b">onInterceptTouchEvent()</code>及其返回值<strong class="ih hj">和</strong>。dispatchTouchEvent依赖于<code class="du ll lm ln lo b">onInterceptTouchEvent()</code>的值，如果它返回true，则调度被取消，如果它返回false，则触摸事件的调度继续进行，直到它被使用。</li><li id="b982" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">如果<code class="du ll lm ln lo b">onTouchEvent()</code>返回真，则意味着触摸被处理，但是如果它返回假，则意味着触摸未被处理。</li></ul><h2 id="8016" class="mc ju hi bd jv md me mf jz mg mh mi kd iq mj mk kh iu ml mm kl iy mn mo kp mp bi translated">对于复杂的触摸交互:</h2><p id="fff9" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们有手势检测器，通过<code class="du ll lm ln lo b">onTouchListener() or onTouchEvent()</code>处理:</p><ul class=""><li id="7be8" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><code class="du ll lm ln lo b">onDown(), onSingleTapUp(), onDoubleTap()</code></li><li id="a352" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du ll lm ln lo b">onLongPress()</code></li><li id="969b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du ll lm ln lo b">onScroll()</code></li><li id="17d3" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du ll lm ln lo b">onFling()</code></li></ul><h1 id="bd92" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">触摸代表</h1><p id="9598" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">帮助器类来处理您希望视图具有比其实际视图边界更大的触摸区域的情况。触摸区域发生变化的视图称为代理视图。该类应该由委托的祖先使用。</p><blockquote class="lp lq lr"><p id="0a81" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><strong class="ih hj">允许特定视图的触摸区域与其实际触摸边界不同。</strong></p></blockquote><p id="9305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你学到了一些东西！感谢您的阅读。</p><p id="8971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ls">点击</em>👏表示你的支持，并与其他媒体用户分享。</p><p id="405b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae mq" href="https://twitter.com/adilkhanforeal" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="ls">推特</em> </strong> </a> <strong class="ih hj">和</strong><a class="ae mq" href="https://www.instagram.com/adilkhanforeal/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ls">insta gram</em></strong></a>上找到我</p><div class="mr ms ez fb mt mu"><a href="https://www.linkedin.com/in/iadilkhan/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">Adil Khan - BBD大学-印度北方邦勒克瑙| LinkedIn</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在世界上最大的职业社区LinkedIn上查看Adil Khan的个人资料。Adil有1个工作列在他们的…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.linkedin.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jn mu"/></div></div></a></div></div></div>    
</body>
</html>
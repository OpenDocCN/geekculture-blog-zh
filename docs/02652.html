<html>
<head>
<title>Python: Make Your Code Simple with decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:用装饰器简化代码</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/make-your-code-simple-with-python-decorators-598b25a3e93a?source=collection_archive---------16-----------------------#2021-05-23">https://medium.com/geekculture/make-your-code-simple-with-python-decorators-598b25a3e93a?source=collection_archive---------16-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2a3a4aed14f6355b763c0d1d98fe4723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2FDEixnS_evvqmuFGopaA.png"/></div></div></figure><h1 id="ed48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是装修工？</h1><p id="bf27" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">装饰器是一种在不改变代码的情况下改变或修改函数或类方法的T2行为的方法。</p><p id="dc71" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">那些装饰者<strong class="jq hj">非常强大</strong>并且有不同的用例，我们将会看到其中的一些。</p><p id="506b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是在此之前，让我们快速回顾一下python的基础知识。</p><h1 id="af2d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Python中函数是如何工作的？</h1><h2 id="0007" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">简单功能:</h2><p id="8216" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，函数是一个<strong class="jq hj">对象</strong>。像任何其他对象一样，函数也有属性和方法。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="490e" class="kr ir hi lr b fi lv lw l lx ly">def my_function():<br/>    print("Decorators example")<br/><br/>my_function()</span></pre><p id="20d2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个例子是一个“my_function”函数调用，它打印了“Decorators example”。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="0e2b" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">函数是一个对象:</h2><p id="bf29" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">但是如果我们显示“my_function”的函数签名，我们得到:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6aac" class="kr ir hi lr b fi lv lw l lx ly">print(my_function)<br/>$&gt; &lt;function my_function at 0x000001C94E156A68&gt;</span></pre><p id="705c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，我们在内存地址“0x000001C94E156A68”处获得了一个名为“my_fonction”的<strong class="jq hj">函数对象</strong>。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="4298" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">我们可以像使用其他变量一样使用函数:</h2><p id="d871" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这意味着，如果一个函数是一个对象，你可以在你的程序中<strong class="jq hj">共享</strong>或者<strong class="jq hj">传递</strong>。这样，我们可以将每个<strong class="jq hj">函数签名</strong>存储到一个字典中。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6ef7" class="kr ir hi lr b fi lv lw l lx ly">def my_function_type_1():<br/>    print("type1")<br/><br/><br/>def my_function_type_2():<br/>    print("type2")<br/><br/><br/>def my_function_type_3():<br/>    print("type3")<br/><br/><br/>types = {<br/>    'type1': my_function_type_1,<br/>    'type2': my_function_type_2,<br/>    'type3': my_function_type_3<br/>}<br/><br/><br/>def typeHandler(type):<br/>    types[type]()<br/><br/><br/>typeHandler('type1')<br/>typeHandler('type2')<br/>typeHandler('type3')</span><span id="5701" class="kr ir hi lr b fi lz lw l lx ly">$&gt; type1<br/>$&gt; type2<br/>$&gt; type3</span></pre><p id="0d87" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于字典键，如果情况，你可以调用相关的函数而不需要创建任何<strong class="jq hj">。</strong></p><p id="0cd5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这使得你的代码更容易阅读和维护。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="1238" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">作为参数的函数:</h2><p id="bc3c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">你也可以传递一个函数作为<strong class="jq hj">参数</strong>。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="19e9" class="kr ir hi lr b fi lv lw l lx ly">def my_callback_function():<br/>    print("Callback")<br/><br/><br/>def my_function(callback):<br/>    print("Doing my stuff")<br/>    # when my logic is done call the parameter function<br/>    callback()<br/>    print("Callback done")<br/><br/><br/>my_function(my_callback_function)</span><span id="45e7" class="kr ir hi lr b fi lz lw l lx ly">$&gt; Doing my stuff<br/>$&gt; Callback<br/>$&gt; Callback done</span></pre><h1 id="2272" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">包装材料</h1><p id="9f4c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在python中，可以在函数内部创建函数。</p><h2 id="70f5" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">函数中的函数:</h2><p id="834f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">例如，如果您想创建一个函数，让<strong class="jq hj">计算另一个函数的时间</strong>:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="f275" class="kr ir hi lr b fi lv lw l lx ly">import datetime as dt<br/><br/><br/>def time_compute(compute_function):<br/>    def wrap():<br/>        begin = dt.datetime.utcnow()<br/>        compute_function()<br/>        end = dt.datetime.utcnow()<br/>        print("Time: ", end - begin)<br/><br/>    wrap()<br/><br/><br/>def my_compute_function():<br/>    print("My compute stuff")<br/>    <br/>    <br/>time_compute(my_compute_function)</span><span id="81de" class="kr ir hi lr b fi lz lw l lx ly">$&gt; My compute stuff<br/>$&gt; Time:  0:00:00</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="5001" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">带参数的函数中的函数:</h2><p id="5946" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用这种方法，您将无法将<strong class="jq hj">参数</strong>传递给“compute_function”。</p><p id="7275" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们修改我们的代码:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="fbf4" class="kr ir hi lr b fi lv lw l lx ly">import datetime as dt<br/><br/><br/>def time_compute(compute_function):<br/>    def wrap(*args, **kwargs):<br/>        begin = dt.datetime.utcnow()<br/>        compute_function(*args, **kwargs)<br/>        end = dt.datetime.utcnow()<br/>        print("Time: ", end - begin)<br/>    return wrap<br/><br/><br/>def my_compute_function(number):<br/>    for i in range(number):<br/>        print("{} my compute function".format(i))<br/><br/><br/>time_compute(my_compute_function)(2)</span><span id="a1bf" class="kr ir hi lr b fi lz lw l lx ly">$&gt; 0 my compute function<br/>$&gt; 1 my compute function<br/>$&gt; Time:  0:00:00</span></pre><p id="abca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通过这些修改，我们可以将参数传递给需要计算耗时的函数。</p><p id="69de" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">信息:</em></p><blockquote class="mb mc md"><p id="f2df" class="jo jp ma jq b jr km jt ju jv kn jx jy me ko kb kc mf kp kf kg mg kq kj kk kl hb bi translated"><strong class="jq hj"> *args </strong>是标准位置参数</p><p id="e194" class="jo jp ma jq b jr km jt ju jv kn jx jy me ko kb kc mf kp kf kg mg kq kj kk kl hb bi translated"><strong class="jq hj"> **kwargs </strong>是关键定义参数</p></blockquote><p id="61ca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可以在此找到更多信息<a class="ae mh" href="https://realpython.com/python-kwargs-and-args/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="392a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">装修工</h1><p id="34dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在前面的例子中，我们已经看到，我们可以通过<strong class="jq hj">包装</strong>来修改函数<strong class="jq hj">的行为</strong>，以添加更多的逻辑。这就是<strong class="jq hj">装修工</strong>的主要目的。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="b684" class="kr ir hi lr b fi lv lw l lx ly">time_compute(my_compute_function)(2)</span></pre><h2 id="6b32" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">简单装饰:</h2><p id="8618" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因为语法不容易阅读，所以“<strong class="jq hj">@</strong>”<strong class="jq hj">操作符</strong>出现了。因此，让我们将前面的例子转换成一个真正的python装饰器。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="52a9" class="kr ir hi lr b fi lv lw l lx ly">import datetime as dt<br/><br/><br/>def time_compute(compute_function):<br/>    def wrap(*args, **kwargs):<br/>        begin = dt.datetime.utcnow()<br/>        compute_function(*args, **kwargs)<br/>        end = dt.datetime.utcnow()<br/>        print("Time: ", end - begin)<br/>    return wrap<br/><br/><br/>@time_compute<br/>def my_compute_function(number):<br/>    for i in range(number):<br/>        print("{} my compute function".format(i))<br/><br/><br/>my_compute_function(2)</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="5daf" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">具有返回值的装饰器:</h2><p id="880d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们很容易地转换了简单的例子。但是我们遇到了另一个问题，如果我们的“my_compute_function”返回一个<strong class="jq hj">值</strong>，我们将永远得不到它，因为我们没有返回它。</p><p id="7a85" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们来修改一下:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6d53" class="kr ir hi lr b fi lv lw l lx ly">import datetime as dt<br/><br/><br/>def time_compute(compute_function):<br/>    def wrap(*args, **kwargs):<br/>        begin = dt.datetime.utcnow()<br/>        ret_value = compute_function(*args, **kwargs)<br/>        end = dt.datetime.utcnow()<br/>        print("Time: ", end - begin)<br/>        return ret_value<br/>    return wrap<br/><br/><br/>@time_compute<br/>def my_compute_function(number):<br/>    value = 0<br/>    for i in range(number):<br/>        print("{} my compute function".format(i))<br/>        value += i<br/>    return value<br/><br/><br/>value = my_compute_function(2)<br/>print("Value: ", value)</span><span id="9751" class="kr ir hi lr b fi lz lw l lx ly">$&gt; 0 my compute function<br/>$&gt; 1 my compute function<br/>$&gt; Time:  0:00:00<br/>$&gt; Value:  1</span></pre><p id="2103" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里我们有一个完整的<strong class="jq hj">装饰师</strong>的例子。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="e0ef" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">多个装饰者:</h2><p id="7a38" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们有很多用例，你可以使用它们，比如日志、测试、监控等等。你也可以添加<strong class="jq hj">多个装饰器</strong>来增加你的功能。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="4f21" class="kr ir hi lr b fi lv lw l lx ly">import datetime as dt<br/><br/><br/>def logg_function(compute_function):<br/>    def wrap(*args, **kwargs):<br/>        print("Call", str(compute_function), "with args:", [str(arg) for arg in args], "with kwargs", [key + '_' + str(arg) for key, arg in kwargs.items()])<br/>        ret_value = compute_function(*args, **kwargs)<br/>        return ret_value<br/><br/>    return wrap<br/><br/><br/>def time_compute(compute_function):<br/>    def wrap(*args, **kwargs):<br/>        begin = dt.datetime.utcnow()<br/>        ret_value = compute_function(*args, **kwargs)<br/>        end = dt.datetime.utcnow()<br/>        print("Time: ", end - begin)<br/>        return ret_value<br/><br/>    return wrap<br/><br/>@logg_function<br/>@time_compute<br/>def my_compute_function(number):<br/>    value = 0<br/>    for i in range(number):<br/>        print("{} my compute function".format(i))<br/>        value += i<br/>    return value<br/><br/><br/>value = my_compute_function(2)<br/>print("Value: ", value)</span><span id="e2ac" class="kr ir hi lr b fi lz lw l lx ly">$&gt; Call &lt;function time_compute.&lt;locals&gt;.wrap at 0x0000027BBDAB18B8&gt; $&gt; with args: ['2'] with kwargs []<br/>$&gt; 0 my compute function<br/>$&gt; 1 my compute function<br/>$&gt; Time:  0:00:00<br/>$&gt; Value:  1</span></pre><p id="dcdd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你对更多的python技巧和窍门感兴趣，或者你想开发一个技术解决方案(网站、应用程序)，你可以在这里发消息联系我们<a class="ae mh" href="http://techsense-corporation.io/" rel="noopener ugc nofollow" target="_blank">http://techsense-corporation.io/</a></p></div></div>    
</body>
</html>
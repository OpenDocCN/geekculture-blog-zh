<html>
<head>
<title>How I use an ActionFilter in .NET Core to keep my Controller clean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中如何使用ActionFilter。NET核心来保持我的控制器干净</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-i-use-an-actionfilter-in-net-core-to-streamline-authorization-f12acbea7788?source=collection_archive---------1-----------------------#2021-09-22">https://medium.com/geekculture/how-i-use-an-actionfilter-in-net-core-to-streamline-authorization-f12acbea7788?source=collection_archive---------1-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/19861382d64a7ce183953137b4d82dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y8Cks_9oqirB-X9Z"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@srkraakmo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephen Kraakmo</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3489" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是过滤器？</h1><blockquote class="jt ju jv"><p id="2e22" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">ASP.NET核心中的过滤器允许代码在请求处理管道中的特定阶段之前或之后运行。</p></blockquote><p id="14f0" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">中有五种类型的过滤器。网络核心</p><ul class=""><li id="1086" class="ky kz hi jz b ka kb ke kf kv la kw lb kx lc ku ld le lf lg bi translated"><strong class="jz hj">授权</strong> —首先运行，确定用户是否被授权</li><li id="7366" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">资源—在授权之后但在所有其他管道之前运行</li><li id="4b43" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated"><strong class="jz hj">动作</strong> —在调用方法之前或之后立即运行代码</li><li id="1ec1" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">异常—处理异常的全局策略</li><li id="4050" class="ky kz hi jz b ka lh ke li kv lj kw lk kx ll ku ld le lf lg bi translated">结果—在操作成功执行之前和之后运行</li></ul><p id="8152" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果你不了解过滤器，我鼓励你在这里学习更多的<a class="ae iu" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank"/>。对于今天的这篇文章，我们将使用授权和动作过滤器来自动合并控制器中的UserId，以便于访问。</p><h1 id="30d3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">目标—将重复的授权代码抽象到过滤器中</h1><h2 id="e3b5" class="lm iw hi bd ix ln lo lp jb lq lr ls jf kv lt lu jj kw lv lw jn kx lx ly jr lz bi translated">抽象ApiController</h2><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="d0c3" class="lm iw hi mf b fi mj mk l ml mm">[ApiController]<br/>[Authorize] // Uses authentication scheme to determine user<br/>[ActionFilter] // We will implement this below<br/>public abstract class ApiController : ControllerBase<br/>{<br/>   public string UserId { get; set; }<br/>}</span></pre><p id="e11c" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我们在这里做的第一件事是创建一个抽象的基本控制器。我们这样做是为了将这个ActionFilter应用于任何将从此类继承的新控制器。它还将封装UserId，这样我们就不必在我们创建的每个控制器中添加UserId字段。还要注意类上面的[ActionFilter]属性，这就是它的作用。NET为任何继承的类运行此筛选器。</p><p id="799f" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">控制器上的[Authorize]属性将决定用户是否有权调用控制器或控制器方法。常见的身份验证方案包括Cookies和JWT，但是对于本文，我们将假设您已经实现了该中间件。</p><h2 id="4681" class="lm iw hi bd ix ln lo lp jb lq lr ls jf kv lt lu jj kw lv lw jn kx lx ly jr lz bi translated">动作过滤器</h2><p id="cbb4" class="pw-post-body-paragraph jw jx hi jz b ka mn kc kd ke mo kg kh kv mp kk kl kw mq ko kp kx mr ks kt ku hb bi translated">现在我们有了带有ActionFilter属性的控制器，让我们写出过滤器本身的代码。</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="1221" class="lm iw hi mf b fi mj mk l ml mm">public class ActionFilter : Attribute, IActionFilter<br/>{<br/>   public void OnActionExecuted(ActionExecutedContext context) {}<br/>   <br/>   // Pull the user ID on each request<br/>   public void OnActionExecuting(ActionExecutingContext context<br/>   {<br/>      var c = context.Controller as ApiController;<br/>      c.UserId = c.User.FindFirstValue(ClaimTypes.NameIdentifier);<br/>   }<br/>}</span></pre><p id="4a0b" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">这个ActionFilter继承自Attribute(允许我们将其用作属性[ActionFilter])和IActionFilter，后者要求我们实现两个方法，OnActionExecuted和OnActionExecuting。OnActionExecuted在动作完成后运行<em class="jy">，而OnActionExecuting在<em class="jy">之前运行。</em>因为我们想在控制器动作中使用UserId，所以我们将使用后者。</em></p><p id="8d5f" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">ActionExecutingContext作为OnActionExecuting中的一个参数提供给我们，从那里我们可以访问控制器本身。我们将控制器转换为ApiController(我们的抽象类),这样我们就可以设置上面声明的UserId字段。在本例中，我使用的是JWT身份验证，因此我们可以使用第二行逻辑提取UserId，并将其设置为UserId。通过设置这个Id，我们将在任何控制器方法开始执行之前填充UserId。</p><h2 id="1372" class="lm iw hi bd ix ln lo lp jb lq lr ls jf kv lt lu jj kw lv lw jn kx lx ly jr lz bi translated">将ApiController与ActionFilter一起使用</h2><p id="9ab5" class="pw-post-body-paragraph jw jx hi jz b ka mn kc kd ke mo kg kh kv mp kk kl kw mq ko kp kx mr ks kt ku hb bi translated">既然我们已经设置了这两部分，我们终于可以在应用程序控制器中使用抽象的代码了</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="576c" class="lm iw hi mf b fi mj mk l ml mm">[Route("api/[controller]")]<br/>public class MyController : ApiController<br/>{<br/>   [HttpGet("user-name")]<br/>   public async Task&lt;IActionResult&gt; GetUserName(<br/>      [FromServices] IUserService userService)<br/>   {<br/>       // Passing the UserId we populated in the Filter<br/>       var userName = await userService.GetUserNameAsync(UserId);</span><span id="6767" class="lm iw hi mf b fi ms mk l ml mm">       return Ok(userName);<br/>   }<br/>}</span></pre><p id="2773" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">因为我们在ApiController基类上使用了[ActionFilter],所以我们能够保持GetUserName控制器方法非常干净，只需要两行代码(实际上可能只有一行)。如果我们不使用过滤器，我们将需要调用用户。FindFirstValue(ClaimTypes。NameIdentifier)代码来获取我们的用户id，这是重复的，很难记住。我们写一次ActionFilter就忘了。</p><h2 id="10bb" class="lm iw hi bd ix ln lo lp jb lq lr ls jf kv lt lu jj kw lv lw jn kx lx ly jr lz bi translated">结论</h2><p id="a690" class="pw-post-body-paragraph jw jx hi jz b ka mn kc kd ke mo kg kh kv mp kk kl kw mq ko kp kx mr ks kt ku hb bi translated">过滤器是中非常强大的工具。NET Core，我希望我能早点了解它。利用过滤器可以抽象出一堆样板代码，让您专注于重要的代码。</p><p id="33aa" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">我经常使用的另一个过滤器是ExceptionFilter，您可以在其中处理异常并根据抛出的异常返回404或500，这可以使您的控制器方法更加整洁！！</p><p id="cca8" class="pw-post-body-paragraph jw jx hi jz b ka kb kc kd ke kf kg kh kv kj kk kl kw kn ko kp kx kr ks kt ku hb bi translated">如果你做到了这一步，请给我留下一些掌声，并关注我的帐户。编码快乐！</p></div></div>    
</body>
</html>
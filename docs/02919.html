<html>
<head>
<title>React setState &amp; its Async Nature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React setState及其异步特性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-setstate-its-async-nature-bc6bcd78eebd?source=collection_archive---------45-----------------------#2021-05-27">https://medium.com/geekculture/react-setstate-its-async-nature-bc6bcd78eebd?source=collection_archive---------45-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b84cf7087dd1f0a8a2e88c182333f5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmFrmohRd4KWtfulzwA3cg.png"/></div></div></figure><p id="0a04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还记得React中setState的第二个可选参数是什么吗？它的目的是什么？如果你和我一样，在我第一次学习的时候，第二个参数没有进入本地存储。在用React构建了更多之后，很明显第二个论点实际上值得关注一段时间。</p><p id="52cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于任何新开发人员来说，将React组件理解为具有自上而下级联数据流的树就足够了。随着您继续构建，一些意想不到的结果可能会突然出现，这可能会让您抓耳挠腮，考虑更多正在发生的细微差别。</p><p id="75fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个这样的“陷阱”与setState函数和意外地在您的逻辑中使用不同于您打算使用的状态版本有关。关于在React <em class="jo">类组件</em>中设置和更新状态的最初要点可以被编译为以下两个主要概念:</p><ol class=""><li id="4167" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">我只能在构造函数</strong>中直接设置状态<em class="jo">(通过将this.state声明为一个POJO，我可以向其提供现在组成所述状态的键和值)。</em></li><li id="b407" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">此后，每当我想要更新状态时，我都需要使用setState </strong>(以类似的方式向构造函数提供更改——指定我想要用一些相应的更新值来更新状态的哪一部分)。</li></ol><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/fcd639a9003445ecba80cb5f5d7eb891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JopIxlVZQcgTlK3jfgBUIQ.png"/></div></div></figure><p id="8d2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个基本代码片段中，state是在构造函数的第6–8行中直接<em class="jo">设置的</em>，并且将通过第13–15行中的函数进行更新，该函数在单击时执行，并使用预期的下一个状态调用setState。虽然这两个主要思想是在组件中设置和更新本地状态的基础，但第三点setState是异步操作的——也是尽早理解的最重要的一点。UI在给定时刻显示的状态版本实际上是异步确定的—<em class="jo">—</em>,开发人员应该考虑到这种“不会恰好在那个时刻发生”的性质。</p><p id="c570" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如React文档中所述:</p><blockquote class="ki kj kk"><p id="d3eb" class="iq ir jo is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated"><em class="hi">“当您使用React时，在一个时间点上，您可以将render()函数视为创建React元素树。在下一次状态或props更新时，render()函数将返回一个不同的React元素树。React然后需要找出如何有效地更新UI以匹配最新的树。”</em></p></blockquote><p id="8385" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么当你调用setState时会发生什么呢？一旦在React中调用setState，您传递给setState <em class="jo">的对象就会合并到组件的当前状态</em>中。这就开始了一个叫做<a class="ae ko" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">和解</strong> </a> <strong class="is hj">的过程。</strong>在不深入研究这种不同算法的情况下，重要的一点是，尽管React正在协调两棵树中的差异，但对于开发人员在下一行编码的“下一状态”相关结果来说，即使是这一操作的闪电般速度(O(n))也可能太慢，无法生效并实际产生他们预期的结果。</p><p id="9145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在前面代码片段的第16行setState调用之后插入一个<strong class="is hj">console . log(this . state . is basic)</strong>，那么将要记录到控制台的很可能是前一个状态，而不是下一个状态。UI将快速改变，并相应地切换按钮的文本以反映下一个状态。但是，console.log语句的执行速度会更快，并且会在状态更新之前打印出来，记录与您将要看到的状态相反的状态。(见下文)。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/f53257b3ea33f83720dc9e58b47aac67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CtlofLQbDdWwpmGQiJm8BA.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx">Logic executed right after a setState call may lead to unpredictable results.</figcaption></figure><p id="ec90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，一辆汽车在一条单车道高速公路的左侧车道上超车，距离他们仅几英尺。该事件期望以如下方式展开:经过的车辆越过足够的安全间隙(任务一完成)，然后车辆显著加速以通过(任务二)。在第一个安全任务完成之前，驾驶员不会真的想要踩油门。否则，任务二的加速将会带给你一个与预期截然不同的结果——也就是一场意外！我们希望在React的更新过程中避免这种类型的时间冲突，这样我们就不会以这些事故——也就是bugs而告终。</p><p id="b311" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们正式修正一下关于setState的第三个要点:</p><p id="4967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi ku translated"><span class="l kv kw kx bm ky kz la lb lc di"> 3 </span></p><p id="99f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续我们的基本例子，如果你通过一个箭头函数作为setState的第二个参数来记录状态，你将<em class="jo">总是</em>在你的控制台中看到更新的状态。(见下文)。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/060e3e88c67d08349f2ae260171e9db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Eg3UlqS1D7he3T5oH_AEA.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx">This console.log will always reflect the state that was just updated by setState.</figcaption></figure><p id="7d34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当将AJAX请求或redux thunks等异步操作合并到旨在更新状态的代码中，然后相应地使用它时，了解这个选项是很有用的。当只是想按顺序执行逻辑时，比如在setState调用之后立即调用行中的任何旧函数，并期望它使用该函数中已经更新的状态，这种缺陷甚至会发生。例如，已经更新的状态可能不存在。任何在状态更新后发生的动作，利用更新后的状态，最好作为setState的第二个参数。</p><p id="92db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个bug可能以比本文所涵盖的更复杂的方式出现。了解setState的异步性，但不保证返回到您的口袋中，一旦您知道要寻找什么，就可以加快您的调试时间。在调用setState之后，我试图在一个函数调用中从DOM中抓取一个图像，期望setState之后的函数返回的保存的图像反映状态更新时，我遇到了丰富setState理解的需要。将该逻辑放在setState中是可选的第二个参数带来的轻松解决方案。</p><p id="d724" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和往常一样，在React文档中有清晰的例子和简洁的解释。我希望setState的第二个参数能被看到，并且您永远不会忘记它是您的状态更新逻辑安全性的一个选项！</p></div></div>    
</body>
</html>
<html>
<head>
<title>Angular: This is how I understood how to use Mixins to reuse logic between components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:这就是我如何理解如何使用Mixins来重用组件之间的逻辑</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-this-is-how-i-understood-how-to-use-mixins-to-reuse-logic-between-components-cda729297de2?source=collection_archive---------0-----------------------#2022-07-09">https://medium.com/geekculture/angular-this-is-how-i-understood-how-to-use-mixins-to-reuse-logic-between-components-cda729297de2?source=collection_archive---------0-----------------------#2022-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cfeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一开始，关于Mixins的文档可能会非常混乱，让人不知所措。简单来说，</p><p id="e51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个mixin类被用来处理一些行为，其他常规类只需扩展这个mixin类就可以很容易地访问这个行为。这是提高多个类之间逻辑可重用性的一种简单方法。</p><p id="20c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有一个名为ABC的类，ABC想重用其他类PQR和MNO的一些方法。</p><p id="26f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ABC可以使用<strong class="ih hj">扩展</strong>关键字一次扩展两个类吗？不要！Typescript不支持此功能。通过扩展，ABC一次只能访问一个类别(PQR/MNO)的方法。</p><p id="7f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Mixin类帮助一个类ABC一次访问多个类的方法。</p><p id="990d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Angular中创建了一个简单的例子来演示上面的想法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/88d4f66f43bca64cf39b39e790f210b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gmLOctdT6bxOqt5oSI73w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Mixins Application</figcaption></figure><p id="be2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该应用程序只有两个组件:<strong class="ih hj">第一组件</strong>和<strong class="ih hj">第二组件</strong>，这两个组件将用于演示我们如何使用mixin类重用一个行为。</p><p id="12f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是:</p><ol class=""><li id="6288" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">创建2个组件<strong class="ih hj">第一组件</strong>和<strong class="ih hj">第二组件。</strong>这些组件将通过按钮导航，如您在上面的屏幕截图中所见。</li><li id="ce58" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">这两个组件都被赋予了通过点击按钮<strong class="ih hj">删除帖子的能力。</strong>在删除HTTP请求实际发送之前，我们将为用户提供一个<strong class="ih hj">确认对话框</strong>来删除帖子。我们将创建一个mixin类来重用两个组件之间的确认对话。</li><li id="9716" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">当我们从FirstComponent切换到SecondComponent时，或者反之亦然，在组件中对observables的任何<strong class="ih hj">订阅都必须关闭</strong>。通过创建一个mixin类，这个行为将再次被重用。</li></ol><p id="dc96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从定义删除帖子的方法的<strong class="ih hj">数据服务</strong>开始。</p><p id="ff23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> deletePost() </strong>接受一个<strong class="ih hj"> postId </strong>并发出一个<strong class="ih hj"> DELETE </strong> Http请求，删除与<strong class="ih hj"> postId </strong>对应的帖子。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div><figcaption class="jp jq et er es jr js bd b be z dx">DataService</figcaption></figure><p id="0118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们转到<strong class="ih hj"> mixins.ts </strong>文件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="5ee6" class="ko kp hi kk b fi kq kr l ks kt">type <strong class="kk hj">GConstructor&lt;T = {}&gt;</strong> = new (…args: any[]) =&gt; T;</span></pre><ol class=""><li id="78d0" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><strong class="ih hj">g构造器</strong>是我们已经创建的一个类型，用于创建某个<strong class="ih hj">通用类型T </strong>的对象。<strong class="ih hj"> &lt; T={} &gt; </strong>表示<strong class="ih hj"> {} </strong>应该是T的默认值，除非另有说明。</li></ol><p id="03b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来分解一下语法。</p><p id="04b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj"> ()= &gt; T </strong>表示不带参数的基于箭头的函数，返回<strong class="ih hj">类型</strong> <strong class="ih hj"> T </strong>。</p><p id="d260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj"> (…args:any[])= &gt; T </strong>表示一个函数，它接受任意数量的参数(这就是[])的原因<strong class="ih hj">类型any </strong>并且这个函数返回<strong class="ih hj">类型T </strong>。</p><p id="de3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;<strong class="ih hj">new</strong><strong class="ih hj">(…args:any[])=&gt;T</strong>表示该函数是一个<strong class="ih hj">类构造函数</strong>，可以用<strong class="ih hj"> new关键字</strong>调用。它是一个函数，类构造函数可以作为参数传递给它。</p><p id="86f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们已经导出了两个方法:<strong class="ih hj">confirmationDialogueMixinFunction()</strong>和<strong class="ih hj">commonObservableUnsubscribeMixinFunction()</strong>来帮助创建一个用于重用行为的mixin类。</p><p id="8c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从<strong class="ih hj">confirmationDialogueMixinFunction()开始。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><ol class=""><li id="80af" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><strong class="ih hj">confirmationDialogueMixinFunction()</strong>是一个<strong class="ih hj"> mixin函数</strong>，它接受一个<strong class="ih hj">基类</strong>作为参数，这个基类属于<strong class="ih hj">类型</strong>类型<strong class="ih hj">基类</strong>。</li><li id="b0f8" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">现在让我们检查下面的语法:</li></ol><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="5f98" class="ko kp hi kk b fi kq kr l ks kt">export function confirmationDialogueMixinFunction<br/><strong class="kk hj">&lt;BaseType extends GConstructor&lt;ModalType&gt;&gt;</strong><br/><strong class="kk hj">(BaseClass: BaseType)</strong></span></pre><p id="babc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> &lt; BaseType扩展g constructor&lt;modal type&gt;&gt;</strong>表示BaseType必须与<strong class="ih hj"> GConstructor </strong>类型兼容，即BaseType类型的BaseClass必须是类构造函数。</p><p id="5d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类中的构造函数必须有参数，其名称和类型与类型中的参数相匹配。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="5b88" class="ko kp hi kk b fi kq kr l ks kt">type <strong class="kk hj">ModalType </strong>= {<br/>ngModalService: NgbModal;<br/>};</span></pre><p id="e4a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，那个<strong class="ih hj">模式类型</strong>有一个类型<strong class="ih hj"> NgbModal的参数<strong class="ih hj"> ngModalService </strong>。这意味着基类的构造函数必须传递相同的参数。没有NgbModal类型的ngModalService </strong>我们不能调用引导对话。所以这个检查很重要。</p><p id="1777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。</strong>mixin函数返回一个匿名类，它扩展了这个<strong class="ih hj">基类</strong>。我们已经定义了这个匿名类并返回了它。这个匿名类现在可以访问基类的所有属性和方法。</p><p id="8329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这个匿名类<strong class="ih hj"> </strong>中定义了一个方法<strong class="ih hj">openconfirmdiation()</strong>，它将打开一个引导确认对话框，以确认用户是否真的想要删除这篇文章。</p><p id="ce8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们能够从<strong class="ih hj"> this关键字</strong>中访问<strong class="ih hj"> ngModalService </strong>属性。我们还没有在匿名类的任何地方定义ngModalService。记住，匿名类扩展了基类，所以它必须能够访问基类的所有属性。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="cfe7" class="ko kp hi kk b fi kq kr l ks kt">const modalReference = <strong class="kk hj">this.ngModalService</strong>.open<br/>( ConfirmationDialogueComponent, modalOptions );</span></pre><p id="176f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">ConfirmationDialogueComponent</strong>是向用户显示确认消息的组件。组件的内容在这里并不重要。</p><p id="c87f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们转到<strong class="ih hj">commonObservableUnsubscribeMixinFunction()</strong>。这和我们之前看到的非常相似。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="552a" class="ko kp hi kk b fi kq kr l ks kt">export function commonObservableUnsubscribeMixinFunction<br/><strong class="kk hj">&lt;BaseType extends GConstructor&gt;<br/>(BaseClass: BaseType)</strong></span></pre><p id="c15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，从<strong class="ih hj"> &lt; BaseType扩展GConstructor &gt;，</strong>它暗示了BaseType的BaseClass一定是一个类构造函数。</p><p id="603d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里对基类的构造函数中必须传递的参数没有限制。这是因为我们没有向GConstructor传递任何类型参数。任何基类都有资格访问这个方法，其中基类中所有可观察对象的所有订阅都将被关闭。</p><p id="e7fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义的mixin函数返回一个匿名类，它将扩展基类。在这个匿名类中，我们定义了一个名为<strong class="ih hj"> unsubscribeSubject </strong>的主题，并定义了一个方法<strong class="ih hj"> destroy() </strong>。</p><p id="8a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只要<strong class="ih hj">取消订阅Subject </strong>不发出值，基类中的所有订阅都将打开。</p><p id="a58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将看到两点:</p><p id="166a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt; first component如何使用我们在mixins.ts中定义的两个方法返回的匿名类创建mixin类</p><p id="de55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;还有<strong class="ih hj"> FirstComponent </strong>如何能够访问mixin类中定义的方法。</p><p id="4ede" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SecondComponent的行为是FirstComponent的复制，因此它是不言自明的。</p><p id="0709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AppComponent模板:</strong> FirstComponent和SecondComponent托管在AppComponent内部。正如您在下面看到的，我们提供了导航到这些组件的按钮。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/88d4f66f43bca64cf39b39e790f210b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gmLOctdT6bxOqt5oSI73w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Mixins Application</figcaption></figure><p id="ace9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我点击<strong class="ih hj">“转到第一个组件”，</strong>第一个组件看起来如下。它只有一个标题和删除文章的按钮。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/58ed6b5473c532174b3ce173c8dec33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xwGXC4uqwbA-LWDUs-T6w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">FirstComponent</figcaption></figure><p id="07ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> FirstComponent模板</strong>:如前所述，该模板包含一个删除帖子的按钮<strong class="ih hj">。</strong>点击按钮调用<strong class="ih hj"> confirmAction() </strong>，传递一个对象作为参数。这个对象包含两个属性:<strong class="ih hj"> action </strong>和<strong class="ih hj"> postId </strong>作为参数。为了简单起见，我们对要删除的文章的postId进行了硬编码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="8f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一个组件类别</strong>:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kh ki l"/></div></figure><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="2f63" class="ko kp hi kk b fi kq kr l ks kt">const <strong class="kk hj">firstComponentMixin </strong>= commonObservableUnsubscribeMixinFunction(<br/>confirmationDialogueMixinFunction(</span><span id="d0d4" class="ko kp hi kk b fi ku kr l ks kt"><strong class="kk hj">class Parent {<br/>constructor(public ngModalService: NgbModal) {}<br/>}</strong><br/>)<br/>);</span></pre><p id="04b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> firstComponentMixin </strong>持有FirstComponent将要扩展的<strong class="ih hj"> mixin类</strong>。让我们看看它是如何创建的。</p><p id="76fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们调用了<strong class="ih hj">confirmationDialogueMixinFunction()</strong>，将一个名为<strong class="ih hj"> Parent </strong>的类作为参数传递。这个类的父类包含一个构造函数，我们已经向它传递了与类型<strong class="ih hj"> ModalType </strong>中所期望的相同的参数。因此，这个父类就是我们作为参数传递给mixin.ts中的<strong class="ih hj">confirmationDialogueMixinFunction()</strong>的<strong class="ih hj">基类</strong></p><p id="911e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">confirmationDialogueMixinFunction()</strong>将返回第一个匿名类，它将扩展父类。因此，返回的第一个匿名类现在将是作为参数传递给<strong class="ih hj">commonObservableUnsubscribeMixinFunction()的<strong class="ih hj">基类</strong>。</strong></p><p id="5cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">commonObservableUnsubscribeMixinFunction()</strong>将再次返回扩展第一个匿名类的第二个匿名类。</p><p id="de3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二个匿名类是firstComponentMixin </strong>中的mixin类。因为mixin类扩展了第一个匿名类，而第一个匿名类扩展了父类，这意味着<strong class="ih hj"> mixin类可以访问父类和第一个匿名类</strong>的属性和方法。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="812c" class="ko kp hi kk b fi kq kr l ks kt">export class <strong class="kk hj">FirstComponent extends firstComponentMixin</strong> implements OnInit {</span><span id="d6cf" class="ko kp hi kk b fi ku kr l ks kt"><strong class="kk hj">constructor(private service: DataService, ngModalService: NgbModal) {super(ngModalService);}</strong></span></pre><p id="89af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，<strong class="ih hj"> FirstComponent扩展了我们已经创建的mixin类</strong>。</p><p id="6f86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当点击“删除帖子”按钮时，调用<strong class="ih hj"> confirmAction() </strong>，该函数调用<strong class="ih hj">confirmationDialogueMixinFunction()返回的匿名类定义的<strong class="ih hj">openconfirmindialogue()</strong>。</strong></p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="e8ee" class="ko kp hi kk b fi kq kr l ks kt"><strong class="kk hj">confirmAction(details: any) </strong>{</span><span id="e098" class="ko kp hi kk b fi ku kr l ks kt">this.modalOptions.backdrop = ‘static’;<br/>this.modalOptions.keyboard = false;<br/>this.modalOptions.windowClass = ‘first-component-confirm-modal’;</span><span id="234b" class="ko kp hi kk b fi ku kr l ks kt">let data = {<br/>heading: `Confirm ${details.action}`,<br/>body: `Please confirm if you want to delete this post with ID &lt;b&gt;${details.postId}&lt;/b&gt;.`,<br/>};</span><span id="01f7" class="ko kp hi kk b fi ku kr l ks kt"><strong class="kk hj">this.openConfirmDialogue(this.modalOptions, data)</strong>.subscribe((data) =&gt; {<br/><strong class="kk hj">this.deleteExistingPost(details.postId);</strong><br/>});</span><span id="1774" class="ko kp hi kk b fi ku kr l ks kt">}</span></pre><p id="a4aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> openConfirmDialogue() </strong>完全负责打开引导对话，接受来自用户的肯定/否定确认，并将其返回给FirstComponent，以它想要的方式处理它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1b58db37a69ee62c17f5a1853ad5d935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KknZFA0bIT5gqV3XXS5kIw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Confirmation Dialogue</figcaption></figure><p id="1d33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FirstComponent将调用<strong class="ih hj"> deleteExistingPost()，</strong>，后者又调用<strong class="ih hj">数据服务</strong>中的<strong class="ih hj"> deletePost() </strong>删除帖子<strong class="ih hj">，</strong>，如果用户确认删除帖子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="018e" class="ko kp hi kk b fi kq kr l ks kt"><strong class="kk hj">deleteExistingPost(postId: number) {</strong><br/>let subs = this.service<br/>.deletePost(postId)<br/><strong class="kk hj">.pipe(takeUntil(this.getObservable()))</strong><br/>.subscribe((x) =&gt; console.log(x));<br/>this.subscriptions.push(subs);<br/>}</span></pre><p id="3786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，只要<strong class="ih hj"> getObservable() </strong>返回的subject没有发出值，对<strong class="ih hj">数据服务</strong>中<strong class="ih hj"> deletePost() </strong>返回的observable的订阅就会持续。</p><p id="a6b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> getObservable() </strong>是<strong class="ih hj">commonObservableUnsubscribeMixinFunction()返回的匿名类中定义的方法。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/a766c4bfcd01d7085236159c3aa9cc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBkCSFAvVQc0ofBN26RVGQ.png"/></div></div></figure><p id="9aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我点击“<strong class="ih hj">转到第二个组件</strong>”按钮，将会触发<strong class="ih hj">ngondestory()生命周期挂钩</strong></p><p id="1fe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个钩子中，我们将调用<strong class="ih hj">commonObservableUnsubscribeMixinFunction()返回的匿名类中定义的<strong class="ih hj"> destroy() </strong>。</strong></p><p id="4cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> destroy() </strong>中，我们调用主题上的<strong class="ih hj"> next() </strong>，这将自动关闭FirstComponent中的所有订阅。</p><p id="0375" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在下面的屏幕截图中看到的，SecondComponent已经加载，在控制台日志中，我们还可以看到FirstComponent中的单个订阅已经关闭。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/b2376fbd353aa4622d774de1af545f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBkidpa_5Wqye0JP1sbLIQ.png"/></div></div></figure><p id="9b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SecondComponent将显示类似的行为，通过这种方式，您可以跨多个组件重用“打开确认对话”和“取消订阅可观察的”逻辑。</p><p id="28bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是在SecondComponent中点击<strong class="ih hj">【Delete Post】</strong>按钮时的确认对话框截图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/28aa9574c43eb52d0dea438ee38abd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRbaE6BqcPxWebTQiEjxWA.png"/></div></div></figure><p id="5521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户给出肯定的确认，postId为<strong class="ih hj">2的帖子被删除。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/d63deac466e0980134db25f42fbff78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taZLtnRgXQ0Plu1v3lNRQQ.png"/></div></div></figure><p id="2988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，当通过点击<strong class="ih hj">“Go to FirstComponent”</strong>按钮切换回first component时，我们看到SecondComponent中的单个订阅被关闭。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/1155e11a62292a052e36b1edfdf398de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JUk1-06HQKWjiOU9UybWA.png"/></div></div></figure><p id="e0cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我总是发现先在typescript项目中做一个简单的例子来清楚地理解这个概念，因为我们只有一个文件，没有太多的依赖关系需要关注。</p><p id="bb92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个工作的typescript项目示例，它不同于angular示例，但说明了mixin概念。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kz ki l"/></div></figure><p id="4a55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以查看下面的整个工作角度示例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kz ki l"/></div></figure></div></div>    
</body>
</html>
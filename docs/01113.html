<html>
<head>
<title>UseFetch Hook, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UseFetch挂钩，解释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/usefetch-hook-explained-4e11d7cf9ee3?source=collection_archive---------10-----------------------#2021-03-28">https://medium.com/geekculture/usefetch-hook-explained-4e11d7cf9ee3?source=collection_archive---------10-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="afd1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个方便的自定义“反应”挂钩的简单指南。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">The ‘React’ Logo</figcaption></figure><p id="096e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">脸书的“React”库使得用JavaScript开发前端组件变得更加简单和程序化。因为它是一个开源库，所以会不断地创建自定义特性，这使得开发人员的工作变得更加容易。</p><p id="3e38" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">其中一个自定义特性是useFetch挂钩。对于那些门外汉来说，钩子是React的一个相对较新的附加功能，它允许用户访问库特性的状态和生命周期特性，而无需编写一个全新的类。你可以在这里阅读基本概况:<a class="ae kj" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-overview.html</a></p><h1 id="b325" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">使用Fetch —简介</h1><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="0f4d" class="lh kl hi ld b fi li lj l lk ll">yarn add use-http    or    npm i -S use-http</span></pre><p id="cf71" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一步是在您的终端中使用上面的命令之一来安装钩子库。一旦安装了这个包，就可以使用这个钩子了。</p><p id="a7ac" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">useFetch的主要特性之一是，它允许你抽象出向服务器发出“Fetch”请求的许多繁琐的方面，并更容易地获得对数据和元数据的访问。</p><p id="5ca1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看一个实际例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/5362c396adcd34355bb98ca12b226c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4eP8r0KxFddOvsbalHV5A.png"/></div></div></figure><p id="c2bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">哇哦。这里发生了很多事。看看能不能分解一些关键部分。</p><p id="9279" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您会注意到在第6行，我们将useFetch挂钩初始化为“www.example.com”，并能够从中获得一些非常常见的属性，如“get”和“post”请求，以及任何“errors”和“loading”属性。</p><p id="7936" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们在回调函数中使用“get”和“post”来避免重复写出我们的URL(稍后您将看到我们如何抽象处理它们返回的承诺)。</p><p id="f777" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">“错误”和“加载”属性有助于条件呈现。&amp;&amp;运算符在计算右侧值之前检查左侧值是否为真。这允许我们执行一个“短路”操作，该操作将有条件地呈现“加载”或“错误”字符串，仅当来自我们的获取的响应认为这些值为真时。</p><p id="3b0e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们已经可以看到useFetch钩子在保持代码干燥方面很有用(不要重复)。您还会注意到，我们定义但从不调用我们的“loadInitialRecipes”函数，这意味着我们的食谱还不会显示出来！让我们看看是否可以使用给我们的可选参数来重构我们的代码。</p><h1 id="057e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">参数:“选项”和依赖数组</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ln"><img src="../Images/69e5b0af266d2db87553f0042ea9dc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNOwJQowHbO8F6mc87OwzA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Automatic fetch.</figcaption></figure><p id="6f05" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您会注意到，在这次迭代中，我们不必编写一个完整的函数来描述我们的“get”请求并处理作为结果返回的承诺。“数据”键为我们保存该值，并允许我们将其直接映射到组件上。</p><p id="ee3b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是等等，我们也从来没有调用过这个函数，那么数据是如何更新的呢？这就是依赖数组的用武之地。</p><p id="f713" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您曾经使用过useEffect钩子，那么您会对依赖数组非常熟悉。它在useFetch中的操作方式相同。每当依赖数组中的状态或变量更新时，就会调用fetch。因为在我们的例子中它是空的，这意味着当组件被挂载时fetch被调用。</p><p id="97e5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果根本没有声明依赖数组，则在代码中的其他地方调用类似“get”或“post”的方法之前，useFetch不会触发。</p><p id="ec44" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">options参数将接受任何本机提取选项，因此您可以使用它来重构您的“patch”、“post”和“delete”提取。</p><p id="575b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们再看一个例子，它稍微重构了一下我们的“post”方法。</p><h1 id="e5e5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">异步/等待和响应</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/ffcdc1e62ba7324daec551bbe603822f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD4seyAX26or6Qa2X2wyNg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Using the ‘response’ key</figcaption></figure><p id="aefb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可能注意到的第一件事是我们去掉了依赖数组。那就好！因为我们只希望在单击“添加食谱”按钮时触发fetch，所以我们不需要它。</p><p id="244e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您应该注意的另一件事是addRecipe函数中的“async/await”关键字。这些都很简单。在一个函数之前声明“async”仅仅意味着你计划异步地使用那个函数(像所有的fetch请求一样),而在post请求之前放置“await”则意味着只有在post请求通过后才设置“newRecipe”的值(跳过承诺的语法)。</p><p id="ba46" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可能注意到的最后一件事是我们的useFetch钩子中新的“response”键。这只是允许我们在添加新食谱到我们的列表之前，检查返回给我们的“200 OK”响应。</p><p id="9ffe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可能倾向于像这样析构响应对象:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="f815" class="lh kl hi ld b fi li lj l lk ll">const { ok } = response</span></pre><p id="1612" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不要这样做。</p><p id="1c2a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">析构响应对象将返回一个过时的值，该值不与当前获取的状态保持一致。所以，虽然你可能认为你的回答是“好”，但实际上并不是“好”。</p><h1 id="a019" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="31b6" class="pw-post-body-paragraph jn jo hi jp b jq lp ij js jt lq im jv jw lr jy jz ka ls kc kd ke lt kg kh ki hb bi translated">总而言之，useFetch是我们工具包中的另一个工具，它使得在React中使用Fetch API变得更加直接和灵活。无论您是使用一个依赖数组将您的获取与其他函数和事件联系起来，还是仅仅使您的代码变得更加枯燥，useFetch挂钩在所有情况下都是有用的，并且是对React应用程序的一个很好的补充。</p><p id="3316" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">更多信息的有用资源:<a class="ae kj" href="https://use-http.com/#/" rel="noopener ugc nofollow" target="_blank">https://use-http.com/#/</a></p></div></div>    
</body>
</html>
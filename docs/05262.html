<html>
<head>
<title>Benchmarking Sorting Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的基准排序算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/benchmarking-sorting-algorithms-in-python-437ba864b799?source=collection_archive---------19-----------------------#2021-07-16">https://medium.com/geekculture/benchmarking-sorting-algorithms-in-python-437ba864b799?source=collection_archive---------19-----------------------#2021-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0f48" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">看看有多少种解决排序问题的方法比较</h2></div><p id="ef27" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(对于基准测试结果和代码，请滚动到文章的底部)</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/372b0c93df6b98e626ccec06395666b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGY1VNlAHRqTmZhUiyB5xA.jpeg"/></div></div></figure><p id="2140" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">排序问题是一个不需要介绍的问题，它是给定一个长度为n的整数数组A，其中的元素是未排序的，输出应该是相同的数组A，其中的元素是已排序的(通常是从最少到最多)。</p><p id="6f04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有许多方法可以解决这个问题，并且已经创建了许多算法，其唯一目的是对数字进行排序。现在，你可能认为这个问题是微不足道的，在某种程度上，它是微不足道的，毕竟人类可以查看集合{5，2，1，6，3}并轻松地将其分类为{1，2，3，5，6}。虽然这是真的，但是当数组开始变大时，真正的问题就出现了。</p><p id="07a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是那些算法的用武之地，它们把数组作为输入，对它进行一些操作，然后数组排序出来。这个解释可能非常简单，为了帮助理解它，我将给出一个这样的算法如何工作的例子。</p><p id="1452" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有一个数组A= {6，4，0，3，2}，我们要做的第一件事是找到数组中最小的元素，并把它移到开头。所以最小的元素是0，所以我们将0和6互换得到A = {0，4，6，3，2}，你已经可以看到数组在开始部分是用0排序的。然后我们对一个n-1大小的数组重复这个过程，所以第一次我们查看整个数组，下一次，我们将查看从4到2(包括4和2)的数组，而不查看0，因为我们知道它在它的排序位置。</p><p id="e5b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我向您描述的算法称为Selectionsort，因为它选择数组中的最小元素，并将其放在数组的开头。像选择排序一样，还有许多其他具有相同目的的排序算法。</p><p id="3ddc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其他排序算法以类似的方式工作，我将对它们进行快速概述，以便您可以了解它们是如何工作的，但是如果您想要更好、更全面的解释，GeeksforGeeks是一个很好的来源。</p><p id="82b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种算法是Quicksort，顾名思义，它对数组进行快速排序。它通过使用pivot元素(数组中的任何元素)工作，并将所有小于它的元素放在它的左边，所有大于它的元素放在右边。如果你反复这样做，数组就会被排序。</p><p id="3061" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们有Mergesort，它的工作原理是将数组分成左右两部分，并一直这样做，直到左右数组的大小为1。然后，它合并数组的左右部分，并有效地对它们进行排序。然后，这个合并过程继续进行，直到整个数组被排序。</p><p id="e6ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果前两个算法对你来说没有意义，不要担心，因为接下来的两个非常容易理解，但我会告诉你一点关于前两个算法所依赖的概念，这个概念叫做递归，它涉及到通过将问题分成更小的问题并解决它们来解决问题。然后你用这些子问题的解来解决原问题。换句话说，它是根据自身来定义一个功能。了解更多信息的绝佳来源是极客论坛和维基百科，以及一些Youtube视频。</p><p id="a821" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个算法叫做Bubblesort，它的工作方式如下，你选择数组中的第一个元素，然后选择紧接其后的元素(索引I和i + 1)。然后你比较两者，如果第一个小于第二个，你交换它们。然后对第二个和第三个元素进行同样的操作，直到最后两个元素。在这一点上，我们有一个部分排序的数组，但是我们需要重复这个过程，直到我们不再需要交换，这时算法就完成了。</p><p id="3123" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们有Insertionsort，它首先查看数组中的第二个元素，并将其与第一个元素进行比较，如果小于第一个元素，则将第二个元素放在数组的开头。然后查看数组中的第三个元素，并将其与第二个元素进行比较，如果第三个元素比第二个元素少，则将其放在数组的开头。重复这个过程，直到到达数组的末尾，就完成了！这个算法之所以有效，是因为它对你正在查看的元素后面的所有内容进行排序，最后一个算法是Selectionsort，我们已经看过了。</p><p id="6bea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(现在为一直在等待结果的人们)</p><p id="a534" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您已经知道了我实现了哪些算法以及它们是如何工作的，您应该能够理解基准测试的结果。唯一要记住的是，当算法没有在一定的时间限制内完成执行时，它们会获得10秒的运行时间。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kf"><img src="../Images/f54e85fe2810e3ebc124ca7223cd1180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5aHqH60ncA29Lpx_lGojA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Here You can see the benchmarks running on my computer</figcaption></figure><p id="f1bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，Github上提供了所有代码，因此您可以在自己的计算机上运行基准测试，亲自查看算法的性能，如果您喜欢，可以给它打一颗星:)。</p><div class="kk kl ez fb km kn"><a href="https://github.com/sanaynesargi/SortBenchmarker/" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hj fi z dy ks ea eb kt ed ef hh bi translated">sanaynesargi/SortBenchmarker</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">一个测试常用排序算法并显示其整体性能的程序</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">github.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb kd kn"/></div></div></a></div><p id="be84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有更多的输出图像，它包含两个图和一个名为results.json的JSON文件，用于导出数据。同样在线图上，x轴表示时间，y轴表示以10的幂表示的阵列大小。在表格中，y轴代表排序算法名称，x轴代表数组大小，单元格代表排序所用的时间。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lc"><img src="../Images/b19c2534258a25c665b8fa9dc5150705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YReKPesqciPwyGzkxsk6ow.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">The X-axis is time in seconds and Y-axis is for array size in powers of 10</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ld"><img src="../Images/f1ff27c2beceb7f9d945ae1cb81cb9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wS23hoQ_v3FtYCNzTr-FeA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">The X-axis is for array size, Y-axis is for sort name, and cells are the sort time</figcaption></figure><p id="ce85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，让我们回顾一下基准测试的结果。我们的总体领先优势是Quicksort，与其他所有算法(除了Mergesort)相比，它的执行时间非常短，紧随其后的是Mergesort，它的表现也非常好，与Mergesort不相上下，甚至在第一次和第二次测试中击败了它！接下来，我们选择了一种排序方式，它在早期表现不错，但在较大的数组规模上无法与Mergesort和Quicksort竞争。排在第四位的是Insertionsort，它在开始和整个基准测试中的性能都比较慢。最后，排在最后的是Bubblesort，不过根据你的论点，你可以把最后两个调一下，因为Bubblesort确实比Insertionsort和Selectionsort(在一个例子中)执行得更好，但是在最后两个测试中没有完成执行。我个人认为这是不可接受的，但你可能会有不同的想法。</p><p id="e27a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢，并希望学到一些东西。</p><p id="ec5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
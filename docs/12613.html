<html>
<head>
<title>Concurrency in Java: Executor Service (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的并发性:执行器服务(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/concurrency-in-java-executor-service-part-2-777badd432f7?source=collection_archive---------2-----------------------#2022-05-22">https://medium.com/geekculture/concurrency-in-java-executor-service-part-2-777badd432f7?source=collection_archive---------2-----------------------#2022-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="71e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对<br/> <a class="ae jd" rel="noopener" href="/geekculture/concurrency-in-java-executor-service-part-1-918b5db79c72">的继续:Java中的并发:执行器服务(第一部分)</a></p><h1 id="076f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Java中的内存模型</h1><p id="9935" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">JVM内部使用的Java内存模型在线程堆栈和堆之间划分内存。Java虚拟机中运行的每个线程都有自己的线程堆栈。线程调用堆栈包含由线程调用以到达当前执行点的方法的历史信息。当线程执行其代码时，调用堆栈会发生变化。</p><p id="2ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程调用堆栈还包含执行中使用的局部变量列表。每个线程都有自己的调用栈，不能访问其他线程栈的内存。因此，即使两个不同的线程正在执行相同的代码块，每个线程调用堆栈中也会创建两个局部变量副本。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/dc7aaf9240eeaad40f302da26fe958b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*zENgZ4vntDb-500oO_v8tQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">JVM Memory Management</figcaption></figure><p id="27cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果局部变量是基元类型的，它就完全存储在堆栈中。如果不是，那么变量存储在堆中，引用存储在调用堆栈中。静态类变量也和类定义一起存储在堆中。如果两个线程同时在同一个对象上调用一个方法，它们都可以访问对象的成员变量，但是每个线程都有自己的局部变量副本。</p><p id="ba84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM可以利用两种内存:</p><ul class=""><li id="8a43" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">保留的</strong> —保证主机操作系统可用的大小(但仍未分配，也不能被JVM访问)—这只是一个承诺</li><li id="3037" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">已提交</strong> —已经被JVM获取、访问和分配</li></ul></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="d42b" class="je jf hi bd jg jh lo jj jk jl lp jn jo jp lq jr js jt lr jv jw jx ls jz ka kb bi translated">可调用接口</h1><p id="4ae3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在Java中有两种创建线程的方法，要么扩展Thread类，要么实现Runnable接口。然而，Runnable类中缺少的一个特性是run()方法不能返回值，也就是说，它的返回类型为null。Callable解决了这个问题。</p><p id="a8c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可调用接口和可运行接口有两个基本区别:</p><ul class=""><li id="eab3" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">要实现Runnable接口，必须实现run()方法，该方法的返回类型为null。要实现一个可调用的接口，你需要实现call()方法，它可以返回一个结果。</li><li id="4b8b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">run()方法不能引发异常。这个特性在可调用接口的call()方法中也有。</li></ul><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="1461" class="ly jf hi lu b fi lz ma l mb mc">public Object call() throws Exception;</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="1c5e" class="je jf hi bd jg jh lo jj jk jl lp jn jo jp lq jr js jt lr jv jw jx ls jz ka kb bi translated">将来的</h1><p id="bba6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与Runnable类似，Callable是一个接口，它封装了要在不同线程上运行的任务。但是Callable的另一个问题是存储异步处理后到达的结果。未来的界面解决了这个问题。Future用于存储从不同线程获得的结果，可用于Runnable和Callable任务。</p><p id="9418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未来代表异步计算的结果。提供了一些方法来检查计算是否完成、等待计算完成以及检索计算结果。计算完成后，只能使用get方法检索结果，如果需要，可以阻塞，直到计算就绪。取消是由cancel方法执行的。提供了其他方法来确定任务是正常完成还是被取消。计算一旦完成，就不能取消。如果为了可取消性而使用Future，但不提供可用的结果，可以声明Future &gt;形式的类型，并返回null作为底层任务的结果。</p><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="914e" class="ly jf hi lu b fi lz ma l mb mc">boolean cancel(boolean mayInterruptIfRunning);<br/>boolean isCancelled();<br/>boolean isDone();<br/>V get() throws InterruptedException, ExecutionException;<br/>V get(long timeout, TimeUnit unit)<br/>    throws InterruptedException, ExecutionException, TimeoutException;</span></pre><p id="c265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们有两个get()方法的实现。第一个将阻塞执行并无限期等待以获得结果，而另一个将在取消任务执行之前等待特定的时间。</p><p id="27a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未来任务:可运行界面的未来</p><p id="5446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FutureTask类是Future的一个实现，它实现了Runnable，因此可以由执行器执行。例如，上述带有submit的结构可以替换为:<br/><br/>future task&lt;String&gt;future = new future task&lt;&gt;(task)；<br/> executor.execute(未来)；</p><p id="98d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为FutureTask实现了Runnable，所以可以将FutureTask提交给执行器执行。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="81a6" class="je jf hi bd jg jh lo jj jk jl lp jn jo jp lq jr js jt lr jv jw jx ls jz ka kb bi translated">向ExecutorService分配任务</h1><p id="89ff" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><em class="md"> ExecutorService </em>可以执行<em class="md">可运行</em>和<em class="md">可调用</em>任务。我们可以使用几种方法将任务分配给<em class="md"> ExecutorService </em>，包括从<em class="md"> Executor </em>接口继承的<em class="md"> execute() </em>，以及<em class="md"> submit() </em>、<em class="md"> invokeAny() </em>和<em class="md"> invokeAll() </em>。</p><p id="b454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="md"> execute() </em> </strong>方法在未来某个时间执行给定的命令。根据执行器实现的判断，命令可以在新线程、池化线程或调用线程中执行。它有一个返回类型<em class="md"> void，并且</em>没有给出任何获得任务执行结果或检查任务状态(它正在运行)的可能性:</p><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="6940" class="ly jf hi lu b fi lz ma l mb mc">executorService.execute(runnableTask);</span></pre><p id="7a0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="md"> submit() </em> </strong>向<em class="md"> ExecutorService </em>提交一个<em class="md">可调用</em>或<em class="md">可运行</em>任务，并返回一个<em class="md"> Future类型的结果。</em>它提交一个返回值的任务来执行，并返回一个代表任务的未决结果的Future。未来的get方法将在成功完成后返回任务的结果。：</p><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="e6bd" class="ly jf hi lu b fi lz ma l mb mc">Future&lt;String&gt; future = <br/>  executorService.submit(callableTask);</span></pre><p id="2240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="md"> invokeAny() </em> </strong>将一组任务分配给一个<em class="md"> ExecutorService </em>，使每个任务运行，并返回一个任务成功执行的结果(如果有成功的执行)。执行给定的任务，返回一个成功完成的任务的结果(即，没有抛出异常)，如果在给定的超时时间过去之前有任何do。在正常或异常返回时，未完成的任务将被取消。但是这种方法增加了复杂性。如果在此操作过程中修改了给定的集合，则此方法的结果是未定义的。：</p><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="a3c9" class="ly jf hi lu b fi lz ma l mb mc"><strong class="lu hj">String</strong> result = executorService.invokeAny(callableTasks);</span></pre><p id="7fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="md"> invokeAll() </em> </strong>将任务集合分配给<em class="md"> ExecutorService </em>，使每个任务运行，并以<em class="md"> Future类型对象列表的形式返回所有任务执行的结果。</em>用于需要同时执行多个任务的情况。它执行给定的任务，当所有任务完成时，返回一个包含它们的状态和结果的期货列表。<strong class="ih hj"><em class="md">future . isdone</em></strong>对于返回列表的每个元素都是真。如果在此操作过程中修改了给定的集合，此方法的结果也是未定义的。：</p><pre class="ki kj kk kl fd lt lu lv lw aw lx bi"><span id="2e6b" class="ly jf hi lu b fi lz ma l mb mc">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="2934" class="je jf hi bd jg jh lo jj jk jl lp jn jo jp lq jr js jt lr jv jw jx ls jz ka kb bi translated">结论</h1><p id="6776" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Java Executor服务隐藏了大量的复杂性，但也使您可以轻松地钻研和调整内部工作方式。Executors类提供了许多处理不同用例的工厂方法。</p><p id="89f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使开发人员能够控制生成线程的数量和应该由单独线程运行的任务的粒度。ExecutorService的最佳用例是处理独立的任务，比如根据“一个任务一个线程”的方案处理事务或请求</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="db12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="md">恭喜你坚持到最后！在</em><a class="ae jd" href="https://twitter.com/bot_pragmatic" rel="noopener ugc nofollow" target="_blank"><em class="md">Twitter</em></a><em class="md">，</em><a class="ae jd" href="https://github.com/abinator-1308/abinator-1308" rel="noopener ugc nofollow" target="_blank"><em class="md">GitHub</em></a><em class="md">，</em><a class="ae jd" rel="noopener" href="/@abhinav.as1308"><em class="md">Medium</em></a><em class="md">，</em><a class="ae jd" href="https://www.linkedin.com/in/abinator-1308/" rel="noopener ugc nofollow" target="_blank"><em class="md">LinkedIn</em></a><em class="md">或</em><a class="ae jd" href="https://www.instagram.com/abinator_1308/" rel="noopener ugc nofollow" target="_blank"><em class="md">insta gram</em></a><em class="md">上随意谈论科技或任何很酷的项目。</em></p><p id="d0a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="9c6d" class="je jf hi bd jg jh lo jj jk jl lp jn jo jp lq jr js jt lr jv jw jx ls jz ka kb bi translated">参考</h1><ul class=""><li id="42a9" class="kt ku hi ih b ii kc im kd iq me iu mf iy mg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=6Oo-9Can3H8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=6Oo-9Can3H8</a></li><li id="97b7" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.baeldung.com/java-executor-service-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-executor-service-tutorial</a></li><li id="cfb9" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://dzone.com/articles/a-deep-dive-into-the-java-executor-service" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/a-deep-dive-into-the-Java-executor-service</a></li><li id="19c9" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">【https://www.geeksforgeeks.org/thread-pools-java/ T4】</li><li id="cf5f" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=sIkG0X4fqs4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=sIkG0X4fqs4</a></li><li id="4657" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=Dma_NmOrp1c" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Dma_NmOrp1c</a></li><li id="b4ee" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/executorservice . html</a></li><li id="e645" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.baeldung.com/java-local-variables-thread-safe" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-local-variables-thread-safe</a></li><li id="9f8f" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://dzone.com/articles/how-much-memory-does-a-java-thread-take" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/how-much-memory-do-a-Java-thread-take</a></li><li id="c631" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae jd" href="https://www.baeldung.com/java-stack-heap#:~:text=Stack%20Memory%20in%20Java%20is,%2DOut%20(LIFO)%20order." rel="noopener ugc nofollow" target="_blank">https://www . bael dung . com/Java-Stack-heap #:~:text = Stack % 20 memory % 20 in % 20 Java % 20 is，%2DOut%20(LIFO)%20order。</a></li></ul></div></div>    
</body>
</html>
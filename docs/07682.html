<html>
<head>
<title>Tutorial: Serial Connection Between Raspberry Pi and Arduino</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:Raspberry Pi和Arduino之间的串行连接</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tutorial-serial-connection-between-raspberry-pi-and-arduino-253a52099b2a?source=collection_archive---------9-----------------------#2021-09-27">https://medium.com/geekculture/tutorial-serial-connection-between-raspberry-pi-and-arduino-253a52099b2a?source=collection_archive---------9-----------------------#2021-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2426ae76365875eb96423c855319d6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Q9I6sJ6D1vguHldFM1GJA.png"/></div></div></figure><p id="7bbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您想要构建复杂的微控制器项目，需要在不同器件之间交换数据时，您需要一种快速可靠的方式来交换数据。在上一篇文章中，我们研究了串行UART连接，一种直接的一对一接口。本文是I2C协议系列的继续，这是一个具有多对多服务器和客户机的半双工双向通信系统。我们将看到如何连接一个Raspberry Pi和一个Arduino Uno来形成一个I2C连接，并在两个系统之间交换数据。</p><p id="0747" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于我的博客</em><a class="ae jp" href="https://admantium.com/blog/micro12_tutorial_i2c_connection/" rel="noopener ugc nofollow" target="_blank"><em class="jo">admantium.com</em></a>。</p><h1 id="c0db" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">设置</h1><p id="9c08" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在下面的设置中，Raspberry Pi将是控制器，Arduino Uno将是客户端。</p><h1 id="5ad8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接线</h1><p id="5f1c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们首先按如下方式连接两个器件:</p><ul class=""><li id="b028" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">连接Raspberry GPIO2 =&gt; Arduino D18 SDA</li><li id="7127" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">连接树莓GPIO3 =&gt; Arduino D19 SCL</li><li id="2d07" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">连接覆盆子接地引脚=&gt; Arduino接地</li></ul><p id="870d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您不确定引脚编号和配置，请参见<a class="ae jp" href="https://pinout.xyz/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi引脚布局</a>和<a class="ae jp" href="https://content.arduino.cc/assets/Pinout-UNOrev3_latest.pdf" rel="noopener ugc nofollow" target="_blank"> Arduino引脚布局</a>，或者阅读我之前的文章。</p><h1 id="6915" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">软件库</h1><p id="a1fc" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在Raspberry Pi上，我们需要安装一个I2C Raspian包和一个Python库。选择的库是SMBus，一种基于I2C的协议。要安装所有必需的软件，请执行以下命令来安装必需的库。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3a41" class="lq jr hi lm b fi lr ls l lt lu">apt-install i2c-tools<br/>sudo pip3 install smbus</span></pre><p id="a659" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于Arduino，不需要额外的设置。选择的库是Wire.h，它与Arduino IDE或plattform.io等第三方IDE捆绑在一起。</p><h1 id="2794" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Arduino: I2C客户端配置</h1><p id="dadb" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Arduino程序将导入<code class="du lv lw lx lm b">&lt;Wire.h&gt;</code>库，一个基本I2C通信的包装器。通过简单的调用<code class="du lv lw lx lm b">Wire.begin()</code>，它将启动一个可以对消息做出反应的IC2客户端。</p><p id="5319" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下程序实现了一个基本的I2C客户端:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3f79" class="lq jr hi lm b fi lr ls l lt lu">#include &lt;Arduino.h&gt;<br/>#include &lt;Wire.h&gt;</span><span id="3c10" class="lq jr hi lm b fi ly ls l lt lu">#define I2C_DEVICE_ADDRESS 0x44</span><span id="66a7" class="lq jr hi lm b fi ly ls l lt lu">void setup() {<br/>  Wire.begin(I2C_DEVICE_ADDRESS);<br/>  Wire.onReceive(receiveMsg);<br/>  Serial.begin(9600);<br/>  Serial.println("Listening for Input");<br/>}</span><span id="b770" class="lq jr hi lm b fi ly ls l lt lu">void loop() {<br/>  Serial.print(".");<br/>  delay(500);<br/>}</span></pre><p id="de05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该程序的工作原理如下:</p><ul class=""><li id="543b" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第2行:导入<code class="du lv lw lx lm b">&lt;Wire.h&gt;</code>库</li><li id="0f87" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第4行:定义Arduino可以到达的I2C客户端地址，这里是它的十六进制<code class="du lv lw lx lm b">0x44</code>(十进制68)——注意选择一个合适的7位地址，该地址不被同一总线上的任何其他设备使用</li><li id="1f6b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第7行:要创建I2C客户端，使用选择的地址执行<code class="du lv lw lx lm b">Wire.begin</code></li><li id="8547" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第8行:当服务器向该客户端发送消息时，回调函数<code class="du lv lw lx lm b">receiveMsg</code>将被执行</li></ul><p id="5a3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调函数定义如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5764" class="lq jr hi lm b fi lr ls l lt lu">void receiveMsg() {<br/>  if (Wire.available()) {<br/>    char c = Wire.read();<br/>    Serial.print(c);<br/>  }<br/>}</span></pre><p id="b8eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数工作原理如下:</p><ul class=""><li id="c72f" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第2行:检查在I2C总线上对于这个特定的客户端是否有一个活动的、未使用的消息</li><li id="f759" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第3行:读取消息的第一个字节，并存储为一个<code class="du lv lw lx lm b">char</code></li><li id="7a2c" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第4行:打印字符</li></ul><p id="6a11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们继续树莓派的设置。</p><h1 id="0783" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">树莓派</h1><p id="8429" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Raspberry Pi将以服务器角色启动I2C节点。在这个角色中，它可以主动向总线写入消息，并从客户端读取数据。</p><p id="ee64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的程序将打开一个小终端，等待用户输入，然后将这些数据发送给客户端。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4904" class="lq jr hi lm b fi lr ls l lt lu">from smbus import SMBus</span><span id="f964" class="lq jr hi lm b fi ly ls l lt lu">clientAddr = 0x44<br/>bus = SMBus(1)</span><span id="8fe0" class="lq jr hi lm b fi ly ls l lt lu">def i2cWrite(msg):<br/>  for c in msg:<br/>    bus.write_byte(clientAddr, ord(c))<br/>  return -1</span><span id="a01e" class="lq jr hi lm b fi ly ls l lt lu">def main():<br/>  print("Send msg to Arduino")<br/>  while True:<br/>    msg = input("$&gt; ")<br/>    print("...")<br/>    i2cWrite(msg)</span><span id="f2b8" class="lq jr hi lm b fi ly ls l lt lu">if __name__ == "__main__":<br/>  main()</span></pre><p id="eb9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们解释一下细节:</p><ul class=""><li id="d73c" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第1行:导入SMBus库</li><li id="45c8" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第3行:定义将接收消息的I2C客户端的地址，我们指定十六进制<code class="du lv lw lx lm b">0x44</code>，十进制144</li><li id="012d" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第4行:创建SMBus类的一个实例</li><li id="ccea" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第6行:自定义方法<code class="du lv lw lx lm b">ic2Write</code>接收一个<code class="du lv lw lx lm b">msg</code>字符串，在第8行，它将把这个字符串的每个字符发送给客户端</li><li id="c529" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第10行:<code class="du lv lw lx lm b">main</code>方法将开始一个无限循环(第12行)，向用户打开提示<code class="du lv lw lx lm b">$&gt;</code>并读取答案(第14行)，然后调用<code class="du lv lw lx lm b">ic2Write</code>并给出完整的消息。</li></ul><p id="58e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我们准备好了。</p><h1 id="d75a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">交换I2C消息</h1><p id="de19" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">首先，检查两个设备的接线。然后，通过Arduino IDE或Plattform IO等第三方IDE上传Arduino程序。</p><p id="3756" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在树莓Pi上，启动Python程序。在另一台终端上，检查是否注册了新的I2C硬件设备。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b9a6" class="lq jr hi lm b fi lr ls l lt lu">$&gt; ls /dev/*i2c*<br/>/dev/i2c-1</span></pre><p id="23e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有看到设备，请检查程序源代码。然后，如果一切正常，最后，使用I2C助手程序检查Arduino是否正确连接:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b8ea" class="lq jr hi lm b fi lr ls l lt lu">$&gt; i2cdetect -y 1</span><span id="d9ce" class="lq jr hi lm b fi ly ls l lt lu">     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f<br/>00:          -- -- -- -- -- -- -- -- -- -- -- -- --<br/>10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br/>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br/>30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br/>40: -- -- -- -- 44 -- -- -- -- -- -- -- -- -- -- --<br/>50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br/>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br/>70: -- -- -- -- -- -- -- --</span></pre><p id="5a1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此命令打印所有7位(即最大144位)连接的IC2设备的表格。您还可以使用以下命令显示设备的所有I2C功能。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="be5c" class="lq jr hi lm b fi lr ls l lt lu">$&gt; sudo i2cdetect -F 1</span><span id="8fb5" class="lq jr hi lm b fi ly ls l lt lu">Functionalities implemented by /dev/i2c-1:<br/>I2C                              yes<br/>SMBus Quick Command              yes<br/>SMBus Send Byte                  yes<br/>SMBus Receive Byte               yes<br/>SMBus Write Byte                 yes<br/>SMBus Read Byte                  yes<br/>SMBus Write Word                 yes<br/>SMBus Read Word                  yes<br/>SMBus Process Call               yes<br/>SMBus Block Write                yes<br/>SMBus Block Read                 no<br/>SMBus Block Process Call         no<br/>SMBus PEC                        yes<br/>I2C Block Write                  yes</span></pre><p id="d49f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在启动Python程序的终端上，键入任意输入。然后，在Arduinos串行控制台中，您应该会看到收到的消息</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="83b9" class="lq jr hi lm b fi lr ls l lt lu">Listening for Input<br/>.......................Hello from Raspberry Pi!................</span></pre><p id="770e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太棒了。我们可以在树莓Pi和Arduino之间交换I2C消息。</p><p id="2074" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是从客户机向服务器发送数据呢？在I2C中，服务器控制所有的通信，它主动向客户机请求数据，只有在被请求时，客户机才会应答。不可能主动将数据从客户端发送到服务器。引用<a class="ae jp" href="https://electronics.stackexchange.com/questions/467938/how-to-end-sending-data-over-i2c-by-slave-or-master?answertab=votes#tab-top" rel="noopener ugc nofollow" target="_blank"> StackExchange </a>:</p><p id="ac93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">所有通信都由服务器控制。客户端什么都不做，服务器不想让它做。服务器控制时钟的速度(时钟拉伸不承受)和读取多少字节。在任何时候，当服务器没有告诉它的时候，客户端都不应该试图强迫数据线。应该预先知道数据结构。</em></p><p id="6463" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您想使用I2C总线在设备之间传递状态信息，那么您需要设计一个主动轮询系统。首先，每个客户端都需要缓冲其状态消息。其次，服务器需要定期调用客户机，收集状态信息，并根据这些信息采取行动。</p><h1 id="57f2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="d43e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">本文展示了从充当服务器的Raspberry Pi到充当客户端的Arduino Uno建立I2C连接的基本步骤。对于Arduino，我们使用内置的库Wire.h，它处理具体的I2C消息细节，并公开从服务器启动、监听和处理I2C通信的方法。在Raspberry Pi上，我们使用Python SMBus库，使用它可以很容易地启动IC2服务器总线，并主动向其连接的客户端发送消息。</p></div></div>    
</body>
</html>
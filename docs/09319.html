<html>
<head>
<title>LeetCode — Populating Next Right Pointers in Each Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —在每个节点中填充右下指针</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/leetcode-populating-next-right-pointers-in-each-node-740457935fe2?source=collection_archive---------10-----------------------#2021-12-05">https://medium.com/geekculture/leetcode-populating-next-right-pointers-in-each-node-740457935fe2?source=collection_archive---------10-----------------------#2021-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2be8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="b772" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们有一棵<strong class="jf hj">完美的二叉树</strong>，其中所有的叶子都在同一层，每个父母都有两个孩子。二叉树具有以下定义:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="943e" class="kk ig hi kg b fi kl km l kn ko">struct Node {<br/>  int val;<br/>  Node *left;<br/>  Node *right;<br/>  Node *next;<br/>}</span></pre><p id="85ef" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">填充每个下一个指针以指向它的下一个右节点。如果没有下一个右节点，下一个指针应该设置为空。</p><p id="168b" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">最初，所有后续指针都被设置为空。</p><p id="d916" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">问题陈述摘自:<a class="ae ku" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/populating-next-right-pointers-in-each-node</a></p><p id="6dbb" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><figure class="kb kc kd ke fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/39cf8b814b30d3bc869b389e9343b731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1K8B6prDyjGT9Qyqi2p7iw.png"/></div></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a7b6" class="kk ig hi kg b fi kl km l kn ko">Input: root = [1, 2, 3, 4, 5, 6, 7]<br/>Output: [1, #, 2, 3, #, 4, 5, 6, 7, #]<br/>Explanation: Given the above perfect binary tree (Figure A), our function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.</span></pre><p id="9c68" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="6742" class="kk ig hi kg b fi kl km l kn ko">Input: root = []<br/>Output: []</span></pre><p id="7417" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="72f8" class="kk ig hi kg b fi kl km l kn ko">- The number of nodes in the tree is in the range [0, 212 - 1].<br/>- -1000 &lt;= Node.val &lt;= 1000</span></pre><p id="da6d" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">跟进:</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b688" class="kk ig hi kg b fi kl km l kn ko">- We may only use constant extra space.<br/>- The recursive approach is fine. We may assume implicit stack space does not count as extra space for this problem.</span></pre><h1 id="413c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="3b39" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们看到问题陈述，树是一棵<strong class="jf hj">完美二叉树</strong>。我们在示例中看到，每个节点的下一个右指针位于一个级别。我们可以做一个层次顺序遍历(按照这篇博客<a class="ae ku" href="https://alkeshghorpade.me/post/leetcode-binary-tree-level-order-traversal" rel="noopener ugc nofollow" target="_blank">的帖子</a>)并为每个节点更新下一个右指针。</p><p id="18e1" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="9e29" class="kk ig hi kg b fi kl km l kn ko">- if root == NULL<br/>  - return root<br/><br/>- initialize queue&lt;Node*&gt; q<br/><br/>- q.push(root)<br/><br/>- initialize Node* node<br/>  initialize i, size<br/><br/>- loop while !q.empty()<br/>  - set size = q.size()<br/><br/>  - loop for i = 0; i &lt; size; i++<br/>    - set node = q.front()<br/><br/>    - if node-&gt;left<br/>      - q.push(node-&gt;left)<br/><br/>    - if node-&gt;right<br/>      - q.push(node-&gt;right)<br/><br/>    - q.pop()<br/><br/>    - if i &lt; size - 1<br/>      - node-&gt;next = q.front()<br/><br/>- return root</span></pre><h2 id="b8b8" class="kk ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">C++解决方案</h2><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b0e1" class="kk ig hi kg b fi kl km l kn ko">class Solution {<br/>public:<br/>    Node* connect(Node* root) {<br/>        if(root == NULL)<br/>            return root;<br/><br/>        queue&lt;Node*&gt; q;<br/>        q.push(root);<br/><br/>        Node* node;<br/>        int i, size;<br/><br/>        while(!q.empty()){<br/>            size = q.size();<br/><br/>            for(i = 0; i &lt; size; i++){<br/>                node = q.front();<br/>                if(node-&gt;left)<br/>                    q.push(node-&gt;left);<br/><br/>                if(node-&gt;right)<br/>                    q.push(node-&gt;right);<br/><br/>                q.pop();<br/>                if(i &lt; size - 1){<br/>                    node-&gt;next = q.front();<br/>                }<br/>            }<br/>        }<br/><br/>        return root;<br/>    }<br/>};</span></pre><h2 id="c901" class="kk ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">戈朗溶液</h2><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b446" class="kk ig hi kg b fi kl km l kn ko">func connect(root *Node) *Node {<br/>    if root == nil {<br/>        return root<br/>    }<br/><br/>    queue := []*Node{root}<br/><br/>    for len(queue) != 0 {<br/>        tmp := []int{}<br/>        size := len(queue)<br/><br/>        for i := 0; i &lt; size; i++ {<br/>            node := queue[0]<br/><br/>            if queue[0] != nil {<br/>                tmp = append(tmp, queue[0].Val)<br/>                queue = append(queue, queue[0].Left)<br/>                queue = append(queue, queue[0].Right)<br/>            }<br/><br/>            queue = queue[1:]<br/><br/>            if i &lt; size - 1 &amp;&amp; queue[0] != nil {<br/>                node.Next = queue[0]<br/>            }<br/>        }<br/>    }<br/><br/>    return root<br/>}</span></pre><h2 id="d487" class="kk ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">Javascript解决方案</h2><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2042" class="kk ig hi kg b fi kl km l kn ko">var connect = function(root) {<br/>    let queue = [];<br/><br/>    if(root)<br/>        queue.push(root);<br/><br/>    while(queue.length &gt; 0) {<br/>        tmp = [];<br/>        let len = queue.length;<br/><br/>        for (let i = 0; i &lt; len; i++) {<br/>            let node = queue.shift();<br/>            tmp.push(node.val);<br/><br/>            if(node.left) {<br/>                queue.push(node.left);<br/>            }<br/><br/>            if(node.right) {<br/>                queue.push(node.right);<br/>            }<br/><br/><br/>            if( i &lt; len - 1 ) {<br/>               node.next = queue[0];<br/>            }<br/>        }<br/>    }<br/><br/>    return root;<br/>};</span></pre><p id="1af1" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="309c" class="kk ig hi kg b fi kl km l kn ko">Input: root = [1, 2, 3, 4, 5, 6, 7]<br/><br/>Step 1: vector&lt;vector&lt;int&gt;&gt; result<br/>        int size, i<br/><br/>Step 2: queue&lt;Node*&gt; q<br/>        q.push(root)<br/>        q = [1]<br/><br/>Step 3: Node* node<br/>        int i, size<br/><br/>Step 4: loop while !q.empty()<br/>        q = [1]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 1<br/><br/>        for(i = 0; i &lt; 1; i++)<br/>          - 0 &lt; 1<br/>          - true<br/><br/>          node = q.front()<br/>          node = 1<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = 2<br/>            - q.push(node-&gt;left)<br/>            - q = [1, 2]<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = 3<br/>            - q.push(node-&gt;right)<br/>            - q = [1, 2, 3]<br/><br/><br/>          q.pop()<br/>          q = [2, 3]<br/><br/>          if i &lt; size - 1<br/>            - 0 &lt; 1 - 1<br/>            - 0 &lt; 0<br/>            - false<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2       3<br/>          / \     / \<br/>         /   \   /   \<br/>        4     5  6   7<br/><br/>Step 5: loop while !q.empty()<br/>        q = [2, 3]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 2<br/><br/>        for(i = 0; i &lt; 2; i++)<br/>          - 0 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 2<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = 4<br/>            - q.push(node-&gt;left)<br/>            - q = [2, 3, 4]<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = 5<br/>            - q.push(node-&gt;right)<br/>            - q = [2, 3, 4, 5]<br/><br/><br/>          q.pop()<br/>          q = [3, 4, 5]<br/><br/>          if i &lt; size - 1<br/>            - 0 &lt; 2 - 1<br/>            - 0 &lt; 1<br/>            - true<br/><br/>            - node.next = q.front()<br/>              node = 2<br/>              q.front = 3<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4     5  6    7<br/><br/>          i++<br/>          i = 1<br/><br/>        for(i &lt; 2)<br/>          - 1 &lt; 2<br/>          - true<br/><br/>          node = q.front()<br/>          node = 3<br/><br/>          if node-&gt;left<br/>            - node-&gt;left = 6<br/>            - q.push(node-&gt;left)<br/>            - q = [3, 4, 5, 6]<br/><br/>          if node-&gt;right<br/>            - node-&gt;right = 7<br/>            - q.push(node-&gt;right)<br/>            - q = [3, 4, 5, 6, 7]<br/><br/><br/>          q.pop()<br/>          q = [4, 5, 6, 7]<br/><br/>          if i &lt; size - 1<br/>            - 1 &lt; 2 - 1<br/>            - 1 &lt; 1<br/>            - false<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4     5  6    7<br/><br/>        for(i &lt; 2)<br/>          - 2 &lt; 2<br/>          - false<br/><br/>Step 6: loop while !q.empty()<br/>        q = [4, 5, 6, 7]<br/>        q.empty() = false<br/>        !false = true<br/><br/>        vector&lt;int&gt; tmp<br/>        size = q.size()<br/>             = 4<br/><br/>        for(i = 0; i &lt; 4; i++)<br/>          - 0 &lt; 4<br/>          - true<br/><br/>          node = q.front()<br/>          node = 4<br/><br/>          if node-&gt;left<br/>             node-&gt;left is nil so false<br/><br/>          if node-&gt;right<br/>             node-&gt;right is nil so false<br/><br/>          q.pop()<br/>          q = [5, 6, 7]<br/><br/>          if i &lt; size - 1<br/>            - 0 &lt; 4 - 1<br/>            - 0 &lt; 3<br/>            - true<br/>            - node-&gt;next = q.front()<br/>              node = 4<br/>              q.front() = 5<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4-----5  6    7<br/><br/>        i++<br/>        i = 1<br/><br/>        for(i &lt; 4)<br/>          - 1 &lt; 4<br/>          - true<br/><br/>          node = q.front()<br/>          node = 5<br/><br/>          if node-&gt;left<br/>             node-&gt;left is nil so false<br/><br/>          if node-&gt;right<br/>             node-&gt;right is nil so false<br/><br/>          q.pop()<br/>          q = [6, 7]<br/><br/>          if i &lt; size - 1<br/>            - 1 &lt; 4 - 1<br/>            - 1 &lt; 3<br/>            - true<br/>            - node-&gt;next = q.front()<br/>              node = 5<br/>              q.front() = 6<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4-----5-6     7<br/><br/>        i++<br/>        i = 2<br/><br/>        for(i &lt; 4)<br/>          - 2 &lt; 4<br/>          - true<br/><br/>          node = q.front()<br/>          node = 6<br/><br/>          if node-&gt;left<br/>             node-&gt;left is nil so false<br/><br/>          if node-&gt;right<br/>             node-&gt;right is nil so false<br/><br/>          q.pop()<br/>          q = [7]<br/><br/>          if i &lt; size - 1<br/>            - 2 &lt; 4 - 1<br/>            - 2 &lt; 3<br/>            - true<br/>            - node-&gt;next = q.front()<br/>              node = 6<br/>              q.front() = 7<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4-----5-6-----7<br/><br/>        i++<br/>        i = 3<br/><br/>        for(i &lt; 4)<br/>          - 3 &lt; 4<br/>          - true<br/><br/>          node = q.front()<br/>          node = 7<br/><br/>          if node-&gt;left<br/>             node-&gt;left is nil so false<br/><br/>          if node-&gt;right<br/>             node-&gt;right is nil so false<br/><br/>          q.pop()<br/>          q = []<br/><br/>          if i &lt; size - 1<br/>            - 3 &lt; 4 - 1<br/>            - 3 &lt; 3<br/>            - false<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4-----5-6-----7<br/><br/>        i++<br/>        i = 4<br/><br/>        for(i &lt; 4)<br/>          - 4 &lt; 4<br/>          - false<br/><br/>Step 7: return root<br/><br/>So we return the answer as<br/><br/>               1<br/>             /   \<br/>            /     \<br/>           2-------3<br/>          / \     / \<br/>         /   \   /   \<br/>        4-----5-6-----7<br/><br/>[1, #, 2, 3, #, 4, 5, 6, 7, #]</span></pre></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="00db" class="pw-post-body-paragraph jd je hi jf b jg kp ji jj jk kq jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><em class="lx">最初发布于</em><a class="ae ku" href="https://alkeshghorpade.me/post/leetcode-populating-next-right-pointers-in-each-node" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://alkeshghorpade . me</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>
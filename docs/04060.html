<html>
<head>
<title>Raspberry Pico: Programming with PIO State Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raspberry Pico:用PIO状态机编程</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/raspberry-pico-programming-with-pio-state-machines-e4610e6b0f29?source=collection_archive---------1-----------------------#2021-06-21">https://medium.com/geekculture/raspberry-pico-programming-with-pio-state-machines-e4610e6b0f29?source=collection_archive---------1-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a8be48d985e47cbd6e7f26e3a706336c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DGtakVijRVmoaUtM_UP_Q.png"/></div></div></figure><p id="0b89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在微控制器编程中，与其他硬件的接口可能非常简单，也可能非常具有挑战性。如果传感器等其他硬件支持I2C、SPI或UART等标准总线系统，您只需将它们连接起来，并通过实现的总线系统读取/写入数据。如果你需要连接其他硬件，你必须实现精确的定时信号，用多个管脚发送和接收数据，并解释这些信号。</p><p id="e87d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以用普通的C语言编写这些时序考虑事项，但这意味着要非常小心地编程，因为您受限于处理器的时钟周期，需要了解每行代码的时序影响。</p><p id="fae4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了应对这一挑战，Raspberry Pico有一个独特的硬件扩展:PIO，可编程输入/输出的缩写。PIO被实现为4个独立的状态机。每个状态机与FIFO队列相连，与主程序交换数据。除了队列之外，stata机器可以DMS和访问所有GPIOs，但不能访问其他硬件或协议。</p><p id="8b53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pico社区使用PIO来输出声音效果或视频，连接到专有的LCD系统，或连接其他需要非常特定的协议的硬件。</p><p id="4b2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了帮助你开始使用PIO，这一篇文章是一个简明的介绍:学习硬件部分的基本知识，看看一个PIO程序是什么样子，以及它如何与一个C主程序交互，最后潜入PIO编程语言。</p><p id="1a1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em> <a class="ae jp" href="https://admantium.com/blog/pico09_pio/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的博客</em> </a> <em class="jo">。</em></p><h1 id="300c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">你为什么需要PIO？</h1><p id="fe12" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">当您想要与无法连接到板载支持的USB、I2C、SPI或UART协议的硬件接口时，您必须编写时间非常有限的代码来读写GPIOs。然而，当您想要连接的外部硬件需要非常低的数据传输速度时，您就需要处理中断或长等待周期。</p><p id="256d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">官方的C SDK指南明确指出，对比你的主进程慢1000倍的协议使用IRQ是不切实际的，因为你将注定CPU在大部分时间都在等待。或者，在另一端，您可能有一个高周期的硬件，您正在迫使您的微控制器从不错过任何一个时钟周期。这两种挑战都迫使你陷入相同的境地:所有的CPU资源都将花费在处理或等待一个外部硬件上。你不能用你的Pico做其他任何事情。</p><p id="866d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PIO子系统为这个问题引入了一个新颖的解决方案。从表面上看，它类似于<a class="ae jp" href="https://en.wikipedia.org/wiki/FGPA" rel="noopener ugc nofollow" target="_blank">现场可编程门阵列(FGPA) </a>，为构建复杂逻辑提供编程环境。但你不是用软件设计集成电路，然后需要编写与这种状态交互的微控制器软件。相反，您可以直接编程多达4个不同的状态机。每个状态机可以自由访问GPIO引脚以读写数据，可以缓冲来自处理器或其他DMA的数据，并通过中断或轮询通知处理器其计算结果。</p><h1 id="34ff" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO示例程序:闪烁的LED</h1><p id="bf9d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们定义一个简单的PIO启动程序，它将使LED闪烁。我们需要定义两个文件:一个PIO文件，它保存了类似汇编程序的代码，另一个是带有<code class="du kt ku kv kw b">main</code>函数的普通C文件。</p><p id="3dde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们先看看PIO的档案。一个PIO文件由两部分组成:一个是定义PIO指令的<code class="du kt ku kv kw b">program</code>部分，另一个是包含将PIO程序暴露给<code class="du kt ku kv kw b">main</code>程序的函数的<code class="du kt ku kv kw b">c-sdk</code>部分。基本布局是这样的:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="f599" class="lf jr hi kw b fi lg lh l li lj">.program hello</span><span id="e278" class="lf jr hi kw b fi lk lh l li lj">...</span><span id="160e" class="lf jr hi kw b fi lk lh l li lj">% c-sdk {<br/>...<br/>%}</span></pre><h1 id="0f0c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO计划</h1><p id="4f16" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">PIO程序本身实际上是用汇编语言编写的，准确地说是汇编语句的子集。要交替打开和关闭led，以下程序就足够了:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="38f4" class="lf jr hi kw b fi lg lh l li lj">.program hello</span><span id="8b08" class="lf jr hi kw b fi lk lh l li lj">set pindirs, 1</span><span id="3480" class="lf jr hi kw b fi lk lh l li lj">loop:<br/>  set pins, 1 [31]<br/>  set pins, 0 [31]<br/>  jmp loop</span></pre><p id="06e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们一行一行地剖析这个程序。</p><ul class=""><li id="c8e9" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">第1行:<code class="du kt ku kv kw b">program</code>语句开始声明一个PIO程序。它需要有一个标识符，这个标识符将在编译和链接过程中使用。</li><li id="b599" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第3行:<code class="du kt ku kv kw b">SET</code>指令是一个多用途语句。这一行意味着我们将所有已配置的set引脚设置为输出</li><li id="02aa" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第5行:这个<code class="du kt ku kv kw b">loop</code>声明是一个自由格式的标签，用来对一个更大的程序的各个部分进行分组。</li><li id="6cd5" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第6行:将配置的LED引脚设置为在总共32个时钟周期内输出高值。每个PIO语句在1个时钟周期内执行，并且可以使用额外的5位值来等待额外的周期。</li><li id="da6f" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第7行:将配置的LED引脚设置为在总共32个时钟周期内输出低值。</li><li id="5117" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第8行:用<code class="du kt ku kv kw b">JMP</code>我们回到先前定义的<code class="du kt ku kv kw b">loop</code>标签。</li></ul><h1 id="5814" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">C-SDK绑定</h1><p id="92b3" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了运行这个程序，您还需要定义一个C-SDK绑定。本质上，绑定是PIO程序内部的一个函数。在编译期间，它将被编译器拾取，编译器输出一个头文件，您可以将它集成到主程序中。</p><p id="1aef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加以下代码——本文后面会有详细的解释。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="8105" class="lf jr hi kw b fi lg lh l li lj">% c-sdk {</span><span id="7fd9" class="lf jr hi kw b fi lk lh l li lj">static inline void hello_program_init(PIO pio, uint sm, uint offset, uint pin) {<br/>  // 1. Define a config object<br/>  pio_sm_config config = hello_program_get_default_config(offset);</span><span id="8a25" class="lf jr hi kw b fi lk lh l li lj">  // 2. Set and initialize the output pins<br/>  sm_config_set_set_pins(&amp;config, pin, 1);</span><span id="c793" class="lf jr hi kw b fi lk lh l li lj">  // 3. Apply the configuration &amp; activate the State Machine<br/>  pio_sm_init(pio, sm, offset, &amp;config);<br/>  pio_sm_set_enabled(pio, sm, true);<br/>}<br/>%}</span></pre><h1 id="d2fe" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">主程序</h1><p id="415e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最后，我们在主程序文件中添加所有的东西。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="1630" class="lf jr hi kw b fi lg lh l li lj">#include &lt;stdio.h&gt;<br/>#include &lt;stdbool.h&gt;<br/>#include &lt;pico/stdlib.h&gt;<br/>#include &lt;hardware/pio.h&gt;<br/>#include &lt;hello.pio.h&gt;</span><span id="3bbd" class="lf jr hi kw b fi lk lh l li lj">#define LED_BUILTIN 25;</span><span id="aacf" class="lf jr hi kw b fi lk lh l li lj">int main() {<br/>  stdio_init_all();</span><span id="9cf7" class="lf jr hi kw b fi lk lh l li lj">  PIO pio = pio0;<br/>  uint state_machine_id = 0;<br/>  uint offset = pio_add_program(pio, &amp;hello_program);  hello_program_init(pio, state_machine_id, offset, LED_BUILTIN, 1);</span><span id="6910" class="lf jr hi kw b fi lk lh l li lj">  while(1) {<br/>    //do nothing<br/>  }<br/>}</span></pre><p id="76ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们可以看到以下详细信息:</p><ul class=""><li id="39ae" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">第4行:为了使用PIO状态机，我们需要包含这个特殊的头</li><li id="e75d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第5行:该语句包括编译期间汇编的PIO程序。它将公开之前定义的函数<code class="du kt ku kv kw b">hello_program_init</code>，并将指向程序的指针定义为<code class="du kt ku kv kw b">hello_program</code>。注意命名约定！</li><li id="1f06" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第12行:Pico有两条不同的状态机总线，我们需要将我们的状态机定义为属于其中一条。</li><li id="0321" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第13行:我们定义了状态机的id(一个4位值)</li><li id="0124" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第14行:这条语句分配动态内存来保存状态机代码。它返回一个内存偏移值，我们将把这个值传递给状态机初始化</li><li id="4076" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">第16行:我们初始化并启动程序</li></ul><h1 id="f6b4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO技术细节</h1><p id="e634" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">看过示例后，让我们深入了解技术细节。</p><h1 id="eb23" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO组件</h1><p id="2c8d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Pico提供了两个PIO模块，每个模块中有4个状态机。每个状态机都提供以下组件。</p><ul class=""><li id="d1e2" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">TX FIFO/RX FIFO:从主程序接收或向主程序发送32位值</li><li id="88b4" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">输入移位寄存器(ISR)/输出移位寄存器(OSR):这些寄存器保存易失性数据，用于状态机和主程序之间的直接交换。</li><li id="c283" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">暂存寄存器:标记为<code class="du kt ku kv kw b">x</code>和<code class="du kt ku kv kw b">y</code>，这些32位寄存器允许您存储状态机所需的任何附加数据。</li><li id="9037" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">可配置的时钟分频器:Pico的时钟周期为133MHz，可通过16位值调整至2000Hz</li><li id="9ea2" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">灵活的GPIO映射:Pico的核心是访问GPIO引脚的能力，每个状态机可以处理四组不同的GPIO(输入、输出、set、side-set)</li><li id="9769" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">DMA访问:不涉及主处理器而直接访问内存</li><li id="b624" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">IRQ标志:可以设置或清除8个全局标志，每个状态机和主程序都可以立即访问中断</li></ul><h1 id="be7d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO汇编语言</h1><p id="c0e9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了给PIO编程，你要使用汇编语言的一种特殊方言。在示例程序中，我们已经看到了如何将逻辑电平应用于引脚，以及如何定义一个简单的循环。汇编语言中只有9个命令，以及一些用于代码结构的附加语句。我将简要介绍所有指令，但是所有指令的完整定义，请参见<a class="ae jp" href="https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf" rel="noopener ugc nofollow" target="_blank">官方文档</a>的第3.3.2节。</p><p id="d915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为语言非常压缩，所以几个语句执行多个功能。尤其是如何正确使用GPIO引脚可能会很棘手。因此，我将语句分成不同种类的函数。</p><h1 id="ded7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">程序结构</h1><p id="6842" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了从总体上构建您的程序，您可以使用以下命令。</p><ul class=""><li id="0125" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">.program NAME</code> -程序的名称，也是编译过程中生成的头文件的名称，用于访问主程序中的状态机</li><li id="fa90" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">.define NAME VALUE</code> -类似于你的C程序，你可以定义在状态机中可见的顶级常量</li><li id="2c80" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">LABEL:</code>——标签是相关语句的句法分组。您可以定义任何标签，然后跳回它</li><li id="f63e" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">; COMMENT</code> -分号后面的任何内容都是注释</li><li id="2686" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">.wrap_target</code>和<code class="du kt ku kv kw b">.wrap</code> -重复运行一段游PIO程序的指令</li><li id="8639" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">.word</code> -存储一个原始的16位值作为程序中的指令(每个PIO语句都是一个16位值)</li><li id="0a15" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">.side_set COUNT (opt)</code> -该指令另外配置该程序的侧引脚。计数值是从指令中减少的位数，opt值决定PIO程序中的<code class="du kt ku kv kw b">side</code>语句是可选的还是强制的。当你使用这个声明时，你可以附加额外的命令到所有的表达式，例如<code class="du kt ku kv kw b">out x, 1 side 0</code>将一个字节从<code class="du kt ku kv kw b">OSR</code>转移到FIFO RX，并将SIDE引脚设置为逻辑低电平。</li></ul><p id="42fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">移动移位寄存器内的数据</strong></p><ul class=""><li id="7131" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">in SOURCE count</code> -将数据移入ISR，来源可以是<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>或<code class="du kt ku kv kw b">ISR</code>，计数为<code class="du kt ku kv kw b">0...32</code></li><li id="84d8" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">out DESTINATION count</code> -将数据从OSR转移到目的地<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">ISR</code></li><li id="d71d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">mov DESTINATION, SOURCE</code> -将数据从源(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>或<code class="du kt ku kv kw b">ISR</code>)移动到目的(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>或<code class="du kt ku kv kw b">ISR</code>)</li><li id="8fe9" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">set DESTIANTION, data</code> -向目的地写入一个5位数据值(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>)</li></ul><p id="e3f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在移位寄存器和主程序之间移动数据</strong></p><ul class=""><li id="6973" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">pull</code> -将数据从TX FIFO加载到OSR</li><li id="dadf" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">push</code> -将数据从ISR推送到RX FIFO，然后清除ISR</li><li id="704e" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">irq INDEX op</code> -将IRQ号<code class="du kt ku kv kw b">index</code>修改为清除(<code class="du kt ku kv kw b">op=0</code>)或设置(<code class="du kt ku kv kw b">op=1</code>)</li></ul><p id="dbcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">将数据写入GPIO引脚</strong></p><p id="fb42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置引脚</p><ul class=""><li id="ace2" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">set PINDIRS, 1</code> -将配置的SET引脚定义为输出引脚</li><li id="81a7" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">set PINS, value</code> -将高(<code class="du kt ku kv kw b">value=1</code>)或低(<code class="du kt ku kv kw b">value=1</code>)写入设置引脚</li></ul><p id="06c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出引脚</p><ul class=""><li id="fb4b" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">mov PINS, SOURCE</code> -从源(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>、<code class="du kt ku kv kw b">ISR</code>)写入输出引脚(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>或<code class="du kt ku kv kw b">ISR</code>)</li></ul><p id="b13d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">从GPIO引脚读取数据</strong></p><p id="3f26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置引脚</p><ul class=""><li id="33a6" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">set PINDIRS, 0</code> -将配置的SET引脚定义为输入引脚</li></ul><p id="7e3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输入引脚</p><ul class=""><li id="738a" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">mov DESTINATION, PINS</code> -从输入引脚写到目的地(<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>、<code class="du kt ku kv kw b">ISR</code>和输出<code class="du kt ku kv kw b">PINS</code>)</li></ul><p id="300b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">条件语句</strong></p><ul class=""><li id="c5f6" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">jmp CONDITION LABEL</code> -当以下<code class="du kt ku kv kw b">CONDITION</code>类型之一为真时，转到<code class="du kt ku kv kw b">LABEL</code></li><li id="791b" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">!(X|Y|OSRE)</code> -当<code class="du kt ku kv kw b">X</code>、<code class="du kt ku kv kw b">Y</code>、<code class="du kt ku kv kw b">OSR</code>为空时为真</li><li id="8a69" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">X-- | Y--)</code> -当暂存寄存器为空时为真，否则递减暂存寄存器</li><li id="db76" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">PIN</code> -当JUMP引脚为逻辑高电平时为真</li><li id="2147" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">wait POLARITY TYPE NUMBER</code> -延迟进一步处理，直到极性匹配..</li><li id="fe0d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">pin NUMBER</code> -输入引脚</li><li id="bd6c" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">gpio NUMBER</code> -绝对编号的gpio</li><li id="44f2" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">irq NUMBER</code> - IRQ号(如果极性为1，IRQ号被清除)</li><li id="ade5" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kt ku kv kw b">nop</code> -什么都不做</li></ul><h1 id="e7c3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO构型</h1><p id="c9a4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">PIO程序是高度可配置的。pico中的c-sdk部分定义了一个将由Pico汇编程序编译的包装函数。这个函数可以从主程序中访问，它可以接收任何参数。</p><p id="80cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在该功能中配置令人眼花缭乱的方面——以下列表简要描述了所有选项。</p><ul class=""><li id="f8bd" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">定义输入引脚、输出引脚和侧引脚</li><li id="c0ed" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">为<code class="du kt ku kv kw b">JMP</code>指令定义一个特殊引脚</li><li id="f4e1" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">初始化输入引脚的方向</li><li id="5865" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">配置输入和输出移位寄存器的移位方向、自动加载和位大小(最高32位)</li><li id="ac2e" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">将输入移位寄存器配置为额外的输出移位寄存器，反之亦然</li><li id="2061" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">时钟分频器将应用于默认的133Mhz时钟时间，这是一个16位值，因此您可以将PIO时钟周期缩小到2000Hz，如0,492ms。</li></ul><p id="386b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在使用PIO时能有所有的配置选项，我喜欢使用下面的模板。按照这个模板，我只需配置我需要修改的内容，或者删除我不需要的内容。</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="cd7a" class="lf jr hi kw b fi lg lh l li lj">static inline void __program_init(PIO pio, uint sm, uint offset, uint in_pin, uint in_pin_count, uint out_pin, uint out_pin_count, float frequency) {<br/>  // 1. Define a config object<br/>  pio_sm_config config = __program_get_default_config(offset);</span><span id="06b0" class="lf jr hi kw b fi lk lh l li lj">  // 2. Set and initialize the input pins<br/>  sm_config_set_in_pins(&amp;config, in_pin);<br/>  pio_sm_set_consecutive_pindirs(pio, sm, in_pin, in_pin_count, 1);<br/>  pio_gpio_init(pio, in_pin);</span><span id="7ff6" class="lf jr hi kw b fi lk lh l li lj">  // 3. Set and initialize the output pins<br/>  sm_config_set_out_pins(&amp;config, out_pin, out_pin_count);<br/>  pio_sm_set_consecutive_pindirs(pio, sm, out_pin, out_pin_count, 0);</span><span id="6f9b" class="lf jr hi kw b fi lk lh l li lj">  // 4. Set clock divider<br/>  if (frequency &lt; 2000) {<br/>    frequency = 2000;<br/>  }<br/>  float clock_divider = (float) clock_get_hz(clk_sys) / frequency * 1000;<br/>  sm_config_set_clkdiv(&amp;config, clock_divider);</span><span id="9916" class="lf jr hi kw b fi lk lh l li lj">  // 5. Configure input shift register<br/>  // args: BOOL right_shift, BOOL auto_push, 1..32 push_threshold<br/>  sm_config_set_in_shift(&amp;config, true, false, 32);</span><span id="0371" class="lf jr hi kw b fi lk lh l li lj">  // 6. Configure output shift register<br/>  // args: BOOL right_shift, BOOL auto_push, 1..32 push_threshold<br/>  sm_config_set_out_shift(&amp;config, true, false, 32);</span><span id="bf94" class="lf jr hi kw b fi lk lh l li lj">  // 7. Join the ISR &amp; OSR<br/>  // PIO_FIFO_JOIN_NONE = 0, PIO_FIFO_JOIN_TX = 1, PIO_FIFO_JOIN_RX = 2<br/>  sm_config_set_fifo_join(&amp;config, PIO_FIFO_JOIN_NONE);</span><span id="b093" class="lf jr hi kw b fi lk lh l li lj">  // 8. Apply the configuration<br/>  pio_sm_init(pio, sm, offset, &amp;config);</span><span id="e6be" class="lf jr hi kw b fi lk lh l li lj">  // 9. Activate the State Machine<br/>  pio_sm_set_enabled(pio, sm, true);<br/>}</span></pre><h1 id="c1db" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="6a39" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">PIO是Raspberry Pico的可编程输入/输出状态机，是一种连接任何硬件的新颖解决方案。状态机不再浪费CPU周期和空闲等待时间，或者相反，不再总是读写管脚，而是承担与任何硬件交互的重任。它们可以配置为在2000HZ至133Mhz范围内工作，可以自由访问所有GPIO引脚，可以在每个时钟周期读写这些引脚。用一种简化的、类似汇编语言的语言，你可以对这些状态机进行编程，使其遵守特定的时序约束，并与主程序交换位数据。这篇文章展示了PIO是如何工作的，列出了组件和所有的编程语言语句。最后，我们看到了状态机的许多配置选项。您可以调用多达8个状态机与您的主程序一起工作——您的用例是什么？</p></div></div>    
</body>
</html>
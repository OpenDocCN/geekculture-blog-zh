<html>
<head>
<title>Running a Redis cluster on AWS with Terraform as IaC and Github Actions As CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上运行Redis集群，将Terraform作为IaC，将Github操作作为CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/running-a-redis-cluster-on-aws-with-terraform-as-iac-and-github-actions-as-ci-cd-a806ce6c447d?source=collection_archive---------4-----------------------#2022-03-14">https://medium.com/geekculture/running-a-redis-cluster-on-aws-with-terraform-as-iac-and-github-actions-as-ci-cd-a806ce6c447d?source=collection_archive---------4-----------------------#2022-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dcfda5e40467ec621fdf6d5269f10c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DR0PoEG7qXQgfgqfGgEerQ.png"/></div></div></figure><h1 id="52fa" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">前言</h1><p id="6187" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这篇文章中，我尝试使用Github actions创建一个具有完整CI/CD的生产级Redis集群，使用Terraform创建IaC，使用Docker compose进行容器编排，并将其全部部署在AWS上。当然还有改进的空间，但是我已经尽我所能在这篇文章中提到了。</p><h1 id="6b7e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍演员</h1><p id="7f47" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在深入实施之前，先介绍一下舞台上的演员！</p><h2 id="2624" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">将（行星）地球化（以适合人类居住）</h2><p id="850a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Terraform用于基础设施代码(IaC)。这意味着您只需将您的基础设施描述为代码，仅此而已！但是更有趣的部分是为什么你可能需要它。</p><p id="9e9c" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">想象一下，你不使用Terraform，这不是一个博客帖子的小项目，而是一个巨大的项目，有一个大的开发团队，不断的变化，冲刺，期限和其他一切，以及所有这些中最关键的方面，一个不应该停机的运行生产环境。您对应用程序所做的大部分更改可能是代码级的更改，并不复杂，只需有一个CI/CD管道就可以在云上自动部署这些更改。如果应用程序崩溃或运行状况恶化，只需单击一个按钮就可以回滚更改，并在单独的环境中进行调查，但有时您也可能会对基础架构进行更改。</p><p id="8d57" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我的问题是你如何做出这些改变？你登录到你的控制台，点击几个按钮？那你怎么回滚呢？再次点击GUI？如果多个人同时尝试进行相同的基础架构更改，会怎么样？如果人们忘记了他们在GUI上所做的更改会怎么样？如果您想要快速回滚大型基础架构，您会手动单击100个按钮，在您的客户归档票证和产品人员盯着您的时候键入<em class="lf"/>5次“永久删除”吗？或者，如果您想在凌晨3点进行更改，但<em class="lf">记得</em>更改的开发人员正在熟睡中，您会怎么办？</p><p id="447d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">解决方案是将基础设施写成代码。因此，如果您将EC2实例、S3桶和RDS数据库编写为代码，将其上传到版本控制，并使用CLI工具获取这些代码并创建基础架构，您就可以解决上述所有问题。不确定在这一重大变化之前的基础设施是什么样的？只要运行<code class="du lg lh li lj b">git checkout HEAD~1</code>就可以得到答案。不确定是谁做出了这种改变？<code class="du lg lh li lj b">git blame</code>会告诉你该怪谁(除非他们用<code class="du lg lh li lj b"><a class="ae lk" href="https://github.com/jayphelps/git-blame-someone-else" rel="noopener ugc nofollow" target="_blank">git-blame-someone-else</a></code>！)您还可以将其作为CI/CD流程的一部分实现自动化，这样您就不需要手动设置一切，而且您可以调配与在开发或试运行中相同的资源，而不会意外忘记确切的配置。IaC是一个好主意的原因可能有一百个，但是现在，只要知道它是一个好主意，我们将使用Terraform作为工具来做这件事。</p><p id="ce52" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">Terraform相当简单，至少我们计划如何使用它。只需编写一个定义您的基础设施的<code class="du lg lh li lj b">tf</code>文件，运行<code class="du lg lh li lj b">tf apply</code>来部署您的基础设施。这其中有细微差别，比如我们如何使用Terraform模块，这使您的配置更易于管理和模块化，我们如何使用变量和输出，以及如何管理状态，但如果这个新的terraform东西对您来说是新的，不要太担心这一点，只需知道我们定义了我们希望在这个<code class="du lg lh li lj b">.tf</code>文件中使用的资源(如EC2实例或S3桶),并使用一个命令部署它们。</p><h2 id="851d" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">雷迪斯</h2><p id="027b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Redis是一个内存数据库，也可以用作发布-订阅系统。关于这一点有很多要说的，但我在过去几个月里一直在写Redis，所以如果你是新手，可以看看这个东西。</p><h2 id="f6b1" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">EC2，ECR</h2><p id="b4eb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于那些不知道的人来说，EC2是AWS上的一项服务，您可以使用它来提供虚拟专用服务器。你可以通过SSH进入这些服务器，运行你的代码，或者做任何你可以在笔记本电脑上通过终端完成的事情。</p><p id="a2d6" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">ECR代表弹性容器注册，是AWS中的docker注册服务。如果你有Docker图片并想把它们放在某个地方，你通常会使用注册服务。您在这个服务中创建了存储库，您可以使用它来推送或提取docker图像。</p><h2 id="b18e" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">Github操作</h2><p id="03d6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Github actions是我们将用于该系统的CI/CD工具。简单地说，我们将在一个简单的YAML文件中定义部署服务和基础设施所需的步骤。Github将在每次推送时基于这个YAML文件建立一个工作流，并部署我们的服务和基础设施</p><h1 id="1249" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">履行</h1><p id="34ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">好，那么我们从实现开始。像往常一样，<a class="ae lk" href="https://github.com/Sanil2108/redis-terraform-aws" rel="noopener ugc nofollow" target="_blank">这里的</a>是给没有耐心的人看的源代码。</p><h2 id="5f84" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第1部分:目录结构</h2><p id="dec5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们从如何组织代码开始。让我们在根目录中创建两个目录，<code class="du lg lh li lj b">services</code>和<code class="du lg lh li lj b">terraform</code>。<code class="du lg lh li lj b">terraform</code>目录包含与设置我们的AWS基础架构相关的所有代码，而<code class="du lg lh li lj b">services</code>目录包含我们定义的服务。除此之外，我们还需要一个<code class="du lg lh li lj b">.github</code>目录来写我们的CI/CD。</p><p id="6599" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是我的根目录现在的样子</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/dd3537e3ad8bd05efb7df709316e5269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0XmRteGw0yY4Ru76UxGTQ.png"/></div></div></figure><h2 id="0e99" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第2部分:集群Redis的Docker设置</h2><p id="87f2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是我之前在这里谈了很多<a class="ae lk" rel="noopener" href="/geekculture/horizontally-scaling-writes-with-redis-clusters-a77cdcdf6de2">的事情。在继续之前，请仔细阅读这些内容。</a></p><p id="6579" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我主要使用我在以前的博客文章中定义的用于集群Redis的解决方案，但是我做了一些小的改动。</p><p id="186d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因为我希望docker-compose文件在EC2实例上运行，所以我需要使用docker注册表来存储图像，并在docker-compose文件中使用<code class="du lg lh li lj b">image</code>指令，而不是<code class="du lg lh li lj b">build</code>指令。</p><p id="6f36" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是我的新docker-compose.yml文件的样子</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="8839" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因为我不能再在构建时引入<code class="du lg lh li lj b">REDIS_PORT</code>变量，所以我把它用作一个环境，而不是一个构建时参数。</p><p id="e973" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是redis-node的新docker文件的样子</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="fb4f" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">所有这些都进入<code class="du lg lh li lj b">services</code>目录。这是服务目录现在的样子</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/f00abd6a50b685ddaeef25d588586fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kGjhPoC7yZm9jA5IUw-Xw.png"/></div></div></figure><p id="3c1d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我以前在以前的帖子中解释过<code class="du lg lh li lj b">redis.conf</code>文件和集群设置的docker file<a class="ae lk" rel="noopener" href="/geekculture/horizontally-scaling-writes-with-redis-clusters-a77cdcdf6de2">这里</a>。</p><h2 id="5ed7" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第3部分:编写在EC2上运行的代码</h2><p id="7972" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我们已经有了想要在EC2实例上运行的docker容器，那么我们如何运行这些容器呢？要做到这一点，我们必须编写一个在EC2首次启动时执行的脚本。</p><p id="b3f0" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这称为用户数据脚本。当我们使用Terraform设置EC2实例时，我们将配置EC2使用这个脚本。</p><p id="5b1d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是server-userdata.sh文件的外观</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="00bc" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我已经添加了注释来解释代码，但如果仍然不清楚，我们正在做的是</p><ol class=""><li id="0b68" class="lt lu hi jq b jr la jv lb jz lv kd lw kh lx kl ly lz ma mb bi translated">安装Docker和docker-compose</li><li id="2526" class="lt lu hi jq b jr mc jv md jz me kd mf kh mg kl ly lz ma mb bi translated">保存<code class="du lg lh li lj b">docker-compose.yml</code>文件</li><li id="7523" class="lt lu hi jq b jr mc jv md jz me kd mf kh mg kl ly lz ma mb bi translated">设置AWS ECR</li><li id="ea07" class="lt lu hi jq b jr mc jv md jz me kd mf kh mg kl ly lz ma mb bi translated">最后，在EC2上运行docker-compose.yml文件</li></ol><p id="32e9" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这个文件存在于我们的terraform目录中，因为我们将在我们的<code class="du lg lh li lj b">main.tf</code>文件中链接它。</p><h2 id="7768" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第4部分:地形模块简介</h2><p id="aa2e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在我们深入研究<code class="du lg lh li lj b">main.tf</code>文件之前，让我简单介绍一下我们正在使用的几个模块。</p><p id="f5ef" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">对于那些不知道的人，Terraform模块是较小的terraform代码片段，您可以在您的项目中重用。类似于编写一个库，可以在其中定义函数或变量，然后在代码中的多个位置导入它们。这有助于你重用你的代码，使它更加模块化，更好看，更易读，等等。使用terraform模块通常被认为是一个好的实践。</p><p id="8a1c" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我在目录结构中组织它的方式如下—</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/4da9474dad40f73b74dde85b5fe6b6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbK1v00EEjUlEcKypiX-xA.png"/></div></div></figure><p id="bb7a" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">有一个<code class="du lg lh li lj b">main.tf</code>文件，一个<code class="du lg lh li lj b">modules</code>目录，还有我们之前讲过的<code class="du lg lh li lj b">server-userdata.sh</code>。</p><p id="c067" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">想法很简单，我写了一个<code class="du lg lh li lj b">main.tf</code>文件来导入和使用这些模块。</p><p id="ebc2" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">让我们看看这些模块是如何工作的。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/829b7d7d86ee53704064165ed1246fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3gMlaEPr3_bfcFsC1Zlcw.png"/></div></div></figure><p id="01ca" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这两个模块都有自己的<code class="du lg lh li lj b">main.tf</code>文件，还有一个<code class="du lg lh li lj b">variables.tf</code>、<code class="du lg lh li lj b">output.tf</code>和一个<code class="du lg lh li lj b">README.md</code>文件。README.md文件的目标应该是显而易见的。<code class="du lg lh li lj b">variables.tf</code>和<code class="du lg lh li lj b">outputs.tf</code>文件使得该模块实际上是模块化的。使用这些文件，您可以将模块配置为接受输入并返回输出，类似于函数中的参数和返回值。这就是你的模块可以模块化的原因。</p><p id="ca9d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">现在，谈一下手头的项目。</p><p id="fb5e" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这里有两个我写的并且我们正在使用的模块，<code class="du lg lh li lj b">ec2-instance</code>模块和<code class="du lg lh li lj b">single-public-subnet</code>模块。简单地说，<code class="du lg lh li lj b">ec2-instance</code>模块提供一个EC2实例，以及安全组和任何更多的需求，而<code class="du lg lh li lj b">single-public-subnet</code>模块提供一个新的VPC，具有一个公共的子网，以及路由表、互联网网关等。</p><p id="659d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">如果你感兴趣，你可以在GitHub上查看代码，但是这对我们现在正在构建的东西并不重要。</p><h2 id="7d91" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第5部分:根main.tf文件</h2><p id="8a3f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是terraform实际运行的文件，它导入所有模块并部署或破坏我们的基础设施。</p><p id="e52d" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是它看起来的样子</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="f722" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这相当简单，因为大部分代码都在我们的模块中抽象出来了。它只是将我们的后端设置为S3和DynamoDB(这是Terraform存储状态和锁文件的地方)，使用我们讨论过的两个模块，并设置两个ECR存储库，我们将使用它们来存储我们的Docker映像。</p><h2 id="55d8" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第6部分:CI/CD</h2><p id="97a2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">最后，实际设置这一切的部分是Github actions中的CI/CD流。这是相当大的，但不要担心，我会深入解释它。</p><figure class="lm ln lo lp fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="74fb" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我们有两份工作，<code class="du lg lh li lj b">build-services</code>和<code class="du lg lh li lj b">update-infrastructure</code>。</p><p id="f5dd" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated"><code class="du lg lh li lj b">build-services</code>配置我们的AWS凭证和ECR，为<code class="du lg lh li lj b">redis-node</code>和<code class="du lg lh li lj b">cluster-setup</code>构建docker映像，并将其部署到ECR。</p><p id="53d2" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">一旦<code class="du lg lh li lj b">build-services</code>完成，<code class="du lg lh li lj b">update-infrastructure</code>运行。这将设置terraform，删除EC2实例，然后根据当前状态重新创建基础设施。</p><p id="920b" class="pw-post-body-paragraph jo jp hi jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这是我的完整目录结构现在的样子</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/e876f2e975c141e79fb1d9962aea63e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*3VlLIs401oBoCXACPQlJ5A.png"/></div></figure><h2 id="7b5f" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">第7部分:全部运行</h2><p id="9b6e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要运行整个过程，只需推送您的代码，如果一切配置正确，您的CI/CD应该会自动构建Docker映像，将其推送到ECR，初始化Terraform，设置您的基础设施，并部署一切！</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/07c433b13f1f3933c5e97f328497b489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ux4rqZ3kaLDJvd7EbAv-nQ.png"/></div></div></figure><h1 id="2cbb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="d938" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">虽然上述解决方案有效，但仍有很大的改进空间。事实上，我将它部署在一个EC2实例上，而不是一个集群，在我看来，这可能是系统中最大的缺陷，但目前，这是我在这个项目中所做的全部工作。也许在不久的将来，我会考虑在堆栈中添加一个合适的容器编排服务，比如ECS。</p></div></div>    
</body>
</html>
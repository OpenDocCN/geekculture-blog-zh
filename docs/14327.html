<html>
<head>
<title>Use Cypress for API testing!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cypress进行API测试！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/use-cypress-for-api-testing-4ff74fec99e7?source=collection_archive---------8-----------------------#2022-08-27">https://medium.com/geekculture/use-cypress-for-api-testing-4ff74fec99e7?source=collection_archive---------8-----------------------#2022-08-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="5ed0" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">你需要自动化API测试？</h2><div class=""/><div class=""><h2 id="9685" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">基于真实世界应用的教程。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/2c43df3330e5eb18147fc61850716357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgJfwhODfkYc_eSSUH6BXg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@k8townsend?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kate Townsend</a> on <a class="ae jw" href="https://unsplash.com/s/photos/waiter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d41f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我在咨询一个后端应用程序。需求之一是对他们的端点进行自动化测试。因此，我有机会探索自动化<a class="ae jw" rel="noopener" href="/technogise/journey-of-a-quality-analyst-2d78ddc44798#e258"> API测试</a>的不同工具。以下是我选择赛普拉斯的原因，以及它是否成功。</p><h2 id="8a33" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">为什么是柏树？</h2><ul class=""><li id="cf19" class="ln lo hi jz b ka lp kd lq kg lr kk ls ko lt ks lu lv lw lx bi translated">主要是因为<a class="ae jw" href="https://learn.cypress.io/advanced-cypress-concepts/integration-and-api-tests" rel="noopener ugc nofollow" target="_blank">赛普拉斯有能力</a>测试API。</li><li id="d4be" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">这已经在组织内部被用于功能UI测试。</li><li id="cb7b" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">Cypress有一个支持性的社区和文档。</li><li id="aa99" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">我们的愿景是，万一这个应用程序最终有了一个前端，我们可以利用相同的框架。</li></ul><p id="eaa1" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">所以，让我们进一步深入细节。</p><h2 id="3b10" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">发出API请求:</h2><p id="4579" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">为此使用<em class="mg"> cy.request </em>命令<em class="mg"> </em>。</p><p id="46e0" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">您可以在发出请求时指定各种属性:</p><ul class=""><li id="987e" class="ln lo hi jz b ka kb kd ke kg mh kk mi ko mj ks lu lv lw lx bi translated"><em class="mg">方法&amp; url </em>是必填项。</li><li id="3cdb" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">我已经在本文前面描述了可选的，如<em class="mg">retryOnStatusCodeFailure&amp;failOnStatusCode</em>。</li><li id="a1ff" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">根据上下文，您可能有也可能没有<em class="mg">正文。</em></li><li id="b223" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">要认证端点，有两种方法，要么使用<em class="mg"> auth </em>要么使用<em class="mg">头。</em>举例:</li></ul><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="6708" class="kt ku hi ml b fi mp mq l mr ms">headers: {'Authorization': `Bearer ${authToken}`}<br/>OR<br/>auth: {bearer: authToken}</span></pre><h2 id="ddb8" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">断言:</h2><p id="0a0c" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">是的，可以验证整个JSON响应体。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mt mu l"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="ak"><em class="mv">Comparing JSON response body.</em></strong></figcaption></figure><p id="7691" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">Cypress能够断言不同的数据点。以下是许多可用断言中的几个:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="b0c3" class="kt ku hi ml b fi mp mq l mr ms">expect(response?.status).to.eq(403);<br/>expect(response?.statusText).to.eq('Forbidden');<br/>expect(response?.body).to.have.property(&lt;value&gt;).to.be.eq(&lt;value&gt;);<br/>expect(response?.body).to.be.eq(&lt;value&gt;);<br/>expect(response?.body).to.have.property(&lt;value&gt;).to.not.be.null;<br/>expect(response?.body).to.have.property(&lt;value&gt;).to.not.be.empty;<br/>expect(response?.body).to.have.property('metaData').to.have.property('count').to.equal(2);<br/>expect(response?.body).to.have.property(&lt;value&gt;).to.have.length(2);</span></pre><h2 id="68d6" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">用于身份验证的自定义命令:</h2><p id="65db" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">Cypress鼓励为你的项目中的重复动作创建<a class="ae jw" rel="noopener" href="/geekculture/integrate-puppeteer-as-a-plugin-in-cypress-1f0912d8e265">自定义命令</a>。身份验证就是这样一种候选方案:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mt mu l"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><strong class="ak">Fetching &amp; storing auth token through an API call.</strong></figcaption></figure><p id="3418" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">注意:<em class="mg"> writeFile </em>命令可以创建一个不存在的新文件。</p><h2 id="79f4" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">管道:</h2><ul class=""><li id="1128" class="ln lo hi jz b ka lp kd lq kg lr kk ls ko lt ks lu lv lw lx bi translated">测试通过Github Actions在测试环境中对主分支每天运行一次。</li><li id="5ea5" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">Github Actions的日志显示了详细的报告，就像您在CLI上看到的一样。考虑到这不是一个前端应用程序，没有必要的视频，截图或合并的HTML报告。</li></ul><p id="98d3" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">PS:要在失败时停止截图，您需要在<em class="mg"> index.ts中添加以下内容:</em></p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="b22a" class="kt ku hi ml b fi mp mq l mr ms"><strong class="ml hs"><em class="mg">Cypress</em></strong>.Screenshot.defaults({<br/>    screenshotOnRunFailure: false<br/>})</span></pre><ul class=""><li id="ef83" class="ln lo hi jz b ka kb kd ke kg mh kk mi ko mj ks lu lv lw lx bi translated">我使用下面的命令来确保<a class="ae jw" href="https://classic.yarnpkg.com/lang/en/docs/cli/install/" rel="noopener ugc nofollow" target="_blank">锁文件</a>没有被更新。它还确保免受恶意用户的攻击。</li></ul><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="2c5f" class="kt ku hi ml b fi mp mq l mr ms">yarn install --frozen-lockfile</span></pre><ul class=""><li id="c72d" class="ln lo hi jz b ka kb kd ke kg mh kk mi ko mj ks lu lv lw lx bi translated">我们使用缓存来节省反馈时间和账单:</li></ul><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="2cd5" class="kt ku hi ml b fi mp mq l mr ms">- uses: actions/setup-node@v3<br/>  with:<br/>    node-version: '16.15.1'<br/>    cache: 'yarn'</span></pre><h2 id="65f6" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">测试的性能:</h2><p id="b343" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">我们在27-63秒内进行了25次测试，取决于所有相关兰姆达斯的温度。在管道上，额外的20秒用于设置。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/9713f04ccf9ca4380d3241d4dbb59484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXYZj_SQBVQ4lmXQP85tDw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Github Action timeline example.</figcaption></figure><p id="d146" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我在寻找优化流水线准备时间的方法。<br/> PS:还有一个评估不同社区插件的选项。</p><h2 id="43bc" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">在不同环境下运行:</h2><p id="0f4b" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">我们希望能够灵活地在任何环境下运行，如本地或开发环境。这可以通过创建一个类似于<em class="mg"> cypress.json </em>的配置文件来实现。示例:一个<em class="mg"> dev-config.json </em>文件:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="2725" class="kt ku hi ml b fi mp mq l mr ms">{<br/>  "projectId": &lt;value&gt;,<br/>  "watchForFileChanges": false,<br/>  "responseTimeout": 45000,<br/>  "baseUrl": &lt;value&gt;,<br/>  "reporter": "mochawesome",<br/>  "reporterOptions": {<br/>    "overwrite": false,<br/>    "html": false,<br/>    "json": true,<br/>    "reportDir": "cypress/mochawesome-report"<br/>  },<br/>  "testFiles": "**/*.*",<br/>  "env": {<br/>    "parameter": &lt;value&gt;<br/>  }<br/>}</span></pre><p id="61d2" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">测试数据存在于实际环境中，它们的id会随着环境的变化而变化。这意味着我们需要一个可以修改所有测试数据值的地方。我们为此使用了上面提到的文件——你看到的<em class="mg">的<em class="mg"> env </em>部分。</em>在<em class="mg">规格</em>文件中，我们通过名称导入并使用这些作为变量。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="857b" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated"><strong class="ak">删除API集成测试:</strong></h2><p id="5226" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">我们的是一个微服务(通过API调用)与其他一些创建的微服务进行通信。</p><p id="597d" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这些测试成功地及时给出了正确的反馈。</p><p id="3237" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们意识到API集成测试和Cypress测试是重复的工作。与回报相比，编写集成测试的工作量更大——我们嘲笑所有需要的服务。这意味着如果其他服务在他们的代码中做了改变，我们将不能捕获问题。然而，Cypress测试是在实际环境中使用所有服务的最新代码运行的。</p><p id="2720" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">因此，我们放弃了集成测试。</p><h2 id="595a" class="kt ku hi bd kv kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ho bi translated">常见问题:</h2><p id="df71" class="pw-post-body-paragraph jx jy hi jz b ka lp is kc kd lq iv kf kg md ki kj kk me km kn ko mf kq kr ks hb bi translated">我们的微服务架构使用AWS基础设施，特别是<strong class="jz hs"><em class="mg">λ</em></strong>。这意味着当测试运行时，我们的服务<strong class="jz hs"> <em class="mg">可能不热</em> </strong>。<strong class="jz hs"><em class="mg">Cypress是否足够健壮以避免这样的假阴性？是..</em> </strong></p><p id="938b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了确保这一点，我们可以在cypress.json中做一些调整:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="32f9" class="kt ku hi ml b fi mp mq l mr ms">"responseTimeout": 45000</span></pre><p id="1662" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们也可以使用</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="d0fe" class="kt ku hi ml b fi mp mq l mr ms">retryOnStatusCodeFailure: true</span></pre><p id="10ec" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">同时通过<em class="mg"> cy.request </em>调用我们的端点。</p><p id="c8c3" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="mg">它是否启动浏览器？没有</em> </strong>，它不会启动浏览器。</p><p id="6a89" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">你可能已经注意到了上面片段中<strong class="jz hs"><em class="mg"/></strong><a class="ae jw" href="https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Closures" rel="noopener ugc nofollow" target="_blank"><strong class="jz hs"><em class="mg">然后</em> </strong> </a> <em class="mg"> </em>的用法。下一个问题是<strong class="jz hs"> <em class="mg">为什么async / await没有被使用</em> </strong>？这里有一点细微的差别:</p><ul class=""><li id="c614" class="ln lo hi jz b ka kb kd ke kg mh kk mi ko mj ks lu lv lw lx bi translated">这是Cypress方法链接，在这里重试前一个命令。</li><li id="602f" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated">值得注意的是，在断言<em class="mg">中，不会重试</em>，但<em class="mg">会重试</em>。</li><li id="3471" class="ln lo hi jz b ka ly kd lz kg ma kk mb ko mc ks lu lv lw lx bi translated"><em class="mg">那么</em>用于多个断言。其中有多个<em class="mg">期望</em>(参见上面的片段)。</li></ul><p id="f240" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">交给你:与Cypress相比，你对API测试工具有什么看法？</p></div></div>    
</body>
</html>
# 种植你的巨石

> 原文：<https://medium.com/geekculture/growing-your-monolith-9f53bd205e7c?source=collection_archive---------28----------------------->

![](img/4714d8d184a76da69be280ac32caa5f5.png)

Photo by [Hulki Okan Tabak](https://unsplash.com/@hulkiokantabak?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](/s/photos/monolith?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

你有一个软件项目的好主意，并决定把它做成一个网站。你有一个小团队，你决定保持简单，只是把整个事情放在一个地方。您构建了一个直接与数据库对话的小型服务器端呈现应用程序。

在一两个月内，你可以快速开发，代码都在一个地方，可以很容易地调试和阅读，你的产品受到用户的喜爱。你击中了要害——祝贺你！现在是时候成长了…

# 前端和后端

也许你雇佣了更多的开发人员，推出了更多的功能，你的代码库开始增长。随着越来越多的开发人员在同一个代码库上工作，您会发现经常会有两个或更多的开发人员在同一个代码上工作，合并冲突变得更加频繁。

你决定拆分你的代码库。

最直观的下一步是将代码库分成客户端应用程序和 API。然而，有一个权衡:

**优点**:

*   关注点分离(API 关注业务逻辑和持久性，而客户端主要关注表示和用户交互)
*   两个存储库降低了冲突的可能性
*   **减少了固有的认知负荷，因为开发人员现在可以专注于前端或后端**

**缺点**:

*   实体、验证和一些业务规则现在可能在客户端和 API 中重复
*   客户端应用程序现在必须跟踪它与之通信的 API 接口
*   您需要分别构建和部署客户端和 API

![](img/417397e821ef435b181c694388d0e66e.png)

Photo by [Asif Akbar](https://www.freeimages.com/photographer/asifthebest-44246) from [FreeImages](https://freeimages.com/)

# 通用模块

代码库仍然不太大，你可以继续提交和推送代码，现在有了更灵活的设置。现在有两个团队，一个负责前端，另一个负责后端。代码库越来越大，前端和后端越来越不同步。这导致了 bug 和团队成员之间更多的(不必要的)交流(甚至可能是一些指责)，以及查看其他代码库中的实现，并反映所做的更改的必要性。

显然，你需要一些前端和后端之间的通用语言。因此，您决定制作一个包含客户机和 API 都将使用的逻辑的包。不幸的是，为此也要付出沉重的代价。

**优点**:

*   很大一部分代码不再重复
*   **业务逻辑可以保持安全和测试**
*   对通用包所做的更改现在同时反映在客户端和 API 中

**缺点**:

*   您有第三个存储库，可能由两个团队维护
*   客户机和 API 需要跟上公共模块的最新变化
*   **通用模块具有不同于前端和后端的编写和构建代码的规则**
*   您需要为公共模块包创建、维护一个存储库，并可能为此付费
*   **开发人员需要理解语义版本化，并遵守它**

![](img/232261ef4881266adfe4bbb124e11ee3.png)

Photo by [Christina Papadopoullou](https://www.freeimages.com/photographer/inapap-54021) from [FreeImages](https://freeimages.com)

正如您所看到的，您是否能从这种变化中获得价值已经变得不那么清楚了。

# 服务

到目前为止，您的小公司已经发展到三四个开发团队，代码库也相应地增长了。该软件现在有许多功能、许多实体和业务规则。

很明显，在前端有独立的门户，这些门户与特定端点的通信比其他端点多。

整个业务的知识以及软件的不同部分是如何操作的，对于任何开发人员来说都是一个太大的负担，所以你决定进行下一次飞跃。

希望您已经保持了代码的整洁和上下文的有界，并且至少您有可能进行转换——是时候将后端拆分成服务了，并且至少在逻辑上将前端拆分成与独立的业务领域相关的部分。正如你可能已经猜到的，这不仅仅是阳光和玫瑰。让我们来看一下权衡:

优势:

*   **API 被分成几个包含相似业务逻辑的仓库，减少了团队的认知负荷**
*   任何一个开发人员从主分支中落后的合并冲突和提交又一次减少了
*   不同团队之间需要的沟通更少
*   理想情况下，每个团队都有一组将业务逻辑封装在实体和接口中的模块
*   每个服务都有一个单独的、较小的数据库

缺点:

*   **代码更难运行和调试**
*   服务通信在基础设施中更难编排
*   这些服务需要与其他服务通信，以保持数据的一致性
*   身份认证需要集中化
*   **整个系统更难理解**

![](img/d4519a8ce9e3cf6f36c5c4b19e91da01.png)

这值得吗？嗯……也许吧。在我们结束之前。让我们再走一步。

# 事件总线

服务间的依赖变得太大，系统不同组件的不稳定性导致整个系统崩溃，顺便提一下，让你发疯。

为了分离服务并处理所有这些讨厌的数据不一致问题，以及为您的用户提供一个更稳定的环境，您决定开始使用事件总线。

**优点**:

*   服务不再需要调用其他服务
*   安全快速地同步数据
*   您确切地知道如何与其他服务通信——您发出事件

缺点:

*   API 开发人员现在必须学习如何使用选择的事件总线
*   **开发人员必须学会根据事件进行思考**
*   负责共享实体的服务现在必须发出事件，其他服务必须使用它们
*   **应用流程在某些情况下非常难以理解**
*   事件的编排成为一个可能的问题

![](img/3b34cf5fa7e6ef51ccbb6efe844d166a.png)

Photo by [Yannik Mika](https://unsplash.com/@yannikm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](/s/photos/post-office?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

# 何时迈出这一步

我确信，向你展示你将要做出的权衡，让你的决定变得复杂，并没有让你的工作变得更容易。我甚至不想假装知道答案，但我能做的是提出一个经验法则:

当团队在当前状态下的认知负荷变得比你将拥有的更大时，采取下一步走向更分布式的系统。

但是你怎么知道那是什么时候呢？倾听人们的心声。他们在抱怨吗？他们在抱怨什么？多久一次？

如果十个开发人员中有六个说他们讨厌在前端和后端维护相同的东西，那么将这种逻辑提取到一个模块中更有可能产生净收益。

尽管如此，如果他们中的大多数人需要学习编写单元测试，也许要重新考虑向池中添加更多的知识债务。

这很好地引导我们开始写这篇文章的原因。

# 可持续性

太多时候，我们为大项目和快速增长做计划，几乎从未问过自己——这是可持续的吗？

我想说，这样的宏伟计划很少出现。如果你是成功的，并且能够负担得起这种快速增长，这很好，但是让更多的人来解决这个问题只会让你坚持这么久，直到建立这个东西并包含所有孤立和未记录的知识的人因为各种原因开始离开。

实现持续增长比测量认知负荷更简单。以下是你可能需要做的一些事情:

*   [**建立对团队的信任**](https://rework.withgoogle.com/print/guides/5721312655835136/#:~:text=The%20Google%20researchers%20found%20that,twice%20as%20often%20by%20executives.)
*   [遵循业内公认的最佳实践](https://dzone.com/articles/accelerate-a-principle-based-devops-framework)
*   [控制进气和测量工作流量](https://getnave.com/blog/kanban-metrics/#:~:text=The%20two%20Kanban%20metrics%20that,are%20connected%20by%20Little's%20Law.)
*   [构建松散耦合的组件](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

当你决定开始这段可持续发展的旅程时，不要一蹴而就。介绍更多的好习惯和做法，只有当大多数人已经采纳了你已经介绍过的。

# 结论

人们往往认为一项新的热门技术或架构是自切片面包以来最好的东西，但事实是——这总是一种交易。

真正的问题是——你需要它吗？

我对软件和开发软件的人想得越多，我就越能看到这些解决方案的复杂性带来的负面影响。

我绝不是说回到 monoliths，而是说如果你的团队由三到四个工作经验有限的开发人员组成，你可能需要重新考虑微服务优先的方法。

权衡你的选择，并尝试选择你的团队可以轻松实现的策略。除非你的团队由经验丰富的海豹突击队员组成，否则我大胆猜测，你最好从一个整体开始，学习分离模块，只有当你很好地掌握了你的系统时才进行拆分。
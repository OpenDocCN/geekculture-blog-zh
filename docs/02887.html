<html>
<head>
<title>Better architecture with Railway Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向铁路规划的更好架构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/better-architecture-with-railway-oriented-programming-ad4288a273ce?source=collection_archive---------13-----------------------#2021-05-27">https://medium.com/geekculture/better-architecture-with-railway-oriented-programming-ad4288a273ce?source=collection_archive---------13-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0028" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如果你仍然抛出异常，你可能做错了</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3530c0ccbccfb94db9ae95a275888222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCLAFAlVFF9UrOZJBagPHg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Light and Dark. Success and Failure. Functional and Reactive. Photo by <a class="ae jn" href="https://unsplash.com/@jackofthearts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Andrew Karn</a> on <a class="ae jn" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d136" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了让你的代码有一个“架构”，你需要一个地图和一条路径，一个图表和一些箭头。但是，我们所说的“路径”到底指的是什么——箭头的本质是什么，它们是如何表现的？</p><p id="2d5b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">换句话说，当我们在层间传递数据时，我们传递的是什么？在一个简单的体系结构中，您可能会向下传递各层的参数散列:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/880ba5a1390c53caa224568885f6c571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKgwW_fcR8GLj1dnWoxMyQ.png"/></div></div></figure><p id="9082" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并接收各层上的模型对象</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/8a2dbdb98a59c13bc34276c2973cbfcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1m0R1nEBihnfkBWaldRw-g.png"/></div></div></figure><p id="6f59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最终被映射成某种HTTP响应代码+一个响应体。</p><p id="8606" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种策略适用于简单的API，但是当我们开始出错时会发生什么呢？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kl"><img src="../Images/f02bea1a17f42f50e4ee4cea4b2e368d.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*UVxc-myPyezubmgSJoKV9Q.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Follow the (functional) road!</figcaption></figure><h1 id="5e84" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">处理命令式代码中的错误</h1><p id="7be0" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">假设我们有一个简单的API端点，<code class="du lj lk ll lm b">post ‘/user/email’</code>。我们想要更新客户的电子邮件地址，并通知他地址已经更改。</p><p id="dbef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的v1快速而肮脏的方法中，你可能会想到下面的方法(在这里用<a class="ae jn" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a> /Ruby实现):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="bad1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的，但是我们如何处理这里的错误呢？我们需要检查它是否有效:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0d20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还想检查是否没有客户记录:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="3c46" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果数据库写操作失败怎么办？</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="43de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们的smtp服务没有通知这一变化，该怎么办呢？也许我们想记录这个事实？</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2592" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于命令式代码，错误处理至关重要，随着API的扩展，更多的错误和边缘情况变得可能或可见。命令式代码中的错误处理使得代码更难阅读。</p><h1 id="01af" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">面向铁路的规划</h1><p id="eaf6" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated"><em class="lp">(注:本节改编自</em> <a class="ae jn" href="https://fsharpforfunandprofit.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> F#为了好玩和利益</em> </a> <em class="lp"> ) </em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lq"><img src="../Images/b353b375192d59f92acd586c0479fe36.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*MqNvP5ci_BN4rT4Jr5Jadg.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">MS actually has a lot of <a class="ae jn" href="https://en.wikipedia.org/wiki/ReactiveX" rel="noopener ugc nofollow" target="_blank">good</a> <a class="ae jn" href="https://en.wikipedia.org/wiki/TypeScript" rel="noopener ugc nofollow" target="_blank">ideas</a>.</figcaption></figure><p id="c0d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2014年，一位来自微软的<a class="ae jn" href="https://twitter.com/ScottWlaschin" rel="noopener ugc nofollow" target="_blank">开发者创造了术语“</a><a class="ae jn" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">铁路导向编程</a>”，它从函数式编程方法中获得了很多灵感。他正确地指出了“设计不愉快的路径”和考虑具有不止一个输出的函数的重要性。</p><p id="603a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们第一次对端点建模时，我们认为它们是具有一个输入和一个输出的简单函数:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/a32a5d4c14f18635d44c1a95fc630db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJKq9HPqeFi01IcKU8MGAw.png"/></div></div></figure><p id="a5c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随着端点范围的扩大，我们可能会考虑将其分成不同的步骤、层、组件等:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/ea799696db1bccafc51cca25959c1158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hvIUrV2bj25P4EBYfp9-w.png"/></div></div></figure><p id="21ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是在现实世界中，我们知道这些步骤中的每一步都有失败的可能，我们必须在这些步骤中的每一步提供中断控制流的机制:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/3fc0bc3209c8948a94945002d79bbc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKqZc1NTrposNA4emtrE7g.png"/></div></div></figure><p id="c5b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">认识到我们需要返回<strong class="jq hj">多个值</strong>的函数，无论是成功还是错误响应，这是面向铁路编程的基础，也是我们今天API设计的基础。</p><h1 id="4d36" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">成功和失败</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/819fb590bd3a31a2b156b64526edbcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Z0QMxWCT7eTpXEe9HZxn0w.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Errors are Responses too</figcaption></figure><p id="fea3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">失败可能发生在我们处理链的任何地方，我们需要一种简化的方法来退出处理并向客户端返回一个<strong class="jq hj">失败</strong>。或者，如果一切顺利，返回一个<strong class="jq hj">成功</strong>。</p><p id="e5c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用于处理端点的一系列类或步骤代表一个功能单元，它总是导致<strong class="jq hj">成功</strong>或<strong class="jq hj">失败</strong>，其中包含结果数据(例如对于成功的读取操作)或关于所发生的失败的信息(例如在验证期间)。</p><p id="b9e3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">反过来，每一步可以返回一个<strong class="jq hj">成功</strong>或<strong class="jq hj">失败</strong>，编排器(<strong class="jq hj">控制器</strong>)使用它们来停止或继续处理。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/4981807b141a69e41e953f16c192def1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MY9oKDrciUPf-L7Cn_EAw.png"/></div></div></figure><h1 id="bd12" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">面向铁路的规划</h1><p id="6947" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">我们把上面的功能处理想象成两条平行的铁轨。对于完全成功的请求，列车沿着绿色(<strong class="jq hj">成功</strong>)轨道前进，直到完成。然而，如果沿途任何地方发生故障，列车将切换到红色(<strong class="jq hj">故障</strong>)轨道，我们将错误返回给客户端。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/a0fadf31814067b8d1a880f30d183f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYWW-5en-77WJLsLOAq4CQ.png"/></div></div></figure><p id="2e8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">双轨函数的构造和组合是基于函数式编程的理论。有许多重要的规则来管理如何建立和组成“双轨功能”。我们建议在<a class="ae jn" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">https://fsharpforfunandprofit.com/rop/</a>通读所有幻灯片</p><h1 id="2051" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">在Ruby中构建双轨</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/e5d357fa70e6e333d43773702269a3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*mq8JkpZegvulu-Z0dQ0LIA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Haskell humor. See <a class="ae jn" href="https://stackoverflow.com/q/3870088" rel="noopener ugc nofollow" target="_blank">Stack Overflow.</a></figcaption></figure><p id="16a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了构建双轨执行路径，我们使用<a class="ae jn" href="https://dry-rb.org/gems/dry-monads/1.3/" rel="noopener ugc nofollow" target="_blank">干式单子</a>。Dry monads定义了monads，这是一个特殊的<a class="ae jn" href="https://www.geeksforgeeks.org/ruby-mixins/" rel="noopener ugc nofollow" target="_blank"> ruby mixin </a>的正式名称，它定义了两种新的<a class="ae jn" href="https://dry-rb.org/gems/dry-monads/1.3/result/" rel="noopener ugc nofollow" target="_blank">结果类型</a>:成功和失败</p><p id="d23e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，任何时候我们可能已经返回了一个值，比如一个<a class="ae jn" href="https://guides.rubyonrails.org/active_record_basics.html" rel="noopener ugc nofollow" target="_blank"> ActiveRecord </a>模型对象，我们现在将返回一个<code class="du lj lk ll lm b">Success(ActiveRecord)</code></p><p id="5246" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，尽管我们可能已经调用了raise <code class="du lj lk ll lm b">SomeError</code>或者甚至是<code class="du lj lk ll lm b">halt 4XX</code>，我们现在将返回一个<code class="du lj lk ll lm b">Failure(SomeError)</code></p><p id="70d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">干燥单胞菌的文档在这里描述<a class="ae jn" href="https://dry-rb.org/gems/dry-monads/1.3/" rel="noopener ugc nofollow" target="_blank">，但是最终的形式可以在这里看到:</a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b2a2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个实现中，您可以看到find_user现在返回一个monad，而不是直接返回一个用户。bind方法解包成功值，并使它们对块可用。借助ruby带来的额外元编程魔力，我们可以进一步简化这个模块:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="c3cc" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">与反应式客户端编程的关系</h1><p id="624f" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">到目前为止，我们一直在谈论服务器端架构，但值得注意的是，我们描述的原则直接映射到客户端架构模式，如<a class="ae jn" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">反应式编程</a>所述。</p><p id="2189" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Swift中，我们可以在<a class="ae jn" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">合并器</a>中重写代码块，它有一个<a class="ae jn" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank">发布器</a>的概念，它定义了<code class="du lj lk ll lm b">Output</code>和<code class="du lj lk ll lm b">Failure</code>类型，类似于上面的干燥单子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8945" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Kotlin中，我们可以使用<a class="ae jn" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank">单个</a>操作符重写<a class="ae jn" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>中的代码块，这再次定义了值和错误输出:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="f7d4" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">更新我们的W形执行</h1><p id="ef59" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">在之前的博客文章中，我们描述了web API执行流的<a class="ae jn" rel="noopener" href="/p/9d65232e8a24/">模式</a>。我们推荐的最后一个模式，W形执行，可以通过以下方式更新:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/fb35fe8c143498779d8eb42d90f21988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9VnyEblecyQbxqyZ0pZfA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Two lanes on each path — one for success, one for failure</figcaption></figure><p id="49db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们知道，如果我们在其中一层转换到错误状态，我们将一直处于“错误”状态，直到我们最终通过POST(或者可能，但不一定总是在Websocket中)向用户返回一个值。</p><h1 id="ddb3" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">接下来</h1><p id="2392" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">是时候我们开始定义一些层了！从Clean架构中获得灵感，使用V-U-W执行流和面向铁路的编程原则，我们准备好<a class="ae jn" rel="noopener" href="/p/2b57074084d5/">定义我们今天用于API端点设计的架构</a>。</p><h1 id="d8b9" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">本系列的更多内容</h1><ul class=""><li id="3060" class="lx ly hi jq b jr le ju lf jx lz kb ma kf mb kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/p/c36044df2ac7/">web API设计的视觉历史</a></li><li id="df7d" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/p/9d65232e8a24/">web API执行流程的模式</a></li><li id="8a52" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated">面向铁路的编程←你来了</li><li id="edd3" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/perry-street-software-engineering/clean-api-architecture-2b57074084d5">干净的API架构</a></li><li id="a417" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/nerd-for-tech/the-endpoint-responsibility-checklist-d7763449f44a">端点责任清单</a></li><li id="47d2" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><a class="ae jn" rel="noopener" href="/perry-street-software-engineering/clean-api-example-save-a-favorite-d45ca6aeba4c">代码示例:保存收藏夹</a></li></ul><h1 id="064e" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">你可能喜欢的其他系列</h1><p id="5e31" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated"><a class="ae jn" href="https://proandroiddev.com/android-activity-lifecycle-considered-harmful-98a5b00d287" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Android活动生命周期被认为有害</strong></a><strong class="jq hj">(2021)<br/></strong>Android进程死亡，不可解释的NullPointerExceptions，以及你现在就需要的MVVM生命周期</p><p id="1177" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" rel="noopener" href="/swlh/kotlin-in-xcode-swift-in-android-studio-26a4ace6fc72"><strong class="jq hj">Xcode中的Kotlin？安卓工作室</strong> </a>中的Swift？<strong class="jq hj"> (2020) </strong> <br/>关于在iOS上使用Clean + MVVM实现一致架构的系列文章&amp; Android</p><h1 id="8943" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">关于作者</h1><p id="51c8" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated"><em class="lp">埃里克·西尔弗伯格是佩里街软件</em> <a class="ae jn" href="https://www.perrystreet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">的首席执行官</em> </a> <em class="lp">，LGBTQ+约会应用</em><a class="ae jn" href="https://www.scruff.com/" rel="noopener ugc nofollow" target="_blank"><em class="lp">SCRUFF</em></a><em class="lp">和</em><a class="ae jn" href="https://www.jackd.com/" rel="noopener ugc nofollow" target="_blank"><em class="lp">Jack ' d</em></a><em class="lp">的发行人，在全球拥有超过2000万会员。</em></p></div></div>    
</body>
</html>
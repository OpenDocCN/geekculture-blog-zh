<html>
<head>
<title>Optimising memory usage in Python code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Python代码中的内存使用</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/optimising-memory-usage-in-python-code-d50a9c2a562b?source=collection_archive---------14-----------------------#2022-05-03">https://medium.com/geekculture/optimising-memory-usage-in-python-code-d50a9c2a562b?source=collection_archive---------14-----------------------#2022-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将讨论一些有用的资源/技巧来优化python中的内存使用，让我们直接切入主题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bd0a1ce2c592a9e4fdb6439871af2954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fTGf-mXo_4_Qgt6I"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@hellokellybrito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">J. Kelly Brito</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4085" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">缓存它</h1><p id="596c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">数据密集型项目很难避免下载大量数据，如网站和数据库转储、推文、其他社交媒体帖子等。这些下载需要大量时间，消耗带宽和我们的信任度。如果数据源对我们的交易不是特别感兴趣，它可能会禁止或限制我们的IP地址，使进一步的下载变得缓慢或不可能。因此，引用一个相对用户友好的网站，礼貌的数据矿工缓存在他们的结束；<a class="ae jt" href="https://dev.livejournal.com/653177.html" rel="noopener ugc nofollow" target="_blank">无礼者被禁</a>。一般来说，我们希望缓存我们下载的任何东西，除非我们有充分的理由相信我们不再需要它，或者它会在我们再次需要它之前过期。</p><ul class=""><li id="db2e" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">一种经典的缓存方法是通过标识符组织一个目录来存储以前获得的对象。例如，标识符可以是对象的URL、tweet ids或数据库行号；任何与物品来源相关的东西。</li><li id="bee7" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">下一步是将标识符转换成外观一致的唯一文件名。我们可以自己编写转换函数，也可以使用标准库。首先对标识符进行编码，它可能是一个字符串。应用一个散列函数，比如<code class="du ll lm ln lo b">hashlib.md5()</code>或者更快的<code class="du ll lm ln lo b">hashlib.sha256()</code>，来获得一个散列对象。这些函数不会产生完全唯一的文件名，但是获得两个相同文件名的可能性(称为<strong class="ih hj">哈希冲突</strong>)非常低，我们可以忽略它。最后，获取对象的十六进制摘要。摘要只是一个64个字符的ASCII字符串:一个完美的文件名，与原始对象标识符没有任何相似之处。</li></ul><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="bf1e" class="lt jv hi lo b fi lu lv l lw lx">import hashlib<br/>source = ‘https://lj-dev.livejournal.com/653177.html'<br/>hash = hashlib.sha256(source.encode())<br/>filename = hash.hexdigest()<br/>print(hash, filename)</span></pre><p id="b338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设已经创建了目录缓存，并且它是可写的，那么我们可以将我们的对象放入其中。</p><p id="faf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，检查对象是否已经被酸洗。如果有，我们已经下载了它，没有必要再从源代码中获取它。</p><p id="9e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但首先，检查对象是否已经被腌制。如果是的话，我们已经下载了。不需要再次从源获取它。</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="54d6" class="lt jv hi lo b fi lu lv l lw lx">cache = f'cache/{filename}.p' <br/>try:<br/>  with open(cache, 'rb') as infile:<br/>      # Has been pickled before! Simply unpickle <br/>      object = pickle.load(infile)<br/>except FileNotFoundError:<br/>    # Download and pickle<br/>    object = 'https://lj-dev.livejournal.com/653177.html' <br/>    with open(cache, 'wb') as outfile:<br/>      pickle.dump(outfile, object) <br/>except:<br/>    # Things happen...</span></pre><p id="f28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可能希望将前面提到的片段组合成一个函数，该函数接受一个对象标识符，并从源或本地缓存中检索对象。缓存是相当令人兴奋的行为；对函数的第一次调用可能比连续调用花费更多的时间。</p><h1 id="14c2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">就地大排序</h1><p id="4119" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">排序和搜索可以说是现代计算中最频繁和最重要的两种操作。它们如此频繁，以至于全球市值第二大的科技公司Alphabet(谷歌)靠n排序和搜索发了财。它们如此重要，以至于Python有两个函数用于对列表进行排序:<code class="du ll lm ln lo b">list.sort()</code>和<code class="du ll lm ln lo b">sorted()</code>。</p><h2 id="3f2e" class="lt jv hi bd jw ly lz ma ka mb mc md ke iq me mf ki iu mg mh km iy mi mj kq mk bi translated">有什么区别？</h2><ul class=""><li id="226d" class="kx ky hi ih b ii ks im kt iq ml iu mm iy mn jc lc ld le lf bi translated">首先，<code class="du ll lm ln lo b">sorted()</code>对任何可迭代的进行排序，而<code class="du ll lm ln lo b">list.sort()</code>只对列表进行排序。鉴于Python对列表的重视，这似乎不是问题。</li><li id="f737" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">其次，<code class="du ll lm ln lo b">sorted()</code>创建原始iterable的排序副本。当它返回时，我们得到两个iterables:原始的和排序的，这是好的和坏的。这很糟糕，因为我们需要两倍的内存。这对于一个小列表来说没什么大不了的，但是对于一个大数据集来说却是一个重要的问题。当我们有一个十亿条的列表时，我们可能会想是否要复制它。作为一种补偿，我们仍然可以按照原来的顺序访问列表项。</li></ul><p id="3668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ll lm ln lo b">list.sort()</code>方法对列表进行排序。它打乱了列表项的顺序，但没有制作副本。如果我们能够将列表加载到内存中，我们肯定能够对其进行排序。然而，<code class="du ll lm ln lo b">list.sort()</code>却破坏了原有的秩序。有趣的是，这两种排序工具的性能大致相同。</p><p id="ca1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结一下，如果我们的列表很大，用</strong> <code class="du ll lm ln lo b"><strong class="ih hj">list.sort()</strong></code> <strong class="ih hj">排序到位。如果我们的列表大小适中或者需要保持原来的顺序，调用</strong> <code class="du ll lm ln lo b"><strong class="ih hj">sorted()</strong></code> <strong class="ih hj">并检索一个排序后的副本。</strong></p><h1 id="b919" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">删除你的垃圾</h1><p id="29fa" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Python是一种具有隐式内存管理的语言。C和C++语言要求我们自己分配和释放内存。Python自己管理分配和释放。当我们通过赋值语句定义一个变量时，Python会创建变量和与之相关的对象。</p><h2 id="2b19" class="lt jv hi bd jw ly lz ma ka mb mc md ke iq me mf ki iu mg mh km iy mi mj kq mk bi translated">何时销毁</h2><p id="8022" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">每个Python对象都有一个<strong class="ih hj">引用计数</strong>，即引用该对象的变量和其他对象的数量。当我们创建一个对象，并且没有把它赋给一个变量时，这个对象就没有引用:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="6e70" class="lt jv hi lo b fi lu lv l lw lx">'Hello, world!' # An object without references</span></pre><p id="eaa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个对象没有被引用，我们就不能使用它。特别是，我们不能把上一个例子中的字符串转换成小写。但是，如果我们将字符串赋给一个变量，我们将引用它并在将来使用它:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="d599" class="lt jv hi lo b fi lu lv l lw lx">s = 'Hello, world!' # An object with single reference</span></pre><p id="94ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过将同一个对象赋给几个变量来创建更多的引用:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="2250" class="lt jv hi lo b fi lu lv l lw lx">s3 = s2 = s1 = s # Four references to the same object!</span></pre><p id="64dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们重新定义一个变量时，它不再指向旧的对象，引用计数减少:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="9a77" class="lt jv hi lo b fi lu lv l lw lx">s = 'Goodbye, world!' # Only three references remain</span></pre><p id="8270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考可以是间接的。例如，strList列表包含对原始字符串的引用。如果我们进一步重新定义s1、s2和s3，只要列表被引用，字符串的引用计数仍然是正的:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="2fba" class="lt jv hi lo b fi lu lv l lw lx">strList = [s1]<br/>s1 = s2 = s3 = None</span></pre><h2 id="5f37" class="lt jv hi bd jw ly lz ma ka mb mc md ke iq me mf ki iu mg mh km iy mi mj kq mk bi translated">垃圾收集工</h2><p id="2a64" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当引用计数变为零时，对象变得不可达。出于任何实际目的，一个不可及的对象就是一堆垃圾。称为<strong class="ih hj">垃圾收集器</strong>的Python运行时的一部分自动收集并丢弃未被引用的对象。很少有必要去干扰它，但是这里有一个场景，这种干扰是有帮助的。</p><p id="ab8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们使用<em class="mo">大数据</em>——不是大数据，而是大到足以给我们的计算机RAM带来压力的数据。我们从原始数据集开始，逐步对其应用昂贵的转换，并记录中间结果。一个中间结果可以用于一个以上的后续转换。最终，我们的计算机内存将被大对象堵塞，其中一些仍然需要，而一些则不需要。我们可以通过使用<code class="du ll lm ln lo b">del</code>操作符显式标记要删除的变量和相关对象来帮助Python:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="1f45" class="lt jv hi lo b fi lu lv l lw lx">bigData = ...<br/>bigData1 = func1(bigData) <br/>bigData2 = func2(bigData)<br/>del bigData # Not needed anymore</span></pre><p id="6049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住<code class="du ll lm ln lo b">del</code>不会从内存中移除对象。它只是将其标记为未引用，并销毁其标识符。垃圾收集器仍然必须干预并收集垃圾。我们可能希望通过模块<code class="du ll lm ln lo b">gc</code>中提供的接口，在预计到大量内存使用的情况下，立即强制进行垃圾收集</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="72b6" class="lt jv hi lo b fi lu lv l lw lx">import gc # Garbage Collector<br/>gc.collect()</span></pre><p id="278f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不要滥用这个功能。垃圾收集需要很长时间，所以我们应该只让它在必要的时候发生。</strong></p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="d191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天就到这里，希望您已经收集了一些关于优化python内存的信息。下次见，再见</p></div></div>    
</body>
</html>
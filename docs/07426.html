<html>
<head>
<title>How to architect your Flask Rest API.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建你的Flask Rest API？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-architect-your-flask-rest-api-abf95637d9f5?source=collection_archive---------3-----------------------#2021-09-18">https://medium.com/geekculture/how-to-architect-your-flask-rest-api-abf95637d9f5?source=collection_archive---------3-----------------------#2021-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/97230ad599f6cdb9c4a66792b191a7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5cbsn_nPBoSLstIqD_7zw.jpeg"/></div></div></figure><p id="7003" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将向你展示如何构建你的Flask REST API。没有别的事了，让我们开始吧。</p><p id="48ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用Flask构建传统的REST API是什么样子？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/2d4e29c59b485584889385a64a6bcf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6anoubchfksPM3bYHZo9Ig.png"/></div></div></figure><p id="ac3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常我们所做的是把所有的内容(路线、数据模型、验证器类等等...)在一个名为App.py的文件中，但是当涉及到架构代码时，我们需要一个适当的文件夹结构，将我们的逻辑分成这些文件夹，然后导入到我们的主App.py中</p><p id="e890" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在我们的代码库中拥有一个好的架构有什么好处？</strong></p><ol class=""><li id="d47c" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">更容易维护。</li><li id="8ddf" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">其他开发者更容易理解。</li><li id="2002" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">避免代码重复，降低成本。</li><li id="3879" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">可以非常快速地对现有代码库进行升级/更改。</li><li id="46bd" class="jt ju hi is b it kc ix kd jb ke jf kf jj kg jn jy jz ka kb bi translated">更多…</li></ol><p id="d407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件夹结构</strong></p><ol class=""><li id="7ada" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated"><strong class="is hj"> api </strong> —包含应用程序所有路径/端点的文件夹。这些路由/端点仅用于接受请求。此路由/端点的逻辑在不同的文件夹中实现。</li></ol><p id="6f67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj">模型</strong> —包含所有带约束的数据库模型类的文件夹</p><p id="566c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<strong class="is hj">服务</strong> —所有路由/端点的逻辑都在这里实现</p><p id="c9bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.<strong class="is hj"> utils </strong> —这是我们将要添加其他函数和类的文件夹，例如JWT令牌生成器函数、JWT令牌验证函数、密码加密函数等</p><h1 id="aed5" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">API层</h1><p id="476b" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在这个文件夹/层中，我们可以将所有的端点写在单独的文件中。例如，我们可以拥有User.py，它包含与用户相关的所有路由。我们可以拥有Product.py，它包含与产品相关的所有路线。像wise一样，我们可以将这一层的所有端点写在不同的文件中。</p><p id="0e42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我们如何在app.py中使用这些端点呢？</p><p id="3615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在我们的主app.js中使用这些端点，我们必须使用Flask提供的Blueprint。使用blueprint，我们可以注册我们的端点，并在app.py中使用该端点</p><pre class="jp jq jr js fd lk ll lm ln aw lo bi"><span id="aa22" class="lp ki hi ll b fi lq lr l ls lt">in our route file</span><span id="1467" class="lp ki hi ll b fi lu lr l ls lt">from flask import Blueprint, request</span><span id="5b0a" class="lp ki hi ll b fi lu lr l ls lt">@product_route.route("/stock/add", methods=['POST'])<br/>def stock_add():            <br/>...</span><span id="4414" class="lp ki hi ll b fi lu lr l ls lt">-----------------</span><span id="41cc" class="lp ki hi ll b fi lu lr l ls lt">in app.py</span><span id="4f78" class="lp ki hi ll b fi lu lr l ls lt">from api.stock import stock_route</span><span id="afd3" class="lp ki hi ll b fi lu lr l ls lt">app.register_blueprint(stock_route)</span></pre><h1 id="c7ba" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">模型层</h1><p id="636f" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在这一层，我们可以定义所有的模型类。如果我们使用类似sql alchemy或mongo engine的东西，我们可以在这里定义这些模型类。</p><h1 id="82d7" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">服务层</h1><p id="a2f6" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">正如你在API层看到的，我们只接受用户的请求。但是我们没有在那里执行任何逻辑。我们使用服务层来编写端点逻辑。例如，假设您有一个端点来获取产品数据。所以在API层你可以写端点。但是为了获得数据，你需要对数据库或文件编写查询。所以逻辑要写在这一层。</p><h1 id="c36e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">实用程序层</h1><p id="3937" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">我们可以将其他函数或类放在这一层。例如，您有一个加密文本(更具体地说是密码)的函数。这些功能很可能依赖于一些第三方软件包。所以如果你把这些放在这里，当你面对一个包的问题时，你唯一要做的就是改变这一层。它不会影响其他层。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="859b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在<a class="ae mc" href="https://github.com/Shihara-Dilshan/John-Keells-App-Revamp/tree/main/Server" rel="noopener ugc nofollow" target="_blank">这里</a>找到用这个架构构建的完整REST API。</p></div></div>    
</body>
</html>
<html>
<head>
<title>DHT11 Temperature Sensor Library for the Raspberry Pico: Python Prototype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于Raspberry Pico: Python原型的DHT11温度传感器库</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dht11-temperature-sensor-library-for-the-raspberry-pico-python-prototype-5ba9f246c9e?source=collection_archive---------22-----------------------#2021-07-05">https://medium.com/geekculture/dht11-temperature-sensor-library-for-the-raspberry-pico-python-prototype-5ba9f246c9e?source=collection_archive---------22-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b485a73cf2d907b925b2ff174885806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bWMJlS8DYute6Ze1JXd9w.png"/></div></div></figure><p id="dd23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Raspberry Pico，简称Pico，是Raspberry Pi基金会的一款新型微控制器。它提供了双核ARM处理器、2MB闪存和26个GPIO引脚。您可以使用C/C++ SDK或MicroPython对Pico进行编程。我被这个设备迷住了，并开始开发一个用于读取DHT11温度传感器的库。然而，为了获得专有1线要求的准确时序要求，我们需要使用PIO子系统。</p><p id="1ffd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上一篇文章解释了Pio系统和语言。在本文中，我将设计并实现一个连接DHT11传感器的PIO原型程序。原型负责向传感器发送所需的启动信号，然后记录其响应，即26–70 us范围内的电脉冲，即编码的传感器数据。使用MicroPython进行开发:交互式REPL环境和脚本语言的特性提供了一个灵活的环境。</p><p id="8c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em> <a class="ae jp" href="https://admantium.com/blog/pico11_temperature_sensor_python_prototype/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的博客</em> </a>。</p><h1 id="ae3d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">DHT11协议概述</h1><p id="dd2c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">DHT11协议在单线连接上工作。此线路为高电平有效。要启用DHT 11传感器</p><ul class=""><li id="c14e" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">发送低电平至少18毫秒</li><li id="00b3" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">释放低电平</li><li id="e89b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">预计80us价格较低</li><li id="d7d2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">对80us的期望很高</li></ul><p id="e35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，传感器通过电线发送不同类型的脉冲，传输总量为40位的数据:</p><ul class=""><li id="bbad" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第0位:高电平代表26-28微秒，低电平代表50微秒</li><li id="bc88" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第1位:高电平50us，随后高电平70us</li></ul><p id="9f53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">40位数据分为2x8位温度数据、2x 8位湿度数据和8位校验和数据。</p><h1 id="2f53" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">PIO程序设计</h1><p id="e84b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们考虑一下PIO计划的要点:</p><ul class=""><li id="63c3" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">可以拥有灵活的引脚映射来读写数据</li><li id="6c0c" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">133MHZ的频率可以用一个8位分频器值来调整</li><li id="16f2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">可以有32条指令</li><li id="42fc" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">可以写入32位寄存器(或64位寄存器，如果状态机的两个FIFOs合并)</li></ul><p id="d1aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些约束以下列方式塑造了程序方法:</p><ul class=""><li id="7c87" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">该程序需要以足够精细的频率工作，以捕捉28us和70us之间的差异，并且还包括启动期间的18ms</li><li id="3f2c" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">我们需要将同一个引脚定义为输入和输出引脚</li><li id="7e80" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">引脚为高电平有效，在DHT11启动阶段后，它将其角色从输出切换到输入，以使用正确的PIO语句</li><li id="8644" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">我们需要记录32位有效载荷和8位校验和数据</li></ul><p id="f0e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过一些实验后，我想到了一种设计，它可以用纯粹的MicroPython命令激活DHT11传感器，然后启动一个状态机，该状态机运行缓慢，足以检测DHT信号中的26–28 us脉冲。</p><h1 id="b05c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">程序原型</h1><p id="c94d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们将一步一步地实现这个程序，一次解决一个约束。</p><h1 id="1ab3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">MicroPython PIO计划要点</h1><p id="af34" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">带有嵌入式PIO程序的MicroPython程序的一般设置如下。此示例显示了如何使单个LED闪烁。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="adf6" class="lq jr hi lm b fi lr ls l lt lu">from rp2 import PIO, StateMachine, asm_pio<br/>from machine import Pin<br/>import time</span><span id="9f16" class="lq jr hi lm b fi lv ls l lt lu">@asm_pio(set_init=PIO.OUT_LOW)<br/>def pio_program():<br/>    set(pins, 1) [31]<br/>    nop()        [31]<br/>    set(pins, 0) [31]</span><span id="6efa" class="lq jr hi lm b fi lv ls l lt lu">state_machine = StateMachine(0, pio_program, freq = 2000, set_base=Pin(25))</span><span id="a995" class="lq jr hi lm b fi lv ls l lt lu">state_machine.active(1)</span></pre><p id="de73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该程序中，发生以下步骤:</p><ul class=""><li id="e875" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">第1–3行:<code class="du lw lx ly lm b">import</code>语句定义了程序所需的对象</li><li id="8943" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第五行。:装饰器<code class="du lw lx ly lm b">@asm_pio</code>将下一个方法标识为PIO程序。装饰器接受定制状态机的所有参数，比如引脚的初始方向、ISR/OSR的移位方向以及push和pull方法的自动或阈值</li><li id="2fcb" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第7–9行:官方文档<a class="ae jp" href="https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf" rel="noopener ugc nofollow" target="_blank">中记录的Pio汇编程序命令</a>。在MicroPython中，命名约定有细微的差别，所以请务必阅读<a class="ae jp" href="https://dernulleffekt.de/doku.php?id=raspberrypipico:pico_pio" rel="noopener ugc nofollow" target="_blank">社区文档</a>以及<a class="ae jp" href="https://github.com/raspberrypi/pico-micropython-examples/blob/master/pio/pio_spi.py" rel="noopener ugc nofollow" target="_blank">浏览示例</a></li><li id="7237" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第11行:PIO程序用于构建一个状态机。该对象接收两个强制参数——状态机id和包含PIO程序的函数名。其他参数是频率和各种引脚设置(on、out、side、set和jmp引脚)</li><li id="3a38" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">第13行:实例化的状态机被激活</li></ul><h1 id="8b4a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">频率计算</h1><p id="7f75" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">您可以将PIO节目频率设置为2Khz到133Mhz之间的任何频率。使用<a class="ae jp" href="https://www.sensorsone.com/period-to-frequency-calculator/" rel="noopener ugc nofollow" target="_blank">在线工具</a>，我们可以看到频率如何转化为秒:<code class="du lw lx ly lm b">2000 Hz = 500us</code>、<code class="du lw lx ly lm b">5000 Hz = 200us</code>和<code class="du lw lx ly lm b">10000 Hz = 100us</code>。然而，频率决定了程序中所有指令的运行速度。因此，我们首先计算所有指令的周期为<code class="du lw lx ly lm b">cycle = target_frequency * (number of statements + wait cycles)</code>，状态机的频率为<code class="du lw lx ly lm b">state_machine_frequency = cycle * * (number of statements + wait cycles)</code></p><p id="9769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于启动程序，我们需要运行大约26us。如果我们的目标是总共20条指令，这就转化为<code class="du lw lx ly lm b">2000Hz / 20 = 100Hz = 10ms = 10000us</code>——发送40us信号太快了。反过来<code class="du lw lx ly lm b">25000 / 20 = 25000 Hz = 0.04ms = 40us</code>——这将迫使use等待500条指令。</p><p id="2948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，启动器PIO程序将只发送初始脉冲，所有其他计算将由另一个状态机运行。</p><p id="5260" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">读取器状态机有16条指令，1条指令将被停止31个周期。所以状态机的周期需要为<code class="du lw lx ly lm b">1us * (16+31)= 21277Hz</code>，总频率为<code class="du lw lx ly lm b">21277Hz * (16 + 31) = 1000019Hz</code>。</p><p id="9b84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">频率配置如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="eef0" class="lq jr hi lm b fi lr ls l lt lu">dht_reader = StateMachine(1,dht11_reader, freq = 1000019)</span></pre><h1 id="1b0e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">引脚设置和配置</h1><p id="73ed" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">如前所述，DHT11启动序列被MicroPython部分覆盖，然后PIO程序将被启动。</p><p id="5ae9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">启动序列包括用上拉电阻将引脚设置为输出模式，然后发送初始高电压250ms，然后发送低脉冲40ms。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3748" class="lq jr hi lm b fi lr ls l lt lu">dht_pin = Pin(15, Pin.OUT, Pin.PULL_DOWN)<br/>dht_pin.value(1)<br/>utime.sleep_ms(250)<br/>dht_pin.value(0)<br/>utime.sleep_ms(20)</span></pre><p id="b093" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们将引脚更改为上拉输入，并启动状态机。该引脚将同时用作输入引脚(因为我们将从中读取一个值)和跳转引脚(因为我们将使用其状态进行分支语句)。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="cbed" class="lq jr hi lm b fi lr ls l lt lu">dht_pin = Pin(15, Pin.IN, Pin.PULL_UP)<br/>dht_reader = StateMachine(1,dht11_reader, freq = 1000019, in_base=dht_pin, jmp_pin=dht_pin</span></pre><h1 id="c804" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">读取和推送数据</h1><p id="92b0" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最后一个要求是实现检测DHT11脉冲的核心逻辑，并将其转换为数据。经过几次尝试，我采用了一种受这个论坛启发的方法。本质上，PIO计划执行以下步骤:</p><ul class=""><li id="744c" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">等待引脚变为低电平，然后等待引脚变为高电平，捕捉DHT11响应信号</li><li id="470f" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">开始<code class="du lw lx ly lm b">read_bit</code>循环，它将再次等待引脚变低</li><li id="ea94" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">然后，当pin变高时，等待32us并读取pin值:如果它仍然为高，则DHT发送位<code class="du lw lx ly lm b">0b1</code>，否则它的<code class="du lw lx ly lm b">0b0</code></li><li id="17a9" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">调用相应的<code class="du lw lx ly lm b">high_detected</code>和<code class="du lw lx ly lm b">low_detected</code>代码块向ISR写入3位数据</li><li id="1b03" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">读取下一位</li></ul><p id="79fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当写入24位时，结果将自动推送到状态机。</p><p id="bca6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的PIO程序如下。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ab89" class="lq jr hi lm b fi lr ls l lt lu">@asm_pio(autopush=True, push_thresh=24)<br/>def dht11_reader():<br/>    # ínitial LOW-HIGH confirmation pulse<br/>    wait(0,pin,0)<br/>    wait(1,pin,0)</span><span id="af77" class="lq jr hi lm b fi lv ls l lt lu">    # Main loop<br/>    # General idea: if pin changes from high to low within 32 cycles, its logic 1, otherwise logic 0<br/>    label("read_bit")<br/>    wait(1,pin,0) [31]<br/>    jmp(pin, "high_detected")<br/>    jmp("low_detected")</span><span id="1be9" class="lq jr hi lm b fi lv ls l lt lu">    # Write 0b111 = (7), return to pattern loop<br/>    label("high_detected")<br/>    set(y,0b111)<br/>    in_(y,3)<br/>    wait(0,pin,0)<br/>    jmp("read_bit")</span><span id="b32e" class="lq jr hi lm b fi lv ls l lt lu">    # Write 0b100 =(4), return to pattern loop<br/>    label("low_detected")<br/>    set(y,0b100)<br/>    in_(y,3)<br/>    wait(0,pin,0)<br/>    jmp("read_bit")</span></pre><h1 id="05cc" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">主程序</h1><p id="9668" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">主程序开始一个无限循环。等待DHT11传感器通电2.5ms后，程序向传感器发送启动信号，启动状态机，并读取5次24位数据。数据将作为字符串存储在数组中。一旦完成，捕获的数据将作为二进制数打印到屏幕上，然后转换成湿度和温度值。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="9656" class="lq jr hi lm b fi lr ls l lt lu">print("Starting DHT11 Program ...")</span><span id="82b4" class="lq jr hi lm b fi lv ls l lt lu">i = 0<br/>while True:<br/>    sleep(2.0)</span><span id="edf5" class="lq jr hi lm b fi lv ls l lt lu">    i +=1<br/>    print("Cycle {} - Running state machine ...".format(i))</span><span id="711b" class="lq jr hi lm b fi lv ls l lt lu">    dht_pin = Pin(15, Pin.OUT, Pin.PULL_DOWN)<br/>    dht_pin.value(1)<br/>    utime.sleep_ms(250)<br/>    dht_pin.value(0)<br/>    utime.sleep_ms(30)<br/>    dht_pin = Pin(15, Pin.IN, Pin.PULL_UP)<br/>    dht_reader = StateMachine(1,dht11_reader, freq = 1000019, in_base=dht_pin, jmp_pin=dht_pin)</span><span id="909d" class="lq jr hi lm b fi lv ls l lt lu">    dht_reader.active(1)<br/>    data = []<br/>    for _ in range(5):<br/>        data.append(bin(dht_reader.get()))</span><span id="7ba3" class="lq jr hi lm b fi lv ls l lt lu">    dht_reader.active(0)<br/>    sleep(0.5)</span><span id="8340" class="lq jr hi lm b fi lv ls l lt lu">    for d in data:<br/>        print(d)</span></pre><h1 id="f585" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">输出示例</h1><p id="1da9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">2021年7月3日10:27在我房间进行的测量得出以下数据:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f8ee" class="lq jr hi lm b fi lr ls l lt lu">Starting DHT11 Program ...<br/>Cycle 1 - Running state machine ...<br/>0b100111111100100100111111<br/>0b111111100111111111111100<br/>0b111111100100100111100100<br/>0b111111111100100111100100<br/>0b100100100100111100100111</span><span id="57d2" class="lq jr hi lm b fi lv ls l lt lu">Temperature: 24.2 Degree Celcius<br/>Humidity: 48.1 %</span><span id="8e5d" class="lq jr hi lm b fi lv ls l lt lu">Temperature: 24.3 Degree Celcius<br/>Humidity: 48.2 %</span></pre><h1 id="2652" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="dd6a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">本文详细介绍了使用MicroPython读取DHT11温度传感器的PIO程序的实现。我们了解了PIOs的基本特性——频率选择、灵活的引脚映射、使用32位寄存器——以及DHT11的限制——80毫秒到24微秒之间的读/写操作、将单引脚角色从输出切换到输入、写入8位数据块。由此，我们一步一步地设计了一个程序。最后，这个项目成功了，但是开发时间和努力是巨大的。使用PIO的最初目标是获得精确的时间控制，然而我发现这只是在花费时间的高代价下实现的。最后，我还发现了一个用于DHT11的纯粹的MicroPython库，它可以完美地工作，并且考虑到最近对Arduino框架的支持，这种传感器的C库可以与Pico兼容。由于这些原因，我不会继续开发Pico C-SDK DHT11库。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Robust media upload with Golang and Cloudinary — Gin-gonic Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang和Cloudinary实现强大的媒体上传— Gin-gonic版本</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/robust-media-upload-with-golang-and-cloudinary-gin-gonic-version-a11366bec4fb?source=collection_archive---------11-----------------------#2022-02-08">https://medium.com/geekculture/robust-media-upload-with-golang-and-cloudinary-gin-gonic-version-a11366bec4fb?source=collection_archive---------11-----------------------#2022-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ab56296e1ca151302f449e6831da8c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqjDWdRF8eyaaeaJyHA7cQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Cover image</figcaption></figure><p id="d8b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">近年来，移动和web应用程序支持文件上传的需求大幅增长，从图像和视频到excel、CSV和PDF等文档。最重要的是，我们必须具备将文件上传支持集成到我们的应用程序中所需的知识。</p><p id="0ca9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章将讨论使用Golang的<a class="ae js" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin-gonic </a>框架和<a class="ae js" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>为REST API添加媒体上传支持。在本教程的最后，我们将学习如何构建一个Gin-gonic应用程序，将Cloudinary与Golang集成，并使用远程URL和本地文件存储将媒体文件上传到Cloudinary。</p><p id="e5af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Gin-gonic，俗称<strong class="iw hj"> Gin </strong>，是一个用Golang编写的HTTP web框架，具有性能和生产力支持。Gin使用定制版本的<a class="ae js" href="https://github.com/julienschmidt/httprouter" rel="noopener ugc nofollow" target="_blank"> HttpRouter </a>，这是一个轻量级、高性能的HTTP请求路由器，它在API路由中的导航速度比大多数框架都要快。</p><p id="270c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Cloudinary提供了一个强大的视觉媒体平台，用于为网站和应用程序上传、存储、管理、转换和交付图像和视频。该平台还为框架和库提供了大量的软件开发工具包(SDK)。</p><p id="8b7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以在这个<a class="ae js" href="https://github.com/Mr-Malomz/gin-cloudinary-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到完整的源代码。</p><h1 id="5a7e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h1><p id="987e" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这篇文章中的以下步骤需要Golang的经验。使用Cloudinary的经验不是必需的，但是拥有它是很好的。<br/>我们还需要以下物品:</p><ul class=""><li id="3511" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">用于存储媒体文件的<a class="ae js" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank">云账户</a>。<a class="ae js" href="https://cloudinary.com/users/register/free" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">报名</strong> </a> <strong class="iw hj">完全免费</strong>。</li><li id="5e44" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或者你选择的任何API测试应用。</li></ul><h1 id="d2bb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让我们编码</h1><h2 id="ac3e" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">入门指南</h2><p id="8ffe" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行以下命令:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="7aef" class="lk ju hi md b fi mh mi l mj mk">mkdir gin-cloudinary-api &amp;&amp; cd gin-cloudinary-api</span></pre><p id="3278" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该命令创建一个<code class="du ml mm mn md b">gin-cloudinary-api</code>文件夹，并导航到项目目录。</p><p id="b832" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们需要通过运行以下命令来初始化Go模块以管理项目依赖关系:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="3a6e" class="lk ju hi md b fi mh mi l mj mk">go mod init gin-cloudinary-api</span></pre><p id="ca52" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该命令将创建一个<code class="du ml mm mn md b">go.mod</code>文件，用于跟踪项目依赖关系。</p><p id="266a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们继续安装所需的依赖项:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="1082" class="lk ju hi md b fi mh mi l mj mk">go get -u github.com/gin-gonic/gin github.com/cloudinary/cloudinary-go github.com/joho/godotenv github.com/go-playground/validator/v10</span></pre><p id="e607" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">github.com/gin-gonic/gin</code>是一个用于构建web应用程序的框架。</p><p id="f39a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">github.com/cloudinary/cloudinary-go</code>是集成Cloudinary的库。</p><p id="5be0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">github.com/joho/godotenv</code>是一个管理环境变量的库。</p><p id="072e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">github.com/go-playground/validator/v10</code>是一个用于验证结构和字段的库。</p><h1 id="bea8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">应用程序入口点</h1><p id="5b1f" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">安装好项目依赖项后，我们需要在根目录下创建<code class="du ml mm mn md b">main.go</code>文件，并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="0cae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="ff9b" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="985a" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">Default</code>配置初始化Gin路由器。<code class="du ml mm mn md b">Default</code>函数用默认中间件(日志和恢复)配置Gin路由器。</li><li id="4686" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">Get</code>函数路由到<code class="du ml mm mn md b">/</code>路径和一个返回<code class="du ml mm mn md b">Hello from Cloudinary</code>的JSON的处理函数。</li><li id="f140" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">Run</code>函数将<code class="du ml mm mn md b">router</code>附加到一个<strong class="iw hj"> http。服务器</strong>并开始监听和服务<code class="du ml mm mn md b">localhost:6000</code>上的HTTP请求。</li></ul><p id="2e2c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们可以通过在终端中运行下面的命令来启动开发服务器，从而测试我们的应用程序。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="e6b8" class="lk ju hi md b fi mh mi l mj mk">go run main.go</span></pre><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/d6820cb98bbc873016f9ff02bc3188ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fKeRWbt8WfqJcRyX.png"/></div></div></figure><h1 id="eb68" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Golang的模块化</h1><p id="df2c" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">对于我们的项目来说，有一个好的文件夹结构是很重要的。良好的项目结构简化了我们在应用程序中处理依赖关系的方式，并使我们和其他人更容易阅读我们的代码库。</p><p id="6ccc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为此，我们需要在我们的项目目录中创建<code class="du ml mm mn md b">configs</code>、<code class="du ml mm mn md b">services</code>、<code class="du ml mm mn md b">controllers</code>、<code class="du ml mm mn md b">helper</code>、<code class="du ml mm mn md b">models</code>和<code class="du ml mm mn md b">dtos</code>文件夹。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/615b380d81c5dc2bc9699dd6f4878497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*4ZZbdSSjSI9xHlN9.png"/></div></figure><p id="d8a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">PS</strong>:<em class="ms"/><code class="du ml mm mn md b"><em class="ms">go.sum</em></code><em class="ms">文件包含所有依赖校验和，由go工具管理。我们不必为此担心。</em></p><p id="b565" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">configs</code>用于模块化项目配置文件</p><p id="c599" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">services</code>用于模块化应用逻辑。它有助于保持控制器的清洁。</p><p id="36a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">controllers</code>用于模块化应用传入请求并返回响应。</p><p id="2dd4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">helper</code>用于模块化用于执行另一个文件的计算的文件。</p><p id="1b35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">models</code>用于模块化数据和数据库逻辑。</p><p id="f836" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">dtos</code>用于模块化文件，描述我们希望API给出的响应。这一点以后会变得更加清楚。<br/> <a class="ae js" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> <em class="ms">数据传输对象(DTO) </em> </a> <em class="ms">简单来说就是将数据从一点传输到另一点的对象。</em></p><h1 id="2fb8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置云阵列</h1><p id="efc3" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">完成后，我们需要登录或注册我们的<a class="ae js" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>账户，以获取我们的<strong class="iw hj">云名称</strong>、<strong class="iw hj"> API密钥</strong>和<strong class="iw hj"> API秘密</strong>。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/dbdfa2f66ee7f9a379f70acaa38eb3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j6VZhr9iSYSsSRkX.png"/></div></div></figure><p id="9b05" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们需要创建一个文件夹来存储我们的媒体上传。为此，导航到<strong class="iw hj">媒体库</strong>选项卡，点击<strong class="iw hj">添加文件夹</strong>图标，输入<code class="du ml mm mn md b">go-cloudinary</code>作为文件夹名称，然后<strong class="iw hj">保存</strong>。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/431830badb36c64457e6c179fdb17d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ftqvPB2HkukLZd1.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/195fef15ca84c1d5f7ff5a8050a76647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IYpf5d6NvDUctHkh.png"/></div></div></figure><p id="d7b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">设置环境变量<br/> </strong>接下来，我们需要将仪表板中的参数包含到环境变量中。为此，首先，我们需要在根目录下创建一个<code class="du ml mm mn md b">.env</code>文件，并在这个文件中添加下面的代码片段:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="9587" class="lk ju hi md b fi mh mi l mj mk">CLOUDINARY_CLOUD_NAME=&lt;YOUR CLOUD NAME HERE&gt;<br/>CLOUDINARY_API_KEY=&lt;YOUR API KEY HERE&gt;<br/>CLOUDINARY_API_SECRET=&lt;YOUR API SECRET HERE&gt;<br/>CLOUDINARY_UPLOAD_FOLDER=go-cloudinary</span></pre><p id="0d83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">加载环境变量<br/> </strong>完成后，我们需要使用我们之前安装的<code class="du ml mm mn md b">github.com/joho/godotenv</code>库创建助手函数来加载环境变量。为此，我们需要导航到<code class="du ml mm mn md b">configs</code>文件夹，在这个文件夹中，创建一个<code class="du ml mm mn md b">env.go</code>文件，并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="152f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="a99c" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="ee1b" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">EnvCloudName</code>、<code class="du ml mm mn md b">EnvCloudAPIKey</code>、<code class="du ml mm mn md b">EnvCloudAPISecret</code>、<code class="du ml mm mn md b">EnvCloudUploadFolder</code>函数，检查环境变量是否正确加载并返回环境变量。</li></ul><p id="1804" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Cloudinary helper函数<br/> </strong>为了方便从我们的应用程序进行远程和本地上传，我们需要导航到<code class="du ml mm mn md b">helper</code>文件夹，并在该文件夹中创建一个<code class="du ml mm mn md b">media_helper.go</code>文件并添加以下代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="069f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="db90" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="32e6" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">ImageUploadHelper</code>函数，它首先将一个<code class="du ml mm mn md b">interface</code>作为参数，并返回远程URL或错误(如果有的话)。<code class="du ml mm mn md b">interface</code>通过接受<strong class="iw hj">远程URL</strong>和<strong class="iw hj">表单文件</strong>使我们的代码可重用。该函数还执行以下操作:<br/> -定义了连接到Cloudinary时的10秒超时。<br/> -通过传入<strong class="iw hj">云名称</strong>、<strong class="iw hj"> API密钥</strong>和<strong class="iw hj"> API秘密</strong>作为参数，并检查是否有错误，初始化一个新的Cloudinary实例。<br/>-使用<code class="du ml mm mn md b">Upload</code>功能上传媒体，并使用<code class="du ml mm mn md b">EnvCloudUploadFolder</code>功能指定存储媒体的文件夹。获取上传结果和错误(如果有)。<br/> -当没有错误时，返回媒体安全URL和<code class="du ml mm mn md b">nil</code>。</li></ul><h1 id="96e4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置模型和响应类型</h1><p id="65a7" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated"><strong class="iw hj">模型<br/> </strong>接下来，我们需要一个模型来表示我们的应用数据。为此，我们需要导航到<code class="du ml mm mn md b">models</code>文件夹，在这个文件夹中，创建一个<code class="du ml mm mn md b">media_model.go</code>文件并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="26f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="d330" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="6ddf" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个具有本地文件上传和远程URL上传所需属性的<code class="du ml mm mn md b">File</code>和<code class="du ml mm mn md b">Url</code>结构。</li></ul><p id="f5fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">响应类型<br/> </strong>接下来，我们需要创建一个可重用的<code class="du ml mm mn md b">struct</code>来描述我们的API的响应。为此，导航到<code class="du ml mm mn md b">dtos</code>文件夹，在该文件夹中创建一个<code class="du ml mm mn md b">media_dto.go</code>文件，并添加以下代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="cd4b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段创建了一个具有<code class="du ml mm mn md b">StatusCode</code>、<code class="du ml mm mn md b">Message</code>和<code class="du ml mm mn md b">Data</code>属性的<code class="du ml mm mn md b">MediaDto</code>结构来表示API响应类型。</p><h1 id="7a8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后，创建REST API</h1><p id="8e8d" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">完成后，我们需要创建一个<strong class="iw hj">服务</strong>来托管所有的媒体上传应用逻辑。为此，导航到<code class="du ml mm mn md b">services</code>文件夹，在该文件夹中创建一个<code class="du ml mm mn md b">media_service.go</code>文件，并添加以下代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="df2e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="117f" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="919a" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用我们之前安装的<code class="du ml mm mn md b">github.com/go-playground/validator/v10</code>库创建一个<code class="du ml mm mn md b">validate</code>变量来验证模型。</li><li id="6595" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">mediaUpload</code>接口，用方法描述我们想要做的上传类型。</li><li id="ed29" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个将实现<code class="du ml mm mn md b">mediaUpload</code>接口的<code class="du ml mm mn md b">media</code>结构。</li><li id="92bd" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个<code class="du ml mm mn md b">NewMediaUpload</code>构造函数，将<code class="du ml mm mn md b">media</code>结构和它实现的<code class="du ml mm mn md b">mediaUpload</code>接口联系起来。</li><li id="09c7" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">使用<code class="du ml mm mn md b">media</code>指针接收器创建所需的方法<code class="du ml mm mn md b">FileUpload</code>和<code class="du ml mm mn md b">RemoteUpload</code>，并返回URL或错误(如果有)。所需的方法还验证来自用户的输入，并使用我们之前创建的<code class="du ml mm mn md b">ImageUploadHelper</code>函数将媒体上传到Cloudinary。</li></ul><p id="7889" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">文件上传端点<br/> </strong>通过服务设置，我们现在可以创建一个从本地文件存储器上传媒体的功能。为此，我们需要导航到<code class="du ml mm mn md b">controllers</code>文件夹，在该文件夹中，创建一个<code class="du ml mm mn md b">media_controller.go</code>文件并添加下面的代码片段:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="be0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="4b96" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">导入所需的依赖项。</li><li id="4d1c" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">创建一个返回Gin-gonic处理程序的<code class="du ml mm mn md b">FileUpload</code>函数。在返回的处理程序中，我们首先使用<code class="du ml mm mn md b">Request.FormFile</code>函数从请求体中检索<code class="du ml mm mn md b">formFile</code>对象。我们使用之前创建的<code class="du ml mm mn md b">MediaDto</code>结构返回了适当的消息和状态代码。其次，我们使用<code class="du ml mm mn md b">NewMediaUpload</code>构造函数通过传递<code class="du ml mm mn md b">formFile</code>作为参数来访问<code class="du ml mm mn md b">FileUpload</code>服务。该服务还返回上传媒体的URL或错误(如果有的话)。最后，如果媒体上传成功，我们将返回正确的响应。</li></ul><p id="0075" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">远程URL上传端点<br/> </strong>要从远程URL上传图片，我们需要修改<code class="du ml mm mn md b">media_controller.go</code>如下所示:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="b980" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ml mm mn md b">RemoteUpload</code>功能与<code class="du ml mm mn md b">FileUpload</code>功能的作用相同。然而，我们创建了<code class="du ml mm mn md b">url</code>变量，并使用Gin-gonic的<code class="du ml mm mn md b">BindJSON</code>方法对其进行了验证。我们还将变量作为参数传递给<code class="du ml mm mn md b">RemoteUpload</code>服务，并返回适当的响应。</p><p id="5e8b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">完成媒体_控制器. go </strong></p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="361f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">将所有这些放在一起<br/> </strong>完成后，我们需要为我们的端点创建一个从本地文件存储和远程URL上传媒体的路由。为此，我们需要用控制器修改<code class="du ml mm mn md b">main.go</code>,并指定相对路径，如下所示:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="27d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成后，我们可以通过在终端中运行下面的命令启动开发服务器来测试我们的应用程序。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="1426" class="lk ju hi md b fi mh mi l mj mk">go run main.go</span></pre><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/39cd602eed7e169c7f3240a0f19d1304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YxjC1_1ZXT9SD14U.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/082d5ee3843b6672b08fa734fb185b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rqluvp63qAWuu70A.png"/></div></div></figure><p id="88ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上传完成后，我们可以查看Cloudinary上的<code class="du ml mm mn md b">go-cloudinary</code>文件夹，查看上传的媒体文件。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/3fdb329873ec98b1aabe5c55be21a748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AHmayrwtSDu0LZtt.png"/></div></div></figure><h1 id="4423" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="0e0b" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这篇文章讨论了如何构建Gin-gonic应用程序，如何将Cloudinary与Golang集成，以及如何使用远程URL和本地文件存储将媒体文件上传到Cloudinary。</p><p id="e946" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可能会发现这些资源很有帮助:</p><ul class=""><li id="54b4" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated"><a class="ae js" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank">金角</a></li><li id="36d8" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://cloudinary.com/documentation/go_integration" rel="noopener ugc nofollow" target="_blank"> Cloudinary Go SDK </a></li><li id="c4f0" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><a class="ae js" href="https://go.dev/tour/methods/4" rel="noopener ugc nofollow" target="_blank"> Go指针接收器</a>。</li></ul></div></div>    
</body>
</html>
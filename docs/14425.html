<html>
<head>
<title>Angular: Replacing setTimeout() and setInterval() with RXJS Timer and Delay operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:用RXJS计时器和延迟运算符替换setTimeout()和setInterval()</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/angular-replacing-settimeout-and-setinterval-with-rxjs-timer-and-delay-operators-cf291b1cdadd?source=collection_archive---------2-----------------------#2022-09-01">https://medium.com/geekculture/angular-replacing-settimeout-and-setinterval-with-rxjs-timer-and-delay-operators-cf291b1cdadd?source=collection_archive---------2-----------------------#2022-09-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e42d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> setTimeout()和setInterval() </strong>非常好用。但是RXJS提供了两个操作符，可以使用可观察的方法做完全相同的工作。如果你是一个喜欢用可观察的方法完成任务的开发人员，那么这个故事可能对你有用。</p><p id="0361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个非常简单的例子，RXJS中的<strong class="ih hj">延迟和定时器操作符</strong>如何以两种方式提供帮助:</p><p id="efcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在执行某项任务之前制造延迟。</p><p id="ccdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在任务1完成后和任务2开始前创建延迟。</p><p id="0cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我用简单的语言简单介绍一下这些运算符是如何工作的:</p><ol class=""><li id="75a6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> delay(x) </strong>是指被观测者要发射的所有物品都要经过<strong class="ih hj"> x ms </strong>的延迟后才会发射。<strong class="ih hj">请注意，所有项目将在延迟后同时发出。两次连续发射之间没有延迟。</strong></li><li id="f313" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">定时器操作符有两种使用方式:</li></ol><p id="767e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj"> timer(x) </strong>表示<strong class="ih hj">所有由可观察对象发出的项目</strong>只有在延迟<strong class="ih hj"> x ms后才会发出</strong>这里timer的工作方式与延迟算子完全相同。</p><p id="8d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">=&gt; <strong class="ih hj"> timer(x，y) </strong>表示被观测者发射的<strong class="ih hj">第一项</strong>将在<strong class="ih hj"> x ms </strong>后发射，剩余的<strong class="ih hj">项</strong>将在发射间隔<strong class="ih hj"> y ms </strong>后发射。</p><p id="2d89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些人更喜欢将x设置为0 ms，这样第一个项目立即发射，其余项目在发射之间有y ms的延迟。</p><p id="e2c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从例子开始。我们只有三个按钮来实现我们的目标。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/19664d787eba9ec6e224610aa221580c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T66rRV3gBUozKh3CiOAoOw.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx">Timer and Delay Application</figcaption></figure><p id="50e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用延迟操作符</strong>按钮延迟一段时间后执行任务。我们使用<strong class="ih hj">延迟操作符</strong>来演示这一点。</p><p id="d74e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用定时器操作器</strong>按钮延迟一段时间后执行任务，几毫秒后再次执行任务。我们使用<strong class="ih hj">定时器操作器</strong>来演示这一点。</p><p id="5aa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在两个任务之间创建延迟</strong>按钮将多次执行一个任务，但每次执行之间会有延迟。这里我们将再次使用<strong class="ih hj">定时器操作器</strong>。</p><p id="1a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能想知道，<strong class="ih hj">测试延迟创建</strong>按钮是干什么的？点击按钮只是导航到<strong class="ih hj"> /delay </strong>路径来加载组件，上面列出了我们的3个按钮。因为我们已经在这条路上，所以<strong class="ih hj">测试延迟创建</strong>按钮的目的已经完成。</p><p id="0ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件模板:</strong>这正是我们在截图中看到的。<strong class="ih hj"> task1() </strong>、<strong class="ih hj"> task2() </strong>和<strong class="ih hj"> task3() </strong>是这个类中的方法，它们演示了我们如何准确地使用延迟和定时器操作符来达到我们的目的。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="7cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组件类</strong></p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="9b62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">I .从<strong class="ih hj">延迟操作符开始，下面的createDelayUsingDelay() </strong>用于返回延迟操作符创建的可观察值。我们还记录了操作符将执行并创建延迟值<strong class="ih hj"> delayValue(毫秒)的时间戳。</strong></p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="63a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用延迟操作符按钮延迟后点击<strong class="ih hj">执行任务将调用<strong class="ih hj"> task1()。</strong></strong></p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="0de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;我们首先使用操作符<strong class="ih hj">从数组[1，5，7，9]中创建了一个cold observable。</strong>数组中的数字对应于4个用户的userId，一旦延迟完成，我们将获取其数据。</p><p id="4872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在管道操作符内部，我们又链接了3个操作符。</p><ol class=""><li id="ffda" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先，我们调用<strong class="ih hj">createDelayUsingDelay()</strong>来创建一个5秒的延迟。<strong class="ih hj">延时操作器</strong>也可以直接加在<strong class="ih hj">管操作器</strong>内，而不是单独的方法。在一个单独的方法中添加<strong class="ih hj">延迟操作符</strong>的目的是展示如何使用它来创建动态延迟。</li><li id="abe0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">一旦5秒的延迟结束，<strong class="ih hj"> tap操作符</strong>执行日志中延迟结束的时间戳，获取用户数据的任务将开始。</li><li id="3abe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，我们使用了<strong class="ih hj"> mergeMap运算符</strong>来并行获取4个用户的数据。</li></ol><p id="ad43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;最后，我们已经从操作符订阅了由<strong class="ih hj">创建的外部可观察对象，以执行可观察对象。</strong></p><p id="04a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我点击<strong class="ih hj">执行任务后，使用延迟操作符</strong>按钮进行延迟，下面是控制台日志。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/b6fc3f3e2cb2335a98fadbdfe0d505fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ_cP2QlLSnE23w34okNuw.png"/></div></div></figure><p id="31f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意延迟操作符执行的时间戳。现在是<strong class="ih hj"> 14:08:02。</strong>准确地说，5秒钟后，<strong class="ih hj"> tap操作符</strong>在<strong class="ih hj">管道操作符</strong>中记录时间戳<strong class="ih hj"> 14:08:07 </strong>，获取用户数据的任务将在该时间开始。</p><p id="5ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意的是，<strong class="ih hj"> tap操作符</strong>已经对由<strong class="ih hj"> from操作符创建的可观察值发出的4个值执行了4次。</strong></p><p id="b9f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二。接下来，我们将移动到<strong class="ih hj">定时器操作符</strong>，在获取4个用户的数据之前创建一个类似的延迟。</p><p id="bab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> createDelayUsingTimer() </strong>将返回一个使用<strong class="ih hj">计时器操作符</strong>创建的可观察值。此处的可观察对象将仅发出1值，即延迟后的0，可观察对象将完成。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="ef24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用定时器操作器按钮延迟后点击<strong class="ih hj">执行任务，我们执行下面定义的<strong class="ih hj"> task2()，</strong>。</strong></p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="787d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;这里我们首先调用<strong class="ih hj"> createDelayUsingTimer() </strong>来创建一个5秒的延迟。</p><p id="efb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在管道操作符中，我们又链接了3个操作符。</p><ol class=""><li id="4f12" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">5秒延迟完成后，<strong class="ih hj"> tap操作符</strong>执行以记录获取用户数据任务开始的时间戳。</li><li id="6456" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> mergeMap运算符</strong>是用于避免嵌套订阅的扁平化运算符。传递给<strong class="ih hj"> mergeMap </strong>的<strong class="ih hj">参数x </strong>只不过是由<strong class="ih hj">定时器操作符</strong>创建的外部可观察对象发出的值。参数x包含值0。mergeMap 操作符期望返回一个内部可观测值。</li></ol><pre class="js jt ju jv fd kj kk kl km aw kn bi"><span id="e8ec" class="ko kp hi kk b fi kq kr l ks kt">mergeMap((x) =&gt; {<br/><strong class="kk hj">return from([1, 5, 7, 9]).pipe(<br/>mergeMap((y) =&gt; this.service.getUser(y))<br/>);</strong><br/>})</span></pre><p id="ad7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经使用来自操作符的<strong class="ih hj">将4个用户Id的数组转换为一个冷可观察值。我们已经用<strong class="ih hj">管道将另一个mergeMap </strong>传输到这个cold observable，以并行获取对应于这4个用户id的数据。</strong></p><p id="d6f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;最后，我们已经订阅了由<strong class="ih hj">定时器操作符</strong>创建的外部可观察对象来执行该可观察对象。</p><p id="939e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在浏览器中，单击按钮将在控制台中产生以下结果。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ku"><img src="../Images/f844d30b3cdc54d1f5ef5ddba5e517e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJQo2OLWEQT8KOtf0SWk0Q.png"/></div></div></figure><p id="17d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意计时器操作符执行的时间戳。现在是<strong class="ih hj"> 14:50:55。</strong>准确地说，5秒钟后，<strong class="ih hj"> tap操作符</strong>在<strong class="ih hj">管道操作符</strong>中记录时间戳<strong class="ih hj"> 14:51:00 </strong>，在该时间获取用户数据的任务将开始。</p><p id="fe5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">三。最后，我们将使用<strong class="ih hj">定时器操作符</strong>来演示它如何模仿<strong class="ih hj"> setInterval()。</strong></p><p id="b93d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">createIntervalUsingTimer()</strong>返回一个由<strong class="ih hj">计时器操作符</strong>创建的可观察值。<strong class="ih hj">定时器操作符</strong>接受2个参数。第一个参数<strong class="ih hj"> delayValue1 </strong>表示时间(单位为ms ),在此之后，第一个值(即0)将由可观察对象发出。接下来将有一个<strong class="ih hj">延迟值2 </strong> ms的间隙，之后将发出第二个值，即1。其余值将遵循类似的模式，即发射之间的<strong class="ih hj">延迟值2 </strong>毫秒间隙。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="45e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击<strong class="ih hj">创建两个任务之间的延迟</strong>按钮，将调用<strong class="ih hj"> task3() </strong>。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="ff5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;首先调用<strong class="ih hj">createIntervalUsingTimer()</strong>，这将从<strong class="ih hj">计时器操作符</strong>创建一个可观察值。这个可观测的将在2秒后发射0。在发射1之前，它将等待5秒。它将再次等待5秒，然后发射2次，依此类推。每当可观察对象发出一个值，我们就调用<strong class="ih hj">数据服务</strong>中的方法<strong class="ih hj"> checkStatus() </strong>，它在执行时会简单地记录一条消息。这是我们正在执行的任务。</p><p id="ac2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;在管道操作符中，我们链接了多个操作符。</p><ol class=""><li id="9ab0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> take(5) </strong>确保我们只想从由<strong class="ih hj">定时器操作符</strong>创建的可观察对象中发出5个数字，之后可观察对象必须完成。原因是当第二个参数被提供给timer操作符时，它无限地发出数字。所以我们需要在某个地方结束它。</li><li id="3673" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们使用<strong class="ih hj"> tap操作符</strong>来指示延迟结束和任务执行的时间戳。</li><li id="2c23" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，我们有另一个tap操作符来执行任务，即调用<strong class="ih hj"> DataService中的<strong class="ih hj"> checkStatus() </strong>。</strong></li></ol><p id="579e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= &gt;最后，我们已经订阅了由<strong class="ih hj">定时器操作符</strong>创建的外部可观察对象来执行该可观察对象。</p><p id="99d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在浏览器中，单击按钮将在控制台中产生以下结果。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/4c66512ed1c9853d989eae772caa22a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPjNB4jd9i05dPN3vZFKGw.png"/></div></div></figure><p id="8775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<strong class="ih hj"> 16:56:33 </strong>开始延时2秒。延迟完成，observable发出0，在<strong class="ih hj"> 16:56:35调用<strong class="ih hj"> checkStatus() </strong>。</strong>我们还记录了使用计时器操作符创建的可观察值发出的值，即0、1、2、3和4。</p><p id="4acc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次调用checkStatus()时，我们都会记录<strong class="ih hj">“检查状态”</strong>。</p><p id="d6ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，有一个5秒的间隙，在此之后，可观察对象发出1，并且<strong class="ih hj"> checkStatus() </strong>在<strong class="ih hj"> 16:56:40 </strong>再次执行，以此类推<strong class="ih hj">。</strong></p><p id="6b64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的工作示例如下:</p><div class="kv kw ez fb kx ky"><a href="https://stackblitz.com/edit/angular-xz9s9x?file=src/app/create-delay/create-delay.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">角形(叉形)堆叠</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">stackblitz.com</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm kb ky"/></div></div></a></div></div></div>    
</body>
</html>
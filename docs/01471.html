<html>
<head>
<title>Concurrency and Threads: Real Life Examples — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发和线程:现实生活中的例子—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/concurrency-and-threads-part-2-51ddef68e364?source=collection_archive---------15-----------------------#2021-04-11">https://medium.com/geekculture/concurrency-and-threads-part-2-51ddef68e364?source=collection_archive---------15-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ed71b70acb4656f40525bf56a18b1db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*imnWL2l7FpzWW98j7gNQaA.gif"/></div></div></figure><div class=""/><p id="f267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">之前，</strong>您看到了多线程系统如何带来复杂性，以及我们如何使用同步来解决这个问题。现在让我们看看线程是如何相互通信的。</p><p id="6640" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我建议那些还没有看过《T2》第一部的人，请浏览一遍，毫无悬念地理解接下来的故事。</p><p id="74fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这些是我们上次学过的关键概念。</p><ol class=""><li id="1505" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hu">共享变量:</strong>被多个线程共享的变量。</li><li id="0d9b" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">临界区:</strong>一段代码，包含一个被多个线程访问的共享变量</li><li id="7c24" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">竞态条件:</strong>我们不知道某个临界段上发生的共享变量的最终值的情况。</li><li id="3325" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">同步:</strong>对竞争情况的解决方案，让一个线程一次运行一个临界区。</li></ol></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="0f3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要理解的一个要点是，只有当不止一个线程更新共享变量时，才会出现与临界区或竞争条件相关的问题。问题不在于多线程读取，而在于多线程写入。</p><p id="268a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，如果我们以某种方式限制对特定对象的更新，我们只返回共享变量的更新副本，而不更新原始副本，会怎么样呢？</p><p id="e83d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是<strong class="is hu">不变性</strong>，这就是<strong class="is hu"> </strong>我们如何简单地实现它。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="7f67" class="kt ku ht kp b fi kv kw l kx ky">public class ImmutableValue {</span><span id="ef6a" class="kt ku ht kp b fi kz kw l kx ky">private int value = 0;</span><span id="ea84" class="kt ku ht kp b fi kz kw l kx ky">public ImmutableValue(int value){<br/>    this.value = value;<br/>  }</span><span id="58fa" class="kt ku ht kp b fi kz kw l kx ky">public int getValue(){<br/>    return this.value;<br/>  }</span><span id="94ea" class="kt ku ht kp b fi kz kw l kx ky">public ImmutableValue add(int valueToAdd){<strong class="kp hu"><br/>    </strong>return new ImmutableValue(this.value + valueToAdd);<strong class="kp hu"><br/>  </strong>}<strong class="kp hu"><br/>  </strong><br/>}</span></pre><p id="851c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果任何线程在这个对象上调用add方法，它不会更新内部变量“value ”,但会用更新后的值获得一个新的不可变对象。所以每个线程都有自己的更新变量副本。</p><p id="ed03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想知道这个什么时候会更新。我想，如果有任何安全的手动过程来更新这个变量，那么我们就可以毫不犹豫地把它作为一个共享变量来使用。</p><h1 id="c591" class="la ku ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我相信我们正在使用的git分支策略就是一个典型的例子。</h1><p id="cce5" class="pw-post-body-paragraph iq ir ht is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">策略是我们从主分支中提取一个特性分支，并且从不直接更新主分支，而是通过一个批准过程。</p><p id="3b3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以它的伪代码看起来就像这样。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="d030" class="kt ku ht kp b fi kv kw l kx ky">public class MasterBranch extends Branch{</span><span id="7c44" class="kt ku ht kp b fi kz kw l kx ky">private Code code ;</span><span id="32ce" class="kt ku ht kp b fi kz kw l kx ky">// Initial setup of the branch<br/> public MasterBranch(Code code){<br/>    <br/>    if(this.code != null){<br/>        this.code = code;<br/>    }else{<br/>        throw new Exception("Master branch is already set up")<br/>    }<br/> }</span><span id="f8c4" class="kt ku ht kp b fi kz kw l kx ky">public Code getCode() throws Exception {<br/>     throw new Exception("Operation not supported");<br/> }</span><span id="f085" class="kt ku ht kp b fi kz kw l kx ky">// git checkout -b "feature/super-cool-feature"<br/> public Branch createBranch() {<br/>     Code code = code.clone(); // Deep clone<br/>     return new Branch(code);<br/> }</span><span id="82f9" class="kt ku ht kp b fi kz kw l kx ky">// git merge feature/super-cool-feature<strong class="kp hu"><br/> </strong>public void merge(Branch featureBranch) throws CodeError {<strong class="kp hu"><br/>    <br/>    </strong>if(featureBranch.isApproved()){<br/>        this.code.merge(featureBranch.getCode());<br/>    } else {<br/>        throw new CodeError("");<br/>    }<strong class="kp hu"><br/>    <br/> </strong>}<strong class="kp hu"><br/>  </strong><br/>}</span></pre><p id="b457" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您会注意到这里主分支的代码对象从不更新，除非有人批准了特性分支。</p><p id="2806" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个批准过程应该负责多个分支更新主分支<strong class="is hu">一次一个</strong>。</p><p id="b1bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人们一定已经意识到这个批准过程是多么的忙乱，就像等待你的朋友批准你的请求，而他正在审查其他一些拉动式请求。</p><p id="b470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">终于轮到你了。然后他说<em class="mc">‘伙计，我看到你的公关和罗宾的有冲突了</em></p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es md"><img src="../Images/4f192b0fe0a4a68fa05e75d4eee1f3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*VGrWv9L9QePlZDSK_efuAw.png"/></div><figcaption class="me mf et er es mg mh bd b be z dx"><a class="ae jo" href="https://imgflip.com/i/3tl76e" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/i/3tl76e</a></figcaption></figure><p id="e30c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哎呀，就是这样。即使是一个男人也有这么多复杂的事情。想象一下，当我们实现自动化时会发生什么？</p><p id="6957" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请想一想，如果罗宾在这里告诉蝙蝠侠他正在开发相同的代码库会怎么样。我们绝对可以挽回一巴掌。</p><p id="6f07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">同样，如果两个线程开始相互通信会怎么样。</strong></p><p id="cb5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">交流线程。哇，真有趣。</strong></p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mi"><img src="../Images/857b64aa1cc3a33ca8c24fc818ac77b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*HY_zHCov1mmmanop86lpXA.png"/></div></figure><p id="1ae9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">是啊，你听到莱斯利。我们可以只用一个共享变量。</strong></p><p id="672e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那就让我们开始吧。下面是另一个插图，可以更好地理解这个沟通过程。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="966d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑两列火车A和b的假设情况。它们在晚上10点到达同一个车站，另一列在晚上10点10分钟后到达。</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mj"><img src="../Images/5e81ce236b62e5e04b2b79eb2e7c9cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*KxtsEbA_K2RjJnL0ia1fFg.png"/></div></figure><p id="483b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设A列车在车站平均停留5分钟，然后B列车经过车站。这是一个简短的模拟代码，其中每个训练就像一个线程。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="636f" class="kt ku ht kp b fi kv kw l kx ky">public class Signal {<br/>     public boolean trainAPassed;<br/>}</span><span id="64d9" class="kt ku ht kp b fi kz kw l kx ky">class TrainA extends Threads {</span><span id="404c" class="kt ku ht kp b fi kz kw l kx ky"> private Signal signal;</span><span id="49e2" class="kt ku ht kp b fi kz kw l kx ky"> public TrainA(Signal signal){<br/>     <br/>    this.signal = signal;<br/>    System.out.println("Train A : Run Engine");</span><span id="0513" class="kt ku ht kp b fi kz kw l kx ky"> }<br/>      <br/> <a class="ae jo" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/> public void run() {</span><span id="8748" class="kt ku ht kp b fi kz kw l kx ky">    System.out.println("Train A : Pass from the station");</span><span id="323d" class="kt ku ht kp b fi kz kw l kx ky">    // Waiting time at the station        <br/>    Thread.sleep(5*60*1000);</span><span id="6f1b" class="kt ku ht kp b fi kz kw l kx ky">    System.out.println("Train A : Passed from the station");<br/>    Signal.trainAPassed = true;<br/> }</span><span id="10ec" class="kt ku ht kp b fi kz kw l kx ky">}</span><span id="4a27" class="kt ku ht kp b fi kz kw l kx ky">class TrainB extends Threads {</span><span id="83a3" class="kt ku ht kp b fi kz kw l kx ky"> private Signal signal;</span><span id="8464" class="kt ku ht kp b fi kz kw l kx ky"> public TrainB(Signal signal){<br/>     this.signal = signal;<br/>     System.out.println("Train B : Run Engine");<br/> }<br/>      <br/> <a class="ae jo" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/> public void run() {</span><span id="1e11" class="kt ku ht kp b fi kz kw l kx ky">  // Wait while the train A is not passed         <br/>     while(!Signal.trainAPassed){<br/>         System.out.println("Waiting for train A to be passed");<br/>     }</span><span id="a447" class="kt ku ht kp b fi kz kw l kx ky">     System.out.println("Train B : Pass from the station");<br/>     System.out.println("Train B : Passed from the station");<br/> }</span><span id="64da" class="kt ku ht kp b fi kz kw l kx ky">}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="c522" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在假设火车A到达车站有点晚，比如说在晚上10:09，但是火车B是准时的。在这种情况下会发生什么？</p><p id="0deb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">B列车需要等到晚上10:14才能进站对吧。<strong class="is hu">站前4分钟的停顿。</strong></p><p id="5fd7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您启动线程，您肯定会看到这条消息，</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="5f2c" class="kt ku ht kp b fi kv kw l kx ky">"Waiting for train A to be passed"</span></pre><p id="d8e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重复4分钟。</p><p id="abc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着Train-B即使在无事可做时也继续运行它的引擎，仍然白白地消耗电力，<strong class="is hu">换句话说对于一个线程来说，消耗CPU时间</strong>。</p><p id="861b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住每一个运行的线程都会消耗CPU的一些时间，即使它除了打印什么也不做。</p><p id="a90c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这绝对是一个糟糕的设计，用专业术语来说叫做<strong class="is hu">忙着等待</strong>。为什么列车B必须保持发动机运转，而列车A却没有通过？对！</p><p id="e2f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们能不能不要让Train-B/Thread-B处于一种不占用CPU时间，仍然不会死的状态。一个线程有这样的状态吗？</p><p id="e160" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，有这样的状态。它被称为<strong class="is hu">等待状态</strong>。</p><p id="7ecd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java和许多其他语言提供了将线程置于这种状态的方法。</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mk"><img src="../Images/2039e8cbaabc4b35bbd763a086b8d744.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*2SWHFep3e-gZaxlbVsO6EA.png"/></div></figure><p id="85f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一篇很好的<a class="ae jo" href="https://javaconceptoftheday.com/thread-life-cycle-thread-states-java/" rel="noopener ugc nofollow" target="_blank">文章</a>，列出了我们可以实现的所有线程状态。</p><p id="cc07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是上一篇文章中的图像，显示了一个线程可能达到的所有状态。</p><p id="12bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以代码会变成这样</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="b6f0" class="kt ku ht kp b fi kv kw l kx ky">class TrainA extends Threads {</span><span id="af62" class="kt ku ht kp b fi kz kw l kx ky">....<br/>....<br/>....</span><span id="1cdd" class="kt ku ht kp b fi kz kw l kx ky"><a class="ae jo" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>public void run() {</span><span id="b489" class="kt ku ht kp b fi kz kw l kx ky">   System.out.println("TrainA : Pass from the station");</span><span id="6296" class="kt ku ht kp b fi kz kw l kx ky">   Thread.sleep(5*60*1000);</span><span id="843d" class="kt ku ht kp b fi kz kw l kx ky">   System.out.println("TrainA : Passed from the station");<br/>            <br/>   signal.notify();</span><span id="fd62" class="kt ku ht kp b fi kz kw l kx ky"> }<br/>}</span><span id="a088" class="kt ku ht kp b fi kz kw l kx ky">class TrainB extends Threads {</span><span id="1277" class="kt ku ht kp b fi kz kw l kx ky">  private Signal signal;</span><span id="761e" class="kt ku ht kp b fi kz kw l kx ky">  public TrainB(Signal signal){<br/>     this.signal = signal;<br/>     System.out.println("TrainB : Run Engine");</span><span id="5a1f" class="kt ku ht kp b fi kz kw l kx ky">  }<br/>      <br/>  <a class="ae jo" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>  public void run() {</span><span id="afa2" class="kt ku ht kp b fi kz kw l kx ky">    if(nearby_station){<br/>        System.out.println("Waiting for trainA to be passed");<br/>        signal.wait();<br/>    }</span><span id="1395" class="kt ku ht kp b fi kz kw l kx ky">    System.out.println("TrainB : Pass from the station");<br/>    Thread.sleep(5*60*1000);</span><span id="b5e9" class="kt ku ht kp b fi kz kw l kx ky">    System.out.println("TrainB : Passed from the station");<br/>  }<br/>}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="05b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">这里这个信号是什么？现在，让我们把它想象成当火车B呼叫signal.wait()时，它关闭它的引擎，当火车A呼叫signal.notify()时，粘在它末端的绿灯变得活跃，暗示火车B现在可以通过了。</strong></p><p id="4f2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，在3月28日晚上，火车A提前了10分钟，它在晚上9点50分到达车站，并在晚上10点离开。现在B列火车来了，等着A列火车过来经过，亮出它最喜欢的绿灯。</p><p id="8948" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但直到晚上10点15分才出现。</p><p id="100d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在列车B的乘务人员有两个选择</p><ol class=""><li id="4e65" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">再等等，听听愤怒的乘客。而他们甚至不知道自己需要等待多久。</li><li id="bc69" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">第二，向车站移动，考虑与列车A相撞的可能性。(<em class="mc">记住，由于</em> <strong class="is hu"> <em class="mc">急转弯</em> </strong>，列车A无法在车站检查其他列车)</li></ol><p id="484a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们所说的<strong class="is hu">错过信号！</strong></p><p id="1328" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，你会怎么做？</p><p id="3bb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正确替换信令算法。如果不是列车A显示通行灯本身，而是将此责任交给车站管理员。如果列车A已经通过，车站管理员会告诉列车B的工作人员继续前进。</p><p id="b715" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何在代码中处理这个问题？列车A是否已经通过的另一个标志。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="0128" class="kt ku ht kp b fi kv kw l kx ky">if(nearby_station &amp;&amp; !station_manager_green_flag_present){<br/>             System.out.println("Waiting for trainA to be passed");<br/>             signal.wait();<br/>}</span></pre><h1 id="66cc" class="la ku ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">所以他们做到了！</h1><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/03bd20428881d75d17fe25ff79da0ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*dslAEeUdV8bJ-www.gif"/></div><figcaption class="me mf et er es mg mh bd b be z dx"><a class="ae jo" href="https://data.whicdn.com/images/31887220/original.gif" rel="noopener ugc nofollow" target="_blank">https://data.whicdn.com/images/31887220/original.gif</a></figcaption></figure></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="1657" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在考虑另一个不幸的情况，忘记之前的情况，如果列车B的控制系统发生故障，在车站附近等待列车A通过时，它开始自动运行。</p><p id="ae62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">灾难没错！</strong></p><p id="57ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这相当于在JAVA线程管理系统中的<strong class="is hu">假唤醒</strong>期间可能出现的情况。</p><p id="38b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mc">这是什么意思？</em>T15】</strong></p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="ef41" class="kt ku ht kp b fi kv kw l kx ky">if(nearby_station &amp;&amp; !station_manager_green_flag_present){<br/>      System.out.println("Waiting for trainA to be passed");<br/>      signal.wait();<br/>}</span></pre><p id="39a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Train B的run方法上的这个<strong class="is hu"> signal.wait() </strong>指令应该在没有给它notify()信号时暂停Train B线程。但有时，在极少数情况下，它无法做到这一点。因此被称为虚假唤醒。</p><p id="35d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="mc">这个怎么解决？</em> </strong></p><p id="eb39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需用while循环改变if条件。因此，当它在没有任何通知信号的情况下醒来时，它会重新检查状态，如果站点管理器仍然没有给出任何绿色标志，它会重新进入睡眠状态。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="553a" class="kt ku ht kp b fi kv kw l kx ky">while(nearby_station &amp;&amp; !station_manager_green_flag_present){<br/>      System.out.println("Waiting for trainA to be passed");<br/>      signal.wait();<br/>}</span></pre><p id="f334" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的软件场景中，当列车A通知列车B时，车站管理员需要准备好绿色标志，否则，列车B将永远停留在while循环中。</p><p id="4007" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会奇怪，为什么我们一开始不雇佣电视台经理来简化流程</p><p id="956b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当列车A准备离开时，车站管理员通知列车B启动发动机，并准备好等待他发出的下一个进入信号。或者在列车B首先到达车站的情况下，它联系车站管理员，无论列车A是否在进入车站的路上。</p><p id="cebc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是你应该看到车站管理员有很高的责任，否则在这种情况下信号等级的复杂性</p><p id="0ec9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> …。如果有100次这样的穿越，处理起来会有多困难。</strong></p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/3155ce7706d9fda2b89743320c225ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*EzoLjqGkbNONQoQx.gif"/></div><figcaption class="me mf et er es mg mh bd b be z dx"><a class="ae jo" href="https://media.giphy.com/media/pntEStkSm6orC/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/pntEStkSm6orC/giphy.gif</a></figcaption></figure><p id="ba91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但另一方面，你应该承认，第一种方法如何使车站管理员的工作变得简单，因为他只需要插上一面旗帜，然后回到他美味的三明治上，我们还使所有系统在某种程度上解耦。</p><p id="86c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，火车通过信号互相交谈。很酷不是吗？</p><p id="1ce9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只需要车站管理员通过一个<strong class="is hu">简单的绿色标志</strong>来处理像错过信号和虚假唤醒这样的不幸情况。</p><p id="e1ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，伙计们，这都是线程信号。总结一下，这就是我们今天学到的东西。</p><ol class=""><li id="80b1" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">如何实现<strong class="is hu">的不变性</strong></li><li id="325f" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如何解除<strong class="is hu">忙等待</strong></li><li id="189f" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如何处理<strong class="is hu">错过的信号</strong></li><li id="fbb9" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如何处理<strong class="is hu">虚假唤醒？</strong></li></ol><p id="083f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢你从头到尾阅读这篇文章，我打算继续写这个话题，下一节将处理死锁和更多问题。</p><p id="878c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">敬请期待！！</strong></p></div></div>    
</body>
</html>
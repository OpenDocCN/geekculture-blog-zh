<html>
<head>
<title>Modern Web Testing using Cypress and Cucumber</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用柏树和黄瓜的现代网络测试</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/modern-web-testing-using-cypress-and-cucumber-c25ffcf55670?source=collection_archive---------11-----------------------#2021-08-24">https://medium.com/geekculture/modern-web-testing-using-cypress-and-cucumber-c25ffcf55670?source=collection_archive---------11-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4342" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">自动化的需要</h1><ul class=""><li id="d5ec" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">大多数<a class="ae jv" href="https://about.gitlab.com/topics/agile-delivery/" rel="noopener ugc nofollow" target="_blank">敏捷交付</a>团队遵循2周的发布周期。为了应对这些变化并交付一个没有错误的应用程序，自动化是必需的。有必要在开发阶段早期识别bug，以提高团队的效率。</li><li id="8315" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">大多数被确定用于测试的<a class="ae jv" href="https://smartbear.com/learn/automated-testing/how-to-perform-end-to-end-testing/" rel="noopener ugc nofollow" target="_blank">端到端场景</a>都很冗长，自动化测试有助于编写更深入的测试来验证复杂的用例。这也涵盖了在手动测试中经常被避免的冗长的测试。</li><li id="0c70" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">在<a class="ae jv" href="https://www.atlassian.com/agile/scrum/sprints" rel="noopener ugc nofollow" target="_blank">冲刺</a>中出现了许多新的需求，为了在没有/很少人为错误的时间表内完成测试和交付，自动化是必需的。对于大多数项目来说，有多个服务于不同目的的环境，一些环境也是特定于客户的。为了实现<a class="ae jv" href="https://searchitoperations.techtarget.com/definition/continuous-deployment" rel="noopener ugc nofollow" target="_blank">连续展开</a>，自动化是必要的。</li></ul><h1 id="b19c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决办法</h1><p id="4800" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">为了满足自动化的需要，<a class="ae jv" href="https://www.cypress.io/how-it-works/" rel="noopener ugc nofollow" target="_blank">柏树</a>框架与<a class="ae jv" href="https://cucumber.io/" rel="noopener ugc nofollow" target="_blank">黄瓜</a>集成是最好的选择之一。在这里，需求以场景的形式写在特征文件中，遵循行为驱动开发(<a class="ae jv" href="https://www.agilealliance.org/glossary/bdd/" rel="noopener ugc nofollow" target="_blank"> BDD </a>)语法。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="0601" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">柏树简介</h1><ul class=""><li id="4c12" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">Cypress是一个免费的开源自动化工具，<a class="ae jv" href="https://en.wikipedia.org/wiki/MIT_License" rel="noopener ugc nofollow" target="_blank">麻省理工学院许可的</a>，用<a class="ae jv" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>编写。</li><li id="c272" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress是为现代网络构建的下一代前端测试工具。在Cypress端到端测试的帮助下，集成和单元测试很容易编写和调试。</li><li id="e862" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress由一个免费、开源、本地安装的<a class="ae jv" href="https://docs.cypress.io/guides/core-concepts/test-runner" rel="noopener ugc nofollow" target="_blank">测试运行器</a>和一个<a class="ae jv" href="https://www.cypress.io/dashboard/" rel="noopener ugc nofollow" target="_blank">仪表板服务</a>组成，用于记录我们的测试。Cypress有自己的文件夹结构，当你在特定的位置第一次打开它时，它会自动生成。它附带了现成的食谱，描述了如何测试Cypress中的常见场景。</li></ul><h1 id="4805" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">柏树建筑</h1><ul class=""><li id="cf4b" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">大多数测试工具(如<a class="ae jv" href="https://github.com/SeleniumHQ/selenium" rel="noopener ugc nofollow" target="_blank"> Selenium </a>)都是在浏览器之外运行，并通过网络执行远程命令。但是Cypress引擎直接在浏览器内部运行。它使Cypress能够在运行时通过操纵<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM </a>和动态改变网络请求和响应来监听和修改浏览器行为。这反过来使得测试执行更快、更稳定。因此，它打开了新的测试方式的大门，并最终控制我们的应用程序。</li><li id="17bb" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">可以很容易地为<a class="ae jv" href="https://en.wikipedia.org/wiki/User_interface" rel="noopener ugc nofollow" target="_blank"> UI </a>和<a class="ae jv" href="https://en.wikipedia.org/wiki/API" rel="noopener ugc nofollow" target="_blank"> API </a>操作创建测试。Cypress直接与API通信，使测试能够运行，并在运行时验证请求和响应。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/62993799c7672891ae98cad880141046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lElHyEWCvZhoR_yG03MWVQ.png"/></div></div></figure><ul class=""><li id="90ef" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">赛普拉斯在现代前端开发栈工作:<a class="ae jv" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>、<a class="ae jv" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>、<a class="ae jv" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">西农</a>、<a class="ae jv" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>。它与开发人员通常用来编写单元测试的工具完美匹配。使用Cypress也可以轻松实现对使用<a class="ae jv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>开发的web应用程序的E2E测试。</li><li id="d18d" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress背后是一个<a class="ae jv" href="https://stackabuse.com/how-to-start-a-node-server-examples-with-the-most-popular-frameworks/" rel="noopener ugc nofollow" target="_blank">节点服务器</a>进程。Cypress和节点进程不断地相互通信、同步和执行任务。能够访问这两个部分(前端和后端)使我们能够实时响应应用程序的事件，同时在浏览器之外执行需要更高权限的任务。</li><li id="37a6" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress也通过动态读取和改变<a class="ae jv" href="https://en.wikipedia.org/wiki/Web_traffic" rel="noopener ugc nofollow" target="_blank">网络流量</a>在网络层运行。这使得Cypress不仅可以修改进出浏览器的所有内容，还可以修改可能干扰其自动化浏览器能力的代码。</li><li id="e9d6" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress最终从上到下控制了整个自动化过程，这使它处于独特的位置，能够了解浏览器内外发生的一切。这意味着Cypress能够提供比任何其他测试工具更一致的结果。</li><li id="71b2" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">因为Cypress是本地安装在我们的机器上的，所以它可以额外接入操作系统来执行自动化任务。这使得执行任务，如截图，录制视频，一般文件系统操作和网络操作成为可能。</li><li id="253c" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress浏览器支持:<a class="ae jv" href="https://www.google.com/intl/en_in/chrome/canary/" rel="noopener ugc nofollow" target="_blank">金丝雀</a>、<a class="ae jv" href="https://www.google.com/intl/en_in/chrome/" rel="noopener ugc nofollow" target="_blank"> Chrome </a>、<a class="ae jv" href="https://livebook.manning.com/book/electron-in-action/chapter-1/" rel="noopener ugc nofollow" target="_blank">电子</a>(默认)、<a class="ae jv" href="https://en.wikipedia.org/wiki/Chromium_(web_browser)" rel="noopener ugc nofollow" target="_blank"> Chromium </a>、<a class="ae jv" href="https://en.wikipedia.org/wiki/Firefox" rel="noopener ugc nofollow" target="_blank"> Mozilla Firefox </a>浏览器(beta支持)和<a class="ae jv" href="https://www.microsoft.com/en-us/edge" rel="noopener ugc nofollow" target="_blank">微软Edge </a>(基于Chromium)浏览器。</li></ul></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="8b4d" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">柏树特征</h1><ul class=""><li id="ace5" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><em class="lt">时间旅行</em> : Cypress在测试运行时拍摄快照。我们可以将鼠标悬停在<a class="ae jv" href="https://docs.cypress.io/api/commands/log" rel="noopener ugc nofollow" target="_blank">命令日志</a>中的命令上，以查看每一步到底发生了什么。</li><li id="cd0c" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">可调试性 : Cypress代码可以直接从浏览器开发工具中调试，因为代码是用JavaScript编写的。它还提供了可读的错误和堆栈跟踪，使得调试速度快如闪电。</li><li id="73b9" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">自动等待</em> : Cypress自动等待命令和断言，然后继续前进。</li><li id="aa36" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/guides/stubs-spies-and-clocks" rel="noopener ugc nofollow" target="_blank"> <em class="lt">间谍、存根和时钟</em> </a>:使用Cypress我们可以验证和控制函数、服务器响应或定时器的行为。</li><li id="3786" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">截图和视频</em>:从<a class="ae jv" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank"> CLI </a>运行时，在失败时自动截图，或者整个测试套件的视频。</li><li id="0e70" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><a class="ae jv" href="https://www.browserstack.com/cross-browser-testing" rel="noopener ugc nofollow" target="_blank"> <em class="lt">跨浏览器测试</em> </a>:在本地和优化的持续集成管道中运行Firefox和Chrome系列浏览器(包括Edge和electronic)内的测试。</li></ul><p id="07e5" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">除此之外，它还改变了测试自动化框架引入之前的开发方式。下图非常漂亮地描绘了它:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/b5a31778d7cb3287c730f8b0bcc151f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkdKRGgGbuTE__ZNEKKhtw.png"/></div></div></figure><p id="b6de" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">以下是Cypress断言、内置命令和项目中常用的自定义命令的一些参考:</p><ol class=""><li id="0398" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq lx js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html#Cypress-Can-Be-Simple-Sometimes" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://docs . Cypress . io/guides/core-concepts/introduction-to-Cypress . html # Cypress-Can-Be-Simple-times</em></a></li><li id="1975" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/references/assertions.html#Chai" rel="noopener ugc nofollow" target="_blank">T17】https://docs . cypress . io/guides/references/assertions . html # ChaiT19】</a></li><li id="49d5" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/core-concepts/retry-ability.html#Commands-vs-assertions" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://docs . cypress . io/guides/core-concepts/retry-ability . html # Commands-vs-assertions</em></a></li><li id="a2ca" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/api/cypress-api/custom-commands.html#Syntax" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://docs . cypress . io/API/cypress-API/custom-commands . html #语法</em> </a></li><li id="9ebb" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/api/commands/stub.html#Syntax" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://docs.cypress.io/api/commands/stub.html#Syntax</em></a></li></ol></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="313b" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">柏树断言</h1><ul class=""><li id="d068" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/references/assertions" rel="noopener ugc nofollow" target="_blank">断言</a>是确定自动化测试用例的指定步骤是否成功的确认步骤。实际上，断言验证测试中的元素、对象或应用程序的期望状态(<a class="ae jv" href="https://innoroo.com/blog/2018/11/22/application-under-test-glossary/" rel="noopener ugc nofollow" target="_blank"> AUT </a>)。例如，断言使我们能够验证一些场景，比如一个元素是否可见或者是否有特定的属性、<a class="ae jv" href="https://www.w3schools.com/css/" rel="noopener ugc nofollow" target="_blank"> CSS </a>类或者状态。</li><li id="1e74" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">所有自动化测试用例都应该有断言步骤，这始终是一个推荐的实践。否则，验证应用程序是否已经达到预期状态将是不可行的。</li><li id="d451" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress本身捆绑了由<a class="ae jv" href="https://docs.cypress.io/guides/references/bundled-tools" rel="noopener ugc nofollow" target="_blank"> Chai、Sinon和jQuery </a>库提供的断言。</li></ul><blockquote class="ly lz ma"><p id="8149" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">我们可以根据调用它们的主题将所有这些断言大致分为两类:<strong class="jf hj">隐式</strong>和<strong class="jf hj">显式</strong>断言。</p></blockquote><h1 id="d20e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">隐式断言</h1><ul class=""><li id="fd53" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">当断言应用于由<a class="ae jv" href="https://docs.cypress.io/api/commands/parent" rel="noopener ugc nofollow" target="_blank">父链接命令</a>提供的对象时，它被称为隐式断言。</li><li id="9455" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">此外，这类断言通常包括诸如“<a class="ae jv" href="https://docs.cypress.io/api/commands/should" rel="noopener ugc nofollow" target="_blank"> <em class="lt">”的命令。</em> </a>【应()】和<a class="ae jv" href="https://docs.cypress.io/api/commands/and" rel="noopener ugc nofollow" target="_blank"> <em class="lt">。和()</em>。</a>”</li><li id="46f0" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">由于这些命令不是独立的，并且总是依赖于先前链接的父命令，它们自动继承并作用于由先前命令产生的对象。</li><li id="0ea6" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">例如:<code class="du me mf mg mh b">cy.get('#loginButton').should('have.class', 'active').and('have.attr', 'href', '/login');</code></li></ul><blockquote class="ly lz ma"><p id="7f24" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">由于<code class="du me mf mg mh b">.should('have.class')</code>不改变主题，所以<code class="du me mf mg mh b">.and('have.attr')</code>是针对同一个元素执行的，当您需要针对单个主题快速断言多个事物时，使用这些隐式断言会很方便。</p></blockquote><p id="2316" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">一般来说，当我们想要:</p><ul class=""><li id="cc5f" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">断言关于同一主题的多个验证。</li><li id="f8e6" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">在对主题做出断言之前改变主题。</li></ul><h1 id="8c8c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">明确的断言</h1><ul class=""><li id="fd63" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">当需要为断言传递一个显式主题时，它属于显式断言的范畴。</li><li id="423d" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">这类断言包含命令，如"<a class="ae jv" href="https://docs.cypress.io/guides/references/assertions#BDD-Assertions" rel="noopener ugc nofollow" target="_blank"><em class="lt"/></a>"和"<a class="ae jv" href="https://docs.cypress.io/guides/references/assertions#TDD-Assertions" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> assert() </em> </a>"这些命令允许您传递显式的主体/对象。</li><li id="fcc0" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">例如:</li></ul><pre class="ld le lf lg fd mi mh mj mk aw ml bi"><span id="9f35" class="mm ig hi mh b fi mn mo l mp mq">const obj = { foo: 'bar' }<br/>expect(obj).to.equal(obj)<br/>expect(obj).to.deep.equal({ foo: 'bar' })</span></pre><p id="9576" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">一般来说，当我们想要:</p><ul class=""><li id="d943" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">在对给定主题进行断言之前，执行一些定制逻辑。</li><li id="5047" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">对同一主题执行多个断言。</li></ul><h1 id="9068" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">常见的柏树断言</h1><p id="ce96" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">Cypress提供了广泛的断言，这在UI自动化过程中非常方便。一些最广泛使用的柏树断言是:</p><p id="235a" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">1) <em class="lt"> Length </em>:验证之前链接的命令返回的元素个数。例如:<code class="du me mf mg mh b">cy.get('.demo-frame &gt; ul &gt; li').should('have.length',20);</code></p><p id="064b" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">2) <em class="lt">类</em>:验证元素是否有提到的类。例如:<code class="du me mf mg mh b">cy.get('form').find('input').should('not.have.class', 'disabled');</code></p><p id="609f" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">3) <em class="lt">文本内容</em>:验证元素是否具有指定的文本。例如:<code class="du me mf mg mh b">cy.get('a').parent('span').should('contain', 'Testing');</code></p><p id="47bd" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">4) <em class="lt">可见性</em>:验证元素是否可见。例如:<code class="du me mf mg mh b">cy.get('button').should('be.visible');</code></p><p id="6532" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">5) <em class="lt">存在</em>:验证该元素是否存在于DOM中。例如:<code class="du me mf mg mh b">cy.get('#loader').should('not.exist');</code></p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="5090" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">柏树钩</h1><p id="53d7" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">Cypress还提供了一些构造，也称为<a class="ae jv" href="https://www.toolsqa.com/cypress/cypress-hooks/" rel="noopener ugc nofollow" target="_blank"> Cypress Hooks </a>，帮助在每个测试用例之前/之后或者测试套件中所有测试用例之前/之后执行一组特定的动作。</p><ul class=""><li id="b7c8" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated"><code class="du me mf mg mh b">before()</code>:在开始执行使用“描述”或“上下文”块中的“它”或“指定”指定的第一个测试之前，运行一次。</li><li id="9c0a" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><code class="du me mf mg mh b">after()</code>:在“描述”或“上下文”块中使用“它”或“指定”指定的所有测试完成后运行一次。</li><li id="8165" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><code class="du me mf mg mh b">beforeEach()</code>:它在开始执行使用“描述”或“上下文”块中的“它”或“指定”指定的每个测试之前运行。</li><li id="1287" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><code class="du me mf mg mh b">afterEach()</code>:它在完成使用“describe”或“context”块中的“It”或“specify”指定的每个测试后运行。</li></ul></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="b8f2" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">赛普拉斯试跑者</h1><ul class=""><li id="cf4f" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">Cypress在一个独特的交互式运行器中运行测试，这个运行器允许我们在命令执行的同时查看测试中的应用程序。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/8273325c3ef8e9adc0b04b2e2d777c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XHs7b3nvKBJbB0gmSIVJg.png"/></div></div></figure><ul class=""><li id="f876" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">测试运行程序的左侧是我们测试套件的可视化表示。每个测试块都被正确嵌套，每个测试在被点击时，显示在测试块中执行的每个Cypress命令和断言，以及在相关的之前的<strong class="jf hj">、每个</strong>之前的<strong class="jf hj">、每个</strong>之后的<strong class="jf hj">和</strong>挂钩之后的<strong class="jf hj">中执行的任何命令或断言。</strong></li><li id="ced6" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">点击命令</em>:当点击每个命令、断言或错误时，会在开发工具控制台中显示额外的信息。当命令执行时，单击还会将测试中的应用程序(右侧)固定到其先前的状态。</li><li id="9399" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">悬停在命令上</em>:当悬停在每个命令和断言上时，会将测试中的应用程序(右侧)恢复到该命令执行时的状态。这允许我们在测试时“时间旅行”回到应用程序以前的状态。</li><li id="a86d" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">测试运行程序还提供了从下拉列表中选择不同浏览器的选项。通过这种方式，我们可以在本地执行跨浏览器测试，前提是安装了所有的浏览器。</li></ul></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="0b30" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">BDD和黄瓜简介</h1><ul class=""><li id="31bf" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">测试场景直接从用户故事中开发。为了涵盖完整的用户故事和围绕它的测试，自动化测试以BDD格式编写，即黄瓜步骤。这些步骤是用<a class="ae jv" href="https://docs.behat.org/en/v2.5/guides/1.gherkin.html" rel="noopener ugc nofollow" target="_blank">小黄瓜语言</a>编写的，所以它们应该是每个人都可以阅读的。</li><li id="0f06" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">在敏捷项目中，需求随着应用程序中引入的新特性而不断变化，因此BDD非常适合这些变化。</li><li id="5281" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><a class="ae jv" href="https://cucumber.io/docs/gherkin/reference/" rel="noopener ugc nofollow" target="_blank">给定—何时—然后</a>方法允许测试人员在特征文件中任意多次使用相同的步骤，这逐渐有助于为自动化节省时间。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es ms"><img src="../Images/d5033ab9e8539d525bf2a2a12aef455c.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*v-lydQAj4kbc_enJBZuxlQ.png"/></div></figure><h1 id="b8a3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">BDD框架的组件</h1><ul class=""><li id="290b" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><a class="ae jv" href="https://www.toolsqa.com/cucumber/cucumber-jvm-feature-file/" rel="noopener ugc nofollow" target="_blank">特性文件</a>是你的框架的黄瓜测试的入口点。这是一个文件，你可以在其中用描述性的小黄瓜语言(比如英语)编写你的测试或者验收标准。一个特征文件可以包括一个或多个采用“给定时间-然后”格式的场景。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mt"><img src="../Images/de2d27467874c28489ae803ac4809b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7d76cW2r6thPuZGaxRsJ7Q.png"/></div></div></figure><ul class=""><li id="1f5a" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated"><a class="ae jv" href="https://cucumber.io/docs/cucumber/step-definitions/" rel="noopener ugc nofollow" target="_blank">步骤定义</a>是一小段附加了设计模式的代码。特征文件中提到的模式后面的注释将步骤定义链接到所有匹配的步骤。</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mu"><img src="../Images/7d60a52cfa3e205e201767c898d1ad8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M_ljBFc0njG2LwkP36leA.png"/></div></div></figure><p id="fc2a" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">更多详情-</p><ol class=""><li id="57d1" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq lx js jt ju bi translated"><a class="ae jv" href="https://cucumber.io/docs/bdd/" rel="noopener ugc nofollow" target="_blank">【https://cucumber.io/docs/bdd/】T4</a></li><li id="fefd" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://cucumber.io/docs/cucumber/" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://cucumber.io/docs/cucumber/</em></a></li></ol></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="d504" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">柏树装置</h1><ul class=""><li id="f09e" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><em class="lt">运行</em> : <code class="du me mf mg mh b">npm init</code>(这将创建一个package.json文件)</li></ul><blockquote class="ly lz ma"><p id="344c" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">确保您已经运行了<strong class="jf hj"> npm init </strong>或者在您的项目的根目录中有一个<strong class="jf hj"> node_modules </strong>文件夹或者<strong class="jf hj"> package.json </strong>文件，以确保cypress安装在正确的目录中。</p></blockquote><ul class=""><li id="5ef2" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated"><em class="lt">使用npm下载</em>:使用下面的命令使用节点包管理器下载Cypress。此外，我们必须在同一个目录中执行这个命令，这意味着在项目文件夹本身内部，我们在上面做<strong class="jf hj"> npm init </strong>时提到过。</li><li id="8b24" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">运行</em> : <code class="du me mf mg mh b">npm install cypress --save-dev</code>(这将使用所需的依赖项更新package.json和package-lock.json文件，并且还将创建一个<a class="ae jv" href="https://stackoverflow.com/questions/63294260/what-is-the-purpose-of-node-modules-folder" rel="noopener ugc nofollow" target="_blank"> node_modules </a>文件夹)</li><li id="2d35" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><em class="lt">运行:</em> <code class="du me mf mg mh b">npx cypress open</code>(这将第一次启动测试运行程序，并生成一个默认的文件夹结构)</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mv"><img src="../Images/29e4bae1147f010e8f2eec45dbab333d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvC3CE9F2peyRRmoUp2lUg.png"/></div></div></figure><p id="45b6" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">更多详情-</p><p id="20fb" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated"><a class="ae jv" href="https://docs.cypress.io/guides/getting-started/installing-cypress.html" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://docs . cypress . io/guides/getting-started/installing-cypress . html</em></a></p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="f768" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">项目结构</h1><p id="dca1" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">下面是Cypress框架的默认文件夹结构的快照:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mw"><img src="../Images/a576703e60074908960126808a4251f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*YTqsI0RZGlG-dsktBWKl7Q.png"/></div></figure><ul class=""><li id="8b40" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">Fixtures被用作静态数据的外部片段，可以被您的测试使用。夹具文件默认位于<strong class="jf hj"> cypress/fixtures </strong>中，但是可以配置到另一个目录。</li></ul><p id="c7f4" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">有关更多详细信息:</p><p id="2cb3" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated"><a class="ae jv" href="https://www.toolsqa.com/cypress/fixtures-in-cypress/" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www.toolsqa.com/cypress/fixtures-in-cypress/</em></a></p><ul class=""><li id="0d9e" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">默认情况下，特征文件和步骤定义位于<strong class="jf hj"> cypress/integration </strong>中，但可以配置到另一个目录。</li><li id="33c4" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">默认情况下，Cypress会在它运行的每个<a class="ae jv" href="https://www.toolsqa.com/cypress/cypress-test-runner/" rel="noopener ugc nofollow" target="_blank">单一规范文件</a>之前自动包含插件文件<strong class="jf hj">Cypress/plugins/index . js</strong>。</li><li id="330d" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">插件文件是一个特殊的文件，它在项目加载之前、浏览器启动之前以及测试执行期间在Node中执行。当Cypress测试在浏览器中执行时，插件文件在后台节点进程中运行，让您的测试能够通过调用<strong class="jf hj"> cy.task() </strong>命令来访问文件系统和操作系统的其余部分。</li><li id="c6b0" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">支持文件夹包含用于UI和API相关操作的实用程序方法(自定义命令)的文件。可以创建自定义命令来为现有的内置Cypress命令提供不同的行为，也可以使用自定义命令来创建新命令。Cypress中的自定义命令只不过是一个普通的Cypress命令。唯一的区别是它是由用户定义的，而不是Cypress提供的默认命令。定制命令有利于自动化您在测试中反复重复的工作流。</li><li id="0323" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">默认情况下，Cypress会自动包含支持文件<strong class="jf hj"> cypress/support/index.js </strong>。</li><li id="491f" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">与Selenium不同，Cypress只支持<strong class="jf hj"> CSS选择器</strong>(与JQuery选择器非常相似)。Cypress也支持Xpath选择器。然而，这不会自动发生。换句话说，我们需要<a class="ae jv" href="https://www.npmjs.com/package/cypress-xpath" rel="noopener ugc nofollow" target="_blank"><strong class="jf hj">cypress-XPath</strong></a>外部插件来辅助这个选择器。</li></ul><blockquote class="ly lz ma"><p id="178e" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">要安装cypress-xpath插件，运行命令:<code class="du me mf mg mh b">npm install -D cypress-xpath</code></p><p id="867a" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">然后我们需要在cypress/support/index.js中添加以下内容:<code class="du me mf mg mh b">require('cypress-xpath')</code></p></blockquote><ul class=""><li id="e157" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">添加自己的自定义命令:</li></ul><p id="5559" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">Cypress提供了一个API来创建一个新的定制命令或者覆盖现有的命令来改变它们的实现。内置的Cypress命令也使用API。它在语法上可以表示如下:</p><pre class="ld le lf lg fd mi mh mj mk aw ml bi"><span id="2d1e" class="mm ig hi mh b fi mn mo l mp mq">// Add a new command</span><span id="a3e7" class="mm ig hi mh b fi mx mo l mp mq">Cypress.Commands.add(name, callbackFn)<br/>Cypress.Commands.add(name, options, callbackFn)</span></pre><p id="b5e0" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">有关更多详细信息:</p><p id="c1e3" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated"><a class="ae jv" href="https://www.toolsqa.com/cypress/custom-commands-in-cypress/" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www.toolsqa.com/cypress/custom-commands-in-cypress/</em></a></p><ul class=""><li id="c3e7" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated"><code class="du me mf mg mh b">package.json</code>由所有需要的附属物组成。所有npm包在项目根中都包含一个名为package.json的文件，该文件包含与项目相关的各种元数据和库。该文件向npm提供信息，允许它识别项目以及处理项目的依赖项。类似于来自Maven的<code class="du me mf mg mh b">pom.xml</code>和gradle中的build.gradle。假设您已经安装了一个节点，我们必须首先创建一个package.json文件。</li></ul><h1 id="1a8a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">柏树中的配置</h1><ul class=""><li id="1f40" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">按照标准定义，配置文件为程序或框架保留一些初始设置和配置。因此，遵循同样的模式，Cypress也提供了<a class="ae jv" href="https://docs.cypress.io/guides/references/configuration" rel="noopener ugc nofollow" target="_blank">特定的配置</a>，这些配置最初有特定的默认值，并且在需要的基础上，这些值可以被用户覆盖。</li><li id="19c2" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">配置指定了一些键值，这些键值可以在整个测试框架中使用，并且将基于它们的默认值或更改值来指导框架的行为。</li><li id="1768" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">全局配置提供了Cypress在执行测试时考虑的所有默认配置。此外，这些配置主要与超时、环境变量、节点版本、从中读取所有集成测试的文件夹路径、fixture、命令等相关。</li><li id="00ca" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress提供的第一种更改默认配置值的方法是在配置文件中指定这些配置所需的值。Cypress使用的默认配置文件是<a class="ae jv" href="https://docs.cypress.io/guides/references/configuration" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> cypress.json </strong> </a>。因此，无论我们想要改变什么值，我们都可以在<strong class="jf hj"> cypress.json </strong>文件中指定那些键值对。</li><li id="d0de" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">假设，我们想更新<a class="ae jv" href="https://docs.cypress.io/guides/references/configuration" rel="noopener ugc nofollow" target="_blank"><strong class="jf hj">defaultCommandTimeout</strong></a>配置，并想将其从默认的<strong class="jf hj"/><strong class="jf hj"><em class="lt">4</em>秒</strong>更改为<strong class="jf hj"> <em class="lt"> 10 </em>秒</strong>。因此，可以通过在<strong class="jf hj"> cypress.json </strong>文件中指定以下值来实现:</li></ul><pre class="ld le lf lg fd mi mh mj mk aw ml bi"><span id="5c56" class="mm ig hi mh b fi mn mo l mp mq">{<br/>  "defaultCommandTimeout": 10000<br/>}</span></pre></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="b4c0" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">Cypress与黄瓜预处理器的集成</h1><p id="687a" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">Cucumber与Cypress集成的第一步是在框架中安装<a class="ae jv" href="https://github.com/TheBrainFamily/cypress-cucumber-preprocessor" rel="noopener ugc nofollow" target="_blank"> Cucumber-preprocessor </a>的依赖项。</p><p id="354e" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">为了安装Cypress的Cucumber-preprocessor节点模块，我们可以使用以下命令:</p><p id="63b8" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated"><code class="du me mf mg mh b">npm install --save-dev cypress-cucumber-preprocessor</code></p><p id="878c" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">当我们执行这个命令时，它将产生示例输出，如下所示:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/47b688d0f591d191ae85cbe4a6a966d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwOYnWX0hcXOvMYem_BCQw.png"/></div></div></figure><p id="d1ec" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">该模块将被添加到项目中package.json文件的“devDependencies”下。</p><blockquote class="ly lz ma"><p id="d5ee" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">现在，一旦Cucumber-preprocessor安装成功，下一步就是进行一些配置更改，这样Cypress就可以开始使用Cucumber并使用户能够编写BDD测试。</p></blockquote><ul class=""><li id="5faf" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">添加到<strong class="jf hj">cypress/plugins/index . js</strong>下的插件中:</li></ul><pre class="ld le lf lg fd mi mh mj mk aw ml bi"><span id="1f8d" class="mm ig hi mh b fi mn mo l mp mq">const cucumber = require('cypress-cucumber-preprocessor').default</span><span id="f716" class="mm ig hi mh b fi mx mo l mp mq">module.exports = (on, config) =&gt; {<br/>  on('file:preprocessor', cucumber())<br/>}</span></pre><ul class=""><li id="7e96" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">为您的Cypress配置添加对特性文件的支持<strong class="jf hj"> cypress.json </strong>:</li></ul><pre class="ld le lf lg fd mi mh mj mk aw ml bi"><span id="eb59" class="mm ig hi mh b fi mn mo l mp mq">{<br/>  "testFiles": "**/*.feature"<br/>}</span></pre><p id="691a" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">以BDD格式(特征文件)编写测试用例时需要注意的一些要点:</p><p id="ce88" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">1) <em class="lt">导入</em> <em class="lt">语句</em>:我们要从<strong class="jf hj">cypress-cumber-preprocessor</strong>中导入<strong class="jf hj"> Given-When-Then </strong>注释。原因是这些注释提供了特征文件中的步骤和步骤定义文件中的方法之间的映射。</p><p id="ab95" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">2)为Cucumber特征文件中的语句编写步骤定义时，特征文件和步骤定义文件中的英文文本应该相同。它帮助正则表达式识别哪个步骤与哪个方法实现相匹配。</p><p id="b7f8" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">3)对于特征文件中用引号括起来的数据，我们将其保存为{string}。随后，我们将把它作为参数传递，就像我们使用用户名、电子邮件等一样。</p><p id="a78f" class="pw-post-body-paragraph kb kc hi jf b jg lo kd ke ji lp kf kg jk lu ki kj jm lv kl km jo lw ko kp jq hb bi translated">有关更多详细信息:</p><ol class=""><li id="5f77" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq lx js jt ju bi translated"><a class="ae jv" href="https://www.npmjs.com/package/cypress-cucumber-preprocessor" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www.npmjs.com/package/cypress-cucumber-preprocessor</em></a></li><li id="2e93" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq lx js jt ju bi translated"><a class="ae jv" href="https://www.toolsqa.com/cypress/bdd-automation-framework-in-cypress/" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www . tools QA . com/cypress/BDD-automation-framework-in-cypress/</em></a></li></ol></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="7e6c" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">用Mochawesome报道</h1><ul class=""><li id="07eb" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">Mocha awesome是一个用于JavaScript测试框架Mocha的定制报告器。</li><li id="7b20" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">它运行在Node.js (&gt;=10)上，与<a class="ae jv" href="https://www.npmjs.com/package/mochawesome-report-generator" rel="noopener ugc nofollow" target="_blank">moch awesome-report-generator</a>协同工作，生成一个独立的HTML/CSS报告，帮助可视化您的测试运行。</li><li id="cad3" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">marge(mocha awesome-report-generator)是mocha awesome的对应物，这是一个用于JavaScript测试框架mocha的定制报告器。Marge从mochawesome获取JSON输出，并生成一个完整的HTML/CSS报告，帮助可视化您的测试套件。</li></ul><blockquote class="ly lz ma"><p id="2652" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated">安装Mochawesome:</p><p id="40e7" class="kb kc lt jf b jg lo kd ke ji lp kf kg mb lu ki kj mc lv kl km md lw ko kp jq hb bi translated"><em class="hi">运行</em> : <code class="du me mf mg mh b">npm install mochawesome</code></p></blockquote><ul class=""><li id="5214" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">在<strong class="jf hj"> cypress.json </strong>配置文件中添加以下内容:</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es my"><img src="../Images/aec8fdea234bb2bdcd521979af2d4d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*zTp7UDqrphhJ0XaRggM-oQ.png"/></div></figure><h1 id="f874" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用Mochawesome报告生成器的优势</h1><p id="dbdc" class="pw-post-body-paragraph kb kc hi jf b jg jh kd ke ji jj kf kg jk kh ki kj jm kk kl km jo kn ko kp jq hb bi translated">以下是Mochawesome与其他Mocha报告工具相比的显著优势:</p><ul class=""><li id="13fd" class="jd je hi jf b jg lo ji lp jk lq jm lr jo ls jq jr js jt ju bi translated">Mochawesome report是以一种移动友好和简单的方式设计的。它使用chartJS来可视化测试报告。</li><li id="ac58" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">它支持显示不同类型的钩子— <code class="du me mf mg mh b">before(), beforeEach(), after(),afterAll()</code>等等。</li><li id="09bc" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">由于Mochawesome中的内嵌代码审查特性，特定代码行的失败可以在报告中直接看到。</li><li id="b8a0" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">它支持堆栈跟踪日志和失败消息。</li><li id="0f39" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">您可以将额外的上下文信息作为附件添加到测试中，如控制台日志、环境细节、测试的自定义消息。这为报告中的测试用例提供了额外的信息。</li><li id="855c" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">由于报告是用独立的HTML/CSS生成的，因此可以与脱机共享。HTML扩展。</li><li id="0a4f" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">下面是测试执行后生成的样本Mochawesome报告的快照:</li></ul><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mz"><img src="../Images/de623b975eb5f877c308d909c92845f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jj7vEykqyiEm2RKfhQMzNA.png"/></div></div></figure></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="7ed0" class="if ig hi bd ih ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc bi translated">价值创造和稳定性</h1><ul class=""><li id="1d21" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">与其他自动化框架相比，Cypress更加通用。那是因为它是用<strong class="jf hj"> JavaScript </strong>编写的，基于<strong class="jf hj">摩卡</strong>和<strong class="jf hj">柴</strong>。它在浏览器中运行时也使用<strong class="jf hj"> Node.js </strong>。</li><li id="2699" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><strong class="jf hj"> JavaScript </strong>是开发者开发网站的主要语言。因此，测试是用同一种语言创建的。使用Cypress，您可以运行跨浏览器测试。</li><li id="95eb" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress可以在Chrome、Firefox、Edge和Chromium等多种浏览器中执行测试。</li><li id="28c0" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress的响应时间不到20毫秒。框架会在另一个测试完成后自动运行测试。这消除了停机时间和手动触发下一个测试的需要，从而加快了整个执行过程。</li><li id="e876" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">为其他用例重用测试非常简单。好处是我们可以在其他项目中重用相同的框架。</li><li id="3f76" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">Cypress可以与CI/CD工具集成，如GitLab、Jenkins、CircleCI等。更多详情:<a class="ae jv" href="https://docs.cypress.io/guides/continuous-integration/introduction#What-is-Continuous-Integration" rel="noopener ugc nofollow" target="_blank">https://docs . cypress . io/guides/Continuous-Integration/introduction #什么是持续集成</a></li></ul></div></div>    
</body>
</html>
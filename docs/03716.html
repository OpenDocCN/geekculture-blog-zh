<html>
<head>
<title>Writing custom Widgets in Flutter (Part 3.b) — SimpleOverlay (no helpers)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中编写定制小部件(第3.b部分)——简单覆盖(无助手)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/writing-custom-widgets-in-flutter-part-3-b-simpleoverlay-no-helpers-9ddf45cea983?source=collection_archive---------33-----------------------#2021-06-14">https://medium.com/geekculture/writing-custom-widgets-in-flutter-part-3-b-simpleoverlay-no-helpers-9ddf45cea983?source=collection_archive---------33-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b7de50bf83ebb03f7afd5b7ea79255ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*J_f50bJMrdo4NmMPHylG5g.png"/></div></figure><h1 id="5481" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="fcdc" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">正如我所承诺的，现在我将展示如何在没有任何助手的情况下编写SimpleOverlay小部件。我将省略一些在以前的文章中已经描述过的样板代码。</p><h1 id="4e16" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">快速理论</h1><p id="e809" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在实现可能包含多个子部件的小部件时，我们还需要知道一些事情。</p><p id="1a8e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我们需要理解的第一件事是<strong class="jm hj">槽</strong>的概念。Slot基本上只是子部件在我们的部件中的一个位置。它与x和y像素坐标无关，而是与逻辑位置有关。例如，在工具栏的情况下，它可以表示导航图标、徽标、标题或动作(命名槽)。但是对于列，它将是每个子元素的索引。</p><p id="669d" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">子元素也可以从一个槽移动到另一个槽，而不需要重新创建。例如，当我们为我们的孩子指定<strong class="jm hj"> GlobalKey </strong>，然后在构建方法期间改变它的槽。或者当我们在元素中调用updateChid并为同一个元素传递不同的Slot时。</p><p id="899b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">还有一点就是调用子方法的顺序:</p><ul class=""><li id="57d5" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">布局-顺序无关紧要，除非一个子元素的大小取决于另一个子元素的大小</li><li id="6a5c" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated">绘画——当孩子互相重叠时，从后向前的顺序，否则顺序并不重要</li><li id="5220" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated">HitTest —当子元素相互重叠时，从前到后的顺序，否则顺序并不重要</li></ul><h1 id="ba1c" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">密码</h1><p id="5168" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">第一个不同是我们的小部件不再扩展<strong class="jm hj">multichildrendeobjectwidget</strong>，而是切换到更简单的<strong class="jm hj"> RenderObjectWidget </strong>:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4a01" class="lk in hi lg b fi ll lm l ln lo"><strong class="lg hj">class </strong>SimpleOverlay <strong class="lg hj">extends </strong>RenderObjectWidget {<br/>  <strong class="lg hj">final </strong>Widget <strong class="lg hj">child</strong>;<br/>  <strong class="lg hj">final </strong>Widget <strong class="lg hj">overlay</strong>;<br/><br/>  <strong class="lg hj">const </strong>SimpleOverlay({<br/>    <strong class="lg hj">required this</strong>.<strong class="lg hj">child</strong>,<br/>    <strong class="lg hj">required this</strong>.<strong class="lg hj">overlay</strong>,<br/>  });<br/><br/>  @override<br/>  RenderObjectElement createElement() {<br/>    <strong class="lg hj">return </strong>SimpleOverlayElement(<strong class="lg hj">this</strong>);<br/>  }<br/><br/>  @override<br/>  RenderObject createRenderObject(BuildContext context) {<br/>    <strong class="lg hj">return </strong>SimpleOverlayRenderObject();<br/>  }<br/>}</span></pre><p id="20b5" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">现在，我们需要向元素中添加子管理逻辑:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a649" class="lk in hi lg b fi ll lm l ln lo"><strong class="lg hj">class </strong>SimpleOverlayElement <strong class="lg hj">extends </strong>RenderObjectElement {<em class="lp"><br/>  </em>Element? <strong class="lg hj">_child</strong>;<br/>  Element? <strong class="lg hj">_overlay</strong>;<br/><br/>  <em class="lp">// ...</em><br/><br/>  @override<br/>  <strong class="lg hj">void </strong>mount(Element? parent, newSlot) {<br/>    <strong class="lg hj">super</strong>.mount(parent, newSlot);<br/><br/>    <strong class="lg hj">_child </strong>= inflateWidget(<strong class="lg hj">widget</strong>.<strong class="lg hj">child</strong>, <strong class="lg hj">true</strong>);<br/>    <strong class="lg hj">_overlay </strong>= inflateWidget(<strong class="lg hj">widget</strong>.<strong class="lg hj">overlay</strong>, <strong class="lg hj">false</strong>);<br/>  }<br/><br/>  @override<br/>  <strong class="lg hj">void </strong>update(SimpleOverlay newWidget) {<br/>    <strong class="lg hj">super</strong>.update(newWidget);<br/><br/>    <strong class="lg hj">_child </strong>= updateChild(<strong class="lg hj">_child</strong>, newWidget.<strong class="lg hj">child</strong>, <strong class="lg hj">true</strong>);<br/>    <strong class="lg hj">_overlay </strong>= updateChild(<strong class="lg hj">_overlay</strong>, newWidget.<strong class="lg hj">overlay</strong>, <strong class="lg hj">false</strong>);<br/>  }<br/><br/>  @override<br/>  <strong class="lg hj">void </strong>unmount() {<br/>    <strong class="lg hj">super</strong>.unmount();<br/>    <br/>    <strong class="lg hj">_child </strong>= <strong class="lg hj">null</strong>;<br/>    <strong class="lg hj">_overlay </strong>= <strong class="lg hj">null</strong>;<br/>  }<br/>}</span></pre><p id="4965" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这里与前面的“没有助手”的例子实际上不同的是槽的使用。在简单覆盖的情况下，我们只有两个槽—子槽和覆盖槽。我选择使用Boolean作为Slot，因为我们只有两个可能的值——<strong class="jm hj">true</strong>用于子对象，而<strong class="jm hj"> false </strong>用于覆盖对象。</p><p id="436b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">再次声明，插槽可以是您想要的任何东西，但是它们应该是一致的。</p><p id="fb32" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">还有一点需要补充——将子RenderObjects生命周期方法传递给我们自己的方法:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="b9a8" class="lk in hi lg b fi ll lm l ln lo"><strong class="lg hj">class </strong>SimpleOverlayElement <strong class="lg hj">extends </strong>RenderObjectElement {<br/>  <em class="lp">// ...</em><br/><br/>  @override<br/>  <strong class="lg hj">void </strong>insertRenderObjectChild(RenderBox child, bool slot) {<br/>    <strong class="lg hj">renderObject</strong>.insertRenderObjectChild(child, slot);<br/>  }<br/><br/>  @override<br/>  <strong class="lg hj">void </strong>moveRenderObjectChild(RenderBox child, bool oldSlot, bool newSlot) {<br/>    <strong class="lg hj">renderObject</strong>.moveRenderObjectChild(child, oldSlot, newSlot);<br/>  }<br/><br/>  @override<br/>  <strong class="lg hj">void </strong>removeRenderObjectChild(RenderBox child, bool slot) {<br/>    <strong class="lg hj">renderObject</strong>.removeRenderObjectChild(child, slot);<br/>  }</span></pre><p id="728f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这里唯一的新东西是出现了<strong class="jm hj"> moveRenderObjectChild </strong>方法。正如我之前提到的，当一个孩子从一个槽(<strong class="jm hj"> oldSlot </strong>)移动到一个新槽(<strong class="jm hj"> newSlot </strong>)时，这个方法将被调用。</p><p id="ea56" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这就是我们的元素。没什么大不了的，大部分代码都一样。现在让我们实现我们的RenderObject。首先，我们需要处理来自元素的插入、移动和移除调用:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="01c1" class="lk in hi lg b fi ll lm l ln lo"><strong class="lg hj">class </strong>SimpleOverlayRenderObject <strong class="lg hj">extends </strong>RenderBox {<br/>  <em class="lp">//...</em></span><span id="ff62" class="lk in hi lg b fi lq lm l ln lo"><em class="lp">  </em>RenderBox? <strong class="lg hj">_child</strong>;<br/>  RenderBox? <strong class="lg hj">_overlay</strong>;<br/><br/>  <strong class="lg hj">void </strong>insertRenderObjectChild(RenderBox child, bool slot) {<br/>    <strong class="lg hj">if </strong>(slot) {<br/>      <strong class="lg hj">_child </strong>= child;<br/>    } <strong class="lg hj">else </strong>{<br/>      <strong class="lg hj">_overlay </strong>= child;<br/>    }<br/>    adoptChild(child);<br/>  }<br/><br/>  <strong class="lg hj">void </strong>moveRenderObjectChild(RenderBox child, bool oldSlot, bool newSlot) {<br/>    <strong class="lg hj">if </strong>(oldSlot) {<br/>      <strong class="lg hj">_child </strong>= <strong class="lg hj">null</strong>;<br/>    } <strong class="lg hj">else </strong>{<br/>      <strong class="lg hj">_overlay </strong>= <strong class="lg hj">null</strong>;<br/>    }<br/>    <strong class="lg hj">if </strong>(newSlot) {<br/>      <strong class="lg hj">_child </strong>= child;<br/>    } <strong class="lg hj">else </strong>{<br/>      <strong class="lg hj">_overlay </strong>= child;<br/>    }<br/>  }<br/><br/>  <strong class="lg hj">void </strong>removeRenderObjectChild(RenderBox child, bool slot) {<br/>    <strong class="lg hj">if </strong>(slot) {<br/>      <strong class="lg hj">_child </strong>= <strong class="lg hj">null</strong>;<br/>    } <strong class="lg hj">else </strong>{<br/>      <strong class="lg hj">_overlay </strong>= <strong class="lg hj">null</strong>;<br/>    }<br/>    dropChild(child);<br/>  }<em class="lp"><br/></em>}</span></pre><p id="81db" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我们在这里接收的Slot的值与我们之前传递给out元素中的inflateWidget和updateChild的值相同。多亏了这个槽，我们知道哪个渲染框应该放在哪里。还要注意<strong class="jm hj"> moveRenderObjectChild </strong>方法——我们不需要从中调用<strong class="jm hj"> adoptChild </strong>或<strong class="jm hj"> dropChild </strong>,因为Child实际上被重用并且已经被附加。</p><p id="97e7" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">最后一项创新是绘画和点击测试:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6d6c" class="lk in hi lg b fi ll lm l ln lo"><strong class="lg hj">class </strong>SimpleOverlayRenderObject <strong class="lg hj">extends </strong>RenderBox {<br/>  <em class="lp">//...<br/><br/>  </em>@override<br/>  <strong class="lg hj">void </strong>paint(PaintingContext context, Offset offset) {<br/>    <strong class="lg hj">if </strong>(<strong class="lg hj">_child </strong>!= <strong class="lg hj">null</strong>) {<br/>      context.paintChild(<strong class="lg hj">_child</strong>!, offset);<br/>    }<br/>    <strong class="lg hj">if </strong>(<strong class="lg hj">_overlay </strong>!= <strong class="lg hj">null</strong>) {<br/>      context.paintChild(<strong class="lg hj">_overlay</strong>!, offset);<br/>    }<br/>  }<em class="lp"><br/><br/>  </em>@override<br/>  bool hitTestChildren(BoxHitTestResult result, {<strong class="lg hj">required </strong>Offset position}) {<br/>    <strong class="lg hj">if </strong>(<strong class="lg hj">_overlay</strong>?.hitTest(result, position: position) == <strong class="lg hj">true</strong>) {<br/>      <strong class="lg hj">return true</strong>;<br/>    }<br/>    <strong class="lg hj">if </strong>(<strong class="lg hj">_child</strong>?.hitTest(result, position: position) == <strong class="lg hj">true</strong>) {<br/>      <strong class="lg hj">return true</strong>;<br/>    }<br/>    <strong class="lg hj">return false</strong>;<br/>  }<em class="lp"><br/></em>}</span></pre><p id="0eeb" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">请注意我们叫孩子的顺序。我们最后绘制覆盖图，因为我们希望它在孩子的上方可见，但是点击测试使用相反的顺序——覆盖图应该优先。</p><p id="78c6" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这是结果:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/b28e415696e57e5e4c4fb876b8f3b2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*gf2KncvavhdjkJUQ.gif"/></div></figure><p id="2d53" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">你可以在我的GitHub上找到实现:<br/><a class="ae ls" href="https://github.com/MatrixDev/Flutter-CustomWidgets" rel="noopener ugc nofollow" target="_blank">https://github.com/MatrixDev/Flutter-CustomWidgets</a></p><p id="1559" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">希望你喜欢它！</p><h1 id="d46f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">其他文章:</h1><ul class=""><li id="4ce3" class="kn ko hi jm b jn jo jr js jv lt jz lu kd lv kh ks kt ku kv bi translated"><a class="ae ls" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-1-ellipsizedtext-a0efdc1368a8" rel="noopener">第1部分—省略文本</a></li><li id="338e" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated"><a class="ae ls" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-2-singlechildrenderobjectwidget-5637fecdf9bb" rel="noopener">第2.a部分——子女人数(带助手)</a></li><li id="720c" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated"><a class="ae ls" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-2-b-childsize-no-helpers-61c578c9bbd2" rel="noopener">第2.b部分—子女人数(无助手)</a></li><li id="7736" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated"><a class="ae ls" href="https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-3a-simpleoverlay-with-helpers-6b3990db48b6" rel="noopener">第3.a部分—简单叠加(带助手)</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Elastic Search Queries Hands-on Examples using Spring Boot and Kibana Dev Console</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot和基巴纳开发控制台的弹性搜索查询实践示例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/elastic-search-queries-hands-on-examples-fe5b2bc10c0e?source=collection_archive---------0-----------------------#2021-09-20">https://medium.com/geekculture/elastic-search-queries-hands-on-examples-fe5b2bc10c0e?source=collection_archive---------0-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事着重于弹性搜索的不同类型的查询，如匹配、术语、多匹配、正则表达式、通配符、范围、几何、多索引搜索。最后，我们将看到使用弹性搜索的高级Rest客户端的spring boot代码。</p><blockquote class="jd je jf"><p id="841c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">我在这个演示中使用了Elastic Search 7.3.0版本。</strong></p></blockquote><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/d138cf3c4bf85fd74238459e8f2b25bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6Q0QgT6aa064W3bsgGrMw.png"/></div></div></figure><p id="1efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是本教程中使用的不同类型的查询的快照</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jw"><img src="../Images/3f5f750291b06b3950a4097de2e563d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fetgIH2QwLWC1bSEJGnGg.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/e57817765faed653df82411f97b8c793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7M53qLbGMCQeEdjCegvYQ.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/cd7dfb8aacec0b53772bba13e1f8a213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgS5Hn_jtFfOEwox2_d6Jg.png"/></div></div></figure><p id="ac4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经设置了一个spring boot应用程序，将数据加载到弹性搜索中，数据有各种类型的搜索过滤器。在我的本地弹性搜索集群中，这两个指数都有大约300万个数据。</p><blockquote class="jd je jf"><p id="8e48" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在查询和加载数据之前，建议从Kibana查询控制台创建索引</p></blockquote><h1 id="06e0" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">数据模型</h1><p id="fb2d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我创建了一个简单的spring boot应用程序来加载数据。请访问<a class="ae lb" href="https://github.com/ereshzealous/spring-cloud-stream-examples/tree/main/elastic-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>链接，从docker设置加载弹性搜索和Kibana控制台，并将数据加载到弹性搜索中。</p><p id="3c46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个动手练习中，我定义了两个索引<code class="du lc ld le lf b">user</code>和<code class="du lc ld le lf b">user_address</code>。</p><h2 id="2b88" class="lg jz hi bd ka lh li lj ke lk ll lm ki iq ln lo km iu lp lq kq iy lr ls ku lt bi translated">用户索引</h2><p id="d557" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">检查用户索引映射文件是<a class="ae lb" href="https://github.com/ereshzealous/spring-cloud-stream-examples/blob/main/elastic-demo/src/main/resources/es/user_index.json" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lu"><img src="../Images/2f7222cd21c3775d1c8756c4b20f01fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3VT6_GAGSATjK3IMVkgyQ.png"/></div></div></figure><h2 id="0b0b" class="lg jz hi bd ka lh li lj ke lk ll lm ki iq ln lo km iu lp lq kq iy lr ls ku lt bi translated">用户地址索引</h2><p id="41df" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">从<a class="ae lb" href="https://github.com/ereshzealous/spring-cloud-stream-examples/blob/main/elastic-demo/src/main/resources/es/user_address_index.json" rel="noopener ugc nofollow" target="_blank">这里</a>检查用户地址索引映射文件。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lv"><img src="../Images/d6fcc26d45a3205c163dbf755248e1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0uImsqbABIDf14G-Y6rdQ.png"/></div></div></figure><h1 id="d0fa" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一些共同特征</h1><blockquote class="jd je jf"><p id="baec" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><code class="du lc ld le lf b">text</code>数据类型和<code class="du lc ld le lf b">keyword</code>数据类型之间的主要区别是<code class="du lc ld le lf b">text</code>字段在索引时被分析，而<code class="du lc ld le lf b">keyword</code>字段不被分析。这意味着，<code class="du lc ld le lf b">text</code>字段在索引时被分解成它们各自的术语，以允许部分匹配，而<code class="du lc ld le lf b">keyword</code>字段按原样被索引。</p></blockquote><h1 id="4078" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">匹配查询</h1><p id="572e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">“匹配”查询是Elasticsearch中最基本和最常用的查询之一，其功能相当于全文查询。我们可以使用这个查询来搜索文本、数字或布尔值。</p><p id="dce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">匹配查询接受文本/数字/日期，分析它们，并构造一个查询。匹配查询属于布尔类型。这意味着对所提供的文本进行分析，并且分析过程从所提供的文本中构造一个布尔查询。运算符标志可以设置为or和，以控制布尔子句(默认为or)。要匹配的可选should子句的最小数量可以使用minimum_should_match参数来设置。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="5a91" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "match": {<br/>      "phrase": {<br/>        <strong class="lf hj">"query": "kL5fP"</strong><br/>      }<br/>    }<br/>  },<br/>  <strong class="lf hj">"highlight": {<br/>    "fields": {<br/>      "phrase": {}<br/>    }<br/>  }</strong><br/>}<br/>----------------------------------------------------------------<br/><strong class="lf hj"><em class="jg">There are 19 results, but minified to show only 1.</em></strong></span><span id="1629" class="lg jz hi lf b fi me mb l mc md">{<br/>  "took" : 3,<br/>  "timed_out" : false,<br/>  "_shards" : {<br/>    "total" : 2,<br/>    "successful" : 2,<br/>    "skipped" : 0,<br/>    "failed" : 0<br/>  },<br/>  "hits" : {<br/>    "total" : {<br/>      "value" : 19,<br/>      "relation" : "eq"<br/>    },<br/>    "max_score" : 11.733445,<br/>    "hits" : [<br/>      {<br/>        "_index" : "user",<br/>        "_type" : "_doc",<br/>        "_id" : "e9a6dbf4-c6a6-46ce-9049-729f4bb64407",<br/>        "_score" : 11.733445,<br/>        "_source" : {<br/>          "_class" : "com.elastic.demo.entity.User",<br/>          "id" : "e9a6dbf4-c6a6-46ce-9049-729f4bb64407",<br/>          "firstName" : "URuMyV",<br/>          "lastName" : "XbonCWM",<br/>          "uniqueId" : "ALHNQSOVOJWFN0I1",<br/>          "country" : "India",<br/>          "city" : "Hyderabad",<br/>          "mobileNumber" : "61623020652",<br/>          "point" : [<br/>            77.27123,<br/>            16.5898<br/>          ],<br/>          "maritalStatus" : "Divorced",<br/>          "numberOfSiblings" : 2,<br/>          "siblings" : [<br/>            "itsZzh kMBKlT",<br/>            "RNrFfJ oBZGSEcd"<br/>          ],<br/>          "profession" : "Banker",<br/>          "income" : 411516,<br/>          "phrase" : "oGRUxB yr72CdCt yZqQb kL5fP",<br/>          "nativeResident" : true,<br/>          "dateOfBirth" : 103573800000,<br/>          "createdOn" : 1570885284000<br/>        },<br/>        <strong class="lf hj">"highlight" : {<br/>          "phrase" : [<br/>            "oGRUxB yr72CdCt yZqQb &lt;em&gt;kL5fP&lt;/em&gt;"<br/>          ]<br/>        }</strong><br/>      }<br/>   ]<br/>}</span></pre><h1 id="634f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">多匹配查询</h1><p id="16e1" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">multi_match查询建立在match查询的基础上，允许多字段查询。</p><p id="420f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">多匹配查询的类型</em> </strong> <br/>多匹配查询在内部执行的方式取决于type参数，可以设置为:</p><p id="032c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg"> best_fields: </em> </strong>(默认)查找匹配任何字段的文档，但使用最佳字段的_score。参见best_fields。<br/>best _ fields类型在搜索同一个字段中的多个最佳单词时最有用。例如，一块地里的“棕色狐狸”比一块地里的“棕色”和另一块地里的“狐狸”更有意义。</p><p id="9a16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg"> most_fields: </em> </strong>查找匹配任何字段的文档，并组合每个字段的_score。查看most_fields。<br/>当查询包含以不同方式分析的相同文本的多个字段时，most_fields类型最有用。例如，主字段可能包含同义词、词干和不带发音符号的术语。第二个字段可能包含原始术语，第三个字段可能包含术语。通过组合所有三个字段的分数，我们可以将尽可能多的文档与主字段匹配，但使用第二个和第三个字段将最相似的结果推到列表的顶部。</p><p id="4cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jg">cross _ fields:</em></strong>用相同的分析器将字段视为一个大字段。在任何字段中查找每个单词。请参见交叉字段。<br/>cross _ fields类型对于多个字段应该匹配的结构化文档特别有用。例如，当查询“威尔·史密斯”的“名字”和“姓氏”字段时，最佳匹配可能是一个字段中有“Will ”,另一个字段中有“Smith”。</p><p id="8d62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">短语:</em> </strong>对每个字段运行<em class="jg"> match_phrase </em>查询，并使用来自最佳字段的<em class="jg"> _score </em>。参见短语和<em class="jg">短语_前缀</em>。<br/><em class="jg">短语</em>和<em class="jg">短语前缀</em>类型的行为就像<em class="jg">最佳字段</em>，但是它们使用<em class="jg">匹配短语</em>或<em class="jg">匹配短语前缀</em>查询，而不是匹配查询。</p><p id="952d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">默认行为:</strong> <em class="jg">在mobileNumber、firstName、lastName和uniqueId上搜索最佳匹配(全文搜索)。</em></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="698f" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "multi_match": {<br/>      "query": "HyWHrsVr",<br/>      "fields": ["mobileNumber", "firstName", "lastName", "uniqueId"]<br/>    }<br/>  }<br/>}</span></pre><p id="45d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Phase_prefix: </strong> <em class="jg">在<em class="jg"> mobileNumber、firstName、lastName和uniqueId上搜索前缀匹配(</em> <strong class="ih hj"> <em class="jg"> hywh </em> * </strong>)。</em></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="825f" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "multi_match": {<br/>      "query": "hywh",<br/>      "type": "phrase_prefix", <br/>      "fields": ["mobileNumber", "firstName", "lastName", "uniqueId"]<br/>    }<br/>  }<br/>}</span></pre><h1 id="8b98" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">术语查询/术语查询</h1><p id="e12a" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">有时，我们对结构化搜索更感兴趣，在这种搜索中，我们希望找到精确的匹配并返回结果。术语和术语查询在这里对我们有帮助。在下面的例子中，我们在索引中搜索职业为<code class="du lc ld le lf b">Singer</code>的所有用户。返回在提供的字段中包含精确术语的文档。您可以使用术语查询根据精确的值(如价格、产品ID或用户名)来查找文档。</p><blockquote class="jd je jf"><p id="51c6" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">注意:<br/>避免对文本字段使用术语查询。默认情况下，作为分析的一部分，Elasticsearch会更改文本字段的值。这使得查找文本字段值的精确匹配变得困难。<br/>要搜索文本字段值，请使用匹配查询。</p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="8349" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "term": {<br/>      "profession.keyword": "Singer"<br/>    }<br/>  }<br/>}<br/>------- <br/>Will return results</span></pre><blockquote class="jd je jf"><p id="e44a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">我们在这里使用<code class="du lc ld le lf b">Keyword</code>的原因是为了搜索一个精确的单词。如果不使用<code class="du lc ld le lf b">keyword</code>，我们必须搜索<code class="du lc ld le lf b">search criteria in lower case</code>。</p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="c35d" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "term": {<br/>      "profession": "Singer"<br/>    }<br/>  }<br/>}<br/><strong class="lf hj">Will not return results<br/>-------------------------------------------------------------<br/></strong>GET user/_search<br/>{<br/>  "query": {<br/>    "term": {<br/>      "profession": "singer".<br/>    }<br/>  }<br/>}<br/><strong class="lf hj">Will return results.</strong></span></pre><p id="d8b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以借助<strong class="ih hj"> <em class="jg">术语，通过多个查询字符串进行搜索。</em> </strong>我们将提炼上述职业为<code class="du lc ld le lf b">Singer</code>和<code class="du lc ld le lf b">Farmer</code>的查询。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="032e" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "terms": {<br/>      "profession.keyword": ["Singer", "Farmer"]<br/>    }<br/>  }<br/>}</span></pre><h1 id="2503" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">布尔查询</h1><p id="e32d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">AND/OR/NOT运算符可用于微调我们的搜索查询，以便提供更相关或更具体的结果。这在搜索API中作为bool查询实现。bool查询接受一个must参数(相当于AND)、一个must_not参数(相当于not)和一个should参数(相当于OR)。</p><p id="eaf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">匹配与其他查询的布尔组合相匹配的文档的查询。bool查询映射到Lucene BooleanQuery。它是使用一个或多个布尔子句构建的，每个子句都有一个类型化的出现。事件类型有</p><p id="1ff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">必须:</strong> <em class="jg">该子句(查询)必须出现在匹配的文档中，并且将有助于得分。</em></p><p id="3feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">筛选:</strong> <em class="jg">该子句(查询)必须出现在匹配的单据中。然而，与</em> <code class="du lc ld le lf b"><em class="jg">must</em></code> <em class="jg">不同的是，查询的分数会被忽略。筛选子句在筛选上下文中执行，这意味着评分被忽略，子句被考虑用于缓存。</em></p><p id="bf0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应该:</strong>T25】该子句(查询)应该出现在匹配的文档中。如果bool查询在查询上下文中，并且有一个must或filter子句，那么一个文档将匹配bool查询，即使没有一个should查询匹配。在这种情况下，这些子句仅用于影响分数。如果bool查询在一个过滤器上下文中，或者既没有must也没有filter，那么至少应该有一个should查询匹配一个文档才能匹配bool查询？这种行为可以通过设置minimum_should_match参数来明确控制。</p><p id="449a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> must_not: </strong> <em class="jg">该子句(查询)不能出现在匹配的单据中。子句在过滤器上下文中执行，这意味着评分被忽略，子句被考虑用于缓存。因为评分被忽略，所以所有文档都返回0分。</em></p><blockquote class="jd je jf"><p id="db29" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">例如:如果我想搜索用户的职业是<code class="du lc ld le lf b">Athelete</code>，婚姻状况是<code class="du lc ld le lf b">married</code>，手机号码与<code class="du lc ld le lf b">12360</code>匹配。<strong class="ih hj">必须作为and操作符</strong></p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="e257" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "must": [<br/>        {<br/>          "match": {<br/>            "profession": "Athlete"<br/>          }<br/>        },<br/>        {<br/>          "wildcard": {<br/>            "mobileNumber.keyword": "*12360*"<br/>          }<br/>        },<br/>        {<br/>          "match": {<br/>            "maritalStatus": "Married"<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><h1 id="1a26" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">通配符</strong></h1><p id="d00c" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">返回包含匹配通配符模式的术语的文档。通配符运算符是匹配一个或多个字符的占位符。例如，*通配符运算符匹配零个或多个字符。您可以将通配符运算符与其他字符组合起来创建通配符模式。</p><blockquote class="jd je jf"><p id="16f9" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在7.10.0中添加了不区分大小写的[7 . 10 . 0]。<br/>(可选，布尔值)设置为true时，允许模式与索引字段值不区分大小写的匹配。默认值为false，这意味着匹配是否区分大小写取决于基础字段的映射。</p></blockquote><p id="7351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想通过名字匹配<code class="du lc ld le lf b">abc</code>或姓氏匹配<code class="du lc ld le lf b">abc</code>或唯一ID匹配<code class="du lc ld le lf b">abc</code>来搜索用户。它是由OR运算符进行的逻辑分组。</p><blockquote class="jd je jf"><p id="ec8b" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">对于7.10.0以下版本，不要使用不区分大小写的关键字，也不要在索引创建期间进行规范化。</p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="7ea3" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "should": [<br/>        {<br/>          "wildcard": {<br/>            "firstName": "*abc*"<br/>          }<br/>        },<br/>        {<br/>          "wildcard": {<br/>            "lastName": "*abc*"<br/>            <br/>          }<br/>        },<br/>        {<br/>          "wildcard": {<br/>            "uniqueId": "*abc*"<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><h1 id="e483" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">正则表达式查询</h1><p id="6f47" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">返回包含匹配正则表达式的术语的文档。</p><p id="2e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正则表达式是一种使用占位符(称为运算符)来匹配数据模式的方法。有关regexp查询支持的运算符列表，请参见<a class="ae lb" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html" rel="noopener ugc nofollow" target="_blank">正则表达式语法</a>。</p><p id="64b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们查询用户索引，以获得其兄弟具有正则表达式<code class="du lc ld le lf b">e[a-z]*h</code>的用户列表。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="3434" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "regexp": {<br/>      "siblings": "e[a-z]*h"<br/>    }<br/>  },<br/>  "_source": ["siblings", "id"],<br/>    "highlight": {<br/>        "fields" : {<br/>            "siblings": {}<br/>        }<br/>    }<br/>}<br/>----------------------------------------------------<br/>Just one result for understanding, This query resulted around 5k documents.<br/>{<br/>        "_index" : "user",<br/>        "_type" : "_doc",<br/>        "_id" : "00159cc8-313c-4492-a5b9-ebaf884ca0e2",<br/>        "_score" : 1.0,<br/>        "_source" : {<br/>          "siblings" : [<br/>            "hcbKUQCki juVLjF",<br/>            "KYSuPQM jTraY",<br/>            "eMDTLh gGgSY"<br/>          ],<br/>          "id" : "00159cc8-313c-4492-a5b9-ebaf884ca0e2"<br/>        },<br/>        "highlight" : {<br/>          "siblings" : [<br/>            "&lt;em&gt;eMDTLh&lt;/em&gt; gGgSY"<br/>          ]<br/>        }<br/>      }</span></pre><h1 id="0296" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">查询字符串</h1><p id="d0a0" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">使用语法严格的解析器，根据提供的查询字符串返回文档。该查询使用语法根据运算符(如and或NOT)解析和拆分提供的查询字符串。然后，在返回匹配的文档之前，查询会独立分析每个拆分的文本。</p><p id="d09a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用query_string查询创建包含通配符的复杂搜索、跨多个字段的搜索等等。虽然该查询是通用的，但它是严格的，如果查询字符串包含任何无效语法，它将返回一个错误。</p><blockquote class="jd je jf"><p id="d7e8" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">查询中~的用法表示模糊查询的用法</p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="c42a" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "query_string": {<br/>      "query": "saad~1 or zojmi~1", -- Skips one word during search.<br/>      "fields": ["lastName", "firstName"]<br/>    }<br/>  },<br/>  "highlight": {<br/>        "fields" : {<br/>            "maritalStatus": {}<br/>        }<br/>    }<br/>}<br/>------------------------------<br/>{<br/>        "_index" : "user",<br/>        "_type" : "_doc",<br/>        "_id" : "0e167d85-281a-4b6a-ab0b-8fc9f496245a",<br/>        "_score" : 10.263874,<br/>        "_source" : {<br/>          "_class" : "com.elastic.demo.entity.User",<br/>          "id" : "0e167d85-281a-4b6a-ab0b-8fc9f496245a",<br/>          "firstName" : "ZOjLi",<br/>          "lastName" : "ROmwpwGE"<br/>        },<br/>        <strong class="lf hj">"highlight" : {<br/>          "firstName" : [<br/>            "&lt;em&gt;ZOjLi&lt;/em&gt;" - Here m is replaced by i. still search is successful becuase of fuzzy logic.<br/>          ]<br/>        }</strong><br/>      }</span></pre><h1 id="9839" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">简单查询字符串</h1><p id="53e1" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">simple_query_string查询是query_string查询的一个版本，它更适合在向用户公开的单个搜索框中使用，因为它分别用+/|/-替换了和/或/NOT，并且它会丢弃查询的无效部分，而不是在用户出错时引发异常。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="33cc" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "query_string": {<br/>      "query": "saad~1 | zojmi~1", -- Skips one word during search.<br/>      "fields": ["lastName", "firstName"]<br/>    }<br/>  },<br/>  "highlight": {<br/>        "fields" : {<br/>            "maritalStatus": {}<br/>        }<br/>    }<br/>}</span></pre><h1 id="dfd9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">范围查询</strong></h1><p id="ecf7" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">Elasticsearch世界中另一个最常用的查询是范围查询。范围查询允许我们获取包含指定范围内的术语的文档。范围查询是术语级别的查询(意味着使用来查询结构化数据)，可用于数字字段、日期字段等。</p><p id="0a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">数值字段:</em> </strong>查询收入≥ 100000且≤ 500000的用户。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="c038" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "range": {<br/>      "income": {<br/>        "gte": 100000,<br/>        "lte": 500000<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="fe76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">关于日期字段:</em> </strong>日期字段，可以多种格式存储。请访问此处的<a class="ae lb" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html" rel="noopener ugc nofollow" target="_blank">了解更多详情</a>。默认情况下，它是纪元毫秒。我用过同样的格式。即使它是以纪元格式存储的，我们也可以用支持的日期/日期时间格式查询数据。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="f54f" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>        "range" : {<br/>            "dateOfBirth": {<br/>                "gte": "2001-08-01",<br/>                "lte": "2001-12-31"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="5539" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">地理字段查询</h1><p id="2208" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在用户索引中，字段点被创建为geo_point。地理字段还有许多其他选项。我将在这个领域创建一个更详细的博客。目前，我们已将Geo_point创建为[lon，lat]。我们将查询特定位置半径1公里以内的位置。</p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="6495" class="lg jz hi lf b fi ma mb l mc md">GET user/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "must": {<br/>        "match_all": {}<br/>      },<br/>      "filter": {<br/>        "geo_distance": {<br/>          "distance": "1km",<br/>          "point": [79.7397, 15.684453142518711]<br/>        <br/>        }<br/>      }<br/>    }</span></pre><h1 id="e2ce" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">多索引搜索</h1><p id="25ad" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">多重搜索API允许在同一个API中执行多个搜索请求。它的终点是<code class="du lc ld le lf b">_msearch</code>。</p><blockquote class="jd je jf"><p id="0416" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">用例:我们有两个索引，<code class="du lc ld le lf b">user</code>和<code class="du lc ld le lf b">user_address</code>。在传统的RDBMS中，user和user_address表通过外键约束进行链接。我们必须连接两个表来查找用户及其相关地址。我们如何在弹性搜索中实现这一点</p></blockquote><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="3a9a" class="lg jz hi lf b fi ma mb l mc md">GET default/_msearch<br/>{"index" : "user"}<br/>{"query": {"bool": {"must": [{"match": {"id.keyword": "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d"}}]}}}<br/>{"index" : "user_address"}<br/>{"query": {"bool": {"must": [{"match": {"userId.keyword": "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d"}}]}}}<br/>---------------------------------------------------------------<br/>{<br/>  "took" : 22,<br/>  "responses" : [<br/>    {<br/>      "took" : 22,<br/>      "timed_out" : false,<br/>      "_shards" : {<br/>        "total" : 2,<br/>        "successful" : 2,<br/>        "skipped" : 0,<br/>        "failed" : 0<br/>      },<br/>      "hits" : {<br/>        "total" : {<br/>          "value" : 1,<br/>          "relation" : "eq"<br/>        },<br/>        "max_score" : 12.832057,<br/>        "hits" : [<br/>          {<br/>            "_index" : "user",<br/>            "_type" : "_doc",<br/>            "_id" : "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d",<br/>            "_score" : 12.832057,<br/>            "_source" : {<br/>              "_class" : "com.elastic.demo.entity.User",<br/>              "id" : "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d",<br/>              "firstName" : "iUWvggrjb",<br/>              "lastName" : "PwZSA",<br/>              "uniqueId" : "YQWRQH2NVROOTC3R",<br/>              "country" : "India",<br/>              "city" : "Hyderabad",<br/>              "mobileNumber" : "73642600218",<br/>              "point" : [<br/>                76.49461,<br/>                16.46887<br/>              ],<br/>              "maritalStatus" : "Widowed",<br/>              "numberOfSiblings" : 1,<br/>              "siblings" : [<br/>                "pqHpPibr KKcXioB"<br/>              ],<br/>              "profession" : "Actor",<br/>              "income" : 209060,<br/>              "phrase" : "6q0y1uOgDZD VG6bWkUGT uGlRAJ RICgp",<br/>              "nativeResident" : false,<br/>              "dateOfBirth" : -110525400000,<br/>              "createdOn" : 1563241250000<br/>            }<br/>          }<br/>        ]<br/>      },<br/>      "status" : 200<br/>    },<br/>    {<br/>      "took" : 22,<br/>      "timed_out" : false,<br/>      "_shards" : {<br/>        "total" : 2,<br/>        "successful" : 2,<br/>        "skipped" : 0,<br/>        "failed" : 0<br/>      },<br/>      "hits" : {<br/>        "total" : {<br/>          "value" : 2,<br/>          "relation" : "eq"<br/>        },<br/>        "max_score" : 13.525113,<br/>        "hits" : [<br/>          {<br/>            "_index" : "user_address",<br/>            "_type" : "_doc",<br/>            "_id" : "a4dd76f1-7003-4ab7-876a-a87646101f4d",<br/>            "_score" : 13.525113,<br/>            "_source" : {<br/>              "_class" : "com.elastic.demo.entity.UserAddress",<br/>              "id" : "a4dd76f1-7003-4ab7-876a-a87646101f4d",<br/>              "userId" : "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d",<br/>              "address1" : "LcjcBGazLfGHAzNMxcnskeSaP",<br/>              "address2" : "xeDrDTPhNDDYZJR",<br/>              "street" : "iVmGEclcCBLoTdfzQdhK",<br/>              "landmark" : "dyHKqajaFaGJSsa",<br/>              "city" : "Hyderabad",<br/>              "state" : "Telangana",<br/>              "zipCode" : "271066",<br/>              "createdOn" : 1571685580000<br/>            }<br/>          },<br/>          {<br/>            "_index" : "user_address",<br/>            "_type" : "_doc",<br/>            "_id" : "455634b6-0996-4a1c-8e9d-3a9172eae01f",<br/>            "_score" : 13.523252,<br/>            "_source" : {<br/>              "_class" : "com.elastic.demo.entity.UserAddress",<br/>              "id" : "455634b6-0996-4a1c-8e9d-3a9172eae01f",<br/>              "userId" : "e25b9ecf-b6fa-4ef4-a5df-2fc7dd62691d",<br/>              "address1" : "qBcBGHtnYmsCZSYINqFMHJpfB",<br/>              "address2" : "khTLQUhsipHzGRy",<br/>              "street" : "xcnTmHhyzJCNVqUPYSoo",<br/>              "landmark" : "YxgEMZHGAxPDKly",<br/>              "city" : "Hyderabad",<br/>              "state" : "Telangana",<br/>              "zipCode" : "054947",<br/>              "createdOn" : 1565102726000<br/>            }<br/>          }<br/>        ]<br/>      },<br/>      "status" : 200<br/>    }<br/>  ]<br/>}</span></pre></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="3186" class="jy jz hi bd ka kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv bi translated">Spring Boot的弹性搜索</h1><p id="2b08" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">到目前为止，我们已经看到了如何使用dev控制台从弹性搜索中查询数据。现在我们将看看如何使用Spring Boot来实现它。</p><p id="6a27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从<a class="ae lb" href="https://github.com/ereshzealous/spring-cloud-stream-examples/tree/main/elastic-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到完整的源代码。</p><p id="7abe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用弹性搜索<strong class="ih hj"><em class="jg">HighLevelRestClient</em></strong>编写查询并从弹性搜索中获取结果。我们也可以直接使用来自Elastic Search的API，但是使用SDK始终是首选。</p><p id="77bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包含依赖关系</strong></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="184b" class="lg jz hi lf b fi ma mb l mc md">plugins {<br/>    id 'org.springframework.boot' version '2.5.4'<br/>    id 'io.spring.dependency-management' version '1.0.11.RELEASE'<br/>    id 'java'<br/>}<br/><br/>group = 'com.elastic.demo'<br/>version = '0.0.1-SNAPSHOT'<br/>sourceCompatibility = '11'<br/><br/>configurations {<br/>    compileOnly {<br/>        extendsFrom annotationProcessor<br/>    }<br/>}<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch'<br/>    implementation group: 'org.elasticsearch.client', name: 'elasticsearch-rest-high-level-client', version: '7.3.0'<br/>    implementation group: 'org.springdoc', name: 'springdoc-openapi-ui', version: '1.5.10'<br/>    implementation group: 'org.elasticsearch', name: 'elasticsearch', version: '7.3.0'<br/>    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.11'<br/>    implementation 'org.springframework.boot:spring-boot-starter-web'<br/>    compileOnly 'org.projectlombok:lombok'<br/>    annotationProcessor 'org.projectlombok:lombok'<br/>    testImplementation 'org.springframework.boot:spring-boot-starter-test'<br/>}<br/><br/>test {<br/>    useJUnitPlatform()<br/>}</span></pre><p id="f9c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">配置弹性搜索</strong></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="b101" class="lg jz hi lf b fi ma mb l mc md">@Configuration<br/>@Slf4j<br/>public class ElasticSearchConfiguration {<br/><br/>   @Bean(name = "highLevelClient", destroyMethod = "close")<br/>   public RestHighLevelClient client(){<br/>      RestClientBuilder builder = RestClient.<em class="jg">builder</em>(new HttpHost("localhost", 9200, "http"));<br/>      builder.setRequestConfigCallback(requestConfigBuilder -&gt; requestConfigBuilder.setConnectTimeout(600 * 1000).setSocketTimeout(600 * 1000)<br/>                                                                                   .setConnectionRequestTimeout(-1));<br/><br/>      RestHighLevelClient client = new RestHighLevelClient(builder);<br/>      return client;<br/>   }<br/>}</span></pre><p id="0b96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">弹性搜索连接代理</strong></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="20b9" class="lg jz hi lf b fi ma mb l mc md">@Service<br/>@Slf4j<br/>@RequiredArgsConstructor<br/>public class HighLevelRestClient {<br/><br/>   private final RestHighLevelClient restHighLevelClient;<br/><br/>   @SneakyThrows<br/>   public SearchResponse postSearchQueries(SearchRequest searchRequest) {<br/>      <em class="jg">log</em>.info("Search JSON query: {}", searchRequest.source().toString());<br/>      return restHighLevelClient.search(searchRequest, RequestOptions.<em class="jg">DEFAULT</em>);<br/>   }<br/><br/>   @SneakyThrows<br/>   public MultiSearchResponse postMSearch(MultiSearchRequest multiSearchRequest) {<br/>      <em class="jg">log</em>.info("Search JSON query: {}", multiSearchRequest.requests().toString());<br/>      return restHighLevelClient.msearch(multiSearchRequest, RequestOptions.<em class="jg">DEFAULT</em>);<br/>   }<br/>}</span></pre><p id="c53f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">查询数据的示例服务方法</strong></p><pre class="jl jm jn jo fd lw lf lx ly aw lz bi"><span id="2652" class="lg jz hi lf b fi ma mb l mc md">public WSUsersResponse searchDateRange(String fromDate, String toDate, Integer offset, Integer limit) {<br/>   SearchRequest searchRequest = new SearchRequest();<br/>   searchRequest.indices("user");<br/>   SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();<br/>   sourceBuilder.from(offset);<br/>   sourceBuilder.size(limit);<br/>   sourceBuilder.query(QueryBuilders.<em class="jg">rangeQuery</em>("dateOfBirth").gte(fromDate).lte(toDate));<br/>   searchRequest.source(sourceBuilder);<br/>   SearchResponse searchResponse = highLevelRestClient.postSearchQueries(searchRequest);<br/>   <em class="jg">log</em>.info("Search JSON query: {}", searchRequest.source().toString());<br/>   return extractUserResponse(searchResponse);<br/>}</span></pre></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="eefe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，还有npm模块、go模块也可用于从弹性搜索中查询数据。它们非常简单。典型的部分是弄清楚如何从弹性搜索中查询数据，使用任何语言或框架的实际实现都非常简单。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Convolutional Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/convolutional-neural-networks-ab4b24d1f916?source=collection_archive---------27-----------------------#2021-09-14">https://medium.com/geekculture/convolutional-neural-networks-ab4b24d1f916?source=collection_archive---------27-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4c0654a803fa3bdab7664352c4af3125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Bp2w5vGD-DeIeCzXEUm9KA.jpeg"/></div></figure><h1 id="c14e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">内容</strong></h1><ul class=""><li id="6ad4" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="jm hj">T3】简介T5】</strong></li><li id="5fdf" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">通用架构</em> </strong></li><li id="ea3a" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">卷积块</em> </strong></li><li id="2ce5" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">卷积运算</em> </strong></li><li id="3093" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">统筹操作</em> </strong></li><li id="6d2c" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">填充操作</em> </strong></li><li id="c787" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">大步走法</em> </strong></li><li id="d53c" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">从头实现CNN</em></strong></li><li id="d55c" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">计算每层的参数个数</em> </strong></li><li id="ff95" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><strong class="jm hj"> <em class="kc">结论和进一步的来源</em> </strong></li></ul></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="2d69" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak">简介</strong></h2><p id="db81" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">卷积神经网络是一种主要用于图像、语音和音频输入的神经网络。CNN对于处理图像和使用卷积运算从图像中提取特征非常有用。主要应用领域包括图像分类、对象检测和图像分割(语义分割和实例分割)。</p><h2 id="a910" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak">CNN的总体架构</strong></h2><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es ls"><img src="../Images/5870f779f915091f0504f7cf25061161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEqmrCFhgpgyUQRDlZ9uZA.jpeg"/></div></div><figcaption class="mb mc et er es md me bd b be z dx">fig1 : CNN architecture</figcaption></figure><p id="f9f1" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">卷积神经网络有两个部分，即特征学习和分类部分。在特征学习部分，我们有许多卷积块，通常每个这样的conv块包括三个操作，即卷积、激活和汇集。CNN模型可以有许多卷积块和完全连接的层，这取决于网络设计。对于每个卷积层，我们需要指定滤波器的数量。过滤器检测模式包括——边缘、形状、纹理、曲线、物体、颜色等。分类部分有前馈神经网络。CNN在训练时学习内核参数。所以我们不需要为特定的特征提取手动设计内核。</p><h2 id="a0a0" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak"> <em class="mk">卷积运算和</em> </strong>内核运算</h2><p id="9cd9" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">在图像处理领域，人们使用手动定义的核或滤波器进行图像去噪、变换等。但是在CNN的上下文中，内核在训练期间是可训练的。最初，我们为过滤器(内核)中的每个参数取随机权重，并使用反向传播获得每个参数的优化参数值。我们在卷积中做什么？它只是内核值和图像不同区域之间的一系列点积。为了捕捉输入图像的所有部分，我们在图像上滑动内核窗口。与卷积层相关联的滤波器滑过来自输入的每组3*3像素。重复该过程，直到滤波器覆盖所有3×3像素块。这种滑动被称为<strong class="jm hj">卷积。</strong>点积的结果存储在输出中，称为特征图。现在考虑下图，它显示了使用内核时卷积是如何发生的。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es ml"><img src="../Images/707653763a6fd4a2e326c56061016d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D6iRfzDkz-sEzyjYoVZ73w.gif"/></div></div><figcaption class="mb mc et er es md me bd b be z dx">fig 2: convolution process</figcaption></figure><p id="7ee6" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">我们可以有许多不同的核用于特征提取(垂直边缘、曲线、边界等)。).在特征图中，高点积表示输入图像相对于核算子的良好匹配部分。那么怎么处理特征图呢？</p><h2 id="ceb0" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak"> <em class="mk">汇集操作</em> </strong></h2><p id="3432" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">卷积运算后得到的特征图对输入图像中特征的位置很敏感。为了解决这种敏感性，我们使用池对特征图进行下采样。因此所得到的下采样特征对于输入图像中特征位置的变化将更加鲁棒(局部平移不变性)。由于输入的维数很大，我们需要执行许多乘法运算。但幸运的是，通过池化，我们在训练时需要的计算量更少。有各种各样的池，最大池和平均池是常见的选择。在汇集中，我们在特征图中取一个小区域，如果它是最大汇集，则取最大值，如果我们应用平均汇集，则取所选区域中值的平均值。让我们考虑下图来理解我们如何在特征图上进行最大池化。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mm"><img src="../Images/e5d85c8394b1b2db8bf7c0946f6ca6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va0N-TjL4Um7tIyPRQPsug.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx">fig3 : max pooling and average pooling</figcaption></figure><h2 id="bb1d" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak"> <em class="mk">填充操作</em> </strong></h2><p id="9884" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">填充是向输入图像添加额外的零像素集的过程，以避免卷积运算期间的信息丢失。填充通过将信息保留在边界来帮助提高性能。如果我们不使用填充，那么卷的大小会很快减小，信息会很快被洗掉。</p><ul class=""><li id="0d6e" class="jk jl hi jm b jn mf jp mg jr mn jt mo jv mp jx jy jz ka kb bi translated">深度学习中有三种填充，即有效填充、相同填充和完全填充。有效填充意味着根本没有填充。相同的填充将在卷积后保持图像大小。完全填充确保所有像素对输出具有相同的影响。在这种情况下，输出大于输入。</li></ul><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mq"><img src="../Images/dc0d1704a3dd2671b76584f098ff96ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJ_u25GlJzLmmYOt9ZvL2Q.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx">fig 4: padding ( 2 layer)</figcaption></figure><h2 id="6c36" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak"> <em class="mk">大步走法</em> </strong></h2><p id="fd4d" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">在步进卷积中，我们将窗口移动一个以上的像素范围。如果步幅是2，那么内核将在图像上滑动2个像素(行或列)。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/b0f9c9f8eb8b7a05c1b2a654351a1409.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/1*4JElZq2OxFGVXiwBfnIlFg.gif"/></div><figcaption class="mb mc et er es md me bd b be z dx">fig 5; convolution with stride = 1</figcaption></figure><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/8d0c8d79ca7ffa7b613f2c4923420c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/1*1VJDP6qDY9-ExTuQVEOlVg.gif"/></div><figcaption class="mb mc et er es md me bd b be z dx">fig 6: convolution with stride = 2</figcaption></figure><h2 id="2e55" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated">缩放、批量标准化和丢弃</h2><p id="421a" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">通过将每个输入像素除以255来进行缩放或归一化。因此，规范化是指将所有值统一到0到1的范围内。相似的尺度特征将导致更快地获得梯度下降。</p><p id="3d12" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">批量规范化有助于我们提高训练速度、性能、稳定性和稳定性。批量标准化应用于我们选择应用的图层。第一批norm做的是标准化激活函数的输出。在规范化之后，batch norm将这个规范化的输出乘以某个任意参数，然后向其添加另一个任意参数。使用两个任意参数的计算为数据设置了新的标准偏差和平均值。这四个参数都是可训练的。该过程使得网络内的权重不会因为极高或极低的值而变得不平衡，因为归一化包括在梯度过程中。使用批量规范，我们还在网络内进行了规范化。批次标准化以批次为基础进行。</p><p id="0a02" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">辍学有助于减少过度拟合。在小数据集上训练的神经网络可能导致过拟合。在训练期间，大量的层输出被随机忽略或丢弃。在神经网络中，每一层都实现了丢失。</p><h2 id="bf9a" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak">全连接层</strong></h2><p id="d759" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">在每个卷积层之后，我们的输入数据得到大量的维度。我们在所有卷积之后使参数变平，然后设计前馈网络。我们可以有许多完全连接的层。在最后的层中，如果我们处理多类分类问题，我们使用SoftMax激活函数，如果我们处理二元分类问题，则使用sigmoid。在下一节中，让我们使用keras创建一个卷积神经网络。</p><h1 id="d896" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">使用keras实现卷积神经网络</strong></h1><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="mt mu l"/></div><figcaption class="mb mc et er es md me bd b be z dx">gist 1 : model class</figcaption></figure><p id="2693" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">现在让我们总结一下模型，并分析每一层的参数。下图显示了模型(网络)摘要。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/c6d567edc3487a54dbc0316bbe1eaeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*A79jXQCECVBP33z0xOyRsg.png"/></div><figcaption class="mb mc et er es md me bd b be z dx">fig 7 : model summary</figcaption></figure><p id="276c" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">我们可以看到输入图像形状为(224，224，3)，因此这里我们有一个三通道图像。在输入层，我们没有任何参数。第一个卷积层使用32个过滤器。我们应该记住，由于我们的输入图像有三个通道，每个过滤器也有三个通道。现在，在网络设计部分，我们已经定义了滤波器大小为(3，3)。因此，每个滤波器有三个通道，每个通道具有(3，3)形状。这意味着每个通道有9个参数。每个滤波器总共有27个参数+ 1个偏差。因为我们在第一卷积中有32个滤波器，所以我们对于第一卷积层有32* 28 = 896个参数。</p><p id="f855" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">我们使用(2，2)池，所以维度减少到原来的一半。(从224到112)。现在来看批量标准化部分，对应于每个滤波器批量标准化层有4个参数，其中一半是不可训练的。因为我们在前一层有32个过滤器，所以总参数是32*4 = 128。脱落层没有任何参数，它对尺寸没有影响。</p><p id="7ae6" class="pw-post-body-paragraph ld le hi jm b jn mf lf lg jp mg lh li jr mh lk ll jt mi ln lo jv mj lq lr jx hb bi translated">注意，在第二卷积层中，我们有9248个参数。让我们看看这个。前一层有32个维度。因此，滤波器也应该有32个通道或维度。每个通道有9个参数。因此，每个滤波器总共有(9*32)+1个偏置(289)。因为我们有32个这样的滤波器，所以第二卷积中的参数总数是289* 32 = 9247</p><h2 id="dc6b" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated"><strong class="ak"> <em class="mk">结论</em> </strong></h2><p id="9c86" class="pw-post-body-paragraph ld le hi jm b jn jo lf lg jp jq lh li jr lj lk ll jt lm ln lo jv lp lq lr jx hb bi translated">我们已经看到了卷积神经网络是如何工作的，并使用keras实现了一个基本的CNN网络。CNN在许多不同的领域都有不同的用例。我们需要每个类别足够数量的图像来从头开始训练CNN。CNN高级主题包括迁移学习、各种卷积、剩余网络等。读者现在应该对卷积神经网络的基础有所了解。</p><h2 id="0f65" class="kp in hi bd io kq kr ks is kt ku kv iw jr kw kx ja jt ky kz je jv la lb ji lc bi translated">参考资料和进一步阅读</h2><ul class=""><li id="813b" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><a class="ae mw" href="https://www.ibm.com/cloud/learn/convolutional-neural-networks" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/cloud/learn/卷积神经网络</a></li><li id="0400" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated"><a class="ae mw" href="https://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">https://cs231n.github.io/convolutional-networks/</a></li><li id="a7a3" class="jk jl hi jm b jn kd jp ke jr kf jt kg jv kh jx jy jz ka kb bi translated">各种图像分类问题的实现:<a class="ae mw" href="https://github.com/thomasreji155" rel="noopener ugc nofollow" target="_blank">https://github.com/thomasreji155</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>GitLab as your Continuous Deployment one-stop shop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitLab是您持续部署的一站式商店</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/gitlab-continuous-deployment-one-stop-shop-2a8ebf168963?source=collection_archive---------26-----------------------#2021-08-01">https://medium.com/geekculture/gitlab-continuous-deployment-one-stop-shop-2a8ebf168963?source=collection_archive---------26-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f35a2f7f6c3d604467e124f9e60073e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*59FP-TCBVk8CGaq4qe9Yew.png"/></div></figure><p id="b811" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本周，我想从我的Start Rust系列中休息一下，专注于一个不同的主题。我已经详细写了我的博客堆栈。</p><p id="bf7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，我没有触及一个方面，这个方面就是我如何从Jekyll生成静态页面。正如我在博文中描述的，我已经包含了相当多的定制。其中一些需要外部依赖，例如:</p><ul class=""><li id="990d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个用于PlantUML图生成的JRE</li><li id="1bef" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><em class="jz"> graphviz </em>包也是出于同样的原因</li><li id="1e96" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">等等。</li></ul><p id="754c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总而言之，这意味着我需要一个完全配置的系统。我用集装箱化，也就是Docker解决了这个问题。在<code class="du ka kb kc kd b">Dockerfile</code>中，我能够安装所有需要的依赖项。然后，在我的GitLab构建文件中，我可以引用这个图像并从它的所有功能中受益。</p><p id="3aeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">YAML</p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="0fae" class="km kn hi kd b fi ko kp l kq kr">image: registry.gitlab.com/nfrankel/nfrankel.gitlab.io:latest</span><span id="d4a7" class="km kn hi kd b fi ks kp l kq kr"># ...</span></pre><h1 id="5c2a" class="kt kn hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">更新，辛苦了</h1><p id="28f4" class="pw-post-body-paragraph im in hi io b ip lq ir is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">Jekyll是建立在Ruby之上的。Ruby中的共享库被称为<em class="jz"> gems </em>。我用了其中的一些，还有哲基尔宝石本身。作为一个长期的Maven用户，我在Ruby世界中搜索了等效的依赖管理工具，并偶然发现了<a class="ae jk" href="https://bundler.io/" rel="noopener ugc nofollow" target="_blank"> Bundler </a>:</p><blockquote class="lv lw lx"><p id="bac7" class="im in jz io b ip iq ir is it iu iv iw ly iy iz ja lz jc jd je ma jg jh ji jj hb bi translated"><em class="hi"> Bundler通过跟踪和安装所需的gem和版本，为Ruby项目提供了一个一致的环境。</em></p></blockquote><p id="e032" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Bundler在一个<code class="du ka kb kc kd b">Gemfile</code>文件上休息。它类似于npm的<code class="du ka kb kc kd b">package.json</code>。当您执行<code class="du ka kb kc kd b">bundle install</code>时，它会用最新的gems版本创建一个<code class="du ka kb kc kd b">Gemfile.lock</code>；用<code class="du ka kb kc kd b">bundle update</code>，它更新它们。</p><p id="87bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止，我的更新过程是这样的:</p><ol class=""><li id="a466" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj mb jr js jt bi translated">将gems更新到最新版本</li><li id="bf48" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">在我的笔记本电脑上构建Docker映像</li><li id="9cb5" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">将图像上传到我的项目的GitLab注册表</li><li id="1ce7" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">提交对锁文件的更改</li><li id="5300" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">推</li><li id="ac26" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">反过来，这会触发GitLab上的构建，并在GitLab页面上部署我的站点。</li></ol><p id="d610" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它有几个缺点:</p><ul class=""><li id="5ea8" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">它需要我的笔记本电脑上的Docker。当然，我已经有了，但不是每个人都满意</li><li id="eadd" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">构建需要时间，也需要CPU时间</li><li id="9572" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">图像占用存储空间。我可以把它清理干净，但这是对我时间的额外浪费。</li><li id="5af1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">它堵塞了我的网络。由于我的上传速度非常有限，当我上传时，我不能做任何涉及互联网的事情。</li></ul><h1 id="03ed" class="kt kn hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">更新，聪明的方法</h1><p id="598e" class="pw-post-body-paragraph im in hi io b ip lq ir is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">最近偶然发现了GitLab cheatsheets 的优秀<a class="ae jk" href="https://dev.to/jphi_baconnais/series/12928" rel="noopener ugc nofollow" target="_blank">系列。在第六部</a>中，作者提到了<a class="ae jk" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>:</p><blockquote class="lv lw lx"><p id="37b2" class="im in jz io b ip iq ir is it iu iv iw ly iy iz ja lz jc jd je ma jg jh ji jj hb bi translated"><em class="hi"> kaniko是一个在容器或Kubernetes集群中从docker文件构建容器映像的工具。</em></p><p id="53d0" class="im in jz io b ip iq ir is it iu iv iw ly iy iz ja lz jc jd je ma jg jh ji jj hb bi translated">kaniko不依赖Docker守护进程，完全在用户空间执行Docker文件中的每个命令。这使得在不能轻松或安全地运行Docker守护进程的环境中构建容器映像成为可能，比如标准的Kubernetes集群。</p><p id="c212" class="im in jz io b ip iq ir is it iu iv iw ly iy iz ja lz jc jd je ma jg jh ji jj hb bi translated"><em class="hi"> kaniko的本意是作为形象运行:</em> <code class="du ka kb kc kd b"><em class="hi">gcr.io/kaniko-project/executor</em></code> <em class="hi">。</em></p></blockquote><p id="6ed5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这意味着您可以将Docker映像构建部分移动到构建过程本身。新流程变成:</p><p id="acf8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止，我的更新过程是这样的:</p><ol class=""><li id="ebc9" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj mb jr js jt bi translated">将gems更新到最新版本</li><li id="7db2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">提交对锁文件的更改</li><li id="7c22" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">推</li><li id="d988" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">尽情享受吧！</li></ol><p id="be2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了做到这一点，我不得不非常仔细地浏览文档。我还将构建文件移到了“新”语法中。这是新版本:</p><p id="81b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">YAML</p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="77f2" class="km kn hi kd b fi ko kp l kq kr">stages:<br/>  - image                                                        # 1<br/>  - deploy                                                       # 1</span><span id="98c5" class="km kn hi kd b fi ks kp l kq kr">build:                                                           # 2<br/>  stage: image                                                   # 3<br/>  image:<br/>    name: gcr.io/kaniko-project/executor:debug                   # 4<br/>    entrypoint: [""]                                             # 5<br/>  script:<br/>    - mkdir -p /kaniko/.docker<br/>    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} | base64)\"}}}" &gt; /kaniko/.docker/config.json                                       # 6<br/>    - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG                                # 7<br/>  only:<br/>    refs:<br/>      - master<br/>    changes:<br/>      - Gemfile.lock                                              # 8</span><span id="5de8" class="km kn hi kd b fi ks kp l kq kr">pages:                                                           # 2<br/>  stage: deploy                                                  # 3<br/>  image:<br/>    name: registry.gitlab.com/nfrankel/nfrankel.gitlab.io:latest # 9</span></pre><ol class=""><li id="0c50" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj mb jr js jt bi translated">定义<em class="jz">阶段</em>。阶段是有序的:在这里，<code class="du ka kb kc kd b">image</code>在<code class="du ka kb kc kd b">deploy</code>之前运行。</li><li id="4aae" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">定义<em class="jz">岗位</em></li><li id="a558" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">作业与一个阶段相关联。根据记录，与同一阶段相关联的作业是并行运行的。</li><li id="f3b3" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">使用Kaniko Docker图像的<code class="du ka kb kc kd b">debug</code>风格。虽然这不是必需的，但是这个映像记录了在出现问题时它是如何改进调试的。</li><li id="8687" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">重置<code class="du ka kb kc kd b">entrypoint</code></li><li id="5f01" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">在下一行中，创建Kaniko用来推送到Docker注册表的凭证文件</li><li id="e398" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">使用提供的<code class="du ka kb kc kd b">Dockerfile</code>构建映像，并将其推送到项目的Docker注册表中。注意GitLab传递这里使用的所有环境变量</li><li id="e7b4" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">仅当<code class="du ka kb kc kd b">Gemfile.lock</code>文件被更改时运行该作业</li><li id="d36e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj mb jr js jt bi translated">使用先前生成的图像生成静态站点</li></ol><h1 id="98dc" class="kt kn hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="eaa9" class="pw-post-body-paragraph im in hi io b ip lq ir is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">这篇文章展示了如何使用Kaniko映像将构建管道的Docker部分从本地机器卸载到GitLab。它节省了时间和资源。我唯一的遗憾是，我应该更早做这件事，因为我是自动化的大力支持者。</p><p id="c8d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我遗漏了最后一步:调度一个更新依赖关系并创建一个<em class="jz">合并请求</em><em class="jz">àla</em>dependent bot的作业。</p><p id="8b59" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">更进一步:</strong></p><ul class=""><li id="b53d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://dev.to/jphi_baconnais/series/12928" rel="noopener ugc nofollow" target="_blank"> GitLab Cheatsheet系列</a></li><li id="1fd7" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://docs.gitlab.com/ee/ci/docker/using_kaniko.html" rel="noopener ugc nofollow" target="_blank">使用kaniko构建Docker图像</a></li><li id="e8fa" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank">关键词引用。gitlab-ci.yml文件</a></li><li id="66d2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.youtube.com/watch?v=d96ybcELpFs" rel="noopener ugc nofollow" target="_blank">在GitLab上用Kaniko构建最低特权容器</a></li><li id="412b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html" rel="noopener ugc nofollow" target="_blank"> GitLab的预定义变量引用</a></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="1f31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz">原载于</em> <a class="ae jk" href="https://blog.frankel.ch/gitlab-continuous-deployment-one-stop-shop/" rel="noopener ugc nofollow" target="_blank"> <em class="jz">一个Java极客</em></a><em class="jz">2021年8月1日</em></p></div></div>    
</body>
</html>
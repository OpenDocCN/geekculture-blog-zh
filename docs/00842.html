<html>
<head>
<title>Java Byte Code Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java字节代码操作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-bytecode-manipulation-a1a660ac93dc?source=collection_archive---------12-----------------------#2021-03-15">https://medium.com/geekculture/java-bytecode-manipulation-a1a660ac93dc?source=collection_archive---------12-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="92f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的目标是将一个公共属性手动添加到类文件中。当类加载器完成加载修改后的类文件时，我们能够看到我们手动添加的字段。</p><p id="1255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java编译器编译了我们的代码之后，就会生成一个类文件。这个类文件包含由Java规范定义的字节码指令。然而，它仍然是一个物理文件。最后，这个文件必须被加载到内存中，解析，然后构造类对象。将此视为解析XML文件，我们必须首先定义XML文件中允许哪些节点。然后，解析器能够根据我们预先定义的节点解析这个文件。Java类文件也一样。Oracle预定义了类文件结构。解析器必须能够理解文件中的结构并执行特定的操作。读取和解析这个文件是由类加载器完成的。在ClassLoader加载类之后，一个类对象被放入堆中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/550d132e69678c9cb6229874c174d272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYPDcE8L2-27Zp801nUjkw.png"/></div></div></figure><p id="93a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在讨论类文件结构之前，我们先讨论一下指令集。</p><p id="464b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">与汇编代码类似，字节码指令的最终目标是从内存位置加载值，对它们执行操作，并将结果写回内存位置。在高级语言中，我们总是使用符号。符号可以是方法名，也可以是变量名，等等。符号本身只是绝对或相对内存位置的代表。</em>T3】</strong></p><p id="b358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以在任何语言中使用下面的语句。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="03a1" class="jv jw hi jr b fi jx jy l jz ka">fun calculate { <br/>  int i = 4<br/>}</span></pre><p id="4962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> i </strong>是一个符号。它代表一个内存位置。该语句要求将数字4放入由<strong class="ih hj"> i </strong>表示的内存位置。在把任何东西放入一个存储单元之前，计算机必须为它预留空间。在这种情况下，大小由<strong class="ih hj"> int指定。</strong></p><p id="8186" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个重要的事实:<em class="jp">一个程序总是在一个线程或者多个线程中运行。每个线程都有一个相应的堆栈结构来存储当前线程的运行时状态。这个堆栈可以存储被调用函数的局部变量。另一个内存位置是堆。堆用于存储全局分配的对象。这个内存模型不只是Java用的，C++里也有。其他语言或多或少也是如此。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/396a04f550716ce20ea3d581018c5b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilVfG3ihS5e_ze0Bx2sD8g.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Java memory model</figcaption></figure><p id="0223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM为每个函数调用创建一个<strong class="ih hj">帧</strong>。所有的局部变量都存储在一个框架中。<strong class="ih hj">我们可以把框架看作一个局部变量数组。</strong>所以我们的<strong class="ih hj"> <em class="jp"> int i = 4就是</em> </strong>只是把数字4存储到数组的最后一个位置。有实现这一功能的指令是有意义的。确实有按照这里列出的指令做这件事的指令<a class="ae kg" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/JVMs/se7/html/JVMs-6 . html</a></p><p id="bae3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个简单的类TestClass来查看这个。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="07de" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class </strong>TestClass(<strong class="jr hj">val name</strong>: String) {<br/>    <strong class="jr hj">fun </strong>testMethod() {<br/>        <strong class="jr hj">val </strong>i: Int = 3<br/>        <em class="jp">print</em>(i)<br/>    }<br/>}</span></pre><p id="c792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<strong class="ih hj"><em class="jp">javap-c test class . class</em></strong>来查看函数的字节码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/c630dc6b1439724e9b62cb897703e6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*GKSW-q86-OE2XiNvpsCJbw.png"/></div></figure><p id="65a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> iconst_3: </strong>将常数3压入操作数堆栈</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/13dd6424348bcef536e9972a5e4f85f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*OGcjc0axwLvp-MugLrjhwg.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">push — operand stack</figcaption></figure><p id="7355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> istore_1 </strong>:从操作数堆栈中弹出整数，并将整数存入当前帧的局部变量数组的索引1。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/0680e05d01a7b1a311f95df005a76afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*0EhZaPaRzjI4UXSjvoWrDA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">pop — operand stack</figcaption></figure><p id="e2e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">操作数堆栈</strong></p><p id="f75f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么需要操作数堆栈？如前所述，指令必须首先从内存中加载数据，对数据进行操作，然后将结果写回内存。JVM在哪里存储从内存加载的数据？</p><p id="0b7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算机CPU上，有寄存器。变量值首先被加载到CPU的寄存器中，计算在寄存器中完成。计算完成后，寄存器的结果被写回存储器。我相信JVM借鉴了CPU本身的这种设计。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/a7a5aa60be3cf5af896906e816bfa3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZY1xWF76dRDVSrHQCfHXQ.png"/></div></div></figure><p id="655b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM为什么不直接把数据加载到CPU寄存器中？因为JVM指令不是机器代码。指令必须被翻译成机器代码才能使用寄存器。这项工作是由JIT完成的。</p><p id="9f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM如何表示创建对象的另一个实例？</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="1f70" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class </strong>Foo(<strong class="jr hj">val name</strong>: String) {<br/>    <strong class="jr hj">fun </strong>foo() {<br/>        <em class="jp">print</em>(<strong class="jr hj">"foo"</strong>)<br/>    }<br/>}<br/><strong class="jr hj">class </strong>TestClass(<strong class="jr hj">val name</strong>: String) {<br/>    <strong class="jr hj">fun </strong>testMethod() {<br/>        <strong class="jr hj">val </strong>foo: Foo = Foo(<strong class="jr hj">"yogi"</strong>) //creating instance of class<br/>    }<br/>}</span></pre><p id="a8b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个实例有3个步骤:</p><ul class=""><li id="482a" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated">加载目标类</li><li id="dc12" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">在堆上为类实例分配内存</li><li id="8bec" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">调用实例的构造函数</li></ul><p id="1f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看生成的字节码</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/cb9bceebde0933ff1c580536def935fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxsnG_zArgkzOSV4kbSl0Q.png"/></div></div></figure><p id="dd72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个指令是<strong class="ih hj"> <em class="jp">新的#8。</em> </strong>数字8是进入常量池表的一个索引。</p><p id="00c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">恒池</strong></p><p id="2b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常量池是JVM <strong class="ih hj">加载类文件</strong>后创建的<strong class="ih hj">运行时结构</strong>。它包含源类中使用的所有符号引用。</p><p id="ad29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<strong class="ih hj"><em class="jp">javap-v test class . class</em></strong>查看类文件中常量池的原始内容。(以下输出实际上是由javap解释的)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/78e7497b6e7eec5fca5d3796cf40839f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xjZ391PtYzZMkxJ6gze1w.png"/></div></div></figure><p id="34c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在类加载器读取我们的<strong class="ih hj"> TestClass.class </strong>文件后，JVM将创建一个常量池表。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/21059b6f3dbb432cb526c83b505f09fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*WO3g7AlgNjBC6OqXqjBCvQ.png"/></div></figure><p id="0e72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常数池表中的每个条目都是可变大小的结构。每个条目可以表示不同的常量类型。常量的类型由名为<strong class="ih hj">标签</strong>的第一个字节表示。这个页面<a class="ae kg" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.1" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/JVMs/se7/html/JVMs-4 . html # JVMs-4 . 4 . 1</a>有所有的常量类型。在我们的图片中，我们列出了两种常量类型。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="57a6" class="jv jw hi jr b fi jx jy l jz ka">CONSTANT_Class_info {<br/>    u1 tag;<br/>    u2 name_index;<br/>}</span><span id="87d0" class="jv jw hi jr b fi lb jy l jz ka">CONSTANT_Utf8_info {<br/>    u1 tag;<br/>    u2 length;<br/>    u1 bytes[length];<br/>}</span></pre><p id="edc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">常量_类别_信息</em>中的<strong class="ih hj">名称_索引</strong>是索引回常量池的数字。constant_pool[name_index]中的条目是一个类型<em class="jp"> CONSTANT_Utf8_info </em>，它包含我们的类名称<strong class="ih hj">“com/Qiu suo/Foo”</strong>。</p><p id="ff6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在类加载器构造常量池之后，它将解析方法引用和类引用。在我们的例子中，类加载器将解析<strong class="ih hj"> "com/qiusuo/Foo" </strong>类。它从<strong class="ih hj"> </strong>类路径加载<strong class="ih hj"> Foo.class </strong>并在堆上构造类对象。它会用构造的<strong class="ih hj"> Foo </strong>类对象的实际内存地址替换<strong class="ih hj"> "com/qiusuo/Foo" </strong>符号引用。</p><p id="ccc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，有急于装和偷懒装。类加载器能够在运行时加载类引用和方法引用。</p><p id="308b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法引用包含在方法引用结构中。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="c480" class="jv jw hi jr b fi jx jy l jz ka">CONSTANT_Methodref_info {<br/>    u1 tag;<br/>    u2 class_index;<br/>    u2 name_and_type_index;<br/>}</span></pre><p id="5e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的结构我们就不赘述了，因为它类似于<em class="jp"> CONSTANT_Class_info。</em></p><p id="87fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当方法引用被解析到内存位置时，JVM指令如<strong class="ih hj"><em class="jp">invoke special # 14</em></strong>可以调用<strong class="ih hj"> Foo </strong>类的构造函数。</p><p id="3896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类文件中另外三个重要的结构是:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="45d1" class="jv jw hi jr b fi jx jy l jz ka">    field_info     fields[fields_count];<br/>    method_info    methods[methods_count];</span></pre><p id="37f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> field_info </strong>和<strong class="ih hj"> method_info </strong>结构包含被加载的类的字段和方法信息。</p><p id="9abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字节码操作</strong></p><p id="f1dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们研究了类文件格式之后，字节码操作就是在读取类文件之后改变它的不同部分的内容。我们将使用<a class="ae kg" href="https://asm.ow2.io/" rel="noopener ugc nofollow" target="_blank"> ASM </a>库来做实验，因为Spring也使用这个库。我们的目标是将一个简单的属性<strong class="ih hj"><em class="jp">public int test = 0</em></strong>添加到我们之前的<strong class="ih hj"> TestClass </strong>类中。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="e010" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class </strong>TestClass(<strong class="jr hj">val name</strong>: String) {<br/>    <strong class="jr hj">fun </strong>testMethod() {<br/>        <strong class="jr hj">val </strong>foo: Foo = Foo(<strong class="jr hj">"yogi"</strong>) //creating instance of class<br/>    }<br/>    public var test: Int = 0 // will be added by ASM<br/>}</span></pre><p id="b995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于字段信息是由类文件中的<strong class="ih hj"> field_info </strong>结构表示的，所以<strong class="ih hj"> ASM </strong>库要做的基本上就是在类文件中多加一个<strong class="ih hj"> field_info </strong>。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="03bc" class="jv jw hi jr b fi jx jy l jz ka">field_info {<br/>    u2             access_flags;<br/>    u2             name_index;<br/>    u2             descriptor_index;<br/>    u2             attributes_count;<br/>    attribute_info attributes[attributes_count];<br/>}</span></pre><p id="146d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> access_flags </strong>:像公共的，私有的，或者受保护的。</p><p id="f12f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> name_index: </strong>类似于CONSTANT_Class_info中的name_index</p><p id="cd8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> attribute_info: </strong>包含类型，注释，泛型信息，字段的常量值。</p><p id="e323" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> descriptor_index: </strong>进入常量池的索引，该条目代表字段的类型</p><p id="6c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个结构的细节可以在这里找到<a class="ae kg" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.5" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/specs/JVMs/se7/html/JVMs-4 . html # JVMs-4.5</a></p><p id="7e21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ASM接口</strong></p><ul class=""><li id="f8c8" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated"><em class="jp"> ClassReader </em> —负责读取类文件的内容。它将调用ClassVisitor来访问类文件的每个部分</li><li id="cb95" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">class visitor—实际的类调用了类文件的不同部分</li><li id="7f8e" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">ClassWriter实际上扩展了ClassVisitor。ClassWriter的visitField函数首先检查该字段是否存在。如果该字段不存在，则在类文件结构中创建该字段。</li></ul><p id="82b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的CustomFieldAdder</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="94a6" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class </strong>CustomFieldAdder(<strong class="jr hj">val access</strong>: Int, <strong class="jr hj">val name</strong>: String, <strong class="jr hj">val fieldType</strong>: String, <strong class="jr hj">val signature</strong>: String?, <strong class="jr hj">val value</strong>: Any, <strong class="jr hj">val cv</strong>: ClassVisitor, <strong class="jr hj">val api</strong>: Int): ClassVisitor(api, cv) {<br/>    <strong class="jr hj">var isFieldPresent </strong>= <strong class="jr hj">false</strong></span><span id="1416" class="jv jw hi jr b fi lb jy l jz ka"><strong class="jr hj">    override fun </strong>visitField(access: Int, name: String?, desc: String?, signature: String?, value: Any?): FieldVisitor? {<br/>        <strong class="jr hj">if</strong>(name.<em class="jp">equals</em>(<strong class="jr hj">this</strong>.<strong class="jr hj">name</strong>)) {<br/>            <strong class="jr hj">isFieldPresent </strong>= <strong class="jr hj">true<br/>        </strong>}<br/>        <strong class="jr hj">return cv</strong>.visitField(access, name, desc, signature, value)<br/>    }<br/><br/>    <strong class="jr hj">override fun </strong>visitEnd() {<br/>        <strong class="jr hj">if </strong>(!<strong class="jr hj">isFieldPresent</strong>) {<br/>            <strong class="jr hj">val </strong>fv = <strong class="jr hj">cv</strong>.visitField(<strong class="jr hj">access</strong>, <strong class="jr hj">name</strong>, <strong class="jr hj">fieldType</strong>, <strong class="jr hj">null</strong>, <strong class="jr hj">value</strong>) //cv is the ClassWriter<br/>            fv?.visitEnd()<br/>        }<br/>        <strong class="jr hj">cv</strong>.visitEnd()<br/>    }<br/>}</span></pre><p id="8499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试类</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8b79" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">class </strong>TestClassWriter: ClassLoader() {<br/>    <strong class="jr hj">fun </strong>run() {<br/>        <strong class="jr hj">val </strong>className = <strong class="jr hj">"com.qiusuo.bytecode.TestClass"<br/>        val </strong>constValue = 4<br/>        <strong class="jr hj">val </strong>accessType = org.objectweb.asm.Opcodes.<em class="jp">ACC_PUBLIC<br/>        </em><strong class="jr hj">val </strong>name = <strong class="jr hj">"test"<br/>        val </strong>fieldType = Type.<em class="jp">INT_TYPE</em>.toString()<br/>        <strong class="jr hj">val </strong>reader = ClassReader(className)<br/>        <strong class="jr hj">val </strong>writer = ClassWriter(reader, 0)<br/>        <strong class="jr hj">val </strong>fieldAdder = CustomFieldAdder(accessType, name, fieldType, <strong class="jr hj">null</strong>, constValue, writer, Opcodes.<em class="jp">ASM7</em>)<br/>        reader.accept(fieldAdder, 0)<br/>        <strong class="jr hj">val </strong>modified =  writer.toByteArray()<br/>        <strong class="jr hj">val </strong>modifiedClass: Class&lt;*&gt; = defineClass(className, modified, 0, modified.<strong class="jr hj">size</strong>)<br/>        <strong class="jr hj">val </strong>instance = modifiedClass.getDeclaredConstructor().newInstance()<br/>        <strong class="jr hj">val </strong>value = modifiedClass.getDeclaredField(<strong class="jr hj">"test"</strong>).get(instance)<br/>        <em class="jp">println</em>(value)<br/>    }<br/>}</span></pre><p id="5776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:我把初始值设为4。但是，打印的值仍然是0。这意味着添加的属性没有初始化为4。我不知道为什么。</strong></p><p id="f58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实验的源代码可以在这里找到</p><p id="669f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://github.com/ryan-zheng-teki/springboottutorial/blob/master/springcoretutorial/src/main/kotlin/com/qiusuo/bytecode/CustomFieldAdder.kt" rel="noopener ugc nofollow" target="_blank">https://github . com/Ryan-Zheng-teki/spring boot tutorial/blob/master/springcore tutorial/src/main/kot Lin/com/Qiu suo/bytecode/customfieldadder . kt</a></p></div></div>    
</body>
</html>
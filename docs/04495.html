<html>
<head>
<title>Complete your GRPC development and testing workflow with Tap-Rpc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tap-Rpc完成您的GRPC开发和测试工作流</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/complete-your-grpc-development-and-testing-workflow-with-tap-rpc-bc185a1adce5?source=collection_archive---------35-----------------------#2021-06-28">https://medium.com/geekculture/complete-your-grpc-development-and-testing-workflow-with-tap-rpc-bc185a1adce5?source=collection_archive---------35-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/96d780b179100b75414926301e8453fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-MdnTZeKk05oaiqeR2Ymw.png"/></div></div></figure><p id="ec49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在<a class="ae jo" href="http://gonuclei.com" rel="noopener ugc nofollow" target="_blank">nucleus</a>使用GRPC为我们的服务，主要是因为GRPC提供了丰富的好处，例如通过原型文件进行简单的服务定义，提供可扩展性，跨语言和平台工作，通过http2支持双向流。</p><p id="1d31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有这些好处，我们解决了一些不可避免的限制和我们经常面对的开发和测试工作流程的细微差别。</p><h1 id="de88" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们试图解决的问题</h1><p id="112f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">任何项目通常的开发和测试工作流程都包括前端和后端开发，以及测试项目的QA人员。</p><p id="3259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前端问题</strong>:前端开发人员总是依赖后端服务准备就绪，以构建用户界面，很多时候服务仍在进行中。如果服务没有准备好，前端将不得不手动模拟响应，这是非常耗时和乏味的。</p><p id="b950" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">后端问题</strong>:后端服务的测试完全依赖于他们编写的测试用例，后端开发人员无法实时修改来自应用程序客户端的请求，这使得发现问题变得更加困难。</p><p id="9b99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">QA关注点:在后端或客户端模拟某些边缘案例和场景是非常困难和耗时的，这通常需要改变客户端和后端的代码库。QA没有简单的方法来实时查看或修改客户端和后端之间交换的请求和响应，这将多次暴露错误和未处理的情况。</p><p id="6918" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决上述所有问题，我们需要一个介于前端(客户端应用程序)和后端(服务)之间的工具</p><ul class=""><li id="a3aa" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">这是一个工具，它让开发人员以一种比通常的日志更好的方式实时看到请求和响应。</li><li id="6417" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">允许您实时修改客户端应用程序和服务器之间交换的请求和响应。</li><li id="d134" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">允许您使用客户端应用程序所需的相关信息生成模拟响应，并提供向服务发送模拟请求的方法。</li></ul><p id="394e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是<strong class="is hj"> Tap-Rpc </strong>(灵感来自Bloom Rpc grpc客户端)的由来。</p><h1 id="613f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TAP-RPC:</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/326fdc274fe48490cc4d16d2fea37b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhyqcxM8x-U1jhSfHf2NdA.png"/></div></div></figure><p id="62fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Tap-Rpc有效地解决了上述问题。</p><ul class=""><li id="f30f" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">简化前端开发，甚至在后端API未准备好的情况下解除前端阻塞。</li><li id="40d6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">显著降低开发人员和QA之间的依赖性</li><li id="2626" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">有助于有效的应用和后端测试</li></ul><h1 id="6fec" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">安装和使用:</h1><ul class=""><li id="446b" class="ks kt hi is b it kn ix ko jb ll jf lm jj ln jn kx ky kz la bi translated">从这里下载最新版本:<a class="ae jo" href="https://github.com/nateshmbhat/tap-rpc/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/nateshmbhat/tap-rpc/releases</a></li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/5755e8d08d824be0f36bab389aff044c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WVVDVDfWqAZZwc-k"/></div></div></figure><ul class=""><li id="9c38" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">在您的客户端应用程序中，将grpc服务的主机和端口设置为指向Tap-Rpc窗口标题中间显示的Tap-Rpc的ip地址和端口。在上图中，窗口标题显示的地址为“<strong class="is hj"> 192.168.6.54:50051 </strong>”。</li><li id="1ac0" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">设置缺省的目标服务器URL，这是监视器和客户机模式所需要的。在上图中，目标服务器被设置为“dev-01.gonuclei.com:80 ”,这是真正的grpc服务的地址。</li><li id="4398" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">用户选择包含服务的原型文件。一旦您选择了proto文件，所有的服务和这些服务中的rpc都会出现在一个树形结构中，您可以选择一个特定的RPC。</li><li id="18f1" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">此时，来自客户端的任何请求都将被转发到后台的默认目标服务器。</li><li id="8ae8" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">现在，您的客户端应用程序已经准备好访问Tap-Rpc的所有特性。</li></ul><p id="0b6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Tap-Rpc提供了3种操作模式，每种模式解决一组不同的问题:</p><ol class=""><li id="0a1f" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lp ky kz la bi translated">模拟Rpc模式</li><li id="a873" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lp ky kz la bi translated">监控模式</li><li id="b46f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lp ky kz la bi translated">客户端模式</li></ol><h1 id="0318" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模拟Rpc模式:</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/be0b8db4ae8ce4ec47983cd6165a786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-RfN5gO0wa_vMLWy"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">Mock Rpc mode in action</figcaption></figure><p id="3cc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模拟rpc模式为可以定制的客户端提供模拟响应。这种模式试图消除对后端服务的依赖。客户端只需要指向窗口标题中给出的地址，就可以开始使用Tap-Rpc作为模拟服务器。</p><ul class=""><li id="d4d9" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">生成的模拟响应依赖于原型属性名和属性类型，这有助于生成真实的响应。例如:图像网址，地址文本，电话，文件路径，电子邮件，姓名等。</li><li id="92cd" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">模拟响应可以由<strong class="is hj">动态编辑</strong>。</li><li id="5b79" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">您也可以选择<strong class="is hj">发送</strong> <strong class="is hj">模拟grpc错误代码</strong>和自定义错误消息来测试错误场景。</li><li id="b2b9" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">本质上，tap-rpc工具的每个用户都有能力拥有自己的服务器，为请求提供真实的响应，而不需要客户端手动硬编码模拟响应。</li></ul><h1 id="2b2c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">监控模式:</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/805e6267cc3d04a48092bbd4386c7e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*clVH7veYlZK3hHwu"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">Monitor mode in action</figcaption></figure><p id="7a3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">监控模式是Tap-Rpc最有趣的特性，它充当应用程序客户机和真正的后端服务器(目标服务器)之间的桥梁，允许您实时监控和修改请求和响应。</p><ul class=""><li id="cff1" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">用户可以实时看到客户端应用程序和服务器之间交换的请求和响应。</li><li id="8976" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">用户可以在请求到达后端之前修改来自客户端的请求。</li><li id="bad1" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">用户可以在响应到达客户端之前修改从服务器返回的响应。</li><li id="a2c6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">用户还可以访问和修改元数据、切换TLS使用、转发错误、更改目标服务器以动态转发请求等。</li></ul><h1 id="5e5b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">客户端模式:</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/619e0417a758111d218aaf5eb7e268bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*35cJlZGTYC2KNMAz"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">Client mode in action</figcaption></figure><p id="8c41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在客户机模式下，您可以通过向目标服务器发送真实的模拟请求来独立测试您的后端服务。</p><ul class=""><li id="ae8a" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">使用客户端模式向后端服务发送真实的模拟请求。</li><li id="60da" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">帮助测试各种场景下的每个后端服务和rpc。</li><li id="5d1b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">用真实的数据生成模拟请求。</li></ul><h1 id="7aa0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用REST而不是GRPC？</h1><p id="dfa6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果你在使用REST服务而不是grpc，我们仍然为你提供了另一个专门用于处理REST服务和请求的工具，你可以从这里获得:<a class="ae jo" href="https://github.com/nateshmbhat/tap-rest/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/nateshmbhat/tap-rest/releases</a></p><blockquote class="lu lv lw"><p id="e066" class="iq ir lx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">这篇文章是由<a class="mb mc ge" href="https://medium.com/u/94450a387c10?source=post_page-----bc185a1adce5--------------------------------" rel="noopener" target="_blank"> manu kj </a>共同撰写的</p></blockquote><blockquote class="md"><p id="cb96" class="me mf hi bd mg mh mi mj mk ml mm jn dx translated"><em class="mn">别忘了砸那个</em> <code class="du mo mp mq mr b"><em class="mn">CLAP</em></code> <em class="mn">按钮👏🏻走之前:)</em></p></blockquote><figure class="mt mu mv mw mx ij er es paragraph-image"><div class="er es ms"><img src="../Images/893063ccf3ad689296cd095afd513f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/0*JSklfL8Hku31_ttG.gif"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Clapping is Caring :)</figcaption></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Pointers and References: Design Goals and Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">指针和参考:设计目标和用例</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/pointers-and-references-design-goals-and-use-cases-a536a984ba4d?source=collection_archive---------22-----------------------#2021-08-19">https://medium.com/geekculture/pointers-and-references-design-goals-and-use-cases-a536a984ba4d?source=collection_archive---------22-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ed8b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">其他语言是为了禁止指针而产生的，它们真的很可怕吗？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8a9ace05e423b30215f94c5537fcc47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZegRhF8XziuF4TQf"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@ben_robbins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben Robbins</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="83e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">起初，C++似乎通过引入另一个抽象层使事情变得更加复杂。引用似乎封装了与指针相同的功能集。这两个构造都用于将<em class="kk">引用</em>到另一个实体，因为它们提供了操作<em class="kk"> referent </em>实体的内容的访问点；它们都在堆上分配。</p><p id="daaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我们面临以下问题:</p><ol class=""><li id="277d" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj kq kr ks kt bi translated">指针和引用是一回事吗？</li><li id="9429" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">有没有指针只能做的技术，反之亦然？</li><li id="9241" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">什么时候我们更喜欢指针而不是引用，反之亦然？</li></ol><p id="3652" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章的结尾，我希望理清这两个概念，并试图给出一个理由，为什么引用应该有自己的权利来构建更健壮的高阶概念。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="c456" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">两颗北极指极星</h1><p id="d76d" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">指针是在c中引入的，指针存储了类型为<code class="du md me mf mg b">T</code>的实体的内存地址(其中<code class="du md me mf mg b">T</code>是一个可以解析为<em class="kk">任何</em>类型的模板参数)，正如前面提到的，它提供了一个访问点，用于改变它所指向的实体的值。考虑下面的片段:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/e72a8b18fe1a8aac804bf4469355afc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpoBFJFcvYGrhZBVuee4Xg.png"/></div></div></figure><p id="1632" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">指针非常适合利用间接方式来操作某个内存块中的内容。让我们修改上面的代码来演示如下的一系列间接操作:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/a1afda02aaeab789b8c15c1d9df722d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlRCysMquUfZfim_nrNnNQ.png"/></div></div></figure><p id="30f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以通过将它们嵌套在一起来扩展它:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/acf2ac943e26eb8f0323069325164fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiOltv-KpkD6t6HuA248nA.png"/></div></div></figure><p id="0bb8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们注意到的，指针的地址和它的引用地址是不同的。这个观察是因为指针有自己的身份。因此，指针可以更多地被重新分配给另一个变量，这样它们就可以容忍空值:<code class="du md me mf mg b">NULL</code>和<code class="du md me mf mg b">nullptr</code>(如果你使用指针的话，最好使用<code class="du md me mf mg b">nullptr</code>)。也就是<code class="du md me mf mg b">int *x = nullptr</code>有效，会编译。</p><p id="09fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更重要的是，指针可以通过前后递增操作符、前后递减操作符和下标操作符迭代数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/69ca2e76f5b0976e14af79f03852e211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgghjSl2c9kLHBP3CuS6LA.png"/></div></div></figure><p id="970c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们注意到的，指针的地址和它的引用地址是不同的。这个观察是因为指针有自己的身份。因此，指针可以更多地被重新分配给另一个变量，以便它们可以容忍空值:<code class="du md me mf mg b">NULL</code>和<code class="du md me mf mg b">nullptr</code>(如果您使用指针的话，最好使用<code class="du md me mf mg b">nullptr</code>)。即<code class="du md me mf mg b">int *x = nullptr</code>有效，会编译。</p><p id="be82" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更重要的是，指针可以通过前后递增操作符、前后递减操作符和下标操作符迭代数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/e339192e278b56d95adb994f46fcf751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1__azELGIQlP9M9MQUNffA.png"/></div></div></figure><p id="c74c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如前所述，指针可用于在堆上分配值以及在该位置写入数据。让我们考虑为一个大小为<code class="du md me mf mg b">3</code>的数组块分配内存:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/c7faa8e9ef986c43f4d2312dc190d1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A08XgsGb6V4OlzlzAEN_MQ.png"/></div></div></figure><h2 id="8bc1" class="mk lh hi bd li ml mm mn lm mo mp mq lq jx mr ms ls kb mt mu lu kf mv mw lw mx bi translated">使用指针的提醒</h2><ul class=""><li id="6ddb" class="kl km hi jq b jr ly ju lz jx my kb mz kf na kj nb kr ks kt bi translated">指针可能很难管理，因为它们可以不受限制地嵌套和组合，这可能导致难以维护的复杂代码。</li><li id="c2fa" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">如果管理不当，指针可能会泄漏资源:当不再需要指针类型时，您必须确保进行清理，并且当它们不再与您的代码相关时，您应该记得释放堆上的资源。</li><li id="ccfd" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">当性能不如安全重要或不需要更精细的控制时，最好使用智能指针:<code class="du md me mf mg b">std::unique_ptr&lt;T&gt; u_ptr</code>、<code class="du md me mf mg b">std::shared_ptr&lt;T&gt; s_ptr</code>和<code class="du md me mf mg b">std::weak_ptr&lt;T&gt; w_ptr</code>而不是原始指针。智能指针允许你以最小的性能代价通过<a class="ae jn" href="https://bityl.co/8BOl" rel="noopener ugc nofollow" target="_blank"> RAII </a>自动清理，在<code class="du md me mf mg b">u_ptr</code>的情况下，性能开销为零。</li><li id="cd8a" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">对于指针对象<code class="du md me mf mg b">ptr_obj</code>或自定义类型，可以通过箭头运算符访问成员，如<code class="du md me mf mg b">ptr_obj-&gt; function()</code>。</li></ul></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="4c5a" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">参考</h1><p id="eac6" class="pw-post-body-paragraph jo jp hi jq b jr ly ij jt ju lz im jw jx ma jz ka kb mb kd ke kf mc kh ki kj hb bi translated">引用使事情更便于表达，它为表达<em class="kk">所有权语义</em>提供了必要的约束集——这个话题现在超出了我们的关注范围。C++遵循的设计原则是，符合标准的解决方案应该比备选方案更容易。</p><p id="e9f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们知道了指针，我们如何将它与引用进行对比呢？</p><p id="b9a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">引用可以被认为是一个<a class="ae jn" href="https://bityl.co/8BUS" rel="noopener ugc nofollow" target="_blank">常量指针</a> <code class="du md me mf mg b">T const* c_ptr = &amp;obj</code>，不应该与<code class="du md me mf mg b">const T* ref = &amp;obj</code>混淆:前者允许修改对象的内容，但限制地址指向<code class="du md me mf mg b">obj</code>，后者则相反，只限制修改<code class="du md me mf mg b">obj</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/87f231fd7f0ebaa7530946317f445497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrqvW6AiJqcyoFaDfqcwCg.png"/></div></div></figure><p id="bad9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要修改<code class="du md me mf mg b">x</code>的内容并将其设置为<code class="du md me mf mg b">y</code>，我们说:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/1b15c455f46bff8431a378e208eb6474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Dl2PMKAoLyEdxBcSwpj7A.png"/></div></div></figure><p id="f7b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用引用可以达到相同的效果。因此，引用绑定到内存中实体的位置。它允许修改实体的内容，但是它<em class="kk">不能</em>被重新分配，必须在初始化时绑定。因此，实体的引用假定了原始变量的实体。</p><p id="24f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如前所述，引用也可以为堆上的单个实体分配内存。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/bb2deb30e7e1e2023a81eccf4ba46502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14hIxgIvfWF1vcBo-g5RoA.png"/></div></div></figure><h2 id="9383" class="mk lh hi bd li ml mm mn lm mo mp mq lq jx mr ms ls kb mt mu lu kf mv mw lw mx bi translated">使用参考的提醒</h2><ul class=""><li id="4b9c" class="kl km hi jq b jr ly ju lz jx my kb mz kf na kj nb kr ks kt bi translated">引用不能分配给<code class="du md me mf mg b">nullptr</code>。</li><li id="411c" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">引用不能迭代数组。</li><li id="7ec5" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">通过局部变量返回引用可能会导致未定义的行为(悬空引用)。</li><li id="df8e" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">引用必须绑定到现有实体。</li><li id="77b1" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">引用只允许一级间接寻址。</li><li id="ba1c" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">参考文献清楚简明地表达了意图。</li><li id="3bd4" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">自C++11标准以来，引用被更频繁地使用，因为move语义的元素<a class="ae jn" href="https://en.cppreference.com/w/cpp/language/move_constructor" rel="noopener ugc nofollow" target="_blank">是从引用的概念</a> ( <code class="du md me mf mg b">lvalue</code>和<code class="du md me mf mg b">rvalue</code>引用)构建的。</li></ul></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="8763" class="lg lh hi bd li lj lk ll lm ln lo lp lq io lr ip ls ir lt is lu iu lv iv lw lx bi translated">摘要</h1><ul class=""><li id="5209" class="kl km hi jq b jr ly ju lz jx my kb mz kf na kj nb kr ks kt bi translated">指针和引用是一回事吗？号码</li><li id="81b2" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj nb kr ks kt bi translated">有没有指针只能做的技术，反之亦然？指针比引用更灵活，如果管理不好，引用会使代码变得复杂。<code class="du md me mf mg b">T const* ref</code>实现了相同的引用行为，除了数组引用，它给了我们更多选择引用而不是指针的理由(如果合适的话),因为它的语义限制了在类似数组的结构上迭代:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/534d6fa08024ebf71a43de74e7a89520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5a_K0usEt3uox7hAuz0nQ.png"/></div></div></figure><p id="ffe6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">而带有引用的数组索引将导致编译器错误:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/e5f085a62f66f766d19a16a948b9d76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cZtw9scdXmCD_SWHhs-qg.png"/></div></div></figure><ul class=""><li id="7db4" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj nb kr ks kt bi translated">什么时候我们更喜欢指针而不是引用，反之亦然？指针类型通常用于设置一个独立的间接字段，该字段能够修改同一类型的多个变量的内容。让同一个指针访问多个变量可能很难跟踪和推理。最好是保持清晰，而不是方便地键入一个指向所有相同类型变量的指针。由于这个原因，利用引用更安全。</li></ul><p id="1932" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">指针并不可怕，事实上，它们是我们在C/C++等语言中发现的最伟大的特性之一，然而，它们的强大是有代价的。</p><p id="a941" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">总之，引用不仅仅是语法上的糖衣炮弹<code class="du md me mf mg b">T const*</code>，它有自己的设计目标和目的，即包含声明实体的地址。这提高了我们意图的清晰度，在这些情况下，C++编译器是我们的朋友。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="e608" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">最初发表于</em><a class="ae jn" href="https://dcode.hashnode.dev/" rel="noopener ugc nofollow" target="_blank"><em class="kk">https://dcode.hashnode.dev/</em></a></p><ul class=""><li id="99dc" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj nb kr ks kt bi translated">什么时候我们更喜欢指针而不是引用，反之亦然？指针类型通常用于设置一个独立的间接字段，该字段能够修改同一类型的多个变量的内容。让同一个指针访问多个变量可能很难跟踪和推理。最好是保持清晰，而不是方便地键入一个指向所有相同类型变量的指针。由于这个原因，利用引用更安全。</li></ul><p id="564c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">指针并不可怕，事实上，它们是我们在C/C++等语言中发现的最伟大的特性之一，然而，它们的强大是有代价的。</p><p id="e1ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">总之，引用不仅仅是要转换的语法糖，它有自己的设计目标和目的，即包含声明实体的地址。这提高了我们意图的清晰度，在这些情况下，C++编译器是我们的朋友。</p></div></div>    
</body>
</html>
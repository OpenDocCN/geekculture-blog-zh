<html>
<head>
<title>Demystifying React’s Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘React的上下文API</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/demystifying-reacts-context-api-9fa9951d80ee?source=collection_archive---------8-----------------------#2022-02-07">https://medium.com/geekculture/demystifying-reacts-context-api-9fa9951d80ee?source=collection_archive---------8-----------------------#2022-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是上下文API，什么时候应该使用它？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b4572e0480c12be32961e2c0fc638e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdcrYecW6uCLwJOOe5048Q.jpeg"/></div></div></figure><h2 id="2a15" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">支柱钻井的问题是</h2><p id="f479" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">您是否发现在React中组件之间传递数据很麻烦？尤其是在跨多个嵌套组件传递数据时。</p><p id="d7fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在典型的React应用程序中，数据通过props在组件之间传输。但是，当应用程序中的许多组件(例如登录凭证、UI主题)都需要数据时，或者您必须通过多个中间组件传递数据时，这就变得难以处理了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kp"><img src="../Images/05f8a773ef360ce72dd71274a18e9b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*5u4WErawDpt-4JxIFwz_4g.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Prop Drilling in React</figcaption></figure><p id="19fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个的解决方法？React的上下文API。</p><p id="4c21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上下文API负责处理状态管理，并解决了许多与支柱钻井相关的问题；它允许您拥有一个可以直接注入任何消费组件的中央存储。让我们通过一个简单的例子来说明这是如何工作的！</p><h2 id="3907" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">初始化上下文和提供程序</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Context</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Provider</figcaption></figure><p id="5d34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React的上下文API已经实现了<em class="kw">提供者消费者模式</em>。提供者管理消费者组件可以订阅的数据。创建一个上下文对象，该对象可用于创建提供者和消费者。</p><p id="be29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">Provider</code>组件接受一个可以传播给后代组件的<code class="du kx ky kz la b">value</code>属性。在我们的<code class="du kx ky kz la b">value</code> prop中，我们有当前用户的信息和一个函数<code class="du kx ky kz la b">updateUser</code>来更新<code class="du kx ky kz la b">Provider</code>中用户的状态。</p><p id="51b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du kx ky kz la b">value</code>属性改变时，消费组件将使用更新后的值重新呈现。需要注意的一点是，重渲染并不局限于消费类组件；当<code class="du kx ky kz la b">value</code>改变时，从<code class="du kx ky kz la b">provider</code>派生的所有组件将重新渲染。</p><h2 id="dc33" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">实现消费者</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Consumer</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">App</figcaption></figure><p id="02ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">useContext</code>函数允许您的功能组件订阅之前实例化的<code class="du kx ky kz la b">Context</code>。该函数接受<code class="du kx ky kz la b">Context</code>对象，从<code class="du kx ky kz la b">useContext</code>返回的参数将是树中离调用组件最近的<code class="du kx ky kz la b">Provider</code>的状态。</p><p id="893e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kx ky kz la b">ChildComponent</code>中，值<code class="du kx ky kz la b">user</code>和<code class="du kx ky kz la b">updateUser</code>已经从<code class="du kx ky kz la b">Provider</code>传播。当点击按钮时，函数<code class="du kx ky kz la b">updateUser</code>将被调用，并且<code class="du kx ky kz la b">user</code>将在上下文中被更新。</p><p id="23df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的app现在用的是上下文API！</p><h2 id="ed19" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">使用带有自定义挂钩的上下文API</h2><p id="e70c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在我们的<code class="du kx ky kz la b">ChildComponent</code>中，我们直接访问<code class="du kx ky kz la b">useContext</code>钩子。但是如果<code class="du kx ky kz la b">ChildComponent</code>不是<code class="du kx ky kz la b">Provider</code>的后代会怎么样呢？返回值将解析为在<code class="du kx ky kz la b">createContext</code>中定义的默认值，即<code class="du kx ky kz la b">undefined</code>，而我们并不知道。这很容易发生在大型应用程序中，其中有许多组件，并且<code class="du kx ky kz la b">Provider</code>不在我们应用程序的顶层。</p><p id="2514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，为每个需要上下文的组件实现检查会很快变得很麻烦。将<code class="du kx ky kz la b">useContext</code>提取到一个定制的钩子中并在钩子中执行检查要简单得多。</p><p id="614b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用自定义钩子重写我们的<code class="du kx ky kz la b">ChildComponent</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Custom Hook</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ku kv l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx">Consumer with custom Context Hook</figcaption></figure><h2 id="d860" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">什么时候应该使用上下文API？</h2><p id="af4e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">尽管React的上下文API与Redux等其他状态管理工具相比实现起来很简单，但它是以这样一种方式构建的，即每当上下文的值发生变化时，所有派生组件都会重新呈现。组件的不断重新渲染可能会降低应用程序的性能，尤其是当它扩展和增长时。</p><p id="1843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要一个不经常更新的全局状态，那么在实现中央存储时，上下文API会比Redux更有效。在这个场景中，上下文API大放异彩，因为Redux需要更广泛的设置才能与React应用程序集成。</p><p id="1180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用上下文API的场景:</p><ul class=""><li id="7ac3" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">共享用户界面主题(暗/亮模式)</li><li id="4323" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">共享用户信息</li><li id="ff86" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">跨多个组件共享数据，不需要频繁更新</li></ul><h2 id="e8c8" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">结论</h2><p id="81be" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Context API是跨React应用程序的多个组件共享数据的有用工具。但是，我们应该谨慎使用它，因为它会导致重新渲染的问题，并且使组件重用更加困难。</p><h2 id="3113" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">额外资源</h2><p id="0af1" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><a class="ae lp" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/context.html</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>CPU Scheduling Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CPU调度算法</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/cpu-scheduling-algorithms-cd882e685eef?source=collection_archive---------23-----------------------#2021-06-23">https://medium.com/geekculture/cpu-scheduling-algorithms-cd882e685eef?source=collection_archive---------23-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1db68b3084e715c3e77eeac958bf868d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsooZUSZgCaEnxIj8YaQ6w.png"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="ff69" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在多道程序系统中，操作系统调度CPU上的进程以最大限度地利用它，这个过程称为CPU调度。操作系统使用各种调度算法来调度进程。</p><p id="1f15" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这是短期调度程序的一项任务，为作业池中存在的进程数量调度CPU。每当正在运行的进程请求一些IO操作时，短期调度程序就保存进程的当前上下文，并将其状态从运行更改为等待。在此期间，进程处于等待状态；短期调度程序从就绪队列中挑选另一个进程，并将CPU分配给这个进程。这个过程被称为上下文切换。</p><p id="d3d4" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在多道程序设计中，如果长期调度程序选择更多的I/O进程，那么大多数时候，CPU仍然是偶像。操作系统的任务是优化资源的利用。</p><p id="899c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如果大多数正在运行的进程将它们的状态从运行改为等待，那么在系统中可能总是存在死锁的可能性。因此，为了减少这种开销，操作系统需要调度作业，以获得CPU的最佳利用率，并避免死锁的可能性。</p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="511f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated">调度算法的目的</h2><ol class=""><li id="7025" class="kq kr hi iz b ja ks je kt ji ku jm kv jq kw ju kx ky kz la bi translated">最大CPU利用率</li><li id="d050" class="kq kr hi iz b ja lb je lc ji ld jm le jq lf ju kx ky kz la bi translated">中央处理器的费用分配</li><li id="5da1" class="kq kr hi iz b ja lb je lc ji ld jm le jq lf ju kx ky kz la bi translated">最大排出量</li><li id="fc24" class="kq kr hi iz b ja lb je lc ji ld jm le jq lf ju kx ky kz la bi translated">最短周转时间</li><li id="6e9e" class="kq kr hi iz b ja lb je lc ji ld jm le jq lf ju kx ky kz la bi translated">最短等待时间</li><li id="8652" class="kq kr hi iz b ja lb je lc ji ld jm le jq lf ju kx ky kz la bi translated">最短响应时间</li></ol></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="f47d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated">抢先算法</h2><h1 id="e66d" class="lg jw hi bd jx lh li lj kb lk ll lm kf ln lo lp ki lq lr ls kl lt lu lv ko lw bi translated">1.最短剩余时间优先</h1><p id="918f" class="pw-post-body-paragraph ix iy hi iz b ja ks jc jd je kt jg jh ji lx jk jl jm ly jo jp jq lz js jt ju hb bi translated">这是SJF的先发制人形式。在该算法中，操作系统根据剩余的执行时间来调度作业。</p><p id="52b5" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">SRTF算法的C++函数</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="cfd5" class="jv jw hi mf b fi mj mk l ml mm">void cpu_scheduler::srtf(){</span><span id="a984" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="0f32" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="8a24" class="jv jw hi mf b fi mn mk l ml mm">timer = 0 + p[curr].arrival_time;</span><span id="bba9" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="e618" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="e637" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="46e8" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="da48" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].remaining_time &lt; p[curr].remaining_time){</span><span id="6049" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="fdad" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3b52" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4b43" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="a2ba" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="e7e4" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; 1){</span><span id="29df" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="7601" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="ff90" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="18ee" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="2904" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="38ee" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="a667" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="b09f" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="8192" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="c2f2" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="126d" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="5cd8" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="0d73" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="469b" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7087" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="8607" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="f98f" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="7198" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="0d47" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="dfd6" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c21c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="12a9" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3d12" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8fc1" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="8fbb" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="7028" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="f2a8" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="5cc7" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre><h1 id="885a" class="lg jw hi bd jx lh li lj kb lk ll lm kf ln lo lp ki lq lr ls kl lt lu lv ko lw bi translated">2.一系列</h1><p id="7d3b" class="pw-post-body-paragraph ix iy hi iz b ja ks jc jd je kt jg jh ji lx jk jl jm ly jo jp jq lz js jt ju hb bi translated">在循环调度算法中，操作系统定义一个时间段。所有的过程将以循环的方式执行。每个进程将占用CPU一小段时间，然后回到就绪队列等待下一次轮到它。这是一种抢占式调度。</p><p id="4614" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">循环算法的C++函数</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="423b" class="jv jw hi mf b fi mj mk l ml mm">void cpu_scheduler::round_robin(){</span><span id="edd9" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="328c" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Enter the Time Quantum : ";</span><span id="0adb" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;time_quantum;</span><span id="534b" class="jv jw hi mf b fi mn mk l ml mm">timer = 0;</span><span id="2941" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="0989" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[0].arrival_time;</span><span id="da59" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(p[curr].id);</span><span id="2b4b" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;endl;</span><span id="f204" class="jv jw hi mf b fi mn mk l ml mm">while(!ready_queue.empty()){</span><span id="fa5b" class="jv jw hi mf b fi mn mk l ml mm">curr = ready_queue.front();</span><span id="b897" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="cacd" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="3554" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; time_quantum){</span><span id="8316" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + time_quantum;</span><span id="c17c" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time = p[curr].remaining_time - time_quantum;</span><span id="bef9" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="8c5a" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="c9bc" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (p[i].id != p[curr].id)){</span><span id="e2e7" class="jv jw hi mf b fi mn mk l ml mm">if((!p[i].done) &amp;&amp; (!found(p[i].id))){</span><span id="6c5e" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(i);</span><span id="ac87" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="117e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="eef0" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="5101" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(curr);</span><span id="5996" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ff49" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="08cb" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="397f" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].remaining_time;</span><span id="6dd8" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time = 0;</span><span id="1b1f" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="ff4f" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="b6ad" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="d5d6" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="4799" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="c20e" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (p[i].id != p[curr].id)){</span><span id="409e" class="jv jw hi mf b fi mn mk l ml mm">if((!p[i].done) &amp;&amp; (!found(p[i].id))){</span><span id="1699" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(i);</span><span id="c8ff" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="e022" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="5a09" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="bfe0" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="902f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3072" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.pop();</span><span id="8a90" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8f78" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="8daf" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="f668" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="32dc" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="324a" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre><h1 id="c7de" class="lg jw hi bd jx lh li lj kb lk ll lm kf ln lo lp ki lq lr ls kl lt lu lv ko lw bi translated">3.优先级调度</h1><p id="9b03" class="pw-post-body-paragraph ix iy hi iz b ja ks jc jd je kt jg jh ji lx jk jl jm ly jo jp jq lz js jt ju hb bi translated">在抢占式优先级调度中，当一个进程到达就绪队列时，它的优先级与就绪队列中其它进程的优先级以及CPU在该时刻正在执行的进程的优先级进行比较。在所有可用进程中，优先级最高的进程将被分配给下一个CPU。抢占式优先级调度和非抢占式优先级调度的区别在于，在抢占式优先级调度中，正在执行的作业可以在更高优先级作业到达时停止。一旦就绪队列中的所有作业都可用，该算法将表现为非抢占式优先级调度，这意味着调度的作业将一直运行到完成，不会发生抢占。</p><p id="9909" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">循环算法的C++函数</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="760f" class="jv jw hi mf b fi mj mk l ml mm">void cpu_scheduler::priority(){</span><span id="751c" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Priority Order (1) for Higher-Lower (-1) for Lower-Higher : ";</span><span id="526d" class="jv jw hi mf b fi mn mk l ml mm">int priority_order;</span><span id="a080" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;priority_order;</span><span id="b65d" class="jv jw hi mf b fi mn mk l ml mm">process_details(1,priority_order);</span><span id="54e0" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="64dd" class="jv jw hi mf b fi mn mk l ml mm">timer = 0 + p[curr].arrival_time;</span><span id="7729" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="9efb" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="67fc" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="895f" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="c213" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].priority &gt; p[curr].priority){</span><span id="e132" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="a605" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3529" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d405" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9637" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="f2b9" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; 1){</span><span id="d754" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="3684" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="7b52" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="f597" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9a23" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="9ee1" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="6d63" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="a08a" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="89cf" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="6fe0" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="cd43" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="9776" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="53d7" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d237" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="776c" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="6cfc" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="4ee6" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="0efe" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="3517" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="a6a3" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4982" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4038" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="10d2" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="01cd" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="eec7" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="cb0a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="b4eb" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="778f" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="0e9f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated">非抢占式算法</h2><h1 id="7662" class="lg jw hi bd jx lh li lj kb lk ll lm kf ln lo lp ki lq lr ls kl lt lu lv ko lw bi translated">1.先到先服务</h1><p id="95e8" class="pw-post-body-paragraph ix iy hi iz b ja ks jc jd je kt jg jh ji lx jk jl jm ly jo jp jq lz js jt ju hb bi translated">这是实现起来最简单的算法。到达时间最短的进程将首先获得CPU。到达时间越短，进程获得CPU的时间就越早。它是非抢占式调度。</p><p id="4957" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">FCFS算法的C++函数</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="8ac8" class="jv jw hi mf b fi mj mk l ml mm">void cpu_scheduler::fcfs(){</span><span id="8673" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="f41c" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="bf56" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].arrival_time;</span><span id="c80b" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="d5ff" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="aa2a" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="0c4f" class="jv jw hi mf b fi mn mk l ml mm">timer += p[curr].burst_time;</span><span id="28d2" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="3963" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="7dd6" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="3adb" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="7058" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="c383" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="be28" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="98bf" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="9490" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="6db6" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="b45f" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="21ee" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1d37" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="16b6" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="5858" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4df3" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="968d" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="2ab5" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9031" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8c8b" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre><h1 id="b8c6" class="lg jw hi bd jx lh li lj kb lk ll lm kf ln lo lp ki lq lr ls kl lt lu lv ko lw bi translated">2.最短的作业优先</h1><p id="ec64" class="pw-post-body-paragraph ix iy hi iz b ja ks jc jd je kt jg jh ji lx jk jl jm ly jo jp jq lz js jt ju hb bi translated">在SJF调度中，在就绪队列中的可用进程列表中，具有最低突发时间的进程将是下一个被调度的。然而，很难预测处理所需的突发时间，因此该算法很难在系统中实现。</p><p id="4af2" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">SJF算法的C++函数</p><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="d31f" class="jv jw hi mf b fi mj mk l ml mm">void cpu_scheduler::sjf(){</span><span id="652a" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="2496" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="9491" class="jv jw hi mf b fi mn mk l ml mm">timer = 0;</span><span id="1498" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].arrival_time;</span><span id="c53b" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="9e22" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="e53e" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="d1ea" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="3573" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].burst_time &lt; p[curr].burst_time){</span><span id="9efe" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="04a0" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9836" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8c4c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ae69" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="b3dc" class="jv jw hi mf b fi mn mk l ml mm">timer += p[curr].burst_time;</span><span id="2555" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="0088" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="5e34" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="00c7" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="85f9" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="4c70" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3d90" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="7817" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="ade1" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="34f2" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="f79c" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="84a4" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4e85" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6de7" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6a48" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9b43" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="a58c" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="778e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1cb3" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c14c" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="8951" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated">将上述函数归纳为一类</h2><pre class="ma mb mc md fd me mf mg mh aw mi bi"><span id="9fe2" class="jv jw hi mf b fi mj mk l ml mm">#include&lt;bits/stdc++.h&gt;</span><span id="9460" class="jv jw hi mf b fi mn mk l ml mm">using namespace std;</span><span id="b8f1" class="jv jw hi mf b fi mn mk l ml mm">struct process{</span><span id="0afd" class="jv jw hi mf b fi mn mk l ml mm">int id;</span><span id="bf4d" class="jv jw hi mf b fi mn mk l ml mm">int arrival_time;</span><span id="73a3" class="jv jw hi mf b fi mn mk l ml mm">int burst_time;</span><span id="fdca" class="jv jw hi mf b fi mn mk l ml mm">int completion_time = 0;</span><span id="3efe" class="jv jw hi mf b fi mn mk l ml mm">int turn_around_time = 0;</span><span id="6b0c" class="jv jw hi mf b fi mn mk l ml mm">int waiting_time = 0;</span><span id="3457" class="jv jw hi mf b fi mn mk l ml mm">int remaining_time = 0;</span><span id="1eb5" class="jv jw hi mf b fi mn mk l ml mm">int priority = 0;</span><span id="cb0e" class="jv jw hi mf b fi mn mk l ml mm">bool done = false;</span><span id="61f4" class="jv jw hi mf b fi mn mk l ml mm">};</span><span id="d423" class="jv jw hi mf b fi mn mk l ml mm">class cpu_scheduler{</span><span id="6dc1" class="jv jw hi mf b fi mn mk l ml mm">private:</span><span id="b559" class="jv jw hi mf b fi mn mk l ml mm">process p[1000];</span><span id="9ede" class="jv jw hi mf b fi mn mk l ml mm">int n;</span><span id="a111" class="jv jw hi mf b fi mn mk l ml mm">queue&lt;int&gt; gantt_chart;</span><span id="2af1" class="jv jw hi mf b fi mn mk l ml mm">queue&lt;int&gt; ready_queue;</span><span id="6cea" class="jv jw hi mf b fi mn mk l ml mm">int timer = 0;</span><span id="af36" class="jv jw hi mf b fi mn mk l ml mm">int time_quantum;</span><span id="861c" class="jv jw hi mf b fi mn mk l ml mm">int curr;</span><span id="b0df" class="jv jw hi mf b fi mn mk l ml mm">float avg_wait = 0;</span><span id="75de" class="jv jw hi mf b fi mn mk l ml mm">public:</span><span id="7125" class="jv jw hi mf b fi mn mk l ml mm">void process_details(bool,int);</span><span id="dd6c" class="jv jw hi mf b fi mn mk l ml mm">void process_sorting();</span><span id="1e85" class="jv jw hi mf b fi mn mk l ml mm">void process_display();</span><span id="0db1" class="jv jw hi mf b fi mn mk l ml mm">void gantt_chart_display();</span><span id="7a90" class="jv jw hi mf b fi mn mk l ml mm">bool stop();</span><span id="be8f" class="jv jw hi mf b fi mn mk l ml mm">bool found(int);</span><span id="1f23" class="jv jw hi mf b fi mn mk l ml mm">void driver_code();</span><span id="fd38" class="jv jw hi mf b fi mn mk l ml mm">void fcfs();</span><span id="211b" class="jv jw hi mf b fi mn mk l ml mm">void sjf();</span><span id="1969" class="jv jw hi mf b fi mn mk l ml mm">void srtf();</span><span id="8ce1" class="jv jw hi mf b fi mn mk l ml mm">void round_robin();</span><span id="c289" class="jv jw hi mf b fi mn mk l ml mm">void priority();</span><span id="2870" class="jv jw hi mf b fi mn mk l ml mm">void average_waiting_time();</span><span id="683a" class="jv jw hi mf b fi mn mk l ml mm">};</span><span id="081b" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::process_details(bool ispriority,int priority_order){</span><span id="d6ed" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Enter the number of Processes : ";</span><span id="4abc" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;n;</span><span id="d292" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="eb7d" class="jv jw hi mf b fi mn mk l ml mm">p[i].id = i;</span><span id="cd1d" class="jv jw hi mf b fi mn mk l ml mm">if(ispriority){</span><span id="d335" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n Enter Priority of Process "&lt;&lt;i&lt;&lt;" : ";</span><span id="f77c" class="jv jw hi mf b fi mn mk l ml mm">int x;</span><span id="82df" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;x;</span><span id="fc08" class="jv jw hi mf b fi mn mk l ml mm">p[i].priority = x * priority_order;</span><span id="ce83" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6f7c" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n Enter Arrival Time of Process "&lt;&lt;i&lt;&lt;" : ";</span><span id="787d" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;p[i].arrival_time;</span><span id="9bdd" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n Enter Burst Time of Process "&lt;&lt;i&lt;&lt;" : ";</span><span id="dc91" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;p[i].burst_time;</span><span id="0bd3" class="jv jw hi mf b fi mn mk l ml mm">p[i].remaining_time = p[i].burst_time;</span><span id="b985" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d7e6" class="jv jw hi mf b fi mn mk l ml mm">process_sorting();</span><span id="dd69" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ce93" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::process_sorting(){</span><span id="ebff" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="b227" class="jv jw hi mf b fi mn mk l ml mm">for(int j = 0; j &lt; n-1; j++){</span><span id="069a" class="jv jw hi mf b fi mn mk l ml mm">if(p[j].arrival_time &gt; p[j+1].arrival_time){</span><span id="ed09" class="jv jw hi mf b fi mn mk l ml mm">process temp = p[j];</span><span id="f83d" class="jv jw hi mf b fi mn mk l ml mm">p[j] = p[j+1];</span><span id="9598" class="jv jw hi mf b fi mn mk l ml mm">p[j+1] = temp;</span><span id="f1b7" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="b574" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c01a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="cd8c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7968" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::process_display(){</span><span id="4b25" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Process Table : \n";</span><span id="b66c" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="fd55" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" Process ID : "&lt;&lt;p[i].id&lt;&lt;" Priority : "&lt;&lt;p[i].priority&lt;&lt;" Arrival Time : "&lt;&lt;p[i].arrival_time;</span><span id="f86c" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" Burst Time : "&lt;&lt;p[i].burst_time&lt;&lt;" Completion Time : "&lt;&lt;p[i].completion_time;</span><span id="1be5" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" Turn Around Time : "&lt;&lt;p[i].turn_around_time&lt;&lt;" Waiting Time : "&lt;&lt;p[i].waiting_time&lt;&lt;endl;</span><span id="c870" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3ece" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="b6bc" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::gantt_chart_display(){</span><span id="ac9b" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Gantt Chart : ";</span><span id="73df" class="jv jw hi mf b fi mn mk l ml mm">while(!gantt_chart.empty()){</span><span id="a8b6" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" P"&lt;&lt;gantt_chart.front()&lt;&lt;" ";</span><span id="a747" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.pop();</span><span id="72a1" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="b112" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d479" class="jv jw hi mf b fi mn mk l ml mm">bool cpu_scheduler::stop(){</span><span id="1cec" class="jv jw hi mf b fi mn mk l ml mm">int c = 0;</span><span id="7f8f" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="d787" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].done){</span><span id="34ed" class="jv jw hi mf b fi mn mk l ml mm">c++;</span><span id="1d31" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="f3d4" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c151" class="jv jw hi mf b fi mn mk l ml mm">if(c == n){</span><span id="a94a" class="jv jw hi mf b fi mn mk l ml mm">return true;</span><span id="ad9e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c589" class="jv jw hi mf b fi mn mk l ml mm">return false;</span><span id="d082" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9039" class="jv jw hi mf b fi mn mk l ml mm">bool cpu_scheduler::found(int n){</span><span id="ca07" class="jv jw hi mf b fi mn mk l ml mm">bool f = false;</span><span id="34b4" class="jv jw hi mf b fi mn mk l ml mm">queue&lt;int&gt; temp = ready_queue;</span><span id="1abb" class="jv jw hi mf b fi mn mk l ml mm">while (!temp.empty()){</span><span id="b42b" class="jv jw hi mf b fi mn mk l ml mm">if(temp.front() == n)return true;</span><span id="d43f" class="jv jw hi mf b fi mn mk l ml mm">temp.pop();</span><span id="018a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="56ce" class="jv jw hi mf b fi mn mk l ml mm">return f;</span><span id="6f4f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="258a" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::fcfs(){</span><span id="3743" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="d0c7" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="6586" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].arrival_time;</span><span id="5a50" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="f11b" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="55e4" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="cc05" class="jv jw hi mf b fi mn mk l ml mm">timer += p[curr].burst_time;</span><span id="5fe3" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="79bf" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="f2d1" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="e686" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="ea3e" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="e924" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6b31" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="e391" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="5a0a" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="8f55" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="f28d" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="2bc1" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1a4c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4725" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7c06" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ab77" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="5a53" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="0c72" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9ef5" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="262b" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="2c53" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::sjf(){</span><span id="f259" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="b3d8" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="f501" class="jv jw hi mf b fi mn mk l ml mm">timer = 0;</span><span id="6560" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].arrival_time;</span><span id="934e" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="c3ed" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="644d" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="c986" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="c532" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].burst_time &lt; p[curr].burst_time){</span><span id="075f" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="709c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7b51" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6d60" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="4010" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="dbc4" class="jv jw hi mf b fi mn mk l ml mm">timer += p[curr].burst_time;</span><span id="759e" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="46ad" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="9acb" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="72a9" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="1cc2" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="544f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="0e23" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="a995" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="5edb" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="c575" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="3a1e" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="ab6e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="fafc" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c1a8" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9dcc" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1cd7" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="851d" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="3d1f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="087c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1e5d" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="649b" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::srtf(){</span><span id="c124" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="cebd" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="7030" class="jv jw hi mf b fi mn mk l ml mm">timer = 0 + p[curr].arrival_time;</span><span id="aec5" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="f2f4" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="6ee6" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="e7de" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="6670" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].remaining_time &lt; p[curr].remaining_time){</span><span id="128c" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="fda4" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="f808" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1e24" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7860" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="d03b" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; 1){</span><span id="505d" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="cc21" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="ce61" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="5625" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="a823" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="b383" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="b131" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="7137" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="9cac" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="a58d" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="6a20" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="48fe" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="7e53" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="e11a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="f807" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="02b9" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="9b92" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="4fb5" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="4aa1" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="96c2" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ef20" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8eda" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="7871" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8d79" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="fb16" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="0c8e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="155a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="044e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6f35" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::round_robin(){</span><span id="3125" class="jv jw hi mf b fi mn mk l ml mm">process_details(0,0);</span><span id="2db5" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Enter the Time Quantum : ";</span><span id="b347" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;time_quantum;</span><span id="3584" class="jv jw hi mf b fi mn mk l ml mm">timer = 0;</span><span id="90dd" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="c596" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[0].arrival_time;</span><span id="bc85" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(p[curr].id);</span><span id="bcda" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;endl;</span><span id="2934" class="jv jw hi mf b fi mn mk l ml mm">while(!ready_queue.empty()){</span><span id="256c" class="jv jw hi mf b fi mn mk l ml mm">curr = ready_queue.front();</span><span id="ce8a" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="f841" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="1c8e" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; time_quantum){</span><span id="4c5e" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + time_quantum;</span><span id="339b" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time = p[curr].remaining_time - time_quantum;</span><span id="82c5" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="6f16" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="5747" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (p[i].id != p[curr].id)){</span><span id="ebc2" class="jv jw hi mf b fi mn mk l ml mm">if((!p[i].done) &amp;&amp; (!found(p[i].id))){</span><span id="60b4" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(i);</span><span id="ffc1" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="8fdf" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="0e3d" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1f6a" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(curr);</span><span id="3bd0" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="b89a" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="ba46" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="217b" class="jv jw hi mf b fi mn mk l ml mm">timer = timer + p[curr].remaining_time;</span><span id="dfe6" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time = 0;</span><span id="2d0d" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="75ae" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="3f04" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="31b0" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="ae01" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="9066" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (p[i].id != p[curr].id)){</span><span id="e84c" class="jv jw hi mf b fi mn mk l ml mm">if((!p[i].done) &amp;&amp; (!found(p[i].id))){</span><span id="0e60" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.push(i);</span><span id="ad7a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="957f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="f119" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="034d" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d501" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="e400" class="jv jw hi mf b fi mn mk l ml mm">ready_queue.pop();</span><span id="19b6" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="41a3" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="6292" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="aa90" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="5ee8" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="695e" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9d66" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::priority(){</span><span id="babf" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Priority Order (1) for Higher-Lower (-1) for Lower-Higher : ";</span><span id="b793" class="jv jw hi mf b fi mn mk l ml mm">int priority_order;</span><span id="18e2" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;priority_order;</span><span id="56ef" class="jv jw hi mf b fi mn mk l ml mm">process_details(1,priority_order);</span><span id="cb83" class="jv jw hi mf b fi mn mk l ml mm">curr = 0;</span><span id="b782" class="jv jw hi mf b fi mn mk l ml mm">timer = 0 + p[curr].arrival_time;</span><span id="62b0" class="jv jw hi mf b fi mn mk l ml mm">while(!stop()){</span><span id="c104" class="jv jw hi mf b fi mn mk l ml mm">if(timer &gt;= p[curr].arrival_time){</span><span id="75c4" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="6f8e" class="jv jw hi mf b fi mn mk l ml mm">if((p[i].id != curr) &amp;&amp; (!p[i].done) &amp;&amp; (timer &gt;= p[i].arrival_time)){</span><span id="e121" class="jv jw hi mf b fi mn mk l ml mm">if(p[i].priority &gt; p[curr].priority){</span><span id="3480" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="f591" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="6063" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="9398" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="0ef1" class="jv jw hi mf b fi mn mk l ml mm">if(!p[curr].done){</span><span id="d81e" class="jv jw hi mf b fi mn mk l ml mm">if(p[curr].remaining_time &gt; 1){</span><span id="08f6" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="5b56" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="705f" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="1673" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="88ed" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="200a" class="jv jw hi mf b fi mn mk l ml mm">p[curr].remaining_time--;</span><span id="7b12" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="0e5f" class="jv jw hi mf b fi mn mk l ml mm">p[curr].completion_time = timer;</span><span id="0755" class="jv jw hi mf b fi mn mk l ml mm">p[curr].done = true;</span><span id="a010" class="jv jw hi mf b fi mn mk l ml mm">p[curr].turn_around_time = p[curr].completion_time - p[curr].arrival_time;</span><span id="a539" class="jv jw hi mf b fi mn mk l ml mm">p[curr].waiting_time = p[curr].turn_around_time - p[curr].burst_time;</span><span id="84a7" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart.push(p[curr].id);</span><span id="5fd9" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="2bfd" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="ed63" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="7357" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="50c9" class="jv jw hi mf b fi mn mk l ml mm">if((timer &gt;= p[i].arrival_time) &amp;&amp; (!p[i].done)){</span><span id="636f" class="jv jw hi mf b fi mn mk l ml mm">curr = i;</span><span id="c740" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="0a75" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="47d5" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="c721" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="2d0a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="faa8" class="jv jw hi mf b fi mn mk l ml mm">else{</span><span id="0aac" class="jv jw hi mf b fi mn mk l ml mm">timer++;</span><span id="499a" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="d359" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="603c" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="76a6" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::average_waiting_time(){</span><span id="bab6" class="jv jw hi mf b fi mn mk l ml mm">for(int i = 0; i &lt; n; i++){</span><span id="d014" class="jv jw hi mf b fi mn mk l ml mm">avg_wait += p[i].waiting_time;</span><span id="9e05" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="896c" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;"\n Average Waiting Time : "&lt;&lt;avg_wait/n&lt;&lt;endl;</span><span id="0ff9" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="bf6f" class="jv jw hi mf b fi mn mk l ml mm">void cpu_scheduler::driver_code(){</span><span id="4179" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t =========================================== CPU SCHEDULING ALGORITHMS =========================================== \n";</span><span id="77f6" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t\t 1. First Come First Serve CPU Scheduling Algorithm  ";</span><span id="51e3" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t\t 2. Shortest Job First CPU Scheduling Algorithm  ";</span><span id="0a7e" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t\t 3. Shortest Remaining Time First CPU Scheduling Algorithm  ";</span><span id="caf9" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t\t 4. Round Robin CPU Scheduling Algorithm  ";</span><span id="dc00" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" \n\t\t\t 5. Priority CPU Scheduling Algorithm  \n";</span><span id="3e0c" class="jv jw hi mf b fi mn mk l ml mm">int ch;</span><span id="8394" class="jv jw hi mf b fi mn mk l ml mm">cout&lt;&lt;" Enter The Algorithm you want to Implement : ";</span><span id="41ce" class="jv jw hi mf b fi mn mk l ml mm">cin&gt;&gt;ch;</span><span id="6947" class="jv jw hi mf b fi mn mk l ml mm">switch(ch){</span><span id="1397" class="jv jw hi mf b fi mn mk l ml mm">case 1:</span><span id="1c86" class="jv jw hi mf b fi mn mk l ml mm">fcfs();</span><span id="701c" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="fde1" class="jv jw hi mf b fi mn mk l ml mm">case 2:</span><span id="4ce0" class="jv jw hi mf b fi mn mk l ml mm">sjf();</span><span id="7998" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="05e8" class="jv jw hi mf b fi mn mk l ml mm">case 3:</span><span id="f692" class="jv jw hi mf b fi mn mk l ml mm">srtf();</span><span id="dade" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="7891" class="jv jw hi mf b fi mn mk l ml mm">case 4:</span><span id="305f" class="jv jw hi mf b fi mn mk l ml mm">round_robin();</span><span id="5554" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="c382" class="jv jw hi mf b fi mn mk l ml mm">case 5:</span><span id="f879" class="jv jw hi mf b fi mn mk l ml mm">priority();</span><span id="e3af" class="jv jw hi mf b fi mn mk l ml mm">break;</span><span id="76b5" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="3dec" class="jv jw hi mf b fi mn mk l ml mm">process_display();</span><span id="c836" class="jv jw hi mf b fi mn mk l ml mm">gantt_chart_display();</span><span id="dfb7" class="jv jw hi mf b fi mn mk l ml mm">average_waiting_time();</span><span id="9e1f" class="jv jw hi mf b fi mn mk l ml mm">}</span><span id="1f61" class="jv jw hi mf b fi mn mk l ml mm">int main(){</span><span id="09dd" class="jv jw hi mf b fi mn mk l ml mm">cpu_scheduler cpu;</span><span id="97b9" class="jv jw hi mf b fi mn mk l ml mm">cpu.driver_code();</span><span id="f344" class="jv jw hi mf b fi mn mk l ml mm">return 0;</span><span id="4684" class="jv jw hi mf b fi mn mk l ml mm">}</span></pre></div></div>    
</body>
</html>
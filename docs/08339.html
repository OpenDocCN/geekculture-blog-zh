<html>
<head>
<title>Apache Airflow Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇气流备忘单</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/apache-airflow-cheatsheet-205f82d6edda?source=collection_archive---------3-----------------------#2021-10-26">https://medium.com/geekculture/apache-airflow-cheatsheet-205f82d6edda?source=collection_archive---------3-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cf1e66a0039a63b193e3af4f5c452a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o131ZwE98nr3EaRk"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@jeisblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Blackeye</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f633" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apache Airflow是一个以编程方式创作、调度和监控数据管道的系统。阿帕奇气流1.0.0版本发布至今已有六年。数月的编码、修复、部署到全球数百家公司的本地服务器和云中。我们克服了许多困难，这里尝试把一些结论放在一个地方，帮助其他人节省时间，使使用气流更容易。</p><p id="4e59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">如果您会发现一些陈述不准确，请不要犹豫，评论，它将尽快修复。</em></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="7e87" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一般</h1><ol class=""><li id="8682" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated">从这里使用官方Docker-image<a class="ae iu" href="https://hub.docker.com/r/apache/airflow" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/apache/airflow</a>很容易启动你当地的气流环境</li><li id="d691" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">Airflow API文档有助于了解您可以使用什么工具将外部系统与Airflow集成。请在这里阅读<a class="ae iu" href="https://airflow.apache.org/docs/apache-airflow/stable/security/api.html" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/Apache-air flow/stable/security/API . html</a></li><li id="3484" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">阅读<code class="du lp lq lr ls b">airflow.cfg</code>(里面有所有的评论)来了解更多关于如何配置你的气流装置是很好的。请花些时间浏览一下项目回购，了解它是如何在https://github.com/apache/airflow建造的。</li><li id="814a" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">Airflow(以及我可爱的Apache超集)基于Flask和Flask App Builder (FAB)框架之上。这意味着您有许多可定制的功能，例如，您自己的安全管理器。你可以在这里阅读<a class="ae iu" rel="noopener" href="/geekculture/custom-security-manager-for-apache-superset-c91f413a8be7">https://medium . com/geek culture/custom-security-manager-for-Apache-superset-c 91 f 413 A8 be 7</a>。</li></ol><h1 id="7659" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">扫描文件和DAG配置</h1><ol class=""><li id="770e" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated">如果你想让调度程序跳过DAG文件夹中的文件，就不要在文件中使用单词<code class="du lp lq lr ls b">airflow</code>和<code class="du lp lq lr ls b">dag</code>。默认情况下，Airflow scheduler仅扫描文本中包含这些单词的文件。如果你想改变默认行为，只需在你的<code class="du lp lq lr ls b">airflow.cfg</code>中使用<code class="du lp lq lr ls b">DAG_DICOVERY_SAFE_MODE=False</code></li><li id="0290" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">另一种方法是通过DAGs文件夹根目录中的<code class="du lp lq lr ls b">.airflowignore</code>文件忽略不必要的文件。其工作原理与<code class="du lp lq lr ls b">.gitignore</code>相同</li><li id="736e" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">请注意，如果您有不同的Dag使用相同的<code class="du lp lq lr ls b">dag_id</code>，将不会出现错误。Web用户界面将一次显示一个随机DAG。</li><li id="cf5f" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">这可能不直观，但<code class="du lp lq lr ls b">start_date</code>是DAG的可选参数。它对于每个任务都是必须的，但是由于某种原因，它在DAG的不同任务中可能是不同的，这是违反直觉的。</li><li id="38f2" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">DAG的默认schedule_interval是<code class="du lp lq lr ls b">timedelta(days=1)</code></li><li id="2a57" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">如果你在使用永无止境的Dag时遇到问题，那么<code class="du lp lq lr ls b">dagrun_timeout</code>参数可以帮助你。</li></ol><h1 id="a8a6" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">DAG运行</h1><ol class=""><li id="c7e5" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated"><code class="du lp lq lr ls b">catchup</code>参数默认设置为<code class="du lp lq lr ls b">True</code>。这意味着每次取消暂停DAG时，所有错过的DAG运行都会立即开始。最佳实践是为每个DAG将此设置为<code class="du lp lq lr ls b">False</code>。甚至，您可能想要在<code class="du lp lq lr ls b">airflow.cfg</code>中设置<code class="du lp lq lr ls b">CATCHUP_BY_DEFAULT=False</code>来改变所有Dag的默认行为。无论如何，即使有了<code class="du lp lq lr ls b">catchup=False</code>，一个dagrun仍然会在解暂停后运行。</li><li id="ee91" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">DAG的第一个dagrun将在<code class="du lp lq lr ls b">start_date + schedule_interval</code>触发，实际上是在<code class="du lp lq lr ls b">execution_date</code>。</li><li id="3653" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">您可以使用<code class="du lp lq lr ls b">pendulum</code>模块创建时区感知Dag。在版本<code class="du lp lq lr ls b">≥1.10.7</code>中，如果为DAG指定了时区，cron表达式将遵循夏令时(DST)，但timedelta对象不会这样做。顺便说一下，在<code class="du lp lq lr ls b">1.10.7</code>之前的Airflow版本中，一切都是反过来的——time delta对象尊重DST，但cron表达式不尊重DST。</li><li id="706d" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">不要把气流当成多功能的东西。它是一个非常强大的流程编排器，或者像有些人说的<strong class="ix hj"> <em class="jt">它是一个服用了类固醇的克罗恩</em> </strong>。使用它来触发气流系统之外的作业。例如，如果您想将数据从PgSQL或MySQL加载到Clickhouse DB —如果适用，使用它自己的机制从外部表加载数据，而不是编写您自己的自定义操作符或使用带有<code class="du lp lq lr ls b">ClickHouseOperator</code>的PostgresOperator。有些人认为<code class="du lp lq lr ls b">DockerOperator</code>和<code class="du lp lq lr ls b">KubernetesPodOperator</code>应该是您在生产环境中使用的唯一两种类型的操作符。</li><li id="da4e" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">如果您使用AWS环境，并且需要在新文件到达S3存储桶时启动作业，那么最好使用AWS Lambda来触发dagrun，而不是使用传感器。这里有一篇关于如何使用Lambdas <a class="ae iu" rel="noopener" href="/swlh/aws-lambda-run-your-code-for-free-1c7fa6714ee9">的有用文章https://medium . com/swlh/AWS-lambda-run-your-code-for-free-1c 7 fa 6714 ee 9</a>。</li></ol><h1 id="6a25" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">变量和连接</h1><ol class=""><li id="0014" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated">隐藏某些变量的值是可能的。您可以在<code class="du lp lq lr ls b">airflow.cfg</code>的<code class="du lp lq lr ls b">DEFAULT_SENSITIVE_VARIABLE_FIELDS</code>中找到哪些字段将被屏蔽。</li><li id="285c" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">使用<code class="du lp lq lr ls b">deserialize_json=True</code>作为<code class="du lp lq lr ls b">Variable.get()</code>的参数，可以从JSON变量值中得到一个<code class="du lp lq lr ls b">dict()</code>对象。它有助于减少与气流数据库的连接数量。</li><li id="c666" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">将<code class="du lp lq lr ls b">Variable.get()</code>语句放在函数定义中，而不是在主DAG代码中使用它们，会让您受益匪浅。否则，调度程序将在每次扫描文件系统寻找新Dag时创建数据库连接。</li><li id="b5fc" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">通过使用环境变量，可以减少数据库连接，而无需将<code class="du lp lq lr ls b">Variable.get()</code>语句移到函数定义中。以<code class="du lp lq lr ls b">AIRFLOW_VAR_*</code>开头的Env变量在UI变量之前被处理，如果有变量的话就停止进一步的搜索。请注意，env变量在UI中是不可见的。</li><li id="ab37" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">另一种方法是使用Jinja模板。任务的模板化字段将仅在任务运行时处理，而不会在调度程序定期扫描DAG文件夹时处理。使用<code class="du lp lq lr ls b">op_args=["{{ var.json.varname.jsonkey }}"]</code>读取模板字段中的变量</li><li id="9977" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">您可以使用环境变量以及名称中的<code class="du lp lq lr ls b">AIRFLOW_CONN_*</code>模式创建气流连接。</li><li id="6423" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">从版本<code class="du lp lq lr ls b">1.10.10</code>开始，可以使用自定义的秘密后端，如AWS秘密管理器或GCP秘密管理器。</li></ol><h1 id="0932" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">任务执行参数</h1><ol class=""><li id="de9d" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated">不使用XCOM在任务间传输<em class="jt">数据</em>，而是鼓励您通过XCOM传输<em class="jt">元数据</em>。</li><li id="d4d8" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">task的<code class="du lp lq lr ls b">depends_on_past</code>参数防止在先前dagrun中的同一任务被标记为成功或失败之前执行该任务。</li><li id="ad69" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">wait_for_downstream</code>参数允许任务仅在同一任务及其直接下游任务在之前的dagrun中完成时执行。</li><li id="9da8" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">任务<code class="du lp lq lr ls b">priority_rule='downstream'</code>(默认)通过对所有下游任务的优先级求和来计算绝对任务优先级权重。例如，当您运行2个dagrun并且任务池大小为1时，dag run的执行将并行进行(任务从一个Dag run开始，然后从另一个Dag run开始)。</li><li id="28c7" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">任务<code class="du lp lq lr ls b">priority_rule='upstream'</code>通过合计所有上游任务的优先级来计算绝对任务优先级权重。例如，当有2个dagrun正在运行，并且任务池的大小为1时，第二个dagrun中的任务只有在第一个Dag run中的最后一个任务完成后才会执行。</li><li id="76e6" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">execution_timeout</code>参数对于长时间运行的任务很有用。</li><li id="4529" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">trigger_rule</code>就是为你准备的，如果你想改变任务的行为默认是哪个<code class="du lp lq lr ls b">ALL_SUCCESS</code>。可用值的完整列表可在此处找到<a class="ae iu" href="https://github.com/apache/airflow/blob/main/airflow/utils/trigger_rule.py" rel="noopener ugc nofollow" target="_blank">https://github . com/Apache/air flow/blob/main/air flow/utils/trigger _ rule . py</a></li></ol><h1 id="baee" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">并行执行</h1><ol class=""><li id="e7a4" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated"><code class="du lp lq lr ls b">parallelism</code>(默认32)—整个气流实例中可以同时执行多少个任务(<code class="du lp lq lr ls b">airflow.cfg</code>参数)。</li><li id="a67c" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">dag_concurrency</code>(默认为16)—DAG中可以同时执行多少个任务(DAG参数)。</li><li id="3b99" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">max_active_runs_per_dag</code>(默认为16)—可以同时执行多少个Dag(<code class="du lp lq lr ls b">airflow.cfg</code>参数)。</li><li id="8371" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">max_active_runs</code> —可以同时执行多少个DAG(DAG参数)。</li><li id="bc87" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">max_queued_runs_per_dag</code>单个DAG的最大排队DAG运行数，调度程序不会创建更多DAG运行(<code class="du lp lq lr ls b">airflow.cfg</code>参数)。</li></ol><h1 id="b78e" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">传感器</h1><ol class=""><li id="c405" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated"><code class="du lp lq lr ls b">poke_interval</code> —传感器检查状况的频率。</li><li id="6f11" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">带有<code class="du lp lq lr ls b">mode='poke'</code>的传感器占用池中的一个插槽，直到满足条件。</li><li id="4841" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">带<code class="du lp lq lr ls b">mode='reschedule'</code>的传感器仅在检查条件时占用池中的一个槽，并在下一次戳之前释放该槽。</li><li id="b7e4" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">timeout</code>带<code class="du lp lq lr ls b">soft_fail=True</code>的参数(默认为7天)可以将传感器设置为<code class="du lp lq lr ls b">skipped</code>状态，而不是<code class="du lp lq lr ls b">failed</code>状态。</li><li id="a423" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">exponental_backoff=True</code>将固定的<code class="du lp lq lr ls b">poke_interval</code>替换为更动态的。</li></ol><h1 id="8328" class="kb kc hi bd kd ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky bi translated">DAG依赖性</h1><ol class=""><li id="5472" class="kz la hi ix b iy lb jc lc jg ld jk le jo lf js lg lh li lj bi translated"><code class="du lp lq lr ls b">ExternalTaskSensor</code>在另一个DAG中监视特定的task_id及其状态。</li><li id="dee9" class="kz la hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated"><code class="du lp lq lr ls b">TriggerDagRunOperator</code>触发另一个DAG，并且可以等待它被执行。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="5ee1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望您喜欢这篇文章，这篇信息将帮助您构建高效的数据管道。如果有，请在<a class="ae iu" rel="noopener ugc nofollow" target="_blank" href="/@agordienko"> Medium </a>、<a class="ae iu" href="https://github.com/aleksandrgordienko" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae iu" href="https://twitter.com/data_diving" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae iu" href="https://www.linkedin.com/in/aleksandrgordienko/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p></div></div>    
</body>
</html>
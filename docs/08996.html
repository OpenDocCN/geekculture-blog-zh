<html>
<head>
<title>LRU: Implementing a Cache Invalidation Policy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LRU:实现缓存失效策略</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/implementing-a-cache-invalidation-in-distributed-cache-engine-lru-with-code-implementation-1f4d3e204b52?source=collection_archive---------12-----------------------#2021-11-22">https://medium.com/geekculture/implementing-a-cache-invalidation-in-distributed-cache-engine-lru-with-code-implementation-1f4d3e204b52?source=collection_archive---------12-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/32413972a80cd09d93b5e3546eb35c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjcPzgjnretwG3XW8zzGtQ.png"/></div></div></figure><p id="a1ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">最初发表于</em><a class="ae jp" href="https://blog.shams-nahid.com/implementing-a-cache-invalidation-in-distributed-cache-engine-lru-with-code-implementation" rel="noopener ugc nofollow" target="_blank">T5【https://blog.shams-nahid.com】</a><em class="jo">。</em></p><p id="3407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在互联网上，有一句非常流行的菲尔·卡尔顿的名言，</p><blockquote class="jq"><p id="8b08" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated"><em class="ka">计算机科学只有两个硬东西:缓存失效和事物命名。</em></p></blockquote><p id="d587" class="pw-post-body-paragraph iq ir hi is b it kb iv iw ix kc iz ja jb kd jd je jf ke jh ji jj kf jl jm jn hb bi translated">使用内存存储访问数据速度极快，减少了重复计算。但是我们要考虑取舍，内存有限，成本高。因此，对于我们来说，找出何时以及如何从高速缓存中删除/无效数据是一项至关重要的工作。</p><h1 id="1e9d" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">缓存失效策略</h1><p id="5106" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">是时候看看如何从分布式缓存系统中取消缓存了。根据应用需求，我们可以采用各种方法来处理无效缓存，</p><ul class=""><li id="f320" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated"><strong class="is hj">最近最少使用的</strong>替换之前使用时间最长的数据。</li><li id="0de4" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><strong class="is hj">最不常用的</strong>替换使用率很低的数据。</li><li id="0a28" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><strong class="is hj">最近使用的</strong>替换最近使用的数据。在这种情况下，数据根据可能被访问的预测进行缓存。只有当数据到达客户端时，缓存中才不再需要这些数据。</li><li id="0f2d" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><strong class="is hj"> FIFO </strong>通过缓存最新数据来替换缓存中最旧的数据。</li></ul><p id="2146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中，最受欢迎的一项政策是<code class="du lx ly lz ma b">LRU</code>。使用这种方法，当我们的内存达到最大值时，我们将删除最早访问的数据。</p><h1 id="3598" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">普通键值散列表的限制</h1><p id="4dd4" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">通常，为了更快地访问，我们将键值存储在内存中，如下所示:</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/ec9540452fc9fecac3121902a966d473.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*vq5LXmYouzM-bcdO"/></div></figure><p id="ac80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，作为键，我们存储乐队名称，作为值，保存他们的流派。问题是，每当我们访问数据时，我们需要确保数据最近被访问过。同样，我们必须跟踪哪些数据在最长时间内没有被访问。</p><p id="5547" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在跟踪最近和最早访问的数据时，我们不能简单地使用键/值对。</p><p id="01e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们利用一个链表来跟踪最近的和最老的数据，我们可以采用下面的体系结构，</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/3a8b90d064aed0435c4628d013ff2ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9cDNWajMaDU4qiRd"/></div></div></figure><p id="1400" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里的<code class="du lx ly lz ma b">Hashmap</code>键中，我们保存的是照常键。对于hashmap的值，我们存储一个链表节点。</p><p id="4f15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们可以用O(1)使用hashmap中的键来访问数据。</p><p id="f5be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是神奇的是链表。这是一个双向链表，任何时候如果我们有一个节点，我们可以用O(1)做移除/插入/移动。</p><p id="429b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">链表的头部总是指向最近的数据，节点的尾部总是指向最早访问的数据。</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/73b995a95cb57f9046fec2cba17b79af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*WbOaRkPnx_eQxE5j"/></div></figure><p id="31e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果使用hashmap，任何数据被访问，我们将把最近访问的数据放到头中。</p><p id="c7cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比如现在，头节点是<code class="du lx ly lz ma b">Air Supply</code>键。在散列表中，如果我们访问<code class="du lx ly lz ma b">Aerosmith</code>，那么<code class="du lx ly lz ma b">Aerosmith</code>将成为头部。</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/2b859da3912ddc6a17dc82863375255b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*1IdXvOPb4_4x9x89"/></div></figure><p id="dd2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这一点，我们可以很容易地检测出哪一个是最近访问的数据，哪一个是最早访问的数据。</p><h1 id="bd56" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">代码实现</h1><p id="2c06" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我们的链表实现就像，</p><pre class="mc md me mf fd mi ma mj mk aw ml bi"><span id="0b1f" class="mm kh hi ma b fi mn mo l mp mq">class LinkedList {<br/>    constructor() {<br/>        this.head = null;<br/>        this.tail = null;<br/>    }</span><span id="9c83" class="mm kh hi ma b fi mr mo l mp mq">    insert(node) {<br/>        if (!this.head) {<br/>            this.head = node;<br/>            this.tail = node;<br/>            return;<br/>        }<br/>        this.head.prev = node;<br/>        node.next = this.head;<br/>        this.head = node;<br/>    }</span><span id="64d5" class="mm kh hi ma b fi mr mo l mp mq">    makeHead(node) {<br/>        // when linked list is empty<br/>        if (!this.head) {<br/>            this.head = node;<br/>            this.tail = node;<br/>            return;<br/>        }</span><span id="89b7" class="mm kh hi ma b fi mr mo l mp mq">        // node is already head<br/>        if (node === this.head) {<br/>            return;<br/>        }</span><span id="618f" class="mm kh hi ma b fi mr mo l mp mq">        // node is a tail node<br/>        if (node.next === null) {<br/>            const previousNode = node.prev;<br/>            previousNode.next = null;<br/>            node.prev = null;<br/>            node.next = this.head.next;<br/>            this.head = node;<br/>            this.tail = previousNode;<br/>            return;<br/>        }</span><span id="fe61" class="mm kh hi ma b fi mr mo l mp mq">        // node is in the middle, so remove it<br/>        node.prev.next = node.next;<br/>        node.next.prev = node.prev;</span><span id="22a9" class="mm kh hi ma b fi mr mo l mp mq">        // make the node as head<br/>        node.next = this.head.next;<br/>        node.prev = null;<br/>        this.head = node;<br/>    }</span><span id="7a5e" class="mm kh hi ma b fi mr mo l mp mq">    remove(node) {<br/>        // when the list is empty<br/>        if (!this.head) {<br/>            return;<br/>        }<br/>        // when the list has only head, removing head node<br/>        if (node === this.head &amp;&amp; !this.head.next) {<br/>            this.head = null;<br/>            this.tail = null;<br/>            return;<br/>        }<br/>        // removing the tail node<br/>        if (node === this.tail) {<br/>            this.tail = this.tail.prev;<br/>            this.tail.next = null;<br/>            return;<br/>        }</span><span id="87cf" class="mm kh hi ma b fi mr mo l mp mq">        // removing the middle node<br/>        const previousNode = node.prev;<br/>        const nextNode = node.next;<br/>        previousNode.next = nextNode;<br/>        nextNode.prev = previousNode;<br/>    }</span><span id="d167" class="mm kh hi ma b fi mr mo l mp mq">    removeLast() {<br/>        this.remove(this.tail);<br/>    }</span><span id="9738" class="mm kh hi ma b fi mr mo l mp mq">    get(node) {<br/>        let currentNode = this.head;<br/>        while (currentNode) {<br/>            if (currentNode === node) {<br/>                return node;<br/>            }<br/>            currentNode = currentNode.next;<br/>        }<br/>        return null;<br/>    }</span><span id="4427" class="mm kh hi ma b fi mr mo l mp mq">}</span><span id="6281" class="mm kh hi ma b fi mr mo l mp mq">class Node {<br/>    constructor(data) {<br/>        this.data = data;<br/>        this.next = null;<br/>        this.prev = null;<br/>    }<br/>}</span><span id="01b7" class="mm kh hi ma b fi mr mo l mp mq">module.exports = {<br/>    Node,<br/>    LinkedList<br/>}</span></pre><p id="9597" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的Hashmap实现就像，</p><pre class="mc md me mf fd mi ma mj mk aw ml bi"><span id="a70b" class="mm kh hi ma b fi mn mo l mp mq">const { LinkedList, Node } = require('./doubly-link-list');</span><span id="5c3a" class="mm kh hi ma b fi mr mo l mp mq">const MAX_HASHMAP_SIZE = 3;</span><span id="95e1" class="mm kh hi ma b fi mr mo l mp mq">class HashMap {<br/>  constructor() {<br/>    this.linkedList = new LinkedList();<br/>    this.size = 0;<br/>    this.dataMap = {};<br/>  }</span><span id="4243" class="mm kh hi ma b fi mr mo l mp mq">  insert({ key, value }) {<br/>    // When we are max size and inserting a new data<br/>    // remove the last data from hash map<br/>    // remove the last one from linked list<br/>    if (!this.dataMap[key] &amp;&amp; this.size === MAX_HASHMAP_SIZE) {<br/>      // get oldest used data<br/>      const lastNode = this.linkedList.tail;<br/></span><span id="e43b" class="mm kh hi ma b fi mr mo l mp mq">      // remove oldest from hashmap<br/>      if (lastNode) {<br/>        delete this.dataMap[lastNode.data.key];<br/>      }</span><span id="c5e8" class="mm kh hi ma b fi mr mo l mp mq">      // remove oldest node from linked list<br/>      this.linkedList.removeLast();</span><span id="fee7" class="mm kh hi ma b fi mr mo l mp mq">      this.size--;<br/>    }</span><span id="b64c" class="mm kh hi ma b fi mr mo l mp mq">    this.linkedList.insert(new Node({ key, value }));<br/>    this.dataMap[key] = this.linkedList.head;</span><span id="462f" class="mm kh hi ma b fi mr mo l mp mq">    this.size++;<br/>  }</span><span id="7db9" class="mm kh hi ma b fi mr mo l mp mq">  remove() { }</span><span id="226f" class="mm kh hi ma b fi mr mo l mp mq">  get(key) {<br/>    if (!this.dataMap[key]) {<br/>      return null;<br/>    }<br/>    // make head first<br/>    console.log(this.dataMap[key])<br/>    this.linkedList.makeHead(this.dataMap[key])<br/>    return this.dataMap[key].data.value;<br/>  }<br/>}</span><span id="a603" class="mm kh hi ma b fi mr mo l mp mq">module.exports = {<br/>  HashMap<br/>}</span></pre><p id="0ebf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请在<a class="ae jp" href="https://github.com/bmshamsnahid/System-Design-Study-Note/tree/master/resources/Distributed-Cache" rel="noopener ugc nofollow" target="_blank"> github </a>中找到完整的代码。</p><p id="7899" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">了解更多关于<a class="ae jp" href="https://blog.shams-nahid.com/deep-dive-inside-a-distributed-cache-engine" rel="noopener ugc nofollow" target="_blank">分布式缓存系统</a>的信息。</p><p id="6da1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也让我知道任何疑问或额外的解释。</p></div></div>    
</body>
</html>
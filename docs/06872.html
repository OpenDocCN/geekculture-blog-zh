<html>
<head>
<title>Sieve Of Eratosthenes: One of the Oldest Algorithms still Prevalent as if it were Born Yesterday</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">厄拉多塞之筛:最古老的算法之一，仍然流行，仿佛它是昨天才诞生的</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sieve-of-eratosthenes-one-of-the-oldest-algorithms-still-prevalent-as-if-it-were-born-yesterday-c3e854df5dc6?source=collection_archive---------30-----------------------#2021-08-31">https://medium.com/geekculture/sieve-of-eratosthenes-one-of-the-oldest-algorithms-still-prevalent-as-if-it-were-born-yesterday-c3e854df5dc6?source=collection_archive---------30-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6423" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">厄拉多塞筛是当今已知的最古老的算法之一。然而，不管它的年龄和它的工艺，为什么人们仍然使用它，我们如何优化这个算法以匹配今天的工艺？</h2></div><p id="f17d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个世界上有很多算法。当我们想到算法的例子时，我们会想到二分搜索法、A* Search、BFS和DFS，以及更多的算法。我们今天知道的算法是迄今为止人类发现的最好的理论计算机科学计算之一(这就是为什么今天的算法如此著名！).然而，这并不意味着古代文明使用的算法效率不高。我们的大多数发现都是建立在古代作品的预先陈述和理论之上的。我们可以拿几何学作为一个简单的例子。几何首先由欧几里得介绍给世界，然后由其他数学家和物理学家推进，带来了新概念，如n维超球的<em class="jt">体积。但是不仅仅是数学超越了以前的工作。计算机科学可以说是一门深受古代文明影响的学科。我们的许多算法，如果不是所有的算法，都是受到古代文明的过程和理论的启发。尽管如此，仍有一些我们今天仍在使用的算法没有任何改变。其中一种算法被称为厄拉多塞筛。</em></p><p id="e273" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">厄拉多塞之筛是人类文明已知的最古老的算法之一，用于寻找任何给定极限的质数。该算法归功于公元前三世纪的希腊天文学家、数学家、地理学家和历史学家厄拉多塞。算法的工作方式非常直观。他指出，对于任何给定的上限，<em class="jt"> n </em>，我们从2开始，迭代地将素数的倍数标记为合数。一旦2的所有倍数都被标记为复合，下一个素数(即3)的倍数就被标记为复合。这个过程会一直持续到<em class="jt"> p </em> ≤ <em class="jt"> n，</em>其中<em class="jt"> p </em>是一个质数，这将使所有未标记的数都是质数。</p><p id="7448" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设我们想找出10之前的所有素数。我们的第一步是列出从2到极限的所有数字(在本例中是10)作为素数。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ju"><img src="../Images/2c883aaac86978e2c75dd31dc4445d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*aG1V5Z0SU_oRAbqViy39tQ.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">Numbers from 2 to 10 | Image by Author.</figcaption></figure><p id="a92e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，从2开始，我们将所有10以下的倍数标记为非质数:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es kg"><img src="../Images/bb78c600a822bb9bda1376ab84dc0609.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*tJfXKS7PY6WSYvFZ_aZmjA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">Notice how the multiples of 2 have been marked as composite.</figcaption></figure><p id="bb17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经将2的所有倍数都标记为合数，那么我们可以继续处理序列中的下一个数字3。就像第二个，我们重复同样的过程。不过注意，6已经标记好了，不用再标记了。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es kh"><img src="../Images/9afccb53eec4ca1c759e1a509d7226f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*g-Lh4BWXXvzplOsxERHE4g.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">The multiples of 3 have been marked as composite.</figcaption></figure><p id="ac6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们继续比较每一个未标记数字的倍数。在这种情况下，5的所有倍数都已被标记，7的第一个倍数大于极限。因此，我们可以得出结论，我们已经找到了所有的素数，直到10: 2和7。</p><p id="f6eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个寻找质数的过程被应用在许多概念中，使它变得非常重要。有时候，甚至我们使用它，但我们并不自觉地知道它(后面会详细介绍)。然而，这种算法的基本实现在寻找大数字的素数时效率不高，因为它花费的时间太长。对于我的计算机科学爱好者来说，这将被认为是一个幼稚的解决方案。无论你在什么领域使用这种算法(我很快会谈到这一点)，这种通过检查每个<em class="jt">和每个</em>数的<em class="jt">和</em>的倍数来寻找素数的过程是没有效率的，因为对于超过10的极限，这将花费太长的时间。对，10！然而，总有改进的余地。</p><p id="d949" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以实现三种优化，将我们的搜索减少大约一倍<em class="jt"> log (log n) </em>。为了说明这些更新，我将使用Python创建一个更有效的算法，因为毕竟这些优化最初是针对计算机科学领域的。让我们先来看看算法在Python中的基本实现:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ki kj l"/></div></figure><h1 id="6b4c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">优化1-设置结束边界</h1><p id="86c7" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在我们的基本实现中，外部循环从2迭代到<em class="jt"> n </em>。换句话说，我们的基本迭代是从2到极限。因为我们标记的是基值的倍数，所以我们只需要检查低于极限平方根的单个数字(<em class="jt"> n </em>)。让我们回头看看我们的例子，限制为10。</p><p id="1762" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与基本实现类似，我们将首先标记所有2的倍数。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es lh"><img src="../Images/5b76cda64320b478423c166b0b7311ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*pC-T4NbhgZwvn0WGsDnjGA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">Multiples of 2 have been marked composite.</figcaption></figure><p id="253a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们可以继续标记3的倍数。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es li"><img src="../Images/766ea7ec1aa44904c3e0e75feb858ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*RGveJZckUiUKryKXPHLOFw.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">Multiples of 3 have been marked composite.</figcaption></figure><p id="1608" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在请注意，我们接下来要看的数字是4。然而，4大于我们的极限(10)的平方根，所以我们可以在这里结束我们的遍历。此外，如果你看看上一步，我们标记所有的3的倍数，所有的非质数确实已经观察到了。</p><h1 id="bf88" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">优化2 —寻找第一个倍数</h1><p id="1e87" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">第二个优化围绕以<em class="jt">(当前数量)</em>的因子跳过遍历。本质上，在我们的基本实现中，内部循环开始检查两倍于当前数字的倍数。但是，我们可以跳过一些检查，从当前数字的平方开始遍历。</p><p id="a51e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到10的例子，我们从标记2的倍数开始。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es kg"><img src="../Images/bb78c600a822bb9bda1376ab84dc0609.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*tJfXKS7PY6WSYvFZ_aZmjA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">Multiples of 2 are marked.</figcaption></figure><p id="36b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，把3的倍数都标出来。因为已经标记了6(3的第一个倍数),所以不用标记它，我们可以从9 (3)开始遍历。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es li"><img src="../Images/766ea7ec1aa44904c3e0e75feb858ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*RGveJZckUiUKryKXPHLOFw.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx">After starting our traversal at 9, we have found all our primes.</figcaption></figure><p id="9d2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">平均而言，通过仅使用这种优化，我们已经通过少一个比较完成了检查。</p><h1 id="a043" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">优化3 —预先标记所有偶数</h1><p id="346a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">这种优化似乎是常识。然而，许多人忘记了这种方法甚至是作为一种优化方法而存在的！当我们从2到极限构建或列出我们的数字时，这种优化就出现了。甚至没有必要检查两个之后的偶数，因为它们永远不会是质数。最多，所有偶数都至少是2的倍数。因此，不是通过在列表中留下偶数来增加额外的迭代，我们可以通过将迭代次数减半来移除它们！简单却有效，不是吗？</p><p id="f089" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现这些优化后，我们的算法如下:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="6822" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们新的优化算法的搜索时间是<em class="jt"> O(n log (log n)) </em>时间。这是对我们天真的<em class="jt"> O(n ) </em>时间方法的巨大改进！但是我们是如何把时间复杂度降低那么多的呢？有三个操作需要考虑:创建数组、递增和标记循环。我们的创建发生在线性时间中，因为它为从2到<em class="jt"> n </em>的每个数字创建一个元素。这相当于手工列出了从2到极限的所有数字。因此，没有比将每个数字一个接一个地写入或添加到数组中直到达到极限更好的解决方案了。现在是定义的复杂部分。多重标记发生在<em class="jt">日志</em>时间<em class="jt">时间</em>因为它归结为某种<a class="ae lj" href="https://www.geeksforgeeks.org/how-is-the-time-complexity-of-sieve-of-eratosthenes-is-nloglogn/" rel="noopener ugc nofollow" target="_blank">复杂的数学<em class="jt">时间</em>时间</a>。根据定义，你可以标记一个非质数的次数是<em class="jt"> n/2 + n/3 + … n/(√n)。</em>它以<em class="jt"> n/2 </em>开始，因为最初，2的所有倍数都被标记为非质数(这将发生大约50次，每次限制为100，因为每个偶数都被标记)。这个过程一直持续到极限的平方根(<em class="jt"> n </em>)。此外，通过一些数学证明，这算出了<em class="jt"> O( n log (log n)) </em>的整体复杂度，因为这大于<em class="jt"> O(n) </em>的数组创建时间。</p><p id="793a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看我的Github，了解关于我的算法Python实现以及我如何包含这些优化的更多信息:<a class="ae lj" href="https://github.com/GEEGABYTE1/InterviewQuestions/tree/master/Sieve_of_Er" rel="noopener ugc nofollow" target="_blank">https://Github . com/geegabyte 1/interview questions/tree/master/Sieve _ of _ Er</a></p><p id="4348" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是为什么这些优化很重要呢？正如我前面提到的，这些优化允许我们在今天的过程中更有效地使用这个算法。不过，你可能会问，“为什么我们不能创造另一种算法来计算素数？”。很棒的问题！尽管数学取得了许多进步，但使厄拉多塞筛仍然适用的是它的精确性和简单性。没有多少算法两者兼得。例如，尽管很简单，但筛子在31.2秒内找到了所有高达1亿的素数，并且在6分30秒内找到了所有26，355，867个高达5亿的素数！</p><p id="f1af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">厄拉多塞的筛子主要用在质数起作用的地方。在当今世界，安全是一件大事，现代加密算法是让我们远离危险网络的东西。目前最流行的现代加密算法之一是sha256。如果你还不知道，sha256保护各种加密货币的交易。技术领域的另一个例子是公钥加密，它依赖于将大数分解为特定密钥的质因数的复杂性。在技术世界之外，筛子主要用于数学，特别是抽象代数和初等几何，其中对物体(形状)的研究反映了素数的行为。甚至生物学家也使用筛子来模拟各种物种的种群增长(例如，昆虫及其与蛴螬的种群比例)。在音乐的世界里，作曲家用质数来创作格律音乐。例如，一位法国作曲家<em class="jt">奥利维亚·梅西安</em>利用质数来创造非正统的节奏，让他的作品听起来更好；《T2》和《T4》分别于1935年和1949年和1950年出版。</p><p id="ff43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">筛子的应用多种多样，信不信由你，我只列举了几个！只要记住一件事，有素数的地方就是用筛子的地方。质数每天都在使用，因为它们有一些有趣的性质，可以描述自然、宇宙和人类的独特行为。因此，由于素数及其在理解世界和现实中的重要性，筛子被用来有效地计算素数，以使我们更好地了解我们生活的宇宙和时间。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="2b34" class="kk kl hi bd km kn lr kp kq kr ls kt ku io lt ip kw ir lu is ky iu lv iv la lb bi translated">资源/引用</h1><p id="38f8" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">德特普尔，杜恩和卡尔文·朗。小学教师的数学推理。艾迪森-韦斯利。纽约；1996.</p><p id="6856" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lj" href="http://www-groups.dcs.st-and.ac.uk/%7Ehistory/Mathematicians/Eratosthenes.html" rel="noopener ugc nofollow" target="_blank">昔兰尼的厄拉多塞。</a><a class="ae lj" href="http://www-groups.dcs.st-and.ac.uk/~history/Mathematicians/Eratosthenes.html" rel="noopener ugc nofollow" target="_blank">http://www-groups . DCS . ST-and . AC . uk/~ history/mathematics/eratosthenes . html</a></p><p id="de01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Goles，e；舒尔茨，o；Markus，M. (2001年)。"捕食者-食饵模型中周期的素数选择."<em class="jt">复杂</em>。<strong class="iz hj">6</strong>(4):33–38。<a class="ae lj" href="https://en.wikipedia.org/wiki/Bibcode_(identifier)" rel="noopener ugc nofollow" target="_blank">bib code</a>:<a class="ae lj" href="https://ui.adsabs.harvard.edu/abs/2001Cmplx...6d..33G" rel="noopener ugc nofollow" target="_blank">2001 cmplex…6d..33G </a>。<a class="ae lj" href="https://en.wikipedia.org/wiki/Doi_(identifier)" rel="noopener ugc nofollow" target="_blank">doi</a>:<a class="ae lj" href="https://doi.org/10.1002%2Fcplx.1040" rel="noopener ugc nofollow" target="_blank">10.1002/cplx . 1040</a>。</p><p id="df40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">idlecodi_matta。(2020年10月18日)。厄拉多塞的一个更快的筛子。空闲编码。<a class="ae lj" href="https://idlecoding.com/making-eratosthenes-go-faster-1/." rel="noopener ugc nofollow" target="_blank">https://idlecoding.com/making-eratosthenes-go-faster-1/.</a></p><p id="c669" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生病，彼得·詹森，编辑。(1995).<a class="ae lj" href="https://books.google.com/books?id=7ag3ymWqvfgC&amp;pg=PT225" rel="noopener ugc nofollow" target="_blank"> <em class="jt">梅西安的同伴</em> </a>。俄勒冈州波特兰市:阿马德乌斯出版社。《出埃及记》13.2 <em class="jt">五旬节餐厅</em>1‘主菜’。<a class="ae lj" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">ISBN</a><a class="ae lj" href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-931340-95-6" rel="noopener ugc nofollow" target="_blank">978–0–931340–95–6</a>。</p></div></div>    
</body>
</html>
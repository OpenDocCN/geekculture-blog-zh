<html>
<head>
<title>React 18 Alpha: A Quick Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18阿尔法:快速概述</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/react-18-alpha-a-quick-overview-49217cd089a5?source=collection_archive---------8-----------------------#2021-06-18">https://medium.com/geekculture/react-18-alpha-a-quick-overview-49217cd089a5?source=collection_archive---------8-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c0b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React 18 Alpha功能的快速概述</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a6d226749e6656757a5c396591e3957c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LYIoWGKswQk45SHYqWEAg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@andreassjovall?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Andreas Sjövall</a> on <a class="ae jt" href="https://unsplash.com/s/photos/new-features?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c138" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React 18 Alpha已于上周发布，带有很酷的新功能和一个<a class="ae jt" href="https://github.com/reactwg/react-18" rel="noopener ugc nofollow" target="_blank">工作组</a>来了解社区对新功能的逐步采用。</p><p id="4036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看有哪些新功能</p><ol class=""><li id="9458" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">自动配料</li><li id="524d" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">开始过渡</li><li id="3485" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">新悬念SSR</li><li id="9455" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">并行暂记</li></ol><h1 id="44d9" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">自动配料</h1><p id="bfdd" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们先来看看什么是批处理？</p><p id="27a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">批处理是将多个状态更新组合到一个渲染中以优化性能。</strong></p><p id="6147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个代码示例来看看这个</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jp jq et er es jr js bd b be z dx">React 17 with Batching</figcaption></figure><p id="47f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试在<a class="ae jt" href="https://codesandbox.io/s/react-17-batching-ehwby?file=/src/index.js" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中的演示</p><p id="467a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，<strong class="ih hj"> handleClick </strong>内部有两个setState。但是当我们点击<strong class="ih hj">下一个</strong>按钮时，组件只渲染一次。您可以在控制台中看到日志。</p><p id="ea0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">批处理在React 17中已经存在，但是React过去只对浏览器事件进行批处理更新，而不是回调。查看下面的代码了解更多细节</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jp jq et er es jr js bd b be z dx">React 17 without batching</figcaption></figure><p id="e0f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试<a class="ae jt" href="https://codesandbox.io/s/react-17-without-batching-fry7t?file=/src/index.js:0-943" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中的演示</p><p id="9678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，当点击<strong class="ih hj">下一个</strong>按钮时，组件在控制台中渲染了两次。React不会在promise、setTimeout或任何其他事件中批量更新。为了克服这个问题，React 18中增加了自动配料。</p><p id="0aec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自动批处理</strong>在所有事件中执行批处理更新。因此，与旧版本的React相比，我们自动获得了更好的性能。</p><p id="a67d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，为了让我们的应用获得更好的性能，我们需要做些什么呢？</p><p id="6ff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需将你的react版本升级到18(目前是18 Alpha)并将<strong class="ih hj"> createRoot </strong>添加到你的<strong class="ih hj"> ReactDom </strong>渲染中，如下所示</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="95d9" class="ls kj hi lo b fi lt lu l lv lw">ReactDOM.createRoot(rootElement).render(&lt;App /&gt;);</span></pre><p id="8a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你所有的更新都会自动批量处理。查看下面的代码示例</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="jp jq et er es jr js bd b be z dx">React 18 with createRoot</figcaption></figure><p id="d85f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试<a class="ae jt" href="https://codesandbox.io/s/react-18-with-createroot-euobe?file=/src/index.js:0-1065" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中的演示</p><p id="f7a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们可以看到组件在控制台中只更新了一次，尽管状态是在承诺中更新的。它很酷，它将通过避免<strong class="ih hj">不需要的渲染</strong>来提高应用程序的性能。</p><p id="e74c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们不想批量更新，我们可以使用下面的<strong class="ih hj"> flushSync </strong></p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="1741" class="ls kj hi lo b fi lt lu l lv lw">import { flushSync } from 'react-dom'; // Note: react-dom, not react</span><span id="8ca6" class="ls kj hi lo b fi lx lu l lv lw">function handleClick() {<br/>  flushSync(() =&gt; {<br/>    setCounter(c =&gt; c + 1);<br/>  });<br/>  // React has updated the DOM by now<br/>  flushSync(() =&gt; {<br/>    setFlag(f =&gt; !f);<br/>  });<br/>  // React has updated the DOM by now<br/>}</span></pre><h1 id="74d9" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">开始过渡</h1><p id="54d5" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">开始转换将状态更新分为两种类型</p><ol class=""><li id="fe22" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">紧急更新</li><li id="ec15" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">过渡更新(慢速更新)</li></ol><p id="d3a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始过渡主要关注app的<strong class="ih hj">用户体验</strong>。因为transition内部的更新在后台运行缓慢。</p><p id="119b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查下面的代码</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="db63" class="ls kj hi lo b fi lt lu l lv lw">import { startTransition } from 'react';</span><span id="88c4" class="ls kj hi lo b fi lx lu l lv lw">// Urgent: Show what was typed<br/>setInputValue(input);</span><span id="5549" class="ls kj hi lo b fi lx lu l lv lw">// Mark any state updates inside as transitions<br/>startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setSearchQuery(input);<br/>});</span></pre><p id="49f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果有类似用户交互事件的紧急更新，setSearchQuery </strong>将被中断。</p><p id="c843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反应提供一个<strong class="ih hj">挂钩</strong>用于与<strong class="ih hj">悬挂</strong>的过渡</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="992a" class="ls kj hi lo b fi lt lu l lv lw">import { useTransition } from 'react';</span><span id="e30e" class="ls kj hi lo b fi lx lu l lv lw">const [isPending, startTransition] = useTransition();</span></pre><p id="ecde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> isPending </strong>可用于向用户显示装载状态。如果过渡正在进行中。</p><p id="63b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React建议对UI中的远程数据和大数据更新使用<strong class="ih hj">转换</strong>。</p><h1 id="fe9b" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">新悬念SSR</h1><p id="256c" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">该特性用于在服务器中呈现react组件。现在服务器端渲染也支持悬念。</p><p id="cc3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们看看什么是<strong class="ih hj"> SSR </strong>？</p><p id="2ed6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> SSR </strong>从服务器上的React组件生成HTML，并将该HTML发送到客户端。SSR让用户在JavaScript包加载和运行之前看到页面的内容。</p><h2 id="aad0" class="ls kj hi bd kk ly lz ma ko mb mc md ks iq me mf kw iu mg mh la iy mi mj le mk bi translated">SSR的缺点</h2><ol class=""><li id="689f" class="ju jv hi ih b ii lg im lh iq ml iu mm iy mn jc jz ka kb kc bi translated">整个HTML需要在服务器中呈现并下载，以便向用户显示UI。</li><li id="911f" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">需要等到所有的JS都下载完，才能让组件<strong class="ih hj">交互</strong>。</li></ol><p id="d9ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得UX对于用户来说是非常糟糕的体验。为了克服这个问题，React引入了两个新特性</p><p id="d7b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SSR的两个主要特征是</p><ol class=""><li id="db7a" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">流式HTML</li><li id="4fb0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">选择性水合</li></ol><h1 id="e9e3" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">流式HTML</h1><p id="ecda" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">有了流HTML，react将发送静态HTML，如标题，菜单，只要它们准备好了就发送给客户端，并在它准备好流时加载沉重的组件(这取决于数据库中的数据，如评论组件)。所以现在用户不需要等待，就可以看到初始的UI渲染。</p><p id="6092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，渲染的UI不是交互式的，它需要等到JS被加载。所以这里<strong class="ih hj">选择性水合</strong>开始发挥作用</p><blockquote class="mo mp mq"><p id="fd7d" class="if ig mr ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><strong class="ih hj">水合是将JS连接到服务器生成的HTML的过程。</strong></p></blockquote><h1 id="f890" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">选择性水合</strong></h1><p id="c5e7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">选择性水合优先考虑哪个组分JS需要首先装载。当组件加载正在进行时，如果用户试图与任何组件进行交互。React将检测该事件并首先水合相互作用组分。</p><p id="9e37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些新的SSR功能将解决</p><ol class=""><li id="e275" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">不再等待在服务器上渲染所有的HTML</li><li id="185e" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">不再等待加载所有的JS来使组件交互</li><li id="8133" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">不再等待所有组分水合以与a组分相互作用。</li></ol><h1 id="2d23" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">并行暂记</h1><p id="7f95" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在悬疑来了全力支持。喜欢</p><ol class=""><li id="d2d0" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">延迟转换(在继续状态转换之前等待数据解析)。</li><li id="0b01" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">占位符限制(通过限制嵌套的连续占位符的外观来减少UI抖动)。</li><li id="4d9b" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">SuspenseList(协调组件列表或网格的外观，比如按顺序排列它们)</li></ol><p id="f8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查悬念示例</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="1f86" class="ls kj hi lo b fi lt lu l lv lw">&lt;Suspense fallback={&lt;Loading /&gt;}&gt;<br/>  &lt;ComponentThatSuspends /&gt;<br/>  &lt;Sibling /&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="c91a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，React将首先显示<code class="du mv mw mx lo b">&lt;Loading /&gt;</code>组件，然后在<code class="du mv mw mx lo b">&lt;ComponentThatSuspends/&gt;.</code>中解析数据时将<code class="du mv mw mx lo b">&lt;Loading /&gt;</code>组件替换为<code class="du mv mw mx lo b">&lt;ComponentThatSuspends /&gt;</code>和<code class="du mv mw mx lo b">&lt;Sibling/&gt;</code></p><p id="33cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">React 18 Concurrent suspension</strong>的新变化是<code class="du mv mw mx lo b">&lt;Suspense /&gt;</code>组件内的任何东西都不会被渲染，直到数据被解析！</p><p id="6eba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在<strong class="ih hj">遗留悬念(React 17中的悬念)</strong>兄弟组件被立即挂载到DOM，它的效果和生命周期被触发，并且对UI隐藏。</p><p id="66d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用React核心团队分享的示例，检查<strong class="ih hj">遗留暂挂</strong>和<strong class="ih hj">并发暂挂</strong>之间的差异。</p><p id="ab34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遗留悬念示例—<a class="ae jt" href="https://codesandbox.io/s/keen-banach-nzut8?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/keen-banach-nzut8?file=/src/App.js</a></p><p id="6d85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并发暂挂实例—<a class="ae jt" href="https://codesandbox.io/s/romantic-architecture-ht3qi?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/romantic-architecture-ht3qi?file=/src/App.js </a></p><h1 id="90df" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">现在让我们试试React Alpha</strong></h1><p id="1a7c" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">要安装最新的React 18 alpha，请使用<code class="du mv mw mx lo b">@alpha</code>标签</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="ba29" class="ls kj hi lo b fi lt lu l lv lw">npm install react@alpha react-dom@alpha</span></pre><p id="ccbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Alpha版到Beta版需要几个月的时间，到稳定版需要更多的时间。查看React <a class="ae jt" href="https://github.com/reactwg/react-18" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">工作组</strong> </a>了解更多详情。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="98a1" class="ki kj hi bd kk kl nf kn ko kp ng kr ks kt nh kv kw kx ni kz la lb nj ld le lf bi translated">资源</h1><ul class=""><li id="2654" class="ju jv hi ih b ii lg im lh iq ml iu mm iy mn jc nk ka kb kc bi translated">react Blog—<a class="ae jt" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank">https://react js . org/Blog/2021/06/08/the-plan-for-react-18 . html</a></li><li id="fc59" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc nk ka kb kc bi translated">React 18工作组—<a class="ae jt" href="https://github.com/reactwg/react-18" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Python Typed Annotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python类型化注释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/python-typed-annotations-1e3f3f5f6841?source=collection_archive---------6-----------------------#2021-04-24">https://medium.com/geekculture/python-typed-annotations-1e3f3f5f6841?source=collection_archive---------6-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d19c52c4f8ba577211f606af3c7c6ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c9ZLAXYk56xvPzUd"/></div></div></figure><p id="1fd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python 3.10刚刚在今年4月10日宣布了他们的<a class="ae jo" href="https://docs.python.org/3.10/whatsnew/3.10.html" rel="noopener ugc nofollow" target="_blank">版本</a>。大多数更新都是为了改善开发人员的体验和代码库的可维护性。</p><p id="ef40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们享受了编写Python代码的乐趣，因为它有可读的语法和用户友好的语言设计。很明显，这是为了摆脱通常在其他语言(如C++或Java)中使用的类型前缀。请记住，C++和Java都是编译语言，它们必须有一套语法规则来映射到您可以执行的机器代码上。但是Python是一种动态类型语言，解释器可以通过<a class="ae jo" href="https://bityl.co/6LB9" rel="noopener ugc nofollow" target="_blank">鸭子类型</a>——<em class="jp">的概念推断出我们在函数中调用的实体的类型，如果它走路像鸭子，叫声像鸭子，那么它一定是鸭子</em>。这给了我们很大的空间来关注算法，而不是担心表达代码逻辑的晦涩的编程语法。这对于相对较小的项目来说是可以的，在这些项目中，我们可以只注释掉函数(或方法)中期望的参数类型。但是与人一起构建一个可维护的软件系统需要一个比注释掉他们的功能期望更好的解决方案。</p><p id="4d4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们讨论Python中的类型化注释之前，让我们先欣赏一下其他语言中类型前缀的优雅，这样我们就可以知道什么时候注释我们的代码。尽管类型前缀会引入语法开销，但它内置于语言中是有原因的:(1) <a class="ae jo" href="https://bityl.co/6LBU" rel="noopener ugc nofollow" target="_blank">解析</a>，以及(2) <a class="ae jo" href="https://bityl.co/6LBT" rel="noopener ugc nofollow" target="_blank">类型安全</a>。在某种程度上，类型前缀保护我们的函数期望接受的类型和它返回的类型，因为我们通常可以把函数想象成一个接受和返回某些东西的黑盒。通过对其他编译语言施加类型限制，它使我们能够保持代码的意图性，我们可以保证它服务于它的目的。因此，我们不仅可以清楚地写(和读)什么进出我们的函数，还可以确保我们的函数接受我们指定的正确类型。</p><p id="6ae9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我们怎样才能让它适应Python呢？这就是类型注释的用武之地。</p><p id="34a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在接下来的章节中，我们将探索Python 3.10支持的类型注释的一些特性。在我们开始之前，下面是我们如何用Python注释一个简单的函数:</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es jq"><img src="../Images/b51fc627743dc5dc77809b58840936eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*Dgmgbxdrku2ujcDmH5o_TQ.png"/></div></figure><p id="5f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在<code class="du jv jw jx jy b">λ</code>函数的注释版本中看到的，它接受一个整数值<code class="du jv jw jx jy b">x</code>并返回一个类型为<code class="du jv jw jx jy b">float</code>的值，而未注释的版本可能需要猜测<code class="du jv jw jx jy b">λ</code>函数期望什么。考虑用C++编写的相同函数:</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/3d0853b23a57bcddddab403128ee0654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eOxy1M6lnodGJWxc3ps8w.png"/></div></div></figure><p id="13d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中类型注释的主要好处是可读性和静态分析。Python 3.5版本上的<a class="ae jo" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP 484 </a>指出，尽管Python可能支持运行时类型检查，但Python仍将是一种动态语言。</p><h1 id="dbf0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是静态分析，我们如何在Python中进行静态分析？</h1><p id="5bdb" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">静态分析工具是一种无需执行程序即可轻松检测漏洞的方法。这提供了对我们代码的深入了解，而不需要执行它们，从而自动维护代码质量。静态分析工具还可以在早期自动发现安全问题。到目前为止一切都很好，但是我们如何在我们的IDE上使用它呢？</p><p id="0886" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">存在几种类型的静态分析，它们有不同的目的，从样式分析到未使用的代码检测。<a class="ae jo" href="https://luminousmen.com/post/python-static-analysis-tools" rel="noopener ugc nofollow" target="_blank">这里有一篇我找到的文章</a>，探讨了Python静态分析的生态系统。</p><p id="04ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们来看看Python 3.10中类型注释的一些特性。</p><h2 id="e8d2" class="ld kb hi bd kc le lf lg kg lh li lj kk jb lk ll ko jf lm ln ks jj lo lp kw lq bi translated">新型联合算子</h2><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/0266c5144353c1588afddfc0bc558150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTfLeuJ2UD1ufpZDzLPrLQ.png"/></div></div></figure><p id="daea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">新的union操作符被接受为<code class="du jv jw jx jy b">isinstance()</code>和<code class="du jv jw jx jy b">issubclass()</code>函数的第二个参数，如下所示:</p><pre class="jr js jt ju fd ls jy lt lu aw lv bi"><span id="7426" class="ld kb hi jy b fi lw lx l ly lz">&gt;&gt;&gt; isinstance(1, int | str)<br/>True</span></pre><h2 id="0dc1" class="ld kb hi bd kc le lf lg kg lh li lj kk jb lk ll ko jf lm ln ks jj lo lp kw lq bi translated">改进的TypeAlias注释</h2><p id="6650" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">Python中的类型别名现在可以显式表达了。比较:</p><pre class="jr js jt ju fd ls jy lt lu aw lv bi"><span id="cf5a" class="ld kb hi jy b fi lw lx l ly lz"># in previous versions<br/>StrCache = 'Cache[str]'  # a type alias<br/>LOG_PREFIX = 'LOG[DEBUG]'  # a module constant</span></pre><p id="47de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和</p><pre class="jr js jt ju fd ls jy lt lu aw lv bi"><span id="75ee" class="ld kb hi jy b fi lw lx l ly lz"># in Python 3.10<br/>StrCache: TypeAlias = 'Cache[str]'  # a type alias<br/>LOG_PREFIX = 'LOG[DEBUG]'  # a module constant</span></pre><p id="3dfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多请看:<a class="ae jo" href="https://docs.python.org/3.10/whatsnew/3.10.html" rel="noopener ugc nofollow" target="_blank">docs.python.org/3.10/whatsnew/3.10.html</a>。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="3d77" class="ka kb hi bd kc kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx bi translated">外卖食品</h1><p id="3d0b" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">虽然类型注释可能会引入语法开销，但它提高了代码的可读性，从而保持了我们的意图完整。作为开发人员，我们希望我们的代码库易于使用，难以误用。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="a080" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">最初发布于</em><a class="ae jo" href="https://dcode.hashnode.dev/python-typed-annotations" rel="noopener ugc nofollow" target="_blank"><em class="jp">https://dcode . hash node . dev</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>
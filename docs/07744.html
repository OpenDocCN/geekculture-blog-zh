<html>
<head>
<title>Hooks — useMemo, useCallback, Custom Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挂钩—使用备忘录、使用回调、自定义挂钩</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hooks-usememo-usecallback-custom-hooks-828ad6113dfb?source=collection_archive---------0-----------------------#2021-09-29">https://medium.com/geekculture/hooks-usememo-usecallback-custom-hooks-828ad6113dfb?source=collection_archive---------0-----------------------#2021-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dea3a9d05fa147c1932ecc9dada02a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pD_a4MRxL5KqQi-DC_R0IQ.png"/></div></div></figure><p id="2422" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在早期的react版本&lt; 16.8 everyone is using class components of react where we can maintain local state of the component. Since there is no possibility of maintaining a state in functional component we used functional component as presentational/dumb component.</p><p id="1f70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Hooks is the new addition in react 16.8. Using <strong class="is hj">使用状态</strong>和<strong class="is hj">使用效果</strong>钩子中，功能组件的状态和生命周期可以被维护。在这篇文章中，让我们详细了解一下<strong class="is hj">使用备忘录</strong>和<strong class="is hj">使用回调</strong>钩子。</p><h1 id="a96d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用备忘录挂钩:</h1><p id="caa2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">useMemo用于<strong class="is hj">记忆数值并优化计算成本</strong>。</p><p id="2c5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使当有人在输入域中键入时，被过滤的用户不会改变，因为它们只在通过<code class="du kr ks kt ku b">search</code>状态单击按钮时改变，但是对于输入域中的每次击键，<strong class="is hj"> filteredUsers </strong>回调函数会反复运行。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/96b3daaf9257547358255b294020485a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kwf3n_3rdnku2cAcA6oGfw.png"/></div></div></figure><p id="d21f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这并没有降低这个小React应用程序的速度。然而，如果我们要处理这个数组中的大量数据，并为每次击键运行过滤器的回调函数，我们可能会降低应用程序的速度。因此，您可以使用React的useMemo钩子来<strong class="is hj">记忆一个函数的返回值</strong>，并且仅当函数的依赖项(这里是<code class="du kr ks kt ku b">search</code>)发生变化时才运行该函数。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/9ce8c893d3d7c1fbf6c9c2d3b569ba71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCZdfzb1UjoM2oA1Ujh-6A.png"/></div></div></figure><p id="8b60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过将useMemo包装到filteredUsers，仅当使用输入的文本更新搜索值以计算filteredUsers列表时，才重新呈现列表组件。我们可以通过使用useMemo来减少频繁的重新渲染。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/fc71c51e7642f6c1b681b9573885f90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*hHkEjTTww3KqO7KXCv7l1A.png"/></div></figure><p id="d7a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过在Codepen上尝试以下示例来检查日志:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="le lf et er es lg lh bd b be z dx">useMemo — demo</figcaption></figure><h1 id="1707" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用回调挂钩:</h1><p id="e0ea" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">useCallback用于<strong class="is hj">记忆功能。</strong></p><p id="320d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个钩子有助于防止频繁地重新呈现使用回调函数的子组件。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/2b67d283e02b11282a11825cffcd4193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-dghNt3SJJ4sMqovuUWFw.png"/></div></div></figure><p id="101d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，每当计数值发生变化时，increment1函数被重新实例化，从而CountButton组件被重新呈现。现在，在大多数情况下，这不是一个大问题，除非你传递许多不同的函数，都在改变不相关的数据，这被证明是你的应用程序性能的一大成本。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/9b5744fceb57a8c760f25a5cec4c6084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2lxTu-nTNY1KwhrSgEyiw.png"/></div></div></figure><p id="d977" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过向increment1函数添加useCallback，仅当count1发生更改时，CountButton组件才会重新呈现，increment1函数才会重新实例化。我们可以通过使用useCallback来减少频繁的重新渲染。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/c75a55a8501ed6ae9dbed7e8798e32ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*NN0GNsD8-t-iF8hYL97HKA.png"/></div></figure><p id="dd94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过在Codepen上尝试以下示例来检查日志:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="le lf et er es lg lh bd b be z dx">useCallback — demo</figcaption></figure><h1 id="9b2e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">自定义挂钩:</h1><p id="1ca8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们还可以想出自己的定制钩子来有效地管理状态。在这里，我们设计filterStateCustomHook来有效地重用用于过滤模态的状态。</p><p id="3aac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建useFilterState.js并粘贴以下内容:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/0d45da821cf2456646604098df959dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uq3xJNsJhdrhoGdF0cq-8g.png"/></div></div></figure><p id="f183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的钩子用于维护showFilter = &gt;来切换过滤器模式，isFilterApplied = &gt;来指示过滤器状态，appliedFilters = &gt;来维护所有应用的过滤器值。通过在需要添加过滤器模式的组件中使用上面的钩子，我们可以重用状态值，而不是专门为组件创建和维护状态。通过这种方式，我们可以减少维护的状态变量，从而从内部提高应用程序的性能。</p><p id="cd48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的钩子在我们的组件中使用如下:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/24e60d2ca476b5d22e317f7feaac4580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QG6kV6mdxJz3LYzYRtd6mQ.png"/></div></div></figure><h1 id="b7c0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论:</h1><p id="f049" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">使用钩子帮助我们改进了代码的设计模式和应用程序的性能，我鼓励你也在你的项目中使用它。</p><p id="a000" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的时间和关注。我希望你能从我写的东西中得到价值。</p></div></div>    
</body>
</html>
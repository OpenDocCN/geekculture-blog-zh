<html>
<head>
<title>Simplifying Event Filtering and Value Aggregation with RudderStack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RudderStack简化事件过滤和值聚合</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/simplifying-event-filtering-and-value-aggregation-with-rudderstack-67f4226f3bc4?source=collection_archive---------60-----------------------#2021-06-17">https://medium.com/geekculture/simplifying-event-filtering-and-value-aggregation-with-rudderstack-67f4226f3bc4?source=collection_archive---------60-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f56f17b6b62056739fe271f488939986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufU2Axy4E4qTQhQlg0n9cA.png"/></div></div></figure><p id="1c74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">处理事件数据有时很麻烦。由于开发人员所做的更改，开发人员可能会传输带有错误的事件。此外，如果数据工程团队决定更改数据仓库模式，有时可能会引入错误。由于对架构的这些更改，可能会发生数据类型冲突。人们如何处理生产环境中可能出现的所有不同的事件数据问题？这篇博客讨论了<a class="ae jo" href="http://www.rudderstack.com/" rel="noopener ugc nofollow" target="_blank"> RudderStack </a>如何处理事件过滤和值聚合而不引入手动错误。</p><p id="a426" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RudderStack的解决方案是一个复杂的机制。在这里，您可以使用JavaScript实现自定义逻辑来定义转换。您可以将这些转换应用于传入的事件。</p><p id="77be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拥有一个像RudderStack这样的表达环境为数据工程团队如何与数据交互提供了无限的可能性。在这篇博文中，我们将只探讨我们在RudderStack社区中遇到的两个最常见的用例。事件过滤和值聚合是通用的，易于实现，但非常强大。</p><h1 id="d29d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用于事件过滤和值聚合的用户转换</h1><p id="259e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您可以在RudderStack设置的配置平面中定义用户转换。在我们的<a class="ae jo" href="https://github.com/rudderlabs/sample-user-transformers" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上几乎没有可用的用户转换示例。这篇博客提供了对这样一个示例转换的深入了解，您可以将它用于:</p><ul class=""><li id="80c6" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><strong class="is hj">事件过滤:</strong>阻止事件传递到目的地。您可能需要过滤组织使用多种工具/平台来满足不同业务需求的事件。此外，您可能希望仅将特定事件路由到特定工具/平台目的地。</li><li id="720e" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><strong class="is hj">值聚合:</strong>这允许聚合特定事件类型的特定属性的值。当组织不打算使用工具/平台来执行事务级记录保存和/或分析时，您可能需要汇总值。相反，他们想要整合的记录/分析。因此，这种转换有助于减少网络流量和请求/消息量。这是因为系统可以用具有聚合值的同一类型的单个事件替换特定类型的多个事件。这种转变也有助于降低成本，因为目的地平台按事件/消息的数量收费。</li></ul><p id="3785" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在我们的<a class="ae jo" href="https://github.com/rudderlabs/sample-user-transformers/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面上查看示例转换。</p><h1 id="f82c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">履行</h1><p id="a74e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您需要在<code class="du lg lh li lj b">transform</code>函数中包含所有逻辑，该函数将一组事件作为输入，并返回一组转换后的事件。<code class="du lg lh li lj b">transform</code>函数是所有用户转换的入口点函数。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="48ee" class="ls jq hi lj b fi lt lu l lv lw">function transform(events) {<br/>	const filterEventNames = [<br/>    		// Add list of event names that you want to filter out<br/>   	 "game_load_time",<br/>   		 "lobby_fps"<br/>	];</span><span id="971b" class="ls jq hi lj b fi lx lu l lv lw"> //remove events whose name match those in above list<br/>	const filteredEvents = events.filter(event =&gt; {<br/>    	const eventName = event.event;<br/>    		return !(eventName &amp;&amp; filterEventNames.includes(eventName));<br/>	});</span></pre><p id="3668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码片段展示了如何使用JavaScript数组的<code class="du lg lh li lj b">filter</code>函数根据事件名称过滤出事件。</p><p id="7a4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该代码的变体也是可能的。在这里，事件名称数组中的值是您希望<em class="ly">保留的值，您从倒数第二行的<code class="du lg lh li lj b">return</code>语句中删除了not ( <code class="du lg lh li lj b">!</code>)条件。</em></p><p id="fde1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码显示了基于简单检查(如事件名称匹配)的事件删除，但更复杂的逻辑涉及检查相关属性值的存在。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="977f" class="ls jq hi lj b fi lt lu l lv lw">//remove events of a certain type if related property value does not satisfy the pre-defined condition<br/>//in this example, if 'total_payment' for a 'spin' event is null or 0, then it would be removed.<br/>    	//Only non-null, non-zero 'spin' events would be considered<br/>	const nonSpinAndSpinPayerEvents = filteredEvents.filter( event =&gt; {<br/>    		const eventName = event.event;<br/>    	// spin events<br/>    		if(eventName.toLowerCase().indexOf('spin') &gt;= 0) {<br/>        		if(event.userProperties &amp;&amp; event.userProperties.total_payments <br/>&amp;&amp; event.userProperties.total_payments &gt; 0) {<br/>            		return true;<br/>        	} else {<br/>            			return false;<br/>        		}<br/>    		} else {<br/>        			return true;<br/>    	}<br/>	});</span></pre><p id="5427" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的例子可以看出，您可以使用过滤后的数组作为一个步骤的输出，作为下一个步骤的输入。因此，您可以将转换条件以菊花链形式连接起来。</p><p id="dd58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，下面的代码展示了如何为批处理中特定类型事件的特定属性准备聚合。此后，代码返回相关类型的单个事件。此外，代码返回相应属性的聚合值。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="349e" class="ls jq hi lj b fi lt lu l lv lw">//remove events of a certain type if related property value does not satisfy the pre-defined condition<br/>//in this example, if 'total_payment' for a 'spin' event is null or 0, then it would be removed.<br/>    	//Only non-null, non-zero 'spin' events would be considered<br/>	const nonSpinAndSpinPayerEvents = filteredEvents.filter( event =&gt; {<br/>    		const eventName = event.event;<br/>    	// spin events<br/>    		if(eventName.toLowerCase().indexOf('spin') &gt;= 0) {<br/>        		if(event.userProperties &amp;&amp; event.userProperties.total_payments <br/>&amp;&amp; event.userProperties.total_payments &gt; 0) {<br/>            		return true;<br/>        	} else {<br/>            			return false;<br/>        		}<br/>    		} else {<br/>        			return true;<br/>    	}<br/>	});</span></pre><h1 id="c662" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="a6ef" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在上面的片段中:</p><ul class=""><li id="9055" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">首先，代码将<code class="du lg lh li lj b">spin_result</code>事件收集到一个数组中。</li><li id="35a0" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">然后，代码通过迭代上述数组的元素来聚合三个属性的值— <code class="du lg lh li lj b">bet_amount</code>、<code class="du lg lh li lj b">win_amount</code>和<code class="du lg lh li lj b">no_of_spin</code>。</li><li id="e007" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">此后，系统将聚合值分配给数组中第一个<code class="du lg lh li lj b">spin_result</code>事件的相应属性。</li><li id="2e1c" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">现在，代码将非目标类型的事件(在本例中为<code class="du lg lh li lj b">spin_result</code>)分离到另一个数组中。如果没有这样的事件，则创建一个空数组。</li><li id="ef2f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">最后，系统将<code class="du lg lh li lj b">single spin_result</code>事件添加到上一步创建的数组中，并返回结果。</li></ul><h1 id="9ea7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">免费注册并开始发送数据</h1><p id="da2d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">测试我们的事件流、ELT和反向ETL管道。使用我们的HTTP源在不到5分钟的时间内发送数据，或者在您的网站或应用程序中安装我们12个SDK中的一个。<a class="ae jo" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">入门</a>。</p><p id="3bd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本博客最初发表于<br/><a class="ae jo" href="https://rudderstack.com/blog/simplifying-event-filtering-and-value-aggregation-with-rudderstack" rel="noopener ugc nofollow" target="_blank">https://rudder stack . com/blog/simplified-event-filtering-and-value-aggregation-with-rudder stack</a></p></div></div>    
</body>
</html>
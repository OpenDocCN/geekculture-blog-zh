<html>
<head>
<title>Is there a better way of writing Integration Tests using containers in .NET?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中使用容器编写集成测试有没有更好的方法？网？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/is-there-a-better-way-of-writing-integration-tests-in-using-containers-net-233de3a23891?source=collection_archive---------11-----------------------#2022-12-12">https://medium.com/geekculture/is-there-a-better-way-of-writing-integration-tests-in-using-containers-net-233de3a23891?source=collection_archive---------11-----------------------#2022-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee1e39aaba7735c7b8cfb9bdd22acdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxKytVgZZ8pkIdaos7R8EQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://pixabay.com/users/valdasmiskinis-12049839/" rel="noopener ugc nofollow" target="_blank">ValdasMiskinis</a> on <a class="ae iu" href="https://pixabay.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="a52d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">太长了，读不下去</h1><p id="e69f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">编写集成测试最干净的方式是使用一次性容器。TestContainers 库帮助你轻松管理它。</p><h1 id="9c6c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">更多…</h1><p id="5aba" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">管理自动化测试的依赖关系是一项挑战。我们可以花费数小时来手动管理它，或者我们可以自动化它并使用第三方库来管理它。在这篇文章中，我正在寻找一种简洁、简单的方法来为现代ASP.NET web应用程序编写集成测试。</p><h2 id="cc1c" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">被测系统</h2><p id="521f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我的例子公开了一个REST API来<em class="lf">创建</em>和<em class="lf">获取</em>汽车:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="406c" class="lp iw hi ll b be lq lr l ls lt">[HttpPost]<br/>public async Task&lt;CarModel&gt; Create(CarModel model)<br/>{<br/>    using (var connection = await _dbConnectionFactory.CreateConnectionAsync())<br/>    {<br/>        _logger.LogInformation("connection string: " + connection.ConnectionString);<br/>        _logger.LogInformation("model: " + model);<br/>        _logger.LogInformation("Checked=" + model.Available + " Text" + model.Name);<br/>        var result = await connection.QueryAsync&lt;string&gt;("INSERT INTO cars (name, available) values (@Name, @Available); SELECT LAST_INSERT_ID();", model);<br/>        var id = result.Single();<br/>        return await Get(id);<br/>    }<br/>}<br/><br/>[HttpGet("{id}")]<br/>public async Task&lt;CarModel&gt; Get(string id)<br/>{<br/>    using (var connection = await _dbConnectionFactory.CreateConnectionAsync())<br/>    {<br/>        _logger.LogInformation("Connection: " + connection.ConnectionString);<br/>        var result = await connection.QueryAsync&lt;CarModel&gt;("SELECT id,available,name FROM cars WHERE id=@Id", new { Id = id });<br/>        var model = result.FirstOrDefault();<br/>        _logger.LogInformation("Model with id: " + model.Id);<br/>        return model;<br/>    }<br/>}</span></pre><p id="3d27" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">你可以在这里找到完整的代码<a class="ae iu" href="https://github.com/alkondrashov/integration-testing-docker" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="66cb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">从集成测试开始</h1><p id="0438" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi">🟢 ⚪ ⚪</p><blockquote class="lz ma mb"><p id="10d9" class="jt ju lf jv b jw lu jy jz ka lv kc kd mc lw kg kh md lx kk kl me ly ko kp kq hb bi translated"><strong class="jv hj">集成测试</strong> —是一种软件测试，其中软件应用程序的不同单元、模块或组件作为一个组合实体进行测试。</p></blockquote><p id="c742" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">我们如何知道我们写了一个集成测试？我们应该在测试中从上到下调用我们系统的所有层:<em class="lf"> REST API </em>，<em class="lf">控制器</em>，<em class="lf">服务</em>，<em class="lf">仓库</em>和<em class="lf">数据库</em>。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="709f" class="lp iw hi ll b be lq lr l ls lt">[Fact]<br/>public async void testCreateCar()<br/>{<br/>    var client = _factory.CreateClient();<br/><br/>    var car = new CarModel { Available = false, Name = "Test Text" };<br/><br/>    var result = await client.PostAsync(_endpoint, new StringContent(JsonConvert.SerializeObject(car), Encoding.UTF8, "application/json"));<br/>    var expectedModel = JsonConvert.DeserializeObject&lt;CarModel&gt;(await result.Content.ReadAsStringAsync());<br/>    <br/>    var response = await client.GetAsync($"{_endpoint}/{expectedModel.Id}");<br/>    var actualModel = JsonConvert.DeserializeObject&lt;CarModel&gt;(await response.Content.ReadAsStringAsync());<br/>    <br/>    Assert.Equal(expectedModel.Id, actualModel.Id);<br/>    Assert.Equal(expectedModel.Name, actualModel.Name);<br/>}</span></pre><p id="9617" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">如果我们在运行测试之前运行REST API和数据库，它将会通过。我们有证据证明我们的系统现在工作了！任何集成测试都比没有测试要好。</p><h1 id="1075" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用Docker的DIY一次性容器</h1><p id="dc19" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi">🟢 🟢 ⚪</p><p id="795f" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">上面的测试有什么问题？运行它需要大量的体力劳动。我们需要手动管理数据库和web应用程序。</p><p id="1fbf" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">当我们开始测试时，我们希望增强依赖关系，当执行结束时，我们希望拆除依赖关系。码头工人应该能帮上忙。我们可以使用3个容器来完成它:运行集成测试的<code class="du mf mg mh ll b">web application</code>、<code class="du mf mg mh ll b">database</code>和<code class="du mf mg mh ll b">integration</code>容器。容器之间的所有集成都在<code class="du mf mg mh ll b">docker-compose.yml</code>中编码:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="2a5b" class="lp iw hi ll b be lq lr l ls lt">version: '3'<br/><br/>services:<br/>  integration:<br/>    build: <br/>      context: .<br/>      dockerfile: Dockerfile.integration<br/>    environment:<br/>      - API_URL=http://web:5001<br/>      - CONNECTION_STRING=Server=db;Database=carsdb;Uid=root;Pwd=password;SslMode=Required;      <br/>    entrypoint: bash /app/wait_for_it.sh web:5001 -t 0 -- dotnet test --logger "console;verbosity=detailed"<br/>    depends_on:<br/>      - web<br/>      - db<br/>  web:<br/>    build: .<br/>    ports: <br/>      - 5001:5001<br/>    environment:<br/>      - ASPNETCORE_ENVIRONMENT=Development<br/>      - CONNECTION_STRING=Server=db;Database=carsdb;Uid=root;Pwd=password;SslMode=Required;<br/>    entrypoint: bash /app/wait_for_it.sh db:3306 -t 0 -- dotnet /app/Cars.dll<br/>    depends_on:<br/>      - db<br/>  db:<br/>    platform: linux/x86_64<br/>    image: mysql<br/>    ports:<br/>      - 3307:3306<br/>    # Start the container with a carsdb, and password as the root users password<br/>    environment: <br/>      - MYSQL_DATABASE=carsdb<br/>      - MYSQL_ROOT_PASSWORD=password<br/>    # Volume the scripts folder over that we setup earlier.<br/>    volumes: <br/>      - ./Scripts:/docker-entrypoint-initdb.d</span></pre><p id="e5dd" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">完整的代码是<a class="ae iu" href="https://github.com/alkondrashov/integration-testing-docker" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="b470" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">我们现在可以通过<code class="du mf mg mh ll b">docker-compose up -build -abort-on-container-exit</code>运行集成测试。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/7c76345d7c39255cf4449d8a496e8a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5NOMUznPTTcZ_iPFIZR__g.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Console output when running tests using <strong class="bd ix"><em class="mj">docker-compose</em></strong></figcaption></figure><p id="09c8" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">这看起来好多了！我们不必分别管理数据库和web服务器。一切都通过Docker处理。但是，解决方案并不干净，还可以改进。主要问题是我们继承了底层Docker设置。此外，容器在测试执行后不会被清除。</p><h1 id="f6fa" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">管理一次性容器的TestContainers</h1><p id="2702" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi">🟢 🟢 🟢</p><blockquote class="lz ma mb"><p id="208c" class="jt ju lf jv b jw lu jy jz ka lv kc kd mc lw kg kh md lx kk kl me ly ko kp kq hb bi translated"><strong class="jv hj"> Testcontainers </strong>用于。NET是一个库，支持对所有兼容的Docker容器的一次性实例进行测试。NET标准版本。图书馆建在屋顶上。NET Docker remote API，并提供了一个轻量级的实现来支持所有情况下的测试环境。</p></blockquote><p id="4ce4" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">如果我们不想自己管理Docker容器，这个库提供了一种简洁的方式来编写集成测试。</p><p id="9e4b" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">我们可以为我们的web应用程序使用预定义的<code class="du mf mg mh ll b">MySqlTestcontainer</code>。TestContainer的配置是通过<code class="du mf mg mh ll b">WebApplicationFactory</code>类完成的:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="5b8f" class="lp iw hi ll b be lq lr l ls lt">public class IntegrationTestFactory : WebApplicationFactory&lt;Program&gt;, IAsyncLifetime<br/>{<br/>    private readonly TestcontainerDatabase _container;<br/><br/>    public IntegrationTestFactory()<br/>    {<br/>        _container = new TestcontainersBuilder&lt;MySqlTestcontainer&gt;()<br/>            .WithDatabase(new MySqlTestcontainerConfiguration<br/>            {<br/>                Password = "localdevpassword#123",<br/>                Database = "carsdb",<br/>            })<br/>            .WithImage("mysql:latest")<br/>            .WithCleanUp(true)<br/>            .Build();<br/>    }<br/>    <br/>    protected override void ConfigureWebHost(IWebHostBuilder builder)<br/>    {<br/>        builder.ConfigureTestServices(services =&gt;<br/>        {<br/>            services.RemoveAll&lt;IDbConnectionFactory&gt;();<br/>            services.AddSingleton&lt;IDbConnectionFactory&gt;(_ =&gt; new MySqlConnectionFactory(_container.ConnectionString));<br/>        });<br/>    }<br/><br/>    public async Task InitializeAsync()<br/>    {<br/>        await _container.StartAsync();<br/>        await _container.ExecScriptAsync("CREATE TABLE IF NOT EXISTS cars (id SERIAL, name VARCHAR(100), available BOOLEAN)");<br/>    }<br/><br/>    public new async Task DisposeAsync() =&gt; await _container.DisposeAsync();<br/>}</span></pre><p id="51bc" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">多亏了<code class="du mf mg mh ll b">IAsyncLifetime</code>，我们可以使用<code class="du mf mg mh ll b">InitializeAsync()</code>和<code class="du mf mg mh ll b">DisposeAsync()</code>方法初始化和处理我们的数据库。</p><p id="45ca" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">我们现在需要使用<code class="du mf mg mh ll b">IntegrationTestFactory</code>来得到一个假的<code class="du mf mg mh ll b">HttpClient</code>:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="3eec" class="lp iw hi ll b be lq lr l ls lt">[Fact]<br/>public async void testCreateCar()<br/>{<br/>    var client = _factory.CreateClient();<br/><br/>    var car = new CarModel { Available = false, Name = "Test Text" };<br/><br/>    var result = await client.PostAsync(_endpoint, new StringContent(JsonConvert.SerializeObject(car), Encoding.UTF8, "application/json"));<br/>    var expectedModel = JsonConvert.DeserializeObject&lt;CarModel&gt;(await result.Content.ReadAsStringAsync());<br/>    <br/>    var response = await client.GetAsync($"{_endpoint}/{expectedModel.Id}");<br/>    var actualModel = JsonConvert.DeserializeObject&lt;CarModel&gt;(await response.Content.ReadAsStringAsync());<br/>    <br/>    Assert.Equal(expectedModel.Id, actualModel.Id);<br/>    Assert.Equal(expectedModel.Name, actualModel.Name);<br/>}</span></pre><p id="ddfa" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">这种方法允许我们使用<code class="du mf mg mh ll b">dotnet test</code>命令运行测试，这是一个优点:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/62c32fc50d6122e773c65954384359c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9eWsfHwge3v55IFy91trQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Console output when running tests using TestContainer</figcaption></figure><p id="6b50" class="pw-post-body-paragraph jt ju hi jv b jw lu jy jz ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq hb bi translated">看看这个！我们已经在Docker中运行了集成测试，无需手动管理容器。</p><h1 id="4e86" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">摘要</h1><p id="4177" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们已经编写了一个集成测试，运行它所需要做的就是启动Docker并执行<code class="du mf mg mh ll b">dotnet test</code>命令。web服务器和数据库将由TestContainers库为我们提供。如果你认为这有什么缺点，请在下面的评论中告诉我。</p><h1 id="ddbd" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">资源</h1><ol class=""><li id="0231" class="ml mm hi jv b jw jx ka kb ke mn ki mo km mp kq mq mr ms mt bi translated"><a class="ae iu" href="https://github.com/alkondrashov/integration-testing-docker" rel="noopener ugc nofollow" target="_blank">存储库</a>使用Docker Compose进行集成测试。</li><li id="cdcb" class="ml mm hi jv b jw mu ka mv ke mw ki mx km my kq mq mr ms mt bi translated"><a class="ae iu" href="https://github.com/alkondrashov/integration-testing-testcontainers" rel="noopener ugc nofollow" target="_blank">存储库</a>使用TestContainers进行集成测试。</li></ol></div></div>    
</body>
</html>
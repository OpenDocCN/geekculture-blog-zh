<html>
<head>
<title>How to deal with deadlocks in mysql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理mysql中的死锁</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-deal-with-deadlocks-in-mysql-58f4d830788b?source=collection_archive---------13-----------------------#2021-08-22">https://medium.com/geekculture/how-to-deal-with-deadlocks-in-mysql-58f4d830788b?source=collection_archive---------13-----------------------#2021-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="23ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">死锁是一个常见的问题，但对一些人来说很神秘。大多数情况下，这是无害的，因为事务将被回滚。但是如果治疗不当，有时会变得很难看。</p><h1 id="79e2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">定义</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/5180d13fec35b050895e158f7701a6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uE4HbY3-BVMllCU6UnoWA.png"/></div></div></figure><p id="e0fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">死锁是指多个(通常是2个)事务(进程)等待对方锁定的情况。通常mysql可以通过回滚事务来检测和解决这个问题，除非死锁检测被关闭。</p><p id="fd8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">死锁不仅限于数据库系统。哪里有并发，哪里就有死锁！</p><h1 id="231a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">战略</h1><p id="6038" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">处理死锁的策略包括3个步骤:</p><ol class=""><li id="b4b9" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">识别违规交易</li><li id="26b0" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">在源代码中定位违规的事务</li><li id="301a" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">找出合适的解决方案</li></ol><h2 id="f9cb" class="lg je hi bd jf lh li lj jj lk ll lm jn iq ln lo jr iu lp lq jv iy lr ls jz lt bi translated">1.识别违规交易</h2><p id="c255" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">第一步是获取死锁信息。一个简单的<em class="lu"> SHOW ENGINE INNODB STATUS </em>就可以了，但是它只显示最新的死锁，这对于了解一段时间内死锁的全貌没有太大帮助。</p><p id="8184" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，mysql 5.5.30中有一个名为<em class="lu">的设置，可以帮助将所有死锁打印到mysql错误日志中。启用此功能不会导致任何停机。</em></p><p id="0d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，检索后的日志会是这样的:</p><pre class="kc kd ke kf fd lv lw lx ly aw lz bi"><span id="245b" class="lg je hi lw b fi ma mb l mc md">*** (1) TRANSACTION:<br/>TRANSACTION 450913541522, ACTIVE 0 sec starting index read<br/>mysql tables in use 1, locked 1<br/>LOCK WAIT 7 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 2<br/>MySQL thread id 93608210, OS thread handle 47321957033728, query id 10802490531 10.0.64.165 db updating<br/>update `table1` set `scroll_to` = 3901, `updated_at` = ‘2021–08–17 11:30:53’ where `id` = 668126442<br/>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:<br/>RECORD LOCKS space id 1455 page no 5719543 n bits 0 index PRIMARY of table `db`.`table1` trx id 450913541522 lock_mode X locks rec but not gap waiting<br/>Record lock, heap no 95 PHYSICAL RECORD: n_fields 24; compact format; info bits 0</span><span id="867b" class="lg je hi lw b fi me mb l mc md">*** (2) TRANSACTION:<br/>TRANSACTION 450913541519, ACTIVE 0 sec inserting<br/>mysql tables in use 1, locked 1<br/>LOCK WAIT 9 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 4<br/>MySQL thread id 93608214, OS thread handle 47339872995072, query id 10802490581 10.0.63.235 admin update<br/>insert into `table2` (`user_id`, `company_id`, `date`, `steps`, `updated_at`, `created_at`) values (491031, 1, ‘2021–08–17’, 359, ‘2021–08–17 11:30:53’, ‘2021–08–17 11:30:53’)<br/>*** (2) HOLDS THE LOCK(S):<br/>RECORD LOCKS space id 1455 page no 5719543 n bits 0 index PRIMARY of table `db`.`table1` trx id 450913541519 lock_mode X locks rec but not gap<br/>Record lock, heap no 95 PHYSICAL RECORD: n_fields 24; compact format; info bits 0</span><span id="9f8e" class="lg je hi lw b fi me mb l mc md">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:<br/>RECORD LOCKS space id 5817 page no 4486 n bits 0 index PRIMARY of table `db`.`user` trx id 450913541519 lock mode S locks rec but not gap waiting<br/>Record lock, heap no 99 PHYSICAL RECORD: n_fields 29; compact format; info bits 0</span></pre><p id="82fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有很多信息，但是由于我只对哪个事务/查询持有哪个锁以及等待哪个锁感兴趣，所以我可以总结如下:</p><pre class="kc kd ke kf fd lv lw lx ly aw lz bi"><span id="1e7c" class="lg je hi lw b fi ma mb l mc md"><em class="lu">Transaction 1: update `table1` set `scroll_to` = 3901, `updated_at` = ‘2021–08–17 11:30:53’ where `id` = 668126442<br/></em>-&gt; Holding an X lock on `db`.`user`<br/>-&gt; Wait for an X lock on `db`.`table1`</span><span id="ef09" class="lg je hi lw b fi me mb l mc md"><em class="lu">Transaction 2: insert into `table2` (`user_id`, `company_id`, `date`, `steps`, `updated_at`, `created_at`) values (491031, 1, ‘2021–08–17’, 359, ‘2021–08–17 11:30:53’, ‘2021–08–17 11:30:53’)<br/></em>-&gt; Hold an X lock on `db`.`table1`<br/>-&gt; Wait for an S lock on `db`.`user`</span></pre><p id="3f7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，虽然日志没有指定事务1持有的锁，但是我们可以推断事务1持有<em class="lu"> `db`.`user` </em>上的锁，事务2正在等待该锁。</p><p id="8a07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意，事务1只更新<em class="lu">表1 </em>，但是它持有表<em class="lu">用户的锁；</em>同样的事情也适用于事务2:它插入到<em class="lu">表2 </em>中，但持有<em class="lu">表1 </em>的锁，并等待表<em class="lu">用户</em>的锁。乍一看，这似乎很奇怪，但原因是这里显示的查询只是整个事务的一部分。这意味着在<code class="du mf mg mh lw b">update `table1`</code>之前，事务1已经对<em class="lu">用户</em>表做了一些事情，因此它持有X锁。同样的解释适用于交易2。这种锁持有/等待信息对于查明这些事务在应用程序源代码中的位置是必要的。</p><h2 id="12e6" class="lg je hi bd jf lh li lj jj lk ll lm jn iq ln lo jr iu lp lq jv iy lr ls jz lt bi translated">2.在源代码中定位违规的事务</h2><p id="5d46" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">下一步是在应用程序代码中搜索事务，通常是通过编辑器的搜索引擎。事务应该包括持有/等待锁的查询，这些锁对应于我们在步骤1中发现的锁。</p><p id="9e4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于大型代码库来说，这可能是一项艰巨的任务，尤其是对于那些使用ORM进行数据库交互的人来说。虽然表名有助于缩小搜索范围，但这需要耐心。您可能还想检查应用程序日志中由死锁产生的错误，这些错误也包含一些关于违规代码行的信息。</p><h2 id="ac0c" class="lg je hi bd jf lh li lj jj lk ll lm jn iq ln lo jr iu lp lq jv iy lr ls jz lt bi translated">3.找出合适的解决方案</h2><p id="577d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在深入研究了应用程序代码之后，我想您已经找到了罪魁祸首。最后一步是找到解决它们的方法。</p><p id="98fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并发是死锁的根源。为了减少死锁发生的机会，事务应该是快速的，以防止被其他事务干扰。通过重构加速它们:</p><ul class=""><li id="b390" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc mi ky kz la bi translated">将业务逻辑代码放在事务之外。我见过遗留项目中充斥着业务逻辑的臃肿的事务。</li><li id="9b4c" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc mi ky kz la bi translated">加速缓慢的查询</li></ul><p id="122c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个解决方案是通过进行同步调用来避免并发。例如:在打开应用程序时，用户的位置和用户的活动信息被异步(同时)发送到服务器，导致数据库死锁。将这些调用转换成同步调用应该可以消除死锁，因为没有并发就没有死锁。如果重构不是遗留项目中的一个选项，这是一个很好的选择。然而，如果业务逻辑不允许这样的变化，这个解决方案可能就行不通了。</p><h1 id="5abd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="828d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">他们说这就像僵局一样令人讨厌和神秘，但是如果我们有一点耐心，知道去哪里寻找，它就会变得不那么神秘，而更像是一个肯定可以摆脱的麻烦。</p></div></div>    
</body>
</html>
<html>
<head>
<title>How to Create a Pinterest Clone Part III: Display and Searching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建Pinterest克隆第三部分:显示和搜索</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-create-a-pinterest-clone-part-iii-display-and-searching-bb1d36e49a0f?source=collection_archive---------9-----------------------#2022-07-16">https://medium.com/geekculture/how-to-create-a-pinterest-clone-part-iii-display-and-searching-bb1d36e49a0f?source=collection_archive---------9-----------------------#2022-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1e9fd55979b435e8d80cc1dc284734a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO0G_mlYhvoytRUwW_S_Ag.png"/></div></div></figure><p id="cea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">概述及目标</strong></p><p id="dd5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前两篇博客(<a class="ae jo" rel="noopener" href="/geekculture/how-to-create-a-pinterest-clone-part-i-upload-photos-a1f385812729">第1部分</a>和<a class="ae jo" rel="noopener" href="/geekculture/how-to-create-a-pinterest-clone-part-ii-image-classification-1ecf4cca0b20">第2部分</a>)中，我们构建了一个web应用程序，其中包含一个供用户上传照片的网页和一个API端点，该端点使用经过训练的神经网络标记照片，将照片文件存储在MongoDB中，并将MongoDB生成的对象ID和标记一起保存到TigerGraph数据库中。在这篇博客中，我们将添加两个功能:显示和搜索。</p><p id="37e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一节:实现后端</strong></p><p id="7b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在后端需要两个新的端点。一个将通过对象ID从MongoDB中检索照片文件，另一个将返回一个照片ID列表，给出一个可选的搜索文本。</p><p id="5815" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说第一个。使用<a class="ae jo" href="https://motor.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">马达</a>模块，可以直接通过对象ID在MongoDB中获得一个条目。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a3d4" class="jy jz hi ju b fi ka kb l kc kd"># from bson.objectid import ObjectId<br/>####################<br/># Connection to MongoDB<br/># client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")<br/># database = client.photo_manager<br/># photo_collection = database.get_collection("photos")</span><span id="0092" class="jy jz hi ju b fi ke kb l kc kd"># Get a specific photo from MongoDB by ID<br/>async def retrieve_photo_from_MongoDB(id:str):<br/>    try:<br/>        entry = await photo_collection.find_one({"_id": ObjectId(id)})<br/>        if entry:<br/>            return entry<br/>        else:<br/>            return False<br/>    except:<br/>        return False</span></pre><p id="e6bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数的返回值要么是False，要么是一个形式为<code class="du kf kg kh ju b">{_id: &lt;Object ID&gt;, photo: &lt;Photo file in bytes&gt;}</code>(python字典)的条目。然后，我们可以在API端点中使用这个函数。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="cd01" class="jy jz hi ju b fi ka kb l kc kd"># from fastapi.responses import Response<br/># import base64<br/>@app.put("/retrievePhoto/{id}")<br/>async def retrieve_photo(id: str):<br/>    data = await retrieve_photo_from_MongoDB(id)<br/>    if not data:<br/>        return { "code": 401, "message": "Failed to get photo."}<br/>    contents = data["photo"]<br/>    contents = base64.b64encode(contents)<br/>    return Response(content=contents, media_type="image/png")</span></pre><p id="025a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要注意的一点是，如果我们直接传输文件的原始字节，它们可能包含干扰连接的网络协议的保留字节，所以我们需要用<a class="ae jo" href="https://docs.python.org/3/library/base64.html" rel="noopener ugc nofollow" target="_blank"> Base64数据编码</a>对字节进行编码。编码的结果也是一个字节数组，我们会把它传回前端，不做进一步处理，因为在前端从编码的字节重建文件更容易。<code class="du kf kg kh ju b">media_type</code>参数只是对其真实类型的一个提醒。我们可以把<code class="du kf kg kh ju b">media_type="image/jpeg"</code>或其他一些类型。</p><p id="20c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一件要注意的事情是，我们需要添加一些CORS设置，以便返回媒体类型的响应。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="d1d3" class="jy jz hi ju b fi ka kb l kc kd"># from fastapi.middleware.cors import CORSMiddleware<br/>####################<br/># API endpoints</span><span id="45d9" class="jy jz hi ju b fi ke kb l kc kd"># app = FastAPI()<br/>app.add_middleware(<br/>    CORSMiddleware,<br/>    allow_origins=["*"],<br/>    allow_credentials=True,<br/>    allow_methods=["*"],<br/>    allow_headers=["*"],<br/>)</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="0dd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们转到另一个端点，它可以返回搜索文本的照片id列表，我们将在TigerGraph上编写一个查询来帮助完成这个任务！</p><p id="5275" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在https://tgcloud.io/<a class="ae jo" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">访问TigerGraph云门户</a>，登录你的账户，启动你的解决方案，然后像上次一样打开GraphStudio。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/0a513b2f2c635f3306ea8ac55304218a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqpapoHgnXC4gSFnjvH-Yw.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/5b0dba9c99173c2bcc3d319c30a964a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnLNW8G_Yq_8NRjPHpT1rA.png"/></div></div></figure><p id="e163" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，切换到左上角的“照片”图，单击“编写查询”选项卡，并使用“+”按钮创建一个新的查询。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/cfb0e03a462b1b4b22ec6adf651c4680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMwnNG7JSaXwn-azwghr6g.png"/></div></div></figure><p id="2a0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在弹出窗口中，输入<code class="du kf kg kh ju b">FetchAllPhotos</code>作为名称，然后单击创建。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/c86ca7e2dccf80f1c549d12d1ab47c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bwCCrE-s3BdcXiz41dFZA.png"/></div></div></figure><p id="2234" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用下面的代码替换默认的查询内容。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b121" class="jy jz hi ju b fi ka kb l kc kd">CREATE QUERY FetchAllPhotos(STRING text, FLOAT threshold) FOR GRAPH photos { <br/>  STRING pattern = "%" + lower(text) + "%";<br/>  seed = SELECT u FROM Type:u WHERE lower(u.name) LIKE pattern;<br/>  result = SELECT v FROM seed:u - (PHOTO_HAS_TYPE:e) - Photo:v<br/>            WHERE e.probability &gt;= threshold;<br/>  PRINT result;<br/>}</span></pre><p id="8a10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，这是一个<a class="ae jo" href="https://docs.tigergraph.com/gsql-ref/current/querying/query-operations" rel="noopener ugc nofollow" target="_blank"> GSQL查询</a>，它接受两个参数(搜索文本和一个概率阈值)，找到所有与搜索文本名称相似的<code class="du kf kg kh ju b">Type</code>顶点，并返回所有与概率大于阈值的这种类型连接的<code class="du kf kg kh ju b">Photo</code>顶点。如果参数<code class="du kf kg kh ju b">text</code>是一个空字符串，所有类型都将被接受。</p><p id="c294" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用GSQL语言我们可以完成更多的事情，比如排序和过滤。如果你有兴趣，请查看<a class="ae jo" href="https://docs.tigergraph.com/gsql-ref/current/querying/select-statement/" rel="noopener ugc nofollow" target="_blank">这篇文档</a>获取更多示例！</p><p id="d610" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以用顶部栏上的按钮保存、安装和运行查询了！一旦你的TigerGraph数据库填充了一些数据，你就可以用不同的输入来测试它。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/baa85e615063381e0c65c274acf73b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U8pBma_A3IGEObLYm1Uww.png"/></div></div></figure><p id="7ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在TigerGraph数据库上安装了查询之后，我们就可以完成最后一个API端点了。我们需要一个函数来运行查询，并返回与要显示的照片相对应的对象id列表。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="83dd" class="jy jz hi ju b fi ka kb l kc kd">async def retrieve_all_photo_info_from_TigerGraph(text: str):<br/>    try:<br/>        threshold = 0.5<br/>        results = conn.runInstalledQuery("FetchAllPhotos", params={<br/>            "text": text,<br/>            "threshold": threshold<br/>        })<br/>        ret = []<br/>        for photo_info in results[0]["result"]:<br/>            ret.append(photo_info["attributes"]["id"])<br/>        return ret<br/>    except:<br/>        return False</span></pre><p id="ca4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们根据经验将阈值设置为0.5，这样，如果用户搜索“衬衫”，将只显示被分类为概率高于50%的衬衫的照片。然后，我们可以轻松地实现API端点。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b07d" class="jy jz hi ju b fi ka kb l kc kd"># from typing import Union<br/>@app.put("/retrieveAllPhotoInfo")<br/>async def retrieve_all_photo_info(text: Union[str, None] = None):<br/>    if text is None:<br/>        data = await retrieve_all_photo_info_from_TigerGraph("")<br/>    else:<br/>        data = await retrieve_all_photo_info_from_TigerGraph(text)<br/>    if not data:<br/>        return { "code": 401, "message": "Failed to retrieve photo"}<br/>    else:<br/>        return { "code": 200, "data": data, "message": "Photo fetched" }</span></pre><p id="c144" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，搜索文本可能是空的(或者没有)，在这种情况下，我们将显示所有照片。</p><p id="c401" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你已经完成了这个项目的整个后端！下面是完整的代码。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5664" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二节:实现前端</strong></p><p id="7da6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在前端添加两个组件:搜索栏和显示部分。搜索栏是简单的类星体框架。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f250" class="jy jz hi ju b fi ka kb l kc kd">&lt;div&gt;<br/>  &lt;q-input<br/>    outlined<br/>    v-model="searchText"<br/>    label="Search"<br/>    debounce="500"<br/>    class="text-body1 text-weight-bolder"<br/>    @update:model-value="retrieveAllPhotos()"<br/>  &gt;<br/>    &lt;template v-slot:prepend&gt;<br/>      &lt;q-icon name="search" /&gt;<br/>    &lt;/template&gt;<br/>  &lt;/q-input&gt;<br/>&lt;/div&gt;</span></pre><p id="9774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它看起来像这样:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/c34612b565c224a5b92c70711d78b16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11JNcp38h-EzdlM_D9YZVg.png"/></div></div></figure><p id="98a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将输入存储在变量<code class="du kf kg kh ju b">searchText</code>中，并在每次输入改变时用函数<code class="du kf kg kh ju b">retrieveAllPhotos</code>(尚未实现)刷新显示部分。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="933c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于显示部分，我们将显示存储在<code class="du kf kg kh ju b">libraryPhotoURLs</code>数组中的所有照片，该数组是从照片文件生成的<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs" rel="noopener ugc nofollow" target="_blank">数据URL</a>的数组。函数<code class="du kf kg kh ju b">retrieveAllPhotos</code>刷新<code class="du kf kg kh ju b">libraryPhotoURLs</code>数组。由于函数<code class="du kf kg kh ju b">getSize()</code>随机返回<code class="du kf kg kh ju b">card-small</code>、<code class="du kf kg kh ju b">card-medium</code>和<code class="du kf kg kh ju b">card-large</code>中的一个类，所以照片的大小是不同的。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b94b" class="jy jz hi ju b fi ka kb l kc kd">&lt;div class="library-content"&gt;<br/>  &lt;div <br/>    v-for="idx in libraryPhotoURLs.length" <br/>    :key="idx" <br/>    :class="getSize()"<br/>  &gt;<br/>    &lt;div class="pin-modal"&gt;<br/>      &lt;div class="modal-head"&gt;<br/>        &lt;div class="save-card"&gt;Save&lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="pin-photo"&gt;<br/>      &lt;img<br/>        :src="libraryPhotoURLs[idx-1]" <br/>        style="opacity: 1; <br/>        max-width: 100%;" <br/>      /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="a236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用CSS网格布局和悬停效果来复制Pinterest的风格。下面给出了与这部分相关的CSS代码。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="dbd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数<code class="du kf kg kh ju b">retrieveAllPhotos</code>向后端发出请求，获取与所有要显示的照片相对应的对象id数组，将<code class="du kf kg kh ju b">libraryPhotoURLs</code>设置为一个新的相同长度的空数组，并为每张照片调用函数<code class="du kf kg kh ju b">retrievePhoto</code>。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="44f7" class="jy jz hi ju b fi ka kb l kc kd">retrieveAllPhotos(){<br/>  const api = axios.create({ baseURL: 'http://localhost:8000' });<br/>  api.put(`/retrieveAllPhotoInfo?text=${this.searchText}`, {})<br/>    .then((resp)=&gt;{<br/>      // an array of object IDs<br/>      const all_photo_info = resp.data.data;<br/>      this.libraryPhotoURLs = (new Array(all_photo_info.length)).fill('');<br/>      for(let i=0;i&lt;all_photo_info.length;i++) {<br/>        this.retrievePhoto(all_photo_info[i], i);<br/>      }<br/>    })<br/>    .catch((err)=&gt;{<br/>      console.log(err);<br/>    });<br/>}</span></pre><p id="b087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数<code class="du kf kg kh ju b">retrievePhoto</code>通过对象ID从后端请求base64编码的照片字节，将字节解码到缓冲区中，重建照片文件，生成数据URL，并将其存储在<code class="du kf kg kh ju b">libraryPhotoURLs</code>数组的指定索引处。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="742a" class="jy jz hi ju b fi ka kb l kc kd">retrievePhoto(id:string, idx:number){<br/>  const api = axios.create({ baseURL: 'http://localhost:8000' });<br/>  api.put(`/retrievePhoto/${id}`, {})<br/>    .then((resp)=&gt;{<br/>      const buff = Buffer.from(resp.data, 'base64');<br/>      const blob = new Blob([buff], { type: 'image/png' });<br/>      const photo = new File([blob], 'test', { type: 'image/png' });<br/>      const reader = new FileReader();<br/>      reader.onload = (e) =&gt; {<br/>        this.libraryPhotoURLs[idx] = e.target?.result as string;<br/>      };<br/>      reader.readAsDataURL(photo as File);<br/>    })<br/>    .catch((err)=&gt;{<br/>      console.log(err)<br/>    });<br/>}</span></pre><p id="2c72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前端的所有改动都是在<code class="du kf kg kh ju b">frontend/src/pages/IndexPage.vue</code>中做的，我们把这个文件<a class="ae jo" href="https://github.com/JimChen2002/photo-library-part3/blob/master/frontend/src/pages/IndexPage.vue" rel="noopener ugc nofollow" target="_blank">的全部代码放在这里</a>。</p><p id="dbb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三部分:总结和资源</strong></p><p id="ddfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝贺你完成这个博客系列！你可以运行应用程序，找到一些衣服的照片，上传到这个应用程序。提醒一下，您可以通过在终端中键入以下内容来运行该应用程序:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f69f" class="jy jz hi ju b fi ka kb l kc kd"># Start the frontend<br/>$ cd photo_library/frontend<br/>$ quasar dev</span><span id="a6d6" class="jy jz hi ju b fi ke kb l kc kd"># Start the backend<br/>$ cd photo_library/backend<br/>$ source venv/bin/activate<br/>$ python3 main.py</span><span id="af40" class="jy jz hi ju b fi ke kb l kc kd"># Remember to start the TigerGraph solution and the MongoDB service</span></pre><p id="677d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你得到和这张图一样的结果:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/f16dd55d327d434721cae8691114be28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ACKxT22YyjEN1xbaZx32Q.png"/></div></div></figure><p id="7a0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个博客系列中，你已经学会了如何做这些事情:</p><ul class=""><li id="a341" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">用Pinterest的风格构建一个前端应用</li><li id="6621" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">使用图像分类模型构建后端服务器</li><li id="d076" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">设置TigerGraph和MongoDB并与之交互</li></ul><p id="7d4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些技能，你可以更容易地开始其他全栈或机器学习项目！</p><p id="e1b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个项目的所有代码上传<a class="ae jo" href="https://github.com/JimChen2002/photo-library-part3" rel="noopener ugc nofollow" target="_blank">在这里</a>与指令运行它。如果你有任何问题，欢迎加入<a class="ae jo" href="https://discord.com/invite/tigergraph" rel="noopener ugc nofollow" target="_blank"> TigerGraph Discord </a>和<a class="ae jo" href="https://dev.tigergraph.com/forum/" rel="noopener ugc nofollow" target="_blank">开发者论坛</a>！</p></div></div>    
</body>
</html>
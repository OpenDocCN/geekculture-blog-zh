<html>
<head>
<title>Custom Secured Annotation Using Spring Expression Language &amp; Spring AOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring表达式语言和Spring AOP定制安全注释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/custom-secured-annotation-using-spring-expression-language-spring-aop-e086e5b9499d?source=collection_archive---------12-----------------------#2021-05-23">https://medium.com/geekculture/custom-secured-annotation-using-spring-expression-language-spring-aop-e086e5b9499d?source=collection_archive---------12-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6ccf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">简介</strong></h1><p id="2bde" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们大多数人都知道Spring Security及其用法。它支持使用<em class="kb"> @Secured </em>注释的方法级授权。它允许我们指定可以访问特定方法的角色列表。因此，如果用户至少拥有一个给定的角色，他将只能访问一个方法。这是一个常见的用例，已经在Spring安全模块中默认提供了。</p><p id="c56f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们有一个稍微不同的用例要实现，它涉及到方法级的授权，但是还有一个条件。用例的完整解释如下。</p><h1 id="3a4c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><span class="l kh ki kj bm kk kl km kn ko di">P</span>T6】问题陈述</h1><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es kp"><img src="../Images/64f225a4ec4d056fc370fb98204aca30.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*2evxkjwoSEtLtbNaHY54hA.png"/></div></figure><p id="abb3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">有多个项目和用户。每个用户对不同的项目有不同的权限。考虑一个对项目执行CRUD操作的服务。例如，用户1对项目1具有读权限，对项目2具有读/写权限，而用户2对这两个项目都具有读/写权限。因此，如果有一个方法涉及到对Project1的任何更新操作，它就不应该被User1访问。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es kx"><img src="../Images/b2f7dde1880ad32771f85d219db7bf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*3Ht96SD-JMddOVBmRbLotg.png"/></div></figure><p id="c1f5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">简单地说，当用户1试图为项目2使用该方法时，他被授权访问相同的方法，但是当他为项目1访问该方法时，他是未授权的。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es ky"><img src="../Images/e1f3c71328adc462d0f3745608dd8da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*k_5juJ5bRMTziNcSy8Hecg.png"/></div></figure><h1 id="47a6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决方案</h1><p id="f3e6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们使用了<a class="ae kz" href="https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/html/aop.html" rel="noopener ugc nofollow" target="_blank"> Spring AOP </a>和<a class="ae kz" href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html" rel="noopener ugc nofollow" target="_blank"> Spring表达式语言(SpEL) </a>来实现用例。Spring AOP让我们在实际方法执行之前/之后执行一些逻辑，等等…我不会深入Spring AOP的细节。现在知道它可以使用不同的注释拦截应用程序中的方法就足够了。这与spring中的@Transactional注释的工作方式相同。</p><p id="2c97" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">为了解决这个问题，我们还创建了一个定制的注释，它将像@Secured接受角色一样接受角色。在访问实际的方法之前，我们通过Spring AOP拦截它，并验证用户是否被授权访问该项目(考虑projectId或任何唯一的项目标识符作为该方法的参数)。使用AOP，我们可以获得执行时出现的所有参数，如它们的名称、值等。</p><p id="35fd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">SpEL开始解析参数及其名称以获得动态projectId。我觉得理论就够了。让我们做一些实际的代码。</p><h1 id="52a0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">一、实施</h1><p id="1929" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们创建一个自定义注释<strong class="jf hj"> @ProjectSecured </strong>。它接受一个角色数组和保存projectIdField的参数的名称。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="58c2" class="lf ig hi lb b fi lg lh l li lj">@Target(ElementType.<em class="kb">METHOD</em>)<br/>@Retention(RetentionPolicy.<em class="kb">RUNTIME</em>)<br/>public @interface ProjectSecured {<br/><br/>    Role[] roles() default {};<br/><br/>    String projectIdField() default "";<br/><br/>}</span></pre><p id="6165" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在可以对ProjectService的方法进行如下注释。这里要检查的重要内容是注释的<strong class="jf hj"> projectIdField </strong>参数。这取决于方法中传递的实际参数及其名称。projectIdField是一个可解析的字符串，它将被Spring表达式语言解析以获得projectId的动态值。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="0935" class="lf ig hi lb b fi lg lh l li lj">@ProjectSecured(roles = {Role.<em class="kb">READ</em>}, projectIdField = "#project.projectId")<br/>public Project readProject(Project project) {<br/>    // some read operation<br/>}<br/><br/>@ProjectSecured(roles = {Role.<em class="kb">READ</em>}, projectIdField = "#id")<br/>public Project readProject(String id) {<br/>    // some read operation<br/>}</span><span id="8a41" class="lf ig hi lb b fi lk lh l li lj"><strong class="lb hj">// pay attention to projectIdField</strong><br/>@ProjectSecured(roles = {Role.<em class="kb">WRITE</em>}, projectIdField = "#project.projectId")<br/>public Project editProject(Project project) {<br/>   // some edit operation<br/>}</span><span id="8060" class="lf ig hi lb b fi lk lh l li lj"><strong class="lb hj">// pay attention to projectIdField</strong><br/>@ProjectSecured(roles = {Role.<em class="kb">WRITE</em>}, projectIdField = "#id")<br/>public Project editProject(String id) {<br/>   // some edit operation<br/>}</span></pre><p id="9607" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">下一个要考虑的重要组件是截获方法并验证用户是否被授权执行操作的方面。正如我们在下面看到的，aspect截获所有用ProjectSecured注释的方法，获取方法签名、参数，并将其传递给SpEL Parser，以便在运行时获取值。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="8dd1" class="lf ig hi lb b fi lg lh l li lj">@Aspect<br/>@Component<br/>public class SecureProjectAspect {<br/><br/>    @Autowired<br/>    UserService userService;<br/><br/>    @Around("methodsAnnotatedWithProjectSecuredAnnotation()")<br/>    public Object processMethodsAnnotatedWithProjectSecuredAnnotation(ProceedingJoinPoint joinPoint) throws Throwable {<br/>        MethodSignature signature = (MethodSignature) joinPoint.getSignature();<br/>        Method method = signature.getMethod();<br/>        ProjectSecured projectSecuredAnnotation = method.getAnnotation(ProjectSecured.class);</span><span id="5416" class="lf ig hi lb b fi lk lh l li lj"><strong class="lb hj">// parse and fetch the projectId</strong><br/>       String projectId = (String) CustomSpringExpressionLanguageParser.<br/>                <em class="kb">getDynamicValue</em>(signature.getParameterNames(), joinPoint.getArgs(), projectSecuredAnnotation.projectIdField());<br/>        Role[] roles = projectSecuredAnnotation.roles();</span><span id="d033" class="lf ig hi lb b fi lk lh l li lj"><strong class="lb hj">// If user is authorized, then proceed else throw an exception<br/></strong>        boolean isUserAuthorized = userService.isUserAuthorized(projectId, Arrays.<em class="kb">asList</em>(roles));<br/>        if (isUserAuthorized) {<br/>            return joinPoint.proceed();<br/>        } else {<br/>            User currentUser = userService.getCurrentUser();<br/>            throw new Exception(currentUser.getUserName() + " is not allowed to perform this operation on project with id:" + projectId);<br/>        }<br/>    }</span><span id="fcba" class="lf ig hi lb b fi lk lh l li lj">    @Pointcut("@annotation(com.example.demo.conf.ProjectSecured)")<br/>    private void methodsAnnotatedWithProjectSecuredAnnotation() {<br/><br/>    }<br/>}</span></pre><p id="9fc5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最后但同样重要的是SpEL解析器，它解析projectIdField表达式并返回动态projectId。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="9ea9" class="lf ig hi lb b fi lg lh l li lj">public class CustomSpringExpressionLanguageParser {<br/>    public static Object getDynamicValue(String[] parameterNames,  <br/>                                   Object[] args, String key) {<br/>        ExpressionParser parser = new SpelExpressionParser();<br/>        StandardEvaluationContext context = new  <br/>            StandardEvaluationContext();<br/><br/>        for (int i = 0; i &lt; parameterNames.length; i++) {<br/>            context.setVariable(parameterNames[i], args[i]);<br/>        }<br/>        return parser.parseExpression(key).getValue(context,  <br/>             Object.class);<br/>    }<br/>}</span></pre><p id="1529" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">所有这些因素加在一起就会产生预期的结果。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="70f5" class="lf ig hi lb b fi lg lh l li lj">@SpringBootTest<br/>public class ProjectServiceAuthorizationTest {<br/><br/>    @Autowired<br/>    private ProjectService projectService;<br/><br/>    @Autowired<br/>    private UserService userService;<br/><br/>    @Test<br/>    public void testReadProject() {<br/><br/>        <strong class="lb hj">// given: current user is User1</strong><br/>        userService.setCurrentUser("1");<br/><br/>        <strong class="lb hj">// when: User1 tries to read Project1</strong><br/>        Project project = projectService.readProject("1");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("Project1", project.getName());<br/><br/>        <strong class="lb hj">// when: User1 tries to read Project2</strong><br/>        project = projectService.readProject("2");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("Project2", project.getName());<br/><br/>       <strong class="lb hj"> // given: current user is User2</strong><br/>        userService.setCurrentUser("2");<br/><br/>        <strong class="lb hj">// when: User2 tries to read Project1</strong><br/>        project = projectService.readProject("1");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("Project1", project.getName());<br/><br/>        <strong class="lb hj">// when: User2 tries to read Project2</strong><br/>        project = projectService.readProject("2");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("Project2", project.getName());<br/>    }<br/><br/><br/>    @Test<br/>    public void testEditProject() {<br/><br/>        <strong class="lb hj">// given: current user is User1</strong><br/>        userService.setCurrentUser("1");<br/><br/>        <strong class="lb hj">// when: User1 tries to edit Project1</strong><br/>        Executable exe = () -&gt; projectService.editProject("1");<br/>        <strong class="lb hj">// then: exception is thrown</strong><br/>        Throwable e = Assertions.<em class="kb">assertThrows</em>(Exception.class, exe);<br/>        e = ((UndeclaredThrowableException) e)                               <br/>            .getUndeclaredThrowable();<br/>        Assertions.<em class="kb">assertEquals</em>("User1 is not allowed to perform       <br/>        this operation on project with id:1", e.getMessage());<br/><br/>        <strong class="lb hj">// when: User1 tries to edit Project2</strong><br/>        Project project = projectService.editProject("2");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("New Project2", project.getName());<br/><br/><br/>        <strong class="lb hj">// given: current user is User2</strong><br/>        userService.setCurrentUser("2");<br/><br/>        <strong class="lb hj">// when: User2 tries to edit Project1</strong><br/>        project = proherejectService.editProject("1");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("New Project1", project.getName());<br/><br/>        <strong class="lb hj">// when: User2 tries to edit Project2</strong><br/>        project = projectService.editProject("2");<br/>        <strong class="lb hj">// then: operation is successful</strong><br/>        Assertions.<em class="kb">assertEquals</em>("New Project2", project.getName());<br/>    }<br/><br/><br/>    @Configuration<br/>    @ComponentScan(basePackages = "com.example.demo")<br/>    static class SpringConfig {<br/>    }<br/>}</span></pre><p id="05f4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个用例的完整代码可以在<a class="ae kz" href="https://github.com/Richa-b/custom-security-app-using-aop-and-spel" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这里的代码<a class="ae kz" href="https://github.com/Richa-b/custom-annotation-with-dynamic-values-using-aop" rel="noopener ugc nofollow" target="_blank">可能也与某些人有关。</a></p></div></div>    
</body>
</html>
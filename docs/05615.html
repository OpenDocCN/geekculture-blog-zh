<html>
<head>
<title>Sorting Algorithms 101: Quick Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法101:快速排序</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/sorting-algorithms-101-quick-sort-9550aca7922e?source=collection_archive---------29-----------------------#2021-07-26">https://medium.com/geekculture/sorting-algorithms-101-quick-sort-9550aca7922e?source=collection_archive---------29-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d30f551dbcd0a25339c055907d9bff21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LB-HKX_owFAnkAw8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@robinpierre?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robin Pierre</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fee1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经到达了我的五部分排序算法系列的最后一个主题！今天，我们终于讨论了快速排序——五种排序算法中最流行的一种。如果您还没有机会复习前四种排序算法，不要担心，我们可以从这里重新开始。你需要知道的就是递归的概念。</p><p id="833b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想快速回顾一下我们到目前为止所做的一切，下面有一个:</p><ol class=""><li id="1137" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa">冒泡排序</a>在其迭代中找到<em class="kc">最大的</em>未排序数，并将其移动到数组的末尾。它的时间复杂度为O(n2)。</li><li id="ce08" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/@freda.hon/sorting-algorithms-101-selection-sort-778c201e330a">选择排序</a>在其迭代中找到<em class="kc">最小的</em>未排序数，并将其移动到数组的开头。这也具有O(n2)的时间复杂度。</li><li id="c6b2" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/geekculture/sorting-algorithms-101-insertion-sort-ee585f6a62cf">插入排序</a>使用一个键，并将其与该键左侧的数字进行比较。如果键左边的数字小于键上的数字，则发生交换。同样，它的时间复杂度也是O(n2)。</li><li id="6f48" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/nerd-for-tech/sorting-algorithms-101-merge-sort-d28e98a4080">归并排序</a>取一个数组，把它分成两半，直到一个元素组成它自己的数组。然后，当每个元素合并回一个新的排序数组时，该算法对它们进行比较和排序。归并排序的时间复杂度为O(nlog(n))。</li><li id="9a49" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">额外收获:<a class="ae iu" rel="noopener" href="/codex/a-quick-guide-to-recursion-b84fdaf6986d">递归</a>是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。在递归中，<em class="kc">函数将调用自身，直到遇到一个基本情况</em>。</li></ol><p id="19c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这对你是一个很好的复习。如果你准备好了，让我们开始快速排序！</p><h1 id="34c2" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">快速排序:工作原理</h1><p id="c0d2" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">快速排序使用枢轴。枢纽通常是列表中的第一个或最后一个元素，但也可以是随机元素(由开发人员决定)。一旦指定了一个轴心，所有小于该轴心的元素将被排列到该轴心左侧的数组中。同时，所有大于轴心的元素将被放在右边的数组中。最后，等于枢轴的所有元素将被插入到中间数组中。</p><p id="8338" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与合并排序类似，快速排序也使用分治策略。现在，我们的列表被分成三个独立的列表(较小的、相等的和较大的)，然后算法将调用自身(递归)，并对较小的和较大的列表重复这个过程(因为相等的列表将位于中间并包含相同的数字，所以它不再需要排序)。只有当每个单个元素组成一个自己的数组时，才满足基本情况。此时，单个元素被排序并返回给调用它的人(前一步)，并合并回一个列表。</p><p id="b53f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过下面的例子来更好地了解这一点。我们将选择最后一个元素作为轴心:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3d14" class="lu kj hi lq b fi lv lw l lx ly">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 2, 7, 5 ]<br/>                                        ^<br/>                                      pivot</span></pre><p id="9f6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分配透视后，算法将从数组的开头开始比较。因为(4)小于(5)，所以(4)将被移到(5)左侧的较小列表中。相反，(7)大于(5)，将被移到(5)的右边。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b5a5" class="lu kj hi lq b fi lv lw l lx ly">                  4, 7, 1, 6, 10, 8, 3, 9, 2, 7, 5 <br/>                                                 ^<br/>                                               pivot</span><span id="9716" class="lu kj hi lq b fi lz lw l lx ly">                              4, 5, 7</span></pre><p id="95ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续讨论(1)。由于(1)小于(5)，它将被移到(5)左侧的较小列表中。</p><p id="6c0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们的列表应该是这样的:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d799" class="lu kj hi lq b fi lv lw l lx ly">                  4, 7, 1, 6, 10, 8, 3, 9, 2, 7, 5 <br/>                                                 ^<br/>                                               pivot<br/>                            4, 1, 5, 7 </span></pre><p id="bce2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们快进一点。当我们遍历整个数组时，我们只剩下:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="1239" class="lu kj hi lq b fi lv lw l lx ly">                  4, 1, 3, 2, 5, 7, 6, 10, 8, 9, 7</span></pre><p id="e5bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/486c265ed384303bb3c1b2ac2c76ffd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCYOEkc4r3qjpPCcKS2Jmw.png"/></div></div></figure><p id="db9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，这些数字被附加到每个数组的末尾。所以在迭代结束时，我们的列表还没有完全排序。这就是为什么算法会调用自身来重复每个列表上的过程。</p><p id="a9a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简单起见，让我们忽略相等的和较大的列表，先只看较小的列表。枢纽被分配给列表的最后一个元素，也就是(2)，我们重新开始比较。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/098e674eca5c3242f988cc3c3c22d416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwsocEa37hbegUPXLvZy2A.png"/></div></div></figure><p id="4bb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于(4)大于(2)，它将被放在一个更大的列表中，在(2)的右边。(1)将出现在(2)左侧的较小列表中，而(3)将被追加到(4)后面的较大列表中。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/82cf03add349e32dafa2ebb64928d36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsAuDp_9Ey-nt1_9YhQfAQ.png"/></div></div></figure><p id="5d9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于[1]和[2]是单个元素，不能拆分，因此到达基本情况并返回到上面的步骤。同时，[4，3]，以(3)为支点再拆分一次，由于(4)大于(3)，所以放在一个更大的列表中，在(3)的右边。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/04631d2139b538da38c9e6546bcad807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHv2cf3WGSnQvIarCCB1tg.png"/></div></div></figure><p id="f983" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3]和[4]现在到达基本情况，并返回到调用它的步骤，[4，3]，然后返回到[4，1，3，2]。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/f7cdd4283b18d6f4526da94ffd0db6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIZ17VTVTjCorbmY7tvXIA.png"/></div></div></figure><p id="3083" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，这些数字现在已经按顺序排列了。</p><p id="9849" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将此应用于原始的较大列表，我们得到以下结果:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/2aa9660cc0cf7e49f0ac995435d767fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sWz-SgSh91yLRvywl6Grg.png"/></div></div></figure><p id="558c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，这个递归调用不需要在相等列表上调用，因为它已经被排序了。</p><p id="3aba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它们合并在一起，您会得到一个完全排序的列表:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="a441" class="lu kj hi lq b fi lv lw l lx ly">[ 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10 ]</span></pre><h1 id="e9ea" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">算法</h1><p id="9a45" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">好了，现在你已经理解了快速排序是如何工作的，让我们来看看实现它的算法。下面的代码将用python编写，但是您应该能够将相同的逻辑应用于任何其他语言。</p><p id="476d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我们需要在算法中完成的任务列表:</p><ol class=""><li id="ada0" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">指定一个轴心</li><li id="5e0b" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">创建更小、相等和更大的子阵列</li><li id="23ce" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">遍历数组</li><li id="f901" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">将每个元素附加到上面适当的子数组中</li><li id="b46d" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">将上述所有四个步骤应用于每个后续子阵列(在分而治之的过程中),并建立一个基础案例</li></ol><p id="0253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表中的前两个似乎很容易首先避开:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="6749" class="lu kj hi lq b fi lv lw l lx ly">def quick_sort(arr):<br/>    pivot = arr[-1]<br/>    smaller, equal, larger = [], [], []</span></pre><p id="99e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于我的pivot，我使用[-1]的索引来引用数组的最后一个元素。</p><p id="30ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了划掉列表中的第三项，我们知道对应于<em class="kc">——循环非常适合遍历数组。所以，让我们包括这个:</em></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e200" class="lu kj hi lq b fi lv lw l lx ly">def quick_sort(arr):<br/>    pivot = arr[-1]<br/>    smaller, equal, larger = [], [], []<br/>    <br/>    for num in arr:</span></pre><p id="c76c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当我们遍历数组时，我们希望发生什么呢？将每个元素附加到适当的子数组(更小、相等或更大)。因此，让我们为比较建立一个<em class="kc">if</em>-语句，并在必要的地方添加元素:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="a1ce" class="lu kj hi lq b fi lv lw l lx ly">def quick_sort(arr):<br/>    pivot = arr[-1]<br/>    smaller, equal, larger = [], [], []<br/>        <br/>    for num in arr:<br/>        if num &lt; pivot:<br/>            smaller.append(num)<br/>        elif num == pivot:<br/>            equal.append(num)<br/>        else: <br/>            larger.append(num)<br/>    return smaller + equal + larger</span></pre><p id="8530" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了。到目前为止看起来很好，我们就快到了。让我们完成清单上的最后一项。</p><p id="c471" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们上面所做的只是将我们的原始数组分成更小、相等和更大的子数组。如果你没记错的话，我们需要这个过程来继续把数组分解成单元素数组。我们可以递归地这样做，并将每个元素返回到调用它的步骤。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3c63" class="lu kj hi lq b fi lv lw l lx ly">def quick_sort(arr):<br/>    pivot = arr[-1]<br/>    smaller, equal, larger = [], [], []<br/>    <br/>    for num in arr:<br/>        if num &lt; pivot:<br/>            smaller.append(num)<br/>        elif num == pivot:<br/>            equal.append(num)<br/>        else: <br/>            larger.append(num)<br/>    return quick_sort(smaller) + equal + quick_sort(larger)</span></pre><p id="f669" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们不要忘记基本情况，否则我们的算法将永远无法逃脱递归调用:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3577" class="lu kj hi lq b fi lv lw l lx ly">def quick_sort(arr):<br/>    if len(arr) &lt; 2:<br/>        return arr<br/>    else:<br/>        pivot = arr[-1]<br/>        smaller, equal, larger = [], [], []<br/>        for num in arr:<br/>            if num &lt; pivot:<br/>                smaller.append(num)<br/>            elif num == pivot:<br/>                equal.append(num)<br/>            else: <br/>                larger.append(num)<br/>        return quick_sort(smaller) + equal + quick_sort(larger)</span><span id="576e" class="lu kj hi lq b fi lz lw l lx ly">array = [ 4, 7, 1, 6, 10, 8, 3, 9, 2, 7, 5 ]<br/>print(quick_sort(array))</span></pre><p id="ae19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！那还不算太糟，是吗？</p><h1 id="7d9e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">时间复杂度</h1><p id="dcaf" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">对于最佳和一般情况，快速排序的时间复杂度为<strong class="ix hj"> O(nlog(n)) </strong>。最坏情况下，时间复杂度为O(n2)。</p><p id="5e1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最坏的情况是什么？对于我们上面的策略，有三种最坏的情况，导致时间复杂度为O(n2):</p><ol class=""><li id="a8e1" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">数组已经排序，最后一个元素被选作轴心</li><li id="3740" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">对数组进行反向排序，选择第一个元素作为枢纽</li><li id="2a6b" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">数组中的所有元素都是相同的</li></ol><p id="8481" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，(n)代表数组中元素的数量。在上述所有三种情况下，算法都必须迭代<em class="kc">每个</em>元素<em class="kc"> (n) </em>次。这使得(n) x (n)或O(n2)。</p><p id="5474" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，对于最佳情况或一般情况，我们如何得到O(nlog(n))呢？</p><p id="87e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个分离级或步骤代表(n)个操作，因此在每个步骤<em class="kc">具有O(n)的时间复杂度。</em>由于我们在每一步将我们的列表一分为二以产生(n)个列表，这等同于log(n) <em class="kc">总步骤</em>。</p><p id="6559" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">把<em class="kc">的每一步</em>和<em class="kc">的总步数</em>放在一起，我们得到(n×log(n))，一个时间复杂度为<strong class="ix hj"> O(nlog(n)) </strong>。</p><p id="93b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还记得，合并排序的时间复杂度为O(nlog(n))，包括最坏的情况。那么，为什么快速排序实际上具有最好的性能呢？简单地说，最坏的情况对于快速排序来说是极其罕见的，而且肯定有办法防止最坏的情况发生。此外，与合并排序相比，快速排序的运行时间通常更快。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="a766" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，那就结束了。希望这个由五部分组成的系列是对排序算法的一个很好的介绍和基础。这是一次相对较浅的潜水，但足以让你开始。</p><p id="253e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你对更流行的技术面试话题感兴趣，我将很快开始另一个关于数据结构的系列。敬请期待，快乐编码！</p></div></div>    
</body>
</html>
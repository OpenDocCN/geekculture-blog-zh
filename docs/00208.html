<html>
<head>
<title>Java Exception Hierarchy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java异常层次结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/java-exception-hierarchy-f6aef08ab9b?source=collection_archive---------0-----------------------#2020-11-01">https://medium.com/geekculture/java-exception-hierarchy-f6aef08ab9b?source=collection_archive---------0-----------------------#2020-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="53ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用异常</p><h1 id="10dc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">介绍</h1><p id="6c51" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">关于Java中的异常，你首先要了解的事情之一是，它们有两种类型——<em class="kg">检查异常</em>和<em class="kg">未检查异常</em>。</p><p id="8dff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何“异常”最终都是从<code class="du kh ki kj kk b">java.lang.Throwable</code>继承而来。它有两个直接后代— <code class="du kh ki kj kk b">java.lang.Error</code>和<code class="du kh ki kj kk b">java.lang.Exception</code>。<code class="du kh ki kj kk b">java.lang.RuntimeException</code>是<code class="du kh ki kj kk b">java.lang.Exception</code>的直系后裔。</p><p id="127f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kg">未检查的异常</em>是继承自<code class="du kh ki kj kk b">java.lang.RuntimeException</code>或<code class="du kh ki kj kk b">java.lang.Error.</code>的异常(可能不是立即继承)</p><p id="a381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kg">被检查的异常</em>是从<code class="du kh ki kj kk b">java.lang.Throwable</code>继承而来(可能不是立即继承)<code class="du kh ki kj kk b">java.lang.RuntimeException </code>和<strong class="ih hj">而不是</strong>以及<strong class="ih hj">而不是<code class="du kh ki kj kk b">java.lang.Error</code>继承而来的异常。<em class="kg">非正式的</em>，这些是继承自<code class="du kh ki kj kk b">java.lang.Exception</code>的异常，而不是继承自<code class="du kh ki kj kk b">java.lang.RuntimeException</code>。</strong></p><p id="6f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查异常在新设计的API中没有使用，甚至在JDK内部也没有使用。</p><blockquote class="kl"><p id="08c4" class="km kn hi bd ko kp kq kr ks kt ku jc dx translated">这被认为是Java语言最大的设计错误。</p></blockquote><p id="8351" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">了解你在哪一层有例外是至关重要的。待遇会不一样。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="8a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JEE世界中，有两种类型的异常— <em class="kg">系统异常</em>和应用程序异常。<em class="kg">系统异常</em>通常是致命的，它们与程序运行的环境有关。例如，DB关闭或发生了<code class="du kh ki kj kk b">OutOfMemoryError</code>。基本上，这意味着出错的不是应用程序代码，而是超出了应用程序的范围。<em class="kg">应用程序异常</em>是由应用程序产生的异常。您的应用程序完全负责处理它。我将在下面简要地谈一谈它们。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="c0e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在web服务世界(尤其是微服务世界)中，我们应该讨论将要返回给调用者的异常以及发生在某个内部层的异常。</p><p id="0a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于传播到调用者的Java异常，一般来说，它应该被转换成符合您用来与调用者通信的协议。例如，如果您使用Spring Boot编写REST服务，您应该定义<code class="du kh ki kj kk b">@ExceptionHandler</code>——<a class="ae lh" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler" rel="noopener ugc nofollow" target="_blank">经典方式</a>或<a class="ae lh" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-exceptions" rel="noopener ugc nofollow" target="_blank">反应流方式</a>。您应该将您的异常转换成一些结构化数据(通常是JavaBean ),这些数据将对异常中的所有必要信息进行编码。框架将把这种结构化数据转换成适当的数据格式(例如JSON或Protobuf ),然后发送给调用者。此外，如有必要，应该使用适当的HTTP响应状态。</p><p id="a829" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的异常大致可以分为以下几类:<em class="kg">非法输入</em>、<em class="kg">违反了一些基本的业务规则</em>、<em class="kg">系统级问题</em>。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="682b" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">输入验证</h1><p id="a7b2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">不管是另一个web服务调用您还是实际用户填写表单，您都会被调用，您的web服务应该做的第一件事就是验证输入。</p><p id="4fd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有多个参数，最好的策略是检查所有的参数，并返回封装所有错误参数的异常。</p><p id="1418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可以在发现第一个错误参数时停止输入验证。</p><p id="088d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，前一种策略更好，但有时您的输入中有复杂的关系，如果基本上出了问题，您不想继续进行输入验证。</p><p id="41ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JEE世界中，这是<em class="kg">应用例外</em>。</p><p id="7c10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是应该<em class="kg">勾选</em>还是<em class="kg">未勾选</em>异常？对于第一层来说，其实并不重要，因为反正会在<code class="du kh ki kj kk b">@ExceptionHandler</code>转换。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="a956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您的web服务调用了另一个类中的某个公共方法。可能是服务层，POJO或者某个实用类。显然，这样的类也应该验证输入。<em class="kg">前置条件</em>的这部分检查。JDK内置了一些简单验证的函数，比如<a class="ae lh" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#requireNonNull(T)" rel="noopener ugc nofollow" target="_blank">objects . require nonnull()</a>或者<a class="ae lh" href="https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/Objects.html#checkFromToIndex(int,int,int)" rel="noopener ugc nofollow" target="_blank">objects . checkfromtoindex()</a>。</p><p id="3f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，让我们考虑参数不为空的验证。<em class="kg">在这种情况下</em>你应该抛出什么异常？我的观点是，你应该通过这些检查来“保护”你的代码。</p><p id="2f37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种选择是不检查并期望您的代码在任意点失败。我在几个项目中见过这种方法。理由如下:<em class="kg">何苦呢——我可以节省不输入这段代码的时间</em>。无论如何，这最终会以<code class="du kh ki kj kk b">NullPointerException</code>失败。主要的缺点是——你的“另一个类”可能会调用另一个类，并且调用链可能是嵌套很深的。你会在某个第三方库中看到这个<code class="du kh ki kj kk b">NullPointerException</code>,这需要你花时间去调查根本原因。在更复杂的场景中，如果<em class="kg">的前提条件</em>更复杂，您甚至可能会返回错误的答案。<strong class="ih hj">最佳实践是尽快验证前提条件。缺点——你花时间进行验证，而验证很可能永远不会失败(你“浪费了你的时间”)。</strong></p><p id="3370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是JEE世界的<em class="kg">系统异常</em>。是“意外的例外”。在许多情况下，它会指出是对API的不正确使用还是代码中的错误。如果是bug，显然与应用程序无关，您应该尽快了解以便修复它。<strong class="ih hj">如果是API </strong>的不正确使用，这意味着问题超出了你的模块的责任，这是“环境”问题，即使“环境”只是你的应用程序的另一部分。此类异常应明确<strong class="ih hj"> <em class="kg">未选中一个</em> </strong> <em class="kg">，</em>因为是“意外异常”。</p><p id="8974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，第一层的输入验证是<em class="kg">应用异常</em>(既可以是<em class="kg">选中的</em>也可以是<em class="kg">未选中的</em>异常，反正是转换过来的)，其他层是<em class="kg">系统异常</em>(和<em class="kg">未选中的</em>一)。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="117a" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated"><em class="ln">违反了一些基本的商业规则</em></h1><p id="1e23" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">因此，我们已经成功地通过了<em class="kg">前提条件</em>检查，包括<em class="kg">输入验证</em>，并且知道我们正在某个内层制作某个业务逻辑。突然，我们发现一些基本的商业规则被违反了。例如，客户在数据库中不存在。这种情况下我们该怎么办？</p><p id="ee4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JEE世界这个<em class="kg">应用例外。在JEE，这是你合同的一部分。你的客户应该知道如何应对违反商业规则的情况，而违反商业规则的主要可能性就在你的沟通合同中。</em></p><p id="4e6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Spring世界中这将是<strong class="ih hj"> <em class="kg">未选中</em> </strong>的异常(Spring无论如何不要使用<em class="kg">已选中</em>的异常)，首先。通常，它不会在您的服务层生成，而是在DAL层生成。</p><p id="07c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="fb5c" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">我假设<em class="kg"> DAL层没有放在单独的微服务</em>里。如果你为DAL层使用单独的微服务，你可以找到另一个例子，这并不重要。</li><li id="d90a" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">如果您违反了业务规则，这显然应该在您的方法的契约中进行编码。但是Spring不使用<em class="kg">为此检查</em>异常。</li></ol><p id="710e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，您应该在服务层(或第一层)捕捉这样的异常，并将其转换为对您的客户端有意义的内容。</p><p id="b1f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，我见过这样的项目，向最终用户显示的消息是在发生<em class="kg">应用程序异常</em>的地方生成的，并放在异常对象本身或某个“全局消息容器”中。</p><p id="290e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们调用其他方法，却得到了<em class="kg">应用程序异常，该怎么办？</em>如果这是<em class="kg">未检查的</em>异常，它很可能会向上传播到堆栈。当然，即使<em class="kg">未选中</em>，也可以捕捉到这样的<em class="kg">应用异常</em>。我在生产中遇到这样的异常后，已经用实践添加了这样的捕获；将catch子句放在第一位要好得多——只需阅读javadoc(或者源代码，如果javadoc缺失或不完整的话)。</p><p id="12e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，你已经发现了<em class="kg">应用程序异常，</em>你该怎么办？嗯，因为是<em class="kg">应用异常</em>你应该知道该怎么做。例如，您可能有这样的业务规则，当您在数据库中寻找某个客户，但没有找到时，您应该创建它，也许用某个标志，所以您搜索客户，得到的<em class="kg">应用程序异常</em>表明没有找到，所以您用搜索数据(也许用某个标志)创建新客户，将他保存到数据库并继续您的业务流程。这个<em class="kg">可能</em>完全没问题。</p><p id="0182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，您会将<em class="kg">应用程序异常</em>返回给调用者，可能会打包到其他异常中。</p><p id="44a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个选项是<strong class="ih hj">将这个异常重新打包成另一个</strong>。您可以捕获一些异常，分析它，然后再抛出另一个异常。<br/>例如，请参见<a class="ae lh" href="https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLStateSQLExceptionTranslator.java" rel="noopener ugc nofollow" target="_blank">sqlstatesqlexception translator</a>和<a class="ae lh" href="https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java" rel="noopener ugc nofollow" target="_blank">sqlerrorcodesqlexception translator</a>。</p><p id="9287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="f5e5" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">这些是从<code class="du kh ki kj kk b">java.sql.SqlException</code>到<a class="ae lh" href="https://github.com/spring-projects/spring-framework/blob/master/spring-tx/src/main/java/org/springframework/dao/DataAccessException.java" rel="noopener ugc nofollow" target="_blank"> DataAccessException </a>的翻译器(详见javadoc)。</li><li id="eeee" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">这个翻译机制是<code class="du kh ki kj kk b">Spring</code>框架的一部分。这些都是<em class="kg">应用</em>从<em class="kg"> </em> <code class="du kh ki kj kk b">Spring</code>的角度来看。</li></ol><p id="68c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，这不是一个有代表性的例子。通常，您将只分析被捕获异常的类型和消息，并抛出另一个具有不同消息和类型的异常。通常，您只需将这个捕获的异常包装到另一个异常中，并将捕获的异常作为原因传递。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="4298" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">系统异常</h1><p id="0074" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">系统异常通常是致命的，它们与程序运行的环境有关。例如，DB关闭或发生了<code class="du kh ki kj kk b">OutOfMemoryError </code>。基本上，这意味着出错的不是应用程序代码，而是超出了应用程序的范围。</p><p id="2670" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常它们是由JVM自己生成的，像<code class="du kh ki kj kk b">OutOfMemoryError</code>或<code class="du kh ki kj kk b">IllegalAccessException </code>(你知道还有<code class="du kh ki kj kk b">IllegalAccessError</code>吗？:-))或一些第三方API，如DB驱动程序。</p><p id="46b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有<code class="du kh ki kj kk b">Error</code>，你通常无事可做，你只想让JVM崩溃(这就是为什么你的<code class="du kh ki kj kk b">catch(Throwable)</code>使用应该非常有限)。因此，通常情况下，这样的<code class="du kh ki kj kk b">Error</code>会将它向上传播到栈中的<code class="du kh ki kj kk b">main()</code>函数，甚至更远。</p><p id="bd2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<code class="du kh ki kj kk b">Error</code>之外，通常<em class="kg">系统异常</em>会被<strong class="ih hj"> <em class="kg">解除</em> </strong>之一。然而，存在一些API将一些<em class="kg">系统异常</em>定义为<em class="kg">检查的</em>异常。一般来说，这是此类API的糟糕设计决策。在这种情况下，你应该如何对待他们？</p><ol class=""><li id="63e9" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">让它向上传播到堆栈，最终使JVM崩溃，就像我们对<code class="du kh ki kj kk b">Error</code> s所做的那样。也许，在向上传播的过程中，您需要将它包装在某个<code class="du kh ki kj kk b">RuntimeException </code>中(或者使用一些肮脏的技巧来填满编译器——这是不推荐的)。</li><li id="af1e" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">让将它传播到第一级，记录它，并向调用者返回一些一般的错误消息。对于所谓的“意外例外”(见上文)，这通常也是最佳策略。</li><li id="ceb2" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">将它翻译成对您的应用程序更方便的异常(见上面的例子)。</li><li id="bbf5" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">忽略异常，等待超时时间，然后重试或制定其他恢复策略。<br/>如果您正在使用一些低级API，或者您正在调用另一个web服务，并且您有一些与网络相关的问题将在短期内解决(一些节点暂时断开连接，或者一些更改已经完成，并且它们正在传播网络；在所有内容都是最新的之后，它就可以工作了——例如，DNS名称更改或SSL证书更新。</li></ol><p id="9d0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着如果你不得不做这样的事情，你就只能使用低级别的API。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="77b7" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">带有链式异常的代码示例</h1><p id="8339" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>所有示例在JDK 8中都能正常工作。在JDK 9和更高版本中，这段代码在类路径中运行时是有效的。详见我关于<a class="ae lh" rel="noopener" href="/@alex_ber/java-platform-module-system-953cc88658fb"> Java平台模块系统</a>的文章。</p><p id="880a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想给你提供一些明确的例子，演示异常<em class="kg">链接</em>(当我们将异常包装到另一个异常时，但是我们使用原始异常作为原因)。</p><p id="5f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>使用<em class="kg">链式异常</em>是很久以前的标准做法。它是在JDK 1.4版本中添加的。其中一个动机是<code class="du kh ki kj kk b"> java.sql.SQLException</code>和<code class="du kh ki kj kk b">java.rmi.RemoteException</code>以及支持这个链接工具的类似类，但不是以同样的方式。所以，这个机制是统一的，任何<code class="du kh ki kj kk b">Throwable</code>都可以使用。</p><p id="e162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例1。</strong></p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="581e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" rel="noopener" href="/@alex_ber/explaining-invokedynamic-number-multiplication-almost-complete-example-part-iv-50b211fd5702">https://medium . com/@ Alex _ ber/explaining-invokedynamic-number-multiply-almost-complete-example-part-iv-50b 211 FD 5702</a></p><p id="4cdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在调用一些方法(它是在JDK 1.8，也就是JDK 8.0中添加的)，如果结果溢出了一个<code class="du kh ki kj kk b">int</code>，它会抛出<em class="kg">未检查的</em> <code class="du kh ki kj kk b">ArithmeticException</code>。作为这个方法的调用者，我们知道我们可以得到<code class="du kh ki kj kk b">ArithmeticException</code>，如果这将发生，我们将使用一些替代策略来完成计算。它慢得多，占用更多内存，在大多数情况下，第一次尝试会成功，但它不会溢出。更多详情请见上面的链接。</p><p id="1456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例2: </strong></p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" rel="noopener" href="/@alex_ber/explaining-invokedynamic-number-multiplication-almost-complete-example-part-iv-50b211fd5702">https://medium . com/@ Alex _ ber/explaining-invokedynamic-number-multiply-almost-complete-example-part-iv-50b 211 FD 5702</a></p><p id="cc85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们使用<code class="du kh ki kj kk b">MethodHandles</code> API来抛出静态初始化块中的<strong class="ih hj">检查过的</strong>异常。<strong class="ih hj">已检查的</strong>异常无法从静态块中传播出去(实际上是编译错误)，所以我们必须将它们包装在一些<strong class="ih hj">未检查的</strong>异常中。注意，我们将<code class="du kh ki kj kk b">MethodHandles</code> API作为原因来传递，以提高我们稍后理解最初是什么导致了<code class="du kh ki kj kk b">InternalError</code>被抛出的能力。</p><p id="d4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例3: </strong></p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><blockquote class="mj mk ml"><p id="be3c" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">...</em> <code class="du kh ki kj kk b"><em class="hi"><br/>createMethodHandle</em></code> <em class="hi">大致相当于:</em></p></blockquote><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" rel="noopener" href="/@alex_ber/explaining-invokedynamic-toy-example-part-ii-674314cfb5a8">https://medium.com/swlh/java-assertion-3b3c9611e1dc</a></p><p id="0f6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想重写原来的<code class="du kh ki kj kk b"><em class="kg">createMethodHandle</em></code> <strong class="ih hj">保留它的合同。</strong>例外条款是合同的组成部分。具体来说，我不想在例外条款中增加新的例外。所以，我把这个新的异常包装到一些现有的异常中。这也是有意义的，我可以说，如果我得到了<code class="du kh ki kj kk b">MethodType,</code>中的<code class="du kh ki kj kk b">NoSuchFieldException</code>到<code class="du kh ki kj kk b">java.lang.reflect.Field</code>，这是<code class="du kh ki kj kk b">IllegalAccessException</code>，如果我得到了<code class="du kh ki kj kk b">SecurityException </code>，那么它也是<code class="du kh ki kj kk b">IllegalAccessException</code>。这是异常<em class="kg">翻译</em>的例子(上面有一个到fancier的链接)。</p><p id="36b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我坚持将<code class="du kh ki kj kk b">SecurityException</code>或<code class="du kh ki kj kk b">NoSuchFieldException </code>作为原因传递给新生成的<code class="du kh ki kj kk b">IllegalAccessException</code>。由于历史原因，它没有将<em class="kg">原因</em>作为其参数之一的重载构造函数，所以我使用了JDK 1.4中专门为这种情况设计的<code class="du kh ki kj kk b">initCause()</code>构造。当然，我可以选择更方便的<strong class="ih hj">未选中的</strong>异常，但要比我已经改变的方法的行为更方便(它将“不太等价”)。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="3b6c" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">更大的</h1><blockquote class="kl"><p id="b22f" class="km kn hi bd ko kp kq kr ks kt ku jc dx translated">但这远不是故事的全部。应用程序代码本身的系统异常怎么办？</p></blockquote><p id="2712" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">当你写应用程序的时候，你应该什么时候抛出<em class="kg">系统异常</em>？</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="a95a" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">内部不变量</h1><p id="733c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">许多程序员使用注释来表明他们对程序行为的假设。例如:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="1b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，您可以使用<a class="ae lh" rel="noopener" href="/swlh/java-assertion-3b3c9611e1dc"> Java断言机制</a>。你可以像这样重写前面的if语句:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><blockquote class="mj mk ml"><p id="e3c5" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">顺便注意，如果</em> <code class="du kh ki kj kk b"><em class="hi">i</em></code> <em class="hi">为负，则上述示例中的断言可能会失败，因为</em> <code class="du kh ki kj kk b"><em class="hi">%</em></code> <em class="hi">运算符不是真模运算符，而是计算余数，余数可能为负。</em></p></blockquote><p id="d1fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/assert . html</a></p><p id="3eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<code class="du kh ki kj kk b">assert</code>语句服务于运行时的验证(当断言通常通过使用-ea标志到<code class="du kh ki kj kk b">java</code>来启用时)和意图文档。它是<strong class="ih hj">可读的</strong>并且它的性能影响很小(<a class="ae lh" href="https://en.wikipedia.org/wiki/Euclidean_algorithm" rel="noopener ugc nofollow" target="_blank">欧几里德算法</a>非常快，不管你是应用它2次还是3次都没关系)。</p><blockquote class="mj mk ml"><p id="90dd" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">尽管如此，</em> <strong class="ih hj"> <em class="hi">备选方案，是具有良好代码覆盖率的单元测试。你应该有一个涵盖else语句的单元测试。</em></strong></p></blockquote><p id="8308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" rel="noopener" href="/swlh/java-assertion-3b3c9611e1dc?source=your_stories_page-------------------------------------">https://medium.com/swlh/java-assertion-3b3c9611e1dc</a></p><p id="b2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是自引自关于<a class="ae lh" rel="noopener" href="/swlh/java-assertion-3b3c9611e1dc"> Java断言机制</a>的帖子。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="bb5a" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">内部不变量(开关)</h1><blockquote class="mj mk ml"><p id="0c66" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">另一个很好的断言候选是没有</em> <code class="du kh ki kj kk b"><em class="hi">default</em></code> <em class="hi">格的</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">语句。一个</em> <code class="du kh ki kj kk b"><em class="hi">default</em></code> <em class="hi">案例的缺席通常表明程序员相信其中一个案例将总是被执行。假设一个特定的变量将有一个小数量的值是一个不变量，应该用一个断言来检查。例如，假设下面的</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">语句出现在一个处理扑克牌的程序中:</em></p></blockquote><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><blockquote class="mj mk ml"><p id="e4ec" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">它可能表示一个假设，即</em> <code class="du kh ki kj kk b"><em class="hi">suit</em></code> <em class="hi">变量只有四个值中的一个… </em></p><p id="afb0" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">一个可接受的替代方案是:</em></p></blockquote><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><blockquote class="mj mk ml"><p id="4aeb" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">即使断言被禁用，这种替代方案也会提供保护，但是</em> <strong class="ih hj"> <em class="hi">额外的保护不会增加成本</em> </strong> <em class="hi">:除非程序失败，否则</em> <code class="du kh ki kj kk b"><em class="hi">throw</em></code> <em class="hi">语句不会执行。此外，在</em> <code class="du kh ki kj kk b"><em class="hi">assert</em></code> <em class="hi">语句不合法的某些情况下，替代语句是合法的。如果封闭方法返回值，则</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">语句中的每个case都包含一个</em> <code class="du kh ki kj kk b"><em class="hi">return</em></code> <em class="hi">语句，并且</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">语句后面没有</em> <code class="du kh ki kj kk b"><em class="hi">return</em></code> <em class="hi">语句，那么添加带有断言的默认case会导致语法错误。(如果没有匹配的大小写并且断言被禁用，则该方法将返回无值)。</em></p></blockquote><p id="2571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/technotes/guides/language/assert . html</a></p><p id="e6ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，Oracle并没有遵循该文档的建议，而是在它的指南示例中使用了<code class="du kh ki kj kk b">IllegalStateException</code>。例如参见<a class="ae lh" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank"> Java语言更新开关表达式</a>。以下是更多相关信息。</p><p id="b9a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用自<a class="ae lh" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank"> Java语言更新开关表达式</a>:</p><blockquote class="mj mk ml"><p id="8b60" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">穷尽性</em> </strong></p><p id="e356" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">与</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">语句不同，</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式的用例必须是穷举的，这意味着对于所有可能的值，必须有一个匹配的开关标签。由此可见，</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式通常需要一个</em> <code class="du kh ki kj kk b"><em class="hi">default</em></code> <em class="hi">子句。但是，对于覆盖所有已知常数的</em> <code class="du kh ki kj kk b"><em class="hi">enum</em></code> <em class="hi"> </em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式，编译器会插入一个隐式的</em> <code class="du kh ki kj kk b"><em class="hi">default</em></code> <em class="hi">子句。</em></p></blockquote><p id="dda9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/Java/javase/14/language/switch-expressions . html</a></p><p id="9251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引自JEP 325:</p><blockquote class="mj mk ml"><p id="67fa" class="if ig kg ih b ii ij ik il im in io ip mm ir is it mn iv iw ix mo iz ja jb jc hb bi translated"><em class="hi">例中的一个</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式必须详尽无遗；对于任何可能的值，都必须有一个匹配的开关标签。实际上，这通常意味着需要一个</em> <code class="du kh ki kj kk b"><em class="hi">default</em></code> <em class="hi">子句；然而，在覆盖所有已知情况的</em> <code class="du kh ki kj kk b"><em class="hi">enum</em></code> <em class="hi"> </em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式的情况下(最终，</em> <code class="du kh ki kj kk b"><em class="hi">switch</em></code> <em class="hi">表达式覆盖密封类型)</em> <strong class="ih hj">，编译器可以插入一个</strong> <code class="du kh ki kj kk b"><em class="hi">default</em></code>子句，指示<code class="du kh ki kj kk b"><em class="hi">enum</em></code>定义在编译时和运行时之间已经改变。(这是当今开发人员手工做的事情，<em class="hi">但是让编译器插入它不仅干扰较少，而且可能比手工编写的错误消息</em> <strong class="ih hj"> <em class="hi"> </em> </strong>更具描述性。)</p></blockquote><p id="a404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://openjdk.java.net/jeps/325" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/325</a></p><p id="a863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，Oracle在<code class="du kh ki kj kk b">enum</code> <code class="du kh ki kj kk b">switch</code>表达式中说“不要用<code class="du kh ki kj kk b">default</code>子句费心”，编译器会a)隐式地添加它，b)它会抛出一些异常，c)它会有描述性的错误消息。</p><p id="9e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，科特林从一开始就没有“经典”<code class="du kh ki kj kk b">switch</code>的说法。相反，它使用<code class="du kh ki kj kk b"><a class="ae lh" href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" rel="noopener ugc nofollow" target="_blank">when</a></code> <a class="ae lh" href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" rel="noopener ugc nofollow" target="_blank">表达式</a>，这将类似于Java的<code class="du kh ki kj kk b"><em class="kg">enum</em></code> <em class="kg"> </em> <code class="du kh ki kj kk b"><em class="kg">switch</em></code> <em class="kg">表达式。</em></p><p id="70b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很明显，Java团队试图“修复”<code class="du kh ki kj kk b">switch</code>，特别是<strong class="ih hj">完全摆脱抛出未经检查的异常的“负担”。</strong></p><p id="8851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际建议如下:</p><ul class=""><li id="6888" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc mp lu lv lw bi translated">如果你有<code class="du kh ki kj kk b">enum</code> <code class="du kh ki kj kk b">switch</code>表情，考虑在<code class="du kh ki kj kk b">switch </code>表情发布时使用增强版。</li><li id="7a3c" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc mp lu lv lw bi translated">抛出一些<strong class="ih hj">未选中的</strong>异常(可以是<code class="du kh ki kj kk b"><strong class="ih hj">AssertionError</strong></code>，但不一定是<strong class="ih hj">)与</strong> <code class="du kh ki kj kk b"><strong class="ih hj">default</strong></code> <strong class="ih hj">子句。</strong></li></ul><p id="10c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些个人的注意，实际上这个用例是促使我使用Java断言机制的原因。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="6734" class="jd je hi bd jf jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka bi translated">控制流不变量</h1><p id="6562" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">假设您有一个如下所示的方法:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="36a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以把最后的注释替换成<strong class="ih hj">抛出一些未检查的异常。</strong></p><p id="668d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以是<code class="du kh ki kj kk b"><em class="kg">AssertionError</em></code> <em class="kg"> </em>也可以是例如<code class="du kh ki kj kk b">IllegalStateException</code>。这并不重要，因为无论如何都不应该执行这个异常。</p><p id="4dd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><figure class="mc md me mf fd mg"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="mq mr et er es ms mt bd b be z dx"><a class="ae lh" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java" rel="noopener ugc nofollow" target="_blank">https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java</a></figcaption></figure><p id="48f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，你可以看到<code class="du kh ki kj kk b">IllegalStateException</code>被抛出是为了取悦编译器。</p><p id="eaac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:你不能让单元测试覆盖上面的第20行。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="3b94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>在单元测试中，你不应该覆盖<strong class="ih hj">所有</strong>可能的执行分支。例如，考虑以下代码:</p><pre class="mc md me mf fd mu kk mv mw aw mx bi"><span id="1840" class="my je hi kk b fi mz na l nb nc">Method method = ...<br/>Parameter[] parameters = method.getParameters();</span><span id="1546" class="my je hi kk b fi nd na l nb nc">int length = (parameters==null)?0:parameters.length;</span><span id="67f4" class="my je hi kk b fi nd na l nb nc">String[] parameterNames = new String[length];</span><span id="3573" class="my je hi kk b fi nd na l nb nc">Parameter param = null;</span><span id="7d5e" class="my je hi kk b fi nd na l nb nc">for (int i = 0; i &lt; parameters.length; i++) {</span><span id="0174" class="my je hi kk b fi nd na l nb nc">   param = parameters[i];</span><span id="592c" class="my je hi kk b fi nd na l nb nc">   if (!param.isNamePresent()) {</span><span id="55d6" class="my je hi kk b fi nd na l nb nc">      return null;</span><span id="db50" class="my je hi kk b fi nd na l nb nc">   }</span><span id="c447" class="my je hi kk b fi nd na l nb nc">   parameterNames[i] = param.getName();</span><span id="48ff" class="my je hi kk b fi nd na l nb nc">}</span></pre><p id="ba5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">受<a class="ae lh" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/StandardReflectionParameterNameDiscoverer.java" rel="noopener ugc nofollow" target="_blank">启发https://github . com/spring-projects/spring-framework/blob/master/spring-core/src/main/Java/org/spring framework/core/standardfreflectionparameternamediscoverer . Java</a></p><p id="f44b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题:</strong>参数为空的情况是否应该编写单元测试？</p><p id="bd40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">回答:</strong>当然不是，如果你看了<code class="du kh ki kj kk b">getParameters()</code>方法的java-doc你会发现它的契约明确声明<code class="du kh ki kj kk b">null</code>不能返回(长度为0的数组可以)。所以，这个测试只是浪费时间。</p><p id="3bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以再问一个问题:<em class="kg">为什么代码里有一个</em> <code class="du kh ki kj kk b"><em class="kg">null</em></code> <em class="kg">的检查？</em>如果合同说<code class="du kh ki kj kk b">null</code>不退？嗯，这是个好问题。有意见认为，这种检查应该避免。尤其是，当使用的API是JDK本身的时候。如果API合同规定<code class="du kh ki kj kk b">null</code>不会被退回，我们收到<code class="du kh ki kj kk b">null</code>的可能性极小。当然最后的说法是<code class="du kh ki kj kk b">true </code>为高质量API，但JDK绝对是高质量API。取消这种检查的另一个原因是，当使用某个API时，需要进行大量的验证，99%的情况下都是浪费时间(无论是开发时间还是运行时间)。(当你验证一切并且不信任任何人时的编程风格被称为<em class="kg">防御性编程；</em>有时是好的，但一般情况下是不建议的)。</p><p id="058c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我最多同意上面提供的观点。但是我认为做一些简单检查来避免应用程序崩溃没有什么坏处。我有两个相反的论点:<em class="kg">错误</em>和<em class="kg">推理的简易性。</em></p><p id="c8ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Bug论证。</strong>如果不管API契约说什么，方法总有一天会返回<code class="du kh ki kj kk b">null</code>呢？它甚至可以发生在JDK，在一些JDK更新程序中可以引入bug。同样，如果检查很简单，为什么不采取积极主动的措施并采取一些防御措施呢？倒楣的事情发生了…</p><p id="2a11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">推理的容易程度。</strong>大多数时候，你会调用一些质量不明确的API。更重要的是，<em class="kg">你不想花时间去搞清楚是一个成熟的开源项目还是一个人维护的项目</em>。你可以争辩说，你应该只使用建立良好的高质量的代码库，但有时你没有一些选择。例如，你有一些利基要求，有人写了一个答案作为开源，但它不是很好地建立项目。或者你得到了这个API作为一个成熟项目的可传递依赖，它包含了对你直接有用的功能。所以，当你读代码时，你不想想，“嗯，在这种情况下，我使用JDK，所以我可以省略<code class="du kh ki kj kk b">null</code>检查，在这种情况下，它是一些未知的API，所以<code class="du kh ki kj kk b">null</code>检查应该把它的位置”。如果验证很简单，那么把它放在每一个地方就简单多了，当你<em class="kg">读</em>代码时(我们读代码的次数比写代码的次数多),就不用麻烦了。否则，可能是程序有问题，可能是你的代码调用了一些不可信的代码，而<code class="du kh ki kj kk b">null</code>检查被忘记了？</p><p id="7c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae lh" rel="noopener" href="/swlh/java-assertion-3b3c9611e1dc"> Java断言机制</a>中找到更多的例子，但我个人从未在实践中使用过它们。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="8f51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的扩展和更新版本</p><p id="2825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://www.toalexsmail.com/2009/07/handling-exceptions-in-j2ee-environment.html" rel="noopener ugc nofollow" target="_blank">https://www . toalexsmail . com/2009/07/handling-exceptions-in-J2EE-environment . html</a></p><p id="7d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://www.toalexsmail.com/2009/07/handling-exceptions-in-j2ee-environment_24.html" rel="noopener ugc nofollow" target="_blank">https://www . toalexsmail . com/2009/07/handling-exceptions-in-J2EE-environment _ 24 . html</a></p></div></div>    
</body>
</html>
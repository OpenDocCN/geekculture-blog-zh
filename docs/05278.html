<html>
<head>
<title>Battle of the iOS Architecture Patterns: View Interactor Presenter Entity Router (VIPER)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS架构模式之战:查看交互器演示者实体路由器(VIPER)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960?source=collection_archive---------1-----------------------#2021-07-17">https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960?source=collection_archive---------1-----------------------#2021-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0580bc6cb8b5193d8629e4ce32f28e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CM9bKxHg4if_pMZl26sphw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Architecture Series — View Interactor Presenter Entity Router (VIPER)</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="2fac" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">动机</h1><p id="1b86" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在开始开发一个iOS应用之前，我们必须考虑项目的结构。我们需要考虑如何将这些代码添加到一起，以便它们在以后有意义——当我们回来重新访问应用程序的一部分时——以及如何与其他开发人员形成已知的“语言”。</p><p id="cdfe" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在这篇实现文章中，我们将把我们的Football Gather应用程序转换成一个VIPER代码库架构。</p><p id="e5aa" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果您错过了其他文章，您可以在下面访问它们，或者您可以在本文末尾找到链接。</p><ul class=""><li id="1fd0" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">模型视图控制器(MVC)——<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6" rel="noopener ugc nofollow" target="_blank">链接此处</a></li><li id="0712" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图视图模型(MVVM)——<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e" rel="noopener ugc nofollow" target="_blank">链接此处</a></li><li id="5e4e" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模特展示者(MVP)——<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e">链接此处</a></li><li id="d8d6" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">带协调员的模型视图演示者(MVP-C) — <a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36">链接此处</a></li></ul><p id="125b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">你是不是不耐烦了，只想看看代码？别担心！你可以在GitHub 上找到它。</p><p id="64d5" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">按照我们在其他帖子中使用的方法，我们将首先说一些关于这个模式的事情，以及它为什么有用。然后再看实际的实现。<br/>最后，我们将展示一些关于编译和构建时间的数字，检查编写单元测试有多容易，并陈述我们的结论。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="2a4f" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">为什么你的iOS应用需要一个架构模式？</h1><p id="8412" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最需要考虑的是要有一个可维护的app。你知道视图在那里，这个视图控制器应该做X而不是y。更重要的是，其他人也知道。</p><p id="40a2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">以下是选择一个好的架构模式的一些优势:</p><ul class=""><li id="2c4c" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">更易于维护</li><li id="764c" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">更容易测试业务逻辑</li><li id="eb7c" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">与其他队友发展共同语言</li><li id="550e" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">分离实体的职责</li><li id="46ad" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">更少的错误</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="1887" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">定义需求</h1><p id="7ce5" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">给定一个有六七个屏幕的iOS应用程序，我们将使用iOS世界最流行的架构模式来开发它:MVC、MVVM、MVP、VIPER、VIP和Coordinators。</p><p id="96de" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">该演示应用程序名为Football Gather，是朋友们跟踪业余足球比赛比分的一种简单方式。</p><h2 id="022f" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">主要特征</h2><p id="c648" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">能够:</p><ul class=""><li id="2d6b" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">在应用程序中添加玩家</li><li id="fd77" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">给运动员分配队伍</li><li id="311d" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">编辑玩家</li><li id="4a2b" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">为比赛设置倒计时</li></ul><h2 id="eafd" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">屏幕模型</h2><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/669dcad664ef2b3270e4cbead48b1a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6e-HGbvAvd7lL-wXpd7zGQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Screen mockups of “Football Gather”, the iOS app</figcaption></figure><h2 id="aa65" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">后端</h2><p id="4ad1" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">该应用由在<a class="ae ll" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank"> Vapor web框架</a>中开发的web应用提供支持。你可以查看我的<a class="ae ll" href="https://www.radude89.com/blog/vapor.html" rel="noopener ugc nofollow" target="_blank"> Vapor 3初始篇</a>和<a class="ae ll" href="https://www.radude89.com/blog/migrate-to-vapor4.html" rel="noopener ugc nofollow" target="_blank">关于迁移到Vapor 4 </a>的文章中的app。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="a7a3" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">伙计，我的毒蛇呢？</h1><p id="7c41" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kb hj"> VIPER </strong>代表视图-交互者-展示者-实体-路由器。</p><p id="e159" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们在MVP中看到了<strong class="kb hj"> Presenter </strong>层是什么以及它的作用。这一概念也适用于VIPER，但是它增加了一个新的职责，从<strong class="kb hj">交互器</strong>获取数据，并根据规则更新/配置<strong class="kb hj">视图</strong>。</p><h2 id="a020" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">视角</h2><p id="fd07" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">必须尽可能的愚蠢。它将所有事件转发给<strong class="kb hj">呈现者</strong>，并且主要应该做<strong class="kb hj">呈现者</strong>告诉它做的事情，这是被动的。</p><h2 id="8653" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">互动者</h2><p id="0f9c" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">引入了一个新的层，在这里我们应该放置与业务规则和逻辑相关的所有内容。</p><h2 id="d1d0" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">提出者</h2><p id="ed13" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">负责根据用户的动作从<strong class="kb hj">交互器</strong>获取数据，然后处理<strong class="kb hj">视图</strong>的更新。</p><h2 id="46be" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">实体</h2><p id="c4e8" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">是<strong class="kb hj">模型</strong>层，用于封装数据。</p><h2 id="2733" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">路由器</h2><p id="162f" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">保存我们应用程序的所有导航逻辑。看起来更像是一个<strong class="kb hj">协调者</strong>，没有业务逻辑。</p><h2 id="0f82" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">沟通</h2><p id="84a4" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当视图层中发生一些事情时，例如当用户发起一个动作时，它被传送到<strong class="kb hj">呈现器</strong>。</p><p id="ee31" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">展示者</strong>向<strong class="kb hj">互动者</strong>询问用户所需的数据。<strong class="kb hj">交互器</strong>提供数据。</p><p id="f91c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">表示器</strong>应用所需的UI转换来显示数据。</p><p id="1f84" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当型号/数据改变时，<strong class="kb hj">交互器</strong>将通知<strong class="kb hj">演示器</strong>。</p><p id="95bb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">展示器</strong>将根据其接收到的数据配置或刷新<strong class="kb hj">视图</strong>。</p><p id="1bd0" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当用户在应用程序的不同屏幕中导航或选择不同的路线来改变流程时，视图会将其传达给<strong class="kb hj">演示者</strong>。</p><p id="8db3" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">呈现器</strong>将通知<strong class="kb hj">路由器</strong>加载新的屏幕或加载新的流(例如，推送新的视图控制器)。</p><h2 id="53bd" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">加长蝰蛇</h2><p id="04c5" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">VIPER架构模式中有一些常用的概念。</p><h2 id="fd18" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">模块</h2><p id="c914" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">将VIPER层的创建从路由器中分离出来并引入一个新的模块组装处理程序是一个好主意。这很可能是用工厂方法模式完成的。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b844" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们应用的具体实现是:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="0b2f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们稍后会看到更多的源代码。</p><h2 id="3ff9" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">TimeDivisionDuplex 时分双工</h2><p id="c9e7" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">从干净代码的角度来看，这种方法做得很好，您开发的层可以很好地分离关注点，并更好地遵循可靠的原则。</p><p id="39f9" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">所以，使用VIPER很容易实现TDD。</p><ul class=""><li id="4dd9" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">模块被解耦。</li><li id="e1d1" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">关注点有明确的分离。</li><li id="223d" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">从编码的角度来看，模块是整洁干净的。</li></ul><h2 id="bad8" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码生成工具</h2><p id="67b7" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">随着我们向我们的应用程序添加更多的模块、流程和功能，我们会发现我们编写了大量的代码，其中大部分都是重复的。</p><p id="6932" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">为您的VIPER模块提供一个代码生成器工具是一个好主意。</p><h2 id="ac4b" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">解决背部问题</h2><p id="b3f8" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们看到，在应用<strong class="kb hj">协调器</strong>模式时，我们在返回堆栈导航到特定的视图控制器时遇到了问题。<br/>在这种情况下，如果我们的应用程序需要在不同的VIPER模块之间返回或发送数据，我们需要想一个办法。</p><p id="852f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这个问题可以通过<strong class="kb hj">代表团</strong>轻松解决。</p><p id="061e" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">例如:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="9871" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们将在<strong class="kb hj">部分看到更多应用于我们代码</strong>的实际例子。</p><h2 id="dc04" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">何时使用VIPER</h2><p id="ba4f" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当你对Swift和iOS编程有所了解，或者你的团队中有经验丰富或更资深的开发人员时，应该使用VIPER。</p><p id="6f17" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果你是一个小项目的一部分，那么VIPER可能太大了。MVC应该工作得很好。</p><p id="e7e8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当你对模块化和单元测试更感兴趣的时候使用它，这样你就能得到高代码覆盖率。当你是一个初学者或者你没有太多的iOS开发经验时，不要使用它。做好写更多代码的准备。</p><p id="2d56" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">从我的角度来看，VIPER很棒，我真的很喜欢代码看起来很干净。易于测试，我的类是解耦的，代码确实是可靠的。</p><p id="33c3" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">对于我们的应用程序，我们将<strong class="kb hj">视图</strong>层分成两个组件:<strong class="kb hj">视图控制器</strong>和实际的<strong class="kb hj">视图</strong>。<br/><strong class="kb hj">view controller</strong>充当<strong class="kb hj">协调器</strong> / <strong class="kb hj">路由器</strong>并保存对视图的引用，通常设置为<code class="du mm mn mo mp b">IBOutlet</code>。</p><h2 id="802a" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">优势</h2><ul class=""><li id="17f2" class="lc ld hi kb b kc kd kg kh kk mq ko mr ks ms kw lh li lj lk bi translated">代码是干净的，SRP是它的核心。</li><li id="2e8a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">单元测试很容易编写。</li><li id="169f" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">代码是解耦的。</li><li id="0296" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">更少的错误，特别是如果你使用TDD。</li><li id="3003" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">对于复杂的项目非常有用，它简化了业务逻辑。</li><li id="22ab" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">这些模块可以重复使用。</li><li id="6f28" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">新功能很容易添加。</li></ul><h2 id="8f61" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">不足之处</h2><ul class=""><li id="86c4" class="lc ld hi kb b kc kd kg kh kk mq ko mr ks ms kw lh li lj lk bi translated">你可能会写很多样板代码。</li><li id="cf19" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">对小型应用程序来说不太好。</li><li id="828a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">你最终会得到一个大的代码库和许多类。</li><li id="5b64" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">根据您的应用程序使用案例，某些组件可能是多余的。</li><li id="d523" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">App启动会略有增加。</li></ul></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="5ae6" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">适用于我们的准则</h1><p id="f02a" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">通过应用VIPER，该应用程序将有重大变化。</p><p id="10d5" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们决定不为<strong class="kb hj">视图</strong>和<strong class="kb hj">视图控制器</strong>保留两个单独的图层，因为其中一个图层会变得很淡，没有多大用处。</p><p id="46b6" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">所有协调员都将被删除。</p><p id="eb7f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">首先，我们首先创建一个<code class="du mm mn mo mp b">AppLoader</code>，它将加载第一个模块<strong class="kb hj"> Login </strong>。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="4589" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们在<code class="du mm mn mo mp b">AppDelegate</code>中分配<code class="du mm mn mo mp b">AppLoader</code>,并在应用完成启动时调用函数<code class="du mm mn mo mp b">build()</code>。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e052" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们之前看到过，我们如何使用<code class="du mm mn mo mp b">ModuleFactory</code>来创建毒蛇模块。我们为所有需要在我们的应用程序中组装的模块提供了一个接口。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="434d" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们有一个结构<code class="du mm mn mo mp b">ModuleFactory</code>，它是上述协议的具体实现。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="dc6a" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们看看<strong class="kb hj"> LoginModule </strong>是如何创建的。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="3539" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">每个模块都有一个功能<code class="du mm mn mo mp b">assemble()</code>，在执行<code class="du mm mn mo mp b">AppModule</code>协议时需要用到。</p><p id="8331" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在这里，我们创建毒蛇层之间的引用:</p><ul class=""><li id="a6d2" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated">我们将视图设置为演示者(弱链接)。</li><li id="1cd0" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated"><strong class="kb hj">主讲人</strong>非常重视<strong class="kb hj">互动者</strong>。</li><li id="054a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated"><strong class="kb hj">演示者</strong>强烈引用了<strong class="kb hj">路由器</strong>。</li><li id="49df" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated"><strong class="kb hj">交互器</strong>持有对<strong class="kb hj">呈现器</strong>的弱引用。</li><li id="1e2a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">我们的<strong class="kb hj">视图</strong>强烈引用了<strong class="kb hj">演示者</strong>。</li></ul><p id="ea60" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当然，我们设置弱引用是为了避免可能导致内存泄漏的保留周期。</p><p id="9115" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们应用程序中的每个VIPER模块都是以相同的方式组装的。</p><p id="13e6" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">LoginRouter</code>有一个简单的工作:在用户登录后呈现球员。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="f97f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当我们将MVP应用到我们的代码时，我们忽略了一个重要的方面，那就是我们没有使我们的<strong class="kb hj">视图</strong>被动。在某些情况下，<strong class="kb hj">主持人</strong>的行为更像是<strong class="kb hj">视图模型</strong>。</p><p id="2c54" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们纠正这一点，让<strong class="kb hj">的观点</strong>尽可能的被动和愚蠢。</p><p id="0d0c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们做的另一件事是将<code class="du mm mn mo mp b">LoginViewProtocol</code>分成多个小协议，以满足特定需求:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="1317" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们通过使用协议组合将它们组合在一起，并用一个<code class="du mm mn mo mp b">typealias</code>命名它们。我们对所有的VIPER协议使用相同的方法。</p><p id="69e8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">LoginViewController</code>描述如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d9d4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">Loadable</code>是我们在先前版本的代码库中使用的相同的助手协议。它只是显示和隐藏一个加载视图，这在处理一些网络请求时很方便。对于类型为<code class="du mm mn mo mp b">UIView</code>和<code class="du mm mn mo mp b">UIViewController</code>的类，它有一个默认的实现(例如:扩展<code class="du mm mn mo mp b">Loadable where Self: UIViewController</code>)。</p><p id="3336" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">ErrorHandler</code>是一个新的助手协议，它有一个方法:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="f56e" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">默认实现使用来自<code class="du mm mn mo mp b">AlertHelper</code>的静态方法来呈现一个警报控制器。我们用它来显示网络错误。</p><p id="ec4c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们继续下面的<strong class="kb hj">演示者</strong>层:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="80b1" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们通过初始化器来设置我们的依赖关系。现在，演示者有了两个新的依赖项:<strong class="kb hj">交互器</strong>和<strong class="kb hj">路由器</strong>。</p><p id="d2cc" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在我们的<strong class="kb hj">视图控制器</strong>完成加载视图后，我们通知<strong class="kb hj">展示者</strong>。我们想让<strong class="kb hj">视图</strong>更加被动，所以我们让<strong class="kb hj">呈现者</strong>指定<strong class="kb hj">视图</strong>如何用我们从<strong class="kb hj">交互者</strong>那里获得的信息配置它的UI元素:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="ea61" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">登录和注册的服务API调用是相似的:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b48b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当API调用完成后，<strong class="kb hj">交互器</strong>从<strong class="kb hj">展示器</strong>中调用以下方法:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="6cfb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">交互器</strong>现在拥有业务逻辑:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="bde3" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们在公共API中公开了<code class="du mm mn mo mp b">rememberMe</code>和<code class="du mm mn mo mp b">username</code>的实际值:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="0385" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">服务处理程序比以前的架构模式更轻便:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="5676" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">编辑玩家时，我们使用委托来刷新来自<strong class="kb hj">玩家列表</strong>模块的玩家列表。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="a9e4" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">导航到编辑屏幕</h2><p id="7aea" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们通过从<code class="du mm mn mo mp b">PlayerListPresenter</code>调用路由器来显示<code class="du mm mn mo mp b">PlayerDetailsView</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="4da1" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">PlayerListRouter</code>如下所示:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="0927" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在，我们用同样的方法从<strong class="kb hj">细节</strong>屏幕到<strong class="kb hj">编辑</strong>屏幕:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e2bc" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">和路由器:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="0d3d" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">导航回列表屏幕</h2><p id="cad0" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当用户确认对播放器的更改时，我们称之为演示者代表。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="5af8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">委托人是<code class="du mm mn mo mp b">PlayerDetailsPresenter</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="a041" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，我们调用<code class="du mm mn mo mp b">PlayerDetailDelegate</code>(分配给<code class="du mm mn mo mp b">PlayerListPresenter</code>)并刷新玩家列表:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="17f8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们按照同样的方法对<strong class="kb hj">确认</strong>和<strong class="kb hj">添加</strong>模块:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="c711" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kb hj">路由器</strong>类如下所示:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d4e9" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<code class="du mm mn mo mp b">PlayerAddPresenter</code>中实现服务处理器:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="57e2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，代表团成员名单:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="9b04" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在这种架构模式中，我们想让<strong class="kb hj">视图</strong>尽可能被动(这一概念也应该应用于MVP)。<br/>对于我们为表格行创建的那个，一个<code class="du mm mn mo mp b">CellViewPresenter</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="cf93" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">具体类别描述如下:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="a003" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">主讲人将更新<code class="du mm mn mo mp b">CellView</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e741" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<code class="du mm mn mo mp b">PlayerViewController</code>中，我们有<code class="du mm mn mo mp b">cellForRowAt</code>方法:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="3a6e" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<strong class="kb hj">表示器</strong>中，我们缓存了现有的单元格表示器:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="c2be" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，我们介绍我们的主要应用程序模块，<strong class="kb hj">收集</strong>。</p><p id="5ed8" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">GatherViewController</code>简化了，看起来很棒:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d4c4" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们使用协议<code class="du mm mn mo mp b">GatherViewConfigurable</code>公开公共API:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d95c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du mm mn mo mp b">GatherViewReloadable</code>定义了<code class="du mm mn mo mp b">reloadData</code>方法。在这里，我们重新加载所有的<code class="du mm mn mo mp b">picker</code>组件和<code class="du mm mn mo mp b">tableView</code>数据。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="66d7" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们不再有两个单独的层，<strong class="kb hj">视图控制器</strong>和<strong class="kb hj">视图</strong>。警报控制器演示在<strong class="kb hj">视图</strong>层中完成:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="c2f9" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们可以使用一个单独的层，并为表格和选取器的<strong class="kb hj">数据源</strong>和<strong class="kb hj">委托</strong>创建另一个对象，但是为了我们的练习，我们更喜欢在我们的<strong class="kb hj">视图控制器</strong>中实现这些方法:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b748" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们还实现了<code class="du mm mn mo mp b">ScoreStepperDelegate</code>来将团队滑块的UI更新传递给演示者。</p><p id="d58b" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后是一些帮助器协议，为我们的自定义单元添加功能，显示和隐藏加载微调器并处理错误。</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="9e62" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">测试我们的业务逻辑</h1><p id="6196" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在VIPER中，我们有<strong class="kb hj">交互器</strong>来处理我们的业务逻辑。这个要测试。</p><p id="f108" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然而，该架构的核心是<strong class="kb hj">表示器</strong>，它处理对<strong class="kb hj">视图</strong>的更新，并与<strong class="kb hj">路由器</strong>和<strong class="kb hj">交互器</strong>进行通信。这也应该被测试。</p><h2 id="a6f3" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">测试演示者</h2><p id="5afc" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">单元测试演示者的类别是<code class="du mm mn mo mp b">GatherPresenterTests</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b6f7" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">测试表视图和选取器视图的数据源:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e6eb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">测试步进处理器:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="16cf" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">测试<code class="du mm mn mo mp b">IBActions</code>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e7de" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">模拟在一个单独的文件中定义:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="8ab2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">测试<strong class="kb hj">互动器</strong>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="30e7" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们嘲笑<strong class="kb hj">的主持人</strong>:</p><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="9226" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">关键指标</h1><h2 id="6b1e" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—协议</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="362e" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—视图控制器和视图</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="4d88" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—模块</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="924f" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—路由器</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="c232" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—演示者</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="d40a" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—交互器</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="55ee" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">代码行—本地模型</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="3655" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">单元测试</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="e4cd" class="lr jc hi bd jd ls lt lu jh lv lw lx jl kk ly lz jp ko ma mb jt ks mc md jx me bi translated">构建时间</h2><figure class="mg mh mi mj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d113" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><em class="mt">测试在8核英特尔酷睿i9，MacBook Pro，2019上运行。Xcode版本:12.5.1。大苏尔马科斯。</em></p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="0015" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">结论</h1><p id="fdcf" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果你正在寻找干净的代码，VIPER是一个很棒的架构。如果我们真的想接受单一责任原则，我们甚至可以更进一步，创造更多的层次。</p><p id="a2a2" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">单元测试很容易编写。</p><p id="c618" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">另一方面，我们的项目中有很多文件、协议和类。当某些东西改变或者我们需要更新UI中的某些东西时，我们最终会改变很多东西，这需要时间。</p><p id="6929" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">具体到我们的应用程序，与其他模式相比，将现有的MVP-C架构转换成VIPER更难实现。我们必须先合并<strong class="kb hj">视图</strong>和<strong class="kb hj">视图控制器</strong>层，然后我们必须接触几乎所有的类并创建新的类/文件。</p><p id="9fdb" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">功能相当小，大部分集中做一件事。</p><p id="c0a9" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果我们想使用静态框架，将模块从主<code class="du mm mn mo mp b">.xcodeproj</code>中分离出来，那么协议文件是有用的。</p><p id="b515" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们注意到<strong class="kb hj"> ViewControllers </strong>已经减少了很多，它们加起来差不多有<strong class="kb hj"> 800 </strong>行代码。这比来自MVC的<strong class="kb hj"> ViewControllers </strong>多一倍，在MVC中我们有<strong class="kb hj"> 1627 </strong>行代码。</p><p id="4845" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">另一方面，我们现在有了新的层次:</p><ul class=""><li id="a9bb" class="lc ld hi kb b kc kx kg ky kk le ko lf ks lg kw lh li lj lk bi translated"><strong class="kb hj">协议</strong> —这只是模块的抽象，只包含层的定义。</li><li id="abba" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated"><strong class="kb hj">模块</strong> —蝰蛇层的组装。它是<strong class="kb hj">路由器</strong>的一部分，通常由工厂初始化。</li><li id="500f" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated"><strong class="kb hj">交互器</strong> —包含业务逻辑和网络调用，编排数据变化。</li></ul><p id="2c7f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">新图层增加了1903行代码。</p><p id="ef15" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">编写单元测试非常有趣。我们让一切脱钩，并很高兴断言不同的条件。我们设法获得了100%的代码覆盖率。</p><p id="c1e0" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然而，构建时间是最长的。每次我们删除<strong class="kb hj">派生数据</strong>文件夹的内容并清理构建文件夹，我们都会损失<strong class="kb hj"> 10.43 </strong>秒。<br/>这比应用在MVVM或MVC时多花了将近一秒钟。但是谁知道我们在修复潜在的错误上节省了多少时间呢？！</p><p id="ebf5" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">清理文件夹后执行单元测试，大约需要<strong class="kb hj"> 20秒</strong>。我们有更多的测试，总共46次。</p><p id="8591" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">更多的文件、类和依赖项会增加编译器的编译时间。</p><p id="d91c" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">幸运的是，我们不必在每次想要运行单元测试时清理构建和清除派生数据文件夹。我们可以将此职责留给CI服务器。</p><p id="ab48" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我个人喜欢在不经常改变的大中型应用程序中使用VIPER，我们在现有的基础上增加新的功能。</p><p id="3a9f" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然而，当采用VIPER时，有一些显著的缺点。首先，你写了很多代码，你可能会想为什么你需要通过三层，而不是仅仅在<strong class="kb hj">视图控制器</strong>中完成。</p><p id="1caa" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">其次，它对小型应用程序没有意义，我们不需要在简单的任务中添加样板文件，创建多余的文件。</p><p id="b759" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，你的app编译时间，甚至你的启动时间都会增加。</p><p id="bdea" class="pw-post-body-paragraph jz ka hi kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">谢谢你坚持到最后！</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="67bd" class="jb jc hi bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">有用的链接</h1><ul class=""><li id="1481" class="lc ld hi kb b kc kd kg kh kk mq ko mr ks ms kw lh li lj lk bi translated">iOS应用程序，Football Gather — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a></li><li id="84d4" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">Vapor中的web服务器应用— <a class="ae ll" href="https://github.com/radude89/footballgather-ws" rel="noopener ugc nofollow" target="_blank"> GitHub Repo Link </a></li><li id="c19d" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">Vapor 3后端API<a class="ae ll" href="https://radu-ionut-dan.medium.com/using-vapor-and-fluent-to-create-a-rest-api-5f9a0dcffc7b" rel="noopener">文章链接</a></li><li id="e4f9" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">迁移到Vapor 4 <a class="ae ll" href="https://radu-ionut-dan.medium.com/migrating-to-vapor-4-53a821c29203" rel="noopener">文章链接</a></li><li id="6557" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图控制器(MVC) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVC" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="94e1" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图ViewModel (MVVM) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVVM" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae ll" href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e" rel="noopener ugc nofollow" target="_blank">文章链接</a></li><li id="3ecc" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">模型视图演示者(MVP)——<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e">文章链接</a></li><li id="6cb6" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">协调员模式—带协调员的MVP(MVP-C)—<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP-C" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae ll" rel="noopener" href="/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36">文章链接</a></li><li id="623a" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">查看交互器演示者实体路由器(VIPER)——<a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIPER" rel="noopener ugc nofollow" target="_blank">GitHub Repo链接</a></li><li id="e000" class="lc ld hi kb b kc lm kg ln kk lo ko lp ks lq kw lh li lj lk bi translated">查看互动者展示者(VIP) — <a class="ae ll" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIP" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae ll" href="https://radu-ionut-dan.medium.com/battle-of-the-ios-architecture-patterns-view-interactor-presenter-vip-59ebdae86e84" rel="noopener">文章链接</a></li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Node.js Configuration in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的Node.js配置</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/node-js-configuration-in-kubernetes-adbb032e9db7?source=collection_archive---------2-----------------------#2021-04-05">https://medium.com/geekculture/node-js-configuration-in-kubernetes-adbb032e9db7?source=collection_archive---------2-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你好。今天我们将讨论每个项目中一个非常常见但非常重要的部分:配置。当然，它的实现依赖于编程语言、框架和基础设施，但是配置机制的原则和要求在任何地方都是相同的。我不会谈论什么是配置，本文的主要重点是通过一些部署在Kubernetes中的Node.js后端服务的例子来展示如何正确设置配置机制。</p><p id="29eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步。开始使用配置</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4f11a29d60667e62af8b3fe6f2af821d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51lRwOJhJwdViOogFFUISw.jpeg"/></div></div></figure><p id="6a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">明显的一步。但是，即使您已经将config添加到项目中，也要重新审视一下您的代码。我敢打赌，有大量的常数或“神奇”的数字和字符串。实际上它们都可以存储在配置中，你现在可能看不到它的任何好处，但是谁知道你的服务将来会有什么需求。将常量存储在config中使您的服务更加灵活，并且可以避免不必要的代码更改。例如:我们有一些模块，每天上午9点更新一次货币报价</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="fc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您的经理要求您增加报价更新的频率，每3小时更新一次:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="1982" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经更改了代码，构建并部署了它。然后您的项目经理要求您在周末禁用货币更新，以减少api的使用。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="fa48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是另一个提交、构建和部署周期。通过将cron字符串存储在config:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="dc13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步。将配置传递给服务</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/3d5e1348910a24e20e0d44619e9dc47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFtCUYZI5P5C6aT7E1YaEQ.jpeg"/></div></div></figure><p id="390d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，我们有一个可配置的服务，我们知道我们想要传递给它什么配置。但是怎么做呢？</p><p id="e6f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最流行的方法之一是通过环境变量传递配置。这是一个非常简单的方法，可以通过<code class="du js jt ju jv b">process.env</code>访问环境变量，并通过在部署规范<a class="ae jw" href="https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/tasks/inject-data-application/define-environment-variable-container/</a>中定义<code class="du js jt ju jv b">env</code>属性将其传递给Kubernetes中的Pods。但是这种方法有一个巨大的缺点:环境变量是键值结构。默认情况下，不支持数组、贴图和内部对象。此外，随着项目的增长，增加了键的数量，这个列表变成了一个+100500行的总混乱。甚至给一个新变量起个名字都开始变得困难。配置不应呈现为扁平结构，这是一个死胡同。</p><p id="a794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JSON和YAML是存储配置数据的完美选择。好吧，不太完美，合并这些格式的文件总是一件令人头痛的事情，但是它们仍然可以让你轻松地分组配置数据，存储数组和映射。JSON或YAML完全是你的选择，我更喜欢YAML，因为它更紧凑。</p><p id="a611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是Node.js进程将如何从<code class="du js jt ju jv b">.json</code>或<code class="du js jt ju jv b">.yaml</code>文件中访问数据呢？当然，您可以编写一些读取文件的代码，但是最好使用ready solution来实现这个目的。我最喜欢的是<a class="ae jw" href="https://www.npmjs.com/package/config" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/config</a>，非常好记:)如果你和我一样喜欢yaml，别忘了在你的项目中加入<code class="du js jt ju jv b">js-yaml</code>。默认情况下，该库试图从<code class="du js jt ju jv b">./config/${NODE_ENV}.json</code>或<code class="du js jt ju jv b">./config/${NODE_ENV}.yaml</code>读取配置，默认情况下<code class="du js jt ju jv b">NODE_ENV</code>为<code class="du js jt ju jv b">development</code>。它还支持默认配置，以避免配置值重复。<code class="du js jt ju jv b">config</code>有很多有用的特性，完整文档在这里<a class="ae jw" href="https://lorenwest.github.io/node-config/" rel="noopener ugc nofollow" target="_blank">https://lorenwest.github.io/node-config/</a></p><p id="b6c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们的服务能够读取配置文件，现在我们需要以某种方式将这些文件传递给准备和生产Kubernetes集群中的服务。甚至不要考虑将配置文件添加到docker映像中！配置必须单独存储。在大公司中，由于安全原因，开发人员不会管理生产配置。为了解决这个问题，Kubernetes提供了将配置文件挂载到pod的能力<a class="ae jw" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#add-configmap-data-to-a-volume" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/tasks/configure-pod-container/configure-pod-config map/# add-config map-data-to-a-volume</a>。所有配置必须存储为Kubernetes配置映射，在Pod上创建Kubernetes会将配置文件添加到所需的目录中，服务会启动必要的配置。</p><p id="5c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一点。有些库，比如TypeORM，建议你将它们的配置保存在单独的文件中，比如<code class="du js jt ju jv b">ormconfig.json</code>。您可以挂载两个或更多的配置文件，但是维护一个文件比维护两个文件要容易得多。只需查看库的文档，一定有一种方法可以在不添加额外文件或环境变量的情况下传递它的配置。</p><p id="67a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤三。验证</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/97f9e86b7bef5814774cc4ace8492e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pzTT1itbKvcm1INhWy2EMA.png"/></div></figure><p id="3dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动服务之前，必须确保其配置有效。我所说的有效配置是指所有必需的字段都存在，并且值具有正确的类型。记录配置验证失败的详细错误消息也非常重要，因为部署不仅可以由您执行。</p><p id="4d17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju jv b">config</code>语言和常识<code class="du js jt ju jv b">./config/test.yaml</code></p><p id="52cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为人类的标志，语言已经被深入研究，但仍然困扰着机器。当今的自然语言处理(NLP)技术:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jy"><img src="../Images/ed3cf31ee4ead2e0ff98a77d1345d570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izBaRgm7E7DXxkaYZosFZw.png"/></div></div></figure><p id="08e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">能从清楚陈述的事实中提取简单的信息，但不能从文本中构建复杂的知识结构；他们也不能回答需要从多个来源的信息进行大量推理的问题。</p><p id="b3d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为与人类交流的基本手段，NLP对于构建服务于我们的超级智能至关重要。</p><p id="3dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju jv b">NODE_ENV=test</code>自举、递归和反思<code class="du js jt ju jv b">config</code></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/ccaa90afc4f7017b51e72a01a54b0764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*XKetm8_pO-DJVkFcg5VwnA.jpeg"/></div></div></figure><p id="c86d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是计算机科学中最强大的范例之一。基本思想是，我们可以构造一个引用自身的数据，或者一个在执行过程中调用自身的函数。这种递归关系不是微不足道的，值得敬畏，因为我们现在正在构建的实体有能力建立在它现有的自我之上。出于同样的原因，我们希望我们的人工智能系统能够收集一些知识，处理这些知识，并使用它们来构建和理解更高层次的概念。这很像在没有比C语言更具表达能力的语言的情况下编写C编程语言编译器:人们会编写一些汇编代码来简化一些任务或例程，并迭代地使用它们来进一步开发和扩展这个编译器，直到构造出一个成熟的编译器。这是典型的自举过程。</p><p id="1c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju jv b">./config/${NODE_ENV}.yaml</code>概念和理论的累积学习<code class="du js jt ju jv b">config</code></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/ec2bbd9ee3981486eeff7c49d130543e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x7SHxrnboY2HmdkFpnvHA.jpeg"/></div></div></figure><p id="f1b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">牛顿的名言“如果我比别人看得更远，那是因为我站在巨人的肩膀上”就是一个范例。知识，无论多么微小或宏大，都可以传给下一代。不幸的是，人工智能系统仍然无法积累知识。就像自举一样，智能机器必须在各个领域积累一代又一代的新概念，就像孩子们在学校可能会学到的那样。</p><p id="ac5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank">发现动作</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="7120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需去谷歌搜索任何关键词。数十亿网页的结果将被返回。就在几十年前，这还是不可想象的。考虑计算机网络层次结构(见上图)。每次你在浏览器中输入google.com，大量的协议和操作，可能涉及几十台机器，只是为了把网站提供给你。作为用户，我们需要知道的只是如何键入这些按键，机器将运行数十年来开发的众多网络算法。对人类来说，这是一个方便的抽象概念。我们希望人工智能能够自己学习这种抽象，这样它就可以像人类一样建立抽象层。如何做到这一点仍然是个谜。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="a6dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人工智能有局限性吗？</p><p id="4c10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes又一次找到了治疗头痛的方法。如果Secret或ConfigMap安装到Pod，它会在数据更改时在Pod中自动更新<a class="ae jw" href="https://kubernetes.io/docs/concepts/configuration/secret/#mounted-secrets-are-updated-automatically" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/configuration/Secret/# mounted-secrets-is-updated-automatically</a>。我们需要做的就是在Node.js服务内存中重新加载配置数据。不幸的是，<code class="du js jt ju jv b">config</code> lib被设计成单例的，它不支持开箱即用。但是有一种方法:</p></div></div>    
</body>
</html>
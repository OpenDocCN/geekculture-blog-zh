<html>
<head>
<title>An introduction to asyncio in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的asyncio简介</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/an-introduction-to-asyncio-in-python-5d3e19a02263?source=collection_archive---------1-----------------------#2022-02-08">https://medium.com/geekculture/an-introduction-to-asyncio-in-python-5d3e19a02263?source=collection_archive---------1-----------------------#2022-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dd54" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你好asyncio世界！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c2e9617bd1da71c7c97d9e11a88c3b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyCMYhuaW3wlrLluI0uAUA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">image source: <a class="ae jn" href="https://dock2learn.com/tech/asyncio-in-python/" rel="noopener ugc nofollow" target="_blank">https://dock2learn.com/tech/asyncio-in-python/</a></figcaption></figure><h1 id="9180" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">简介:</h1><p id="7c25" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Asyncio是<code class="du lc ld le lf b">python</code>中<code class="du lc ld le lf b">concurrent programming</code>的工具，比螺纹和<code class="du lc ld le lf b">multi-processing</code>重量更轻。这基于执行一组任务的事件循环，重要的是，这些任务可以自由选择何时将<code class="du lc ld le lf b">yield</code>控制返回到事件循环。</p><h1 id="a93e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">asyncio的目标用户:</h1><p id="dede" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><code class="du lc ld le lf b">asyncio</code>图书馆是针对这两者的</p><ol class=""><li id="776b" class="lg lh hi ki b kj li km lj kp lk kt ll kx lm lb ln lo lp lq bi translated">最终用户开发人员</li><li id="40e6" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">框架开发人员</li></ol><p id="4013" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">我们属于第一类，在这一类中，我们构建将被某些用户使用的应用程序。例如，应用程序可以是<code class="du lc ld le lf b">fastapi</code>应用程序。</p><p id="11b5" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">框架开发人员是用python编写库的人，这些库将被像我们这样的最终用户应用程序开发人员使用。</p><h1 id="9fb3" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">你好asyncio世界！</h1><p id="768f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">编写程序的步骤如下</p><ol class=""><li id="022d" class="lg lh hi ki b kj li km lj kp lk kt ll kx lm lb ln lo lp lq bi translated">创建一个事件循环。</li><li id="cae6" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">调用属于协同例程的异步/等待函数。</li><li id="ab26" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">创建一个在循环中运行的任务。</li><li id="7867" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">等待任务完成。</li><li id="c30b" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">关闭循环。</li></ol><p id="ec1e" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">现在，让我们开始我们的第一个asyncio程序。</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="f09c" class="me jp hi lf b fi mf mg l mh mi">import asyncio, time<br/><br/><br/>async def hello_world():<br/>    print(time.ctime())<br/>    await asyncio.sleep(1.0)<br/>    print(time.ctime())<br/><br/><br/>asyncio.run(hello_world())</span></pre><p id="873f" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">输出:</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="5aa5" class="me jp hi lf b fi mf mg l mh mi">Tue Feb 8 09:31:51 2022 <br/>Tue Feb 8 09:31:52 2022</span></pre><p id="d655" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">现在，我们引入了两个新的关键词<code class="du lc ld le lf b">async</code>和<code class="du lc ld le lf b">await</code>。任何用<code class="du lc ld le lf b">async def</code>声明的python函数都称为<code class="du lc ld le lf b">coroutine</code>函数。</p><p id="f8ef" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated"><code class="du lc ld le lf b">await</code>关键字总是接受一个为<code class="du lc ld le lf b">awaitable.</code>的参数</p><ol class=""><li id="d816" class="lg lh hi ki b kj li km lj kp lk kt ll kx lm lb ln lo lp lq bi translated">协同程序(作为异步定义的结果而执行的函数)。</li><li id="dfa2" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">任何实现特殊方法<code class="du lc ld le lf b">__await__</code>的对象。</li></ol><p id="4097" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">嗯，我们讨论了编写<code class="du lc ld le lf b">asyncio</code>程序的几个步骤。然而，hello world程序与它们不太匹配。让我们一层层剥开。在<code class="du lc ld le lf b">asyncio.run()</code>的引擎盖下到底发生了什么。</p><h1 id="eba4" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">在asyncio.run()的引擎盖下:</h1><p id="f628" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了理解<code class="du lc ld le lf b">asyncio.run()</code>到底是做什么的，让我们在不使用<code class="du lc ld le lf b">run()</code>方法的情况下重写hello world asyncio程序。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://media.giphy.com/media/du8jrWgg9A9XdoIRJ7/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/du8jrWgg9A9XdoIRJ7/giphy.gif</a></figcaption></figure><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="ea7a" class="me jp hi lf b fi mf mg l mh mi">import asyncio, time<br/><br/><br/>async def hello_world():<br/>    print(time.ctime())<br/>    await asyncio.sleep(1.0)<br/>    print(time.ctime())<br/><br/><br/>loop = asyncio.get_event_loop()<br/>task = loop.create_task(hello_world())<br/>loop.run_until_complete(task)<br/>loop.close()</span></pre><p id="54b8" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">输出:</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="0d6b" class="me jp hi lf b fi mf mg l mh mi">Tue Feb 8 09:31:51 2022 <br/>Tue Feb 8 09:31:52 2022</span></pre><p id="5aae" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这个程序和第一个完全一样，除了它更全面一些。我们不使用run()方法来执行协程。相反，我们创建一个<code class="du lc ld le lf b">event loop</code>并作为<code class="du lc ld le lf b">event loop</code>的一部分运行任务。</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="a689" class="me jp hi lf b fi mf mg l mh mi">loop = asyncio.get_event_loop()</span></pre><p id="1340" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这一步得到一个<code class="du lc ld le lf b">event loop</code>。为什么我们需要一个？答案很简单。<code class="du lc ld le lf b">Coroutines</code>不能像普通python函数一样直接调用它们来执行。他们需要一个事件循环来运行。这就是我们如何得到一个☝️。在协程之外的任何地方调用<code class="du lc ld le lf b">get_event_loop()</code>总是给出相同的实例。</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="874a" class="me jp hi lf b fi mf mg l mh mi">task = loop.create_task(hello_world())</span></pre><p id="6a39" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">要执行一个协程，必须创建一个<code class="du lc ld le lf b">task</code>。没有这个，<code class="du lc ld le lf b">coroutine</code>永远不会被执行。<code class="du lc ld le lf b">create_task</code>调度协程在事件循环上运行。这将返回一个任务对象。可以使用<code class="du lc ld le lf b">task.result()</code>提取返回值，其中task是任务对象。</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="5ee0" class="me jp hi lf b fi mf mg l mh mi">loop.run_until_complete(task)</span></pre><p id="1e3b" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这是一个阻塞调用，将一直运行到协程完成。<code class="du lc ld le lf b">asyncio.run()</code>内部调用这个方法，类似的阻塞主线程。</p><pre class="iy iz ja jb fd ma lf mb mc aw md bi"><span id="8038" class="me jp hi lf b fi mf mg l mh mi">loop.close()</span></pre><p id="c429" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这是最后一步，应该对停止的循环调用close()。闭环无法恢复。asyncio.run()为每次运行创建一个事件循环，并负责关闭。</p><h1 id="7b79" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">总结:</h1><p id="7d34" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我希望这篇文章能够帮助您逐步进入python asyncio的世界。</p><p id="4a52" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这只是对asyncio编程的介绍。我将在以后的文章中更多地讨论事件循环，使用上下文管理器和asyncio等。任何asyncio程序都应该遵循上述步骤，这样就很容易更好地理解asyncio库。</p><p id="ba27" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">话虽如此，asyncio.run()是我们在日常编程中最常用的。这些步骤是为了理解内部发生了什么。</p><h1 id="805a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">警告:</h1><ol class=""><li id="e15d" class="lg lh hi ki b kj kk km kn kp ml kt mm kx mn lb ln lo lp lq bi translated"><code class="du lc ld le lf b">asyncio</code>不会让你的程序更快。<em class="lz">想得开！它只是避免了线程必须做的上下文切换和竞争条件。</em></li><li id="1afe" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lc ld le lf b">asyncio</code>不除去GIL。它只是不需要处理它，因为它是单线程的。</li><li id="b922" class="lg lh hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><code class="du lc ld le lf b">asyncio</code>完全消除所有竞态条件。<em class="lz">嗯！不是真的</em>。它可以避免多线程程序可能引入的竞争情况，例如同一进程内的共享内存访问。主要的优点是我们确切地知道在哪里有控制转移，因为关键字<code class="du lc ld le lf b">await</code>使得调试更容易。</li></ol></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="1ae9" class="pw-post-body-paragraph kg kh hi ki b kj li ij kl km lj im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated"><em class="lz">原载于2022年2月8日</em><a class="ae jn" href="https://dock2learn.com/tech/asyncio-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://dock2learn.com</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Introductory Tutorial to React: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React入门教程:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introductory-tutorial-to-react-part-2-b176db2496a8?source=collection_archive---------18-----------------------#2021-11-09">https://medium.com/geekculture/introductory-tutorial-to-react-part-2-b176db2496a8?source=collection_archive---------18-----------------------#2021-11-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程旨在为React提供一个清晰的介绍(假设没有先验知识)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1d1263c2de40595911e8ef9928b2efeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0d41ns8PTQZz4a3VbMrBg.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="44ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保从本教程的第1部分开始，点击<a class="ae jw" href="https://sarahkatharinabuehler.medium.com/introductory-tutorial-to-react-part-1-3468f37bea5a" rel="noopener">此处</a>。</p><h1 id="5fd3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">完成游戏</h1><p id="bb19" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们现在有了井字游戏的基本构件。为了有一个完整的游戏，我们现在需要在棋盘上交替放置“X”和“O ”,我们需要一种方法来确定赢家。</p><p id="f3a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查赢家，我们需要将每个方块的值存储在一个位置。最好的方法是将它存储在母板组件中，而不是每个方块中。通过传递一个道具，Board组件可以告诉每个方块显示什么，就像我们向每个方块传递一个数字一样。</p><blockquote class="la lb lc"><p id="1c16" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">"要从多个子组件收集数据，或者让两个子组件相互通信，您需要在它们的父组件中声明共享状态。父组件可以通过使用props将状态传递回子组件；这使子组件彼此保持同步，并与父组件保持同步。</p></blockquote><p id="fad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这听起来可能很复杂，但是你会看到很多概念，比如道具传递，在前面的步骤中都很熟悉！</p><p id="b8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们要做的第一件事，就是给Board组件添加一个状态。让我们调用当前状态方块和函数updateSquares(稍后指定),并将初始值设置为与9个方块对应的9个空字段的数组:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="db26" class="lm jy hi li b fi ln lo l lp lq">const Board = () =&gt; {<br/>   <strong class="li hj">const [squares, updateSquares] = useState(Array(9).fill())</strong></span></pre><p id="f688" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住我们在开始时所做的:在Board组件中，我们使用<code class="du lr ls lt li b">&lt;Square value={props.index}</code>将价值道具(索引0到8)作为<code class="du lr ls lt li b">value</code>从Board传递到Square组件。让我们再次使用道具传递机制，让value反映棋盘当前状态数组的索引<code class="du lr ls lt li b">squares:</code></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="548d" class="lm jy hi li b fi ln lo l lp lq">const TicTacToeSquare = props =&gt; {<br/>   return(&lt;Square value={<strong class="li hj">squares[props.index]</strong>} /&gt;)}</span></pre><p id="4963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要改变当一个方块被点击时会发生什么。记住一个状态钩子对于定义它的组件总是私有的，所以我们需要为Square创建一个方法来更新棋盘的状态。相反，我们将把一个函数从Board传递到square，并让Square在单击Square时调用该函数。为了将事件处理程序<strong class="ih hj"> onClick </strong>作为道具传递给子组件，我们使用函数<strong class="ih hj"> handleClick，</strong>，稍后我们将指定该函数:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="21f5" class="lm jy hi li b fi ln lo l lp lq">const TicTacToeSquare = props =&gt; {<br/>   return(&lt;Square value={squares[props.index]} <strong class="li hj">onClick={() =&gt; handleClick(props.index)</strong>}/&gt;)}</span></pre><p id="5208" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将两个道具从棋盘传到方块:<code class="du lr ls lt li b">value</code>和<code class="du lr ls lt li b">onClick</code>。因此，我们需要对Square组件进行以下更改:删除<code class="du lr ls lt li b">useState</code>表达式和<code class="du lr ls lt li b">const click</code>，并将状态<code class="du lr ls lt li b">value</code>替换为<code class="du lr ls lt li b">props.value</code>，因为Square不再跟踪游戏的状态！将<code class="du lr ls lt li b">onClick{click}</code>内的<code class="du lr ls lt li b">click</code>换成从板上传下来的<code class="du lr ls lt li b">props.onClick,</code>；</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="3289" class="lm jy hi li b fi ln lo l lp lq">const Square = (props) =&gt; {<br/>  return (<br/>     &lt;button className="square" onClick={<strong class="li hj">props.onClick</strong>}&gt; <br/>   <strong class="li hj">  {props.value}</strong> <br/>     &lt;/button&gt;<br/>)}</span></pre><p id="cd1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个阶段刷新浏览器会抛出一个错误，因为<strong class="ih hj">板组件</strong>中的某些东西还没有定义。试着去经历它，并为自己找出它可能是什么。<em class="ld">提示:这与下面的useState挂钩有关。</em></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="0ce1" class="lm jy hi li b fi ln lo l lp lq">const [squares, updateSquares] = useState(Array(9).fill())</span></pre><p id="9f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是，我们还没有定义<code class="du lr ls lt li b">updateSquares</code>函数应该如何更新<code class="du lr ls lt li b">squares</code>状态。让我们现在就在<strong class="ih hj">板组件</strong>中进行。</p><p id="a6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在要做的是使用<strong class="ih hj">扩展操作符</strong> ( <a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">阅读更多关于它的内容</a>)，它允许我们将<strong class="ih hj"> <em class="ld">作为状态数组</em> </strong> <em class="ld"> </em>的副本，或者作为替代，进行数组切片(我们现在不使用它，但是可以随意阅读<a class="ae jw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">阅读更多关于它的内容</a>)。这样，我们可以创建一个正方形的副本，并将其赋给一个新变量，我们可以用“X”替换它的属性，然后将它赋给之前在useState钩子中未定义的<code class="du lr ls lt li b">updateSquares</code>函数。在不变性小节中，我们将简要解释为什么我们创建一个正方形数组的副本，而不是修改原始数组。</p><p id="d4c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，实施这些更改:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="6c68" class="lm jy hi li b fi ln lo l lp lq">const Board = () =&gt; {<br/><strong class="li hj"> const handleClick = (props) =&gt; {<br/>   const newSquares = [...squares]<br/>   newSquares[props] = "X"<br/>   updateSquares(newSquares) }</strong></span></pre><p id="7718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">我们的浏览器现在发生了什么？</em> </strong></p><p id="2b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其实和以前一样。当我们点击棋盘上的一个方块时，它会被填充一个x。</p><p id="a685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">但是后台发生了什么？</em>T41】</strong></p><ol class=""><li id="87a3" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">当用户点击其中一个方块时，在方块的<code class="du lr ls lt li b">return()</code>表达式中指定的<code class="du lr ls lt li b">onClick</code>事件处理程序被激活。</li><li id="87b4" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">这个事件处理程序依次调用<code class="du lr ls lt li b">props.onClick()</code>，它是Board组件中指定的<code class="du lr ls lt li b">onClick</code>道具。</li><li id="5086" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">由于棋盘将函数<code class="du lr ls lt li b">handleClick(props.index)</code>传递给<code class="du lr ls lt li b">onClick</code>，当用户点击一个方块时，该函数被调用。</li><li id="7285" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">因此，当handleClick函数被调用时，会生成一个状态数组的副本，并用X填充(注意，只有那些被单击的方块)。这意味着所有方块的状态现在存储在棋盘组件中，而不是单独的方块组件中，这允许我们在未来确定游戏的赢家。</li></ol><blockquote class="la lb lc"><p id="524e" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">因为方形组件不再保持状态，所以方形组件从Board组件接收值，并在它们被单击时通知Board组件。用React术语来说，方形组件现在是<strong class="ih hj">控制的组件</strong>。董事会对他们有完全的控制权。</p></blockquote><h2 id="696a" class="lm jy hi bd jz mi mj mk kd ml mm mn kh iq mo mp kl iu mq mr kp iy ms mt kt mu bi translated">不变</h2><p id="7cbf" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">通常有两种方法来改变数据。</p><ol class=""><li id="c82c" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated"><em class="ld">通过直接改变数据的值来改变数据。示例:</em></li></ol><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="be5a" class="lm jy hi li b fi ln lo l lp lq">const player = {score: 1, name: 'Jeff'};<br/>player.score = 2;<br/>// Now player is {score: 2, name: 'Jeff'}</span></pre><ol class=""><li id="9c86" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated"><em class="ld">用具有所需更改的新副本替换</em>数据。示例:</li></ol><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="4d18" class="lm jy hi li b fi ln lo l lp lq">const player = {score: 1, name: 'Jeff'};<br/>const newPlayer = {...player, score: 2};<br/>// using object spread syntax</span></pre><p id="3133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，创建新副本的好处是什么？</p><p id="3f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">撤销和重做</em> </strong>:避免直接的数据突变可以让我们保持游戏历史的先前版本不变，以便我们可以访问它们，例如当用户想要撤销和重做某些动作时。</p><p id="90be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">检测变更</em> </strong>:我们可以很容易地检查以前的版本是否与变更后的版本不同</p><p id="52b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">确定组件何时需要重新渲染。</em> </strong></p><h1 id="430e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">现在回到游戏</h1><p id="f3c3" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们现在需要修复井字游戏中的一个明显缺陷:不能在棋盘上标记“O”。</p><p id="ea49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，我们将继续保留第一步“X”。为此，我们在Board组件中创建了另一个useState钩子，并将初始状态变量设置为<code class="du lr ls lt li b">true.</code></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="18ed" class="lm jy hi li b fi ln lo l lp lq">const [xisNext, updateXisNext] = useState(true)</span></pre><p id="dc96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以使用一个新概念:使用JavaScript <strong class="ih hj">条件操作符</strong> <code class="du lr ls lt li b"><a class="ae jw" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">condition ? true : false</a></code>的内联if-else条件呈现。首先，我们希望在handleClick函数中指定，每当单击一个正方形时，如果xisNext为true(在游戏开始时，它总是为true)，则浏览器上的newSquares数组中的值将为X。否则，如果是<strong class="ih hj">假</strong>，那么被点击的方块中就会出现O。现在，我们如何让xisNext在每秒点击时为假？通过使用updateXisNext函数用当前XisNext的逻辑not更新状态。</p><blockquote class="la lb lc"><p id="6097" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">感叹号("！")符号是<strong class="ih hj">的逻辑“非”运算符</strong>。放在布尔值的前面，它反转该值，返回相反的值。如<strong class="ih hj"> <em class="hi">！true </em> </strong>返回false。</p></blockquote><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="2363" class="lm jy hi li b fi ln lo l lp lq">const handleClick = (props) =&gt; {<br/>    const newSquares = [...squares]<br/>    newSquares[props] = <strong class="li hj">xisNext? "X" : "O"</strong><br/>    updateSquares(newSquares)<br/>    <strong class="li hj">updateXisNext(!xisNext)</strong> }</span></pre><p id="dd4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们也改变棋盘上的“状态”文本，以便它显示哪个玩家有下一轮:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="9a6b" class="lm jy hi li b fi ln lo l lp lq">const status = `Next player: ${xisNext? "X" : "O"}`</span></pre><blockquote class="la lb lc"><p id="aad5" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">${}用于将变量插入字符串，并将其解释为字符串</p></blockquote><h1 id="7b32" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">宣布获胜者</h1><p id="47ad" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">现在，我们应该显示什么时候游戏赢了，没有更多的机会了。请记住，方块索引的格式如下:<br/> 0 1 2 <br/> 3 4 5 <br/> 6 7 8</p><p id="dbf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们声明一个新函数，并将其命名为<strong class="ih hj"> calculateWinner </strong>和输入<strong class="ih hj"> squares。</strong>基于方块的格式，我们确定所有的<strong class="ih hj">获胜组合</strong>，并将它们声明为一个变量(我们称之为<strong class="ih hj"> lines </strong>)，我们可以迭代通过该变量来查看输入的方块数组是否有一条全是X或全是O的线(即，赢)。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="8337" class="lm jy hi li b fi ln lo l lp lq">function calculateWinner(squares) {<br/> const lines = [<br/> [0, 1, 2],<br/> [3, 4, 5],<br/> [6, 7, 8],<br/> [0, 3, 6],<br/> [1, 4, 7],<br/> [2, 5, 8], <br/> [0, 4, 8],<br/> [2, 4, 6],] }</span></pre><p id="7254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以接下来我们用一个<em class="ld"> for循环和if语句</em>来指定:<strong class="ih hj"> For </strong>每一行<em class="ld"/><strong class="ih hj"><em class="ld">行数组</em></strong><strong class="ih hj"><em class="ld"/></strong>上面的【a，b，c】被定义为<strong class="ih hj"> <em class="ld">行</em> </strong>以便标记列的位置然后<strong class="ih hj">如果</strong>正方形数组中位置[a]的值等于位置[b]和[c],则返回正方形[a]位置的值。如果输入方块数组中不包含任何赢线组合，则返回<strong class="ih hj"> null。像往常一样，有不止一种方法可以做到这一点，尝试不同的方法是非常有帮助的！</strong></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ddfd" class="lm jy hi li b fi ln lo l lp lq">for (let line of lines) {<br/>  if (squares[a] === squares[b] &amp;&amp; squares[a] === squares[c])<br/>  return squares[a]}<br/>  return null }</span></pre><p id="65d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二者择一地</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="394e" class="lm jy hi li b fi ln lo l lp lq">for (let line of lines) {<br/>  const [a, b, c] = line<br/>  const equal = squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]<br/>  return(equal? squares[a] : squares[''])}</span></pre><p id="3dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我解释一下上面代码中的一些内容:</p><ul class=""><li id="e828" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc mv ma mb mc bi translated">我们使用<code class="du lr ls lt li b"><a class="ae jw" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">let</strong></a></code> <strong class="ih hj"> </strong> <em class="ld">行的行</em>而不是<code class="du lr ls lt li b">const</code>，因为变量<strong class="ih hj">行</strong>将被<strong class="ih hj"> </strong>重新分配。</li><li id="acab" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">如果用逻辑<strong class="ih hj"> &amp; &amp; </strong>运算符:如果在&amp; &amp;之前指定的条件是<code class="du lr ls lt li b">true</code>，那么<code class="du lr ls lt li b">&amp;&amp;</code>之后的元素将出现在输出中。如果是<code class="du lr ls lt li b">false</code>，React会忽略并跳过它。</li><li id="b9b1" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">=== (Triple equals)是JavaScript中的一个<strong class="ih hj">严格相等比较运算符</strong>，它为不同类型的值返回false。如果我们用===来比较2和“2”，那么它将返回一个假值。使用两个等号将返回true，因为在进行比较之前，字符串“2”被转换为数字2。</li><li id="17e4" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">语法<em class="ld">相等？squares[a] : squares[''] </em>表示如果equal为<strong class="ih hj">真</strong>，则执行<em class="ld"> squares[a] </em>否则执行 <em class="ld"> squares[''] </em>(为空字段)</li><li id="d135" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">在JSX中不能有JS变量声明或循环，所以我们需要把它指定为一个函数，在返回表达式中调用。</li></ul><p id="97bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我们调用棋盘中的<code class="du lr ls lt li b">calculateWinner(squares)</code>来检查玩家是否赢了。如果一个玩家赢了，我们可以显示文本，如“赢家:X”或“赢家:O”。我们将用下面几行代码替换公告板中的<code class="du lr ls lt li b">status</code>声明:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ef10" class="lm jy hi li b fi ln lo l lp lq">const winner = calculateWinner(squares)<br/>const status = winner? `Winner: ${winner}` : `Next player: ${xisNext ? 'X' : 'O'}`</span></pre><p id="3b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以改变棋盘的<code class="du lr ls lt li b">handleClick</code>功能，如果有人赢了游戏或者一个方块已经被X或O填满，我们可以忽略一次点击而提前返回:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="506a" class="lm jy hi li b fi ln lo l lp lq">const handleClick = (props) =&gt; {<br/>   const newSquares = [...squares]<br/>   const winnerDeclared = Boolean(calculateWinner(newSquares))<br/>   const squareFilled = Boolean(newSquares[props])<br/>   if (winnerDeclared || squareFilled) return<br/>   newSquares[props] = xisNext? "X" : "O"<br/>   updateSquares(newSquares)<br/>   updateXisNext(!xisNext)}</span></pre><blockquote class="la lb lc"><p id="0bc6" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">注意:对于任何非空、非零、对象或数组，Boolean()将返回true，而如果正方形是空的，则返回false，因为在正方形数组的副本中还没有计算出获胜者。</p><p id="eb9c" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">逻辑<strong class="ih hj">或</strong>运算符:<code class="du lr ls lt li b"><em class="hi">(a || b)</em></code>如果<code class="du lr ls lt li b"><em class="hi">a</em></code>为真则不计算<code class="du lr ls lt li b"><em class="hi">b</em></code>并返回<code class="du lr ls lt li b"><em class="hi">a</em></code>，如果为假则计算并返回<code class="du lr ls lt li b"><em class="hi">b.</em></code></p></blockquote><h1 id="b663" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">存储移动历史</h1><p id="9ce9" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">作为最后一个练习，让我们能够“及时回到”游戏中的前一步。</p><p id="60db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得我们如何使用<code class="du lr ls lt li b">[...squares]</code>在每次点击后复制一个正方形数组，而不是改变它。这允许我们存储<code class="du lr ls lt li b">squares</code>数组的每个过去版本，并在已经发生的回合之间导航。我们将过去的<code class="du lr ls lt li b">squares</code>数组存储在另一个名为<code class="du lr ls lt li b">history</code>的数组中，该数组代表从第一步到最后一步棋的所有棋盘状态。它应该具有以下结构:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="a02b" class="lm jy hi li b fi ln lo l lp lq">history = [<br/>  // Before first move<br/>  {<br/>    squares: [<br/>      null, null, null,<br/>      null, null, null,<br/>      null, null, null,<br/>    ]<br/>  },<br/>  // After first move<br/>  {<br/>    squares: [<br/>      null, null, null,<br/>      null, 'X', null,<br/>      null, null, null,<br/>    ]<br/>  },]</span></pre><p id="5614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循与上次提升状态相同的逻辑，我们希望将<code class="du lr ls lt li b">history</code>状态存储在棋盘的父组件:游戏组件中。这给了游戏组件对棋盘数据的完全控制权，并让它指示棋盘呈现来自<code class="du lr ls lt li b">history</code>的先前移动。</p><p id="1ccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将使用如上所示的结构来设置游戏组件的初始状态:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="862e" class="lm jy hi li b fi ln lo l lp lq">const Game = () =&gt; {<br/>   const initialHistory = [{ squares: Array(9).fill(null) }];<br/>   const [history, setHistory] = useState(initialHistory);<br/>   const [xIsNext, setXIsNext] = useState(true);</span></pre><p id="a383" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将让棋盘组件接收来自游戏组件的<code class="du lr ls lt li b">squares</code>和<code class="du lr ls lt li b">onClick</code>道具。因为我们现在有了一个用于许多方块的单击处理程序，我们需要将每个方块的位置传递给<code class="du lr ls lt li b">onClick</code>处理程序来指示哪个方块被单击了。以下是转换电路板组件所需的步骤:</p><ul class=""><li id="d859" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc mv ma mb mc bi translated">删除板上的<code class="du lr ls lt li b">useState</code>表情。</li><li id="9cb4" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">将板的<code class="du lr ls lt li b">renderSquare</code>中的<code class="du lr ls lt li b">squares[i]</code>替换为<code class="du lr ls lt li b">props.squares[i]</code>。</li><li id="3780" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">将板的<code class="du lr ls lt li b">renderSquare</code>中的<code class="du lr ls lt li b">handleClick(i)</code>替换为<code class="du lr ls lt li b">props.onClick(i)</code>。</li></ul><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="b212" class="lm jy hi li b fi ln lo l lp lq">const Board = (props) =&gt; {<br/>   const TicTacToeSquare = (number) =&gt; {<br/>   return(&lt;Square value={props.squares[number.index]}<br/>   onClick={() =&gt; props.onClick(number.index)}/&gt;)}</span><span id="4ab1" class="lm jy hi li b fi mw lo l lp lq">return ( <br/>   &lt;div&gt; <br/>   &lt;div className="board-row"&gt;<br/>   &lt;TicTacToeSquare index={0} /&gt;<br/>...</span></pre><p id="b49b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要将<code class="du lr ls lt li b">handleClick</code>功能从棋盘组件转移到游戏组件。我们还需要修改<code class="du lr ls lt li b">handleClick</code>，因为游戏组件的状态结构不同。在游戏的<code class="du lr ls lt li b">handleClick</code>功能中，我们将新的历史条目连接到历史上。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="b4c0" class="lm jy hi li b fi ln lo l lp lq">const handleClick = i =&gt; {<br/>    const currentStep = history[history.length - 1];<br/>    const newSquares = [...currentStep.squares];<br/>    <br/>    const winnerDeclared = Boolean(calculateWinner(newSquares));<br/>    const squareAlreadyFilled = Boolean(newSquares[i]);<br/>    if (winnerDeclared || squareAlreadyFilled) return;<br/>    <br/>    newSquares[i] = xIsNext ? 'X' : 'O';<br/>    const newHistory = [...history, {squares: newSquares}];</span><span id="a247" class="lm jy hi li b fi mw lo l lp lq">    setHistory(newHistory);<br/>    setXIsNext(!xIsNext);</span></pre><p id="6014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们上面所做的看起来很复杂，所以让我解释一下:</p><ul class=""><li id="9212" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc mv ma mb mc bi translated">历史以数组的形式提供了棋盘每一步棋的“屏幕截图”，其中包含当前被O或x占据的方格。然后<strong class="ih hj">history[history . length-1]</strong>仅从历史中获取最后一步棋，其中包含一个包含所有当前被占据方格的数组。这被分配给一个新的变量currentStep。</li><li id="6cf2" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">然后我们在制作currentStep的副本时使用…currentStep.squares，因为我们想要提取在历史中用squares指定的<strong class="ih hj">数组</strong>，并将其分配给一个新的数组newSquares。</li><li id="2f26" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">为了指定winnerDeclared，我们在newSquares上使用<strong class="ih hj"> calculateWinner </strong>函数，以确定最后一步棋的方格数组中是否有赢家。我们再次将它设为布尔值，如果有则返回true，如果没有则返回false(即函数返回null)。</li><li id="f987" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">为了指定squareAlreadyFilled，我们使用newSquares[i],因为每当点击一个空的<strong class="ih hj">正方形时，它返回null，这作为布尔值是假的，而对于一个被占用的<strong class="ih hj">正方形，当转换为布尔值时，它返回X或O，这是真的。</strong></strong></li><li id="3b89" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated"><strong class="ih hj">if(winner declared | | squareAlreadyFilled)返回；</strong>意味着如果这两种情况中的任何一种是真的，我们就提前返回，不再允许点击</li><li id="6621" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">With <strong class="ih hj"> newSquares[i] = xIsNext？x ':' O '；我们确保值在X和O之间交替，并被重新分配给新方块中的每个方块，这样新方块就可以被重新分配为squares: Array</strong></li><li id="60c7" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">然后，我们将newSquares添加回<strong class="ih hj"> {squares: newSquares} </strong>中，并使用<strong class="ih hj"> …history </strong>将其添加到新的历史副本中，我们称之为<strong class="ih hj"> newHistory。</strong></li><li id="eb36" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc mv ma mb mc bi translated">所有这些，使用setHistory(newHistory)用其更新函数<strong class="ih hj"> setHistory </strong>更新<strong class="ih hj">状态历史</strong>为<strong class="ih hj"> newHistory </strong></li></ul><blockquote class="la lb lc"><p id="04b2" class="if ig ld ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><strong class="ih hj">为什么history.length — 1？因为Javascript数组是从0开始的，这意味着如果你有一个包含5个条目的数组，你将使用索引0到4来访问它们。我们减去一，得到最后一个索引。</strong></p></blockquote><p id="bf27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们通过添加以下内容来更新游戏组件，以使用最近的历史条目来确定和显示游戏的状态:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="f77b" class="lm jy hi li b fi ln lo l lp lq">const currentStep = history[history.length - 1];<br/>  const winner = calculateWinner(currentStep.squares);<br/>  const status = winner<br/>    ? `Winner: ${winner}`<br/>    : `Next player: ${xIsNext ? 'X' : 'O'}`;</span></pre><p id="d5ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在游戏组件的返回表达式中，我们更新了以下内容，以反映我们在上面所做的更改:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="a39e" class="lm jy hi li b fi ln lo l lp lq">return (<br/>    &lt;div className="game"&gt;<br/>      &lt;div className="game-board"&gt;<br/>        &lt;Board<br/><strong class="li hj">          squares={currentStep.squares} <br/>          onClick={i =&gt; handleClick(i)}</strong><br/>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="game-info"&gt;<br/>        &lt;div&gt;{<strong class="li hj">status</strong>}&lt;/div&gt;<br/>        &lt;ol&gt;{}&lt;/ol&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="8062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，板组件只需要<code class="du lr ls lt li b">renderSquare</code>函数和<code class="du lr ls lt li b">return</code>表达式。游戏的状态和<code class="du lr ls lt li b">handleClick</code>功能应该在游戏组件中。</p><p id="101c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">注:</em> </strong>我最初有一个错误，因为我把父组件Game的道具调用和内部道具index的调用搞混了，index来自元素TicTacToeSquare，它代表一个用户定义的组件。既然我们已经将squares和onClick之类的道具从游戏组件传递到了棋盘上，我们需要使用一个单独的名称(例如，number，但它可以被称为任何东西)来传递到用户定义的TicTacToeSquare中。然后我们可以使用number.index分别从TicTacToeSquare到props调用道具索引，后者调用。正方形和。来自游戏组件的onClick。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="9310" class="lm jy hi li b fi ln lo l lp lq">const TicTacToeSquare = (number) =&gt; {<br/>   return(<br/>   &lt;Square <br/>   value={props.squares[number.index]}<br/>   onClick={() =&gt; props.onClick(number.index)}/&gt; )}</span></pre><h1 id="2e33" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak"> <em class="mx">恭喜恭喜！</em> </strong></h1><p id="7184" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">您已经在web浏览器中创建了一个井字游戏，更重要的是，您还学习了react编程的一些基础知识和逻辑。</p><p id="550f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">我将在这里停止教程，但如果你想知道如何在浏览器上显示历史作为过去移动的列表，请使用Tom Bowden的</em> <a class="ae jw" rel="noopener" href="/@tombowden_8885/tutorial-intro-to-react-with-hooks-89b331f54b50"> <em class="ld">剩余指令</em> </a> <em class="ld">。</em></p></div></div>    
</body>
</html>
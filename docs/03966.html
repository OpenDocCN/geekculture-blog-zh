<html>
<head>
<title>Github-Strategy for Oauth using Passport in nodeJS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">github-在nodeJS中使用Passport的Oauth策略。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/github-strategy-for-oauth-using-passport-in-nodejs-1e878ff4b892?source=collection_archive---------15-----------------------#2021-06-18">https://medium.com/geekculture/github-strategy-for-oauth-using-passport-in-nodejs-1e878ff4b892?source=collection_archive---------15-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a989a55b59321699ce400fc5782b8c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlcQ8w2g5vlENEWUDzaRog.jpeg"/></div></div></figure><ul class=""><li id="867e" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">在任何express应用程序中，我们都可以使用PassportJS npm包来验证使用第三方应用程序的用户。</li><li id="377a" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">这些应用程序用于获取他们的公共配置文件数据。将<strong class="is hj"> Github-Strategy </strong>用于Oauth有<strong class="is hj"> 5个步骤</strong>。</li><li id="1e9b" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">但是首先，我们必须使用Express包设置一个基本的<strong class="is hj"> Express服务器</strong>，并设置会话中间件来创建一个会话。</li></ul></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="6f31" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤1:-将应用程序注册到Github。</h1><ul class=""><li id="d495" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">首先，我们必须将我们的应用程序注册到我们的GitHub个人资料中，以获取<strong class="is hj"> Client_Secret </strong>和<strong class="is hj"> Client_ID。</strong></li><li id="45a1" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">进入github &gt;个人资料&gt;设置&gt;开发者设置&gt; Oauth应用。</li><li id="e409" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在点击新建OAuth app，输入<strong class="is hj">应用名称</strong>，<strong class="is hj">首页URL </strong>为“<a class="ae kx" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="ky">http://localhost:3000</em></strong></a>”，<strong class="is hj">回调URL </strong>为“<a class="ae kx" href="http://localhost:3000/auth/github/callback" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="ky">http://localhost:3000/auth/github/回调</em> </strong> </a>”。</li><li id="e22b" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在从新创建的OAuth app中复制Client_ID和Client_Secret，粘贴到<strong class="is hj"> </strong> <a class="ae kx" href="http://localhost:3000/auth/github/callback" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">中。env </strong> </a>文件放在我们的项目中以备将来使用。</li></ul></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="4291" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤2:-处理护照的路线。</h1><ul class=""><li id="3bb5" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">首先，我们必须在index.ejs页面上创建一个按钮，以便在GitHub route "<strong class="is hj">/auth/GitHub</strong>"上创建请求。</li><li id="f774" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在我们必须处理索引路由器内的"<strong class="is hj"> /auth/github </strong>"和"<strong class="is hj"> /auth/github/callback </strong>"路由。</li><li id="2875" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">但是首先，我们必须将passport和passport-GitHub包安装到我们的服务器中。使用下面的命令。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a0d6" class="li jv hi le b fi lj lk l ll lm">$ npm i passport passport-github --save</span></pre><ul class=""><li id="0c38" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">现在去“www.passportjs.com”上的passport的文档，搜索“<strong class="is hj"> github策略</strong>”。阅读文档。</li><li id="5080" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在，我们必须处理索引路由器页面中的“/成功”、“/失败”、“/auth/github”和“/auth/github/callback”路由，如下所示。</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/511a05e52793442529794ee2dded05c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*56e_3tQRKUGmrUJuTjaFqA.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">handling routes inside index router page</figcaption></figure><ul class=""><li id="7f72" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">处理回调路由时，如果验证失败，failureRedirect将重定向“/failure”路由，如果成功，将重定向“/success”路由。</li></ul><blockquote class="ls lt lu"><p id="09bd" class="lv lw ky is b it iu lx ly iv iw lz ma mb mc md me mf mg mh mi mj mk ml mm jd hb bi translated">提示:-不要忘记在索引路由器页面中导入passport。</p></blockquote></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="0b5a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第三步:- GitHub策略。</h1><ul class=""><li id="fc62" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">现在我们必须定义Github策略。我们必须在新文件夹<strong class="is hj">模块</strong>中创建一个名为<strong class="is hj"> passport.js </strong>的新文件。</li><li id="3074" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在在passport.js文件中首先导入passport包。</li><li id="4e05" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在我们必须使用下面的代码行导入GitHub-strategy。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="af99" class="li jv hi le b fi lj lk l ll lm"><strong class="le hj">var</strong> GitHubStrategy = <strong class="le hj">require</strong>('passport-github').Strategy;</span></pre><ul class=""><li id="81e9" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">现在，要定义策略，请编写以下代码</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6217" class="li jv hi le b fi lj lk l ll lm">passport.use(<strong class="le hj">new</strong> GitHubStrategy({<br/>   clientID: process.env.CLIENT_ID,  //  import client id from .env<br/>   clientSecret: process.env.CLIENT_SECRET, //import clientsecret .env<br/>   callbackURL: "/auth/github/callback"<br/>  },<br/>  <strong class="le hj">function</strong>(accessToken, refreshToken, profile, done) {<br/>       console.log(profile);<br/>       <!-- -->done(null, false); //passing falsey value as 2nd argument will return failure route.</span><span id="5f49" class="li jv hi le b fi mn lk l ll lm">  });<br/>  }<br/>));</span></pre><ul class=""><li id="a114" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">现在，在初始化express服务器之前，在app.js文件中导入passport.js文件，以便它可以在应用程序中使用。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5fff" class="li jv hi le b fi lj lk l ll lm">require(./modules/passport.js);</span></pre><blockquote class="ls lt lu"><p id="4a1f" class="lv lw ky is b it iu lx ly iv iw lz ma mb mc md me mf mg mh mi mj mk ml mm jd hb bi translated">提示:-将falsy值作为第二个参数传递给done()将调用失败路由，传递truethy值将调用成功路由。</p></blockquote></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="3a7f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤4:-向数据库添加本地副本。</h1><ul class=""><li id="cfd2" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">在上一步中，我们将<strong class="is hj">配置文件</strong>记录到控制台，我们可以检查我们在<strong class="is hj">控制台</strong>中获得的值。</li><li id="6fd4" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">我们可以从<strong class="is hj">概要文件</strong>变量中提取所需的<strong class="is hj">数据</strong>，并通过创建<strong class="is hj">用户</strong>模型将其存储到mongo数据库中。</li><li id="d727" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在我们必须在“root/models/User.js”中创建一个<strong class="is hj">用户</strong>模型。</li><li id="ea22" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">现在我们必须在passport.js文件中导入用户模型</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="99f8" class="li jv hi le b fi lj lk l ll lm">let User=require("../models/User");</span></pre><ul class=""><li id="6e65" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">现在，我们必须检查我们将要创建的用户是否存在于数据库中，以避免数据库中出现重复的用户。</li><li id="7ab3" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">我们可以使用User.find()方法来检查用户是否在配置文件变量中使用电子邮件。</li><li id="78bd" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">如果用户已经存在，我们必须呈现失败页面和成功页面，如果不存在。</li><li id="a253" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">查看下图了解更多细节</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/c191b5b4e112a6db4efdcb62e460e582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*IMyiz7rxn-decsZfEKGEsw.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">adding user to databse</figcaption></figure><ul class=""><li id="d23b" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">但是现在，如果我们运行应用程序，我们将看到错误，因为没有使用passport.initialize()中间件。</li><li id="1602" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">创建会话后，我们使用passport.initialize()中间件，这一点很重要。</li><li id="aa80" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">之后，我们必须使用passport.session()中间件从浏览器cookie中检索会话。</li></ul><blockquote class="ls lt lu"><p id="4156" class="lv lw ky is b it iu lx ly iv iw lz ma mb mc md me mf mg mh mi mj mk ml mm jd hb bi translated">T <!-- --> ip:-在app.js中导入passport包以使用上述中间件。</p></blockquote><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/b56f2979d91e030543aab3eb8d4d1379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*mqQdWgjmPX9tHsQ0cXNf2A.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">settimg middlewares</figcaption></figure><ul class=""><li id="a711" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">但是passport需要序列化函数来将用户添加到会话中。所以我们必须定义session.serialize函数。</li></ul><blockquote class="ls lt lu"><p id="a542" class="lv lw ky is b it iu lx ly iv iw lz ma mb mc md me mf mg mh mi mj mk ml mm jd hb bi translated">提示:-如果我们想要禁用会话创建，下面的步骤是可选的。</p></blockquote><ul class=""><li id="52f3" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">如果我们想禁用它，我们可以做一件事。我们可以去index.js路由器页面，在故障路由后面加上“<strong class="is hj">session:false”</strong>。</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/ef25746ec2522723e18c4c5ab4038b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*9qc3VQbZ-D_47DBqipzcrA.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">disbling session</figcaption></figure></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="3e4a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">步骤5 :-序列化和反序列化用户。</h1><ul class=""><li id="4af8" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">转到<strong class="is hj"> passportJS文档</strong>并搜索“<strong class="is hj"> serialize </strong>”并阅读文档以了解详细信息。</li></ul><h2 id="12df" class="li jv hi bd jw mr ms mt ka mu mv mw ke ix mx my ki iz mz na km jb nb nc kq nd bi translated">定义搜索用户:-</h2><ul class=""><li id="0437" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">要将用户添加到会话中，我们必须在passport.js文件中定义策略之后定义序列化用户函数。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2115" class="li jv hi le b fi lj lk l ll lm">passport.serializeUser(<strong class="le hj">function</strong>(user, done) {   <br/>      done(null, user.id);  <br/>  });</span></pre><ul class=""><li id="4c4a" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">现在你会想知道序列化函数中的<strong class="is hj">用户</strong>是如何访问<strong class="is hj">用户值</strong>的。</li><li id="6482" class="iq ir hi is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh bi translated">我们知道，一旦策略被执行，它将把创建的用户的值传递给序列化函数。</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/cc5d801a74b6f354552fd9296f533299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2J5w4SsUV75KXNDyqrUJg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">session flow.</figcaption></figure><h2 id="9932" class="li jv hi bd jw mr ms mt ka mu mv mw ke ix mx my ki iz mz na km jb nb nc kq nd bi translated">定义取消搜索用户:-</h2><ul class=""><li id="f176" class="iq ir hi is b it ks iv kt ix ku iz kv jb kw jd je jf jg jh bi translated">如果我们重启服务器，我们需要一个反序列化函数来检索现有的登录用户数据。</li></ul><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3dda" class="li jv hi le b fi lj lk l ll lm">passport.deserializeUser(<strong class="le hj">function</strong>(id, done) {<br/>   User.findById(id, <strong class="le hj">function</strong>(err, user) {<br/>     done(err, user);<br/>   });<br/> });</span></pre><ul class=""><li id="c791" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">反序列化函数获取会话cookie中的用户id，填充用户信息并用用户变量调用done回调。并将用户数据自动放入<strong class="is hj"> req </strong>变量和<strong class="is hj"> req.locals </strong>中。</li></ul><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/296f76ab98dab59d7b4c8deb9a3eea6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JYwhbjVZgBdXqoP8CwYjg.png"/></div></div></figure></div></div>    
</body>
</html>
<html>
<head>
<title>Intro to Algorithms: Two Pointers Technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法简介:双指针技术</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/intro-to-algorithms-two-pointers-technique-b37f962eab5?source=collection_archive---------32-----------------------#2021-06-21">https://medium.com/geekculture/intro-to-algorithms-two-pointers-technique-b37f962eab5?source=collection_archive---------32-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b9bc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一项基本技术的详细介绍</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d8e1f66799565805285bb6b6ade0f194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2crjwgPZ3HPQClwNRmgnA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@etiennegirardet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Etienne Girardet</a> on <a class="ae jn" href="https://unsplash.com/s/photos/2?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="810c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的上一篇文章中，我介绍了二分搜索法T4算法的来龙去脉。二分搜索法方法假设您正在浏览的集合已经被排序，两个指针技术也不例外。然而，二分搜索法在集合中定位单个元素，而双指针技术用于在数组中定位两个同时满足条件的元素。让我们来看看它是如何工作的。</p><h1 id="ce28" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">提前收费:一个天真的解决方案</h1><p id="cc20" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们转向一个强力的、天真的解决方案，在这个方案中，两个指针技术可能更适合。</p><blockquote class="lh"><p id="2864" class="li lj hi bd lk ll lm ln lo lp lq kj dx translated">给定一个整数数组(已经按升序排序)，查找并返回两个元素的索引，这两个元素相加后等于所提供的目标值。</p></blockquote><p id="ee80" class="pw-post-body-paragraph jo jp hi jq b jr lr ij jt ju ls im jw jx lt jz ka kb lu kd ke kf lv kh ki kj hb bi translated">或者给定一个<code class="du lw lx ly lz b">array</code>和一个<code class="du lw lx ly lz b">target</code>，写一个算法求解<code class="du lw lx ly lz b">array[i] + array[j] === target</code>。</p><p id="747f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们如何设计一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Brute-force_search" rel="noopener ugc nofollow" target="_blank">强力</a>的方法来解决这个问题？第一步是遍历数组中的每个元素。然后，我们必须检查每个选择的<em class="ma">元素和集合中剩余的<em class="ma">元素，测试它们的总和是否与目标值匹配。听起来像是一些嵌套循环的工作。</em></em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="a6a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个解决方案在技术上确实有效，但是效率低得可怜。你必须为数组中的每个元素遍历整个数组，直到找到解！如果数组有三四个元素长，这听起来可能并不可怕。但是想象一下用一个一百万元素长的数组来做这件事。你必须数到一百万(技术上是999，999)才能进入第二个元素！想想看，如果我们的解决方案是在数组的最后两个元素中找到的，那要花多长时间。</p><p id="ca22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个方法有一个很大的O符号O(n ),这意味着随着数组的增长，寻找答案所需的时间呈指数增长<em class="ma"/>。一点都不理想。我们如何设计出更好的解决方案？</p><h1 id="d2f4" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">实现两个指针</h1><p id="5604" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们再看一下问题的描述:</p><blockquote class="md me mf"><p id="bbcb" class="jo jp ma jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated">给定一个整数数组(<strong class="jq hj">已经按升序排序</strong>)查找并返回两个元素的索引，当两个元素相加时，它们等于所提供的目标值。</p></blockquote><p id="4296" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们如何利用这些信息来构建更有效的算法？有了这个知识，我们知道增加索引<em class="ma">总是</em>增加当前元素的值，减少索引将<em class="ma">总是</em>做相反的事情。</p><p id="b0d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在前面的解决方案中，我们总是用第二个指针<code class="du lw lx ly lz b">j</code>递增索引，给定<code class="du lw lx ly lz b">i + 1</code>的值，然后遍历剩余的元素。相反，我们可以让<code class="du lw lx ly lz b">j</code>指向数组的最后一个元素<em class="ma">并添加一些条件逻辑。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h1 id="19a7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">接近基本情况</h1><p id="d910" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们的条件逻辑将需要识别我们的<em class="ma">基础用例</em>——退出我们函数的终止场景。对于我们当前的例子来说，这很简单。</p><blockquote class="md me mf"><p id="23cc" class="jo jp ma jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated">给定一个整数数组(已经按升序排序)，find和<strong class="jq hj">返回两个元素的索引，这两个元素加在一起等于提供的目标值</strong>。</p></blockquote><p id="1fa4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我们的基础案例是<code class="du lw lx ly lz b">array[i] + array[j] === target</code>。当条件满足时，我们可以退出函数，返回<code class="du lw lx ly lz b">[i, j]</code>作为解决问题的索引。我们如何从前面代码示例中的位置导航到那个基本条件呢？</p><p id="f073" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有两种方法可以使我们不满足基本情况<em class="ma">的条件。</em><strong class="jq hj"><em class="ma"/></strong><code class="du lw lx ly lz b"><strong class="jq hj"><em class="ma">array[i]</em></strong></code><strong class="jq hj"><em class="ma"/></strong><code class="du lw lx ly lz b"><strong class="jq hj"><em class="ma">array[j]</em></strong></code><strong class="jq hj"><em class="ma">之和将大于或小于我们的目标值。结合我们所知道的递增和递减指数，我们得到了解决问题所需的一切。</em></strong></p><p id="3580" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ma">如果两个要素之和大于目标，减少其中一个指标将使我们更接近目标</em> </strong>。反之亦然。<strong class="jq hj"> <em class="ma">如果两个要素之和小于目标值，增加其中一个指标将引导我们走向正确的方向。</em> </strong>我们应该选择哪个指标进行哪个操作？</p><p id="a3e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的第一个指针<code class="du lw lx ly lz b">i</code>从0开始，所以很难再减少了(让我们暂时忽略负指数，因为它们与我们当前的问题没有任何关系或帮助)。类似地，我们的第二个指针<code class="du lw lx ly lz b">j</code>，从<code class="du lw lx ly lz b">array.length — 1</code>或者最后一个可能的索引开始。如果我们递增<code class="du lw lx ly lz b">j</code>，我们最终会指向一个不存在的元素！不太好。</p><h1 id="1dde" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">看这两个指针</strong></h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">If you look closely you’ll notice an additional base case, which returns false when no two elements’ sum matches the target value.</figcaption></figure><p id="2ef7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">查看我们完成的算法，你可以清楚地看到，它明显比暴力方法更有效。在最坏的情况下，该函数将迭代给定数组中的每个元素，从而使该函数的时间复杂度为O(n)。这意味着我们改进的函数与O(n)复杂度的强力方法相比要快得多。相当大的进步！</p><h1 id="adc8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">概述</h1><p id="1086" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">回顾一下，当在满足特定条件(即<em class="ma">基本情况</em>)的数组中搜索一对元素时，双指针技术是有用的。然后，我们评估这两个元素无法满足基本条件的方式，并编写条件逻辑，这将使我们更接近我们的目标。</p><p id="dcd7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">双指针技术不是一种算法，而是一种<em class="ma">技术，</em>意味着有多种方法可以使用它。然而，基本原则是很重要的。使用两个(或更多)指针允许我们比暴力方法更有效地遍历和处理数据。这种技术在其他什么场景中可能有用？除此之外，您还可以如何编写上面提供的解决方案？(或许是以后博文的重点？)</p><p id="e37a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你觉得这篇文章有帮助，请考虑订阅或与你的同事分享。非常感谢，祝编码愉快！</p><pre class="iy iz ja jb fd mj lz mk ml aw mm bi"><span id="95f1" class="mn kl hi lz b fi mo mp l mq mr">Resources:</span><span id="f26d" class="mn kl hi lz b fi ms mp l mq mr"><a class="ae jn" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" rel="noopener ugc nofollow" target="_blank"><strong class="lz hj">Two Sum II - Leetcode Challenge #167</strong></a><strong class="lz hj"><br/></strong><em class="ma">The inspiration for this write up</em></span><span id="67dd" class="mn kl hi lz b fi ms mp l mq mr"><a class="ae jn" href="https://www.geeksforgeeks.org/two-pointers-technique/" rel="noopener ugc nofollow" target="_blank"><strong class="lz hj">Two Pointers Technique - Geeks for Geeks</strong></a></span><span id="916b" class="mn kl hi lz b fi ms mp l mq mr"><a class="ae jn" href="https://bookshop.org/books/grokking-algorithms-an-illustrated-guide-for-programmers-and-other-curious-people/9781617292231" rel="noopener ugc nofollow" target="_blank"><strong class="lz hj">Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People</strong></a></span></pre></div></div>    
</body>
</html>
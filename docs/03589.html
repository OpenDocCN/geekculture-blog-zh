<html>
<head>
<title>Create a generic networking layer using async/await.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用async/await创建一个通用网络层。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-a-generic-networking-layer-using-async-await-9168b6281721?source=collection_archive---------2-----------------------#2021-06-11">https://medium.com/geekculture/create-a-generic-networking-layer-using-async-await-9168b6281721?source=collection_archive---------2-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/65e9ae2f52a2d9cc4c85ab6050587969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJMzmivPqqdhjPGNw0APaA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/videos/play/wwdc2021/10132/</a></figcaption></figure><div class=""/><p id="3a35" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成处理程序是闭包，是自包含的功能块，可以在代码中传递和使用。它们作为参数传递给函数，然后在函数完成时被调用。</p><p id="5cf3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们想要执行异步作业时，它们在iOS中使用，例如，让我们看看使用<strong class="ix hz"> URLSessionDataTask </strong>执行请求并解码响应的通用API是什么样子的。它看起来会像这样…</p><figure class="jt ju jv jw fd hk"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Generic networking layer — completion handlers</figcaption></figure><p id="071e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里公共的<strong class="ix hz"> fetch </strong>函数在内部调用私有的<strong class="ix hz">解码</strong> <strong class="ix hz">任务</strong>函数。<strong class="ix hz">解码</strong> <strong class="ix hz">任务</strong>函数使用<strong class="ix hz"> URLSession </strong>数据任务从服务器获取资源，正如您可以看到的，会话数据任务也是一个闭包，在它内部，一旦我们获得数据、响应或错误，我们就执行我们的转义完成处理程序。这并没有什么问题，只是简单的东西会变得冗长而不可读。</p><p id="7848" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一些其他选项，如<strong class="ix hz"> Promises </strong>有助于使这种代码更加紧凑和易于理解，但现在在<strong class="ix hz"> Swift 5.5 </strong>中，我们可以使用新的<strong class="ix hz"> async </strong>和<strong class="ix hz">await</strong>API来清理这一点，甚至使我们的代码更加安全，所以让我们看看如何重构这种通用代码，但现在使用<a class="ae hv" href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> async-await </strong> </a>。</p><figure class="jt ju jv jw fd hk"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="53a2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于示例的目的，我们仍然使用相同的APIError，但是现在我们使用<strong class="ix hz"> async/await </strong>，fetch函数仍然将可解码类型和请求作为参数，但是现在该函数是<strong class="ix hz"> async </strong>，而不是传递完成处理程序。</p><ol class=""><li id="ebf0" class="jz ka hy ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">当你标记一个函数<strong class="ix hz"> async时，</strong>关键字应该在函数签名中的<strong class="ix hz">抛出</strong>之前，就像这个例子，或者如果函数没有<strong class="ix hz">抛出</strong>则在箭头之前。现在，如果响应成功，对象被解码，方法将返回它。</li><li id="ac9b" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">iOS 15引入了一个新的<strong class="ix hz"> URLSession </strong>方法<a class="ae hv" href="https://developer.apple.com/documentation/foundation/urlsession/3767352-data" rel="noopener ugc nofollow" target="_blank">T3】数据(for:delegate:)  </a> <strong class="ix hz">，</strong>这个<strong class="ix hz"> </strong>方法<strong class="ix hz"> </strong>返回非可选数据和非可选响应。如果您进入<strong class="ix hz"> GenericAPI </strong>示例，您将看到我们使用<a class="ae hv" href="https://developer.apple.com/documentation/foundation/urlsession/1407613-datatask" rel="noopener ugc nofollow" target="_blank">data task(with:completion handler:)</a>代替，该方法返回可选数据、可选响应和可选错误。这两种方法都是异步的，并且做得非常相似(嗯，不完全是这样,“旧的”API也返回错误信息，但是异步的<strong class="ix hz">不返回，我不确定为什么苹果决定在返回值中删除这条信息🤷🏽‍♂️).这个<strong class="ix hz">异步</strong>方法<strong class="ix hz">抛出</strong>所以调用者需要添加一个<strong class="ix hz">尝试</strong>关键字，因为是<strong class="ix hz">异步</strong>它也需要<strong class="ix hz">等待</strong>关键字。</strong></li></ol><blockquote class="kn ko kp"><p id="df86" class="iv iw kq ix b iy iz ja jb jc jd je jf kr jh ji jj ks jl jm jn kt jp jq jr js hb bi translated"><em class="hy">如果一个表达式中有多个</em> <strong class="ix hz"> <em class="hy">异步</em> </strong> <em class="hy">函数调用，你只需要写</em><strong class="ix hz"><em class="hy">await</em></strong><em class="hy">一次，就像你只需要一个</em><strong class="ix hz"><em class="hy">try</em></strong><em class="hy">对于一个有多个抛出函数调用的表达式。</em></p></blockquote><p id="db95" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.在<strong class="ix hz"> do/catch </strong>块中，如果解码操作成功，我们将返回解码后的值。</p><p id="d388" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.要不然，我们<strong class="ix hz">扔</strong>。</p><p id="5d05" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当调用一个<strong class="ix hz">异步</strong>方法时，有一件事你需要知道，让我们看一个例子，我们将创建一个远程对象，它有一个<strong class="ix hz">发布的</strong>属性<strong class="ix hz"> </strong>，这个属性将用我们的<strong class="ix hz">异步</strong>获取函数的响应来设置…</p><pre class="jt ju jv jw fd ku kv kw kx aw ky bi"><span id="3e57" class="kz la hy kv b fi lb lc l ld le"><strong class="kv hz">final</strong> <strong class="kv hz">class</strong> FeedRemote: ObservableObject {<br/>/// 1<br/><strong class="kv hz">private</strong> <strong class="kv hz">let</strong> client = Client()<br/>/// 2<br/>@Published <strong class="kv hz">private</strong>(<strong class="kv hz">set</strong>) <strong class="kv hz">var</strong> musicItems: [MusicItemViewModel] = []</span><span id="49eb" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">///3<br/>var</strong> request: URLRequest = {<br/><strong class="kv hz">let</strong> urlString = "https://rss.itunes.apple.com/api/v1/us/apple-music/coming-soon/all/50/explicit.json"<br/><strong class="kv hz">let</strong> url = URL(string: urlString)!<br/><strong class="kv hz">return</strong> URLRequest(url: url)<br/>}()</span><span id="f6d2" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">///4<br/>func</strong> fetchMusicItems()  {</span><span id="a320" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">let</strong> container = <strong class="kv hz">try</strong> <strong class="kv hz">await</strong> client.fetch(type:  Container&lt;MusicItem&gt;.self, with: request)<br/>     musicItems = container.feed.results.map { MusicItemViewModel(musicItem: $0) }<br/>}</span></pre><ol class=""><li id="0574" class="jz ka hy ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated"><strong class="ix hz">客户端</strong>是一个符合<strong class="ix hz"> AsyncGenericAPI的类。</strong></li><li id="005f" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated"><strong class="ix hz"> musicItems </strong>属性将使用<strong class="ix hz"> Combine </strong>框架发布响应中的更改。</li><li id="bde3" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">在这种情况下，请求将使用RSS提要Apple generator API。</li><li id="34f9" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">从视图控制器或任何具有初始化的<strong class="ix hz"> FeedRemote </strong>对象的实例中调用<strong class="ix hz"> fetchMusicItems </strong>。在这个函数内部，我们调用我们的<strong class="ix hz">异步</strong> fetch函数，它有<strong class="ix hz"> try </strong>和<strong class="ix hz">异步</strong>关键字，因为我们知道这是一个<strong class="ix hz">异步</strong>和<strong class="ix hz">抛出</strong>调用。</li></ol><p id="95cc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你尝试运行这个应用程序，编译器会显示几个错误…</p><p id="384f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你能看到的第一个错误是<em class="kq"> " </em> <strong class="ix hz"> <em class="kq">从这里抛出的错误没有被处理"</em>，</strong>这是一个简单的错误，你只需要将你的代码包装在一个<strong class="ix hz"> do/catch </strong>块中，第二个错误更有趣<strong class="ix hz"> <em class="kq">"在一个不支持并发的函数中进行异步调用"</em> </strong>这是什么意思？嗯，这只是意味着您需要从同步上下文中“桥接”异步调用，不用担心，这很容易解决，您可以将`<strong class="ix hz"> fetchMusicItems` </strong>标记为<strong class="ix hz"> async </strong>,就像这样…</p><pre class="jt ju jv jw fd ku kv kw kx aw ky bi"><span id="b8c6" class="kz la hy kv b fi lb lc l ld le"><strong class="kv hz">func</strong> fetchMusicItems() <strong class="kv hz">async</strong> { &lt;---- marking the function as async</span><span id="1763" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">do</strong> {</span><span id="fb52" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">let</strong> container = <strong class="kv hz">try</strong> <strong class="kv hz">await</strong> client.fetch(type:  Container&lt;MusicItem&gt;.self, with: request)<br/>      musicItems = container.feed.results.map {   MusicItemViewModel(musicItem: $0) }</span><span id="3cf3" class="kz la hy kv b fi lf lc l ld le">} <strong class="kv hz">catch</strong> {<br/>      print("The error is --- \((error <strong class="kv hz">as</strong>! APIError).customDescription)")<br/>  }<br/>}</span></pre><p id="a530" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这解决了这里的问题，但它只是移动了一级应用程序，您可以继续将顶级函数标记为<strong class="ix hz"> async </strong>但有一个更好的方法，您可以使用<strong class="ix hz"> async </strong>闭包<strong class="ix hz"> </strong>来异步执行您的<strong class="ix hz"> async </strong>调用，最终实现如下所示…</p><pre class="jt ju jv jw fd ku kv kw kx aw ky bi"><span id="10ae" class="kz la hy kv b fi lb lc l ld le"><strong class="kv hz">func</strong> fetchMusicItems() {</span><span id="f343" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">async</strong> { &lt;--- async closure :) <br/>       <strong class="kv hz">  do</strong> {<br/><strong class="kv hz">             let</strong> container = <strong class="kv hz">try</strong> <strong class="kv hz">await</strong> client.fetch(type: Container&lt;MusicItem&gt;.self, with: request)<br/>             musicItems = container.feed.results.map { MusicItemViewModel(musicItem: $0) }<br/>         } <strong class="kv hz">catch</strong> {<br/>             print("The error is --- \((error <strong class="kv hz">as</strong>! APIError).customDescription)")<br/>         }<br/>   }<br/>}</span></pre><p id="aa45" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样，通过使用<strong class="ix hz">异步</strong>闭包，现在你可以执行你的<strong class="ix hz">异步</strong>函数，而不需要将顶层函数标记为<strong class="ix hz">异步</strong>🎉</p><p id="be79" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有最后一样东西我想给你看。如果您比较一下<code class="du lg lh li kv b"><strong class="ix hz">GenericAPI</strong></code>中fetch函数的实现与<strong class="ix hz"> AsyncGenericAPI </strong>中fetch函数的实现，您可以看到，在第一个函数中，当我们获得结果时，我们使用<strong class="ix hz"> CGD </strong>跳转到主线程，那么我们如何确保我们的<strong class="ix hz">async genericapi</strong>fetch<strong class="ix hz"/>方法<strong class="ix hz"> </strong>也在主线程上给我们结果以进行UI更新呢？</p><p id="8d0f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，我们也可以使用GCD来完成这个任务，然后像这样把我们的代码推到主线程上…</p><pre class="jt ju jv jw fd ku kv kw kx aw ky bi"><span id="854d" class="kz la hy kv b fi lb lc l ld le"><strong class="kv hz">func</strong> fetchMusicItems() {</span><span id="6db0" class="kz la hy kv b fi lf lc l ld le"><strong class="kv hz">async</strong> {<br/>           <strong class="kv hz">do</strong> {<br/>              <strong class="kv hz">let</strong> container = <strong class="kv hz">try</strong> <strong class="kv hz">await</strong> client.fetch(type: Container&lt;MusicItem&gt;.self, with: request)<br/>              DispatchQueue.main.async { &lt;--- GCD main queue<br/>                <strong class="kv hz">self</strong>.musicItems = container.feed.results.map { MusicItemViewModel(musicItem: $0) }<br/>              }<br/>           } <strong class="kv hz">catch</strong> {<br/>               print("The error is --- \((error <strong class="kv hz">as</strong>! APIError).customDescription)<br/>           }<br/>      }<br/>}</span></pre><p id="ff2f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是可行的，但是现在有一个更好的方法，你可以使用<strong class="ix hz"> @MainActor </strong>属性包装器来保证你的代码将在主线程上运行，甚至不需要手动指定它。Swift会自动将在那里发生的任何工作排队，就像我们自己使用了<strong class="ix hz"> DispatchQueue.main </strong>一样。</p><p id="ccc6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以仅在您的函数或属性中使用<strong class="ix hz"> @MainActor </strong>，但是对于这个远程类将总是发布结果以显示在<strong class="ix hz"> UI中的示例，</strong>在整个类中使用它更有意义。通过这样做，它里面的每个函数或属性都将拥有一个<strong class="ix hz"> @MainActor </strong>提供的好处。</p><p id="844b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码将如下所示…</p><pre class="jt ju jv jw fd ku kv kw kx aw ky bi"><span id="5806" class="kz la hy kv b fi lb lc l ld le">@MainActor<br/><strong class="kv hz">final</strong> <strong class="kv hz">class</strong> FeedRemote: ObservableObject {<br/>/// FeedRemote implementation ....<br/>}</span></pre><p id="b0d2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是Swift 5.5通过其新的并发API带来的一小部分工具，还有更多，如果您感兴趣，这里是WWDC2021关于这一主题的所有演讲的精选列表。😁</p><h2 id="5600" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank">在Swift中满足异步/等待</a></h2><h2 id="0c85" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10133/" rel="noopener ugc nofollow" target="_blank">用迅捷动作者保护易变状态</a></h2><h2 id="5bff" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10134/" rel="noopener ugc nofollow" target="_blank">探索Swift中的结构化并发</a></h2><h2 id="9e75" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10058/" rel="noopener ugc nofollow" target="_blank">满足异步序列</a></h2><h2 id="aef9" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10254/" rel="noopener ugc nofollow" target="_blank"> Swift并发:幕后</a></h2><h2 id="b3aa" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10095/" rel="noopener ugc nofollow" target="_blank">对URLSession使用async/await</a></h2><h2 id="00e9" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10194/" rel="noopener ugc nofollow" target="_blank"> Swift并发:更新一个样本应用</a></h2><h2 id="e7ee" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10254/" rel="noopener ugc nofollow" target="_blank">快速并发:幕后</a></h2><h2 id="9285" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10019/" rel="noopener ugc nofollow" target="_blank">在SwiftUI中发现并发</a></h2><h2 id="d409" class="kz la hy bd lj lk ll lm ln lo lp lq lr jg ls lt lu jk lv lw lx jo ly lz ma mb bi translated"><a class="ae hv" href="https://developer.apple.com/videos/play/wwdc2021/10258/" rel="noopener ugc nofollow" target="_blank">了解并消除应用程序中的挂起现象</a></h2><p id="1604" class="pw-post-body-paragraph iv iw hy ix b iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo mg jq jr js hb bi translated">这里有一个<a class="ae hv" href="https://github.com/jamesrochabrun/WWDC2021" rel="noopener ugc nofollow" target="_blank">示例</a>项目，包含这篇文章的所有代码和更多内容。🤓</p><p id="cbf4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae hv" href="https://forums.swift.org/t/will-swift-concurrency-deploy-back-to-older-oss/49370" rel="noopener ugc nofollow" target="_blank">这里</a>是围绕早期版本的Swift并发支持的讨论。😭🙏</p><p id="1d8a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kq">感谢</em>。🤖</p></div></div>    
</body>
</html>
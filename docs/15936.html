<html>
<head>
<title>Container Sandboxing | gVisor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器沙箱| gVisor</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/container-sandboxing-gvisor-b191dafdc8a2?source=collection_archive---------4-----------------------#2022-12-01">https://medium.com/geekculture/container-sandboxing-gvisor-b191dafdc8a2?source=collection_archive---------4-----------------------#2022-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8476" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">容器沙箱和gVisor使用概述</h2></div><p id="389a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与虚拟机相比，容器与主机操作系统的隔离较弱。因为虚拟机运行在它们自己的操作系统(内核)上，容器之间共享主机内核资源。因此，容器不如虚拟机安全。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/dd3d9a77ca90e8262687ffb432b9f7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*L5p_E4FnSNmv9IO-VsRhgw.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">from: <a class="ae kf" href="https://unit42.paloaltonetworks.com/" rel="noopener ugc nofollow" target="_blank">https://unit42.paloaltonetworks.com/</a></figcaption></figure><p id="8313" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将讨论容器沙盒，它将帮助我们使容器更加隔离。</p><p id="6692" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传统的Linux容器不是沙箱化的。容器使用系统调用与操作系统内核通信。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kg"><img src="../Images/188d0dcb798280c3ba64275fef311541.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*ZKJU_lYUDu1HYzgd.PNG"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">From: Google Cloud</figcaption></figure><p id="49fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用<a class="ae kf" href="https://levelup.gitconnected.com/seccomp-secure-computing-mode-kubernetes-docker-97130516662c" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> seccomp过滤器</strong> </a>我们可以限制系统调用，而<a class="ae kf" href="https://levelup.gitconnected.com/apparmor-for-docker-kubernetes-e82ef023a10c" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> AppArmor配置文件</strong> </a>将帮助我们限制容器可以使用的资源。但是，为生产环境中的数百种应用创建seccomp滤波器或AppArmor profile将是一项繁琐的任务。为了克服这种情况，我们可以使用容器沙箱。</p><h2 id="8ff6" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">沙盒技术</h2><p id="eaf4" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated"><strong class="iz hj"> ●基于VM的容器技术— <br/> </strong>一种提高容器隔离的方法是在自己的虚拟机(VM)中运行每个容器。这为每个容器提供了自己的“机器”，包括内核和虚拟化设备，与主机完全分离。即使guest虚拟机中存在漏洞，hypervisor仍然会隔离主机以及主机上运行的其他应用程序/容器。<br/><a class="ae kf" href="https://katacontainers.io/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">Kata Containers</strong></a><strong class="iz hj"/>是一个开源社区，致力于使用轻量级虚拟机构建安全的容器运行时，这些虚拟机感觉和执行起来像容器，但使用硬件虚拟化技术作为第二层防御来提供更强的工作负载隔离。更多信息见<a class="ae kf" href="https://katacontainers.io/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/e661acbdd10d107044610479a807b78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*3EC1cSvJlXWDn8rmsHIAbw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx">From: <a class="ae kf" href="https://katacontainers.io/" rel="noopener ugc nofollow" target="_blank">https://katacontainers.io/</a></figcaption></figure><p id="dbfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> ●带gVisor的沙盒容器— <br/> gVisor </strong>拦截应用系统调用，充当访客内核，无需通过虚拟化硬件进行转换。更多来自<a class="ae kf" href="https://gvisor.dev/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lm"><img src="../Images/a387e0309a09048231fb00112bada971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*W8FN-yRcoP3c7z6K.PNG"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">From: google cloud</figcaption></figure><p id="8c4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们主要关注的是<strong class="iz hj"> gVisor </strong>。以下是关于如何在我们的系统上安装<strong class="iz hj"> gVisor </strong>以及如何将<strong class="iz hj"> gVisor </strong>与kubernetes pods一起使用的讨论。</p><h2 id="4fd0" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">不带护目镜</h2><p id="ffb4" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在kubernetes中，容器运行在worker节点内核上，尽管它们是使用名称空间和cgroups隔离的。为了验证容器在worker nodes内核上运行，让我们在主机上运行'<strong class="iz hj"> uname </strong>'命令。</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="da7d" class="ls ki hi lo b be lt lu l lv lw"># execute 'uname' command<br/>&gt;&gt; uname -sr    <br/>Linux 5.4.0-131-generic    # &lt;------</span></pre><p id="8637" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后让我们创建一个pod，并将'<strong class="iz hj"> exec </strong>放入其中，并运行'<strong class="iz hj"> uname </strong>'命令。</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="51ce" class="ls ki hi lo b be lt lu l lv lw"># create a pod<br/>&gt;&gt; kubectl run normal-pod --image=busybonx -- sleep 2000<br/><br/># exec into the pod<br/>&gt;&gt; kubectl exec -it normal-pod -- bash<br/><br/># execute 'uname' command <br/>root@normal-pod:/ uname -sr<br/>Linux 5.4.0-131-generic      # &lt;------</span></pre><p id="7861" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我们看到worker节点和pod的内核名称和内核版本名称是相同的。这样，我们可以假设pod共享工作节点内核。为了确定这一点，我们可以检查进程id (PID)。容器只不过是运行在worker节点上的进程。为了再次验证'<strong class="iz hj"> exec </strong>'进入pod —</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="b505" class="ls ki hi lo b be lt lu l lv lw"># exec into the pod<br/>&gt;&gt; kubectl exec -it normal-pod -- bash<br/><br/># run the 'ps aux' command<br/><br/>-&gt; ps aux<br/>-----------------------------------------------------------------------------<br/>PID   USER     TIME  COMMAND<br/>    1 root      0:00 sleep 2000   #&lt;----------<br/>   22 root      0:00 sh<br/>   27 root      0:00 ps aux</span></pre><p id="e3b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，<strong class="iz hj">‘ssh’</strong>在pod正在运行的worker节点上运行<strong class="iz hj">‘PS aux’</strong>命令，并搜索作为容器运行的进程。</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="59f3" class="ls ki hi lo b be lt lu l lv lw">&gt;&gt; ssh node01<br/>&gt;&gt; ps aux | grep sleep<br/><br/>root       34930  0.0  0.0   1312     4 ?        Ss   02:12   0:00 sleep 2000</span></pre><p id="8cba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，相同的进程正在worker上运行，但是进程id不同。因为进程是使用PID名称空间隔离的。</p><p id="3bf5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们可以说，pod/containers共享工作节点内核，这可能是一个主要的安全风险。因为受损的运输舱/集装箱会影响其他运输舱/集装箱。</p><h2 id="df0c" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">使用gVisor沙盒</h2><p id="32d2" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated"><strong class="iz hj"> 1。gVisor在worker节点上的安装</strong> <br/>我们可以使用下面的脚本在节点上安装<strong class="iz hj">gVisor</strong>(pods将在这些节点上运行)</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="dede" class="ls ki hi lo b be lt lu l lv lw">#!/bin/bash<br/><br/># To download and install the latest release<br/><br/>(<br/>  set -e<br/>  ARCH=$(uname -m)<br/>  URL=https://storage.googleapis.com/gvisor/releases/release/latest/${ARCH}<br/>  wget ${URL}/runsc ${URL}/runsc.sha512 \<br/>    ${URL}/containerd-shim-runsc-v1 ${URL}/containerd-shim-runsc-v1.sha512<br/>  sha512sum -c runsc.sha512 \<br/>    -c containerd-shim-runsc-v1.sha512<br/>  rm -f *.sha512<br/>  chmod a+rx runsc containerd-shim-runsc-v1<br/>  sudo mv runsc containerd-shim-runsc-v1 /usr/local/bin<br/>)<br/><br/><br/># Update /etc/containerd/config.toml<br/><br/>cat &lt;&lt;EOF | sudo tee /etc/containerd/config.toml<br/>version = 2<br/>[plugins."io.containerd.runtime.v1.linux"]<br/>  shim_debug = true<br/>[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]<br/>  runtime_type = "io.containerd.runc.v2"<br/>[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]<br/>  runtime_type = "io.containerd.runsc.v1"<br/>EOF<br/><br/># Reload containerd<br/><br/>sudo systemctl restart containerd</span></pre><p id="ccae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 2。运行时类<br/> </strong> RuntimeClass是用于选择容器运行时配置的特性。容器运行时配置用于运行pod的容器。</p><p id="2996" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在不同的pod之间设置不同的RuntimeClass，以提供性能和安全性之间的平衡。例如，如果我们的部分工作负载需要高级别的信息安全保证，我们可能会选择调度这些pod，以便它们在使用硬件虚拟化的容器运行时中运行。然后，我们将受益于替代运行时的额外隔离，代价是一些额外的开销。</p><p id="9c1e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为<strong class="iz hj"> gVisor </strong>配置一个运行时类:</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="2493" class="ls ki hi lo b be lt lu l lv lw">apiVersion: node.k8s.io/v1<br/>kind: RuntimeClass<br/>metadata:<br/>  name: gvisor  # &lt;-- name can be anything<br/>handler: runsc  # &lt;-- gVisor uses 'runsc' named container runtime to create containers</span></pre><p id="5ecf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认的容器运行时是由OCI定义的'<strong class="iz hj"> runc </strong>'。<strong class="iz hj"> gVisor </strong>使用“<strong class="iz hj"> runsc </strong>”命名运行时，kata containers使用“<strong class="iz hj"> kata-runtime </strong>”命名运行时。</p><p id="9449" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 3。使用RuntimeClasses <br/> </strong>部署pod一旦为集群配置了RuntimeClasses，我们就可以在Pod的spec部分指定一个<code class="du lx ly lz lo b">runtimeClassName</code>来使用它。例如:</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="0d61" class="ls ki hi lo b be lt lu l lv lw">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  labels:<br/>    run: sandboxed<br/>  name: sandboxed<br/>spec:<br/>  runtimeClassName: gvisor   #&lt;--<br/>  containers:<br/>  - args:<br/>    - sleep<br/>    - "2000"<br/>    image: busybox<br/>    name: sandboxed</span></pre><p id="8a8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 4。验证</strong></p><p id="b696" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">● ' <strong class="iz hj"> exec </strong>'进入吊舱，运行'<strong class="iz hj"> dmesg </strong>'命令验证gVisor是否开始工作:</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="3224" class="ls ki hi lo b be lt lu l lv lw">&gt;&gt; kubectl exec -it sandboxed -- sh<br/><br/>--&gt; dmesg | grep gVisor<br/><br/>[   0.000000] Starting gVisor..　　#&lt;--</span></pre><p id="693c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">●' <strong class="iz hj"> exec </strong>进入吊舱，运行'<strong class="iz hj"> uname </strong>命令:</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="194a" class="ls ki hi lo b be lt lu l lv lw">&gt;&gt; kubectl exec -it sandboxed -- sh<br/><br/># run uname command<br/>--&gt; uname -sr<br/>Linux 4.4.0   #&lt;---</span></pre><p id="2fe0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后在pod正在运行的worker节点上运行'<strong class="iz hj"> uname </strong>'命令:</p><pre class="ju jv jw jx fd ln lo lp bn lq lr bi"><span id="09fe" class="ls ki hi lo b be lt lu l lv lw">&gt;&gt; ssh node01<br/>&gt;&gt; uname -sr<br/>Linux 5.4.0-131-generic  #&lt;---</span></pre><p id="f11d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所看到的，worker节点和容器的内核名称和内核发布版本是不同的。这意味着容器不是直接运行在worker节点上，而是被沙箱化了。</p><p id="d6cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解沙盒概念，您可以阅读以下资源:</p><div class="ma mb ez fb mc md"><a href="https://cloud.google.com/blog/products/identity-security/open-sourcing-gvisor-a-sandboxed-container-runtime" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">开源gVisor，一个沙盒容器运行时|谷歌云博客</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">Nicolas Lacasse软件工程师容器彻底改变了我们开发、打包和部署应用程序的方式…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">cloud.google.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jz md"/></div></div></a></div></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><blockquote class="mz na nb"><p id="fbf4" class="ix iy nc iz b ja jb ij jc jd je im jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated"><em class="hi">如果您觉得这篇文章很有帮助，请点击</em> <strong class="iz hj"> <em class="hi">跟随</em> </strong> <em class="hi">👉</em><strong class="iz hj"><em class="hi"/></strong><em class="hi"/><strong class="iz hj"><em class="hi">拍手</em> </strong> <em class="hi">👏</em> <strong class="iz hj"> <em class="hi"> </em> </strong> <em class="hi">按钮帮助我写更多这样的文章。<br/>谢谢🖤 </em></p></blockquote><h2 id="d4ce" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">🚀👉<strong class="ak">Kubernetes上的所有文章</strong></h2><div class="ma mb ez fb mc"><div role="button" tabindex="0" class="ab bv ff cb dy ng nh bn ni jz nj"><div class="nk l"><div class="ab q"><div class="l di"><img alt="Md Shamim" class="l de bw nl nm du" src="../Images/b46bdc53005abde6c6cb3e8ff0c200c3.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*Hqd8Xz1WHsoL1s2To3awnA.png"/><div class="dr bw l nl nm ds n aw dt"/></div><div class="gg l dw"><p class="bd b fp z dy dz ea eb ec ed ee ef dx translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" rel="noopener follow" target="_top" href="/@shamimice03?source=post_page-----b191dafdc8a2--------------------------------"> Md沙米姆</a></p></div></div><div class="np nq fg l"><h2 class="bd hj ta tb dy tc ea eb mj ed ef hh bi translated">关于Kubernetes的所有文章</h2></div><div class="ab q"><div class="l dw"><a class="bd b be z bi td au te tf tg qf th an fx fy ti tj tk gb gc gd de bk ge" rel="noopener follow" target="_top" href="/@shamimice03/list/all-articles-on-kubernetes-7ae1a0f96f3b?source=post_page-----b191dafdc8a2--------------------------------">View list</a></div><div class="tl l dw"><span class="bd b fp z dx">24 stories</span></div></div></div><div class="oc dh od dy ab oe dw di"><div class="di nu bv nv nw"><div class="dh l"><img alt="" class="dh" src="../Images/f1050aa27a3ef03122558b1ba1de1f58.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*7DhVxBWLKw_5M_jP"/></div></div><div class="di nu bv nx ny nz"><div class="dh l"><img alt="" class="dh" src="../Images/f1c4131e92176033bce05392de197205.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*AkrEbqlA_j76u2I5Tm8npg.png"/></div></div><div class="di bv oa ob nz"><div class="dh l"><img alt="" class="dh" src="../Images/27d4385154af67764cf37713dbbdc38e.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*98RmgcHgM1cyOobu"/></div></div></div></div></div></div></div>    
</body>
</html>
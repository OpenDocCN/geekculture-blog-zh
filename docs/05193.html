<html>
<head>
<title>Merge Sort, an explanation of it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">归并排序，对它的一个解释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/merge-sort-an-explanation-of-it-b7c76108fc9b?source=collection_archive---------3-----------------------#2021-07-14">https://medium.com/geekculture/merge-sort-an-explanation-of-it-b7c76108fc9b?source=collection_archive---------3-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7da3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是合并排序？它是如何工作的？实际的递归和我认为的递归。合并排序的一个例子。有什么优缺点？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ab9236be0c687d84ee255624769ad941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3M9GiBYYEMBsaDa"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/@_yashrjain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Yash Jain</a> on <a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cfe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我目前正在上柯尔特·斯蒂尔的Udemy class JavaScript算法和数据结构大师课。<a class="ae jt" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/js-algorithms-and-data-structures-master class/</a>，我会推荐给任何想学习更多关于Javascript中算法的人。其中一个主题是排序算法。特别是，我今天要讨论的是归并排序。</p><h1 id="6713" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是合并排序？</h1><p id="eb85" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">合并排序是一种排序算法。根据<a class="ae jt" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">维基百科</a>，它是约翰·冯·诺依曼早在1945年发明的。这是一个分治算法。<a class="ae jt" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分而治之</a>是一种算法设计模式，在这种模式下，你接受输入，并将其递归地分成子问题，直到它简单到足以解决。通过利用这种设计模式，与其他排序算法(如冒泡排序)相比，时间复杂度大大降低到O(n log n)。换句话说，对于大型数据集，它比简单的排序算法要快得多。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/1756463211547c859b84dd8328b752ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyMyVq62_k35_4fyA8m-wQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Visual reference of the Merge Sort Algorithm</figcaption></figure><h1 id="fa9a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="ad74" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在上图中，您可以看到算法如何工作的可视化表示。该算法接受一个输入，它可以是各种数据类型，但我们现在使用数组。然后，输入被递归分割，直到得到一组每个只包含1个元素的数组。一旦你到了这个阶段，你就可以应用你的排序逻辑了。在上面的例子中，由于我们处理的是整数，所以只是对array1和array 2的简单比较。然后，将排序后的数字合并到两个数字的合并数组中。接下来，继续递归排序和合并数组，直到只剩下一个排序后的数组。</p><h1 id="c2dc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">关于递归的一个旁注</h1><p id="c533" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以在开始Javascript算法和数据结构大师课之前。我以为我知道什么是递归。在某种程度上，我的看法是正确的。它是一个在函数内部调用自身的函数。我的典型递归函数是这样的:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="ce65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，真正的递归确实需要更少的代码行，但是从概念上来说更难理解。我在这里提到它的唯一原因是递归是合并排序的关键部分。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="2d7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不想在这里纠缠于细节，但是我想让你注意真正的递归是如何工作的。真正的循环利用调用堆栈并将返回值保存在内存中，直到满足返回条件，然后处理并返回值堆栈。请注意，在下面的gif中，调用堆栈先增长，然后收缩。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/07e0f2980ad51c03cc526b0cf6406796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/1*oneSKuDKmnuNTpl_2xEPsg.gif"/></div></figure><h1 id="a83f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">合并排序的示例和说明</h1><p id="110e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">好，现在来看一个实际的例子，并解释一下发生了什么。通常，当您使用合并排序时，会有一个巨大的数据集，但是我们将使用一个由四个随机整数组成的数组。</p><h2 id="6523" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">首先，我们需要一个助手函数。</h2><p id="2521" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">正如我前面提到的，合并排序的基础是先划分然后合并排序后的数组。所以我们需要一个辅助函数来合并所有这些数组。它不知道数组的长度。它只关心我们输入两个数组。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="3ac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在上面的辅助函数中，代码接受两个任意长度的数组，然后依次比较数组-1和数组-2的值。需要注意的一点是，为了让这个函数工作，我们的数组需要排序。这已经完成了，因为，如前所述，在执行该函数之前，我们已经将未排序的数组分解为每个数组中的单个元素。</p><h2 id="a2ab" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">现在是秘制酱料。</h2><p id="a5c0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如上所述，如果你对真正的递归不了解/不习惯，这个函数可能有点让人摸不着头脑。我会试着向你介绍正在发生的事情，希望对你来说更有意义。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="37bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，虽然只有6行代码，但是这里发生了很多事情。因此，希望下面的图表可以帮助解释正在发生的事情。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/3aa490b06e0c20a30faeb2ddf3660b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgdSKYKkcNme0gIiVL9Hww.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Diagram of Merge Sort Algorithm</figcaption></figure><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="4507" class="lb jv hi lr b fi lv lw l lx ly">if (arr.length &lt;= 1) return arr;</span></pre><p id="dd92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过调用<code class="du lz ma mb lr b">mergeSort([12,8,30,1])</code>来启动这个函数。第一行检查数组的长度。如果它小于或等于1，则返回arr。这是针对边缘情况和递归函数的返回条件。</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="5dd7" class="lb jv hi lr b fi lv lw l lx ly">let mid = Math.floor(arr.length/2);</span></pre><p id="cd65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们找到数组的中点。</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="d298" class="lb jv hi lr b fi lv lw l lx ly">let left = mergeSort(arr.slice(0,mid));</span></pre><p id="e4f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们第一次递归调用。它递归调用数组左侧的函数。由于它是递归的，所以它将被添加到调用堆栈中，并等待解决方案。</p><p id="f74d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在用两个左边的值调用<code class="du lz ma mb lr b">mergeSort([12,8])</code>。条件不满足，所以它将<code class="du lz ma mb lr b">[12]</code>设置为左值。再次调用函数，但是这次满足条件。所以返回的值是<code class="du lz ma mb lr b">[12]</code>。现在函数可以继续运行了，因为已经为<code class="du lz ma mb lr b">left</code>返回了一个值。所以下一个是对的，也就是<code class="du lz ma mb lr b">8</code>。它递归调用<code class="du lz ma mb lr b">mergeSort([8])</code>。并且满足条件，所以返回值8。然后因为有一个值为<code class="du lz ma mb lr b">right mergeArrays([12],[8])</code>被调用，它返回<code class="du lz ma mb lr b">[8,12]</code>。所以我们的调用栈可以被执行，因为现在我们有了所有递归调用的返回值。</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="adfa" class="lb jv hi lr b fi lv lw l lx ly">our initial mergeSort([12,8,30,1]) now has a value for left = [8,12]</span></pre><p id="1d03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，与递归过程一样，最初的mergeSort()调用可以移到右边的值上。<code class="du lz ma mb lr b">right = mergeSort([30,1])]</code>哪个递归调用mergeSort的条件不满足，所以左现在是<code class="du lz ma mb lr b">left = mergeSort([30])</code>。与前一次执行时不同，这一次满足条件，返回30。操作顺序中的下一步是<code class="du lz ma mb lr b">right = mergeSort([1])</code>再次调用mergeSort，但是条件立即被满足，所以<code class="du lz ma mb lr b">[1]</code>它被返回。现在我们已经为<code class="du lz ma mb lr b">left</code>和<code class="du lz ma mb lr b">right</code>取了一个值，并调用了<code class="du lz ma mb lr b">mergeArrays([30],[1])</code>。</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="4d5c" class="lb jv hi lr b fi lv lw l lx ly">mergeArrays([30],[1]) returns [1,30] which is a value for right of the original call of mergeSort</span></pre><p id="0997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望到现在为止，你还没有完全糊涂。概括地说，我们用<code class="du lz ma mb lr b">mergeSort([12,8,30,1])</code>初始化函数，左半部分定义在一个递归函数中，它执行自己的任务，直到返回值。现在已经为<code class="du lz ma mb lr b">left</code>返回了一个值，我们可以再次转移到<code class="du lz ma mb lr b">right</code>上，调用一个递归函数，直到返回一个值。有了<code class="du lz ma mb lr b">left</code>和<code class="du lz ma mb lr b">right</code>的值，我们就可以移动到原始<code class="du lz ma mb lr b">mergeSort()</code>的<code class="du lz ma mb lr b">return mergeArrays(left, right)</code></p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="1cfe" class="lb jv hi lr b fi lv lw l lx ly">return mergeArrays([8,12]),[1,30])</span></pre><p id="47ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为所有高阶函数都已返回，所以我们返回</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="b817" class="lb jv hi lr b fi lv lw l lx ly">results = [1,8,12,30]</span></pre><p id="d415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是归并排序的工作原理。我强烈建议将该算法插入一个设置断点的Chrome代码片段中，并探索在引擎盖下发生了什么。我甚至花了一些时间来理解实际的递归函数。</p><h1 id="d174" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">合并排序的优点和缺点</h1><p id="2388" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">归并排序的优势？对于大型数据集，它比简单的排序算法(如冒泡排序)要快得多。不像某些算法的时间复杂度最好、一般、最差都是O(n log n)。这又一次不同于冒泡排序，它相当一致。</p><p id="339d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">归并排序的弊端？它不像不太复杂的排序算法那样简单。假设您正在处理一个包含20个条目的数组。时间复杂度之间的差异将非常小。此外，不同于简单排序算法的空间复杂度是O(n)，其中冒泡排序的空间复杂度将是O(1)。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="0c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到这里，我对归并排序的解释就结束了。我们讨论了什么是合并排序，合并排序是如何工作的。实际的递归和我最初对递归的理解。合并排序的一个例子。最后，合并排序的优点和缺点。编码快乐！</p></div></div>    
</body>
</html>
<html>
<head>
<title>RDTSC the only way to benchmark.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RDTSC是唯一的基准。</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rdtsc-the-only-way-to-benchmark-fc84562ef734?source=collection_archive---------14-----------------------#2021-08-18">https://medium.com/geekculture/rdtsc-the-only-way-to-benchmark-fc84562ef734?source=collection_archive---------14-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8e98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在对那些只有几行指令的小函数进行基准测试，或者仅仅是那些在很短时间内完成执行的函数，那么获得精确基准测试的唯一方法就是使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Time_Stamp_Counter" rel="noopener ugc nofollow" target="_blank"> RDTSC </a>函数。</p><p id="82e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统上，当人们决定对代码段进行性能基准测试时，他们可能会选择一些不同分辨率的计时器，分辨率越低，基准测试运行的迭代次数就越多，以获得更好的近似值。</p><p id="bf97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统上，电脑都有一个第二分辨率跑马灯，使用<a class="ae jd" href="https://www.geeksforgeeks.org/time-function-in-c/" rel="noopener ugc nofollow" target="_blank">时间()</a>功能显示在<a class="ae jd" href="https://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html" rel="noopener ugc nofollow" target="_blank">时间. h </a>中。使用这个低精度计时器，我们可以做这样的事情:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/5b6c9ff7a3b58061314206c71a50278e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*w29jPSV1uAxDCJgwe1jEoQ.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">Executions in 3 seconds: 1,098,775,381<br/>Executions per millisecond: 366,258<br/>Executions per microsecond: 366<br/>~0.4 executions every nanosecond</figcaption></figure><p id="58ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将time(0)指定为sqrt()函数的输入，因为这将为sqrt()函数提供编译器无法预测的值，从而确保编译器不会以某种方式优化我们的while循环，导致我们的基准测试结果不再代表我们想要的结果。最后，我们还必须对我们的<em class="jq"> r </em>变量做一些事情，以防止编译器以不希望的方式优化我们的基准。我们用每次迭代的sqrt()输出递增一个变量，然后在最后将该变量打印到控制台。在我们的例子中，我们将“float r”转换为单个字符，并将其打印到控制台，以避免干扰控制台输出。</p><p id="6929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过将采样间隔从3秒增加到更高的值来使用上述函数提高结果的精度，或者我们可以通过使用timer.h <a class="ae jd" href="https://www.geeksforgeeks.org/clock-function-in-c-c/" rel="noopener ugc nofollow" target="_blank"> clock() </a>函数来获得更复杂的结果，该函数提供更高分辨率的计时器，从而在相同的3秒间隔内产生更精确的结果。</p><p id="e9b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在windows上，作为win32 API的一部分，你有<a class="ae jd" href="https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter" rel="noopener ugc nofollow" target="_blank">QueryPerformanceCounter()</a>，它精确到不到一微秒，尽管据我所知，当调用这个函数时，你必须将它锁定到单个CPU内核，否则操作系统级上下文切换会混淆结果。这可以通过使用<a class="ae jd" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask" rel="noopener ugc nofollow" target="_blank">SetThreadAffinityMask()</a>函数在已经被设置为单个CPU内核的相似性的线程中调用QueryPerformanceCounter来完成。</p><p id="6b63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，windows有两个毫秒分辨率的计时器，它们是流行的<a class="ae jd" href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount" rel="noopener ugc nofollow" target="_blank"> GetTickCount() </a>和WinMM函数<a class="ae jd" href="https://docs.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timegettime" rel="noopener ugc nofollow" target="_blank"> timeGetTime() </a>，精度更高，达到5毫秒或更高。虽然它们是毫秒计时器，但实际精度可能不到一毫秒。</p><p id="a499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们已经讨论了大多数操作系统time()和clock()上可用的低精度和高精度定时器，以及特定于windows的定时器。虽然它们是足够的，但是它们需要更大的样本量来弥补定时功能所损失的精度。</p><p id="e911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的解决方案当然是使用RDTSC函数，它计算CPU时钟周期的滴答数；这意味着，对于RDTSC记录的每一个滴答，CPU都进行了一次迭代或一个周期。平均而言，截至2021年，现代CPU的工作频率约为4.2 GHz，这意味着它每秒执行42亿次循环。</p><p id="81dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管每次调用RDTSC函数都会返回不同的结果，但是在我们得出一个稳定的平均值之前，这个函数也需要被多次采样。对于运行在4.2 GHz的英特尔处理器，我发现3，000，000个样本足以获得稳定的平均值。</p><p id="caa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用RDTSC定时器只需要包含<a class="ae jd" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#" rel="noopener ugc nofollow" target="_blank"> x86intrin.h </a>就可以使用<a class="ae jd" href="https://docs.microsoft.com/en-us/cpp/intrinsics/rdtsc" rel="noopener ugc nofollow" target="_blank"> __rdtsc() </a>函数。<a class="ae jd" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=rdtsc&amp;expand=5578" rel="noopener ugc nofollow" target="_blank">尽管英特尔喜欢宣称并非如此。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/279079a5ea5e9ad4dfd7028220674eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*7t8zsAwsNUbioDNe_jtmjA.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">You can also just call the instruction directly grabbing only its lower 32 bits.</figcaption></figure><p id="8515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们的高精度RDTSC实现在sqrt()函数上的样子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es js"><img src="../Images/4c4204e74821f3f8ae01fd0d8ddf0f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*KoINNH3XNkk2Ou2gPqPh9w.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">sqrt() Cycles: 17</figcaption></figure><p id="6062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在实际的CPU周期中为我们提供了一个非常精确的基准，即单个函数平均需要多长时间。我们也可以像这样输出平均值旁边的最高值和最低值；</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jt"><img src="../Images/b0f0e9d8b70cc2f44638245cc640cee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*qAPOJEMXYpVRML6mFy5r-Q.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">sqrt() Min Cycles: 12<br/>sqrt() Max Cycles: 7,709<br/>sqrt() Avg Cycles: 17</figcaption></figure><p id="a82e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，将所有这些放在一个大型高精度测试中，该测试与一些<a class="ae jd" href="https://en.wikipedia.org/wiki/C_mathematical_functions" rel="noopener ugc nofollow" target="_blank"> math.h </a>函数相关:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="5fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该能够使用任何优化标志(如-Ofast)来编译它，并且它不会破坏预期的结果。如果你想看这篇文章中包含的其他代码片段，请参考<a class="ae jd" href="https://gist.github.com/mrbid/31e295c5db2339820dde44571fb98596" rel="noopener ugc nofollow" target="_blank">的扩展版本。</a></p><p id="182e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诚然，您的基准测试将包括调用__rdtsc()函数的延迟，但这是一个较小的错误，我个人认为不值得尝试计算__rdtsc()调用的平均延迟以从最终平均值中减去。</p><p id="2217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能也有兴趣看看我在<a class="ae jd" href="https://github.com/TFCNN/DOCS/tree/main/MAC%20Bench" rel="noopener ugc nofollow" target="_blank">乘-累加运算</a>上做的基准测试。</p><p id="838b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://godbolt.org/是一个有用的工具，它输出你的C或C++代码的编译汇编指令。否则，您可以将-S标志传递给GCC编译器，或者对编译后的二进制文件使用objdump -d。</p><pre class="jf jg jh ji fd jw jx jy jz aw ka bi"><span id="7e72" class="kb kc hi jx b fi kd ke l kf kg">gcc bench.c -Ofast -lm -o bin<br/>gcc -S bench.c -Ofast -lm -o bin.asm<br/>objdump -d bin &gt; objdump_bin.asm</span></pre><p id="3a42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自从写了这篇文章，我发现在Windows上使用</strong><a class="ae jd" href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtime" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">getsystem time()</strong></a><strong class="ih hj">函数也是一个流行的选项:</strong><br/><a class="ae jd" href="https://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/10905892/equivalent-of-gettimeday-for-Windows</a></p><p id="92a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">英特尔，《如何对代码执行时间进行基准测试》，2010年</strong><br/><a class="ae jd" href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf" rel="noopener ugc nofollow" target="_blank">https://www . Intel . com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-Benchmark-Code-Execution-paper . pdf</a></p></div></div>    
</body>
</html>
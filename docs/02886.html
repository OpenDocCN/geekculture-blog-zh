<html>
<head>
<title>C++ Inheritance Memory Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++继承内存模型</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/c-inheritance-memory-model-eac9eb9c56b5?source=collection_archive---------12-----------------------#2021-05-27">https://medium.com/geekculture/c-inheritance-memory-model-eac9eb9c56b5?source=collection_archive---------12-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a00a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将深入探讨C++继承在内存中的样子以及多态在幕后是如何工作的。这不是一篇关于继承的最佳实践和动机的文章，而是关于C++如何制造如此强大和快速的继承工具。</p><p id="4e3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说单继承。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="a00e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">派生类继承了Base的所有成员变量和函数，对象内存如下所示</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jk"><img src="../Images/d70fc864325e281c14d7261969e115cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWEjnqGaiSjcglnaRH4Zew.png"/></div></div></figure><p id="2b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始时，派生对象看起来与内存中的基本对象相似，但是后来有了一些额外的东西，如<code class="du jr js jt ju b">int b</code>。</p><p id="6e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能还想知道所有的函数都存储在内存的什么地方。所有的函数指令都一次性存储在内存中的一个特殊位置，而不是针对每个对象。当东西被编译时，那些函数调用会指向函数指令的位置。</p><h2 id="aea2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">如何覆盖一个函数</h2><p id="3736" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">继承的下一个重要部分是派生类重写基类中定义的函数的能力。为此，C++让我们将函数虚拟化。当一个函数是虚拟的，它就在虚拟表上(vtable)。vtable存储所有虚函数的函数指针。每个类都有一个vtable，该类的所有对象都有一个指向它的vtable指针。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kv"><img src="../Images/79314ac0cac5d2c39fb65de5d0237b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZsrtwiROr23wMcwTETorg.png"/></div></div></figure><p id="41ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基类的函数指针的顺序与派生类的顺序相同。但是，基本虚拟表的<code class="du jr js jt ju b">bar1</code>函数指针指向<code class="du jr js jt ju b">Base::bar1</code>，派生虚拟表的<code class="du jr js jt ju b">bar1</code>函数指针指向<code class="du jr js jt ju b">Derived::bar1</code>。在基类的虚函数之后，派生的vtable还将包含它创建的所有其他虚函数。</p><p id="d154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对像<code class="du jr js jt ju b">d_ptr-&gt;bar()</code>这样的虚函数的调用相当于<code class="du jr js jt ju b">*((d_ptr-&gt;vtable_ptr)[0])(d_ptr)</code>。您实际上没有访问vtable_ptr的权限，所以这种等价是理论上的。</p><ol class=""><li id="a7a8" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><code class="du jr js jt ju b">d_ptr-&gt;vtable_ptr</code>获取指向函数指针数组的vtable_ptr。</li><li id="bc32" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du jr js jt ju b">(d_ptr-&gt;vtable_ptr)[0]</code>是派生vtable的第一个元素，它为我们提供了一个指向<code class="du jr js jt ju b">Derived::bar1</code>的函数指针。</li><li id="82a9" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du jr js jt ju b">*((d_ptr-&gt;vtable_ptr)[0])</code>是解引用的函数指针。</li><li id="d9cd" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du jr js jt ju b">*((d_ptr-&gt;vtable_ptr)[0])(d_ptr)</code>正在调用<code class="du jr js jt ju b">Derived::bar1</code>并传入对调用它的对象的引用。编译器总是隐式地将“this”指针传递给成员函数。</li></ol><p id="4e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚函数在运行时在对象的vtable上查找。因此，与编译时标记的常规函数不同，虚函数将在运行时在vtable上查找函数，并运行vtable条目指向的任何函数。这是C++中支持多态性的强大工具。<strong class="ih hj">多态性</strong>是指你在运行时决定某些东西的功能。可以有一个指向对象调用<code class="du jr js jt ju b">bar1</code>的指针，但是实际调用的<code class="du jr js jt ju b">bar1</code>版本取决于对象。这就是为什么功能只在运行时确定。</p><h2 id="75ac" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">怎么可以设置b_ptr = &amp;d？</h2><p id="c9d7" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为什么基指针可以指向派生对象？让我们首先回答为什么这应该是真的，然后我们将得到如何C++内存对齐允许这一点。</p><p id="01dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有派生对象都是基对象，但不是所有基对象都是派生对象。所以如果你有一个基指针，你只需要调用在基类中声明的函数。因为Derived从Base继承了所有的函数和变量，所以派生的对象可以访问Base调用的所有函数，所以这是一个需要的特性。</p><p id="8b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现这一点，虚函数和变量的顺序需要在基本对象和派生对象中保持一致。当一个基址指针指向一个派生的对象时，它只看到它的基址部分。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lk"><img src="../Images/c4574e5396771f5677490b5218d999a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuDmkUd1Ffl5fK8wXkNgqw.png"/></div></div></figure><p id="015a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">红框表示基指针从派生对象中看到的内容。<code class="du jr js jt ju b">b_ptr</code>见<em class="ll">底座</em>视图<em class="ll">视图</em>。派生的对象看起来和上面的Base一样，然后它在下面创建了更多的东西，但是这些对<code class="du jr js jt ju b">b_ptr</code>来说无关紧要，因为它没有查看Base视图。</p><p id="b90e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住<code class="du jr js jt ju b">b_ptr-&gt;bar1()</code>翻译成<code class="du jr js jt ju b">*((b_ptr-&gt;vtable_ptr)[0])(d_ptr)</code>，它调用vtable上的第一个函数指针。不管底层对象是派生的还是基的，vtable上的第一个条目都是某个版本的<code class="du jr js jt ju b">bar1</code>。因为变量和函数指针的内存布局对于Base和Derived的开始是相同的，<code class="du jr js jt ju b">b_ptr</code>能够毫无问题地指向一个派生对象并调用虚函数<code class="du jr js jt ju b">bar1</code>。</p><h2 id="3b2f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">多重遗传</h2><p id="7bea" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">当你有一个继承自多个基类的派生类时，内存就变得有点棘手了。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="e83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要对内存进行布局，以便<code class="du jr js jt ju b">b1_ptr</code>只能访问Base1接口，而<code class="du jr js jt ju b">b2_ptr</code>只能访问Base2接口。为此，我们拆分了虚拟表。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lk"><img src="../Images/aa3ff1a7dc1d768e748e07f66daee5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3plg9eZsKJ3Gi98hvcHVMg.png"/></div></div></figure><p id="3136" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个vtable包括Base1的虚函数和Derived的虚函数。派生对象中的下一个东西是Base1的所有字段。接下来是vtable_ptr2，它指向Base2中的所有虚函数。然后是所有Base2字段，后面是派生字段。</p><p id="b78f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们拆分vtables的原因是为了让<code class="du jr js jt ju b">b1_ptr</code>可以有一个合适的Base1视图，而<code class="du jr js jt ju b">b2_ptr</code>可以有一个合适的Base2视图。我们不能将Base2的虚函数放在第一个虚拟表中，因为<code class="du jr js jt ju b">foo2</code>需要是虚拟表中的第一个东西才能获得有效的Base2视图，但是<code class="du jr js jt ju b">foo1</code>已经是第一个虚拟表中的第一个东西了。因此，我们需要两个虚拟表来支持这两种视图。</p><p id="5ced" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，<code class="du jr js jt ju b">b2_ptr</code>指向的地址实际上比<code class="du jr js jt ju b">b1_ptr</code>指向的地址更大。其实，<code class="du jr js jt ju b">b1_ptr+sizeof(Base1)</code> = <code class="du jr js jt ju b">b2_ptr</code>。编译器会为你处理指针调整，所以不用担心。<code class="du jr js jt ju b">d_ptr</code> = <code class="du jr js jt ju b">b2_ptr</code>也一样，但是<code class="du jr js jt ju b">d_ptr</code>拥有整个派生对象的视图。</p><h2 id="7d7d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">表演</h2><p id="f0d1" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">虚函数比常规函数稍微贵一点，所以如果你想做一个超低延迟的程序，这一节很重要。调用一个虚函数需要解引用vtable指针，这是一个常规函数不需要做的额外查找。</p><p id="48d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一件事是，像内联这样的编译器优化不能在虚函数上运行。内联是指将函数代码复制并粘贴到调用函数的地方，这样可以避免创建堆栈框架、将参数压入堆栈等。这不能用虚函数来实现，因为正在运行的函数只能在运行时确定。这些都是非常小的性能冲击，但值得了解。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Software Design Pattern #2: Abstract Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式#2:抽象工厂</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/software-design-pattern-2-abstract-factory-1700fefa700d?source=collection_archive---------17-----------------------#2021-09-21">https://medium.com/geekculture/software-design-pattern-2-abstract-factory-1700fefa700d?source=collection_archive---------17-----------------------#2021-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式是可重用的模板，帮助我们使用最佳实践解决软件设计问题。这样，它们允许我们使用更易于维护、理解和测试的代码来构建应用程序。</p><h1 id="1bca" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">逃离速度实验室</h1><p id="595a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以在我们的网站上找到我们所有的文章、课程和教程:<br/><a class="ae kg" href="https://www.evlabs.io" rel="noopener ugc nofollow" target="_blank">https://www . ev labs . io</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/4405f11f7bf473f61378968e20beca00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNOHvw3zIESmQzOqe4l0UQ.jpeg"/></div></div></figure><h1 id="2521" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这个图案是用来做什么的？</h1><blockquote class="kt ku kv"><p id="de3a" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated">它提供了一个接口来创建相关或依赖对象的系列，而无需指定它们的具体类。</p></blockquote><p id="9f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设我们想要为iOS创建一个应用程序。iPhone有两个不同的视觉方面:<strong class="ih hj">亮模式</strong>和<strong class="ih hj">暗模式</strong>。如果用户使用光模式，我们将不得不显示光视觉组件(按钮，导航栏等)，如果他们使用暗模式，暗组件。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es la"><img src="../Images/8cb881de64fc6148ad423d0caf991521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*9K1F4SMo028UyfjvrzwF8Q.png"/></div></figure><p id="cc43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这意味着，每当我们在代码中创建一个可视元素时，我们都必须检查正在使用的可视模式，并选择正确的组件。这产生了三个问题:</p><ul class=""><li id="fc03" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">如果引入第三种视觉模式，我们将不得不在创建组件的所有位置更改代码。</li><li id="e254" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">我们将应用程序逻辑与描述如何创建可视组件的逻辑混合在一起。</li><li id="d9f6" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">例如，我们可能会不小心把浅色的按钮和深色的导航条混在一起。</li></ul><p id="b42c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用<strong class="ih hj">抽象工厂</strong>模式，我们将确保应用程序代码与可视组件的代码保持分离。也就是说，应用程序将简单地创建一个<strong class="ih hj">按钮</strong>或一个<strong class="ih hj">导航栏</strong>，工厂将根据所使用的视觉模式生产相应的组件。另一方面，使用的工厂将只生产一个视觉方面的元素，阻止我们混合它们。最后，如果出现第三种视觉模式，我们只需要更改代码行，在那里选择合适的工厂。</p><h1 id="a1fb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的？</h1><p id="df3d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">下图描述了所涉及的类别:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lp"><img src="../Images/2f3ef7201cc715f5f1b0c816e3518318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*MIM01WO-vpRVMr5GNLccZg.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx">Diagram of the Abstract factory pattern</figcaption></figure><p id="64ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序将使用一个组件工厂，它将负责生成适当的按钮和导航栏，而应用程序不必担心细节。<br/>为了实现这一点，我们创建了三个抽象类，它们是应用程序将与之联系的类，而不是它们的具体实现:</p><pre class="ki kj kk kl fd lu lv lw lx aw ly bi"><span id="bb19" class="lz je hi lv b fi ma mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">ComponentFactory</strong>(ABC):<br/>    @abstractmethod<br/>    <strong class="lv hj">def</strong> create_button(self):<br/>        <strong class="lv hj">pass</strong>    </span><span id="5519" class="lz je hi lv b fi me mb l mc md">    @abstractmethod<br/>    <strong class="lv hj">def</strong> create_navbar(self):<br/>        <strong class="lv hj">pass</strong></span><span id="1c32" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">Button</strong>(ABC):<br/>    @abstractmethod<br/>    <strong class="lv hj">def</strong> render(self):<br/>        <strong class="lv hj">pass</strong></span><span id="d537" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">Navbar</strong>(ABC):<br/>    @abstractmethod<br/>    <strong class="lv hj">def</strong> render(self):<br/>        <strong class="lv hj">pass</strong></span></pre><p id="1caf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工厂是一个可以创建某个家族的对象的类。抽象工厂是创建工厂的模板。由于我们的抽象工厂(ComponentFactory ),我们将能够创建两个不同的工厂，一个生产亮主题的元素，另一个生产暗主题的元素。</p><pre class="ki kj kk kl fd lu lv lw lx aw ly bi"><span id="bcfa" class="lz je hi lv b fi ma mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">LightThemeFactory</strong>(ComponentFactory):<br/>    <strong class="lv hj">def</strong> create_button(self):<br/>        <strong class="lv hj">return</strong> LightButton()    </span><span id="af90" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">    def</strong> create_navbar(self):<br/>        <strong class="lv hj">return</strong> LightNavbar()</span><span id="d05c" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">LightButton</strong>(Button):<br/>    <strong class="lv hj">def</strong> render(self):<br/>        <strong class="lv hj">...</strong></span><span id="ce83" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">LightNavbar</strong>(Navbar):<br/>    <strong class="lv hj">def</strong> render(self):<br/>        ...</span><span id="43ee" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">DarkThemeFactory</strong>(ComponentFactory):<br/>    <strong class="lv hj">def</strong> create_button(self):<br/>        <strong class="lv hj">return</strong> DarkButton()</span><span id="de53" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">def</strong> create_navbar(self):<br/>        <strong class="lv hj">return</strong> DarkNavbar()</span><span id="abc3" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">DarkButton</strong>(Button):<br/>    <strong class="lv hj">def</strong> render(self):<br/>        <strong class="lv hj">...</strong></span><span id="f68c" class="lz je hi lv b fi me mb l mc md"><strong class="lv hj">class</strong> <strong class="lv hj">DarkNavbar</strong>(Navbar):<br/>    <strong class="lv hj">def</strong> render(self):<br/>        ...</span></pre><p id="ad69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，两家工厂都能够创建特定类型的按钮和导航栏，它们扩展了抽象类<strong class="ih hj"> Button </strong>和<strong class="ih hj"> Navbar </strong>。<br/>这样，在启动应用程序时，我们只需创建适当的工厂:</p><pre class="ki kj kk kl fd lu lv lw lx aw ly bi"><span id="26e5" class="lz je hi lv b fi ma mb l mc md"><strong class="lv hj">if</strong> theme == "dark":<br/>    component_factory = DarkThemeFactory()<br/><strong class="lv hj">elif</strong> theme == "light":<br/>    component_factory = LightThemeFactory()<br/><strong class="lv hj">else</strong>:<br/>    <strong class="lv hj">raise</strong> <strong class="lv hj">NotImplementedError</strong>(f"This visual mode doesn't exist")</span></pre><p id="87be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建组件，我们只需:</p><pre class="ki kj kk kl fd lu lv lw lx aw ly bi"><span id="038e" class="lz je hi lv b fi ma mb l mc md">button = componentfactory.create_button()<br/>navbar = componentfactory.create_navbar()</span></pre><h1 id="838d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">利益</h1><ul class=""><li id="ccfb" class="lb lc hi ih b ii kb im kc iq mf iu mg iy mh jc lg lh li lj bi translated">应用程序不关心组件细节。</li><li id="6887" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">它将对象的创建封装在一个类(工厂)中，而不是直接创建它们。</li><li id="f845" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">在应用程序执行时，只需更改几行代码就可以更改工厂。</li><li id="f647" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">该应用程序可以独立于其视觉外观进行测试。</li></ul></div></div>    
</body>
</html>
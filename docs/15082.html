<html>
<head>
<title>Comprehend TSVECTOR and TSQUERY in Postgres for Full-Text Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Postgres中用于全文搜索的TSVECTOR和TSQUERY</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/comprehend-tsvector-and-tsquery-in-postgres-for-full-text-search-1fd4323409fc?source=collection_archive---------2-----------------------#2022-10-12">https://medium.com/geekculture/comprehend-tsvector-and-tsquery-in-postgres-for-full-text-search-1fd4323409fc?source=collection_archive---------2-----------------------#2022-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b398" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">简介:</h1><p id="30b4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">全文搜索搜索与查询匹配的文档，并且可以根据记录与查询的相关性对记录进行排序。在全文搜索系统中，文档(如杂志文章、电子邮件或数据库表)充当搜索单元。最常见的搜索类型是按照与查询相似性的顺序返回包含查询词的所有文档。查询和相似性的概念非常灵活，并且根据应用程序的不同而不同。最基本的搜索将查询视为一组单词，并根据它们在文档中出现的频率进行比较。这是Google、Firefox等网络搜索引擎使用的一种技术。</p><p id="3887" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">文本搜索引擎必须能够解析文档并将词位(关键字)链接到父文档。然后，这些关联被用来查找包含查询词的文档。你可能听说过SQL数据库中的‘I like’和‘like’操作符，它们用于搜索文本。“like”和“ilike”运算符执行全文搜索分析任务的能力是有限的。</p><p id="db13" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">问题与喜欢</strong> <strong class="jf hj">运算符:</strong></p><ol class=""><li id="4f59" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">like运算符搜索精确单词，但不能搜索单词变体。例如，如果您在某个文档中搜索单词“produce”，而该文档中的一些记录只包含单词“producing”，则查询将不会返回这些记录。当搜索任何形式的单词时，必须为每个变体显式包含like子句，如果需要查找大量单词，这可能会很耗时。</li><li id="2f14" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">Like运算符不会返回与查询条件匹配的文档的排名。例如，如果查询词在多个文档中出现不止一次，则查询词出现次数最多的文档比出现次数最少的文档更重要。like运算符不提供多个文档之间的相对排名。</li><li id="d064" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">like操作符在处理大型文档时速度非常慢，导致性能低下。</li></ol><p id="e06c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我们使用“ilike”操作符时，我们在“like”操作符上遇到的问题仍然存在。唯一的区别是‘I like’不区分大小写。</p><h1 id="0d3d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">PostgreSQL中的全文搜索:tsvector和tsquery</h1><p id="8892" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">PostgreSQL提供了两种数据类型tsvector和tsquery来帮助进行全文搜索，因为“like”和“ilike”运算符在执行全文搜索分析任务的能力方面受到限制。TS代表tsvector和tsquery中的文本搜索。tsvector类型用于表示可搜索文本的文档，而tsquery类型用于表示文本查询格式的文本查询。在Postgresql中，两者都用于执行全文搜索。tsvector是单个词位的有序集合，这些词位是标准化的词，包括同一词的多个变体。</p><p id="b6b4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将深入研究to_tsvector()和to_tsquery()函数，它们分别返回tsvector和tsquery数据类型。</p><p id="7e06" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在Postgres中，使用以下语法创建一个表，并向其中添加4条记录。这是代码:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5a7c" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">create table document_text(file_id int, content text, description text);</strong></span><span id="a62b" class="ld ig hi kz b fi li lf l lg lh"><strong class="kz hj">insert into document_text values</strong>(1, 'The stock exchange predicts a bull market which would make many investors happy, but analysts warn of possibility of too much optimism and that in fact we are awaiting a bear market. As always predicting the future market is an uncertain game and all investors should follow their instincts and best practices.','Impact of bull market on investors'<strong class="kz hj">);</strong></span><span id="ba97" class="ld ig hi kz b fi li lf l lg lh"><strong class="kz hj">insert into document_text values</strong>(2, 'A bull market is one in which the market is rising and the economy is doing well, whereas a bear market is one in which the economy is collapsing and most equities are losing value. Although some investors are "bearish," the vast majority of investors are "bullish." Over lengthy time periods, the stock market has generally produced positive returns.','Market: positive and  negative sentiments'<strong class="kz hj">);</strong></span><span id="6ddf" class="ld ig hi kz b fi li lf l lg lh"><strong class="kz hj">insert into document_text values</strong>(3, 'During a bear market, market sentiment is negative, and investors begin to shift their money away from stocks and into fixed-income instruments as they wait for the stock market to recover. To summarise, the drop in stock market values has shaken investor confidence. As a result, investors keep their money out of the market, causing a general price decrease as outflow grows.','Bull and bear market'<strong class="kz hj">);</strong></span><span id="04c0" class="ld ig hi kz b fi li lf l lg lh"><strong class="kz hj">insert into document_text values(</strong>4, ' the decrease in stock market values has shaken investor confidence, As they would have predicted that the market will fall more.  This causes investors to keep their money out of the market, causing a general price decrease as outflow grows. In bear market, value of stocks falls while in bull market the value of stocks falls. However the market has been producing the positive result over length periods.','Impact of price decrease in market'<strong class="kz hj">);</strong></span></pre><p id="cd12" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该表如下所示:</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/44b6cd6180ac69ab6fd82698dda573d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*21g76VzwnK0AgecC.JPG"/></div></div></figure><h1 id="9174" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.如何使用to_tsvector()？</h1><p id="6b03" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> to_tsvector() </strong>是Postgres的内部函数，返回作为参数传递的文本或文档的tsvector，可用于执行高效的文本搜索。tsvector是键-值对的有序集合，其中键代表词位，值代表词位的位置。词位是词的规范化表示。tsvector中没有停用词，如“h as”、“in”或“as”，词位按字母顺序排序。</p><p id="845e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如，在下面的查询中，置信度被转换为“confid”词位，位于位置10。词位“市场”出现了两次，分别在位置5和15，因此后面跟着两个数字。</p><p id="c394" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询:</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6f9c" class="ld ig hi kz b fi le lf l lg lh">select to_tsvector('The decline in stock market values has shaken investor confidence, as they expected the market to fall further.');</span></pre><p id="cadf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lr"><img src="../Images/4170e012e92515d9ab21be534bdae031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TPQabo3iPe8v8tES.JPG"/></div></div></figure><h1 id="25b0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.如何使用to_tsquery()？</h1><p id="e72b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> to_tsquery() </strong>返回文本(或文档)中搜索模式的tsquery。每个单词的规范化词位表示与单词本身略有不同；例如，信心已经被转化为“confid”词。在不使用to_tsquery()函数的情况下搜索confidence将返回false，因为Postgres在内部将单词“confidence”转换为tsquery数据类型，这将返回“confidence”，而ts向量中不存在“confidence”。</p><p id="1ec2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询1: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="33e8" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">select to_tsvector('The decline in stock market values has shaken investor confidence, as they expected the market to fall further.') @@ 'confidence';</strong></span></pre><p id="2162" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出1: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ls"><img src="../Images/35058302cb843fed8184a6c55eb1766e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3VObepugcEpRUMe.JPG"/></div></div></figure><p id="666e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">tsquery typecast与to_tsquery()函数的区别:</strong></p><p id="a323" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如以下查询所示，类型转换为tsquery数据类型不会在Postgres中产生准确的结果。当我们在单词confidence上使用cast操作符(::)时，我们得到单词“confidence”。相反，置信度的规范化表示“confid”由to_tsquery()返回。如果PostgreSQL函数可用，您应该始终使用它们进行转换，而不是使用转换运算符。cast运算符也会导致查询性能下降。</p><p id="c542" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询2: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9102" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">select 'confidence'::tsquery, to_tsquery('confidence');</strong></span></pre><p id="1a45" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出2: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lt"><img src="../Images/cf1625f358fe49154f25404162e099aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yf2GZGRkQuDTYMmM.JPG"/></div></div></figure><p id="e854" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">如果我们在‘confidence’周围使用to_tsquery()，那么它将返回true。</strong></p><p id="d8bf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询三:</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2d50" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">select to_tsvector('The decline in stock market values has shaken    investor confidence, as they expected the market to fall further.') @@ to_tsquery('confidence');</strong></span></pre><p id="d614" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出3: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lu"><img src="../Images/9a77a720df1d630062d519bb416a631c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bGpUet69j1Ha9oQU.JPG"/></div></div></figure><p id="3f2f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">to_tsquery()可用于使用布尔运算符(如and、or和not)对多个单词进行查询。我们将在上面创建的表document_text上逐个看到它们。</p><p id="f700" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> 2.1。带有And( &amp;)运算符的to _ ts query:</strong></p><p id="a9e8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由' &amp; '分隔的多个单词可以作为参数传递给to_tsquery()函数，以匹配文档中的所有单词。下面的查询查找内容字段以任何形式和任何顺序包含所有单词“confidence”、“investors”和“prediction”的记录。返回file_id为4的记录，因为它包含查询中给出的所有三个词:confidence、investors和predicted。</p><p id="c26b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询4: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6053" class="ld ig hi kz b fi le lf l lg lh">select file_id, content from document_text where to_tsvector(content) @@<strong class="kz hj"> to_tsquery('confidence &amp; prediction &amp; investors');</strong></span></pre><p id="29e3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出4: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lv"><img src="../Images/89655d03b9f31149340978acee4a79f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kwFgQ3Yrq4qbH_vq.JPG"/></div></div></figure><p id="175e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> 2.2用Or(|)运算符的to _ ts query:</strong></p><p id="d8e1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由<strong class="jf hj">或运算符(' |') </strong>分隔的多个单词可以作为参数传递给to_tsquery()函数，以匹配文档中的任何一个单词。以下搜索在内容字段中以任意顺序查找包含“negative”和/或“economy”的记录。文件id为2和3的记录满足指定的标准，因此出现在输出中。</p><p id="aa44" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询5: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="cb63" class="ld ig hi kz b fi le lf l lg lh">select file_id, content from document_text where to_tsvector(content) @@ <strong class="kz hj">to_tsquery('negative | economy');</strong></span></pre><p id="3ba0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出5: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/3490fc6d2c0372f22ba50f8eb0c651c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vvxo7MYqAPWW-7Vy.JPG"/></div></div></figure><p id="3258" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> 2.3。to_tsquery() with Not(！)操作员:</strong></p><p id="e428" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要查找不包含指定单词的记录，请使用<strong class="jf hj"> NOT运算符('！').</strong> <strong class="jf hj">不是(！)</strong>是一元运算符，因此出现在单词之前。以下查询查找内容字段不以任何顺序包含单词“bear”的记录。只有文件id为4的记录不包含单词“bear ”,因此出现在输出中。</p><p id="c090" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询6: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a420" class="ld ig hi kz b fi le lf l lg lh">select file_id, content from document_text where to_tsvector(content) <strong class="kz hj">@@ to_tsquery('!bear');</strong></span></pre><p id="d0cc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出6: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/cc670b21a862c5d87d3992c85291da49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*va6R-Q_pG6SczUv8.JPG"/></div></div></figure><p id="778f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> 2.4。</strong> <strong class="jf hj"> to_tsquery()带有多个布尔运算符:</strong></p><p id="43a3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">大多数时候，我们都在寻找包含特定单词组合的记录，其中一些必须出现，而另一些不应该出现。这可以通过在单个tsquery中组合多个布尔运算符来实现。例如，要查找包含单词' predict '但不包含' bear '的记录，或者包含单词' instrument '的记录，我们可以通过'<strong class="jf hj"> (predict &amp;！bear)| instrument' </strong>里面的to_tsquery()函数。返回file_id为3和4的记录，因为单词“instrument”出现在file_id为3的记录中，单词“predict”而不是“bear”出现在file_id为4的记录中。</p><p id="cd76" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询7: </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f96c" class="ld ig hi kz b fi le lf l lg lh">select file_id, content from document_text where to_tsvector(content) @@ <strong class="kz hj">to_tsquery('(!bear &amp; predict)| instruments');</strong></span></pre><p id="94c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出7: </strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/f80c320d9d0de327f5de73f39f6f8c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w1rVF_K8vp7xYo6V.JPG"/></div></div></figure><h1 id="d4c7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">优化快速文本搜索:</h1><p id="0032" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">大型数据集的全文搜索速度较慢。为了提高全文搜索的性能，Postgres提供了在tsvector字段上建立索引的选项，这样可以更快地执行查询。您可以在表格上创建索引，以加快和优化对较大文档的文本搜索。GIN是最常用的全文搜索索引。Postgres文档建议了两种方法:一种是直接在索引中创建to_tsvector()字段，另一种是首先使用to_tsvector()在表中创建另一个tsvector列，然后在这个字段上创建一个gin索引。</p><p id="6726" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将遵循第二种方法来创建索引。我们还可以使用concatenate操作符在to_tsvector()中指定多个列。在创建GIN索引之前，我们将修改该表，在名为tsvector_content_desc的字段内容和描述中包含一个tsvector字段。我们对内容和描述使用了coalesce()函数，如果包含空值，就用空字符串替换它们。</p><p id="d7e1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">添加列的查询:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="54b1" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">alter table document_text <br/>       add column tsvector_content_desc  tsvector <br/>       GENERATED ALWAYS AS (to_tsvector('english', coalesce(content, '') || ' ' || coalesce(description, ''))) <br/>       STORED;</strong></span></pre><p id="b538" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ly"><img src="../Images/a2d23ce028a2aecdfaacb7c3e915fd8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XgIDLvBKRTXKy1XN.JPG"/></div></div></figure><p id="4450" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询创建索引:</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d469" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">CREATE INDEX textsearch_idx ON document_text USING GIN (tsvector_content_desc);</strong></span></pre><p id="b051" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lz"><img src="../Images/97a5a1994684deb0b922aa1296a13ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKMfBLE3PDpA2XDV.JPG"/></div></div></figure><p id="2918" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们可以使用tsvector_content_desc字段在以下查询中执行文本搜索。您可以注意到这个查询消耗的时间是0.88 ms，这比上面其他不使用索引的查询执行时间要低得多。</p><p id="0b27" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">查询:</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="10fb" class="ld ig hi kz b fi le lf l lg lh"><strong class="kz hj">select file_id, content <br/>       from document_text <br/>       where tsvector_content_desc @@ <br/>                     to_tsquery('(!bear &amp; predict)| instruments');</strong></span></pre><p id="ebcd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ma"><img src="../Images/63a7e06f40f0dcd7e93e9bccf59181b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qgV0_QdNL37FuwaX.JPG"/></div></div></figure><p id="ec53" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">结论:</strong></p><p id="10d5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Postgres的全文搜索功能非常棒，而且相对较快(足够了)。它将使您的应用程序无需其他工具即可增长。</p><p id="a6e6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">关键要点:</strong></p><ol class=""><li id="ae1a" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">“like”和“ilike”运算符不能用于较大文档的全文搜索，因为它们执行全文搜索的能力有限。</li><li id="54c1" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">tsvector和tsquery是Postgres中可用的数据类型，它们克服了“like”和“ilike”运算符对全文搜索的有限功能。</li><li id="b2ad" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">to_tsvector()和to_tsquery()是Postgres中用于搜索查询术语变体的函数。</li><li id="eb94" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">可以对tsvector字段进行索引，以便更快、更有效地对较大的文档进行全文搜索，从而避免任何性能问题。</li></ol><p id="8d09" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以根据自己的应用需求选择最佳的文本搜索策略。了解Postgres中文本搜索可用的数据类型和函数将有助于您决定在数据库中使用哪些数据类型。如果应用程序需要一个短而精确的单词搜索词，您可以使用“like”和“ilike”操作符。如果应用程序需要对较大的文档进行更复杂的搜索，可以使用to_tsvector()和to_tsquery()函数。</p><p id="6d96" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">参考文献:</strong></p><p id="e89d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae mb" href="https://www.postgresql.org/docs/current/textsearch-tables.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/current/text search-tables . html</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Chrome and Firefox both choke on CSS Grid, but one of them renders 10x the other one!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrome和Firefox都在CSS网格上窒息，但其中一个渲染了另一个的10倍！</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/chrome-and-firefox-both-chock-on-css-grid-42da0b7f3093?source=collection_archive---------6-----------------------#2021-09-01">https://medium.com/geekculture/chrome-and-firefox-both-chock-on-css-grid-42da0b7f3093?source=collection_archive---------6-----------------------#2021-09-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f4a8762ebb69c7d9dbed2d3e80859213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9FqP15LYnu1219kff3zMw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Chrome vs. Firefox illustration. Image source: <a class="ae iu" href="http://xahlee.info/js/i/chrome_vs_firefox.jpg" rel="noopener ugc nofollow" target="_blank">Xahlee.info</a></figcaption></figure><p id="592b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名程序员，你的工作就是不断想出一些会耗尽你空闲时间的兼职项目，然后因为不再具有挑战性而被放弃！我想到的最新想法是在Github页面上建立一个网站，通过<a class="ae iu" href="https://en.wikipedia.org/wiki/Shahnameh" rel="noopener ugc nofollow" target="_blank"> Shahnama </a>进行阅读和搜索。这导致了我想谈论的与两大网络浏览巨头的有趣经历。但首先，请允许我解释什么是沙纳玛。</p><p id="4f01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">《沙纳玛》是<a class="ae iu" href="https://en.wikipedia.org/wiki/Greater_Iran" rel="noopener ugc nofollow" target="_blank">大伊朗</a>的民族史诗，讲述了这个地区自文明开始以来王国和帝国兴衰的故事。Shahnama实际上是一首写在<a class="ae iu" href="https://en.wikipedia.org/wiki/Mathnawi" rel="noopener ugc nofollow" target="_blank"> mathnawi </a>系统中的长诗。你可能会问，这和网页设计有什么关系？在mathnawi中，诗句以旋律对句的形式出现，每一句都由两个彼此押韵的半诗组成。因此，这样的诗歌常常表现为如下图像:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/74a9ad39e9a5cf9653a8fc0c1d05c821.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*OMFwGIYQndOLuLR8fMPF3g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">The first four verses of Shahnama. The rhyming parts have been highlighted. Note that Persian is a right-to-left language.</figcaption></figure><p id="ba87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，这看起来是一个在CSS网格中使用这个不太新的特性的绝佳机会！设置非常简单。每个hemistich都有自己的块，父类获得下面的CSS类来启用网格并为内容设置模板:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="21da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样做之后，我立即在我常用的浏览器Google Chrome中加载了我在Nuxt.js 2.15.7中构建的SPA。乍一看，一切都很好。但是后来我想起了我通过废弃<a class="ae iu" href="https://kaffeketab.ir/ferdowsi/" rel="noopener ugc nofollow" target="_blank">这个奇妙的网站</a>收集的Shahnama版本有88830个半针。滚动条看起来非常小，只有44415行。按下结束键显示了以下暴行:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/506ee6cb88087be36e9ac8b1bebc1f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkVZdQm7b_5u5sj2fjV1HA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Chrome, choking on a CSS Grid with too many elements.</figcaption></figure><p id="cb6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里看到的是，在一定数量的半缝合之后，其余的都被一个接一个地覆盖，形成了那个巨大的黑色矩形。有趣的是，最后一次出现的به خون پری چهرگان تشنه بود海米斯蒂奇恰恰是沙纳玛的第2000次海米斯蒂奇！为什么是这个数字？这不是c语言中任何典型数据类型的上限，那么，到底是什么在起作用呢？我认为回答这个问题需要查看我从<a class="ae iu" href="https://aur.archlinux.org/packages/google-chrome" rel="noopener ugc nofollow" target="_blank"> Arch用户库</a>得到的谷歌Chrome 91.0.4472的源代码。但是让我们继续前进吧！</p><p id="3e86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我想到了我的老朋友火狐，我已经有一段时间没和他说话了。Manjaro为我更新了它，所以我就一头扎进去了。结果完全一样！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/1c73199e102092a54468da296522522d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpaUpxJcTusxhy_DN3jTUw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Firefox, choking on a CSS Grid with too many elements, but less than Chrome!</figcaption></figure><p id="2f48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">老实说，不完全一样。事实上，我从官方Manjaro库安装的最后一个由Firefox 91.0.2正确渲染的hemistich正是Shahnama中的第19998个hemistich！我不知道为什么这个数字离Chrome的10倍只差2位！</p><p id="4024" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种行为在两种浏览器中都可以重现。我重启了两个浏览器，清理了所有其他标签和后台任务，确保有足够的内存，甚至从头开始重新安装了同一个版本。结果是一样的。这只能说明这个限制是开发者自己强加的。我心想这可能与浏览器的内存使用有关。我们让KSysGuard去调查:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/ad29a88e8ca479717460e3dd80d87b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVXUfSsSaVs1cMzqRGeSLw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Chrome and Firefox, rendering the same page simultaneously.</figcaption></figure><p id="6e9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要介意WebStorm在顶部有将近2GB的内存！如果我们总结一下每个浏览器创建的进程，Chrome占用的内存是952MB，而Firefox使用的是622MB，渲染的内容多了10倍！在体验过程中，两种浏览器都没有出现明显的延迟。然而，在Chrome中Ctrl+F比在Firefox中花费的时间要长一些。但公平地说，我预计Chrome会比这些新手使用更多的内存！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/29e77e6fedfe57c909aea262a12a8f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKcd-IpuBIa0_vsIk-U_8Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Chrome just loves RAM! Illustration by <a class="ae iu" href="https://messbyaccident.com/" rel="noopener ugc nofollow" target="_blank">mess by accident</a>.</figcaption></figure><p id="58fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很好奇是什么导致一个浏览器渲染2000个块，而另一个渲染19998个块，然后将所有剩余的块一个接一个地叠加起来！如果你有什么想法，请告诉我。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Finding the latest date is not as easy as you would think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">找到最近的日期并不像你想象的那么容易</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/finding-the-latest-date-is-not-as-easy-as-you-would-think-2d6a0a49eda1?source=collection_archive---------3-----------------------#2022-07-18">https://medium.com/geekculture/finding-the-latest-date-is-not-as-easy-as-you-would-think-2d6a0a49eda1?source=collection_archive---------3-----------------------#2022-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d5c2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何在Spark中查找日期分区列中的最新值</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9d48e5173addb83768a2e689316bd870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcJqqdo6FW_U21MLZP43Ew.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@bahlooldesigner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Akbar Tarkati</a> on <a class="ae jn" href="https://unsplash.com/s/photos/latest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9678" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一篇非常有趣的文章，因为它打破了关于分区列的神话，我的意思是分区是如此惊人，以至于在某些时候我们开始认为它是理所当然的。<em class="kk">至少我做了</em>，这篇文章是关于我从假设的错误中学到的东西。</p><p id="5a66" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以，让我们开始吧！</p><p id="46b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的，那么当您在分布式存储(如HDFS/S3或实际上任何存储)中存储大量数据时，您首先会做什么？</p><p id="bdf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您<em class="kk">对它进行分区</em>，以便更容易地访问数据。基本上，一旦我决定了一个(或多个)列，它可以在存储数据时被指定为分区列，这样当我下一次访问它时，使用分区列作为过滤器，访问可以很快完成。</p><p id="f9ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还在迷茫？让我们想象一下分区:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kl"><img src="../Images/700fca67ad28d504ce57fca713c55ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZL7RU4rSj15y-zeaK_Dag.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Image by Author</figcaption></figure><p id="21f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果还不清楚，<a class="ae jn" href="https://www.datio.com/iaas/understanding-the-data-partitioning-technique/#:~:text=In%20HDFS%20the%20files%20are,shelves%20would%20be%20the%20Datanodes." rel="noopener ugc nofollow" target="_blank">这里的</a>是一些可以用来理解分区的资源。</p><h1 id="a671" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">问题</h1><p id="f615" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">好了，已经定义了分区，让我们讨论一下用例。<strong class="jq hj">作为本文的参考，所有操作都在Spark中执行。</strong></p><p id="f1e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我正在处理一个由<code class="du lj lk ll lm b">date</code>划分的数据(姑且称之为我们的数据<code class="du lj lk ll lm b">medium_article_stats</code>),并需要从中获取最新的数据，那么我做了什么呢？</p><p id="56f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我<strong class="jq hj"> <em class="kk">假设</em> </strong>数据由<code class="du lj lk ll lm b">date</code>分区，我可以简单地在<code class="du lj lk ll lm b">date</code>列上运行<code class="du lj lk ll lm b">max</code>，它将使用分区元数据(基本上是跟踪从哪里获取我们的分区的信息)来计算。</p><p id="18ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似于:</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="7760" class="lr kn hi lm b fi ls lt l lu lv">medium_article_stats.select(max("date")).show</span></pre><h2 id="4fa9" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">问题</h2><p id="0cb9" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">现在，这能行吗？</p><p id="e274" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你知道这个答案，我为你骄傲！如果没有，让我们来发现答案。</p><h2 id="7e4b" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">回答</h2><p id="68d7" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">是的，这行得通。</p><p id="cce7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我打赌你没想到会有这一天！</p><p id="c9bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是它确实可以工作，但是请注意，为了计算最大值，将扫描整个数据以实际获取列的最大值！！</p><p id="0a1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，如果数据存储为parquet/orc，可能会有格式级的优化，但是我们使用分区元数据计算<code class="du lj lk ll lm b">max date</code>的假设肯定是不准确的。</p><h2 id="706a" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">那么，这意味着什么呢？</h2><p id="cd4a" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">这意味着如果你正在运行<code class="du lj lk ll lm b">max(date)</code>,它就像扫描你的完整数据来获取<code class="du lj lk ll lm b">max</code>,并且在数据量很大的情况下会非常慢(因为你已经对它进行了分区)</p><p id="edb1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在查看上述查询的Spark查询执行计划时，我发现了这个缓慢的问题</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="d19a" class="lr kn hi lm b fi ls lt l lu lv">== Physical Plan ==<br/>(1) Scan csv <br/><br/>(2) SortAggregate<br/>Input [1]: [date#26]<br/>Keys: []<br/>Functions [1]: [partial_max(date#26)]<br/>Aggregate Attributes [1]: [max#107]<br/>Results [1]: [max#108]<br/><br/>(3) Exchange<br/>Input [1]: [max#108]<br/>Arguments: SinglePartition, ENSURE_REQUIREMENTS, [id=#41]<br/><br/>(4) SortAggregate<br/>Input [1]: [max#108]<br/>Keys: []<br/>Functions [1]: [max(date#26)]<br/>Aggregate Attributes [1]: [max(date#26)#101]<br/>Results [1]: [max(date#26)#101 AS max(date)#105]</span></pre><p id="399e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，我们可以看到，为了计算最大值，首先在单个任务级别<code class="du lj lk ll lm b">(2)</code>计算<code class="du lj lk ll lm b">partial_max</code>,然后进行洗牌<code class="du lj lk ll lm b">(3)</code>,所有内容都被放入单个分区&amp;,最后计算<code class="du lj lk ll lm b">max</code>。</p><p id="e4c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里的<code class="du lj lk ll lm b">(2)</code>和<code class="du lj lk ll lm b">(3)</code>是对大型数据集的极其昂贵的操作，想象一下扫描3年的数据！(<em class="kk">不要测试</em> <em class="kk">在S3运行这个查询，扫描3年的数据后的账单可能会让你骨折</em>)</p><p id="9271" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们的假设是准确的，那么基本上只有<code class="du lj lk ll lm b">(4)</code>会运行，扫描分区元数据并给我max，但事实并非如此。</p><p id="ad9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">理解了为什么<code class="du lj lk ll lm b">max(date)</code>很慢之后，让我们看看如何在一个分区的列中找到最新的日期？</p><h1 id="82fe" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">解决方法</h1><h2 id="14d8" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">方法1:使用<code class="du lj lk ll lm b">SHOW PARTITIONS</code></h2><p id="c467" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">如果一个外部的hive表存在于你存储在HDFS的数据之上，我们可以显式地做我们假设会发生的事情</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="b6bc" class="lr kn hi lm b fi ls lt l lu lv">spark.sql("show partitions <!-- -->medium_article_stats<!-- -->").select(max("partition")).show(truncate=false)</span></pre><p id="f038" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，<code class="du lj lk ll lm b">max</code>将只在分区上计算，与直接在表上运行<code class="du lj lk ll lm b">max</code>相比，速度要快得多。</p><h2 id="6b6a" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">方法2:添加过滤器</h2><p id="0cd1" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">如果您的数据上没有hive表，并且主要处理路径，那么在<code class="du lj lk ll lm b">date</code>上添加一个显式的<code class="du lj lk ll lm b">filter</code>，然后再计算<code class="du lj lk ll lm b">max</code>，可以帮助加快查询速度。但是请注意，<code class="du lj lk ll lm b">date</code>之后的数据仍然会被扫描用于<code class="du lj lk ll lm b">max</code>计算。</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="6144" class="lr kn hi lm b fi ls lt l lu lv">medium_article_stats<!-- -->.filter(col("date") &gt; "2022-05-01").select(max("date")).show</span></pre><h2 id="8e57" class="lr kn hi bd ko lw lx ly ks lz ma mb kw jx mc md ky kb me mf la kf mg mh lc mi bi translated">方法3:从S3/HDFS路径导出最大值</h2><p id="67d1" class="pw-post-body-paragraph jo jp hi jq b jr le ij jt ju lf im jw jx lg jz ka kb lh kd ke kf li kh ki kj hb bi translated">这是一种黑客行为，基本上，这个想法是</p><ul class=""><li id="b936" class="mj mk hi jq b jr js ju jv jx ml kb mm kf mn kj mo mp mq mr bi translated">列出目录中的所有路径</li></ul><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="dfac" class="lr kn hi lm b fi ls lt l lu lv">medium_article_stats/date=2022-01-20<br/>medium_article_stats/date=2022-01-21<br/>medium_article_stats/date=2022-01-22<br/>medium_article_stats/date=2022-01-23<br/>medium_article_stats/date=2022-01-24</span></pre><ul class=""><li id="39e5" class="mj mk hi jq b jr js ju jv jx ml kb mm kf mn kj mo mp mq mr bi translated">拆分字符串，以便在列表中抓取<code class="du lj lk ll lm b">date</code></li></ul><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="93b2" class="lr kn hi lm b fi ls lt l lu lv">[<!-- -->2022-01-20, 2022-01-21, 2022-01-22, 2022-01-23, 2022-01-24<!-- -->]</span></pre><ul class=""><li id="2659" class="mj mk hi jq b jr js ju jv jx ml kb mm kf mn kj mo mp mq mr bi translated">计算列表中的<code class="du lj lk ll lm b">max</code></li></ul><p id="d69a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，这是我能想到的一些方法，如果你还有其他问题，请随时发表评论:)</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="77b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗯，就这样吧！这就是我今天想要分享的知识，如何在对分区列执行<code class="du lj lk ll lm b">max</code>时避免全表扫描。这里需要注意的另一件事是，即使我们在列上运行<code class="du lj lk ll lm b">max</code>，也要记住一个分区的列总是一个<code class="du lj lk ll lm b">string</code>数据类型，所以要为列设置格式，以便在其上运行<code class="du lj lk ll lm b">max</code>能够给出准确的结果。</p><p id="5e9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，如果你的<code class="du lj lk ll lm b">date</code>格式看起来像这样，即使过滤仍然有效，运行max会给出不准确的结果。</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="daa8" class="lr kn hi lm b fi ls lt l lu lv">medium_article_stats/date=2022-01-1<br/>medium_article_stats/date=2022-01-10<br/>medium_article_stats/date=2022-01-2<br/>medium_article_stats/date=2022-01-3<br/>medium_article_stats/date=2022-01-4 # This would be returned as max as it is a string comparison</span></pre><p id="4c34" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">推荐的格式之一是:</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="38cf" class="lr kn hi lm b fi ls lt l lu lv">medium_article_stats/date=2022-01-01<br/>medium_article_stats/date=2022-01-10 # Accurate max calculation<br/>medium_article_stats/date=2022-01-02<br/>medium_article_stats/date=2022-01-03<br/>medium_article_stats/date=2022-01-04</span></pre><p id="fc88" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望这有所帮助，你可能不会犯和我一样的错误。</p><p id="43be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这篇文章，请为它鼓掌，它让我微笑，激励我继续写作！:)</p><p id="df84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">快乐学习，<br/> JD</p></div></div>    
</body>
</html>
<html>
<head>
<title>Understanding MRO (Method Resolution Order) for old and new style classes in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解python中新旧样式类的MRO(方法解析顺序)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-mro-method-resolution-order-for-old-and-new-style-classes-in-python-f541747c48c7?source=collection_archive---------27-----------------------#2021-08-01">https://medium.com/geekculture/understanding-mro-method-resolution-order-for-old-and-new-style-classes-in-python-f541747c48c7?source=collection_archive---------27-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d255" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">python中的C3线性算法和mro讲解</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5106ffb7f0903a246c9818af0864f5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebX5yI9vd76Kiun27MzTMA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Understanding mro in python old and new style classes</figcaption></figure><h1 id="3cbc" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="c9ca" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">与Java不同，Python支持多重继承。因此，理解方法解析顺序至关重要，尤其是对于python，因为它对于新的和旧的样式类有不同的MRO。</p><p id="dc83" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果你是python的新手，尽管我们现在还没有对python 2的官方支持，但了解这些概念的起源是有好处的。python 3中的所有类都只采用新样式的类，如果您想尝试旧样式的类，请使用python 2.2或更低版本。</p><p id="f0d4" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">到本文结束时，您应该对新旧样式类的方法解析顺序有了清晰的认识。</p><h1 id="eb70" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">动机:</h1><p id="46f7" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">python 2.2中的方法解析不是单调的，即不一致。因此，有人提议采用C3法决议顺序。</p><blockquote class="lg lh li"><p id="f458" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated"><em class="hi">单调性:</em></p><p id="4363" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated"><em class="hi">当下列条件成立时，MRO是单调的:</em>如果C1在C的线性化(类优先列表)中先于C2，那么C1在C的任何子类的线性化中先于C2<em class="hi">。</em></p></blockquote><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c410" class="ls jo hi lo b fi lt lu l lv lw">class C(C1, C2):<br/>    pass<br/><br/><br/>class ChildC(C,C1,C2):<br/>    pass</span></pre><h2 id="6cf4" class="ls jo hi bd jp lx ly lz jt ma mb mc jx ko md me jz ks mf mg kb kw mh mi kd mj bi translated">什么是C3？</h2><p id="2cb2" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><a class="ae mk" href="https://doc.sagemath.org/html/en/reference/misc/sage/misc/c3.html" rel="noopener ugc nofollow" target="_blank"> C3 </a>是Python用来为涉及多重继承的新样式类构造方法解析顺序的算法。目的是确保超类别列表与类别的父类或元素类的方法解析顺序相匹配。</p><p id="bbfe" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我将在接下来的几节中用适当的例子来解释C3。</p><p id="9c4b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">经典类(python 2)保持旧的方法解析顺序。因此，C3算法仅适用于新的样式类。</p><h1 id="e741" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">什么是MRO？</h1><p id="80a3" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><em class="lj">方法解析顺序</em> (MRO)是构建类优先级列表的一组规则，即一个类的祖先列表。在Python文献中，习语“C的MRO”也被用作C类的类优先列表的同义词。这里C类只是一个任意的类。</p><h2 id="b401" class="ls jo hi bd jp lx ly lz jt ma mb mc jx ko md me jz ks mf mg kb kw mh mi kd mj bi translated">新型类:</h2><p id="cf8c" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们考虑一个多重继承的经典例子。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="3e9a" class="ls jo hi lo b fi lt lu l lv lw">class A(object):<br/><br/>    def display(self):<br/>        print(f" From class A")<br/><br/><br/>class B(A):<br/><br/>    def display(self):<br/>        print(f" From class B")<br/><br/><br/>class C(A):<br/><br/>    def display(self):<br/>        print(f" From class C")<br/><br/><br/>class D(C, B):<br/><br/>    def display(self):<br/>        print(f" From class D")<br/><br/><br/>class E(C, B):<br/><br/>    def display(self):<br/>        print(f" From class E")<br/><br/>D().display()<br/>E().display()<br/><br/>Output:<br/> From class D<br/> From class E</span></pre><p id="2aa3" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">上面是python 3中多重继承的一个非常清晰的实现。现在，任何从<code class="du ml mm mn lo b">class D</code>和<code class="du ml mm mn lo b">class E</code>继承的类都是有效的。如果你想检查方法解析顺序，你可以使用代码<code class="du ml mm mn lo b">print(D.__mro__)</code>。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="815f" class="ls jo hi lo b fi lt lu l lv lw">print(D.__mro__)<br/><br/>Output:<br/>(&lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/5eab544a45ffc2b60406404e1bc49091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gb22fj6aYyoGoV8Z"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">method resolution in new style classes for class D</figcaption></figure><p id="434b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">以上输出显示了<code class="du ml mm mn lo b">class D</code>的mro。顺序是<code class="du ml mm mn lo b">D-&gt;C-&gt;B-&gt;A-&gt;Object</code>。C3顺序是从左到右，如果一个方法在左类和右类中都没有实现，那么它会更深入到父类。</p><p id="969e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果你想测试这一点，你可以试着从<code class="du ml mm mn lo b">class D</code>和<code class="du ml mm mn lo b">class C</code>中注释掉<code class="du ml mm mn lo b">display()</code>方法，继续深入查看从哪里调用该方法。</p><p id="2487" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在一切似乎都很好…</p><p id="30d7" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们稍微混合一下。我们将在<code class="du ml mm mn lo b">class E</code>中互换继承顺序。让我们定义<code class="du ml mm mn lo b">class E(B,C)</code>而不是<code class="du ml mm mn lo b">class E(C,B)</code>，其中后者用<code class="du ml mm mn lo b">class D</code>匹配继承顺序。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="df30" class="ls jo hi lo b fi lt lu l lv lw">class A(object):<br/><br/>    def display(self):<br/>        print(f" From class A")<br/><br/><br/>class B(A):<br/><br/>    def display(self):<br/>        print(f" From class B")<br/><br/><br/>class C(A):<br/><br/>    def display(self):<br/>        print(f" From class C")<br/><br/><br/>class D(C, B):<br/><br/>    def display(self):<br/>        print(f" From class D")<br/><br/><br/>class E(B, C):<br/><br/>    def display(self):<br/>        print(f" From class E")</span></pre><p id="a6bc" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在我们已经交换了<code class="du ml mm mn lo b">class E</code>中的继承顺序，我们将尝试创建一个从D和e继承的新类<code class="du ml mm mn lo b">class F(D,E)</code>。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="abd1" class="ls jo hi lo b fi lt lu l lv lw">class F(D,E):<br/><br/>    def display(self):<br/>        print(f" From class F")<br/><br/><br/>F().display()</span><span id="637c" class="ls jo hi lo b fi mp lu l lv lw">Output:<br/>Traceback (most recent call last):<br/>  File "/home/dineshkumarkb/MyGitHub/MyPractice/Python/mro.py", line 31, in &lt;module&gt;<br/>    class F(D,E):<br/>TypeError: Cannot create a consistent method resolution<br/>order (MRO) for bases C, B</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/c3108a7f6d7d5f6fa9a3d5d2f726bc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*QA5aSO9UaCoysLwTuHJmeg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">A typical multiple inheritance in python</figcaption></figure><p id="b019" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这就对了。有了新的样式类，python不允许创建不一致的方法解析，因为线性化是从左到右，然后是深度。因此，如果继承顺序改变，用户将无法从这些类中创建子类。这是由C3指定的线性算法是怎么回事。重申mro定义，<em class="lj">如果C1在C的线性化中先于C2，那么C1在C的任何子类的线性化中先于C2</em>。</p><h1 id="c467" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">旧样式类别:</h1><p id="b70e" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">现在我们对新样式类中的mro有了清晰的概念，让我们理解在python 2.3之前事情是如何工作的。记住，在python 2.3之前，mro是深度优先，然后从左到右，不像新的样式类。</p><p id="0bec" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><em class="lj">注意:确保你有python 2.3以下的解释器来运行这段代码。任何高于2.2的python版本都提供了新的样式类实现。</em>还要确保A类不会从<code class="du ml mm mn lo b">object</code>类继承。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c11a" class="ls jo hi lo b fi lt lu l lv lw">class A:<br/><br/>    def display(self):<br/>        print("From class A")<br/><br/><br/>class B(A):<br/><br/>    def display(self):<br/>        print("From class B")<br/><br/><br/>class C(A):<br/><br/>    def display(self):<br/>        print("From C")<br/><br/><br/>class D(C, B):<br/><br/>    def display(self):<br/>        print("From D")<br/><br/><br/>class E(B, C):<br/><br/>    def display(self):<br/>        print("From E")<br/><br/><br/>class F(D,E):<br/><br/>    def display(self):<br/>        print("From class F")<br/><br/>F().display()</span></pre><p id="4ac8" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在Python 2.2中，解释器允许你从这样的父类继承类。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="c85a" class="ls jo hi lo b fi lt lu l lv lw">Output: </span><span id="de7c" class="ls jo hi lo b fi mp lu l lv lw">From class F</span></pre><p id="e1db" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这里没有错误，解决的顺序是模糊的。现在，让我们试着在从<code class="du ml mm mn lo b">class F</code>开始的每个类中注释掉<code class="du ml mm mn lo b">display()</code>方法，看看解释器如何解析继承。</p><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="80f0" class="ls jo hi lo b fi lt lu l lv lw">class A:<br/><br/>    def display(self):<br/>        print("From class A")<br/><br/><br/>class B(A):<br/><br/>    def display(self):<br/>        print("From class B")<br/><br/><br/>class C(A):<br/>    pass<br/><br/>    # def display(self):<br/>    #     print("From C")<br/><br/><br/>class D(C, B):<br/>    pass<br/><br/>    # def display(self):<br/>    #     print("From D")<br/><br/><br/>class E(B, C):<br/><br/>    def display(self):<br/>        print("From E")<br/><br/><br/>class F(D, E):<br/>    pass<br/><br/>    # def display(self):<br/>    #     print("From class F")<br/><br/>F().display()</span></pre><p id="faaa" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">从<code class="du ml mm mn lo b">class F</code>中移除显示方法后，它会转到一个父类<code class="du ml mm mn lo b">class D</code>。在移除<code class="du ml mm mn lo b">class D</code>中的<code class="du ml mm mn lo b">display()</code>方法时，理想情况下应查看<code class="du ml mm mn lo b">class E</code>。然而，它深入一层并取入<code class="du ml mm mn lo b">class C</code>，它是<code class="du ml mm mn lo b">class D</code>的父节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/daeee7659ede8a5ec11a1e05c397c0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*njUrPAB56O-haXZg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">mro in old style classes</figcaption></figure><pre class="iy iz ja jb fd ln lo lp lq aw lr bi"><span id="43dc" class="ls jo hi lo b fi lt lu l lv lw">Output </span><span id="0e53" class="ls jo hi lo b fi mp lu l lv lw">From class A</span></pre><p id="1bee" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">您可以尝试通过注释不同类的方法来理解解决顺序。我希望这篇文章能够清晰地描述python的旧风格和新风格类以及C3算法的方法解析顺序。</p><h1 id="2aad" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">总结:</h1><ul class=""><li id="22b3" class="mr ms hi kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">Python的新样式类遵循C3算法来确定新样式类的方法解析顺序。</li><li id="a507" class="mr ms hi kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">python 2.3支持新的样式类</li><li id="b199" class="mr ms hi kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">旧的样式类使用深度优先然后从左到右的方法确定mro。</li><li id="0154" class="mr ms hi kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">新的样式类首先从左到右确定mro，然后向更深的方向移动。</li></ul><h1 id="775f" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">参考资料:</h1><ul class=""><li id="2e56" class="mr ms hi kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated"><a class="ae mk" href="https://www.python.org/download/releases/2.3/mro/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/download/releases/2.3/mro/</a></li><li id="0753" class="mr ms hi kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae mk" href="https://doc.sagemath.org/html/en/reference/misc/sage/misc/c3.html" rel="noopener ugc nofollow" target="_blank">https://doc . sagemath . org/html/en/reference/misc/sage/misc/C3 . html</a></li></ul><p id="b17b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">对于远程python工作，请尝试https://remotepython.io/的<a class="ae mk" href="https://remotepython.io/" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="2a88" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><em class="lj">原载于2021年8月1日https://dineshkumarkb.com</em><em class="lj"/><a class="ae mk" href="https://dineshkumarkb.com/tech/understanding-mro-method-resolution-order-for-old-and-new-style-classes-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="lj">。</em></a></p></div></div>    
</body>
</html>
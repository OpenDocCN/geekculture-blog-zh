<html>
<head>
<title>Javascript Internals: What’s Under the Hood?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript内部:什么在引擎盖下？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/javascript-internals-whats-under-the-hood-29946f0ae156?source=collection_archive---------0-----------------------#2020-11-07">https://medium.com/geekculture/javascript-internals-whats-under-the-hood-29946f0ae156?source=collection_archive---------0-----------------------#2020-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/405c78699a6a95c25bb5e657e461a3ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phPBi2X5MqbMEPj5a_oHQw.jpeg"/></div></div></figure><p id="0bb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本文原载于</em><a class="ae jp" href="https://priyathgregory.dev/blog/javascript-internals-whats-under-the-hood" rel="noopener ugc nofollow" target="_blank"><em class="jo">priyathregory . dev</em></a><em class="jo">。</em></p><p id="4dcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您真的不需要了解太多就可以开始使用Javascript。事实上，一个完全成熟的产品化应用程序可以在不理解语言内部工作原理的情况下构建。这既是福也是祸；这种语言有许多采用者，但只有极少数掌握者。</p><p id="a1e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种认识让我开始尝试理解Javascript到底是如何工作的。旅程远未结束，但雾已经开始消散。这一切都始于一个问题，“Javascript到底是什么？”。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="da06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么Javascript是什么呢？正式地说，Javascript是一种单线程、非阻塞、异步编程语言。</p><p id="7909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">…</p><p id="e250" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">等等什么？</p><p id="f7e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从表面上看，这个定义(至少对我来说)是矛盾的、令人困惑的，而且只会引发更多的问题。单线程程序怎么可能是非阻塞的呢？怎么可能也是异步的呢？</p><p id="9561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些都是非常合理的问题。但是请原谅我，他们也有答案。答案就在Javascript的核心——它的运行时环境。</p><h1 id="d4bf" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Javascript运行时</h1><p id="9964" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">Javascript运行时环境是让您的代码工作的基础，它允许Javascript在其正式定义中包含所有复杂的术语，从浏览器的上下文来看，它主要是4个方面的组合:</p><ol class=""><li id="b869" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">Javascript引擎</li><li id="01e9" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">Web APIs</li><li id="c3f1" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">回调队列</li><li id="cf00" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">事件循环</li></ol><p id="9607" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们逐个检查这些部分。</p><blockquote class="lo lp lq"><p id="0d68" class="iq ir jo is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated"><strong class="is hj">注</strong></p><p id="e1ca" class="iq ir jo is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated">Javascript运行时环境可以根据上下文采取不同的形状和形式。例如，浏览器的运行时环境(我们将详细探讨)与node.js的运行时环境不同。我们讨论的概念将适用于大多数Javascript运行时环境，与上下文无关。</p></blockquote><h1 id="91b1" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Javascript引擎</h1><p id="a38f" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">Javascript引擎是运行时环境的大脑，它的主要目的是将人类可读的脚本转换成机器可读的代码。</p><p id="a80d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它还管理一个调用栈(想想LIFO栈数据结构)来跟踪代码的执行，并且执行本身总是在一个线程上同步执行。此外，该引擎还执行垃圾收集、优化和一大堆其他的事情，这些都值得单独撰写一篇文章。</p><p id="e7e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何值得您花费时间的引擎都将包含ECMAScript的实现，ECMAScript是一种为标准化Javascript而创建的脚本语言规范。这使得引擎“知道”什么是<code class="du lu lv lw lx b">while</code>循环，以及<code class="du lu lv lw lx b">Math.round(x)</code>应该做什么。如果您所需要的只是一堆while循环、一些函数定义和一些变量(换句话说，如果您所需要的是在ECMAScript规范中定义的)，Javascript引擎完全有能力自己处理您的代码。</p><p id="fa10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是Javascript不仅仅是几个函数定义。它是一种强大的语言，能够做很多事情，这就把我们带到了下一个难题，web APIs。</p><h1 id="fe93" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Web APIs</h1><p id="d58b" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">如果您查看诸如V8之类的Javascript引擎的源代码，您会发现许多您认为是标准Javascript规范的一部分的功能根本不存在。一个恰当的例子是<code class="du lu lv lw lx b">setTimeout</code>函数。我不知道你怎么想，但是对我来说<code class="du lu lv lw lx b">setTimeout</code>是标准的Javascript。但是如果它不在引擎里，它在哪里？</p><p id="18cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输入Web APIs。Web APIs是特定于浏览器的关键实现，它扩展了Javascript语言。例如，如果你打开谷歌Chrome控制台，输入如下内容:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="7927" class="mg jy hi lx b fi mh mi l mj mk">function main(){ <br/>  setTimeout(()=&gt;console.log('Hello World!'), 5000); <br/>}; <br/>main();</span></pre><p id="d920" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Hello World”将如预期的那样在5秒钟后打印到控制台上。这段代码之所以有效，是因为谷歌Chrome的Web APIs将自己的<code class="du lu lv lw lx b">setTimeout</code>实现嵌入到了它的Javascript引擎V8中。类似地，DOM也是Javascript引擎的一部分。任何与DOM相关的东西:无论是事件侦听器、访问器还是操纵器，都在..你猜对了，web APIs！</p><p id="11da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，一个非常合乎逻辑的问题是，如果Javascript引擎不知道这些函数，那么它将如何处理我的脚本中的“web API”函数调用？</p><p id="04de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案在于浏览器如何将web APIs嵌入其Javascript引擎。</p><p id="2170" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当Javascript引擎试图解析一个符号时，它将从局部范围开始，沿着范围链向上。链的最末端是<code class="du lu lv lw lx b">global</code>范围。作为初始化Javascript引擎的一部分，任何主机环境都可以向这个<code class="du lu lv lw lx b">global</code>范围添加自己的API，从而向Javascript引擎公开函数及其相应的处理程序。</p><p id="e35a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解这一点，让我们回到我们的例子:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="f3a5" class="mg jy hi lx b fi mh mi l mj mk">function main(){ <br/>  setTimeout(()=&gt;console.log('Hello World!'), 5000); <br/>}; <br/>main();</span></pre><p id="afd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当这段代码被复制到Google Chrome浏览器时，实际上会发生什么？</p><ul class=""><li id="d631" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn ml lg lh li bi translated">V8引擎将通过向调用堆栈添加<code class="du lu lv lw lx b">main()</code>来启动。</li><li id="c1c9" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated">然后引擎会在作用域链中寻找<code class="du lu lv lw lx b">setTimeout</code>函数定义。(这将在<code class="du lu lv lw lx b">global</code>范围内提供，因为<code class="du lu lv lw lx b">setTimeout</code>没有内置在发动机中)。</li><li id="b2db" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated">V8引擎将把<code class="du lu lv lw lx b">setTimeout()</code>推到调用栈上，“调用”web API的<code class="du lu lv lw lx b">setTimeout</code>定义，这反过来将在Javascript主线程的之外启动浏览器为此准备的任何本机实现。</li><li id="56be" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated">至此，就发动机而言，它的工作已经完成。因此，<code class="du lu lv lw lx b">setTimeout()</code>将被弹出调用堆栈，紧接着是<code class="du lu lv lw lx b">main()</code>。</li></ul><p id="c7ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧。但不可能是这样，对吧？延迟5秒钟后，仍有一个回调要执行。说到回调，到底发生了什么？</p><p id="6c9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了找到这些答案，我们需要看看运行时难题的下一部分，回调队列。</p><h1 id="f1da" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">回调队列</h1><p id="cca5" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">那该死的复试去哪了？</p><p id="0981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此之前，我们需要首先理解回调函数的作用。</p><p id="3b0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调函数本质上是Javascript引擎和一个<strong class="is hj">异步</strong> web API任务之间的绑定，通常带有在异步任务完成其职责后做什么的指令。<strong class="is hj">任何在引擎主线程之外运行的代码都需要一个相关的回调函数来与引擎进行通信。</strong></p><p id="40e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你还没有意识到，这是异步Javascript背后的基本概念。</p><blockquote class="lo lp lq"><p id="f2d6" class="iq ir jo is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated"><strong class="is hj">提示</strong></p><p id="7322" class="iq ir jo is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated">任何在Javascript引擎主线程之外执行的操作都是异步操作。</p></blockquote><p id="368d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，这些都很好，但是说真的，我们的复试在哪里？</p><p id="e935" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们倒回去一点。</p><p id="bcc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在V8引擎“调用”了<code class="du lu lv lw lx b">setTimeout</code> web API绑定之后，一些特定于浏览器的本地代码将负责计时5秒的延迟。这是一个发生在引擎主线程之外的异步操作，其实现细节并不重要。同样的本地代码也将负责确保我们“丢失的”回调函数找到回家的路。</p><p id="07db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这是怎么做到的呢？</p><p id="30eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，在Javascriptland领域中，等待执行的回调有一个特殊的位置。这是回调队列，它是Javascript运行时中使异步Javascript成为可能的两个关键部分之一。</p><p id="164e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本机代码知道它的存在，一旦异步任务完成，它将把我们的回调函数推到回调队列中。</p><p id="8bb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的回调函数就要完成了，但是我们还没有完成。Javascript运行时难题还有最后一块。</p><h1 id="d427" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">事件循环</h1><p id="040a" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated"><em class="jo">到底什么是事件循环？</em></p><p id="02b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件循环是Javascript引擎和回调队列之间的凝胶，它做两件事。</p><p id="2052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，它将定期检查Javascript引擎的调用堆栈是否为空。如果是，则它将从回调队列中获取一个回调，并将其放入调用堆栈中，从而有效地安排其执行。</p><p id="976e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其实就是这么简单。</p><p id="5462" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调队列和事件循环共同使异步Javascript代码工作。前者将完成的异步操作的回调函数排队，而后者将安排它们在Javascript的主线程上执行。</p><h1 id="d89e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">整圈</h1><p id="f864" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated"><em class="jo">“…一种单线程、非阻塞的异步编程语言。”</em></p><p id="ecda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这是一篇内容相当丰富的文章，介绍了在Javascript的保护下实际发生的事情，而且上面的定义比几分钟前的定义更有意义。</p><p id="6b3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我曾试图保持事物非常一般化；只是为了确保您了解这些概念不仅适用于浏览器的运行时，也适用于您可能遇到的任何Javascript运行时环境。</p><p id="87a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我也非常确信，这将打开许多新的问题，你可能以前没有。但这就是关键所在。问题应该导致研究，这可能会导致更多的混乱，但如果你坚持下去，最终会导致答案。这就是你学习的方法。</p><p id="82fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以要把一大堆文字总结成几个要点:</p><ul class=""><li id="46b5" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn ml lg lh li bi translated"><strong class="is hj">Javascript运行时</strong>使Javascript代码工作。它可以采用许多不同的形状和形式(浏览器、node . js)；但运行时的基本概念在所有环境中都将保持不变。浏览器的运行时环境由Javascript引擎、一堆web APIs、回调队列和事件循环组成。</li><li id="82fb" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated"><strong class="is hj">Javascript引擎</strong>将人类可读的Javascript代码转换为机器可读的字节码，并始终在<strong class="is hj">单线程上执行。</strong>它还负责管理呼叫堆栈以及其他一系列事务。</li><li id="56fb" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated"><strong class="is hj">web API</strong>扩展了Javascript语言，其自身的功能被添加到Javascript引擎的<code class="du lu lv lw lx b">global</code>对象中。这些功能中有些是同步的，有些可以是异步的。</li><li id="e1cd" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated"><strong class="is hj">回调队列</strong>将等待Javascript引擎执行的回调排队。回调通常总是与某些异步操作相关联。</li><li id="899b" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated"><strong class="is hj">事件循环</strong>是Javascript引擎和回调队列之间的凝胶。它的工作是将回调从回调队列移动到引擎的调用堆栈中以供执行。</li><li id="f3ff" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn ml lg lh li bi translated">回调队列和事件循环是Javascript的<strong class="is hj">异步</strong>(和<strong class="is hj">非阻塞</strong>)的核心！)自然。</li></ul><h1 id="c962" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">资源</h1><ol class=""><li id="aa85" class="la lb hi is b it kv ix kw jb mm jf mn jj mo jn lf lg lh li bi translated">如果你喜欢看而不是读，我强烈推荐看看<a class="ae jp" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=239s" rel="noopener ugc nofollow" target="_blank">和<em class="jo">到底什么是事件循环？</em> </a>出自菲利普·罗伯茨。说真的，看看这个。</li><li id="a8e3" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated"><a class="ae jp" href="https://stackoverflow.com/questions/59316975/the-javascript-v8-engine-and-web-apis" rel="noopener ugc nofollow" target="_blank">这个</a>栈溢出帖子讨论V8引擎和web APIs之间的链接，而<a class="ae jp" href="https://stackoverflow.com/questions/59344915/which-part-of-the-javascript-runtime-is-responsible-for-putting-the-callback-int" rel="noopener ugc nofollow" target="_blank">这个</a>帖子讨论回调队列。</li></ol></div></div>    
</body>
</html>
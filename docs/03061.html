<html>
<head>
<title>What is new on JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript有什么新特性？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/what-is-new-on-javascript-ef69240e2825?source=collection_archive---------46-----------------------#2021-05-30">https://medium.com/geekculture/what-is-new-on-javascript-ef69240e2825?source=collection_archive---------46-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/eeb07a8e82bc568ed4318efdbd7da002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9quzmMptwR8A53ZL18Mb3g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Image from <a class="ae iu" href="https://www.pinterest.com/pin/709950328743580333/" rel="noopener ugc nofollow" target="_blank">Pinterest</a></figcaption></figure><h1 id="19b0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">一点历史</h1><p id="79e3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">JavaScript是一种脚本语言，由Brenden Eich在Netscape工作时创建，用于他们的旗舰浏览器“Netscape Navigator”。首先，它被命名为“Mocha ”,然后是“LiveScript ”,后来又被改为JavaScript，因为当时Netscape正与Sun Microsystems合作，寻找一种解决方案来打破Internet Explorer在Internet浏览器市场上的垄断地位，并在与Java兼容的web浏览器中工作。而是<strong class="jv hj"> <em class="kr"> Java！= JavaScript。</em>T3】</strong></p><p id="bc24" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">JavaScript基本上被设计为一种核心语言，用于在客户端与HTML和CSS一起创建网站，而JS提供了网站的交互性和动态性。最初它被设计成在客户端运行，现在它已经获得了作为服务器端语言作为后端运行的能力。</p><h1 id="fe33" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是ECMAScript？</h1><p id="21f5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">由于JavaScript在客户端使用的灵活性，不同的供应商倾向于逆转并开始使用不同版本的JavaScript，以保持其增长。1997年，Netscape委托欧洲计算机制造商协会(ECMA)为语言规范创建一个标准。</p><p id="357b" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">ECMAScript版本6是2015年发布的主要版本。引入了重大变化。</p><p id="eea2" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">现在让我们来讨论ES6给JavaScript生态系统带来了哪些重大变化。</p><h1 id="85dd" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是新的？</h1><h2 id="d10f" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">变量</h2><p id="bb0b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在ES6之前，使用<strong class="jv hj"><em class="kr">【var】</em></strong>定义的JavaScript块变量甚至可以在块外访问。但是随着ES6 JS引入了<strong class="jv hj"><em class="kr"/></strong>关键字，所有使用<strong class="jv hj"><em class="kr"/></strong>关键字定义的变量都不能在块外访问。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="669f" class="kx iw hi lq b fi lu lv l lw lx">{<br/>   var x = "Hello"<br/>}</span><span id="d21a" class="kx iw hi lq b fi ly lv l lw lx">console.log(x) //Access is possible</span><span id="8546" class="kx iw hi lq b fi ly lv l lw lx">{<br/>   let y = "World";<br/>}</span><span id="129f" class="kx iw hi lq b fi ly lv l lw lx">console.log(y) //undefined - Access is impossible</span></pre><p id="a920" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">ES6的下一次更新是<strong class="jv hj"><em class="kr">【const】</em></strong>。“const”使变量不可修改，只是一个常数。但它的特殊之处在于，只有当它是<strong class="jv hj"> <em class="kr">而不是</em> </strong> <strong class="jv hj"> <em class="kr">数组或对象时，它才是常量。</em> </strong>我们来看一个例子</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="4624" class="kx iw hi lq b fi lu lv l lw lx">const x = "Hello World!";</span><span id="e257" class="kx iw hi lq b fi ly lv l lw lx">x = "Hello Earth";</span></pre><p id="5da6" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在上面的场景中，开发人员不能将变量的内容更改为“Hello Earth ”,因为它是一个常量。</p><p id="61e6" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">但是说到物品。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="25a4" class="kx iw hi lq b fi lu lv l lw lx">const greetingMessage  = class greeting{<br/>      constructor(){<br/>         this.firstLine = "Hello"<br/>         this.secondLine = "World"<br/>       }<br/>}</span><span id="7f66" class="kx iw hi lq b fi ly lv l lw lx">greetingMessage.firstLine = "Hello"<br/>greetingMessage.secondLine = "Earth"</span></pre><p id="6a19" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">对于数组来说。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3ff7" class="kx iw hi lq b fi lu lv l lw lx">const categories = ["Horror", "Documentry", "Thriller"]<br/>categories.push("Mystery")</span></pre><p id="26ba" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">即使它声明为“const ”,修改也是可能的</p><h2 id="0376" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">功能</h2><p id="b655" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">从ES6开始，JS引入了新的箭头函数，这是一种简单的函数声明方式。传统的函数声明方式是这样的。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8fa7" class="kx iw hi lq b fi lu lv l lw lx">function getTotalPrice(qty, price){<br/>     return price * qty;<br/>}</span></pre><p id="67a1" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">但是对于箭头函数，允许开发人员以几种不同的方式定义函数。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="1da4" class="kx iw hi lq b fi lu lv l lw lx">let totalAmount = (qty, price) =&gt;{<br/>        return price * qty;<br/>}</span><span id="3a51" class="kx iw hi lq b fi ly lv l lw lx">let price = totalAmount(5, 100)</span></pre><p id="ffbe" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">这种方法可以进一步简化</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f381" class="kx iw hi lq b fi lu lv l lw lx">let totalAmount=(qty, price) =&gt; price * qty;<br/>let price = totalAmount(5, 100);</span></pre><p id="a4c1" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">如果该方法有一个只有一个参数的操作，arrow函数提供了一种方便的方式来编写如下的方法。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="931f" class="kx iw hi lq b fi lu lv l lw lx">let totalAmount = qty =&gt; 100 * qty;<br/>let totalPrice = totalAmount(5);</span></pre><p id="cb0d" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">然而，当使用箭头功能时，有一件重要的事情需要考虑。让我们来看看这个例子</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="c4d3" class="kx iw hi lq b fi lu lv l lw lx">const item = {<br/>    getItem: function(){<br/>        console.log("Using Function : ")<br/>        console.log(this)<br/>    },</span><span id="f266" class="kx iw hi lq b fi ly lv l lw lx">getItemUsingArrow: ()=&gt;{<br/>        console.log("Using Arrow Function : ")<br/>        console.log(this)<br/>    }<br/>}</span><span id="5550" class="kx iw hi lq b fi ly lv l lw lx">item.getItem()<br/>item.getItemUsingArrow()</span></pre><p id="b8bc" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">当我们运行上面的程序时，输出将是这样的。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/bddcafddd69f445a09d89b929f323202.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*_QCY9hs4AWkMaaEEr1yrnQ.png"/></div></figure><p id="e5b2" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">我们可以看到，当我们在函数的更简单方式中使用<em class="kr">“this”</em>关键字时，它指的是调用函数的对象。(项)。但是在使用箭头函数时，它总是不把<em class="kr">“this”</em>作为函数的调用者。</p><h2 id="74f4" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">目标</h2><p id="3c76" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">JavaScript提供了用键、值方法定义对象的能力。首先，让我们看一个类示例，讨论ES6中JS类的新特性</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="8f9e" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">如果我们仔细观察类中的<em class="kr">【date】</em>字段，它没有赋值，这是因为如果开发人员想要指出一个现有的已定义变量，它不需要赋值。与前面的例子相同，类中的日期属性将引用上面声明的变量<br/> <code class="du mc md me lq b">let date = new Date()</code></p><p id="694d" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">而JS用ES6带给对象的下一个新事物是<strong class="jv hj"> <em class="kr">动态属性。</em> </strong>在上例中，我们可以看到一个用方括号括起来的字段，作为占位符<strong class="jv hj">【信息】</strong><strong class="jv hj">。</strong>这些被识别为动态属性，其中可以动态地注入字段名，以改变字段名</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="634f" class="kx iw hi lq b fi lu lv l lw lx">info = "Review"</span></pre><p id="5dc3" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">而“[info]”将被替换为“Review”，这将发生在运行时，并且主要在执行时使用键值。</p><p id="0712" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">当涉及到对象修改时，这些值可以像这样自由地改变。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="292b" class="kx iw hi lq b fi lu lv l lw lx">Book.author = "Dan Brown"</span></pre><p id="9a37" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">但是有时开发人员可能需要不让这些值被改变。JS附带了一个名为“Object.freeze()”的方法来停止修改对象。这是它的工作原理。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="bbd2" class="kx iw hi lq b fi lu lv l lw lx">Object.freeze(Book)</span></pre><p id="7f45" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">那么我们对Book对象所做的任何修改都不会生效。但是在本书的例子中，我们有一个内部类叫做“Publisher”。仅仅冻结外部类并不能保护内部类。为了保护外部类，冻结方法可以如下应用。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="fc03" class="kx iw hi lq b fi lu lv l lw lx">Object.freeze(Book.Publisher)</span></pre><h2 id="6101" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">班级</h2><p id="3deb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">当谈到JS类和对象时，它遵循与其他静态类型语言有些相似的方法。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="d62d" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">为了使数组中的值解包更容易，JS引入了<strong class="jv hj">“析构函数”将对象分解成不同的变量。</strong>和析构函数可以在多种用法中使用为例。</p><p id="c211" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">导入库或外部模块，</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="bfb9" class="kx iw hi lq b fi lu lv l lw lx">const {writeFile} = require("fs")</span></pre><p id="0da2" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">从数组中解包值</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f759" class="kx iw hi lq b fi lu lv l lw lx">[elementOne, elementTwo, ...otherElements] = [39, 43, 63, 10, 66];</span></pre><p id="e1c0" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在上面的例子中，它将根据前两个变量(“elementOne”、“elementTwo”)分配前两个值，然后用三个点声明“otherElements”。在析构函数中，它将“43”之后的所有值分配到一个名为“otherElements”的单独数组中，如下所示。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="0b51" class="kx iw hi lq b fi lu lv l lw lx">elementOne = 39<br/>elementTwo = 43<br/>otherElements = [ 63, 10, 66 ]</span></pre><p id="7121" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">这些析构函数也可以应用于类。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="6985" class="kx iw hi lq b fi lu lv l lw lx">const book = {<br/>    name: "Inferno",<br/>    author: "Dante Alighieri",</span><span id="820c" class="kx iw hi lq b fi ly lv l lw lx">    Publisher : {<br/>            name : "Noonday Press",<br/>            origin: "MI, ITALY",<br/>    }<br/>}</span><span id="db3a" class="kx iw hi lq b fi ly lv l lw lx">const { name, author } = book;</span></pre><p id="373f" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">变量如何初始化，如下所示</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b5e2" class="kx iw hi lq b fi lu lv l lw lx">name = "Inferno"<br/>author = "Dante Alighieri"</span></pre><h2 id="5f5c" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">回访和承诺</h2><p id="f1cb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">JS中的函数定期以同步方式执行，其中一个函数必须等待另一个函数完成它的工作。但是JS提供了一种异步的工作方式，在这种方式下，其他任务不必等到其他函数完成执行。</p><p id="9cc0" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">回调函数用于实现这种异步行为，它能够将一个函数作为参数传递给另一个函数，并在一个函数完成执行后运行。下面是一个回调函数的例子</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="187b" class="kx iw hi lq b fi lu lv l lw lx">function greetings(name, callback) {<br/>     console.log("Hello " + name + "!, Have a nice day!" )<br/>     callback();<br/>}</span><span id="1617" class="kx iw hi lq b fi ly lv l lw lx">greetings("John", function() {<br/>     console.log("Inside the callback function")<br/>});</span></pre><p id="aaa2" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">接下来最重要的是承诺。它是一个表示任务完成与否的对象。承诺有三种状态，</p><ol class=""><li id="c57e" class="mf mg hi jv b jw ks ka kt ke mh ki mi km mj kq mk ml mm mn bi translated">待定:初始状态，既未完成也未拒绝。</li><li id="d96c" class="mf mg hi jv b jw mo ka mp ke mq ki mr km ms kq mk ml mm mn bi translated">已完成:表示操作成功完成。</li><li id="1c51" class="mf mg hi jv b jw mo ka mp ke mq ki mr km ms kq mk ml mm mn bi translated">拒绝:表示操作失败。</li></ol><p id="0f6f" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">这里有一个创建异步API消费过程的例子。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><h2 id="b0e6" class="kx iw hi bd ix ky kz la jb lb lc ld jf ke le lf jj ki lg lh jn km li lj jr lk bi translated">参考</h2><p id="406e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现代JavaScript从一开始01-<a class="ae iu" href="https://www.youtube.com/watch?v=Jc2iW4yVv38" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Jc2iW4yVv38</a></p><p id="3d2b" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">现代JavaScript从头部分02-【https://www.youtube.com/watch?v=XK_lB5-XzhQ】<br/>T3&amp;</p></div></div>    
</body>
</html>
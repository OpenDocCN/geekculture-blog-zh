<html>
<head>
<title>HackerRank Bead Ornaments Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HackerRank珠饰品说明</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/hackerrank-bead-ornaments-explained-eddb02643b40?source=collection_archive---------19-----------------------#2022-12-09">https://medium.com/geekculture/hackerrank-bead-ornaments-explained-eddb02643b40?source=collection_archive---------19-----------------------#2022-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a6ca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">理解凯莱公式和<strong class="ak">生成树的基尔霍夫定理</strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/da7f6bb4974ffc1f732c3ab88f62731b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-gLGJQMHfy7tnPVA"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@cookiethepom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cookie the Pom</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1abe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个有趣的问题。但是看起来像是背Linux命令。如果你没有图形算法的背景，这很难解决。如果你知道这些算法，包括<a class="ae jn" href="https://en.wikipedia.org/wiki/Cayley%27s_formula" rel="noopener ugc nofollow" target="_blank">凯莱公式</a>和<a class="ae jn" href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem" rel="noopener ugc nofollow" target="_blank">基尔霍夫定理</a>，你可以用这个公式问题分分钟求解。</p><h2 id="8fff" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题</h2><p id="cbd2" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">珠子有N种颜色。你有第I种颜色的珠子。你想把所有的珠子连在一起做成一件装饰品。您可以使用以下算法创建装饰:</p><ul class=""><li id="4d5e" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">步骤# 1:将所有的珠子按任意顺序排列，这样相同颜色的珠子就可以放在一起。</li><li id="7e8f" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">第二步:饰品最初只由排列中的第一颗珠子组成。</li><li id="75c6" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">第三步:对于顺序中的每一个珠子，把它和装饰物中相同颜色的珠子连接起来。如果没有相同颜色的珠子，它可以连接到饰品中的任何珠子上。</li></ul><p id="9f5c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所有的珠子都是截然不同的，即使它们有相同的颜色。如果两个珠子在一种结构中用线连接，而在另一种结构中没有，那么这两个饰品被认为是不同的。使用这种算法可以形成多少种不同的饰品？返回答案模(1000000007L)。</p><p id="3604" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">更新/澄清</strong></p><p id="effa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">把珠子的形成想象成一棵树，而不是一条直线。一个珠子可以连接任意数量的珠子。</p><div class="ly lz ez fb ma mb"><a href="https://www.hackerrank.com/challenges/beadornaments/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">珠子饰品| HackerRank</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">珠子有颜色。你有这种颜色的珠子。你想把所有的珠子连在一起做成一件装饰品…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.hackerrank.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jh mb"/></div></div></a></div><h2 id="01c5" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">解决办法</h2><p id="4e03" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">请不要用排列混淆它。这是一个图算法问题。如果你没有这方面的背景，你可能不需要去理解它，因为这些图论定理可能需要数学家花费数年的时间来建立。坦率地说，这可能不是一个好的面试问题，但它只是测试你是否知道这些图表公式。</p><p id="c485" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://stackoverflow.com/questions/23327244/bead-ornaments-algorithm" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>对这个问题有很好的解释。这里就不赘述了。但这里将举例说明用Java实现，以便于理解。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="9296" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'beadOrnaments' function below.<br/>     *<br/>     * The function is expected to return an INTEGER.<br/>     * The function accepts INTEGER_ARRAY b as parameter.<br/>     */<br/><br/>    final static long MOD = 1000000007L;<br/>    public static int beadOrnaments(List&lt;Integer&gt; b) {<br/>        // Write your code here<br/>        if (b.size() &lt; 1) return 0;<br/>        <br/>        long res = 0;<br/>        if (b.size() == 1) {<br/>            // n = 1: This is a problem of Cayley's formula<br/>            int a = b.get(0);<br/>            res = (long) Math.pow(a, a - 2);   <br/>        }<br/>        else {<br/>            // n &gt; 1: it's Kirchhoff's matrix tree with Cayley's formula<br/>            long sum = 0;<br/>            res = 1;<br/>            for (int v : b) {<br/>                res *= Math.pow(v, v - 1);<br/>                sum += v;<br/>            }<br/>            res *= Math.pow(sum, b.size() - 2);<br/>        }<br/>        <br/>        return (int) (res % MOD);<br/>    }<br/><br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        int t = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, t).forEach(tItr -&gt; {<br/>            try {<br/>                int bCount = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>                List&lt;Integer&gt; b = Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))<br/>                    .map(Integer::parseInt)<br/>                    .collect(toList());<br/><br/>                int result = Result.beadOrnaments(b);<br/><br/>                bufferedWriter.write(String.valueOf(result));<br/>                bufferedWriter.newLine();<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="04ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来很简洁。编码快乐！</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="bce8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="nh">问题、想法？在这里留下评论。跟随我成为有趣的解决问题之旅的一部分。</em></p></div></div>    
</body>
</html>
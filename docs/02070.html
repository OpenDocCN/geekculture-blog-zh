<html>
<head>
<title>Programmatically Update View Constraints in Constraint Layout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以编程方式更新约束布局中的视图约束</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/programatically-update-view-constraints-in-constraint-layout-f4eb1b6dfc38?source=collection_archive---------13-----------------------#2021-05-03">https://medium.com/geekculture/programatically-update-view-constraints-in-constraint-layout-f4eb1b6dfc38?source=collection_archive---------13-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b52794d4d820f1a0c19cf8ae6818a8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zV4Yqn81L4avPBIWTTuAEQ.jpeg"/></div></div></figure><p id="b707" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Constraint layout是迄今为止Android框架中最通用的视图组之一，然而，以编程方式更新视图约束所需的Kotlin代码可能有点冗长。我已经创建了一个约束布局Kotlin扩展，它将使这个过程更容易应用，在代码中看起来更清晰。我们开始吧！</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="cfce" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">约束说明</h1><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="3718" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有<strong class="is hj"> ConstraintInstructions </strong>接口，它有两个简单的实现，<strong class="is hj"> ConnectConstraint </strong>和<strong class="is hj"> DisconnectConstraint </strong>。</p><p id="b29a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> ConnectConstraints </strong>采用4个参数来帮助描述您要约束的视图以及约束的内容。</p><ol class=""><li id="477d" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">startID —您要约束的视图的resourceId。</li><li id="c711" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">startSide —作为startID传递的视图中您想要约束的一侧。传入<em class="ln"> *side </em>参数的值应该是ConstraintSet类中的常量。常见的有:ConstraintSet。<em class="ln">开始，</em>约束集。<em class="ln">顶部，</em>约束集。<em class="ln">结束，或</em>约束集。<em class="ln">底部。</em></li><li id="b7fd" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">endID —您希望将<strong class="is hj">约束到</strong>的视图的resourceId。请记住，通常视图被约束到另一个视图或父视图，所以如果您想将startID视图约束到另一个视图，您应该传入该视图的resourceId。<strong class="is hj">如果要约束到父节点，那么传入0。</strong></li><li id="8daf" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">endSide——作为endID传递的视图的一侧，您希望将startID视图<strong class="is hj">约束到</strong>。</li></ol><p id="a7e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> DisconnectConstraint </strong>只有两个参数描述了视图和该视图要清除的约束侧。</p><ol class=""><li id="2934" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">startID要从中删除约束的视图的resourceId。</li><li id="934f" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">startSide作为startID传递的视图中要删除约束的一侧。这遵循与前面相同的模式，只对应于ConstraintSet类中的常量。</li></ol><p id="2443" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好的理解，我们来看一个例子。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="c9bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在XML中，为了进行约束，我们描述了要附加的边和视图/父视图。在ImageView中我们应用<strong class="is hj"><em class="ln">app:layout _ constraint top _ toBottomOf = " @ id/title "</em></strong>，和说的一样；</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="d3a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这应该读起来非常相似；XML中唯一没有提到的是startID的视图引用，因为这是我们应用属性的视图。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="99c0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">将所有内容整合在一起的扩展</h1><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="cb1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有一个扩展函数，它接受一列ContraintInstuctions并将它们应用于ConstraintLayout的子视图。我们首先创建一个<strong class="is hj">constraint set</strong>对象和<strong class="is hj"> <em class="ln"> clone() </em> </strong>布局的当前约束。然后我们遍历指令并匹配类类型。每当我们想要连接约束时，我们使用ConstraintSet函数<strong class="is hj"><em class="ln">connect()；</em> </strong>它接受ConnectConstraint中的相同参数。相反，如果我们想从视图中移除约束，我们使用ConstraintSet函数<strong class="is hj"> <em class="ln"> clear() </em> </strong>并在DisconnectConstraint中传递相同的参数。最后，我们将新的约束集更改应用到布局和BOOM！我们可以通过编程快速、灵活地连接和断开约束。</p></div></div>    
</body>
</html>
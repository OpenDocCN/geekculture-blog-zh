<html>
<head>
<title>Dynamic Querying Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让动态查询变得简单</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/dynamic-querying-made-easy-e34d1f1c23ab?source=collection_archive---------15-----------------------#2021-07-05">https://medium.com/geekculture/dynamic-querying-made-easy-e34d1f1c23ab?source=collection_archive---------15-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5ed5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Boot使用CrudRepository或JPARepository接口使查询变得非常容易。几乎所有的基本用例，包括基于列值获取结果，都可以使用上述接口来满足。</p><p id="2ce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是让我们考虑下面的场景。<em class="jd">如果我们直到收到用户端的请求才知道要过滤哪一列，该怎么办？</em>2<br/>。<em class="jd">当我们处理过滤用例时，这将是特别需要的，用户可能会应用某些过滤器，而不是应用少数过滤器。</em> <br/> 3。<em class="jd">基于这些参数，我们必须动态填充查询中的某些参数，并忽略其他参数。</em></p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="3fa1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">解决办法</h1><p id="638b" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们可以简单地在扩展CrudRepository/JPARepository的接口中为各个列生成查询。但是这不是一种正确的方式，我们通过接受少数几个列并拒绝其他列来为所有用例编写查询会非常耗时。</p><h1 id="0769" class="jl jm hi bd jn jo ko jq jr js kp ju jv jw kq jy jz ka kr kc kd ke ks kg kh ki bi translated">实解；)</h1><p id="8678" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">好了，现在来看看真正的解决方案，它将优雅地处理这个问题。我们可以使用<strong class="ih hj">规范</strong> <em class="jd">接口</em>来实现我们的目标，好的一面是，它非常简单，非常通用。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/bd1daa52a206c71206492e9d385c963c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xu4E1715Ciwbl3cUW7ltcg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Basic JPA architecture</figcaption></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lj"><img src="../Images/1f721fd7efa99797007ca36dba73bf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*5zZbSIrl3xXG1JeBXd3pAg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Specification Flow</figcaption></figure><p id="720c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们深入实现之前，我们将对规范接口中的内容进行简单描述</p><ol class=""><li id="a121" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj"><em class="jd">to predicate(&lt;method params&gt;):</em></strong>这是生成谓词(查询条件)的方法，需要对其执行查询。</li><li id="7ca3" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">T18】criteria query&lt;？&gt; :  </strong>将针对实体运行以获取结果的查询</li><li id="c64c" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj"> <em class="jd">表达式&lt; T &gt; : </em> </strong>这是一个提供各种方法对实体列执行操作的接口。</li><li id="1272" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj"><em class="jd">criteria builder:</em></strong>这个类用于根据需要提供给查询的谓词、表达式等生成查询。</li></ol></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="ef14" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">实施</strong></h1><p id="6625" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">下面的代码块说明了我们如何将各种操作应用到标准构建器中。Key和operation都可以作为参数传递给实现规范的类。我将把细节留给实现者。我实现了一个包含以下内容的包装类</p><ol class=""><li id="3a47" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><em class="jd"> Key: </em>需要查询的列</li><li id="5566" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="jd">值:</em>列需要映射的内容</li><li id="f97c" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="jd">操作符:</em>需要对目标列执行的操作。</li></ol><p id="ad02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在初始化规范实现者时，这个包装器将作为参数传递。</p><pre class="ku kv kw kx fd ly lz ma mb aw mc bi"><span id="ce45" class="md jm hi lz b fi me mf l mg mh">@Override<br/>public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) {<br/>    String operation = wrapper.getOperation();<br/>    String key = wrapper.getKey();<br/>   if (key != null) {<br/>        switch (operation) {<br/>            case "&gt;":<br/>                applyGreaterThan(key, criteriaBuilder);<br/>                break;<br/>            case "&lt;":<br/>                applyLessThan(key, criteriaBuilder);<br/>                break;<br/>            case "&gt;=":<br/>                applyGreaterThanOrEqualTo(key, criteriaBuilder);<br/>                break;<br/>            case "&lt;=":<br/>                applyLessThanOrEqualTo(key, criteriaBuilder);<br/>                break;<br/>            case "&lt;&gt;":<br/>                predicate = criteriaBuilder.isNotNull(key);<br/>                break;<br/>            case "~":<br/>                predicate = criteriaBuilder.isNull(key);<br/>                break;<br/>            case "=":<br/>                applyEqualTo(key, criteriaBuilder);<br/>                break;<br/>            case "in":<br/>                applyIn(key);<br/>                break;<br/>            default:<br/>                break;<br/>        }<br/>    }<br/>    return predicate;<br/>}</span></pre><p id="34e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，有各种各样的方法被调用。下面提到其中一种方法。在该方法中，实现了精确匹配和相似匹配。</p><pre class="ku kv kw kx fd ly lz ma mb aw mc bi"><span id="9451" class="md jm hi lz b fi me mf l mg mh">private void applyEqualTo(Expression&lt;T&gt; key, CriteriaBuilder criteriaBuilder) {<br/>    if (key.getJavaType() == String.class) {<br/>        predicate = criteriaBuilder.like(<br/>                ( Expression&lt;String&gt; ) key, "%" + wrapper.getValue() + "%");<br/>    } else {<br/>        predicate = criteriaBuilder.equal(key, wrapper.getValue());<br/>    }<br/>}</span></pre><p id="2503" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是用我们的搜索参数设置包装器并创建规范。</p><pre class="ku kv kw kx fd ly lz ma mb aw mc bi"><span id="8ba6" class="md jm hi lz b fi me mf l mg mh">Wrapper firstCondition = new Wrapper("<em class="jd">column_name"</em>, "=", value);<br/>wrapper secondCondition= new Wrapper("<em class="jd">column_name"</em>, "&lt;", value);<br/>SpecificationImplementor&lt;T&gt; spec1 = new SpecificationImplementor&lt;&gt;(firstCondition);<br/>SpecificationImplementor&lt;T&gt; spec2 = new SpecificationImplementor&lt;&gt;(secondCondition);<br/>Specification&lt;T&gt; finalSpecification= Specification.<em class="jd">where</em>(spec1)<br/>        .and(spec2);</span></pre><p id="3469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面提到的片段中可以看出，我们可以实现n个条件，并最终将它们合并成一个规范。初始化SpecificationImplementor对象时，会发生以下情况。</p><ol class=""><li id="f42e" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">将调用toPredicate方法，我们已经覆盖了该方法以适应我们的逻辑。</li><li id="75df" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">基于传递的操作符，特定的条件将被添加到谓词中。</li><li id="ef42" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">添加了谓词的规范对象将返回给调用者。</li></ol><p id="58a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了上面提到的片段，我们还可以添加更多的条件，并创建OR条件或任何其他条件。</p><p id="91f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在所需要的就是使用这个动态构造的规范在目标实体上调用查询。为此，我们需要扩展JPASpecificationExecutor接口。</p><pre class="ku kv kw kx fd ly lz ma mb aw mc bi"><span id="1448" class="md jm hi lz b fi me mf l mg mh">public interface TargetRepository extends CrudRepository&lt;TargetEntity, Long&gt;, JpaSpecificationExecutor&lt;TargetEntity&gt;</span></pre><p id="ed3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们实现了它，我们就可以直接传递我们构造的规范</p><pre class="ku kv kw kx fd ly lz ma mb aw mc bi"><span id="1e72" class="md jm hi lz b fi me mf l mg mh">List&lt;TargetEntity&gt; targetEntity = TargetRepository.findAll(finalSpecification)</span></pre><p id="9215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们没有在存储库接口中编写任何查询，每个查询都是使用规范构建的。</p><p id="4de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得解决方案更加通用，并且可以使用相同的规范实现者来适应n个查询，而只需最少的/不需要代码更改。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="bba5" class="md jm hi bd jn mi mj mk jr ml mm mn jv iq mo mp jz iu mq mr kd iy ms mt kh mu bi translated">越多越开心！</h2><p id="0afc" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">上面提到的只是一个简单的用例。我们可以基于这个实现更多的查询，并且也支持分页结果。因此，从现在开始，无论传递多少查询参数进行查询，我们都可以简单地使用相同的代码来获得结果。快乐问人！！。</p></div></div>    
</body>
</html>
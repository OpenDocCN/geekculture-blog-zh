<html>
<head>
<title>The Async Challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步挑战</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/build-your-own-asynctask-fcfc4aaf0225?source=collection_archive---------4-----------------------#2021-03-02">https://medium.com/geekculture/build-your-own-asynctask-fcfc4aaf0225?source=collection_archive---------4-----------------------#2021-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7758" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">创建并执行您自己的AsyncTask。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/377cf11690778a936d189142e8ebf884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVipIK8mDdBKFcfEHGX0VQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">by <a class="jn jo ge" href="https://medium.com/u/54fbf878c2f4?source=post_page-----fcfc4aaf0225--------------------------------" rel="noopener" target="_blank">Chetan Gupta</a></figcaption></figure><p id="186d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">几十年来，<code class="du kl km kn ko b">AysncTask</code>一直是在Android中编写并发代码的最广泛使用的解决方案之一，现在即使它被弃用，知道如何自己复制相同的功能也是很好的。</p><p id="fac7" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">所以，在这篇文章中，我尝试实现我自己的<code class="du kl km kn ko b">AsyncTask</code>，在浏览文章之前——试着自己实现它，并考虑提交你的Github的链接。</p><p id="4e37" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">让我们继续…</p><p id="eb3e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">一个<code class="du kl km kn ko b">AsyncTask</code>实现的一个常见的事情是，它在一个<code class="du kl km kn ko b">background thread</code>上运行一个任务，其结果在<code class="du kl km kn ko b">UI thread</code>上发布。</p><blockquote class="kp kq kr"><p id="32ef" class="jp jq ks jr b js jt ij ju jv jw im jx kt jz ka kb ku kd ke kf kv kh ki kj kk hb bi translated">AsyncTask使用的三种输入类型如下:<br/> 1。<code class="du kl km kn ko b"><em class="hi">Params</em></code>:任务执行时发送给任务的参数类型<br/> 2。<code class="du kl km kn ko b"><em class="hi">Progress</em></code>:后台发布的进度单位类型。计算<br/> 3。<code class="du kl km kn ko b"><em class="hi">Result</em></code>:背景计算结果的类型</p></blockquote><p id="b6f8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们知道成功实施<code class="du kl km kn ko b">AsyncTask</code>的4个主要步骤是:</p><ol class=""><li id="21e6" class="kw kx hi jr b js jt jv jw jy ky kc kz kg la kk lb lc ld le bi translated"><code class="du kl km kn ko b">onPreExecute</code>:在执行任何任务之前，在<code class="du kl km kn ko b">UI Thread</code>上调用</li><li id="20ec" class="kw kx hi jr b js lf jv lg jy lh kc li kg lj kk lb lc ld le bi translated"><code class="du kl km kn ko b">doInBackground(Params..)</code>:在<code class="du kl km kn ko b">onPreExecute</code>执行完毕后，立即在<code class="du kl km kn ko b">background thread</code>上调用</li><li id="3469" class="kw kx hi jr b js lf jv lg jy lh kc li kg lj kk lb lc ld le bi translated"><code class="du kl km kn ko b">onProgressUpdate(Progress…)</code>:在<code class="du kl km kn ko b">UI Thread</code>上调用，显示执行任务的进度</li><li id="4dfd" class="kw kx hi jr b js lf jv lg jy lh kc li kg lj kk lb lc ld le bi translated"><code class="du kl km kn ko b">onPostExecute(Result…)</code>:在<code class="du kl km kn ko b">UI Thread</code>上调用，在<code class="du kl km kn ko b">doInBackground()</code>执行完毕后立即发布结果</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/0069fbc12df0d78efeb4562d1334b751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SXPYgWEJrp1QBw64B2rrg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Fig. 1.1 Internal working of an AsyncTask</figcaption></figure><p id="7f42" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因此，<code class="du kl km kn ko b">AsyncTask</code>合同的实现如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e4e2" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><code class="du kl km kn ko b">AsyncTaskResolver</code>类将这4个步骤实现为类中的<strong class="jr hj">抽象函数</strong>，稍后将从<code class="du kl km kn ko b">execute()</code>方法中触发，该方法基本上是异步操作的触发点。</p><p id="0833" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了让这些方法<code class="du kl km kn ko b">onPreExecute()</code>、<code class="du kl km kn ko b">onProgressUpdate()</code>和<code class="du kl km kn ko b">onPostExecute()</code>在<code class="du kl km kn ko b">UI Thread</code>上被调用，我使用了<code class="du kl km kn ko b">Handler</code>(它允许你从<code class="du kl km kn ko b">background thread</code>与<code class="du kl km kn ko b">UI thread</code>进行通信)。</p><p id="157d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为后台执行生成新线程的类如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="463c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了在后台执行任务，我使用具有两个主要功能的<code class="du kl km kn ko b">ThreadSpawner</code>类生成了一个后台线程——T8和T9。</p><p id="4e61" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><code class="du kl km kn ko b">execute()</code>函数以lambda函数<code class="du kl km kn ko b">task</code>为参数，负责启动线程执行。</p><p id="abae" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在<code class="du kl km kn ko b">execute()</code>方法中，我们创建了一个新线程，它在<strong class="jr hj">开始</strong>时触发lambda。<code class="du kl km kn ko b">execute()</code>正在返回<code class="du kl km kn ko b">ThreadSpawner</code>类的<strong class="jr hj">当前实例</strong>，这对实现函数的<strong class="jr hj">链接</strong>很有用。</p><p id="161a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了彻底关闭线程，我们在<code class="du kl km kn ko b">ThreadSpawner</code>类中有<code class="du kl km kn ko b">cancel()</code>方法，它调用<code class="du kl km kn ko b">Thread.interrupt()</code>来停止线程。</p><blockquote class="ln"><p id="8d24" class="lo lp hi bd lq lr ls lt lu lv lw kk dx translated">注意:<code class="du kl km kn ko b">Thread.stop()</code>已被弃用，因为它本身就不安全。</p></blockquote><p id="ab3b" class="pw-post-body-paragraph jp jq hi jr b js lx ij ju jv ly im jx jy lz ka kb kc ma ke kf kg mb ki kj kk hb bi translated">现在，您可以使用活动中的<code class="du kl km kn ko b">AsyncTask</code>来安排任务了:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c0bc" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">使用<code class="du kl km kn ko b">execute()</code>功能触发<code class="du kl km kn ko b">AsyncTask</code>，使用<code class="du kl km kn ko b">cancel()</code>功能终止任务；</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="62d8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我知道有上百种更好的方法来设计API，但这是我想到的最少的方法，下面附有代码的链接，如果你有建议和改进，请打开一个关于知识库的PR。随时欢迎投稿和建议…</p><div class="mc md ez fb me mf"><a href="https://github.com/pooja-srivs/CustomAsyncTask" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">pooja-srivs/CustomAsyncTask</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在GitHub上创建一个帐户，为pooja-srivs/CustomAsyncTask开发做贡献。</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jh mf"/></div></div></a></div><h1 id="5716" class="mu mv hi bd mw mx my mz na nb nc nd ne io nf ip ng ir nh is ni iu nj iv nk nl bi translated">社区提交的内容</h1><p id="4a9d" class="pw-post-body-paragraph jp jq hi jr b js nm ij ju jv nn im jx jy no ka kb kc np ke kf kg nq ki kj kk hb bi translated">以下是来自开发人员社区的提交列表:</p><h2 id="9033" class="nr mv hi bd mw ns nt nu na nv nw nx ne jy ny nz ng kc oa ob ni kg oc od nk oe bi translated">切坦·古普塔</h2><p id="4a87" class="pw-post-body-paragraph jp jq hi jr b js nm ij ju jv nn im jx jy no ka kb kc np ke kf kg nq ki kj kk hb bi translated">提交了AsyncTask挑战，使用了<strong class="jr hj">处理线程</strong>并改进了用于<strong class="jr hj">错误处理</strong>的API，他的提交如下</p><div class="mc md ez fb me mf"><a href="https://github.com/ch8n/AsyncTasker" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">ch8n/异步任务器</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">你好朋友们。🙌，欢迎来到我的编码游乐场！继续四处探索👩‍💻如果你发现什么，一定要让我知道…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="of l mq mr ms mo mt jh mf"/></div></div></a></div><p id="74ad" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">他还在发表了大量关于Kotlin和Android的文章</p><div class="mc md ez fb me mf"><a href="https://chetangupta.net" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">机器人咬|大脑瓜-科特林|切坦·古普塔</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">使用本地技术设计和开发现代android应用程序，使用Kotlin和Java同步提高工作效率…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">chetangupta.net</p></div></div><div class="mo l"><div class="og l mq mr ms mo mt jh mf"/></div></div></a></div><h1 id="8732" class="mu mv hi bd mw mx my mz na nb nc nd ne io nf ip ng ir nh is ni iu nj iv nk nl bi translated"><a class="jn jo ge" href="https://medium.com/u/d36fab545633?source=post_page-----fcfc4aaf0225--------------------------------" rel="noopener" target="_blank"> AndroidDeveloperLB </a></h1><p id="66ee" class="pw-post-body-paragraph jp jq hi jr b js nm ij ju jv nn im jx jy no ka kb kc np ke kf kg nq ki kj kk hb bi translated">提交的挑战和他的解决方案包括:<br/>——可以在任何地方创建和执行。不仅仅是主线程，UI线程<br/>——可以通过生命周期<br/>自动取消——只有一个值需要处理:结果。对于参数和进度，您可以添加自己的实现</p><div class="mc md ez fb me mf"><a href="https://github.com/AndroidDeveloperLB/AsyncTaskEx" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">AndroidDeveloperLB/AsyncTaskEx</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">一个AsyncTask的修改版本，在Kotlin中，使用一些简单的类删除了一些内容，添加了一些内容…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="oh l mq mr ms mo mt jh mf"/></div></div></a></div></div></div>    
</body>
</html>
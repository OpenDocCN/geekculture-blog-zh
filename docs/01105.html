<html>
<head>
<title>File Upload and Download in Node.js using Multer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Multer在Node.js中上传和下载文件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/file-upload-and-download-in-node-js-c524a8050c8f?source=collection_archive---------2-----------------------#2021-03-28">https://medium.com/geekculture/file-upload-and-download-in-node-js-c524a8050c8f?source=collection_archive---------2-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0f97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的应用程序中上传或下载文件不是您很少使用的东西。因此，了解如何在客户端上传文件以及如何在服务器端处理和存储文件是非常重要的。此外，在获取存储在服务器上的文件时，必须意识到不同的可能性，例如下载的文件应该在浏览器标签之一中打开，还是应该作为附件下载并单独打开。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a2aa2f67b8ac9ee4750bbdf8196f6e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rc78D8gjIIvova2pdTst8A.png"/></div></figure><h2 id="97b9" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">客户端的文件上传:</h2><p id="c361" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">为了解释客户端的文件上传，下面以Vue.js的代码片段为例。在表单元素内部，<strong class="ih hj"> enctype= </strong> <code class="du kl km kn ko b"><strong class="ih hj">"multipart/form-data"</strong></code> <strong class="ih hj"> </strong>表示通过表单提交的不仅仅是文本，还有文件。如果只想在表单中提交文本，应该使用<strong class="ih hj"> enctype= </strong> <code class="du kl km kn ko b"><strong class="ih hj">"</strong><a class="ae kp" href="http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">x-www-urlencoded</strong></a><strong class="ih hj">"</strong></code>，因为这样会更有效。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kq kr l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Vue.js snippet for uploading a file</figcaption></figure><p id="80f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">input元素有一种类型的<code class="du kl km kn ko b"><strong class="ih hj">"file"</strong></code>,它表示这个input元素不接受文本输入，而是在单击input元素对应的输入框时打开一个文件浏览器。当您从资源管理器中选择一个文件并点击<strong class="ih hj">打开</strong>时，那么<strong class="ih hj"> @change </strong>钩子将被触发并调用附带的函数和语句。这里，附加函数filesChange有两个参数，元素的名称和文件列表。<strong class="ih hj">对于上述输入元素的情况，输入元素的名称</strong>将是<code class="du kl km kn ko b"><strong class="ih hj">"photo"</strong></code>，因为它已经作为name= <code class="du kl km kn ko b"><strong class="ih hj">"photo"</strong></code>在输入元素中传递。<strong class="ih hj">文件列表</strong>代表一个数组，其中包含用户在文件浏览器中选择的所有文件。</p><p id="cbd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看方法<strong class="ih hj"> filesChange，</strong>我们创建一个名为<strong class="ih hj"> FormData </strong>的JS对象。FormData是复制表单的可迭代对象。可以看做是数组的数组。每一个数组都代表想要发送给服务器的元素。每个数组都有一个名字和一个值。一个可选参数是fileName。这些都是由<strong class="ih hj">添加的。append(名称，值，【文件名】)</strong>方法生成formData。Name表示输入元素的名称，value表示字符串或BLOB(二进制大型对象), fileName是在服务器上接收输入元素的文件名。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kr l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Send the selected files to the backend server in a post request</figcaption></figure><p id="ad91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，下一个任务是将上传的文件发布到服务器，在那里它将被适当地处理。我们使用axios，它是一个http客户端，可以用来发送http请求。这里，我们使用<strong class="ih hj"> axios.post(url，formData) </strong>方法，因为我们添加了一些东西，即HTTP动词post。我们需要一个后端服务器运行，以便我们从客户端发送的文件在服务器上得到正确处理。</p><p id="2603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">后端的文件处理:<br/> </strong>我们在服务器端使用了Express server。在后端阶段，必须用适当的控制器功能来映射路线。在我们的例子中，路径是'/upload '。我们将触及一个名为<strong class="ih hj"> multer </strong>的node.js库。我们使用multer来提取输入的文件。Multer是一个中间件，从HTTP请求中提取上传的文件</p><p id="af7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户可以通过以下方式安装multer</p><blockquote class="kx ky kz"><p id="52a5" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">npm安装乘数—保存</p></blockquote><p id="d01d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以将multer导入到我们的routes文件中</p><p id="9a10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">const multer = require(' multer ')<br/>app . use(multer()。单人('照片'))</p><p id="41dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，app是<strong class="ih hj"> express </strong>对象的一个实例。<strong class="ih hj">。single(name) </strong>指定我们只希望为一个特定的输入元素名上传一个文件，对于我们的例子来说是“photos”。现在，一旦应用了<strong class="ih hj"> multer </strong>中间件，我们就可以使用<strong class="ih hj"> req.file </strong>来访问该文件。req.file包含</p><p id="8de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字段名:</strong>输入上传文件的元素名称<br/> <strong class="ih hj">原始名称:</strong>文件的原始名称。服务器用来存储文件的名称可以不同于原始名称<br/> <strong class="ih hj">编码:</strong>用于编码的位数<br/> <strong class="ih hj"> mimetype: </strong>此<br/> <strong class="ih hj">缓冲区是哪种类型的文件:</strong>文件作为流发送到服务器，缓冲区包含该流。</p><p id="04d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在multer中使用<strong class="ih hj"> dest </strong> param，缓冲流可以转换成二进制数据</p><p id="f030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">app . use(multer({ dest:' destination folder ' })。单人('照片'))</p><p id="b0ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后端项目根目录下的destinationFolder将是作为缓冲流发送的文件作为二进制对象存储的地方。在这种情况下，我们不会在req.file中看到<strong class="ih hj">缓冲区</strong>键</p><p id="df3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得更多关于如何存储传入文件的选项，我们可以使用<strong class="ih hj">。磁盘存储</strong>方法</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="le kr l"/></div></figure><p id="a7fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> destination </strong>是一个以http req变量、文件和一个cb (callback)为参数的函数。回调又将error(如果有，如果没有error则为null)作为第一个参数，将destination folder作为存储文件的位置。类似地，filename函数也将http req变量、file和一个cb(回调)作为参数。这个回调再次将error(如果有，如果没有错误则为null)作为第一个参数，将我们用来存储文件的名称作为第二个参数。这里，我们在文件的原始名称后面附加了时间戳，以防止重复上传同一文件时出现冲突。<br/>以同样的方式，我们可以添加一个文件过滤器，不允许上传不匹配特定mimetype的文件。在这个例子中，我们只允许png、jpg和jpeg类型的图像。</p><p id="f4bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经将文件存储在服务器文件系统中，下一件事就是通过另一个http请求从前端下载文件</p><p id="ebe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要下载这个文件，我们需要使用一个内置的JS库，名为“fs”或文件系统。它允许我们对文件系统进行操作。要在特定的路径下载文件，我们只需要把下面的代码放到正确的控制器中。</p><p id="e12c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">const fs =要求(<code class="du kl km kn ko b">'fs'</code>)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/c07f43668619c860433e0b4dee4737f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kLOAASNUZ2eLla_ZMr3Qg.png"/></div></div></figure><p id="1425" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们设置了“内容-处置”头。“附件”意味着文件不会在浏览器中打开，但会在打开之前先下载。<br/>变量<strong class="ih hj">文件名</strong>包含下载新文件的文件名。这是可行的。</p><p id="e189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里我们是通过<strong class="ih hj"> readFile一次读取整个文件。</strong>对于较大的文件，下载文件需要很长时间。更糟糕的是，有时服务器上的内存可能会因为许多传入的请求而溢出，因为它必须读取内存中的所有数据。因此，要改善它，我们必须使用文件流</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lk kr l"/></div></figure><p id="549b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面这段代码中，我们首先创建了一个文件读取流，因为我们想从一个特定的路径读取数据。param <strong class="ih hj"> path </strong>以字符串的形式包含了要下载的文件的相对地址。同样，我们将“Content-Disposition”头设置为“attachment ”,这样文件就可以作为附件下载，其名称与变量filename相同。<strong class="ih hj"> pipe </strong>方法获取一个读流，并将其内容放入一个写流。在这里，http res是一个写流，因此我们将可读文件流的全部数据写入http response res。现在尝试运行代码，将打开一个文件资源管理器，您可以指定要存储文件的文件夹。完成后，文件将被下载，并出现在浏览器的底部，如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/5137866e2c71d251e298586a9f7f2865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGJC4VaCn4aMWBa6R5BUbg.png"/></div></div></figure><p id="3bd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="f3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">博客到此为止。我们学习了从前端上传文件。在后端，我们通过一个叫做multer的中间件来处理文件上传，这个中间件可以自动提取文件并按照我们的指定存储它们。它可以为我们过滤某些文件类型。我们还学习了如何通过创建读取文件流并使用管道将该流写入HTTP响应来下载文件。作为参考，可以参考下面git库中的我的代码</p><div class="lm ln ez fb lo lp"><a href="https://github.com/abhirath14/Upload-Download" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">abhirath 14/上传-下载</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">使用multer上传和下载文件这个文件夹有两个目录:客户端和服务器。客户端目录包含…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md jj lp"/></div></div></a></div></div></div>    
</body>
</html>
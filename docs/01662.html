<html>
<head>
<title>Docker for Local Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地方发展码头工人组织</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/docker-for-local-development-1caf04b84e94?source=collection_archive---------12-----------------------#2021-04-19">https://medium.com/geekculture/docker-for-local-development-1caf04b84e94?source=collection_archive---------12-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你使用Docker吗？我打赌你有！这些天Docker是一个非常常见的事情，几乎每个空缺职位都要求有经验的Docker。通常，开发人员编写服务并为其创建Dockerfile，然后将其传递给DevOps团队，以创建CI/CD管道来将其部署到生产和其他环境。但是当地的发展呢？Docker在我的笔记本电脑上能用吗？当然可以。在本文中，我们将介绍Docker在本地开发过程中的基本用例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/95898b4609203656f7cb0b1902cb6539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqkOxvoRYBBXy3IIr9ikzQ.jpeg"/></div></div></figure><p id="a25e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">环境</strong></p><p id="89e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到2015年，我的笔记本电脑上安装了PostgreSQL、MySQL、MongoDB、Redis、Nginx、RabbiqMQ和ElasticSearch。猜猜看，现在我的机器上安装了多少个？答案是零，它们都被替换成了Docker和Docker-Compose。</p><p id="1d01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker-compose使您能够在本地运行所有必要的服务，而无需安装它们。此外，使用Docker-compose，您可以运行任何服务的特定版本，这是非常有用的功能，例如，如果您的一个项目使用MongoDB版，而另一个项目使用4.2版。当然，有很多关于如何安装MongoDB多个版本的指南，但是在docker-compose config中指定需要的版本要容易得多。</p><p id="5dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您有一个用NestJS编写的Node.js后端服务，它使用MongoDB作为数据存储，Redis作为缓存，下面是这个服务的docker-compose.yaml:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="1697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几点我想强调一下:</p><ul class=""><li id="6ba8" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">服务版本必须在docker标签中明确指定。不要使用像<code class="du ka kb kc kd b">redis:6</code>这样的快捷标签。次要版本和补丁版本很重要！版本必须是固定的，并且与生产环境中的版本相同。您很容易面临与特定服务版本相关的错误。注意这一点，任何版本更新甚至补丁都必须测试。</li><li id="8515" class="jr js hi ih b ii ke im kf iq kg iu kh iy ki jc jw jx jy jz bi translated">如果可能的话，使用阿尔卑斯山的图像。在这个例子中，Redis镜像基于<code class="du ka kb kc kd b">alpine</code>，但是MongoDB基于<code class="du ka kb kc kd b">bionic</code>，这仅仅是因为MongoDB没有<code class="du ka kb kc kd b">alpine</code>版本。这不是一个必要的要求，更像是一个建议，但是它可以节省你的硬盘空间。您可以查看DockerHub上的可用标签列表，Redis image的示例链接<a class="ae kj" href="https://hub.docker.com/_/redis?tab=tags&amp;page=1&amp;ordering=last_updated" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/redis?tab=tags&amp;page = 1&amp;ordering = last _ updated</a></li><li id="7dca" class="jr js hi ih b ii ke im kf iq kg iu kh iy ki jc jw jx jy jz bi translated">将卷用于持久服务。在这个例子中，MongoDB已经挂载了卷，而Redis没有。Redis是内存存储，我们将其用作缓存存储，因此它不需要持久磁盘存储。但是如果您将Redis配置为持久的，那么您也必须将一个卷挂载到它的映像中。</li></ul><p id="fd28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">跑步app </strong></p><p id="833a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们已经拥有了启动Node.js服务所需的一切，只需在终端中键入<code class="du ka kb kc kd b">npm start:debug</code>就可以了。稍等一下，会用什么Node.js版本？安装在你系统里的那个。但是如果我们有几个不同主要Node.js版本的项目该怎么办呢？将所有项目升级到当前的LTS Node.js版本可能会很困难，并会导致一些意外的错误。</p><p id="f832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Node.js版本切换的工具有NVM<a class="ae kj" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank">https://github.com/nvm-sh/nvm</a>或者<code class="du ka kb kc kd b">n</code>T16】https://www.npmjs.com/package/n之类的。我真的很喜欢<code class="du ka kb kc kd b">n</code>，它是一个npm包，非常容易安装和使用。但我们的应用仍将取决于当地环境。如果我们把docker也放进去呢？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/408133a3d2b39f41d60438ec3ee7003f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PwZBg21lpqiv-7AQB3y-g.jpeg"/></div></div></figure><p id="ffac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于NestJS应用程序，Dockerfile看起来像这样:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="1da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在本地运行？在每次代码更改时构建它？这毫无意义。</p><p id="3a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我们需要引入一个新概念——Docker image for development。你可以为一个服务创建任意多的Docker图片，这是完全合法的。Docker镜像必须满足其要求，对于生产，它应该是苗条的，对于开发，它应该支持调试模式和实时重载。不要试图编写通用Docker映像，只需创建它的新版本。让我们将我们的应用程序添加到docker-compose配置中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="0b06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是怎么回事:</p><ul class=""><li id="e1a1" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">用<code class="du ka kb kc kd b">image</code>我们已经定义了Node.js版本</li><li id="1d2e" class="jr js hi ih b ii ke im kf iq kg iu kh iy ki jc jw jx jy jz bi translated">在<code class="du ka kb kc kd b">ports</code>中包含Node.js服务的http端口<code class="du ka kb kc kd b">3000</code>和Node.js调试的标准端口<code class="du ka kb kc kd b">9229</code>。你可以很容易地从你的IDE或者谷歌Chrome开发者工具连接到它。</li><li id="0547" class="jr js hi ih b ii ke im kf iq kg iu kh iy ki jc jw jx jy jz bi translated">在<code class="du ka kb kc kd b">volumes</code>中，我们已经将当前项目目录挂载到docker的<code class="du ka kb kc kd b">workdir</code></li><li id="80ea" class="jr js hi ih b ii ke im kf iq kg iu kh iy ki jc jw jx jy jz bi translated"><code class="du ka kb kc kd b">command</code>指示Docker执行什么。<code class="du ka kb kc kd b">npm run start:debug</code>是一个由NestJS编写的npm脚本，用于在调试模式下运行带有实时重载的app</li></ul><p id="b9cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们采用了纯Node.js映像，用<code class="du ka kb kc kd b">node_modules</code>挂载了我们的代码，并说要执行哪个命令。我们甚至还没有创建一个新的<code class="du ka kb kc kd b">Dockerfile</code>，所有的改变都是在<code class="du ka kb kc kd b">docker-compose.yaml</code>中完成的。通过运行以下命令，可以在docker中更好地安装额外的npm软件包:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="4d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是更安全的方式，因为一些包可能包含C++库的绑定，它们在安装过程中被编译。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="5ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这个主题并没有完全涵盖，有太多的案例和大量的Docker和Docker-Compose特性。我已经成功地将这种技术用于Node.js和Golang的后端开发，以及VueJS和React的前端开发。我敢打赌，您也可以将它用于您的堆栈，以自动化您的开发过程，并保护它免受由环境不匹配引起的意外错误的影响。</p><p id="826e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下次见，servus！</p></div></div>    
</body>
</html>
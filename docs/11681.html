<html>
<head>
<title>Why is Flutter Fast? — Part 3: Rendering Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Flutter很快？—第3部分:渲染管道</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-is-flutter-fast-part-3-rendering-pipeline-3a31056355e5?source=collection_archive---------0-----------------------#2022-04-04">https://medium.com/geekculture/why-is-flutter-fast-part-3-rendering-pipeline-3a31056355e5?source=collection_archive---------0-----------------------#2022-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5c8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在许多情况下，使用Flutter SDK中包含的一组小部件就足以为最终用户提供良好的用户体验。然而，现代应用程序的发展趋势是，设计者和用户需要更富动感、高度可定制的UI组件。由于<em class="jd">像素驱动的架构</em>，而不是依赖于平台中可用的小部件，Flutter的目标是在同一级别的所有平台上实现高UI可定制性和一致性[ <a class="ae je" href="https://docs.flutter.dev/resources/faq#does-flutter-use-my-operating-systems-built-in-platform-widgets" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]。</p><p id="0881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信高效地实现丰富和高质量的UI组件需要很好地理解Flutter框架是如何工作的。这就是为什么<a class="ae je" href="https://www.youtube.com/watch?v=Y9Az2p06yTs" rel="noopener ugc nofollow" target="_blank">我在</a><a class="ae je" href="https://fluttervikings.com/" rel="noopener ugc nofollow" target="_blank"> Flutter Vikings会议</a> <em class="jd">上的演讲“从运动设计规范到Flutter代码</em>”从解释Flutter的渲染管道开始。</p><p id="3a58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">渲染管道不是一个特定于Flutter的术语。在计算机图形学中，它用于定义一个模型，该模型由渲染对象以产生一帧的连续步骤组成。渲染管道的最终结果是我们在窗口中看到的像素。</p><p id="6d56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于渲染管道是一个非常详细的主题，我们将在本文中只提到一部分。要了解更多详细信息，我建议阅读来自<a class="ae je" href="https://community.alibabacloud.com/users/5040995529404844?spm=a2c65.11461447.0.0.160b6fb8EnLzbf" rel="noopener ugc nofollow" target="_blank">阿里巴巴Clouder </a>的<a class="ae je" href="https://www.alibabacloud.com/blog/exploration-of-the-flutter-rendering-mechanism-from-architecture-to-source-code_597285" rel="noopener ugc nofollow" target="_blank">这篇综合博客文章</a>，并观看来自Adam Barth的著名<a class="ae je" href="https://youtu.be/UUfXWzp0-DU" rel="noopener ugc nofollow" target="_blank">演讲</a>、<em class="jd"> Flutter的渲染管道</em>。</p><ul class=""><li id="a325" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated"><a class="ae je" href="https://ulusoyca.medium.com/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47" rel="noopener">第1部分:次线性建筑</a></li><li id="a640" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">第二部分:分层架构</li><li id="4de7" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><strong class="ih hj">第三部分:渲染管道</strong></li></ul><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="6aa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为Flutter应用程序开发人员，我们在渲染管道中的角色很少:</p><ol class=""><li id="6825" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc ka jl jm jn bi translated">构建一个部件树，并在构建阶段将其提供给框架。</li><li id="c4da" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated">当我们想要更新UI时，让框架知道哪些小部件需要被标记为<em class="jd">“需要构建”</em>。例如，通过用手势事件调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" rel="noopener ugc nofollow" target="_blank">StatefulWidget</a></code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>方法，我们隐式地将小部件标记为需要构建，并将其对应的元素标记为下一帧的脏元素。</li></ol><h1 id="1e13" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">UI工具包的性能</h1><p id="559d" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在移动应用开发的早期，为用户准备一个足够快的UI是主要考虑的事情。随着设备获得更多的计算能力，性能目标转移到不同的领域，例如:</p><ul class=""><li id="8a20" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated">有效地使用设备资源，使得设备在UI线程中呈现期间有足够的资源来执行后台任务</li><li id="5637" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">每秒绘制60或120帧的流畅动画性能，绘制一帧需要16或8毫秒。</li><li id="0524" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">优化设备中处理器的使用，从而降低绘制帧所消耗的能量，并因此节省电池。</li></ul><blockquote class="li"><p id="c8be" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">“几十年来，脏区管理一直是UI框架的主要内容，但从早期在主频为MHz的芯片上进行CPU渲染到现代在几乎任何设备上进行GHz GPU渲染，技术水平已经发生了很大变化。<a class="ae je" href="https://docs.google.com/document/d/19WDvGJql1bmnECTdEzJFeH9Ixw4AP2R7JlgujBSbDbk/edit#" rel="noopener ugc nofollow" target="_blank">【7</a>]</p></blockquote><p id="508d" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">实现这些目标需要高效的UI渲染算法和良好的脏区管理。Flutter framework已经有很好的解决方案来防止渲染管道不同阶段不必要的计算，我们将在本文中提到。然而，小组意识到仍有改进的余地。例如，在本文档的<a class="ae je" href="https://docs.google.com/document/d/19WDvGJql1bmnECTdEzJFeH9Ixw4AP2R7JlgujBSbDbk/edit#" rel="noopener ugc nofollow" target="_blank">中，你可以读到关于最小化每帧重画区域的讨论。</a></p><h1 id="7ab1" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">runApp</h1><p id="4c58" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">当我在撰写这一系列文章时，我注意到了来自Flutter团队的Andrew Fitz Gibbon的<a class="ae je" href="https://youtu.be/e5RhcvWqJAo" rel="noopener ugc nofollow" target="_blank">这个很棒的视频</a> <em class="jd">“了解runApp函数】</em>。当我试图弄清楚这个框架是如何工作的时候，看到他像我一样探索源代码真是太棒了。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="22c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flutter应用程序开发人员通过调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/runApp.html" rel="noopener ugc nofollow" target="_blank">runApp</a></code>方法开始使用widgets层。这是启动Flutter应用程序的方法。这种方法完成了两件重要的事情:</p><ol class=""><li id="5708" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc ka jl jm jn bi translated">作为参数提供给<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/runApp.html" rel="noopener ugc nofollow" target="_blank">runApp</a></code>方法的根小部件被附加到小部件树的<strong class="ih hj">顶部</strong>。对于初始构建，它是一个线性的<strong class="ih hj">自顶向下的</strong>过程，在<a class="ae je" href="https://ulusoyca.medium.com/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47" rel="noopener"> <em class="jd">第一篇</em> </a>中作为<strong class="ih hj">案例5 </strong>提到了所有的<code class="du kb kc kd ke b"><a class="ae je" href="https://medium.com/r?url=https%3A%2F%2Fapi.flutter.dev%2Fflutter%2Fwidgets%2FElement%2FupdateChild.html" rel="noopener">updateChild</a></code>方法调用。在这种情况下，当所有的小部件在小部件树中展开时，它们相应的元素和渲染对象被创建。</li><li id="702a" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated">颤振框架层和引擎层借助<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>类绑定。这个单例类在<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/runApp.html" rel="noopener ugc nofollow" target="_blank">runApp</a></code>方法中初始化。它包含渲染管道的两个重要的管理器类:<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>和<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>。</li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/0bb28c8a17fc77862f656ab07e3be882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IndPyqXb52XkXWjBTQ8SkQ.png"/></div></div></figure><p id="8c49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>类看起来像框架中的God对象，但它实现了许多单例混合来分离实现中的关注点。每个mixin都是引擎和框架之间的粘合剂，具有特定的职责。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es me"><img src="../Images/b24548d19a02f5f230a10878d0d64781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Afp-KYxqBPMZzE0VK36F8A.png"/></div></div></figure><ul class=""><li id="a3fa" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/gestures/GestureBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">GestureBinding</a></code>是手势识别器的绑定。</li><li id="b3c4" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/scheduler/SchedulerBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">SchedulerBinding</a></code>是调度器帧回调的绑定，比如瞬态回调、持久回调、帧后回调和帧间非渲染任务。它确保任务仅在适当的时候运行。</li><li id="fa7b" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/services/ServicesBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">ServicesBinding</a></code>是针对<a class="ae je" href="https://api.flutter.dev/flutter/services/services-library.html" rel="noopener ugc nofollow" target="_blank">平台特定服务</a>的绑定，暴露于框架层。</li><li id="741d" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/painting/PaintingBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">PaintingBinding</a></code>是为Flutter <a class="ae je" href="https://api.flutter.dev/flutter/painting/painting-library.html" rel="noopener ugc nofollow" target="_blank">画库</a>绑定的，该画库封装了引擎的绘画API。</li><li id="a994" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/semantics/SemanticsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">SemanticsBinding</a></code>是<a class="ae je" href="https://api.flutter.dev/flutter/semantics/semantics-library.html" rel="noopener ugc nofollow" target="_blank">语义层</a>和引擎的绑定。</li><li id="a6ba" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">WidgetsBinding</a></code>是widget树和引擎之间的绑定。这是<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>开始和结束构建阶段的mixin。</li><li id="2690" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RendererBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">RendererBinding</a></code>是渲染树和引擎之间的绑定。这就是mixin，<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>在构建阶段的开始和结束之间执行渲染管道阶段。</li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mf"><img src="../Images/e6190b55c20f74f012d063dba8ce2f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJFOKJrqxd-TlXvgYM2Ssg.png"/></div></div></figure><h1 id="125c" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">拉伸机</h1><p id="00d1" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">当需要制作和布局一个帧时，引擎调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>类上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding/drawFrame.html" rel="noopener ugc nofollow" target="_blank">drawFrame</a></code>方法，这将启动构建阶段的渲染管道。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/b07c2286a00f07bfa4d7476f041fcfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*we-817u0aILiFkLCVjHbQw.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Image taken from <a class="ae je" href="https://www.alibabacloud.com/blog/exploration-of-the-flutter-rendering-mechanism-from-architecture-to-source-code_597285" rel="noopener ugc nofollow" target="_blank">alibabacloud blog</a></figcaption></figure><p id="b446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">渲染管道的输出是层树，该层树在CPU中运行的光栅线程中消耗，用于光栅化和合成。这个线程之前被Flutter团队命名为GPU线程，但后来被重命名为raster thread，因为它会产生误导，给人一种它是在GPU中运行的印象。Skia在光栅线程上运行，最终输出被翻译成GPU渲染指令，以在屏幕上绘制像素。</p><p id="dc84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>是<em class="jd">小部件树</em>的管理器类。通过调用<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/BuildOwner/scheduleBuildFor.html" rel="noopener ugc nofollow" target="_blank">scheduleBuildFor</a></code>方法，需要构建的元素被添加到<strong class="ih hj">脏元素</strong>列表中。</p><p id="79c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>是<em class="jd">渲染树</em>的管理器类。在构建阶段之后，它存储布局、合成位、绘制和渲染管道的语义阶段的脏状态。例如，如果一个<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>在布局阶段被标记为脏的，那么在渲染帧的过程中为那个<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>计算布局。</p><blockquote class="li"><p id="4b6e" class="lj lk hi bd ll lm ml mm mn mo mp jc dx translated">“任何时候渲染对象上的任何变化都会影响该对象的布局，它应该调用<a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject/markNeedsLayout.html" rel="noopener ugc nofollow" target="_blank"> markNeedsLayout </a>。”[ <a class="ae je" href="https://docs.flutter.dev/resources/inside-flutter" rel="noopener ugc nofollow" target="_blank"> 6 </a></p></blockquote><figure class="mr ms mt mu mv jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mq"><img src="../Images/5373ddc1d0129d69b130853eab2ae030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-vz62DCiRdxXRFNB0Xx5g.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">list of dirty render objects in PipelineOwner</figcaption></figure><h1 id="8cbf" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">单程布局</h1><p id="a860" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在颤振中，布局阶段是单向的:<strong class="ih hj"> <em class="jd">自上而下</em></strong><strong class="ih hj"><em class="jd">一遍</em> </strong>。父级<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>调用子级渲染对象的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject/layout.html" rel="noopener ugc nofollow" target="_blank">layout</a></code>方法，为它们提供约束:<em class="jd">最大宽度</em>、<em class="jd">最小宽度</em>、<em class="jd">最大高度、</em>和<em class="jd">最小高度</em>值。</p><blockquote class="li"><p id="7063" class="lj lk hi bd ll lm ml mm mn mo mp jc dx translated">"颤振每帧执行一个布局."[ <a class="ae je" href="https://docs.flutter.dev/resources/inside-flutter" rel="noopener ugc nofollow" target="_blank"> 6 </a></p></blockquote><p id="c608" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">与构建阶段一样，布局阶段最初也具有线性性能，随后具有次线性性能。每个子节点<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>被访问，并且在布局过程中仅返回其尺寸<strong class="ih hj">一次</strong>，直到下一帧。儿童无权超越规定的限制来调整自己的大小。</p><blockquote class="li"><p id="3ad3" class="lj lk hi bd ll lm ml mm mn mo mp jc dx translated">“约束下去。尺寸会变大。父设置位置。[ <a class="ae je" rel="noopener" href="/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2"> 2 </a> ]</p></blockquote><p id="787d" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">父<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>访问并且<strong class="ih hj">将渲染树</strong>中的 <strong class="ih hj">约束</strong> <strong class="ih hj">向下逐个传递给其子<strong class="ih hj"/>。例如，让我们考虑一个有两个子节点的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/Flex-class.html" rel="noopener ugc nofollow" target="_blank">Flex</a></code>布局的父节点:一个灵活的子节点和一个不灵活的子节点。在这种情况下，父母首先布局不灵活的孩子。布局的子节点<strong class="ih hj">将其在渲染树</strong>中的大小传递给父节点<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>。之后，家长为灵活的孩子计算自由空间。最后，灵活的子对象将根据剩余空间接收其约束，并将其在渲染树中的大小返回给父对象<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" rel="noopener ugc nofollow" target="_blank">RenderObject</a></code>。</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mw"><img src="../Images/8b0805ff65bf14b1cdf5157aadb4491e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7B6E_ROL2vDyfE4Fihk_Q.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Constraints &amp; Size direction in Flutter</figcaption></figure><blockquote class="li"><p id="51eb" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">在布局过程中，从父对象流向子对象的唯一信息是约束，从子对象流向父对象的唯一信息是几何图形[ <a class="ae je" href="https://docs.flutter.dev/resources/inside-flutter" rel="noopener ugc nofollow" target="_blank"> 6 </a></p></blockquote><p id="ebb5" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在Flutter中，子对象的定位由父对象独立于布局过程进行控制，并且不能在布局所有子对象之前完成。一些渲染对象尽可能晚地进行定位。甚至在某些情况下，定位是在<em class="jd">喷漆阶段</em>完成的。</p><p id="e103" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到在不同平台上如何实现，在构建和布局阶段使用单遍算法的次线性性能是一个重要的优化。例如，绘制布局对于原生Android应用程序来说是两遍过程:<a class="ae je" href="https://developer.android.com/reference/android/view/View#measure(int,%20int)" rel="noopener ugc nofollow" target="_blank"> <em class="jd">测量</em> </a>遍和<a class="ae je" href="https://developer.android.com/reference/android/view/View#layout(int,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank"> <em class="jd">布局</em> </a>遍。在<em class="jd">度量</em>过程中，父视图调用子视图上的<code class="du kb kc kd ke b"><a class="ae je" href="https://developer.android.com/reference/android/view/View#measure(int,%20int)" rel="noopener ugc nofollow" target="_blank">measure</a></code>方法，以找出子视图在给定约束内应该有多大。当此方法从子视图返回时，子视图及其所有子视图将测量自身。根据不同的情况，父类可能不止一次调用子类的<code class="du kb kc kd ke b"><a class="ae je" href="https://developer.android.com/reference/android/view/View#measure(int,%20int)" rel="noopener ugc nofollow" target="_blank">measure</a></code>方法。例如，在第一次呼叫中，父母知道如果没有约束，孩子们想要变得多大或多小。然后，在第二次调用中，父节点提供实际的约束。当<a class="ae je" href="https://developer.android.com/reference/android/view/View#measure(int,%20int)" rel="noopener ugc nofollow" target="_blank"> <em class="jd">测量</em> </a>走刀完成时<em class="jd">布局走刀</em>开始。在这个过程中，父母根据他们想要的尺寸给他们的孩子定位。</p><h1 id="1f22" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">用例子总结</h1><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mx"><img src="../Images/4b9e00b309eafca3eceeafccbedc0d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wospSd_PmI3lYZAmIr9GRw.png"/></div></div></figure><p id="e5a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个例子来总结我们在这一系列文章中学到的东西。在上面的小部件树中，我们有根小部件<code class="du kb kc kd ke b">A</code>，它有两个子部件:小部件<code class="du kb kc kd ke b">B</code>和有状态小部件<code class="du kb kc kd ke b">C</code>。在小部件<code class="du kb kc kd ke b">C</code>的<code class="du kb kc kd ke b">State</code>对象中，我们通过在顶部提供一个子小部件<code class="du kb kc kd ke b">E</code>来声明一个小部件子树。</p><h2 id="34f6" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">污染树木</h2><p id="62fa" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">假设小部件<code class="du kb kc kd ke b">E</code>的子小部件<code class="du kb kc kd ke b">F</code>是一个<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">GestureDetector</a></code>小部件，我们在它的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/GestureDetector/onTap.html" rel="noopener ugc nofollow" target="_blank">onTap</a></code>回调方法上调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>方法。在这种情况下，元素<code class="du kb kc kd ke b">C</code>将被标记为需要构建，因为在它的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象内部调用了<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>方法。因此，在新帧开始之前，元素<code class="du kb kc kd ke b">C</code>将被添加到脏元素列表中。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es nm"><img src="../Images/f93aabc380e03c9d259ad92dd0c54132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vL-G4j3BxySK0I5q3_mvJQ.png"/></div></div></figure><p id="66ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们更深入地了解一下“泥土”的含义。小部件<code class="du kb kc kd ke b">C</code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">State</a></code>对象可以访问其永久关联的元素<code class="du kb kc kd ke b">C</code>。当在这个状态对象上调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/State/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>方法时，它将调用元素<code class="du kb kc kd ke b">C</code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/Element/markNeedsBuild.html" rel="noopener ugc nofollow" target="_blank">markNeedsBuild</a></code>方法。在这个方法中，<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>类将为元素<code class="du kb kc kd ke b">C</code>安排一个构建。</p><p id="2b4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过调用元素<code class="du kb kc kd ke b">C</code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/BuildOwner/scheduleBuildFor.html" rel="noopener ugc nofollow" target="_blank">scheduleBuildFor</a></code>方法，该元素将被添加到<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>类跟踪的脏元素列表中。这些脏元素将在下一帧中被清除。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es nn"><img src="../Images/07147e5bf76f389a575159d9ca867960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2jNkUUDKIHsYTxV38BaBw.png"/></div></div></figure><h2 id="b078" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">绘制新框架</h2><p id="e514" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">当在<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>上调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding/drawFrame.html" rel="noopener ugc nofollow" target="_blank">drawFrame</a></code>方法时，下一帧的渲染管道开始。</p><p id="025a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过调用<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/BuildOwner/buildScope.html" rel="noopener ugc nofollow" target="_blank">buildScope</a></code>方法，在<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>实例的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">WidgetsBinding</a></code> mixin中触发构建阶段。在这个方法中，所有脏元素都是一个接一个地重新构建的。</p><h2 id="8924" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">更新子元素</h2><p id="ad13" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在是时候让元素<code class="du kb kc kd ke b">C</code>通过调用它们的<code class="du kb kc kd ke b"><a class="ae je" href="https://medium.com/r?url=https%3A%2F%2Fapi.flutter.dev%2Fflutter%2Fwidgets%2FElement%2FupdateChild.html" rel="noopener">updateChild</a></code>方法来检查它的子元素了。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="ab fe cl no"><img src="../Images/783991f0ef1b67c9c90aef640a84c430.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tVuoRGO50LxrAoNCh68qIg.png"/></div></figure><h2 id="ee82" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">案例3 — canUpdate返回true</h2><p id="4459" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在第一个槽中，检查元素<code class="du kb kc kd ke b">E</code>。看起来那个槽的新窗口小部件的运行时类型又是<code class="du kb kc kd ke b">E</code>，让我们假设新旧窗口小部件<code class="du kb kc kd ke b">E</code>有相同的键。因此，<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/Widget/canUpdate.html" rel="noopener ugc nofollow" target="_blank">canUpdate</a></code>方法将返回<code class="du kb kc kd ke b">true</code>，元素<code class="du kb kc kd ke b">E</code>和渲染对象<code class="du kb kc kd ke b">E</code>将使用新小部件<code class="du kb kc kd ke b">E</code>描述的新配置进行更新。</p><ul class=""><li id="a5d0" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated">假设在这个版本中，小部件<code class="du kb kc kd ke b">E</code>的宽度或高度是不同的。然后，渲染节点<code class="du kb kc kd ke b">E</code>将通过调用其<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject/markNeedsLayout.html" rel="noopener ugc nofollow" target="_blank">markNeedsLayout</a></code>方法将其自身标记为需要布局。在布局阶段将为当前帧安排视觉更新。</li><li id="d410" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">让我们假设小部件<code class="du kb kc kd ke b">E</code>的不透明度在这个版本中是不同的。然后，渲染节点<code class="du kb kc kd ke b">E</code>将通过调用其<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject/markNeedsPaint.html" rel="noopener ugc nofollow" target="_blank">markNeedsPaint</a></code>方法将其自身标记为需要绘制。在绘制阶段，将为当前帧安排视觉更新。</li><li id="16cc" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">让我们假设为了可访问性的目的，小部件<code class="du kb kc kd ke b">E</code>的语义配置在这个版本中是不同的。然后，渲染节点<code class="du kb kc kd ke b">E</code>将通过调用其<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderObject/markNeedsSemanticsUpdate.html" rel="noopener ugc nofollow" target="_blank">markNeedsSemanticUpdate</a></code>方法将其自身标记为需要语义更新。因此，将在语义阶段为当前帧安排语义更新。</li></ul><p id="61ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，当RenderObject被更新时，对它调用这些<code class="du kb kc kd ke b">needs</code>方法是可选的。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es np"><img src="../Images/63736f0bea40ba07975227d23d50465f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M90Cl2oJ-OpNOJxilYwOxQ.png"/></div></div></figure><h2 id="2ca0" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">案例5 —膨胀部件</h2><p id="f671" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">与之前的构建阶段不同，元素<code class="du kb kc kd ke b">C</code>的下一个槽不再是空的。有一个新的小部件(<code class="du kb kc kd ke b">Y</code>)作为元素<code class="du kb kc kd ke b">C</code>的直接子元素。在这种情况下，父元素<code class="du kb kc kd ke b">C</code>将膨胀小部件<code class="du kb kc kd ke b">Y</code>，并为新创建的元素<code class="du kb kc kd ke b">Y</code>分配一个新的槽。还将实例化新的呈现对象Y。</p><h2 id="0430" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">案例4 — canUpdate返回false</h2><p id="a530" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在是元素<code class="du kb kc kd ke b">E</code>访问其子元素的时候了。在最后的构建阶段，元素<code class="du kb kc kd ke b">E</code>的第一个插槽中有元素<code class="du kb kc kd ke b">F</code>。在当前的构建阶段，它有一个新的小部件，该小部件有一个不同的运行时类型(<code class="du kb kc kd ke b">Z</code>)。因此，<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/Widget/canUpdate.html" rel="noopener ugc nofollow" target="_blank">canUpdate</a></code>方法将返回<code class="du kb kc kd ke b">false</code>，元素<code class="du kb kc kd ke b">F</code>将被设置为不活动，小部件<code class="du kb kc kd ke b">Z</code>将被膨胀，元素<code class="du kb kc kd ke b">Z</code>和渲染对象<code class="du kb kc kd ke b">Z</code>将被实例化。</p><h2 id="b198" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">案例2——建筑走道的切割</h2><p id="5547" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在元素<code class="du kb kc kd ke b">E</code>的下一个槽中，我们有一个带有<code class="du kb kc kd ke b">const</code>构造函数的小部件G。我们假设它的构造函数参数也是<code class="du kb kc kd ke b">const</code>变量。然后小部件G子树的构建遍历将停止，因为小部件G是一个<code class="du kb kc kd ke b">const</code>小部件，元素G将被重用而无需更新。</p><h2 id="a67c" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">案例1 —停用未使用的</h2><p id="b0c2" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">元件<code class="du kb kc kd ke b">Z</code>的构建走查继续进行。它将检查旧的子元素的槽。与先前的构建不同，在当前的构建中没有这些插槽的子部件。因此，这将是<strong class="ih hj">情况1 </strong>，其中元素<code class="du kb kc kd ke b">H</code>和元素<code class="du kb kc kd ke b">I</code>将被设置为非活动的，并且它们相应的元素和渲染节点将从树中移除。</p><h2 id="7756" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">该冲水了</h2><p id="2c41" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">现在构建阶段已经在<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">WidgetsBinding</a></code>中完成，我们已经访问了脏部件的所有子树。是时候刷新<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RendererBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">RendererBinding</a></code>中的布局、合成位、绘画和语义了！</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es nq"><img src="../Images/01ad2ef69201517058989d931df39cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*LbIjtmRCoP96T5dt"/></div></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es nr"><img src="../Images/984bc1cf3d12c8aa7b8fc1a5f557800f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3yUF1FcDNxh0dZxMOT-vw.png"/></div></div></figure><p id="65c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构建阶段之后，渲染管道继续进行<em class="jd">布局</em> <em class="jd">阶段</em>。这个阶段从调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html" rel="noopener ugc nofollow" target="_blank">WidgetsFlutterBinding</a></code>实例的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RendererBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">RendererBinding</a></code> mixin中的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner/flushLayout.html" rel="noopener ugc nofollow" target="_blank">flushLayout</a></code>方法开始。在此阶段，渲染树中的所有脏渲染对象将为自己计算几何体，以便它们的计算大小在下一阶段保持最新。</p><p id="699f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">合成位阶段</em>跟随布局阶段，从调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner/flushCompositingBits.html" rel="noopener ugc nofollow" target="_blank">flushCompositingBits</a></code>方法开始。这个阶段是关于渲染对象中的图层管理。我建议深入研究这篇关于在Flutter中合成比特的惊人文章。</p><blockquote class="li"><p id="746b" class="lj lk hi bd ll lm ml mm mn mo mp jc dx translated">在框架的上下文中，合成通常是指将渲染对象分配给与绘画相关的层[4]</p></blockquote><p id="a97e" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">通过调用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html" rel="noopener ugc nofollow" target="_blank">PipelineOwner</a></code>的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/PipelineOwner/flushPaint.html" rel="noopener ugc nofollow" target="_blank">flushPaint</a></code>方法，在<em class="jd">合成位阶段</em>之后开始<em class="jd">绘制</em> <em class="jd">阶段</em>。在这个阶段，所有脏的渲染对象都用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawLine.html" rel="noopener ugc nofollow" target="_blank">drawLine</a></code>、<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/dart-ui/Canvas/clipRect.html" rel="noopener ugc nofollow" target="_blank">clipRect</a></code>、<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/dart-ui/Canvas/rotate.html" rel="noopener ugc nofollow" target="_blank">rotate</a></code>、<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/dart-ui/Canvas/transform.html" rel="noopener ugc nofollow" target="_blank">transform</a></code>等方法绘制到一个<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/dart-ui/Canvas-class.html" rel="noopener ugc nofollow" target="_blank">Canvas</a></code>上。此阶段执行的绘图将在层树的节点中合成。</p><blockquote class="li"><p id="6baa" class="lj lk hi bd ll lm ml mm mn mo mp jc dx translated">"<code class="du kb kc kd ke b">Canvas</code>表示支持许多绘图操作的图形上下文."[5]</p></blockquote><p id="f31d" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在绘制阶段结束时，所有的绘制指令都存储在层树中。然后，是时候调用根对象上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderView/compositeFrame.html" rel="noopener ugc nofollow" target="_blank">compositeFrame</a></code>了，它也被称为<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/rendering/RenderView-class.html" rel="noopener ugc nofollow" target="_blank">renderView</a></code>。在光栅线程中提交图层树之后，具有脏语义的渲染对象将被更新。语义事件侦听器(如操作系统的可访问性系统)将被告知UI更改。</p><h2 id="ccb8" class="my kg hi bd kh mz na nb kl nc nd ne kp iq nf ng kt iu nh ni kx iy nj nk lb nl bi translated">最终确定版本</h2><p id="ff68" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在第一篇文章中，我们提到了作为<strong class="ih hj">案例1 </strong>和<strong class="ih hj">案例4 </strong>中<code class="du kb kc kd ke b"><a class="ae je" href="https://medium.com/r?url=https%3A%2F%2Fapi.flutter.dev%2Fflutter%2Fwidgets%2FElement%2FupdateChild.html" rel="noopener">updateChild</a></code>方法调用的结果的非活动子元素。当前帧的渲染管道以调用<code class="du kb kc kd ke b"><a class="ae je" href="https://kikt.gitee.io/flutter-doc/widgets/BuildOwner-class.html" rel="noopener ugc nofollow" target="_blank">BuildOwner</a></code>类上的<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/BuildOwner/finalizeTree.html" rel="noopener ugc nofollow" target="_blank">finalizeTree</a></code>结束。在该方法中，在绘制同一帧的过程中，树中未被重用的非活动子元素被移除，并且它们的资源被清除。在我们的例子中，我们在构建阶段没有做任何<a class="ae je" href="https://docs.flutter.dev/resources/inside-flutter#tree-surgery" rel="noopener ugc nofollow" target="_blank"> <em class="jd">树操作</em> </a>。因此，元素<code class="du kb kc kd ke b">F</code>、<code class="du kb kc kd ke b">H</code>和<code class="du kb kc kd ke b">I</code>将被卸载。</p><h1 id="ccc3" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="6fcf" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">在这一部分，我们解释了Flutter的渲染管道，并介绍了在窗口上绘制框架的步骤。这听起来可能是一个复杂的话题，但我相信渲染管道中最重要的学习阶段是构建、布局和绘制。理解这些步骤将有助于我们充分利用小部件库。例如，我们可以利用<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/CustomSingleChildLayout-class.html" rel="noopener ugc nofollow" target="_blank">CustomSingleChildLayout</a></code>和<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/CustomMultiChildLayout-class.html" rel="noopener ugc nofollow" target="_blank">CustomMultiChildLayout</a></code>来定制布局逻辑，同时留在小部件层。另一个例子是<code class="du kb kc kd ke b"><a class="ae je" href="https://api.flutter.dev/flutter/widgets/Flow-class.html" rel="noopener ugc nofollow" target="_blank">Flow</a></code>小部件，它使我们能够添加在绘制阶段执行的逻辑。</p><p id="71b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是本系列的最后一篇文章。我希望这有助于理解框架的内部。让我们再次感谢这项技术背后的杰出工程师。特别感谢<a class="ae je" href="https://twitter.com/adambarth" rel="noopener ugc nofollow" target="_blank">亚当·巴斯</a>、<a class="ae je" href="https://twitter.com/_eseidel" rel="noopener ugc nofollow" target="_blank">埃里克·塞德尔</a>、<a class="ae je" href="https://github.com/Hixie" rel="noopener ugc nofollow" target="_blank">伊恩·希克森·希谢</a>，以及整个Flutter团队为大家提供了非常棒的文档和培训材料。</p><p id="248b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">把话传出去，和Flutter待在一起！</p><h1 id="911a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">参考</h1><ol class=""><li id="781b" class="jf jg hi ih b ii ld im le iq ns iu nt iy nu jc ka jl jm jn bi translated">FAQ，<a class="ae je" href="https://docs.flutter.dev/resources/faq#does-flutter-use-my-operating-systems-built-in-platform-widgets" rel="noopener ugc nofollow" target="_blank"> docs.flutter.dev </a></li><li id="27d5" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated"><a class="ae je" rel="noopener" href="/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2">扑动:即使是初学者也必须知道的高级布局法则</a>、<a class="nv nw ge" href="https://medium.com/u/c2db527bc802?source=post_page-----3a31056355e5--------------------------------" rel="noopener" target="_blank">马塞洛·格莱斯伯格</a>。</li><li id="f625" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated"><a class="ae je" href="https://developer.android.com/guide/topics/ui/how-android-draws" rel="noopener ugc nofollow" target="_blank">Android如何绘制视图</a></li><li id="f599" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated">合成，<a class="ae je" href="https://flutter.megathink.com/rendering/compositing" rel="noopener ugc nofollow" target="_blank">flutter.megathink.com</a></li><li id="016f" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated">画，<a class="ae je" href="https://flutter.megathink.com/rendering/painting" rel="noopener ugc nofollow" target="_blank">flutter.megathink.com</a></li><li id="7c6f" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated"><a class="ae je" href="https://docs.flutter.dev/resources/inside-flutter" rel="noopener ugc nofollow" target="_blank">内部颤动</a></li><li id="80e1" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc ka jl jm jn bi translated"><a class="ae je" href="https://docs.google.com/document/d/19WDvGJql1bmnECTdEzJFeH9Ixw4AP2R7JlgujBSbDbk/edit#" rel="noopener ugc nofollow" target="_blank">肮脏区域管理</a></li></ol></div></div>    
</body>
</html>
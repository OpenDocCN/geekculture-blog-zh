<html>
<head>
<title>Solve HankerRank Breadth-First Search: Shortest Reach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解HankerRank广度优先搜索:最短距离</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/solve-hankerrank-breadth-first-search-shortest-reach-6977f52174f2?source=collection_archive---------7-----------------------#2022-12-07">https://medium.com/geekculture/solve-hankerrank-breadth-first-search-shortest-reach-6977f52174f2?source=collection_archive---------7-----------------------#2022-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a9e6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Java解决HankerRank难题:广度优先搜索:最短到达</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/143e72be09d8dd717db98812ebf65acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l-cG-jLcJ24FUznf"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@martinshreder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Shreder</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="83b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">树和图是基本的数据结构。他们在编码面试中很常见。这里将解决HankerRank广度优先搜索:最短到达和走过如何优化一个图的问题。</p><h2 id="6b7a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题</h2><p id="fad1" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">考虑一个无向图，其中每条边重6个单位。从1到n连续标记每个节点</p><p id="7272" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你将会被问到一些问题。对于每个查询，您将得到一个描述无向图的边列表。在创建了图形表示之后，您必须使用广度优先搜索算法(<a class="ae jn" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank"> BFS </a>)确定并报告从给定起始位置到每个其他节点的最短距离。按照节点编号顺序返回从起始节点开始的距离数组。如果某个节点不可达，则为该节点返回-1。</p><p id="0669" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">功能描述</strong></p><p id="ad04" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在下面的编辑器中完成bfs函数。如果一个节点是不可达的，它的距离是-1。</p><p id="f125" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">bfs具有以下参数:</p><ul class=""><li id="d7ec" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">int n:节点的数量</li><li id="5a1c" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">int m:边的数量</li><li id="c587" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">int edges[m][2]:边的开始和结束节点</li><li id="797d" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">int s:开始遍历的节点</li></ul><p id="888f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Returns <br/> int[n-1]:以节点号递增的顺序到节点的距离，不包括起始节点(如果节点不可达，则为-1)</p><p id="83fb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请在这里看HankerRank原问题。</p><div class="ly lz ez fb ma mb"><a href="https://www.hackerrank.com/challenges/bfsshortreach/problem" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">广度优先搜索:最短距离</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">考虑一个无向图，其中每条边重6个单位。每个节点从1到n被连续标记…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">www.hackerrank.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jh mb"/></div></div></a></div><h2 id="2357" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">解决办法</h2><p id="7ad9" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">这个问题可以分两步解决:构造一个图，然后用BFS搜索。下面就来实现吧。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="b0fb" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'bfs' function below.<br/>     *<br/>     * The function is expected to return an INTEGER_ARRAY.<br/>     * The function accepts following parameters:<br/>     *  1. INTEGER n<br/>     *  2. INTEGER m<br/>     *  3. 2D_INTEGER_ARRAY edges<br/>     *  4. INTEGER s<br/>     */<br/><br/>    public static List&lt;Integer&gt; bfs(int n, int m, List&lt;List&lt;Integer&gt;&gt; edges, int s) {<br/>    // Write your code here<br/>        if (n &lt; 1 || edges == null || edges.size() &lt; 1 || s &lt; 1) return null;<br/><br/>        // Step 1<br/>        Set&lt;Integer&gt; [] tree = new Set[n];<br/>        for (List&lt;Integer&gt; edge : edges) {<br/>            int a = edge.get(0);<br/>            int b = edge.get(1);<br/>            if (tree[a-1] == null) {<br/>                tree[a-1] = new HashSet&lt;Integer&gt;();<br/>            }<br/>            tree[a-1].add(b);<br/>            if (tree[b-1] == null) {<br/>                tree[b-1] = new HashSet&lt;Integer&gt;();<br/>            }<br/>            tree[b-1].add(a);<br/>        }<br/><br/>        // Step 2<br/>        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();<br/>        // O(n^2)<br/>        for (int i = 1; i &lt;= n; i++) {<br/>            if (i == s) continue;<br/>            // find from i to s<br/>            Set&lt;Integer&gt; root = tree[i-1];<br/>            if (root == null) {<br/>                res.add(-1);<br/>                continue; <br/>            }<br/>            Deque&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();<br/>            for (Integer r : root) {<br/>                queue.add(r);<br/>            }<br/>            int height = 1;<br/>            boolean [] visited = new boolean [n];<br/>            while (!queue.isEmpty()) {<br/>                Deque&lt;Integer&gt; queuen = new LinkedList&lt;Integer&gt;();<br/>                boolean found = false;<br/>                while (!queue.isEmpty()) {<br/>                    int v = queue.poll().intValue();<br/>                    if (!visited[v-1]) {<br/>                        visited[v-1] = true;<br/>                        if (v == s) {<br/>                            res.add(height *6);<br/>                            found = true;<br/>                            break;<br/>                        }<br/>                        if (tree[v-1] != null) {<br/>                            for (Integer r : tree[v-1]) {<br/>                                queuen.add(r);<br/>                            } <br/>                        }<br/>                    } <br/>                }<br/>                <br/>                if (found) break;<br/>                queue = queuen;<br/>                height++;<br/>            } <br/>        }<br/>        <br/>        // return res<br/>        return res;<br/>    }<br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        int q = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, q).forEach(qItr -&gt; {<br/>            try {<br/>                String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int n = Integer.parseInt(firstMultipleInput[0]);<br/><br/>                int m = Integer.parseInt(firstMultipleInput[1]);<br/><br/>                List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();<br/><br/>                IntStream.range(0, m).forEach(i -&gt; {<br/>                    try {<br/>                        edges.add(<br/>                            Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))<br/>                                .map(Integer::parseInt)<br/>                                .collect(toList())<br/>                        );<br/>                    } catch (IOException ex) {<br/>                        throw new RuntimeException(ex);<br/>                    }<br/>                });<br/><br/>                int s = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>                List&lt;Integer&gt; result = Result.bfs(n, m, edges, s);<br/><br/>                bufferedWriter.write(<br/>                    result.stream()<br/>                        .map(Object::toString)<br/>                        .collect(joining(" "))<br/>                    + "\n"<br/>                );<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="7a1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">只要遵循一些常见的图形模式，这就很简单了。但是它的时间复杂度是O(n ),并且会使HackerRank硬测试用例失败。所以我们把它优化为O(n)。也就是说，用一个BFS来计算距离。</p><pre class="iy iz ja jb fd mq mr ms bn mt mu bi"><span id="523f" class="mv kl hi mr b be mw mx l my mz">import java.io.*;<br/>import java.math.*;<br/>import java.security.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import java.util.concurrent.*;<br/>import java.util.function.*;<br/>import java.util.regex.*;<br/>import java.util.stream.*;<br/>import static java.util.stream.Collectors.joining;<br/>import static java.util.stream.Collectors.toList;<br/><br/>class Result {<br/><br/>    /*<br/>     * Complete the 'bfs' function below.<br/>     *<br/>     * The function is expected to return an INTEGER_ARRAY.<br/>     * The function accepts following parameters:<br/>     *  1. INTEGER n<br/>     *  2. INTEGER m<br/>     *  3. 2D_INTEGER_ARRAY edges<br/>     *  4. INTEGER s<br/>     */<br/><br/>    public static List&lt;Integer&gt; bfs(int n, int m, List&lt;List&lt;Integer&gt;&gt; edges, int s) {<br/>    // Write your code here<br/>        if (n &lt; 1 || edges == null || edges.size() &lt; 1 || s &lt; 1) return null;<br/><br/>        // Step 1<br/>        Set&lt;Integer&gt; [] tree = new Set[n];<br/>        for (List&lt;Integer&gt; edge : edges) {<br/>            int a = edge.get(0);<br/>            int b = edge.get(1);<br/>            if (tree[a-1] == null) {<br/>                tree[a-1] = new HashSet&lt;Integer&gt;();<br/>            }<br/>            tree[a-1].add(b);<br/>            if (tree[b-1] == null) {<br/>                tree[b-1] = new HashSet&lt;Integer&gt;();<br/>            }<br/>            tree[b-1].add(a);<br/>        }<br/><br/>        // Step 2<br/>        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();<br/>        <br/>        // O(n) start from S<br/>        for (int i = 0; i &lt; n - 1; i++) {<br/>            res.add(-1);    <br/>        }<br/>        <br/>        Set&lt;Integer&gt; root = tree[s-1];<br/>        if (root == null) return res;<br/>        <br/>        Deque&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();<br/>        for (Integer r : root) {<br/>            queue.add(r);<br/>        }<br/>        int height = 1;<br/>        boolean [] visited = new boolean [n];<br/>        visited[s-1] = true;<br/>        while (!queue.isEmpty()) {<br/>            Deque&lt;Integer&gt; queuen = new LinkedList&lt;Integer&gt;();<br/>            while (!queue.isEmpty()) {<br/>                int v = queue.poll().intValue();<br/>                if (!visited[v-1]) {<br/>                    visited[v-1] = true;<br/>                    // update distances<br/>                    if (v &gt; s)<br/>                        res.set(v-2, height*6);<br/>                    else <br/>                        res.set(v-1, height*6);<br/>                    if (tree[v-1] != null) {<br/>                        for (Integer r : tree[v-1]) {<br/>                            queuen.add(r);<br/>                        } <br/>                    }<br/>                } <br/>            }<br/>            queue = queuen;<br/>            height++;<br/>        }<br/>        <br/>        // return res<br/>        return res;<br/>    }<br/><br/>}<br/><br/>public class Solution {<br/>    public static void main(String[] args) throws IOException {<br/>        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));<br/>        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));<br/><br/>        int q = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>        IntStream.range(0, q).forEach(qItr -&gt; {<br/>            try {<br/>                String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");<br/><br/>                int n = Integer.parseInt(firstMultipleInput[0]);<br/><br/>                int m = Integer.parseInt(firstMultipleInput[1]);<br/><br/>                List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();<br/><br/>                IntStream.range(0, m).forEach(i -&gt; {<br/>                    try {<br/>                        edges.add(<br/>                            Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))<br/>                                .map(Integer::parseInt)<br/>                                .collect(toList())<br/>                        );<br/>                    } catch (IOException ex) {<br/>                        throw new RuntimeException(ex);<br/>                    }<br/>                });<br/><br/>                int s = Integer.parseInt(bufferedReader.readLine().trim());<br/><br/>                List&lt;Integer&gt; result = Result.bfs(n, m, edges, s);<br/><br/>                bufferedWriter.write(<br/>                    result.stream()<br/>                        .map(Object::toString)<br/>                        .collect(joining(" "))<br/>                    + "\n"<br/>                );<br/>            } catch (IOException ex) {<br/>                throw new RuntimeException(ex);<br/>            }<br/>        });<br/><br/>        bufferedReader.close();<br/>        bufferedWriter.close();<br/>    }<br/>}</span></pre><p id="d279" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它工作得很好，可以通过如下所有的HackerRank测试用例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/c7b49a6db3d54b61de47dbe44d23d4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8uukXBQp-gEDyUgPpOKUw.png"/></div></div></figure><p id="935d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><p id="a9b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ni">问题、想法？请在下面的回复中留下评论。如果你喜欢解决有趣的问题，请联系我。</em></p></div></div>    
</body>
</html>
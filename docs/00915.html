<html>
<head>
<title>How to Handle API Key Authentication in JsonApiDotNetCore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JsonApiDotNetCore中处理API密钥认证</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/how-to-handle-api-key-authentication-in-jsonapidotnetcore-b21b3ebec467?source=collection_archive---------9-----------------------#2021-03-19">https://medium.com/geekculture/how-to-handle-api-key-authentication-in-jsonapidotnetcore-b21b3ebec467?source=collection_archive---------9-----------------------#2021-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b800" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">保持<strong class="ak">符合</strong>JSON:API<strong class="ak">规范的解决方案。</strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ab879b0662adb9f5c9d1b94b20bdd992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HMWwfXbuXRyqeHo8"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@georgeprentzas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Prentzas</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3e62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated">非常私有或公共的API需要某种形式的认证和授权来保护(某些)资源，防止恶意请求和限制资源使用。</p><p id="dda0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文将结合<strong class="jq hj">开源</strong> <a class="ae jn" href="https://github.com/json-api-dotnet/JsonApiDotNetCore" rel="noopener ugc nofollow" target="_blank"> JsonApiDotNetCore </a>框架重点介绍长期API键的实现。</p><p id="4351" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt"> JsonApiDotNetCore是一个用于构建</em><a class="ae jn" href="https://jsonapi.org" rel="noopener ugc nofollow" target="_blank"><em class="kt">JSON:API</em></a><em class="kt">兼容REST APIs的框架。NET核心和实体框架核心。</em></p><p id="1d85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管我们将只关注API keys方法，但这并不意味着它是每个项目的正确解决方案。API keys方法在软件行业中被广泛使用，但是就安全性而言，它不是最好的方法。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="d01d" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">认证和授权</h1><p id="c3ba" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">身份验证和授权是相辅相成的，但是为了防止混淆，概述两者之间的主要区别是很重要的。</p><h2 id="d3ac" class="ly lc hi bd ld lz ma mb lh mc md me ll jx mf mg ln kb mh mi lp kf mj mk lr ml bi translated">证明</h2><p id="20e7" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">认证的目的是证明你的<strong class="jq hj">身份</strong>。或者换句话说，证明你就是你所说的那个人。</p><p id="1908" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个常见的例子是使用用户名和密码登录网站(如Medium)。在这里输入正确的组合将允许您访问您的帐户。</p><h2 id="46d3" class="ly lc hi bd ld lz ma mb lh mc md me ll jx mf mg ln kb mh mi lp kf mj mk lr ml bi translated">批准</h2><p id="19f2" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">授权步骤的目的是证明您的访问权限。证明你被授权提出某个请求。</p><p id="8084" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，确定您是否有足够的<strong class="jq hj">权限</strong>来编辑网站上的资源(例如，Medium story)。其中足够的权限允许您对资源执行操作。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="eb8f" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">自定义身份验证处理程序</h1><p id="9baf" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">在我最近的一个项目中，我决定使用长期API密匙作为默认的认证方法。与其他身份验证方法(Cookie、JWT和OAuth)相比，API keys方法没有现成的实现。因此，我们必须创建自己的身份验证处理程序。</p><p id="ace5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们从定义身份验证方案选项模型开始。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://gist.github.com/VincentVrijburg/03fd4cf7cf9f5298fabc9924986a0865" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/VincentVrijburg/03fd4cf7cf9f5298fabc9924986a0865</a></figcaption></figure><p id="cb0d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们现在不需要任何自定义选项，但是你可以，例如，将选项从你的<code class="du mo mp mq mr b">appsettings.json</code>传递到这个<code class="du mo mp mq mr b">KeyAuthenticationOptions</code>(例如，在你的<code class="du mo mp mq mr b">Startup.cs</code>中)以便在处理程序中使用它们。</p><p id="4ef0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，在我们实现实际的认证处理程序之前，我们将首先创建一个<code class="du mo mp mq mr b">AuthenticationService</code>来处理认证过程。可以说，这将把数据访问逻辑与我们的身份验证逻辑分离开来。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://gist.github.com/VincentVrijburg/02d54982eeda792163c323e3352eb836" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/VincentVrijburg/02d54982eeda792163c323e3352eb836</a></figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx"><a class="ae jn" href="https://gist.github.com/VincentVrijburg/1b22b7e0c4192c6dc8df50ddee78fb93" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/VincentVrijburg/1b22b7e0c4192c6dc8df50ddee78fb93</a></figcaption></figure><p id="9e92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个例子中，<code class="du mo mp mq mr b"><a class="ae jn" href="https://github.com/VincentVrijburg/JsonApiDotNetCore.Demo.Auth/blob/2d6b210f2fbc007333275ba4c81e9d84bd561030/src/JsonApiDotNetCore.Demo.Auth.Data/Repository/KeyRepository.cs" rel="noopener ugc nofollow" target="_blank">KeyRepository</a></code>是一个模拟数据存储，其中有一些虚构的API键值。通常，您会访问存储在数据库或密钥管理服务中的API密钥。方法<code class="du mo mp mq mr b">IsAuthenticatedAsync</code>的要点是检查所提供的API密钥是否有效。</p><p id="cf39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">稍后，我们将添加这个<code class="du mo mp mq mr b">IKeyAuthenticationService</code>作为一个范围依赖。这将允许我们在请求过程中的任何时候(在认证步骤成功之后)读取设置的属性(例如UserId)。</p><p id="daa9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">至此，我们拥有了组成实际身份验证处理程序的所有必要元素。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="49c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，我们还没有定义定制响应。基本实现现在会处理这个问题。</p><p id="6034" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经构建了所有的身份验证组件，剩下唯一要做的事情就是在身份验证管道中注册它们。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="b430" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在您注册了创建的身份验证处理程序之后，作为您的默认身份验证方案，默认中间件将处理剩下的工作。就这么简单！</p><p id="2c9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，这个实现对于大多数API项目来说是一个很好的开始。然而，如果您决定使用JsonApiDotNetCore框架构建您的API，我们必须提交一些额外的更改，以便1)能够使用我们的自定义身份验证处理程序，2)保持符合<a class="ae jn" href="https://jsonapi.org" rel="noopener ugc nofollow" target="_blank"> JSON:API </a>规范。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="3e33" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">在JsonApiDotNetCore中处理身份验证</h1><p id="5c45" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">在(ASP)的早期版本中。NET核心，您可以创建一个返回自定义身份验证处理程序的中间件。然而，他们将这种方法改变为单一中间件设置。正如我们已经看到的，当前的方法是添加自定义身份验证处理程序作为一个方案，并用默认的<code class="du mo mp mq mr b">.UseAuthentication()</code>注册它。</p><p id="0a6f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管这种新方法简化了身份验证的实现，但它使JADNC (JsonApiDotNetCore)的集成变得复杂。</p><p id="3c8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于认证中间件需要在JADNC中间件之前注册，所以我们不能依赖JADNC内置的错误响应序列化器。因此，我们必须手动实现一个来保持符合<a class="ae jn" href="https://jsonapi.org" rel="noopener ugc nofollow" target="_blank"> JSON:API </a>规范。</p><p id="85b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们首先实现一个<code class="du mo mp mq mr b">ErrorResponseWriter</code>来处理JADNC范围之外的异常。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6108" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以在我们的定制认证处理程序中直接使用这个<code class="du mo mp mq mr b">ErrorResponseWriter</code>,但是我们将在这个响应编写器之上构建另一层。在身份验证和授权管道的不同级别捕获异常的层。</p><p id="9131" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们通过创建一个通用的异常中间件来实现这个概念。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c9b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此时，我们可以在身份验证处理程序中定制响应。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="b39a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，我们选择了覆盖两个方法，并相应地抛出异常。</p><p id="7837" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经构建了所有的身份验证和错误响应组件，剩下唯一要做的事情就是在应用程序管道中注册它们。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="d4ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们已经在JsonApiDotNetCore中成功实现了API密钥认证，同时遵守了<a class="ae jn" href="https://jsonapi.org" rel="noopener ugc nofollow" target="_blank"> JSON:API </a>规范。</p><p id="52c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看看GitHub <strong class="jq hj">库</strong>，看看在<a class="ae jn" href="https://github.com/json-api-dotnet/JsonApiDotNetCore" rel="noopener ugc nofollow" target="_blank"> JsonApiDotNetCore </a>中基于API密钥的认证的完整实现，作为一个演示项目。</p><div class="ms mt ez fb mu mv"><a href="https://github.com/VincentVrijburg/JsonApiDotNetCore.Demo.Auth" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">VincentVrijburg/JsonApiDotNetCore。演示验证</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">JsonApiDotNetCore框架中基于密钥的认证的演示实现。用dotnet恢复NuGet包…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jh mv"/></div></div></a></div></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="8629" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">参考</h1><p id="efe5" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">我用来写这篇文章的来源的完整概述。</p><p id="2663" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> JSON:API规范</strong> <br/>网址:<a class="ae jn" href="https://jsonapi.org/" rel="noopener ugc nofollow" target="_blank">https://jsonapi.org/</a></p><p id="fa25" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> JsonApiDotNetCore </strong> <br/>资源库:<a class="ae jn" href="https://github.com/json-api-dotnet/JsonApiDotNetCore" rel="noopener ugc nofollow" target="_blank">https://github.com/json-api-dotnet/JsonApiDotNetCore</a><br/>网站:<a class="ae jn" href="https://jsonapi.org/" rel="noopener ugc nofollow" target="_blank">https://jsonapi.net/</a></p><p id="275a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> JsonApiDotNetCore。演示授权</strong>储存库:<a class="ae jn" href="https://github.com/VincentVrijburg/JsonApiDotNetCore.Demo.Auth" rel="noopener ugc nofollow" target="_blank">https://github.com/VincentVrijburg/JsonApiDotNetCore.演示验证</a></p></div></div>    
</body>
</html>
<html>
<head>
<title>Swift | Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift |协议</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/swift-protocols-6419b71b7d13?source=collection_archive---------9-----------------------#2022-02-11">https://medium.com/geekculture/swift-protocols-6419b71b7d13?source=collection_archive---------9-----------------------#2022-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="479b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">协议中的属性、方法和初始值设定项要求</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c61d1bc6b6ab6825fa9e56c8ab0f1f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yK4u4r3C3lZ6JOwUQSdIqA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kaleidico</a> on <a class="ae jn" href="https://unsplash.com/s/photos/blueprint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5eaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Swift被认为是面向协议的编程。为了理解面向协议编程的概念，我们需要理解什么是协议。</p><h1 id="16a8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">协议</strong></h1><p id="186d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">协议是特定任务或功能的方法和属性的蓝图。它们只定义和呈现，本身不实现功能。结构、类和枚举符合协议，并负责实现它们符合协议的特定功能和任务。一个类、结构或枚举可以符合多个协议。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5bf2" class="lm kl hi li b fi ln lo l lp lq">protocol FirstProtocol{......}<br/>protocol SecondProtocol{....}</span><span id="862f" class="lm kl hi li b fi lr lo l lp lq">struct example1: FirstProtocol, SecondProtocol{ ......}</span></pre><p id="c51a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果使用类并继承。您必须首先指出超类，然后是协议。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="f798" class="lm kl hi li b fi ln lo l lp lq">class example2: Superclass, FirstProtol, SecondProtocol{......}</span></pre></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="d2af" class="kk kl hi bd km kn lz kp kq kr ma kt ku io mb ip kw ir mc is ky iu md iv la lb bi translated">协议中的属性要求</h1><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1c02" class="lm kl hi li b fi ln lo l lp lq">protocol someProtocol{<br/>     var gettableAndSettable: String{get set} <br/>     var gettableOnly: Int{get} <br/>     static var typeProperty: Double{ get}</span><span id="b25e" class="lm kl hi li b fi lr lo l lp lq">}</span></pre><p id="f41f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">协议中的属性有实例属性和类型属性，如<strong class="jq hj">符合类型</strong>。当在协议中调用属性时，它应该指定类型(是实例还是静态属性)、名称，以及它是否只是一个getter，还是getter和setter。协议要求将它们的属性设置为变量。</p><p id="25c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">举例</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="dc31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果协议中的属性定义为get only，则它可以实现为计算属性或存储属性。但是当它被实现为get和set属性时，它应该被实现为computed属性。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="21fd" class="kk kl hi bd km kn lz kp kq kr ma kt ku io mb ip kw ir mc is ky iu md iv la lb bi translated">方案中的方法要求</h1><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="df87" class="lm kl hi li b fi ln lo l lp lq">protocol someProtocol{<br/>      func instanceMethod() <br/>      func instanceMethod1(name:String, age: Int) <br/>      func instanceMethod2(name:String) -&gt; String <br/>      static func typeMethod1()</span><span id="01d5" class="lm kl hi li b fi lr lo l lp lq">}</span></pre><p id="dbc9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就像属性一样，协议有实例和类型方法作为<strong class="jq hj">符合类型</strong>。方法与常规的实例和类型方法相同，但是没有主体和花括号。定义这些方法时，不能指定参数默认值，但参数值的编写方式与常规方法相同</p><h2 id="3d16" class="lm kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">类中的类型方法</h2><p id="b78a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">类型方法在类中实现时会更复杂，因为类方法可以被重写。一个类可以使用class关键字来允许子类覆盖超类对类型方法的实现。因此，当您希望符合将类型方法作为符合类型的协议时，可以使用static或class关键字来实现这些方法。</p><ul class=""><li id="8ec8" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated"><strong class="jq hj">静态</strong>关键字→无法覆盖子类。</li><li id="c8d3" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><strong class="jq hj"> class </strong>关键字→能够覆盖子类。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="049e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码显示了如何在类中使用类型方法作为一致性类型的协议。someClass()是父类，anotherClass1()是子类。someClass()符合somProtocol()协议，该协议有两个类型方法。我选择用<strong class="jq hj">静态</strong>关键字实现someTypeMethod()，用<strong class="jq hj">类</strong>关键字实现anotherTypeMethod1()。由于anotherTypeMethod1()是带有class关键字的类型方法，因此子类可以重写它。</p><h2 id="4fc3" class="lm kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated"><strong class="ak">变异方法要求</strong></h2><p id="6906" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">当通过实例方法(在枚举和结构中)更改值类型的内部值时，请在methods func关键字前使用mutating关键字，以指示该方法更改了内部值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="4256" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如上所述，协议有一个变异方法作为一致性类型。当协议符合一个结构时，您需要使用mutating关键字来实现它。然而，当它符合一个类时，您不需要这样做。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="b9b8" class="kk kl hi bd km kn lz kp kq kr ma kt ku io mb ip kw ir mc is ky iu md iv la lb bi translated">协议中的初始化器要求</h1><p id="9d59" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">协议可以有初始化器。要请求一个初始化器，就像方法请求一样，你需要定义一个初始化器并实现它。换句话说，您只需要指定参数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="feb6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当初始化器在协议中作为一致性类型被调用时，它们在结构中被调用时不需要<strong class="jq hj">必需的</strong>关键字。但是，required关键字必须在类中使用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="me mf l"/></div></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="493d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">实现协议要求以执行特定功能。</p><ul class=""><li id="6844" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated">协议定义了适用于特定任务或功能的方法、属性和其他要求的蓝图。</li><li id="b67d" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">结构、类和枚举符合协议，并且实际上可以实现协议要求来执行特定的功能。</li><li id="d8b4" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">协议只是定义和呈现，本身并不实现功能。只定义了条件。</li><li id="1dde" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">多个协议可以符合一个结构、类或枚举。</li><li id="cf16" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">协议只定义方法、属性和初始化器。只要符合这些标准，它们就会在任何地方得到实施。</li></ul></div></div>    
</body>
</html>
<html>
<head>
<title>Integrating SwiftUI into UIKit project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将SwiftUI集成到UIKit项目中</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/integrating-swiftui-into-uikit-project-a1051e432041?source=collection_archive---------5-----------------------#2022-10-17">https://medium.com/geekculture/integrating-swiftui-into-uikit-project-a1051e432041?source=collection_archive---------5-----------------------#2022-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ccf2092d082d96077e67f2e36b4647d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-QlS6HrrJgHkKVd4L9IhA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">SwiftUI in UIKit</figcaption></figure><p id="0422" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我正在做一个项目，我们开始的地方很经典——没有故事板的UIKit，MVVM +协调员设计模式。它对你来说可能很熟悉，尤其是如果你正在为一家初创公司工作。我们所有的开发过程都进行得非常快。有时候，我会把我典型的工作日与中距离跑步相比较。企业一直在等待新功能的出现。在某个时刻，我们发现我们花了很多时间来构建新的UI特性，但是我们的特性不是很定制。我们把时间浪费在约束视图、配置和遵从委托上。你知道列表和表格视图设置的区别。</p><p id="5c0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最好的选择之一是尝试SwiftUI。使用这个框架，我个人想解决主要问题——更快地交付特性，将屏幕和视图从一个地方移动到另一个地方，而不损害现有的代码库。</p><p id="1301" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一开始，使用SwiftUI进行生产有点可怕，但最终，我们得到了一个不错的结果:我们将构建功能的速度提高了一倍。这意味着我们可以腾出时间来关注逻辑、单元测试和UI测试。</p><p id="017c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，根据我的经验，我想分享一下在你的UIKit项目中，你如何快速、轻松地开始用MVVM+C设计模式构建新的场景(屏幕)。</p><h1 id="9fe6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">TL；速度三角形定位法(dead reckoning)</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/c686c163c8d2d766153db092b5c044e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gEso0pwq0cnh31lmDLlAFw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">MVVM+C UIKit project with SwiftUI SignIn screen</figcaption></figure><div class="kv kw ez fb kx ky"><a href="https://github.com/maxkalik/uikit-swift-to-swiftui" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">带有SwiftUI登录屏幕的MVVM+C UIKit项目</h2><div class="lf l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">github.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll io ky"/></div></div></a></div><h1 id="e2c1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">探索项目</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/9031b2eaf8e53d9c640f5390fc510aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jflYSLRebUIFbgC2DlCjEw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Home Screen (UIKit)</figcaption></figure><p id="3381" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">给定:带有屏幕的UIKit应用程序—姑且称之为橙色背景的主屏幕。如果我们运行一个应用程序，它会启动一些自定义的活动指示器。当用户界面可以使用时，我们只有一个按钮——登录。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/2e87260cfbaab3265a7e293d0268bf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noIEtR6UTPJT0hu-saRgRQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">SignIn Screen (SwiftUI)</figcaption></figure><p id="8593" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设你有一个任务。某个产品经理或您的团队领导要求您实现一个新功能—一个新的登录屏幕。它应该以这种方式工作:在主屏幕上点击登录，我们应该呈现登录屏幕。我们必须在那里添加一些逻辑——为了检查<code class="du ln lo lp lq b">textfield</code>是否为空，我们需要给出一个带有错误消息的警告。</p><p id="7b66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果用户正确地完成了所有操作——<code class="du ln lo lp lq b">textfield</code>由名字填充，那么在一些加载过程之后，我们需要转到之前的橙色主屏幕，上面有更新的按钮标题和标签。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/3f83356b7774b4d4c5c275ce376fb2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwUmGTOWREIaddT1B2YhXQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Home Screen (UIKit)</figcaption></figure><p id="2e84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好的。这似乎不是一项复杂的任务，作为开发人员，您决定使用SwiftUI实现整个屏幕。好决定。但是，让我们想想如何整合我们的SwiftUI员工。</p><h1 id="0bca" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">从建筑的角度来看</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/81f513881c9c090d5974104a1aff38ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UhMc1NMLTpf1r-Bny_KimA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">App Coordinator</figcaption></figure><p id="f5ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，让我们从协调者的角度看一下这个项目。第一种<code class="du ln lo lp lq b">start</code>方法准备主屏幕。正如你所看到的，准备这个模块需要视图模型和视图控制器。那么这个视图控制器就被推送到导航视图控制器的堆栈中。在使用MVVM +协调器设计模式时，这是iOS开发中一个非常常见的模块准备过程。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="573e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">视图模型</strong> — <code class="du ln lo lp lq b">HomeViewModel</code>包括几个代表— <code class="du ln lo lp lq b">ViewDelegate</code>和<code class="du ln lo lp lq b">CoordinatorDelegate</code>。<code class="du ln lo lp lq b">ViewDelegate</code>用于控制特定场景下屏幕上的视图。在这种情况下，它是一个主屏幕，视图模型负责在屏幕上显示和隐藏活动指示器。<strong class="iw hj"> CoordinatorDelegate </strong>委派显示我们的新屏幕——登录屏幕的责任。但是如果我们想使用SwiftUI，我们要如何实现这一部分呢？</p><h1 id="4726" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><code class="du ln lo lp lq b">BaseViewController</code></h1><p id="978b" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">好的。如果你对这个项目了如指掌，你就可以开始了。<br/>但是让我们假设在这一点上你并不确切知道项目的结构。你在团队中工作。你尊重你的每一个同事和他们的工作，你不想仅仅因为你想整合你的SwiftUI员工就打破现有的结构。</p><p id="e29d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以让我们来看看视图层次结构。你很可能会看到类似这样的东西——<code class="du ln lo lp lq b">ViewController</code>被<code class="du ln lo lp lq b">BaseViewController</code>或类似的东西继承。它需要存储一些基本视图逻辑(不是业务逻辑)。在我们的例子中，<code class="du ln lo lp lq b">BaseViewController</code>有显示和隐藏活动指示器的方法。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="iq ir et er es is it bd b be z dx">BaseViewController with methods for showing and hiding activity indicator</figcaption></figure><p id="463d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你很可能已经知道如何在UIKit中使用SwiftUI视图，以及为什么我们需要<code class="du ln lo lp lq b">UIHostingController</code>。此外，我打赌你明白引擎盖下的<code class="du ln lo lp lq b">UIHostingController</code>和往常的<code class="du ln lo lp lq b">UIViewController</code>一样。您将这个视图控制器推送到<code class="du ln lo lp lq b">UINavigationController</code>是正确的，因为它在其堆栈中自由地接受这个控制器。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/fc65640fcb0dbd5b8fc8838627a1c713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7eBJY2A8CoxzqyApxqlPUw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">UIHostingController in UINavigationController stack</figcaption></figure><p id="6d92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是我们有一个要求——我们必须使用这个确切的<code class="du ln lo lp lq b">ProgressView </code>而不重复我们自己。当然，这个进度视图我们可以在SwiftUI中重新实现，但是可重用性呢？是时候记住<a class="ae lz" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>原理和你脑子里所有关于这个的警告了。正如我之前所说，我们不想打破现有的结构。</p><h1 id="55b6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><code class="du ln lo lp lq b">BaseHostingController</code></h1><p id="f99b" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">合适的解决方案是准备与从<code class="du ln lo lp lq b">UIHostingController</code>继承的<code class="du ln lo lp lq b">BaseViewController</code>相同的<code class="du ln lo lp lq b">BaseHostingController</code>，并以某种方式从那里使用一些启动和停止活动指示器的方法。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/a4bda83dc9a98e3647e035fa05d426f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLYyOTzfva6m54npr31CLA.png"/></div></div></figure><p id="ad35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所知<code class="du ln lo lp lq b">UIHostingController</code>就是<code class="du ln lo lp lq b">UIViewController</code>。这意味着我们可以用一个协议包装我们的两个基本控制器。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="c433" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个BaseController协议将使用<code class="du ln lo lp lq b">ProgressView</code>和与<code class="du ln lo lp lq b">BaseViewController</code>中相同的基本方法。我们开始吧。将该协议与<code class="du ln lo lp lq b">BaseViewController</code>和<code class="du ln lo lp lq b">BaseHostingController</code>一致，我们就有机会从UIKit和SwiftUI模块中使用相同的<code class="du ln lo lp lq b">ProgressView</code>。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Base Controllers</figcaption></figure><p id="839c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了<code class="du ln lo lp lq b">BaseHostingController</code>，我们可以像使用<code class="du ln lo lp lq b">BaseViewController</code>一样使用它，尤其是在查看代表时。我们只是很容易地从这个主机控制器控制我们的加载指示器，而不会破坏项目的结构。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="acc7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就连协调人似乎也没变。只出现了一个漂亮的方法:<code class="du ln lo lp lq b">showSignIn()</code></p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="43ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看，它多么完美地符合现有的MVVM+协调器设计模式。<code class="du ln lo lp lq b">AppCoordinators</code>获得了干净易读的方法，其步骤与准备要显示的模块的步骤相同。<code class="du ln lo lp lq b">SignInHostingController</code>中的<code class="du ln lo lp lq b">ViewDelegate</code>与<code class="du ln lo lp lq b">BaseViewController</code>的工作方式相同。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/88640f9d8e3b3c0759668d6b4d796ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrFq-7aB6hIM5_9ta7eF5A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">AppCoordinator with SignIn Module</figcaption></figure><h1 id="2809" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">包扎</h1><p id="a73a" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">如果你在一个团队中工作，你的代码应该对每个人都是可预测和可读的，即使你的同事不知道SwiftUI，但无论如何，他们会理解如何维护这种结构。</p><p id="6195" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据我的个人经验，我非常成功地使用了这种方法。今天我们项目中几乎70%的屏幕都是带有<code class="du ln lo lp lq b">UIHostingController</code>的SwiftUI。我猜这将是100%，但这将是另一个关于如何将您的UIKit应用程序完全转移到SwiftUI的故事:)</p><h1 id="e63c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">资源</h1><p id="e084" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">GitHub库:<a class="ae lz" href="https://github.com/maxkalik/uikit-swift-to-swiftui" rel="noopener ugc nofollow" target="_blank">https://github.com/maxkalik/uikit-swift-to-swiftui</a></p><p id="21f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">UIHostingController:<a class="ae lz" href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/swift ui/UIHostingController</a></p><pre class="kr ks kt ku fd mc lq md me aw mf bi"><span id="2935" class="mg jt hi lq b fi mh mi l mj mk"><strong class="lq hj">Want to Connect?</strong></span><span id="42c0" class="mg jt hi lq b fi ml mi l mj mk">Don't hesitate to follow me on <a class="ae lz" href="https://twitter.com/maxkalik" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span><span id="5631" class="mg jt hi lq b fi ml mi l mj mk">I appreciate any suggestions or comments regarding my research and articles.</span></pre></div></div>    
</body>
</html>
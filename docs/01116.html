<html>
<head>
<title>Create your own React context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的React上下文</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/create-your-own-react-context-b91060fd3ef0?source=collection_archive---------13-----------------------#2021-03-28">https://medium.com/geekculture/create-your-own-react-context-b91060fd3ef0?source=collection_archive---------13-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1e08" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在反应的童话世界里的冒险</h2></div><p id="8673" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React的<a class="ae jt" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a> API允许我们在将数据从祖先传递到后代时任意跳过组件树的层次。当处理由层次结构中不同层次的不相关组件读取的有状态数据时，这很方便。也是<a class="ae jt" href="https://dev.to/alexi_be3/react-component-patterns-49ho" rel="noopener ugc nofollow" target="_blank">复合组件</a>、<a class="ae jt" href="https://reactrouter.com" rel="noopener ugc nofollow" target="_blank"> React路由器</a>背后强大的复合模式的中坚力量。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/28fc9996d932331ecd3c6d517b3e2a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8P-R7o3Q8t_KHNEuVcoCQ.png"/></div></div></figure><p id="a5df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自从引入以来，上下文API一直是围绕集中式状态管理的几乎所有讨论的核心。虽然它本身并不是一个完整的状态管理工具，但它可以与其他React原语结合使用，创建一个轻量级的替代方案来替代现有的解决方案，如<a class="ae jt" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>、<a class="ae jt" href="https://react-redux.js.org" rel="noopener ugc nofollow" target="_blank"> React Redux </a>或<a class="ae jt" href="https://github.com/mobxjs/mobx/tree/main/packages/mobx-react" rel="noopener ugc nofollow" target="_blank"> MobX React </a>。</p><p id="b4f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于使用上下文API使中央应用程序状态对组件树可用，最常见的问题之一是性能。什么时候渲染？订阅一个上下文会触发那些只读取它的一个子部分的组件的不必要的更新吗？将来React组件是否应该默认为<a class="ae jt" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">记忆</a>？</p><p id="4264" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个问题上，社会上的意见分歧很大。一些人提倡使用API，如<a class="ae jt" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"> connect </a>来封装渲染优化的逻辑。有些人认为我们不应该总是纠结于组件的重新渲染，而是应该关注保持它们的渲染逻辑简单和精简。一些人认为掌握好的组件设计的基础会产生集中状态管理的可靠替代方案。各方面都有优点。</p><p id="224a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的意思不是赞同任何一种特定的世界观，而是帮助你驾驭解决<a class="ae jt" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank"> prop drilling </a>问题的复杂性。在本文中，我们将一步步实现我们自己的上下文API。</p><h1 id="0773" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">API</h1><p id="26ed" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">一个利用集中状态的轻量级应用程序的例子可以选择提供最新的状态以及通过上下文更新它的方法。当前的上下文创建API返回一个<a class="ae jt" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">提供者</a>包装组件，访问上下文值的最先进方式是通过<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> useContext </a>钩子。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="da02" class="li kh hi le b fi lj lk l ll lm">import { <a class="ae jt" href="https://reactjs.org/docs/context.html#reactcreatecontext" rel="noopener ugc nofollow" target="_blank">createContext</a>, <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a>, <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a> } from "<a class="ae jt" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">react</a>";</span><span id="7f3e" class="li kh hi le b fi ln lk l ll lm">const StateContext = createContext(initialState);<br/>const DispatchContext = createContext(noop);</span><span id="421b" class="li kh hi le b fi ln lk l ll lm">function App() {<br/>    const [state, dispatch] = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a>(reducer, initialState);</span><span id="2050" class="li kh hi le b fi ln lk l ll lm">    return (<br/>        &lt;StateContext.Provider value={state}&gt;<br/>             &lt;DispatchContext.Provider value={dispatch}&gt;<br/>                  &lt;Component /&gt;<br/>             &lt;DispatchContext.Provider&gt;<br/>        &lt;/StateContext.Provider&gt;<br/>    );<br/>}</span><span id="af83" class="li kh hi le b fi ln lk l ll lm">function Component() {<br/>    const dispatch = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a>(DispatchContext);<br/>    const bar = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a>(StateContext).foo.bar;</span><span id="24ea" class="li kh hi le b fi ln lk l ll lm">    // ...<br/>}</span></pre><p id="a857" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">提供者起源于生命周期逻辑只能在<a class="ae jt" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">类组件</a>中实现的时代。随着钩子的引入，我们现在有可能开发一个API，它允许应用程序利用多种上下文来摆脱<a class="ae jt" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">提供者</a>的深度嵌套金字塔。</p><p id="72c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个有趣的变化是使用选择器来访问上下文数据，这是由<a class="ae jt" href="https://react-redux.js.org" rel="noopener ugc nofollow" target="_blank"> React Redux </a>推广的。我们将在API中包含我们自己的<a class="ae jt" href="https://react-redux.js.org/api/hooks#useselector" rel="noopener ugc nofollow" target="_blank"> useSelector </a>实现，并探索它的好处。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="29e5" class="li kh hi le b fi lj lk l ll lm">import { <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a> } from "<a class="ae jt" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">react</a>";<br/>import { <strong class="le hj">createContext</strong> } from "..."; </span><span id="33d5" class="li kh hi le b fi ln lk l ll lm">const [<strong class="le hj">useProvider</strong>, <strong class="le hj">useSelector</strong>] = <strong class="le hj">createContext</strong>(initialState);<br/>const [<strong class="le hj">useDispatchProvider</strong>, <strong class="le hj">useDispatch</strong>] = <strong class="le hj">createContext</strong>(noop);</span><span id="4c11" class="li kh hi le b fi ln lk l ll lm">function App() {<br/>    const [state, dispatch] = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a>(reducer, initialState);</span><span id="230b" class="li kh hi le b fi ln lk l ll lm">    <strong class="le hj">useProvider</strong>(state);<br/>    <strong class="le hj">useDispatchProvider</strong>(dispatch);</span><span id="3b74" class="li kh hi le b fi ln lk l ll lm">    return &lt;Component /&gt;;<br/>}</span><span id="e075" class="li kh hi le b fi ln lk l ll lm">function Component() {<br/>    const dispatch = <strong class="le hj">useDispatch</strong>();<br/>    const bar = <strong class="le hj">useSelector</strong>(<strong class="le hj">state =&gt; state.foo.bar</strong>);</span><span id="1b82" class="li kh hi le b fi ln lk l ll lm">    // ...<br/>}</span></pre><h1 id="5b87" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第一步:设置场景</h1><p id="8875" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">React <a class="ae jt" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">挂钩</a>的引入使得<a class="ae jt" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>以及<a class="ae jt" href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" rel="noopener ugc nofollow" target="_blank">混合组件</a>的使用被淘汰。这在高阶事物的神秘领域留下了怀旧的空白。我们可以偶尔创造一个高阶钩子来填补这个空白。</p><p id="7886" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个上下文相当于创建一对彼此明确对应的钩子。我们可以利用这种设计在层次结构的不同层次的组件之间建立连接，而不需要传递道具。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="30c1" class="li kh hi le b fi lj lk l ll lm">export function createContext(initialValue) {<br/>    const useProvider = createProviderHook();<br/>    const useSelector = createSelectorHook();</span><span id="6a47" class="li kh hi le b fi ln lk l ll lm">    return [useProvider, useSelector];<br/>}</span><span id="2309" class="li kh hi le b fi ln lk l ll lm">function createProviderHook() {<br/>    return function(value) {<br/>          // ?<br/>    }<br/>}</span><span id="d974" class="li kh hi le b fi ln lk l ll lm">function createSelectorHook() {<br/>    return function(select) {<br/>          // ?<br/>    }<br/>}</span></pre><h1 id="e169" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第二步:分享背景</h1><p id="5d80" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">钩子的成对创建也是创建上下文对象的好机会，它们通过上下文对象共享数据。当useProvider不断地将最新收到的值写入上下文时，useSelector不断地从中读取最新的值。</p><p id="af05" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，即使最新的上下文值被两个钩子共享，它也不是被动共享的。调用useProvider的组件的更新不一定会触发调用useSelector的所有后代的更新。被记忆的组件可能存在于两者之间。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="4f1a" class="li kh hi le b fi lj lk l ll lm">export function createContext(initialValue) {<br/>    <strong class="le hj">const context = {<br/>        value: initialValue,<br/>    };</strong></span><span id="1015" class="li kh hi le b fi ln lk l ll lm">    const useProvider = createProviderHook(<strong class="le hj">context</strong>);<br/>    const useSelector = createSelectorHook(<strong class="le hj">context</strong>);</span><span id="cd96" class="li kh hi le b fi ln lk l ll lm">    return [useProvider, useSelector];<br/>}</span><span id="c9ed" class="li kh hi le b fi ln lk l ll lm">function createProviderHook(<strong class="le hj">context</strong>) {<br/>    return function(value) {<br/>        <strong class="le hj">context.value = value;</strong><br/>    }<br/>}</span><span id="afce" class="li kh hi le b fi ln lk l ll lm">function createSelectorHook(<strong class="le hj">context</strong>) {<br/>    return function(select) {<br/>        <strong class="le hj">return select(context.value);</strong><br/>    }<br/>}</span></pre><h1 id="5448" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated"><strong class="ak">第三步:注册订阅</strong></h1><p id="aafc" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们现在需要确保当useProvider接收到新值时，所有调用useSelector的组件都得到更新。</p><p id="fdad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其思想是让useSelector的每个实例将自己作为订阅者引入上下文，并让useProvider在收到新值时通知所有已注册的订阅。有了这个添加，我们的上下文API实现也将在使用<a class="ae jt" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">记忆组件</a>的情况下正确工作。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="db74" class="li kh hi le b fi lj lk l ll lm"><strong class="le hj">import { </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useEffect</strong></a><strong class="le hj">, </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useReducer</strong></a><strong class="le hj">, </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useMemo</strong></a><strong class="le hj"> } from "</strong><a class="ae jt" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">react</strong></a><strong class="le hj">";</strong></span><span id="4874" class="li kh hi le b fi ln lk l ll lm">export function createContext(initialValue) {<br/>    const context = {<br/>        value: initialValue, <br/>        <strong class="le hj">subscriptions: new </strong><a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">Set</strong></a><strong class="le hj">();</strong><br/>    };</span><span id="d579" class="li kh hi le b fi ln lk l ll lm">    const useProvider = createProviderHook(context);<br/>    const useSelector = createSelectorHook(context);</span><span id="0d48" class="li kh hi le b fi ln lk l ll lm">    return [useProvider, useSelector];<br/>}</span><span id="bf6e" class="li kh hi le b fi ln lk l ll lm">function createProviderHook(context) {<br/>    return function(value) {<br/>        context.value = value;</span><span id="b58b" class="li kh hi le b fi ln lk l ll lm"><strong class="le hj">        </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useEffect</strong></a><strong class="le hj">(() =&gt; {<br/>            for (const notifyUpdate of context.subscriptions) {<br/>                notifyUpdate();<br/>            }<br/>        }, [value]);</strong><br/>    }<br/>}</span><span id="be4d" class="li kh hi le b fi ln lk l ll lm">function createSelectorHook(context) {<br/>    return function(select) {<br/>        const selectedValue = select(context.value);<br/><strong class="le hj">        const notifyUpdate = </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useReducer</strong></a><strong class="le hj">(c =&gt; c + 1, 0)[1];<br/>        const subscription = </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useMemo</strong></a><strong class="le hj">(() =&gt; notifyUpdate), []);</strong></span><span id="bb1c" class="li kh hi le b fi ln lk l ll lm">        <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useEffect</strong></a><strong class="le hj">(() =&gt;<br/>            context.subscriptions.add(subscription);<br/>            return () =&gt; {<br/>                context.subscriptions.delete(subscription);<br/>            }<br/>        }, []);</strong>      </span><span id="5358" class="li kh hi le b fi ln lk l ll lm">        return selectedValue;<br/>    }<br/>}</span></pre><h1 id="3b7f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第四步:修复闪烁的用户界面</h1><p id="f86a" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们来看看一件有趣的事情，如果我们使用Effect通知注册的订阅。</p><p id="5998" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">调用useProvider udates的组件安排所有订阅的通知在更改提交到DOM和浏览器重新绘制之后发生。如果由于提供者祖先的更新，所有的上下文使用者都被同步更新，那么就没问题了，到通知效果运行时，所有的订阅都将收到最新的上下文值，没有更新需要触发。</p><p id="2ca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果中间有一个<a class="ae jt" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">记忆组件</a>，并且至少有一个消费者没有因为提供者祖先更新而立即更新，那该怎么办呢？然后，在浏览器绘制初始更新和通知效果运行后，未收到最新上下文值的消费者被通知并更新，确定要重新绘制的浏览器。</p><p id="fa49" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，在存在memozied组件的情况下，当上下文值改变时，可能至少需要两次重绘来显示更新的组件树。这可能会在用户界面中产生闪烁效果。</p><p id="c092" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是为什么我们要用<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">来代替</a>的原因。</p><p id="1226" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它的回调保证在渲染更改提交到DOM之后运行，但是在之前<em class="lo">浏览器有机会重新绘制。不仅如此，在布局效果中触发的进一步的状态更新也保证在浏览器重新绘制之前同步应用并提交到DOM，这意味着提供者祖先的更新和消费者后代的更新同时呈现给用户。</em></p><p id="df43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，这不一定是好事。这只是一个设计决策。一次性同步更新组件树也意味着浏览器在渲染时会被阻塞更长时间。进一步探究这种区别自然会引出<a class="ae jt" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>，我现在还不准备谈论它，至少在它变得稳定之前。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="12de" class="li kh hi le b fi lj lk l ll lm">import { <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useLayoutEffect</strong></a><strong class="le hj"> </strong>} from "<a class="ae jt" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">react</a>";</span><span id="64b2" class="li kh hi le b fi ln lk l ll lm">function createProviderHook(context) {<br/>    return function(value) {<br/>        context.value = value;</span><span id="4419" class="li kh hi le b fi ln lk l ll lm"><strong class="le hj">        </strong><a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">useLayoutEffect</strong></a>(() =&gt; {<br/>            for (const notifyUpdate of context.subscriptions) {<br/>                notifyUpdate();<br/>            }<br/>        }, [value]);<br/>    }<br/>}</span></pre><p id="4dfe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">喜欢新奇事物的人可能会问，同步通知已经在呈现阶段的订阅怎么样？如果你知道你在做什么，那就是使用<a class="ae jt" href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops" rel="noopener ugc nofollow" target="_blank">功能等同于getDerivedStateFromProps </a>。确实很奇特，很少被记载，也很难解释。我打算暂时把它放在一边。</p><p id="be96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一句，如果你还没有，一定要留出一些时间来阅读<a class="ae jt" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">效果使用指南</a>。我总是觉得很清爽。</p><h1 id="bf1e" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第五步:自上而下更新</h1><p id="e607" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">到目前为止，事情进展顺利。这一过程中的每一步都是合乎逻辑的，而且有些清晰。但是那些听过React鬼故事的人可能会记得React Redux的幽灵、<a class="ae jt" href="https://react-redux.js.org/api/hooks#stale-props-and-zombie-children" rel="noopener ugc nofollow" target="_blank">陈旧的道具和僵尸小孩</a>。</p><p id="65a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi"><strong class="iz hj">(ノಠ益ಠ)ノ彡┻━┻</strong></p><p id="53fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇令人惊叹的文章已经在探索问题的复杂性方面做了出色的工作。如果您是新手，我建议您不要因为这一点上的复杂性而感到不知所措，而是慢慢来，首先掌握基础知识。</p><p id="ff1e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽可能简短地说，我们的实现不会受到僵尸孩子的影响。让我们通过对注册订阅实施批量、自顶向下的通知来解决过时的props问题。到目前为止，我们手头上最好的工具是<a class="ae jt" href="https://reactjs.org/docs/react-dom.html" rel="noopener ugc nofollow" target="_blank"> ReactDOM </a>的一个隐藏功能，记录在用户土地的民间传说中。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="8077" class="li kh hi le b fi lj lk l ll lm"><strong class="le hj">import { unstable_batchedUpdates } from "</strong><a class="ae jt" href="https://reactjs.org/docs/react-dom.html" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">react-dom</strong></a><strong class="le hj">";</strong></span><span id="1336" class="li kh hi le b fi ln lk l ll lm">function createProviderHook(context) {<br/>    return function(value) {<br/>        context.value = value;</span><span id="1ead" class="li kh hi le b fi ln lk l ll lm">        <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">useLayoutEffect</a>(() =&gt; {<br/><strong class="le hj">            unstable_batchedUpdates(() =&gt; {<br/>                </strong>for (constnotifyUpdate of context.subscriptions) {<br/>                    notifyUpdate();<br/>                }<br/><strong class="le hj">            });            <br/></strong>       }, [value]);<br/>    }<br/>}</span></pre><h1 id="db38" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第六步:避免不必要的更新</h1><p id="f2ca" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们还没有利用基于选择器的界面。到目前为止，当上下文值改变时，即使选择的值保持不变，useSelector的每个注册订阅都会得到通知。我们的目标是只触发元素的更新，当在新的上下文中调用时，选择器回调为这些元素返回不同的值。</p><p id="d4c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，<strong class="iz hj">仅触发元素</strong>的更新和<strong class="iz hj">仅更新元素</strong>之间有细微的区别。后者意味着使用这个API本身优化了组件的呈现。事实并非如此。为了提高性能，在提供者祖先和消费者后代之间也必须有<a class="ae jt" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">记忆组件</a>。默认情况下，React更新一个更新元素的所有后代，不管它们的属性是否改变。这里是<a class="ae jt" href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/" rel="noopener ugc nofollow" target="_blank">(大部分)反应渲染行为</a>的完整指南。</p><p id="8f85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个想法是在每次useSelector运行时，与useProvider共享最新的选择器以及最新选择的值。useProvider可以使用这些来选择退出通知订阅，通知订阅不会收到与前一个值不同的选定值。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="a1ca" class="li kh hi le b fi lj lk l ll lm">function createProviderHook(context) {<br/>    return function(value) {<br/>        context.value = value;</span><span id="7eb9" class="li kh hi le b fi ln lk l ll lm">        <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">useLayoutEffect</a>(() =&gt; {<br/><strong class="le hj">       </strong>     unstable_batchedUpdates(() =&gt; {<br/>                for (const {<strong class="le hj"><br/>                    select,<br/>                    selectedValue,<br/>                    </strong>notifyUpdate<strong class="le hj">,</strong><br/>                } of context.subscriptions) {<strong class="le hj"><br/></strong>                    <strong class="le hj">if (select(value) !== selectedValue) {</strong><br/>                        notifyUpdate();<br/>                    <strong class="le hj">}<br/>                </strong>}<br/>            });<br/>        }, [value]);<br/>    }<br/>}</span><span id="8260" class="li kh hi le b fi ln lk l ll lm">function createSelectorHook(context) {<br/>    return function(select) {<br/>        const selectedValue = select(context.value);<br/>        const notifyUpdate = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a>(c =&gt; c + 1, 0)[1];<br/>        const subscription = <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a>(() =&gt; <strong class="le hj">({</strong>          <br/>            <strong class="le hj">select, <br/>            selectedValue,</strong><br/>            notifyUpdate,<br/>        <strong class="le hj">})</strong>, []);</span><span id="7b3b" class="li kh hi le b fi ln lk l ll lm">        <strong class="le hj">subscription.select = select;<br/>        subscription.selectedValue = selectedValue;</strong></span><span id="e974" class="li kh hi le b fi ln lk l ll lm">        <a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a>(() =&gt;<br/>            context.subscriptions.add(subscription);<br/>            return () =&gt; {<br/>                context.subscriptions.delete(subscription);<br/>            }<br/>        }, []);</span><span id="aedd" class="li kh hi le b fi ln lk l ll lm">        return selectedValue;<br/>    }<br/>}</span></pre><h1 id="0281" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">第七步:完成API</h1><p id="9769" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">咻，有很多东西需要消化，但是我们就快到了！我们缺少两个小细节来完成API。我们可以为useSelector提供一个默认的回调，允许它在没有参数的情况下被调用。我们还可以让用户通过第二个相等检查器回调来决定两个上下文值相等意味着什么。严格来说，这些特性并不是API所必需的，但是它们确实在实践中对API用户产生了重要的影响。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="a34c" class="li kh hi le b fi lj lk l ll lm">function createSelectorHook(context) {<br/>    return function(select <strong class="le hj">= identity, areEqual = strictEquality</strong>) {<br/>          <em class="lo">// This margin is too narrow to contain it.</em><br/>    }<br/>}</span><span id="6ba1" class="li kh hi le b fi ln lk l ll lm"><strong class="le hj">function identity(value) {<br/>    return value;<br/>}</strong></span><span id="be65" class="li kh hi le b fi ln lk l ll lm"><strong class="le hj">function strictEquality(left, right) {<br/>    return left === right;<br/>}</strong></span></pre><h1 id="01c5" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结论</h1><p id="2c42" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们已经使用React提供的三种基本能力实现了一个上下文API:在组件的整个生命周期中持久保存任意数据的能力(<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>或<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef </a>)，在组件挂载、卸载或接收新数据时运行任意代码的能力(<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"> useEffect </a>和<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"> useLayourEffect </a>)，以及任意触发任何组件更新的能力(<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank"> useState </a>或<a class="ae jt" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a>)。</p><p id="3440" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢阅读这篇文章，并且它激励你去追求你自己的反应实验。几年后，我们可能会回顾当前的做法，使它们变得不必要的复杂。但是在我们到达那里之前，我们必须继续挖掘事情的真相，并且问自己，<em class="lo">这能变得更简单吗？</em></p><p id="ce59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您抽出时间，祝您度过愉快的一天！我将继续测试并维护本报告中的代码。</p><p id="1b05" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 〆(・∀・) </strong></p></div></div>    
</body>
</html>
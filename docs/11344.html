<html>
<head>
<title>Clean Code Development | Integration Operation Separation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净代码开发|集成操作分离原则</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/clean-code-development-integration-operation-separation-principle-ec85a0e47bcb?source=collection_archive---------0-----------------------#2022-03-18">https://medium.com/geekculture/clean-code-development-integration-operation-separation-principle-ec85a0e47bcb?source=collection_archive---------0-----------------------#2022-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c78348d50bbbbe9a429de0281f3332cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6EVllsGHLIM5CSOGOYM7g.png"/></div></div></figure><p id="3b45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本周，我不得不为一个项目添加一个新功能，这个项目是我一年前开始的，已经很久没碰过了。当我第一次看我的代码时，我认为它非常干净，我很震惊，它是如此的不一致和无组织。我不得不投入大量时间，仅仅是为了清楚地理解我的代码做了什么。</p><p id="372a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我不能总是投入那么多时间，只是为了理解，我想用我的代码表达什么，我看了看一些干净的代码策略。其中，我发现最重要的是整合操作隔离原则(IOSP)。</p><h1 id="2fe4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是集成操作隔离</h1><p id="e4ab" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">IOSP(Integration Operation Segregation Principle)是一种干净的代码策略，它允许我们清楚地区分集成代码和操作代码。它允许我们系统化地将大型方法的复杂性简化成更简单的方法。</p><p id="ac1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">集成方法</strong>只组成其他单元(包括其他集成方法)但不包含任何逻辑。</p><p id="cd14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">操作方法</strong>只包含逻辑，从不集成任何其他功能方法。它们应该非常小，可组合，易于阅读。</p><h1 id="719a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">如何应用这一原则</h1><p id="08ea" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果您有大的方法或者只是一般意义上的混乱方法，您可以通过几个简单的步骤来应用这个模式。</p><ol class=""><li id="1422" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">找到同时完成操作和集成任务的大方法</li><li id="f160" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">把它们分成更小的方法</li><li id="a15e" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">将你的方法分为<strong class="is hj">集成方法</strong>或<strong class="is hj">操作方法</strong></li></ol><p id="e989" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你不确定，如果一个方法是集成的还是可操作的，那么这个方法就需要更多的分解。如果你做对了，你现在应该有一个真正易读的集成方法，它实现了其他的方法。</p><h2 id="5f34" class="lf jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">例子</h2><p id="b699" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这里我有一个小的示例类，里面只有一个大的、无用的方法。乍一看，你真的看不出这个功能是怎么回事。你可以看到它的标题，但它实际上在里面做什么，真的很难讲。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="dfe1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步，我们可以从第14行提取一个新函数。这个函数可以被称为<code class="du lz ma mb mc b">generateKrokiImage()</code>，因为它调用了krokiAdapter的<code class="du lz ma mb mc b">generateImage()</code>函数。</p><p id="50f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们可以从第11行到第16行提取一个新函数，并将其命名为类似于<code class="du lz ma mb mc b">replaceAdocDiagramWithKroki()</code>的东西。这个函数用我们的<code class="du lz ma mb mc b">generateKrokiImage()</code>函数生成的新值替换正则表达式找到的旧值。</p><p id="e700" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以提取的下一个函数位于第8到10行。它遍历整个文件树并检查每一项，如果它确实是一个asciidoc文件并与给定的正则表达式匹配。我们可以称这个函数为<code class="du lz ma mb mc b">forEachAdocFile()</code>。</p><p id="f347" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们有一个非常容易理解的函数，它结构良好，易于维护。它可能看起来像这样:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="55e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以清楚地看到，convert函数是这个类中唯一的集成方法，也是从外部调用的方法。所有其他私有方法都是可操作的。</p><h1 id="cc1e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">反射</h1><h2 id="c778" class="lf jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">什么进展顺利</h2><p id="b49e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">由于IntelliJ IDEA的重构方法，该原则的实际实现非常好，非常简单。</p><h2 id="4af4" class="lf jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">什么需要改进</h2><p id="0809" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">首先，我没有真正理解这种模式的目的，因为最后，代码比以前更长了(因为不同方法之间的空白)。我对此有点困惑，不得不问我的导师。经过短暂的讨论，他澄清了一些事情，我很清楚，通过这种方式，你可以一眼就看到整个类或方法做了什么。</p></div></div>    
</body>
</html>
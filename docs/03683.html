<html>
<head>
<title>Deploying a React app and a Node.js server on a single machine with PM2 and Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PM2和Nginx在一台机器上部署React应用程序和Node.js服务器</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploying-a-react-app-and-a-node-js-server-on-a-single-machine-with-pm2-and-nginx-15f17251ee74?source=collection_archive---------0-----------------------#2021-06-14">https://medium.com/geekculture/deploying-a-react-app-and-a-node-js-server-on-a-single-machine-with-pm2-and-nginx-15f17251ee74?source=collection_archive---------0-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的目的是记录我在同一台带有负载平衡器的Linux机器上部署前端和后端的过程。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="00ff" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">安装先决条件</h1><p id="7034" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">请注意，这些说明对Ubuntu 16或更高版本有效。</p><h2 id="484e" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">节点. js</h2><ul class=""><li id="5c3d" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated">安装命令:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="7cdc" class="kn jl hi lp b fi lt lu l lv lw">$ sudo apt install nodejs</span></pre><ul class=""><li id="b332" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">验证安装:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="9fbe" class="kn jl hi lp b fi lt lu l lv lw">$ node --version<br/>v12.16.0</span></pre><h2 id="a44e" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">Nginx (Web服务、反向代理和负载平衡)</h2><ul class=""><li id="6d83" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated">更新Ubuntu库信息:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="37e9" class="kn jl hi lp b fi lt lu l lv lw">$ sudo apt-get update</span></pre><ul class=""><li id="a42c" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">安装软件包:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="f621" class="kn jl hi lp b fi lt lu l lv lw">$ sudo apt-get install nginx</span></pre><ul class=""><li id="f483" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">验证安装:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="28eb" class="kn jl hi lp b fi lt lu l lv lw">$ sudo nginx -v<br/>nginx version: nginx/1.14.0 (Ubuntu)</span></pre><ul class=""><li id="80e6" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">启动NGINX:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="f5b7" class="kn jl hi lp b fi lt lu l lv lw">$ sudo nginx</span></pre><ul class=""><li id="7723" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">验证NGINX已启动并正在运行:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="c722" class="kn jl hi lp b fi lt lu l lv lw">$ curl -I 127.0.0.1<br/>HTTP/1.1 200 OK<br/>Server: nginx/1.14.0 (Ubuntu)</span></pre><h2 id="6a0a" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">NPM (Node.js包管理器)</h2><ul class=""><li id="f5e7" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated">安装NPM:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d525" class="kn jl hi lp b fi lt lu l lv lw">$ sudo apt install npm</span></pre><ul class=""><li id="4473" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">验证安装:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="59bc" class="kn jl hi lp b fi lt lu l lv lw">$ npm -v<br/>6.14.13</span></pre><h2 id="7543" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">PM2(Nodejs应用程序生产流程经理)</h2><ul class=""><li id="a3e3" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated">安装PM2:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3bbd" class="kn jl hi lp b fi lt lu l lv lw">$ npm install pm2@latest -g</span></pre><ul class=""><li id="21be" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">验证安装:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="736f" class="kn jl hi lp b fi lt lu l lv lw">$ pm2 -v<br/>4.5.6</span></pre><h2 id="ee62" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">Certbot(从Let's Encrypt获取免费证书的客户端)</h2><ul class=""><li id="7a88" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated">确保您的snapd版本是最新的:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1244" class="kn jl hi lp b fi lt lu l lv lw">$ <!-- -->sudo snap install core; sudo snap refresh core</span></pre><ul class=""><li id="d4b2" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">安装证书机器人:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6d89" class="kn jl hi lp b fi lt lu l lv lw">$ sudo snap install --classic certbot</span></pre><ul class=""><li id="efa4" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated">准备Certbot命令:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="0ae1" class="kn jl hi lp b fi lt lu l lv lw">$ sudo ln -s /snap/bin/certbot /usr/bin/certbot</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="387d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">这种结构将如何工作？</h1><figure class="lk ll lm ln fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ma"><img src="../Images/ebda58844509d6ece760cac48338dbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9pfEAzTVZMW-srS9rZBIg.jpeg"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Flowchart Diagram for the deployment of Frontend and Backend on a single machine</figcaption></figure><p id="b99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Nginx将通过我们的PM2 Node.js实例为我们的React构建文件提供服务，并帮助我们的后端应用程序实现负载平衡。Node.js实例的数量与CPU拥有的内核数量成正比。要检查您的Linux CPU有多少内核，只需运行以下命令:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3e8e" class="kn jl hi lp b fi lt lu l lv lw">$ nproc<br/>4</span></pre><p id="ac1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，我的CPU中有四个内核，这将转化为运行PM2的Node.js的四个实例。这些实例将根据Nginx的特定负载平衡方法接收HTTPS请求流量。这将有助于我们充分发挥机器的潜力，并减少停机时间。</p><h2 id="c664" class="kn jl hi bd jm ko kp kq jq kr ks kt ju iq ku kv jy iu kw kx kc iy ky kz kg la bi translated">以下是PM2提供的一些主要功能:</h2><ul class=""><li id="66f5" class="lb lc hi ih b ii ki im kj iq ld iu le iy lf jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/application-declaration/" rel="noopener ugc nofollow" target="_blank">行为配置</a></li><li id="bd47" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/docker-pm2-nodejs/" rel="noopener ugc nofollow" target="_blank">集装箱集成</a></li><li id="93fd" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/cluster-mode/" rel="noopener ugc nofollow" target="_blank">集群模式</a></li><li id="1cca" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/watch-and-restart/" rel="noopener ugc nofollow" target="_blank">观看&amp;重新加载</a></li><li id="d204" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/log-management/" rel="noopener ugc nofollow" target="_blank">日志管理</a></li><li id="c569" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/monitoring/" rel="noopener ugc nofollow" target="_blank">监控</a></li><li id="66fe" class="lb lc hi ih b ii mn im mo iq mp iu mq iy mr jc lg lh li lj bi translated"><a class="ae mm" href="http://pm2.keymetrics.io/docs/usage/startup/" rel="noopener ugc nofollow" target="_blank">启动脚本</a></li></ul><p id="4167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们不会使用PM2提供的集群模式，因为我们将使用NGINX来平衡后端负载。这个决定将在本文中解释。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="07f1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">部署前端</h1><p id="7e9a" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">这将是您通常的前端部署，您将首先克隆您的项目存储库，安装您的依赖项并运行您的构建脚本。</p><p id="031c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克隆您的存储库:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1151" class="kn jl hi lp b fi lt lu l lv lw">$ mkdir project &amp;&amp; cd project</span><span id="8b8d" class="kn jl hi lp b fi ms lu l lv lw">$ git clone <a class="ae mm" href="https://gitlab.com/absolutsistemas/web/gis-be.git" rel="noopener ugc nofollow" target="_blank">git@gitlab.com:your/project/frontend.git</a></span></pre><p id="d658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装<em class="mt">节点模块</em>依赖关系:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="fbeb" class="kn jl hi lp b fi lt lu l lv lw">$ cd frontend</span><span id="04ac" class="kn jl hi lp b fi ms lu l lv lw">$ npm install</span></pre><p id="f91d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行您的构建脚本:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4ad6" class="kn jl hi lp b fi lt lu l lv lw">$ npm run build</span></pre><p id="2b62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取您的构建路径:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4a51" class="kn jl hi lp b fi lt lu l lv lw">$ cd build &amp;&amp; pwd<br/>/root/frontend/build</span></pre><p id="4925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，我们将在NGINX配置中使用这个构建路径。</p><h1 id="1ecf" class="jk jl hi bd jm jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh bi translated">用PM2设置后端</h1><p id="9127" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">首先，您需要克隆您的后端项目:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="c9b9" class="kn jl hi lp b fi lt lu l lv lw">$ cd project</span><span id="fe79" class="kn jl hi lp b fi ms lu l lv lw">$ git clone <a class="ae mm" href="https://gitlab.com/absolutsistemas/web/gis-be.git" rel="noopener ugc nofollow" target="_blank">git@gitlab.com:your/project/backend.git</a></span></pre><p id="bc7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装<em class="mt">节点_模块</em>依赖关系:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5740" class="kn jl hi lp b fi lt lu l lv lw">$ cd backend</span><span id="a8b0" class="kn jl hi lp b fi ms lu l lv lw">$ npm install</span></pre><p id="683e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以利用PM2的<em class="mt">行为配置</em>特性，用环境变量和PM2参数创建一个YAML格式的生态系统文件。</p><p id="7de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个有四个内核的CPU，用四个工人创建一个<strong class="ih hj"> process.yml </strong>文件:</p><figure class="lk ll lm ln fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="ee90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数:</p><ul class=""><li id="bf0c" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">脚本</strong></li></ul><p id="def2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相对于pm2开始的脚本路径</p><ul class=""><li id="cd1d" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">执行模式</strong></li></ul><p id="ea3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动你的应用程序的模式，可以是“集群”或“分叉”</p><ul class=""><li id="fcb6" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">名称</strong></li></ul><p id="4861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的PM2节点的名称</p><ul class=""><li id="441d" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">环境</strong></li></ul><p id="ee23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将出现在应用程序中的环境变量</p><p id="6b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，Node.js应用程序应该准备好使用动态端口号运行。</p><figure class="lk ll lm ln fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="4fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成所有设置后，您可以使用start命令启动您的工作程序:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3cbd" class="kn jl hi lp b fi lt lu l lv lw">$ pm2 start process.yml</span></pre><p id="2717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动workers后，您将能够检查当前运行的PM2节点列表:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="ce53" class="kn jl hi lp b fi lt lu l lv lw">$ pm2 list</span></pre><figure class="lk ll lm ln fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es nb"><img src="../Images/23db7d1b7028e711b80b27b9a1cae861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQWCgb3on_Gyb7GFZI5S5w.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">List of PM2 nodes running</figcaption></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="183d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">配置DNS</h1><p id="18c3" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">您需要在您的域中添加一个指向您的机器IP地址的DNS记录。</p><p id="12f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查找您的计算机的IP地址，请运行以下命令:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="767b" class="kn jl hi lp b fi lt lu l lv lw">$ ip r<br/>default via <strong class="lp hj">192.08.62.1</strong> dev eth0 onlink<br/>192.08.62.2/24 dev eth0 proto kernel scope link src <strong class="lp hj">192.08.62.1</strong></span></pre><p id="a079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在您的域名DNS设置中，添加一个指向<strong class="ih hj">192.08.62.1</strong>的DNS记录:</p><figure class="lk ll lm ln fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es nc"><img src="../Images/f37a2d95f6e696090e5f1e8bfd6cfe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7jY6yiRYq7-v5bmCRtaRA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">DNS record that points to the Linux machine</figcaption></figure><p id="188b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DNS传播需要72小时才能完成，但可能需要一两个小时左右。您可以使用<a class="ae mm" href="https://dnschecker.org/" rel="noopener ugc nofollow" target="_blank"> DNS Checker </a>检查您的域名是否有更新的DNS记录。</p><h1 id="481e" class="jk jl hi bd jm jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh bi translated">配置Nginx</h1><p id="eb39" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">您需要访问Nginx配置文件并添加代码块，以便它能够解释您的架构并相应地重定向请求。</p><p id="28b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问并开始编辑配置文件:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="b8f2" class="kn jl hi lp b fi lt lu l lv lw">$ nano /etc/nginx/sites-available/default</span></pre><p id="efe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我们需要添加<strong class="ih hj"> upstream </strong>块，这是一种告诉Nginx当这个上游收到请求时，它应该根据特定的负载平衡方法在多个服务器之间进行代理的方式。</p><p id="be6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可用的负载平衡方法有:</p><ul class=""><li id="940a" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">循环赛(默认)</strong></li></ul><p id="82da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，Nginx按顺序遍历上游服务器列表，依次将下一个连接请求分配给每个服务器。</p><ul class=""><li id="d6c4" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">哈希</strong></li></ul><p id="6131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个方法中，Nginx计算一个基于文本和Nginx变量组合的散列，并将其分配给其中一个服务器。与哈希匹配的传入请求将只发送到该特定服务器。</p><ul class=""><li id="99b6" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj"> IP哈希</strong></li></ul><p id="acb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哈希是根据客户端的IP地址计算的。这种方法确保来自同一个客户机的多个请求到达同一个服务器。</p><ul class=""><li id="6978" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">最少连接</strong></li></ul><p id="2867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Nginx使用最少的连接将传入的请求发送到服务器，从而维持服务器间的负载。</p><ul class=""><li id="5594" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">最少时间</strong></li></ul><p id="9d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，Nginx通过使用当前活动连接数和过去请求的加权平均响应时间来计算值并分配给每个服务器，并将传入的请求发送给具有最低值的服务器。</p><p id="1d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于这个例子的目的，我们将使用最常见的方法<strong class="ih hj">最少连接数</strong>。</p><p id="6132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将上游块添加到默认配置文件中:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8e1c" class="kn jl hi lp b fi lt lu l lv lw">upstream loadbalancer {<br/>  least_conn;<br/>  server localhost:3500;<br/>  server localhost:3501;<br/>  server localhost:3502;<br/>  server localhost:3503;<br/>}</span></pre><p id="2dd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当向https://example.com的<a class="ae mm" href="https://example.com" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><strong class="ih hj"/>发出请求时，它应该用我们的前端文件做出响应，当向https://example.com/api的<a class="ae mm" href="https://example.com/api" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>发出请求时，它应该用一个<em class="mt"> proxy_pass </em>重定向到我们的负载平衡器。</p><p id="fb8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此配置结束时，您的默认配置文件应该如下所示:</p><figure class="lk ll lm ln fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><ul class=""><li id="2036" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">位置/ </strong>块:</li></ul><p id="556c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将root作为您的前端构建文件夹路径，这不仅对React构建有效，而且对任何使用<strong class="ih hj">index.html</strong>文件生成静态构建文件的javascript框架都有效。</p><ul class=""><li id="0c54" class="lb lc hi ih b ii ij im in iq lx iu ly iy lz jc lg lh li lj bi translated"><strong class="ih hj">位置/api/ </strong>区块:</li></ul><p id="4064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">会将每个HTTPS请求重定向到我们的负载均衡器。Nginx可以识别出一个名为<strong class="ih hj"> loadbalancer </strong>的上游已经被声明，所以我们可以直接proxy_pass到<strong class="ih hj"> http://loadbalacer/ </strong>。</p><p id="7e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保存配置文件后，检查保存的语法是否有效:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="979b" class="kn jl hi lp b fi lt lu l lv lw">$ sudo nginx -t<br/>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br/>nginx: configuration file /etc/nginx/nginx.conf test is successful</span></pre><p id="a2f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新加载Nginx以反映最近的更改:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d18c" class="kn jl hi lp b fi lt lu l lv lw">$ systemctl reload nginx</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="678d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用Certbot设置免费的SSL证书</h1><p id="571c" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">要在Nginx配置中设置SSL:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d2ed" class="kn jl hi lp b fi lt lu l lv lw">sudo certbot --nginx</span></pre><p id="1478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循每个安装步骤。Certbot将从Let's encrypt获取一个证书，并自动更新您的Nginx配置文件。</p><p id="b905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以测试Certbot的自动更新:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8b33" class="kn jl hi lp b fi lt lu l lv lw">sudo certbot renew --dry-run</span></pre><p id="8f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都完成了，你可以在<a class="ae mm" href="https://example.com!" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">https://example.com</strong></a>访问你的应用！😄</p><h1 id="6705" class="jk jl hi bd jm jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh bi translated"><strong class="ak">结论</strong></h1><p id="fd77" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们现在可以理解为什么使用Nginx的这种负载平衡方法比只使用PM2的集群模式更好。当您的应用程序维护低水平的并发用户时，您可以使用这种初始架构。当这些用户开始到来，而这种配置不再足够时，您可以轻松地将该机器仅用于负载平衡，并开始将您的上游重定向到localhost之外的服务器，这样可以实现平滑的水平扩展。</p><p id="c8c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们当前设置下水平缩放的直观表示:</p><figure class="lk ll lm ln fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es nd"><img src="../Images/967a01f3a47565cfb75d2a6d66a89197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2C5IkHZZo1MTmb1IIkxOw.jpeg"/></div></div></figure></div></div>    
</body>
</html>
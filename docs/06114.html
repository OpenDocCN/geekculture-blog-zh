<html>
<head>
<title>Breadth First Search (in java)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索(java语言)</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/breadth-first-search-in-java-d32d29f6bb9e?source=collection_archive---------3-----------------------#2021-08-06">https://medium.com/geekculture/breadth-first-search-in-java-d32d29f6bb9e?source=collection_archive---------3-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7dec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BFS是一个经典的图搜索算法。这里是<a class="ae jd" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank"> wiki </a>提供的定义</p><blockquote class="je jf jg"><p id="f4f1" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">广度优先搜索</strong> ( <strong class="ih hj"> BFS </strong>)是一种<a class="ae jd" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>，用于在<a class="ae jd" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>数据结构中搜索满足给定属性的节点。它从<a class="ae jd" href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology" rel="noopener ugc nofollow" target="_blank">树根</a>开始，在移动到下一个深度级别的节点之前，探索当前<a class="ae jd" href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology" rel="noopener ugc nofollow" target="_blank">深度</a>的所有节点。需要额外的内存，通常是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Queue_(data_structure)" rel="noopener ugc nofollow" target="_blank">队列</a>，来跟踪已经遇到但还没有探索的子节点。</p><p id="691b" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">例如，在<a class="ae jd" href="https://en.wikipedia.org/wiki/Chess_endgame" rel="noopener ugc nofollow" target="_blank">国际象棋残局</a>中，<a class="ae jd" href="https://en.wikipedia.org/wiki/Chess_engine" rel="noopener ugc nofollow" target="_blank">国际象棋引擎</a>可以通过应用所有可能的移动从当前位置构建<a class="ae jd" href="https://en.wikipedia.org/wiki/Game_tree" rel="noopener ugc nofollow" target="_blank">博弈树</a>，并使用广度优先搜索为白棋找到获胜位置。隐式树(如博弈树或其他解决问题的树)的大小可能是无限的；广度优先搜索保证找到一个解节点<a class="ae jd" href="https://en.wikipedia.org/wiki/Breadth-first_search#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>(如果存在的话)。</p></blockquote></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="e5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BFS是一种解决图论问题的算法，下面是一些应用:</p><p id="ab44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.求未加权图中两个节点间的最短路径。通过扩展，我们可以发现图中的两个节点之间是否存在路径，以及从一个特定节点可以到达的所有节点。</p><p id="d7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.计算流量网络中的最大流量(福特-富尔克森算法)。我们也可以使用深度优先搜索，但是BFS降低了最坏情况的复杂度。</p><p id="673e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.GPS使用BFS查找邻近位置</p><p id="8f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.社交网络。就像培根数的经典例子一样，我和蕾哈娜相差n度。n趋向于无穷大。</p><p id="f06b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.网络广播使用BFS到达所有节点</p><p id="9b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.快速解魔方</p><p id="dff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.网络爬虫使用BFS建立相关页面的索引</p><p id="0201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8.对等网络使用BFS来寻找最近的邻居节点</p><p id="0d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9.垃圾收集(使用切尼算法)</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="ec12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的时间复杂度为O(v + e)</p><p id="66e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">v —图形中顶点的数量</p><p id="1873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">e —图中的边数</p><p id="bc94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，遍历该图所需的时间取决于该图中顶点和边的数量。不能说我没想到会这样。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="53da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">伪代码</strong>看起来像这样:</p><ol class=""><li id="edad" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">初始化未访问节点的队列</li><li id="b9ad" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">挑选一个节点并将其添加到队列中</li><li id="5d04" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">从队列前面取出第一个节点，并将其添加到已访问节点列表中</li><li id="1f20" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">仅当刚刚访问过的节点的所有相邻节点尚未被访问时，才将它们添加到队列中</li><li id="d0f5" class="js jt hi ih b ii kb im kc iq kd iu ke iy kf jc jx jy jz ka bi translated">重复3和4，直到队列为空</li></ol><p id="c17e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了防止一次又一次地处理同一个节点，我们使用一个布尔数组来标记被访问过的节点。我们使用一个队列来存储节点，并将它们标记为“已访问”,直到它的所有邻居都被标记。就像厨房一样，队列遵循先进先出(FIFO)的方法，所以邻居是按照插入的顺序被访问的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/115793983497ba611f0fb36cb654508c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*JQTq3G9G9a8Y6jeHZbFQrQ.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">graph</figcaption></figure><p id="b4f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，看看这个图表。虽然这是一个看起来很悲伤的图表，但它必须用于教育目的。</p><p id="2daa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将添加一个<strong class="ih hj">父数组</strong>，它将引用哪个顶点是由哪个其他顶点引入的。</p><p id="bc1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们从S开始，我们将它标记为-1，因为它是源。</p><p id="a08b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点1和3是由S引入的，所以我们将它们标记为0，因为它们是由源引入的。</p><p id="1cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点5由节点1引入</p><p id="d962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点2是由1和3引入的，但为了方便起见，我们称它是由节点3引入的</p><p id="1e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点4由节点3引入</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ks"><img src="../Images/cc6feae3e9edd7dcf7ee18990e367185.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Egf0_y2t9iVBACPvlpLM8A.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">parent array of graph</figcaption></figure><p id="c0a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了整个图形的分层表示。你可能会问，这有什么用？现在它告诉我们任意节点间的最短路径。假设你想找出从节点4到节点s的最短路径。</p><p id="c144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点4的值是3，我们去节点3。</p><p id="dbd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点3的值是0，我们我们去源。</p><p id="9f02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，从节点4到源的路径是4 → 3 → S</p><p id="c005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这显然是一个简单的例子，但是同样的基本思想可以扩展到你想要运行它的任何图形上。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="8a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还将为计算机创建一个<strong class="ih hj">邻接表</strong>,以了解哪个节点通过一条边链接到哪个其他节点。为此，我们将使用一个链表数组。1表示有边，0表示没有边。</p><p id="8cb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使我们可以将图形作为一个数组来查看，并确定一条边是否是共享的。一旦我们知道了这一点，我们就可以将此信息记录到父阵列，并移动到队列中的下一个节点。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kt"><img src="../Images/d18a12f7ec7b54cf15fd36caffb73f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*bloNb_lu8mni_3feNnxBag.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">adjacency list of graph</figcaption></figure></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="02c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">队列<strong class="ih hj">的功能类似于</strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/bd1a2d4c3168155b4c2e6e815b8c9bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlIXpF2r1pzWhGTIv2OVoQ.png"/></div></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/5d64560dae1e59b56ccecdaa58add361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Efg9dP9L3dSVy42_-hOgSw.png"/></div></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es la"><img src="../Images/297de97564ffb3eb0d7a02e054238bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*WS5sPj2-YOGnQXXJ2aO-IA.png"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lb"><img src="../Images/ef15ab3c1dd13c9c3f9ef08caba7ae5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*DpeUpAtrcRzSyDoqz4F0fA.png"/></div></figure></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="5a24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好，让我们看看所有这些部分是如何编码在一起的:</p><pre class="kh ki kj kk fd lc ld le lf aw lg bi"><span id="6899" class="lh li hi ld b fi lj lk l ll lm">import java.util.LinkedList;<br/>import java.util.Queue;<br/>import java.util.Scanner;</span><span id="17ab" class="lh li hi ld b fi ln lk l ll lm">public class Graph {<br/>    private LinkedList&lt;Integer&gt; adjacencyList[];</span><span id="f61b" class="lh li hi ld b fi ln lk l ll lm">    public Graph (int vertex) {<br/>        adjacencyList = new LinkedList[vertex];<br/>        for (int i = 0; i &lt; vertex; i++) {<br/>            adjacencyList[i] = new LinkedList&lt;Integer&gt;();<br/>        }<br/>    }</span><span id="01f1" class="lh li hi ld b fi ln lk l ll lm">    public void addEdge(int start, int finish) {<br/>        adjacencyList[start].add(finish);<br/>        adjacencyList[finish].add(start);<br/>    }</span><span id="f249" class="lh li hi ld b fi ln lk l ll lm">    // minimum distance between start and finish nodes using BFS<br/>    public int BFS(int start, int finish) {</span><span id="1d42" class="lh li hi ld b fi ln lk l ll lm">        // array to hold vertices already visited<br/>        boolean[] visited = new boolean[adjacencyList.length];</span><span id="7391" class="lh li hi ld b fi ln lk l ll lm">        //parent array holds value of vertex which introduced this vertex<br/>        int[] parent = new int[adjacencyList.length];<br/>        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();<br/>        </span><span id="2977" class="lh li hi ld b fi ln lk l ll lm">        q.add(start);<br/>        parent[start] = -1;<br/>        visited[start] = true;</span><span id="dfd9" class="lh li hi ld b fi ln lk l ll lm">        while (!q.isEmpty()) {<br/>            // pull out the first vertex in the queue<br/>            int current = q.poll();</span><span id="f9d4" class="lh li hi ld b fi ln lk l ll lm">            // if the vertex pulled is the last one, break loop<br/>            if (current == finish) break;</span><span id="511a" class="lh li hi ld b fi ln lk l ll lm">            for (int neighbour: adjacencyList[current]) {<br/>                // if neighbour hasn't been visited<br/>                if(!visited[neighbour]) {<br/>                    visited[neighbour] = true;<br/>                    // add to the queue<br/>                    q.add(neighbour);<br/>                    // since current vertex introduced us<br/>                    parent[neighbour] = current;<br/>                }<br/>            }<br/>        }</span><span id="e24b" class="lh li hi ld b fi ln lk l ll lm">        //traverse through the parent array<br/>        int current = finish;<br/>        int distance = 0;<br/>        while (parent[current] != -1) {<br/>            System.out.print(current + "-&gt; ");<br/>            current = parent[current];<br/>            distance++;<br/>        }<br/>        System.out.print(start);</span><span id="c41f" class="lh li hi ld b fi ln lk l ll lm">        return distance;<br/>    }</span><span id="aeac" class="lh li hi ld b fi ln lk l ll lm">public static void main(String[] args) {<br/>        Scanner sc = new Scanner(System.in);<br/>        System.out.println("Enter number of vertices and edges");<br/>        int vertices = sc.nextInt();<br/>        int edges = sc.nextInt();</span><span id="9106" class="lh li hi ld b fi ln lk l ll lm">        // define graph<br/>        Graph graph = new Graph(vertices);</span><span id="ee94" class="lh li hi ld b fi ln lk l ll lm">        // input edges and initialize graph<br/>        System.out.printf("Enter %d edges: ", edges);<br/>        for (int i = 0; i &lt; edges; i++) {<br/>            int start = sc.nextInt();<br/>            int finish = sc.nextInt();<br/>            graph.addEdge(start, finish);<br/>        }</span><span id="04ba" class="lh li hi ld b fi ln lk l ll lm">        System.out.println("Enter start and end vertex");<br/>        int start = sc.nextInt();<br/>        int finish = sc.nextInt();</span><span id="c05e" class="lh li hi ld b fi ln lk l ll lm">        int distance = graph.BFS(start, finish);<br/>        System.out.println("\nMinimum distance between " + start + "           &amp; " + finish + " is " + distance);<br/>    }<br/>}</span></pre><p id="c9d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次到此为止。随着我了解更多，我会进一步优化这一点。但是现在，这已经足够了👋👋</p></div></div>    
</body>
</html>
<html>
<head>
<title>Using the new C# Azure.Data.Tables SDK with Azure Cosmos DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用新的C# Azure。带有Azure Cosmos DB的数据表SDK</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/using-the-new-c-azure-data-tables-sdk-with-azure-cosmos-db-786085ac8190?source=collection_archive---------2-----------------------#2021-07-05">https://medium.com/geekculture/using-the-new-c-azure-data-tables-sdk-with-azure-cosmos-db-786085ac8190?source=collection_archive---------2-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b101" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本文中，我将向您展示我们如何使用新的Azure对Azure Cosmos DB Table API帐户执行简单的操作。表C# SDK。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bd0ef98de3044b79b1ff70a87d76a790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AtKwtoq8sw56MiYa.png"/></div></div></figure><p id="ec12" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上个月，<a class="ae kf" href="https://devblogs.microsoft.com/azure-sdk/announcing-the-new-azure-data-tables-libraries/" rel="noopener ugc nofollow" target="_blank"> Azure SDK团队发布了一个新的Azure Tables库。NET，Java，JS/TS和Python </a>。这个版本使Table SDK与其他<a class="ae kf" href="https://aka.ms/azsdk/guide" rel="noopener ugc nofollow" target="_blank">Azure SDK</a>保持一致，它们使用特定的Azure核心包来处理请求、错误和凭证。</p><p id="c076" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/table-introduction" rel="noopener ugc nofollow" target="_blank"> Azure Cosmos DB提供了一个Table API </a>产品，本质上是Azure Table Storage的兴奋剂！如果你需要一个全球分布的表存储服务，Azure Cosmos DB应该是你的首选。</p><p id="ac3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你要在Azure Cosmos DB Table API和常规Azure Table存储之间做出选择，我建议你阅读下面的<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/table-introduction#table-offerings" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="d8d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将向您展示我们如何使用新的Azure对Azure Cosmos DB Table API帐户执行简单的操作。表C# SDK。具体来说，我们将回顾:</p><ul class=""><li id="21c8" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">安装SDK💻</li><li id="7dfd" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">连接到我们的表客户机并创建一个表🔨</li><li id="0890" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">定义我们的实体🧾</li><li id="0c33" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">添加实体➕</li><li id="1269" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">执行事务性批处理操作💰</li><li id="aa89" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">查询我们的表❓</li><li id="e227" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">删除实体❌</li></ul><p id="9ef5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们开始吧！</p><h1 id="6af8" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">安装SDK💻</h1><p id="41b3" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">安装SDK非常简单。我们可以通过运行下面的<em class="lr"> dotnet </em>命令来做到这一点:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="6d90" class="lx kv hi lt b fi ly lz l ma mb">dotnet add package Azure.Data.Tables</span></pre><p id="e633" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你更喜欢使用UI来安装NuGet包，我们可以在Visual Studio中右键单击我们的C#项目，单击管理NuGet包并搜索<strong class="jl hj"> Azure。数据表</strong>包:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/935e2a090fb20a35c10cec50f6684c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FAtmDDA5ZiVoEyGW.png"/></div></div></figure><h1 id="68c4" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">连接到我们的表客户机并创建一个表🔨</h1><p id="bdad" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">SDK为我们提供了两个客户端来与服务进行交互。一个<em class="lr"> TableServiceClient </em>用于在帐户级别与我们的表进行交互。</p><p id="1f6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们这样做是为了创建表、设置访问策略等。</p><p id="af9c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们也可以使用一个<em class="lr"> TableClient </em>。这用于在我们的实体上执行操作。我们还可以使用<em class="lr"> TableClient </em>来创建如下表格:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="bfce" class="lx kv hi lt b fi ly lz l ma mb">TableClient tableClient = new TableClient(config["StorageConnection"], "Customers");<br/>            await tableClient.CreateIfNotExistsAsync();</span></pre><p id="156e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了创建我们的表客户端，我从Azure传入我的存储连接字符串和我想要与之交互的表的名称。在下面一行中，如果表不存在，我们就创建它。</p><p id="f2fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要获取存储连接字符串，我们可以从我们的Cosmos DB帐户的<strong class="jl hj">连接字符串</strong>下进行:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/c4a690ad4715e258d274379b0b18180a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wNhOEllUasy7Jh49.png"/></div></div></figure><p id="dd0f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们第一次运行这段代码时，我们可以看到已经在数据浏览器中创建了这个表:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es md"><img src="../Images/33a2bae0a65c666e0470eb285220807a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/0*HyM_KIumq0tHUVv-.png"/></div></figure><h1 id="12d1" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">定义我们的实体🧾</h1><p id="ccd4" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在表存储中，我们在表中创建需要一个<em class="lr">分区键</em>和一个<em class="lr">行键</em>的实体。这些的组合需要在我们的表中是唯一的。</p><p id="ff74" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实体有一组属性，强类型实体需要从<em class="lr"> ITableEntity </em>接口扩展，该接口公开分区键、行键、ETag和时间戳属性。ETag和Timestamp会由Cosmos DB生成，所以我们不需要设置这些。</p><p id="8bec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于本教程，我将使用上述属性和两个字符串属性(Email和PhoneNumber)来组成一个<strong class="jl hj"> CustomerEntity </strong>类型。</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="af3d" class="lx kv hi lt b fi ly lz l ma mb">public class CustomerEntity : ITableEntity<br/>{<br/>    public string PartitionKey { get; set ; }<br/>    public string RowKey { get; set; }<br/>    public string Email { get; set; }<br/>    public string PhoneNumber { get; set; }<br/>    public DateTimeOffset? Timestamp { get; set; }<br/>    public ETag ETag { get; set; }<br/>}</span></pre><h1 id="4c73" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">添加实体➕</h1><p id="c20f" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">要向我们的表中添加一个新实体，我们需要实例化它并简单地调用<em class="lr">。AddEntityAsync() </em>方法来插入它:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="82ee" class="lx kv hi lt b fi ly lz l ma mb">CustomerEntity customerEntity = new CustomerEntity()<br/>{<br/>     PartitionKey = "Velida",<br/>     RowKey = "Will",<br/>     PhoneNumber = "0123456789",<br/>     Email = "will@test.com"<br/>};</span><span id="1d81" class="lx kv hi lt b fi me lz l ma mb">await tableClient.AddEntityAsync(customerEntity);</span></pre><p id="e845" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回到Cosmos DB中的Customers表，我们可以看到实体被成功插入。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/83fae143b732184e2fe09a46e948af62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ECGH4hcsTLtjawge.png"/></div></div></figure><h1 id="aba4" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">执行事务性批处理操作💰</h1><p id="8442" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">表服务允许我们在一个批处理请求中进行多个操作。</p><p id="4110" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">事务是“全有或全无”，这意味着如果我们批处理中的一个操作失败，<strong class="jl hj">它们都将失败！</strong>事务可以混合执行创建、删除、更新和更新操作。</p><p id="040a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，一个事务中的所有操作都需要以同一个分区键为目标。</p><p id="105c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在下面的代码片段中，我正在创建一个<em class="lr"> CustomerEntity </em>对象的列表，我将把这些对象作为一个批处理创建操作插入到我的表中。</p><p id="4f3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我们创建一个类型为<em class="lr"> TableTransactionAction </em>的新列表，并将我们希望包含在批处理操作中的实体列表添加到其中。然后我们使用<em class="lr">。SubmitTransactionAsync() </em>提交批处理操作的方法:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="c9fa" class="lx kv hi lt b fi ly lz l ma mb">string partitionKey = "Velida";<br/>List&lt;CustomerEntity&gt; familyList = new List&lt;CustomerEntity&gt;<br/>{<br/>      new CustomerEntity<br/>      {<br/>            PartitionKey = partitionKey,<br/>            RowKey = "Don",<br/>            PhoneNumber = "0987612345"<br/>      },<br/>      new CustomerEntity<br/>      {<br/>            PartitionKey = partitionKey,<br/>            RowKey = "Jane",<br/>            PhoneNumber = "0987612345"<br/>      },<br/>      new CustomerEntity<br/>      {<br/>            PartitionKey = partitionKey,<br/>            RowKey = "Jan",<br/>            PhoneNumber = "0987601298",<br/>            Email = "jan@test.com"<br/>      }<br/>};</span><span id="3604" class="lx kv hi lt b fi me lz l ma mb">List&lt;TableTransactionAction&gt; addFamilyBatch = new List&lt;TableTransactionAction&gt;();</span><span id="6c8a" class="lx kv hi lt b fi me lz l ma mb">addFamilyBatch.AddRange(familyList.Select(f =&gt; new TableTransactionAction(TableTransactionActionType.Add, f)));</span><span id="7b6b" class="lx kv hi lt b fi me lz l ma mb">Response&lt;IReadOnlyList&lt;Response&gt;&gt; response = await tableClient.SubmitTransactionAsync(addFamilyBatch);</span></pre><p id="93d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回到我们的表中，我们可以看到实体已经成功地插入到我们的表中:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/46e25f16caac1d3fb4e2186c34950d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B_U-9AxncOAdo8aH.png"/></div></div></figure><h1 id="8915" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">查询我们的表❓</h1><p id="d206" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">我们可以用几种方法查询表存储中的数据。下面的代码片段使用了一个OData表达式。</p><p id="1468" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用OData查询过滤器可能是一件痛苦的事情，但是SDK提供了一个帮助器库，使它变得稍微容易一些。使用<em class="lr">。CreateQueryFilter() </em>，我们可以这样编写我们的OData查询:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="ad5b" class="lx kv hi lt b fi ly lz l ma mb">Pageable&lt;TableEntity&gt; oDataQueryEntities = tableClient.Query&lt;TableEntity&gt;(filter: TableClient.CreateQueryFilter($"PartitionKey eq {partitionKey}"));</span><span id="996e" class="lx kv hi lt b fi me lz l ma mb">foreach (TableEntity entity in oDataQueryEntities)<br/>{<br/>    Console.WriteLine($"{entity.GetString("PartitionKey")}:{entity.GetString("RowKey")}");<br/>}</span></pre><p id="caca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">运行这段代码，我们可以看到我们的实体<em class="lr">分区键</em>和<em class="lr">行键</em>的连接，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/c5e3a86f7ff45dc3654a3da87e9f8595.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/0*oyP8t5of-iccX5CW.png"/></div></figure><p id="4cc6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还可以使用LINQ表达式来查询我们的表。这里，我使用LINQ查询来检索一个<em class="lr"> CustomerEntity </em>，其<em class="lr"> RowKey </em>值为“Will”:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="2266" class="lx kv hi lt b fi ly lz l ma mb">Pageable&lt;CustomerEntity&gt; linqEntities = tableClient.Query&lt;CustomerEntity&gt;(customer =&gt; customer.RowKey == "Will");</span><span id="b587" class="lx kv hi lt b fi me lz l ma mb">foreach (var entity in linqEntities)<br/>{<br/>     Console.WriteLine($"{entity.RowKey} {entity.PartitionKey}");<br/>}</span></pre><p id="758b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当这段代码运行时，我们可以看到打印出来的实体:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mg"><img src="../Images/4f0a1f5f33e41f6feaf7519d5f44a335.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/0*laBFfRsJV40X7K5J.png"/></div></figure><h1 id="33b3" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">删除实体❌</h1><p id="17a7" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">从我们的表中删除实体只是一个简单的<em class="lr">。DeleteEntityAsync() </em>调用。我们需要做的就是像这样传入我们的<em class="lr">分区键</em>和<em class="lr">行键</em>值:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="4947" class="lx kv hi lt b fi ly lz l ma mb">await tableClient.DeleteEntityAsync(partitionKey, "Will");</span></pre><p id="ae9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">检查我们的表，我们可以看到我们的实体已被成功删除:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/2a4878c90b6d4b32da0cbf634594bef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VGWZXIEBRr-2PfT8.png"/></div></div></figure><h1 id="ea07" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">包扎</h1><p id="be2e" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">希望读完这篇文章后，你能理解使用Azure。Data.Tables SDK非常简单。我喜欢Azure SDK团队采取的使其SDK彼此更加一致的方法。</p><p id="a71d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用天蓝色。Data.Tables SDK，我们可以构建同时使用Azure Cosmos DB表存储和常规表存储的应用程序，因此如果您发现您正在使用常规表存储构建应用程序，并且您正在努力扩展，您可以切换到Cosmos DB，而无需任何代码更改！</p><p id="3cd5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想了解更多关于Azure的知识。Data.Tables library，看看<a class="ae kf" href="https://devblogs.microsoft.com/azure-sdk/announcing-the-new-azure-data-tables-libraries/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>和<a class="ae kf" href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/tables/Azure.Data.Tables/samples" rel="noopener ugc nofollow" target="_blank">这篇GitHub repo </a>！</p><p id="8d05" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">希望这篇文章对你有用！一如既往，如果你有任何问题，欢迎在下面评论或在<a class="ae kf" href="https://twitter.com/willvelida" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上问我！</p><p id="ddfc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编码快乐！💻👨‍💻👩‍💻</p></div></div>    
</body>
</html>
<html>
<head>
<title>Rebuilding an Imperatively-Coded Game from Scratch in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中从头开始重建强制编码的游戏</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rebuilding-an-imperatively-coded-game-from-scratch-in-react-9a082ad002c0?source=collection_archive---------26-----------------------#2021-04-09">https://medium.com/geekculture/rebuilding-an-imperatively-coded-game-from-scratch-in-react-9a082ad002c0?source=collection_archive---------26-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6769860e7c1e44c0612802e2efea5610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgnOESlQdjMRWslRID5-LA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">The Guessing Game (<a class="ae iu" href="https://shapirodaniel.github.io/guessing-game-react/" rel="noopener ugc nofollow" target="_blank">https://shapirodaniel.github.io/guessing-game-react/</a>)</figcaption></figure><p id="ac96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">我们将重新打造的游戏！</em> <a class="ae iu" href="https://shapirodaniel.github.io/guessing-game-imperative/" rel="noopener ugc nofollow" target="_blank"> <em class="jt">猜谜游戏，命令式</em> </a></p><p id="35e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">重构后的基于React的游戏！</em> <a class="ae iu" href="https://shapirodaniel.github.io/guessing-game-react/" rel="noopener ugc nofollow" target="_blank"> <em class="jt">猜谜游戏，功能性+反应性</em> </a></p><p id="42ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">Github repos for both:</em><a class="ae iu" href="https://github.com/shapirodaniel/guessing-game-imperative" rel="noopener ugc nofollow" target="_blank"><em class="jt">命令式代码库</em> </a> <em class="jt"> | </em> <a class="ae iu" href="https://github.com/shapirodaniel/guessing-game-react" rel="noopener ugc nofollow" target="_blank"> <em class="jt">功能性+反应式代码库</em> </a></p><p id="538f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你和我一样，你至少有一个有趣的副业，当你还是个新手的时候，就已经写好了。当我2020年加入Fullstack Academy时，我刚刚为面包师傅编写了一个食谱管理工具(查看一下！面包师的朋友)，而且对框架一无所知，我用我所有的新的命令式技巧构建了我的下一个web app——一个在1到100之间的10 x 10数字网格上玩的猜谜游戏。</p><p id="066f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然游戏逻辑肯定可以重构，但游戏机制——你可以作为对用户交互的响应而锁定的一切——这是一个— <em class="jt">插入太阳镜迷因— </em>反应框架的真正好处将会显现出来。</p><p id="fa78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">告诉我你想要什么(你真的真的想要什么)</strong></p><p id="6a45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">命令式编程的困难之处在于，您必须详尽地记录实现某个效果所需的步骤。React通过允许您描述<em class="jt">您希望发生什么</em>，而不是<em class="jt">您希望它如何发生</em>，释放了精神资源——所以让我们将DOM的微观管理转向React，以便我们可以专注于更高层次的问题，如游戏逻辑和多个相关DOM节点或<em class="jt">组件的交互</em>。</p><p id="86c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在我们开始React之前，让我们先来看看这个游戏场的命令式版本。尽管React允许我们使用JSX并编写HTML、CSS和Javascript的混合代码，但命令式代码库使标记在很大程度上与控制器(JS)分离。</p><p id="529e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们构建一个“奇数行”模板，用数字填充它。(也有一个“偶数行”模板，其中的<code class="du ju jv jw jx b">darkSquare, lightSquare</code>类是交替的，我们将把它留给想象……)</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/rowtemplate" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/rowtemplate</a></figcaption></figure><p id="0ed8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们指定一个容纳十行的游戏场容器。如果你曾经使用过React，这种策略反映了框架从顶级容器呈现应用程序的方法，通常被标识为<em class="jt">根</em>或<em class="jt">应用程序</em>。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist: <a class="ae iu" href="https://tinyurl.com/imperativeplayingfield" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/imperativeplayingfield</a></figcaption></figure><p id="7b6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，在我们的游戏类中，我们调用<code class="du ju jv jw jx b">buildPlayingField()</code>来构建网格，调用<code class="du ju jv jw jx b">assignNodeVals()</code>来给每个网格分配一个从1到100的数字。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/buildplayingfield" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/buildplayingfield</a></figcaption></figure><p id="bf5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将我们强制性编码的游戏场转换成面向功能的React组件，我们可能会得到类似这样的东西——首先，一个名为<code class="du ju jv jw jx b">Row</code>的子组件呈现棋盘模式的单行。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-row-impl" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/reactrow</a></figcaption></figure><p id="1d40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们创建一个<code class="du ju jv jw jx b">PlayingField</code>组件，它将映射一个“标量”列表——这些是我们希望每行从其开始的数字——并将标量传递给<code class="du ju jv jw jx b">Row</code>子组件。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-playingfield" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-playingfield</a></figcaption></figure><p id="f302" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编写函数式React组件而不是命令式代码的好处在于它们固有的可维护性和可扩展性——简洁不是主要问题，因为我们编写了更多的代码来完成相同的任务。在我们的React游戏领域中，棋盘的全部逻辑都包含在一个函数中，我们没有详尽地记录应用程序应该如何构建DOM，而是描述我们希望看到的内容，将其余的留给React。</p><blockquote class="ke kf kg"><p id="9ae0" class="iv iw jt ix b iy iz ja jb jc jd je jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated"><strong class="ix hj">国家是巨大的发动机，缓慢地运转着。(弗朗西斯·培根)</strong></p></blockquote><p id="8529" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React在状态管理方面真的大放异彩——跟踪用户当前经历的“情况”的所有值Bacon的格言让我们知道为什么:状态是一个庞大的事物，从用户加载我们的应用程序的那一刻起，它就向许多方向爬行和分支。报道州内可能出现的每一个案件就相当于旋转盘子的把戏——为了避免一堆碎陶瓷，每个事件都必须精确地按顺序处理。</p><p id="7362" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果没有状态管理系统，命令式状态管理会很快<em class="jt">分离</em>:以这个处理所有点击事件及其相关逻辑的单片功能<code class="du ju jv jw jx b">clickHandler</code>为例。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-clickhandler" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-clickhandler</a></figcaption></figure><p id="559d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们有办法将<strong class="ix hj">游戏逻辑</strong>从<strong class="ix hj"> DOM元素本身</strong>中分离出来，这样我们就可以分别对它们进行推理，会怎么样？如果以这种方式分离关注点，我们会得到什么好处呢？</p><p id="8ede" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过提取状态逻辑来重构<code class="du ju jv jw jx b">clickHandler</code>，将机械信息(“当用户点击X，Y发生”)发送给反应组件，并让它们接收来自单一真实来源的状态更新。React生态系统有几个可用的状态管理系统:考虑到我们适度的需求，React的上下文API非常合适。</p><p id="a256" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用React上下文API + useReducer管理状态</strong></p><p id="5ed3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React上下文是提供者组件，它包装React的部分(或全部)虚拟DOM，并使全局状态上下文对上下文提供者下游的所有子元素可用，这些子元素通过React的<code class="du ju jv jw jx b">useContext</code>钩子访问上下文提供的值。</p><p id="58d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经看到，我们的状态逻辑经常涉及几个不同的DOM元素同时改变。例如，当用户请求提示时:</p><ul class=""><li id="f0d0" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js kp kq kr ks bi translated">生成提示并分配类来反映它们</li><li id="b5c9" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">用户的剩余猜测减少</li><li id="62ad" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">代表用户选择的活动区块被重置</li><li id="0b1a" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">如果提示由于剩余猜测次数少或难度高而不可用，则触发与提示相关的条件逻辑</li></ul><p id="58c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React允许我们颠倒这种命令式的数据流模型，将状态传递给元素，而不是在DOM中操纵状态。让我们利用React的<code class="du ju jv jw jx b">useReducer</code>钩子，通过向一个reducer发出<strong class="ix hj">动作</strong>来修改我们的全局状态，这个reducer只是一个函数，它返回一个更新的状态，给出一个动作类型和一个状态修改的有效负载。</p><p id="0567" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的应用程序让用户采取五个不同的行动:设置难度，选择一个方块，提交选择的方块作为猜测，获得提示，重置游戏。如果我们限制用户在游戏中改变难度等级的能力，那么我们实际上只有四个交互。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist: <a class="ae iu" href="https://tinyurl.com/react-reducer-actions" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-reducer-actions</a></figcaption></figure><p id="ff4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的reducer将接受当前状态，初始化如下(其中以<strong class="ix hj"> *Lib </strong>结尾的对象是保存映射到难度、进度和玩家消息的变量的字符串库，以及保存大量提示和猜测的数字库):</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist: <a class="ae iu" href="https://tinyurl.com/react-reducer-initstate" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-reducer-initstate</a></figcaption></figure><p id="4d2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当用户采取动作时，一个对象被<em class="jt">分派</em>或发送给reducing函数，后者将打开动作类型——这是一个由DOM元素转发给reducer的消息，DOM元素捕获了由分派的消息描述的用户动作。有了我们的动作类型，让我们把所有的部分放在一起。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-reducer" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-reducer</a></figcaption></figure><p id="562f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将用来把<code class="du ju jv jw jx b">state</code>和<code class="du ju jv jw jx b">dispatch</code>方法传递给下游组件的提供者组件依赖于提供者包装它的子树，我们允许它用<code class="du ju jv jw jx b">props.children.</code>来做这件事</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-context-provider" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-context-provider</a></figcaption></figure><p id="03db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们将组件及其子组件包装在一个<code class="du ju jv jw jx b">GameProvider</code>中，无论我们将提供者放在什么级别，所有的子组件都可以访问它的<code class="du ju jv jw jx b">GameContext</code>，而<strong class="ix hj">提供了对<code class="du ju jv jw jx b">state</code>和<code class="du ju jv jw jx b">dispatch</code>的</strong>访问——我们将使用这些来修改实际执行该工作的组件内部的状态！(把<code class="du ju jv jw jx b">useReducer's</code> <code class="du ju jv jw jx b">state</code>对象和<code class="du ju jv jw jx b">dispatch</code>方法看作是<code class="du ju jv jw jx b">useState</code>更健壮的版本)。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-provider-wrapped-app" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-provider-wrapped-app</a></figcaption></figure><p id="cfa0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们回到了我们的<code class="du ju jv jw jx b">PlayingField</code>，在这里我们将看到<code class="du ju jv jw jx b">Row</code>子组件现在渲染游戏状态，而不知道<em class="jt">如何</em>或什么导致状态改变——它只是渲染新的状态——并且它不是通过道具训练，而是直接在<code class="du ju jv jw jx b">GameContext</code>上访问状态。</p><blockquote class="ke kf kg"><p id="64a1" class="iv iw jt ix b iy iz ja jb jc jd je jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">顺便说一下，我们可以放心地将useReducer的<code class="du ju jv jw jx b">dispatch </code>方法从React上下文中取出，因为每当提供者本身发生变化时，都会触发提供者子树的呈现:</p><p id="15aa" class="iv iw jt ix b iy iz ja jb jc jd je jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">" React保证<code class="du ju jv jw jx b">dispatch</code>函数身份是稳定的，不会在重新渲染时改变."——<a class="ae iu" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usereducer</a></p></blockquote><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): https://tinyurl.com/reactrow</figcaption></figure><p id="09b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">PlayerButtons</code>组件展示了我们从分离关注点中获得的清晰性:按钮分派动作，而不需要知道那些动作将如何传递新状态。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-playerbtns" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-playerbtns</a></figcaption></figure><p id="b4a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以很容易地将<code class="du ju jv jw jx b">START_GAME</code>逻辑扩展到我们的<code class="du ju jv jw jx b">DifficultySwitches</code>，允许我们在没有任何额外逻辑的情况下阻止用户在游戏中重置游戏难度！我们可以访问我们的<code class="du ju jv jw jx b">GameContext</code>，这将让我们与组件共享<strong class="ix hj"> *Lib </strong>常量库，减少重复定义的需要。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx">Direct link to gist (with more reasonable spacing!): <a class="ae iu" href="https://tinyurl.com/react-difficulty-switches" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/react-difficulty-switches</a></figcaption></figure><p id="a93a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">外卖</strong></p><p id="0fab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React是一个强大的前端框架，它直接内置了一些很棒的状态管理API，特别是它的<code class="du ju jv jw jx b">useReducer</code>钩子和<code class="du ju jv jw jx b">useContext</code>钩子，允许向你的整个应用程序提供一个复杂的类似Redux的单一事实来源，一个特定的特性，或者一个完全本地的环境，用于管理你的应用程序的其余部分可以愉快地忽略的小块状态。</p><p id="97af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然Redux可能有些过头，但React的上下文系统是一种低调、灵活的替代方案，特别适合小空间中的大状态——就像本教程使用React自然的面向功能的设计对强制编码的猜谜游戏进行的演练重构。感谢阅读，并享受使用React和React Context API + useReducer构建有状态应用程序的乐趣！</p><p id="d07d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Daniel Shapiro是一名全栈软件工程师，毕业于全栈学院，目前是该学院的助教。当他不制作酷的东西时，你通常会发现他沉迷于他以前的职业生涯，在芝加哥的许多工匠面包店担任首席面包师，烘焙一批英式松饼，带着他的小猎犬百合在沙滩上跑步，或者在密歇根湖划船。联系shapirodanieladam@gmail.com的丹尼尔或者连接LinkedIn上的<a class="ae iu" href="http://linkedin.com/in/shapirodanieladam" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">，一定要访问</em> <a class="ae iu" href="http://breadbakersfriend.com" rel="noopener ugc nofollow" target="_blank"> <em class="jt">面包师的朋友</em> </a> <em class="jt">，这是一个专为业余和专业面包师设计的网络应用程序！</em></p></div></div>    
</body>
</html>
<html>
<head>
<title>Introduction to Redis common patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis通用模式介绍</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/introduction-to-redis-common-patterns-3a99c112eb30?source=collection_archive---------8-----------------------#2021-07-26">https://medium.com/geekculture/introduction-to-redis-common-patterns-3a99c112eb30?source=collection_archive---------8-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8dd9267035e32f0fb7f29fd6d3f0a0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVnJTZ8yf-MXll9bhPKqAQ.png"/></div></div></figure><p id="6242" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis(远程字典服务器)</a>是一个内存中的数据存储，我们可以将其用作数据库、缓存和消息代理。Redis最明显的用例是作为服务器端的缓存存储。除了缓存，还有一些模式可以帮助我们解决常见的问题。</p><h1 id="2797" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">限速</strong></h1><p id="5e14" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您有一个公共端点，并且希望根据客户端IP地址限制对端点的访问。假设我们希望将访问限制为每分钟100个请求。通过使用内置的Redis <a class="ae jo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>和<a class="ae jo" href="https://redis.io/commands/incr" rel="noopener ugc nofollow" target="_blank"> INCR </a>函数，我们可以为我们的端点构建速率限制器函数。流程非常简单:</p><ul class=""><li id="5a71" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">根据客户端IP和当前分钟创建一个密钥，即10.1.89.100:15。</li><li id="55e3" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">通过对我们的端点使用每个请求的键，从Redis获取值。</li><li id="9bfa" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">如果该值大于100，则中断该过程。</li><li id="c8e6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">如果该值小于或等于100，则继续该过程。</li><li id="0db1" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用基于键的INCR增加值。</li><li id="979f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">要清除Redis存储中未使用的数据，使用<a class="ae jo" href="https://redis.io/commands/expire" rel="noopener ugc nofollow" target="_blank"> EXPIRE </a>将密钥到期时间设置为1分钟</li></ul><p id="7d68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好，让我们在端点上实现速率限制器:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="6653" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建“GET /pokemons”端点来返回Pokemon数据数组，并将端点的使用限制为每分钟5个请求。对于每个请求，我们使用客户端IP作为密钥，并增加计数器。当计数器大于5时，我们立即响应429 HTTP状态，因此客户端应该再等待一分钟来执行它们的下一个请求。</p><h1 id="5e7d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">锁定</strong></h1><p id="72c3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">有时，我们希望我们的应用程序在同一时间做完全相同的工作，我们需要阻塞其他请求，直到前一个请求完成。</p><p id="b606" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有“POST /generate_reports”端点，该端点负责规范化数据库上的数据，并基于规范化的数据创建报告。我们希望一个用户只能同时生成一个报告。通过将Redis <a class="ae jo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> SET </a>与NX和EX命令一起使用，我们可以创建一个锁来保护我们的资源进行多路访问。下面是创建我们的锁定机制的步骤:</p><ul class=""><li id="ec8b" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">基于用户ID或某个标识符创建一个密钥。</li><li id="869c" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">生成一个随机字符串作为值。</li><li id="c413" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">定义一个生存时间(TTL)来防止我们的锁死锁，所以当客户端无法释放锁时，密钥将根据我们的TTL被清除。</li><li id="9a2f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">通过使用先前的密钥、值和TTL，使用“SET {KEY} {VALUE} NX EX {TTL}”命令将其放入Redis。NX选项只在键不存在时设置键，当键已经存在时返回nil。</li><li id="d422" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">如果前面的命令没有返回nil，则运行报告生成过程，否则立即中断。</li><li id="48cc" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">当报告生成后，我们需要释放锁。为了避免密钥被另一个客户端删除，在前面的步骤中，我们创建了一个不可猜测的随机字符串作为值。因此，我们将创建一个脚本，仅在值匹配时删除键。</li></ul><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="a745" class="lr jq hi ln b fi ls lt l lu lv">if redis.call("GET",KEYS[1]) == ARGV[1]<br/>then<br/>    return redis.call("DEL",KEYS[1])<br/>else<br/>    return 0<br/>end</span></pre><ul class=""><li id="906e" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">在锁被释放后，我们可以接受另一个请求。</li></ul><p id="8948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是我们锁实现的例子:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1920" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Redis的作者Redis提出了更健壮的锁算法叫做<a class="ae jo" href="https://redis.io/topics/distlock" rel="noopener ugc nofollow" target="_blank"> Redlock </a>。我已经在这个<a class="ae jo" href="https://syafdia.medium.com/implementing-redlock-on-redis-for-distributed-locks-a3cfe60d4ea4" rel="noopener">帖子</a>上写了关于红锁实现的文章。</p><h1 id="25e7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">工作队列</strong></h1><p id="19b7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">基于<a class="ae jo" href="https://en.wikipedia.org/wiki/Job_queue" rel="noopener ugc nofollow" target="_blank">维基百科</a>的作业队列定义:</p><blockquote class="lw lx ly"><p id="7ec1" class="iq ir lz is b it iu iv iw ix iy iz ja ma jc jd je mb jg jh ji mc jk jl jm jn hb bi translated">在<a class="ae jo" href="https://en.wikipedia.org/wiki/System_software" rel="noopener ugc nofollow" target="_blank">系统软件</a>中<strong class="is hj">作业队列</strong>(有时是<strong class="is hj">批处理队列</strong>)，是一个由<a class="ae jo" href="https://en.wikipedia.org/wiki/Job_scheduler" rel="noopener ugc nofollow" target="_blank">作业调度器</a>软件维护的数据结构，包含要运行的作业。用户将他们想要执行的程序“作业”提交到<a class="ae jo" href="https://en.wikipedia.org/wiki/Batch_processing" rel="noopener ugc nofollow" target="_blank">批处理队列</a>。</p></blockquote><p id="a7eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，通过使用作业队列，我们可以将有关要执行任务的信息放入队列中，从而在多个进程之间使用异步通信。</p><p id="0e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">队列上的操作是先进先出(FIFO)。Redis内置了列表数据结构。通过在列表上使用<a class="ae jo" href="https://redis.io/commands/brpop" rel="noopener ugc nofollow" target="_blank"> BRPOP </a>和<a class="ae jo" href="https://redis.io/commands/lpush" rel="noopener ugc nofollow" target="_blank"> LPUSH </a>命令，我们可以实现自己的作业队列。</p><p id="b010" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要创建一个worker，从队列中提取作业</p><ul class=""><li id="a4c3" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">我们使用“BRPOP {QUEUE_NAME} 0”命令从队列中提取作业，该命令将阻塞我们的程序，直到它接收到作业。</li><li id="b6f7" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">由于前一个命令在接收到一个作业后会被终止，所以我们应该把它放在无限循环里面。</li><li id="76f7" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">收到作业后，处理该作业。</li></ul><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ae85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，接下来我们将创建一个处理程序来将作业推入队列</p><ul class=""><li id="8d30" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">我们只需创建一个HTTP端点“POST /send_welcome_email ”,它负责接收电子邮件，并将电子邮件放入队列中，以便工作人员可以异步发送电子邮件。</li><li id="9c15" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用“LPUSH {QUEUE_NAME} {EMAIL}”将电子邮件推送至队列。</li></ul><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="15a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试在终端的不同选项卡上运行worker和HTTP处理程序。当您向/send_welcome_email端点发送包含电子邮件数据的发布请求时，我们的工作人员将立即提取作业并处理该电子邮件地址。</p><p id="fc1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">酷，我们刚刚实现了我们自己的作业队列系统，但这还不是生产就绪。如果你想通过Redis在产品上使用queue，你可以使用<a class="ae jo" href="https://github.com/mperham/sidekiq" rel="noopener ugc nofollow" target="_blank"> Sidekiq </a>，这篇<a class="ae jo" href="https://longliveruby.com/articles/how-sidekiq-really-works" rel="noopener ugc nofollow" target="_blank">文章</a>解释了Sidekiq如何在内部工作。</p><h1 id="2f26" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">酒馆Sub </strong></h1><p id="5c37" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我只是再次引用<a class="ae jo" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>XD</p><blockquote class="lw lx ly"><p id="25d0" class="iq ir lz is b it iu iv iw ix iy iz ja ma jc jd je mb jg jh ji mc jk jl jm jn hb bi translated">在<a class="ae jo" href="https://en.wikipedia.org/wiki/Software_architecture" rel="noopener ugc nofollow" target="_blank">软件架构</a>中，<strong class="is hj">发布-订阅</strong>是一种<a class="ae jo" href="https://en.wikipedia.org/wiki/Messaging_pattern" rel="noopener ugc nofollow" target="_blank">消息传递模式</a>，其中<a class="ae jo" href="https://en.wikipedia.org/wiki/Message_passing" rel="noopener ugc nofollow" target="_blank">消息</a>的发送者(称为发布者)不将消息编程为直接发送给特定接收者(称为订阅者)，而是将发布的消息分类，而不知道可能有哪些订阅者(如果有的话)。类似地，订阅者表达对一个或多个类别的兴趣，并且仅接收感兴趣的消息，而不知道存在哪些发布者(如果有的话)。</p></blockquote><p id="7568" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，基本上，发布订阅是一种模式，其中发布者向通道发送消息，订阅者从通道接收消息。而发布者并不关心订阅者是谁，订阅者的目的是什么。</p><p id="aae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用pub sub的Redis命令非常简单，如果我们想要订阅一个频道，我们调用<a class="ae jo" href="https://redis.io/commands/subscribe" rel="noopener ugc nofollow" target="_blank"> SUBSCRIBE </a>，如果我们想要向给定的频道发布消息，我们调用<a class="ae jo" href="https://redis.io/commands/publish" rel="noopener ugc nofollow" target="_blank"> PUBLISH </a>。</p><p id="53f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然Redis为我们提供了内置的发布订阅实现，那么让我们来关注一下如何使用它。假设我们有一个电影院应用程序，我们有一个在电影院预订座位和处理付款的功能。对于这个特性，我们开发了3个服务，姑且称之为:</p><ul class=""><li id="b975" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">HTTP座位管理器应用程序</li><li id="74c7" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">Pub Sub支付应用</li><li id="a522" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">酒吧副座经理应用程序</li></ul><p id="d3fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当用户在电影院观看电影时，他们将访问我们的网页，并通过HTTP Seat Manager App选择座位，当用户的座位被阻止时，它将发布到BLOCK_SEAT_SUCCESS频道。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="e42f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的Pub Sub支付应用程序将侦听BLOCK_SEAT_SUCCESS通道，当它通过这些通道收到消息时，它将通过“make_payment”功能进行支付，如果支付成功，一条消息将发布到MAKE_PAYMENT_SUCCESS通道。当支付失败时，它会通过MAKE_PAYMENT_FAILED通道发布另一条消息。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="fb92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pub Sub支付App有“退款”功能，以防有ALLOCATE_SEAT_FAILED频道的消息。因为当“allocate_seat”功能出错时，我们的Pub Sub Seat Manager应用程序将通过此通道发布一条消息。</p><p id="83be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pub Sub Seat Manager应用程序将侦听MAKE_PAYMENT_SUCCESS通道，如果它通过该通道接收到数据，它将调用“allocate_seat”函数为用户分配座位。并且在从MAKE_PAYMENT_FAILED或ALLOCATE_SEAT_FAILED通道收到消息的情况下，它具有“unblock_seat”功能，因此可以为其他流程释放座位。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="45c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，这是我们使用Redis发布订阅特性的例子。在单独的终端上运行它，你可以看到输出。并尝试调整参数，使其失败或成功，并查看其他进程将基于订阅的通道运行。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="5468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们刚刚使用Redis实现了一些常见的模式，但是这些模式不仅限于本文，我们可以实现地理空间、IP范围索引、全文搜索、分区索引、Bloom Filter等。你可以在这个库的<a class="ae jo" href="https://github.com/syafdia/programming-sample/tree/master/RedisPattern" rel="noopener ugc nofollow" target="_blank">上看到这篇文章的完整源代码。</a></p><p id="33a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢</p><p id="00ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考</strong></p><ul class=""><li id="774c" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><a class="ae jo" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> https://redis.io </a></li><li id="81ce" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><a class="ae jo" href="https://redislabs.com/redis-best-practices/introduction/" rel="noopener ugc nofollow" target="_blank">https://redislabs.com/redis-best-practices/introduction</a></li><li id="2a8a" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><a class="ae jo" href="https://longliveruby.com/articles/how-sidekiq-really-works" rel="noopener ugc nofollow" target="_blank">https://longliveruby.com/articles/how-sidekiq-really-works</a></li></ul></div></div>    
</body>
</html>
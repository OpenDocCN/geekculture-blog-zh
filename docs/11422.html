<html>
<head>
<title>Immutability and its Importance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不变性及其重要性</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/immutability-and-its-importance-d43aa39c8614?source=collection_archive---------13-----------------------#2022-03-21">https://medium.com/geekculture/immutability-and-its-importance-d43aa39c8614?source=collection_archive---------13-----------------------#2022-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/890680e64105f791163fe2c858645966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dp9KlgC9BNgWc7e4UVW3fw.jpeg"/></div></div></figure><p id="9c62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么是不变性？</p><p id="5e4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个词在字典中的字面意思是——不会随着时间的推移而改变。在编程语言中，这个词也有相似的意思。在一些编程语言中，对象的不变性是隐含的，但对于java来说，情况并非如此。下面用一个例子来详细看看。</p><p id="649d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，我们将创建一个“用户”类的对象。用户由姓名、id、出生日期和地址等属性组成。似乎创建一个简单的类。如果我们不熟悉不变性，那么最有可能的是，我们最终会创建下面的类。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a112" class="jx jy hi jt b fi jz ka l kb kc">public class User {</span><span id="cf65" class="jx jy hi jt b fi kd ka l kb kc">private String name;</span><span id="774d" class="jx jy hi jt b fi kd ka l kb kc">private Long id;<br/>private Date dateOfBirth;<br/>private StringBuilder address;</span><span id="36a6" class="jx jy hi jt b fi kd ka l kb kc">public User(String name, Long id, Date dateOfBirth, StringBuilder address) {<br/>this.name = name;<br/>this.id = id;<br/>this.dateOfBirth = dateOfBirth;<br/>this.address = address;<br/>}</span><span id="f7f8" class="jx jy hi jt b fi kd ka l kb kc">public String getName() { return name;    }<br/>public void setName(String name) { this.name = name;    }<br/>public Long getId() { return id;    }<br/>public void setId(Long id) { this.id = id;    }<br/>public Date getDateOfBirth() { return dateOfBirth;    }<br/>public void setDateOfBirth(Date dateOfBirth) { this.dateOfBirth = dateOfBirth;    }<br/>public StringBuilder getAddress() { return address;    }<br/>public void setAddress(StringBuilder address) { this.address = address;    }<br/>}</span></pre><p id="2468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您不希望User的对象是不可变的，这是非常好的。但是如果你想要一个不可变的对象，那么你需要修改你的代码。在修改之前，我们先测试一下上面的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4d7e" class="jx jy hi jt b fi jz ka l kb kc">@Test<br/>void testImmutability() {</span><span id="2726" class="jx jy hi jt b fi kd ka l kb kc">User user = new User("TestName", 1234L, new Date(1990, 1, 1), new StringBuilder("India"));</span><span id="7fd1" class="jx jy hi jt b fi kd ka l kb kc">user.setName("AnotherName");<br/>user.setId(3456L);<br/>user.setDateOfBirth(new Date(2020, 1, 1));<br/>user.setAddress(new StringBuilder("CountryDoesNotExist"));</span><span id="f8ac" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="c9ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据不变性的定义，对象“用户”不应该改变其状态，这意味着用户的所有属性都不应该是可编辑的，或者没有其他方法应该更新其值或引用。这么简单！删除setter方法，可以吗？让我想想…</p><p id="e66e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户类别版本— 2</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d2fb" class="jx jy hi jt b fi jz ka l kb kc">private Long id;<br/>private Date dateOfBirth;<br/>private StringBuilder address;</span><span id="8354" class="jx jy hi jt b fi kd ka l kb kc">public User(String name, Long id, Date dateOfBirth, StringBuilder address) {<br/>this.name = name;<br/>this.id = id;<br/>this.dateOfBirth = dateOfBirth;<br/>this.address = address;<br/>}</span><span id="e795" class="jx jy hi jt b fi kd ka l kb kc">public String getName() { return name;    }<br/>public Long getId() { return id;    }<br/>public Date getDateOfBirth() { return dateOfBirth;    }<br/>public StringBuilder getAddress() { return address;    }<br/><br/>}</span></pre><p id="3b76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们再测试一次-</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b0ea" class="jx jy hi jt b fi jz ka l kb kc">@Test<br/>void testImmutability() {</span><span id="a37b" class="jx jy hi jt b fi kd ka l kb kc">User user = new User("TestName", 1234L, new Date(1990, 1, 1), new StringBuilder("India"));</span><span id="0db0" class="jx jy hi jt b fi kd ka l kb kc">assertEquals("TestName", user.getName());<br/>assertEquals(1234L, user.getId());<br/>assertEquals(new Date(1990, 1 ,1), user.getDateOfBirth());<br/>assertEquals("India", user.getAddress().toString());</span><span id="55eb" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="f6ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有setter方法，没有其他方法来更新值，如果你运行上面的测试将会成功！看来我们成功了！</p><p id="f56d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在上面的代码中还有一个问题，让我们在下面修改后的测试中看看。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="09ca" class="jx jy hi jt b fi jz ka l kb kc">@Test</span><span id="fa10" class="jx jy hi jt b fi kd ka l kb kc">void testImmutability() {</span><span id="418b" class="jx jy hi jt b fi kd ka l kb kc">User user = new User("TestName", 1234L, new Date(1990, 1, 1), new StringBuilder("India"));</span><span id="0652" class="jx jy hi jt b fi kd ka l kb kc">user.getAddress().append(" Some addition Address");<br/>user.getDateOfBirth().setMonth(6);</span><span id="e49a" class="jx jy hi jt b fi kd ka l kb kc">assertEquals("TestName", user.getName());<br/>assertEquals(1234L, user.getId());<br/>assertEquals(new Date(1990, 1 ,1), user.getDateOfBirth());<br/>assertEquals("India", user.getAddress().toString());</span><span id="c2bd" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="cee7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您观察，即使没有setter方法，地址和出生日期也会改变，因为“StringBuilder”和“date”对象本质上都是可变的。但是' Name '(字符串)和' Id '(整数)不是。因此，我们需要对本质上可变的属性做一些规定。让我们看看例子。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d39d" class="jx jy hi jt b fi jz ka l kb kc">public Date getDateOfBirth() {<br/> return new Date(this.dateOfBirth.getYear(),    this.dateOfBirth.getMonth(), this.dateOfBirth.getDate());<br/>}</span><span id="064c" class="jx jy hi jt b fi kd ka l kb kc">public StringBuilder getAddress() {<br/> return new StringBuilder(this.address);<br/>}</span></pre><p id="088e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我刚刚更新了上面代码片段中的getter方法，我们复制了对象，然后从getter方法返回副本。如果您在您的类中更新这些getter方法并运行测试，这一次您的测试将成功运行。</p><p id="0817" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使一个类不可变，还有一条规则，我们需要使这个类成为final。但在我看来，这不是最重要的规则，因为我们不会为这类类创建子类。</p><h1 id="fbfa" class="ke jy hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">不可变类的应用</h1><p id="e8f3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">主要的用例是计算对象的散列。散列只不过是返回整数值的数学函数。哈希的计算通常是为了给对象分配一个唯一的值，因此在计算哈希时，最好考虑所有的属性。</p><p id="d683" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑一下之前作为例子的用户类。我们有四个属性，我们将从这四个属性中创建一个散列。创建一个散列仅仅意味着从Object类中重写hashcode方法，并编写一个有意义的散列函数！</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="089f" class="jx jy hi jt b fi jz ka l kb kc">@Override<br/>public int hashCode() {</span><span id="9d93" class="jx jy hi jt b fi kd ka l kb kc">return Objects.hash(address, dateOfBirth, id, name);</span><span id="d6d9" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="4e3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在考虑您已经创建了您的用户类的五个对象，并且您的类没有被更新来创建不可变的对象。你把你所有的对象放在一个集合或者一个地图中(作为一个键)。现在，在代码的某个地方，您更新了刚刚放入Set/Map中的用户对象的状态。集合/映射的工作原理是散列，因此它根据将对象放入集合/映射时生成的散列码来存储对象。因此，当将对象放入Set/Map用户对象时，它具有不同的hashcode，并且在更改对象的状态后，它可能具有不同的hashcode，这可能会在您的程序中导致不需要的结果。</p><p id="54f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果你让你的类不可变，然后在这样的数据结构中使用它，它会工作得更准确。</p></div></div>    
</body>
</html>
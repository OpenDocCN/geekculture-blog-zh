<html>
<head>
<title>Rest vs Spread Operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Rest与Spread运算符</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/rest-vs-spread-operator-in-javascript-5ec180c82909?source=collection_archive---------7-----------------------#2021-12-21">https://medium.com/geekculture/rest-vs-spread-operator-in-javascript-5ec180c82909?source=collection_archive---------7-----------------------#2021-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="96e5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目标</h1><p id="3304" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">理解JavaScript中<strong class="jf hj"> Rest </strong>和<strong class="jf hj"> Spread </strong>一元运算符的用法。</p><h1 id="1014" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">运算符符号</h1><p id="2cbc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">静止</strong>操作符的符号为<code class="du kb kc kd ke b">…</code> (3个点)。</p><p id="c2ae" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj">展开</strong>操作符的符号为<code class="du kb kc kd ke b">…</code> (3点)</p><p id="4cf4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">注意-两者具有相同的运算符符号</p><h1 id="6227" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">TL；速度三角形定位法(dead reckoning)</h1><h2 id="295f" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">Rest运算符的基本用法</h2><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #0.1 | Basic Usage of Rest Operator</figcaption></figure><h2 id="980c" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">传播算子的基本用法</h2><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #0.2 | Basic Usage of Spread Operator</figcaption></figure><h1 id="8726" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">让我们开始…</h1><h1 id="12db" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">第一部分</h1><p id="72fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在解释JavaScript上下文中的Rest和Spread操作符之前，最好在一个<strong class="jf hj">通用上下文</strong>中理解它们。</p><p id="fadc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">假设你有一副52张扑克牌。</p><p id="55b3" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">当<strong class="jf hj">牌展开</strong>时，我们称之为拿走一副牌并把它们平放在桌子上。</p><p id="2a79" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">并且在<strong class="jf hj">收集卡片</strong>时收集展开的卡片并将其转换回卡片组。</p><p id="574f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">下面是视觉辅助的图表—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="lj le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gif #1.1 | Visual Aid for Cards Spread and Cards Collect</figcaption></figure><blockquote class="lk ll lm"><p id="ef5b" class="jd je ln jf b jg kf ji jj jk kg jm jn lo kh jq jr lp ki ju jv lq kj jy jz ka hb bi translated">现在，假设我们想留下前十张牌，收集剩下的42张。我们会叫它什么？</p><p id="0b6b" class="jd je ln jf b jg kf ji jj jk kg jm jn lo kh jq jr lp ki ju jv lq kj jy jz ka hb bi translated">我们会说，我们保留前十张卡片，收集42张卡片中的<code class="du kb kc kd ke b"><strong class="jf hj">rest</strong></code>。</p><p id="b066" class="jd je ln jf b jg kf ji jj jk kg jm jn lo kh jq jr lp ki ju jv lq kj jy jz ka hb bi translated">(你能连接为什么是rest操作符吗？)</p></blockquote><p id="7e40" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">现在，通过考虑我们上面提到的类比，让我们理解JavaScript环境中的<strong class="jf hj"> rest </strong>和<strong class="jf hj"> spread </strong>。</p><p id="aa7b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">52张牌的一副牌(或一叠牌)是可迭代的，例如一个数组，每张牌是可迭代的一个元素。</p><p id="5d2a" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">将可迭代平面的所有元素放置到一个方法，或另一个可迭代，或其他，称为<strong class="jf hj">可迭代展开</strong>。用于此目的的运算符是<code class="du kb kc kd ke b">…</code> (3点)。</p><p id="5cda" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">在这个位置展开 <a class="ae lr" href="#980c" rel="noopener ugc nofollow">看上面提到的例子。</a></p><p id="261f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">当涉及到将布局的元素收集回iterable时，我们<strong class="jf hj">并不真正称之为Iterable Collect </strong>，我们只是说<code class="du kb kc kd ke b">let’s collect <strong class="jf hj">rest</strong> of the elements to an iterable</code>。其余的元素可以是所有布局的元素，也可以是其中的一些。用于此目的的操作符也是<code class="du kb kc kd ke b">…</code> (3个点)。</p><p id="7bbe" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">此处的<strong class="jf hj"/><a class="ae lr" href="#295f" rel="noopener ugc nofollow">参见上述示例。</a></p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="8cbf" class="if ig hi bd ih ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc bi translated">第二部分</h1><p id="5e4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这一节中，我们将讨论JavaScript中的基本概念和术语，这对理解Rest和Spread操作符很有用。</p><h2 id="2d57" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated"><strong class="ak"> #2.1)什么是按值复制和按引用复制？</strong></h2><p id="f120" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在JavaScript中，将一个具有原始值的变量赋给另一个变量会创建原始值的精确副本，也就是说，它通过值进行<strong class="jf hj">复制。</strong></p><p id="703e" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">例如</p><pre class="ky kz la lb fd me ke mf mg aw mh bi"><span id="317b" class="kk ig hi ke b fi mi mj l mk ml">let a = "Delhi", <br/>let b = a; </span><span id="b42c" class="kk ig hi ke b fi mm mj l mk ml">console.log(a); // "Delhi"<br/>console.log(b); // "Delhi"</span></pre><p id="4e3e" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">乍一看，输出似乎很明显。如果我向变量<code class="du kb kc kd ke b">a</code>追加另一个字符串会怎么样？<code class="du kb kc kd ke b">a</code>中的更新值是否也反映在变量<code class="du kb kc kd ke b">b</code>中？</p><pre class="ky kz la lb fd me ke mf mg aw mh bi"><span id="3cda" class="kk ig hi ke b fi mi mj l mk ml">a = a + ", India";</span><span id="86f0" class="kk ig hi ke b fi mm mj l mk ml">console.log(a); // "Delhi, India"<br/>console.log(b); // "Delhi"</span></pre><p id="4895" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">答案是<strong class="jf hj">不</strong>！因为当<code class="du kb kc kd ke b">a</code>的值被赋给<code class="du kb kc kd ke b">b</code>时，那么<code class="du kb kc kd ke b">a</code>的值的<strong class="jf hj">精确副本</strong>被提供给<code class="du kb kc kd ke b">b</code>。</p><p id="69ac" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">看看下面的视频——</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #2.1.1 | Copy by Value</figcaption></figure><p id="5853" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj">按值复制</strong>仅在变量值为原始类型时发生，如数字、字符串、布尔、未定义、符号和BigInt。</p><p id="7556" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">让我们再举一个例子，但是用一个物体。</p><pre class="ky kz la lb fd me ke mf mg aw mh bi"><span id="b8bd" class="kk ig hi ke b fi mi mj l mk ml">let obj1 = {name: "Mani"};<br/>let obj2 = obj1; </span><span id="0f49" class="kk ig hi ke b fi mm mj l mk ml">console.log(obj1); // {name: "Mani"}<br/>console.log(obj2); // {name: "Mani"}</span></pre><p id="b71c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">似乎很明显，对吧？</p><p id="847c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">如果我向<code class="du kb kc kd ke b">obj1</code>添加另一个属性会怎么样？会在<code class="du kb kc kd ke b">obj2</code>中也有体现吗？</p><pre class="ky kz la lb fd me ke mf mg aw mh bi"><span id="e4ef" class="kk ig hi ke b fi mi mj l mk ml">obj1["lastName"] =  "Srivastava";</span><span id="0757" class="kk ig hi ke b fi mm mj l mk ml">console.log(obj1); // {name: "Mani", lastName: "Srivastava"}<br/>console.log(obj2); // {name: "Mani", lastName: "Srivastava"}</span></pre><p id="f97c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">答案是肯定的。</p><p id="0151" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">看看下面的视频——</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #2.1.2 | Copy by Reference</figcaption></figure><p id="e62f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">发生这种情况只是因为如果一个对象的值是非原语的，那么将一个对象赋给另一个变量会导致<strong class="jf hj">引用被复制</strong>到那个变量。这就是为什么一个物体的变化在另一个物体中是可见的。</p><h2 id="8b1c" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#2.2)什么是浅层复制和深层复制？</h2><p id="ec8c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">浅拷贝，在JS对象的上下文中，意味着</p><ul class=""><li id="5aac" class="mo mp hi jf b jg kf jk kg jo mq js mr jw ms ka mt mu mv mw bi translated">按值复制对象声明第一级中包含基元值的对象的所有键。</li><li id="0aea" class="mo mp hi jf b jg mx jk my jo mz js na jw nb ka mt mu mv mw bi translated">在对象声明的第一级中引用包含非基元值的对象的所有键。</li></ul><p id="7334" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">深度复制意味着按值复制对象的所有键，无论是在第一级还是任何更深的级别，并且与原始对象具有相同的结构。</p><p id="5567" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">想了解浅抄，看下面的视频。</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #2.2.1 | Shallow Copy</figcaption></figure><h2 id="8f55" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated"><strong class="ak"> #2.3)什么是可迭代？</strong></h2><p id="78e2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">iterable是一种能够一次返回一个值的数据结构，允许它在for中迭代..循环的。</p><p id="1fdf" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">数组、字符串、映射、集合是JavaScript中可迭代对象的内置例子。</p><p id="38a7" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">默认情况下，对象不是可迭代的，但是可以使用<code class="du kb kc kd ke b">Symbol.iterator</code>属性将它们转换成可迭代的。查看参考资料部分的链接#2。</p><p id="4812" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">实际上，<code class="du kb kc kd ke b">Symbol.iterator</code>属性也在内置的iterables中。看看下面的视频。</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #2.3.1 | Iterables</figcaption></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="a1aa" class="if ig hi bd ih ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc bi translated">第三部分</h1><p id="a651" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本节中，我们将查看Rest和Spread运算符的各种用法示例。</p><h2 id="4800" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#3.1)扩展运算符</h2><p id="c931" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在继续之前应该注意的一点是，Spread操作符只处理iterables，并对它们进行浅层复制。</p><p id="188c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.1.1)成串展开</strong></p><p id="fe27" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">由于字符串是可迭代的，我们可以对它使用spread操作符。浅拷贝的观点在这里并不重要。</p><p id="c047" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">看看下面的代码，并自己执行它。</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.1.1.1 | Spread in Strings</figcaption></figure><p id="a323" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.1.2)排列展开</strong></p><p id="6842" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">由于数组是可迭代的，我们可以对它使用spread运算符。它对数组进行浅层复制。看看下面的代码—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.1.2.1 | Spread in Arrays</figcaption></figure><p id="ab91" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.1.3)在地图中展开并设置</strong></p><p id="e785" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">看看下面的代码—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.1.3.1 | Spread in Map and Set</figcaption></figure><p id="22bc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.1.4)在物体中扩散</strong></p><p id="fbe1" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">我们之前已经看到，一个对象不是可迭代的。这意味着我们不能使用spread运算符来扩展(或传播)它的值。</p><p id="67bc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">但是我们可以使用spread操作符来制作一个对象的<strong class="jf hj">浅拷贝</strong>。</p><p id="8339" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">观看以下视频了解详细信息——</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #3.1.4.1 | Spread in an Object</figcaption></figure><p id="3539" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.1.5)在自定义可迭代对象中传播</strong></p><p id="abf4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">默认情况下，一个对象是不可迭代的，但是我们可以使用<code class="du kb kc kd ke b">Symbol.iterator</code>属性使它成为可迭代的。参考以下代码—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.1.5.1 | Custom Iterable Object</figcaption></figure><p id="8c08" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">了解了这些之后，让我们检查一下是否可以在自定义的iterable对象上使用spread操作符。观看下面的视频—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mn le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Video #3.1.5.1 | Spread in an Custom Iterable Object</figcaption></figure><h2 id="184d" class="kk ig hi bd ih kl km kn il ko kp kq ip jo kr ks it js kt ku ix jw kv kw jb kx bi translated">#3.2) Rest运算符</h2><p id="82f1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">受<strong class="jf hj">第1节</strong>中提到的卡片类比的启发，<code class="du kb kc kd ke b">rest</code>运算符用于收集剩余的值，并将它们放入一个对象或数组中。</p><p id="4a95" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.2.1)在功能中休息</strong></p><p id="8b60" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">请看下面的例子，了解rest在函数中的用法</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.2.1.1 | Rest Operator in Functions</figcaption></figure><p id="b60f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">只需观察<code class="du kb kc kd ke b">“Kumar”</code>之后<code class="du kb kc kd ke b">…restArgs</code>是如何收集论据的。我们要么从函数调用中收集部分参数，要么收集所有参数。</p><p id="ec94" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">但是我们能在<code class="du kb kc kd ke b">…restArgs</code>参数后放些什么来收集最后一个参数吗？比如下面这个例子——</p><pre class="ky kz la lb fd me ke mf mg aw mh bi"><span id="54e5" class="kk ig hi ke b fi mi mj l mk ml">function myFunc(...restArgs, lastArg) {  </span><span id="5df5" class="kk ig hi ke b fi mm mj l mk ml">   // ....<br/>}</span></pre><p id="9221" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">不要！我们不能这样做，这样做的话，浏览器会抛出以下错误</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="er es nc"><img src="../Images/aea913384fac843b84042d8bc34bb476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlIRj262xB9rGby4CMVbNA.png"/></div></div></figure><blockquote class="lk ll lm"><p id="309f" class="jd je ln jf b jg kf ji jj jk kg jm jn lo kh jq jr lp ki ju jv lq kj jy jz ka hb bi translated">注意:您可以使用<code class="du kb kc kd ke b">arguments</code>对象访问函数的参数。查看参考段<strong class="jf hj">中的<strong class="jf hj">参考连杆#1 </strong>。</strong></p></blockquote><p id="3577" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj"> #3.2.2)为非结构化作业休息</strong></p><p id="5bec" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">在数组和对象的情况下，我们可以使用rest操作符进行非结构化赋值。参考下面的例子—</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Gist #3.2.2.1 | Rest Operator in De-structuring Assignments</figcaption></figure><p id="b588" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">注意，对于数组，RHS中值的位置决定了LHS中键的值。因此，由于LHS的<code class="du kb kc kd ke b">a</code>和RHS的<code class="du kb kc kd ke b">12</code>在第一位，所以<code class="du kb kc kd ke b">12</code>映射到<code class="du kb kc kd ke b">a</code>。</p><p id="afb4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">但是在对象的情况下，RHS中的键映射到LHS中的相同键。如果RHS中没有LHS中提到的密钥，那么该密钥将在控制台中记录<code class="du kb kc kd ke b">undefined</code>。所以，如果<code class="du kb kc kd ke b">obj</code>的结构中没有<code class="du kb kc kd ke b">firstName</code>键，那么<code class="du kb kc kd ke b">console.log(firstName)</code>将记录<code class="du kb kc kd ke b">undefined</code>。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="1dee" class="if ig hi bd ih ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc bi translated">结论</h1><p id="6b1b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们看到了在JavaScript中何时何地使用Rest和Spread操作符。</p><h1 id="c77e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><ol class=""><li id="e79c" class="mo mp hi jf b jg jh jk jl jo nj js nk jw nl ka nm mu mv mw bi translated"><a class="ae lr" href="https://www.freecodecamp.org/news/javascript-rest-vs-spread-operators/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/JavaScript-rest-vs-spread-operators/</a></li><li id="cea2" class="mo mp hi jf b jg mx jk my jo mz js na jw nb ka nm mu mv mw bi translated"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator#user-defined_iterables" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Symbol/iterator # user-defined _ iterables</a></li></ol></div></div>    
</body>
</html>
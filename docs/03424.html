<html>
<head>
<title>Testing useEffect and Redux Hooks using Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用酶测试使用效果并减少挂钩</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/testing-useeffect-and-redux-hooks-using-enzyme-4539ae3cb545?source=collection_archive---------2-----------------------#2021-06-08">https://medium.com/geekculture/testing-useeffect-and-redux-hooks-using-enzyme-4539ae3cb545?source=collection_archive---------2-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4b4b275ffd58c4a941036d3298cc14d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJX7PFKiuWxTzHivQUSqKw.jpeg"/></div></div></figure><p id="f722" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好。大约两年前，我写了一篇关于用钩子测试React函数组件的博客，现在我从一个新的角度写同样的内容。<br/><strong class="is hj">TLDR；</strong>在这里，我将告诉你一个我学会的测试生命周期挂钩的方法，例如<code class="du jo jp jq jr b">useEffect</code>和redux挂钩，即<code class="du jo jp jq jr b">useSelector</code>和<code class="du jo jp jq jr b">useDispatch</code>，同时使用<code class="du jo jp jq jr b">enzyme</code>浅安装组件。<br/>如果你没有读过我的上一篇文章，我建议你读一读，因为它涵盖了诸如如何测试诸如useState之类的钩子以及如何处理受控和不受控组件之类的主题，我不会在这里讨论这些主题。</p><div class="js jt ez fb ju jv"><a href="https://acesmndr.medium.com/testing-react-functional-components-with-hooks-using-enzyme-f732124d320a" rel="noopener follow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">用酶测试反应功能成分与钩子</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">使用Jest测试库和…通过浅层渲染测试具有状态和生命周期挂钩的功能组件</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">acesmndr.medium.com</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj io jv"/></div></div></a></div><h2 id="dba5" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">前言🌃</h2><p id="6339" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">当时，当我写上一篇文章时，没有办法测试浅层安装的react函数组件的生命周期方法，因为当我们使用enzyme的<code class="du jo jp jq jr b">shallow</code>来测试生命周期方法时，诸如<strong class="is hj"> useEffect </strong>和<strong class="is hj"> useLayoutEffect </strong>之类的生命周期方法不会被执行。因此，我推荐使用<code class="du jo jp jq jr b">mount</code>来测试生命周期方法。我对此并不满意，因为我所有的测试文件都是<code class="du jo jp jq jr b">shallow</code>和<code class="du jo jp jq jr b">mount</code>方法的混合，而且从本质上来说感觉是多余的。</p><p id="337f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一年后，我收到了迈克的评论，如果我想测试效果挂钩，可以尝试使用<code class="du jo jp jq jr b">jest-react-hooks-shallow</code>包。当时我试着用它，但我记得它不工作。最近我想再试一次，这次成功了。所以我在这里也写了一些关于它的内容，以及如何将它嵌入到你的酶测试中。</p><h1 id="77b4" class="ll kl hi bd km lm ln lo kq lp lq lr ku ls lt lu kx lv lw lx la ly lz ma ld mb bi translated">玩笑-反应-钩子-浅薄</h1><p id="a408" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated"><em class="mc">(如果您不想了解实施细节，请跳过此部分)</em></p><p id="96af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个包所做的就是神奇地让肤浅的渲染器运行效果生命周期方法<code class="du jo jp jq jr b">useEffect</code>和<code class="du jo jp jq jr b">useLayoutEffect</code>，让我们的编码生命周期更容易。</p><div class="js jt ez fb ju jv"><a href="https://www.npmjs.com/package/jest-react-hooks-shallow" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">玩笑-反应-钩子-浅薄</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">这个包使React挂钩(即useEffect()和useLayoutEffect())能够处理浅层渲染。换句话说…</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">www.npmjs.com</p></div></div><div class="ke l"><div class="md l kg kh ki ke kj io jv"/></div></div></a></div><p id="3fbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用npm或yarn设置它相当容易。您必须采取的一个额外步骤是在jest设置文件中初始化它，您已经在该文件中设置了酶适配器。</p><pre class="me mf mg mh fd mi jr mj mk aw ml bi"><span id="ee9d" class="kk kl hi jr b fi mm mn l mo mp">import enableHooks from 'jest-react-hooks-shallow';<br/><br/>// pass an instance of jest to `enableHooks()`<br/>enableHooks(jest);</span></pre><p id="29b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦安装完毕，测试文件中所有浅安装的组件将会按照软件包文档中的说明运行它的效果钩子。这就是我遇到问题的地方。我的组件没有运行效果挂钩。经过几次尝试，我意识到效果挂钩只有在我用HTML标签包装它们的时候才有效。所以我的意思是如果</p><pre class="me mf mg mh fd mi jr mj mk aw ml bi"><span id="9cb4" class="kk kl hi jr b fi mm mn l mo mp">const wrapper = shallow(&lt;Login/&gt;);</span></pre><p id="fbbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不工作，那么尝试使用shallow，将它包装在一个div中，然后使用<code class="du jo jp jq jr b">dive()</code>获取它。</p><pre class="me mf mg mh fd mi jr mj mk aw ml bi"><span id="014b" class="kk kl hi jr b fi mm mn l mo mp">const wrapper = shallow(&lt;div&gt;&lt;Login/&gt;&lt;/div&gt;);<br/>const container = wrapper.find('Login').dive();</span></pre><p id="b4bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后你可以测试功能组件的生命周期。</p><p id="2e8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以在所需的规格文件中手动启用效果挂钩，而不是在设置<code class="du jo jp jq jr b">jest-react-hooks-shallow</code>库时通过传递附加参数来全局启用。</p><pre class="me mf mg mh fd mi jr mj mk aw ml bi"><span id="e621" class="kk kl hi jr b fi mm mn l mo mp">enableHooks(jest, { dontMockByDefault: true });</span></pre><p id="3909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后你需要在测试文件中启用效果挂钩，方法是用<code class="du jo jp jq jr b">withHooks()</code>把它们包装起来。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="7ab7" class="ll kl hi bd km lm ln lo kq lp lq lr ku ls lt lu kx lv lw lx la ly lz ma ld mb bi translated">写作测试</h1><p id="131e" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">让我们以这个小组件为例，它在mount上发出一个AJAX请求，检查用户是否登录，有条件地呈现一个输入字段(如果他们登录了)，并在输入字段值改变时验证文本字段。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="05cf" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">测试组件安装效果挂钩</h2><p id="e83e" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">尽管useEffect钩子现在与<code class="du jo jp jq jr b">jest-react-hooks-shallow</code>一起运行，但我立即遇到了Effect钩子中异步函数的问题。我试图用jest <code class="du jo jp jq jr b">jest.mock('axios')</code>模仿axios，甚至试图集成<code class="du jo jp jq jr b"><a class="ae lk" href="https://github.com/mswjs/msw" rel="noopener ugc nofollow" target="_blank">msw</a></code>包来创建一个模拟服务器。但是这两个实现中的问题是，当模拟服务器返回一个值时，测试已经退出了。我尝试添加<code class="du jo jp jq jr b">setTimeout</code>并使用<code class="du jo jp jq jr b">done()</code>函数来确保它会等待更改触发，但无论我做什么都失败了。它总是渲染<code class="du jo jp jq jr b">&lt;&gt;User is not logged in.&lt;/&gt;</code>组件。</p><p id="d0a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我犯的错误是，我试图模仿服务器，而不是模仿抽象出查询服务器值的逻辑的函数。所以解决这个问题的方法很简单。我所做的是将发出异步请求的函数移动到另一个文件中，并模拟该函数。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="8a62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然异步请求被分离到一个不同的文件中，您可以模仿axios或者使用<code class="du jo jp jq jr b">msw</code>为<code class="du jo jp jq jr b">requests.js</code>添加测试规范。现在为<code class="du jo jp jq jr b">MyComponent.jsx</code>编写测试规范，你可以模仿<code class="du jo jp jq jr b">requests.js</code>来确保快速响应，从而解决问题。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="396d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，测试按预期运行，在用户登录时呈现输入字段，确保我们已经测试了组件挂载效果挂钩。</p><pre class="me mf mg mh fd mi jr mj mk aw ml bi"><span id="ce44" class="kk kl hi jr b fi mm mn l mo mp">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><span id="4fae" class="kk kl hi jr b fi ms mn l mo mp">exports[`MyComponent: When the user is logged in should render the logged in elements 1`] = `"&lt;input type=\\"text\\" value=\\"\\"/&gt;&lt;div&gt;&lt;/div&gt;"`;</span><span id="de8e" class="kk kl hi jr b fi ms mn l mo mp">exports[`MyComponent: When the user is not logged in should render not logged in message 1`] = `"User is not logged in."`;</span></pre><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/5dbb655bb659ead9267893569c01fc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*BjsPraIaZqXQqJG_uScCUg.png"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Passing tests ✅</figcaption></figure><h2 id="7dff" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">测试组件更新效果挂钩</h2><p id="8b92" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">测试组件更新效果挂钩也相当简单。我们可以模拟事件并检查变化。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="2794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们确保了当<code class="du jo jp jq jr b">text</code>状态更新时<code class="du jo jp jq jr b">validateText()</code>和<code class="du jo jp jq jr b">doSomething()</code>属性得到执行。</p><h1 id="96fe" class="ll kl hi bd km lm ln lo kq lp lq lr ku ls lt lu kx lv lw lx la ly lz ma ld mb bi translated">测试Redux挂钩</h1><p id="7695" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">如果你使用<code class="du jo jp jq jr b">react-redux</code>而不使用<code class="du jo jp jq jr b">useSelector</code>和<code class="du jo jp jq jr b">useDispatch</code>挂钩，你就错过了。我推荐阅读我写的这篇关于如何从使用connect迁移到使用redux挂钩的文章。🏴‍☠️</p><div class="js jt ez fb ju jv"><a href="https://acesmndr.medium.com/connect-to-usedispatch-and-useselector-in-redux-46aa5021ab55" rel="noopener follow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">连接到useDispatch并在Redux中使用Selector</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">为什么应该从mapDispatchToProps和mapStateToProps迁移到useDispatch和useSelector，以及如何做到这一点…</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">acesmndr.medium.com</p></div></div><div class="ke l"><div class="my l kg kh ki ke kj io jv"/></div></div></a></div><p id="881a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑这个简单的组件，其中从存储中获取登录状态，并在挂载时分派一个操作。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="2a33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用这些钩子测试组件，您需要模拟它们，最好的方法是在设置酶适配器的测试设置文件中这样做。嘲笑完<code class="du jo jp jq jr b">react-redux</code>之后会是这个样子。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="7a79" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">测试使用选择器挂钩</h2><p id="8c1d" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">现在测试useSelector挂钩非常简单，因为我们已经模拟了它。所以我们只需添加一个模拟实现来返回所需的值。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="3854" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">测试使用的Dispatch挂钩</h2><p id="d666" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">它类似于测试useSelector挂钩，但唯一的关键区别是，由于useDispatch是一个调度我们传递的函数的函数，因此我们需要一个模拟实现，以便它返回一个模拟函数，我们测试模拟函数以测试操作是否已被调度。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="f0fa" class="ll kl hi bd km lm ln lo kq lp lq lr ku ls lt lu kx lv lw lx la ly lz ma ld mb bi translated">结论</h1><p id="b25c" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">因此，通过这种方式，我设法为effect和redux挂钩编写了测试规范。总结一下:</p><ul class=""><li id="fca4" class="mz na hi is b it iu ix iy jb nb jf nc jj nd jn ne nf ng nh bi translated">当浅安装组件时，默认情况下Enzyme不支持效果挂钩。你需要添加<code class="du jo jp jq jr b">jest-react-hooks-shallow</code>来确保钩子运行。</li><li id="3dd1" class="mz na hi is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh bi translated">异步请求应该从组件中抽象到一个单独的文件中，这样在测试组件而不是模拟服务器时，可以删除或模拟产生异步请求的方法。</li><li id="07b6" class="mz na hi is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh bi translated">要测试组件更新useEffect挂钩，只需触发状态更新并检查渲染元素中的效果。</li><li id="f063" class="mz na hi is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh bi translated">Redux挂钩可以通过模仿它们和它们的实现来测试。</li></ul><p id="e919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这将有助于那些一直使用酶编写测试的人。😇如果您知道任何更简单或更好的编写浅层测试的方法，请告诉我。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Intrusion detection using Python OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python OpenCV进行入侵检测</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/intrusion-detection-using-python-opencv-515fad19cf2?source=collection_archive---------6-----------------------#2021-07-16">https://medium.com/geekculture/intrusion-detection-using-python-opencv-515fad19cf2?source=collection_archive---------6-----------------------#2021-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="885d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">分析闭路电视视频以检测入侵</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4a09a219b6e6e286825b204baa9122a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYDqJ1WMHfxGjdfiyX1pdw.jpeg"/></div></div></figure><h1 id="ca8f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">问题陈述</h1><p id="d6a7" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在这个简单的演示中，我们将看到如何分析和识别视频中的对象。下面的视频捕捉入侵者，我们将了解基本的处理技术来检测这一点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="7825" class="kz jk hi bd jl la lb lc jp ld le lf jt kk lg lh jv ko li lj jx ks lk ll jz lm bi translated">OpenCV是什么？</h2><p id="4d0c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">OpenCV是一个Python库，旨在解决计算机视觉问题。这是一个非常受欢迎的图像/视频处理库。</p><p id="35ff" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">OpenCV Python只不过是用于Python的原始C++库的包装类。使用这种方法，所有OpenCV数组结构都可以与NumPy数组相互转换。</p><h2 id="a355" class="kz jk hi bd jl la lb lc jp ld le lf jt kk lg lh jv ko li lj jx ks lk ll jz lm bi translated">计算机如何读取图像？</h2><p id="81ad" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">任何神经网络的输入都应该是数字，幸运的是，图像自然地被表示为数字数组。</p><ul class=""><li id="e639" class="ls lt hi kd b ke ln kh lo kk lu ko lv ks lw kw lx ly lz ma bi translated">图像由像素组成。</li><li id="afb9" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">0-255之间的数字代表每个像素的颜色强度。</li><li id="de3b" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">彩色图像中的每个像素是一个代表红、蓝、绿强度的阵列。红色、绿色和蓝色(RGB)被称为通道。</li><li id="e933" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">灰度图像(黑白图像)只有一个通道。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/6b533a2d97c53bc8eaa9e145123a60c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9u3b62cHn3DWJR_nctASw.png"/></div></div></figure><h2 id="0117" class="kz jk hi bd jl la lb lc jp ld le lf jt kk lg lh jv ko li lj jx ks lk ll jz lm bi translated"><strong class="ak">读取灰度和彩色图像</strong></h2><p id="437b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">将使用OpenCV(cv2)读取图像，并使用matplotlib绘制图像。</p><ul class=""><li id="4877" class="ls lt hi kd b ke ln kh lo kk lu ko lv ks lw kw lx ly lz ma bi translated">“imread”命令将从“文件”目录中读取图像</li><li id="3f70" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">cv2。“read gray”将用于读取灰度图像</li></ul><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="adba" class="kz jk hi mi b fi mm mn l mo mp">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span><span id="1af6" class="kz jk hi mi b fi mq mn l mo mp">## Reading a gray scale image<br/>img = cv2.imread("files/sachin_gray_scale.jpg",cv2.IMREAD_GRAYSCALE)<br/>plt.imshow(img,cmap='gray')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/521390ebd233848733e32596a248727d.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*2M2Wt2DQiWxe_Zn-fn4pLA.jpeg"/></div><figcaption class="ms mt et er es mu mv bd b be z dx">Sachin gray scale image</figcaption></figure><ul class=""><li id="7d30" class="ls lt hi kd b ke ln kh lo kk lu ko lv ks lw kw lx ly lz ma bi translated">OpenCv读取BGR颜色空间的彩色图像，而matplotlib需要RGB颜色空间的图像。为了显示图像，我们必须使用cv2将颜色从BGR转换为RGB。COLOR_BGR2RGB。</li></ul><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="6ce0" class="kz jk hi mi b fi mm mn l mo mp">## Reading a color image<br/>img = cv2.imread("files/sachin_color.jpg")<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/f37d780895ad75bf347ef1f32a1afd9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*MTHHSBqA9jravvTq14rIug.jpeg"/></div><figcaption class="ms mt et er es mu mv bd b be z dx">Sachin Color image</figcaption></figure><p id="54aa" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">灰度图像的形状为(206，160)，彩色图像的形状为(206，160，3)。最后一个数字显示频道。</p><h2 id="3b17" class="kz jk hi bd jl la lb lc jp ld le lf jt kk lg lh jv ko li lj jx ks lk ll jz lm bi translated"><strong class="ak">视频分析</strong></h2><p id="aa37" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">视频基本上是一系列帧，每一帧都是一幅图像。我们将看到OpenCV是如何被用来处理一系列图像(即视频)的。</p><p id="ca9e" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">首先加载视频，找出总帧数。我们还将显示一系列帧中的一幅图像。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="757a" class="kz jk hi mi b fi mm mn l mo mp"># Open a sample video available in sample-videos<br/>vcap = cv2.VideoCapture(r'files/sample_video.mp4')<br/>count = 0</span><span id="cd12" class="kz jk hi mi b fi mq mn l mo mp">#total number of frame in the video<br/>vcap.get(cv2.CAP_PROP_FRAME_COUNT)</span><span id="1ac5" class="kz jk hi mi b fi mq mn l mo mp">Out[32]: 2053.0</span></pre><p id="413a" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">这个视频总共有2053帧。下面语法中的“ret”返回二进制值(0/1 ),而“frame”返回视频中的一帧。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="5590" class="kz jk hi mi b fi mm mn l mo mp">ret,frame = vcap.read()<br/>frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)</span><span id="f98f" class="kz jk hi mi b fi mq mn l mo mp">plt.imshow(frame)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/2c9bc047eb7daa1d704c2569bcad2d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*sf3MxgYdNg103uWjWZ8XgQ.png"/></div></figure><p id="f971" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">要将视频转换为一系列帧，请读取示例视频文件，并在本地文件夹中每隔60个时间步长保存一次图像/帧。循环将继续，直到vcap.read()返回一帧。将每一帧保存在。jpg '格式。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="fbb1" class="kz jk hi mi b fi mm mn l mo mp"># Open a sample video available in sample-videos<br/>vcap = cv2.VideoCapture(r'files/sample_video.mp4')</span><span id="b3f2" class="kz jk hi mi b fi mq mn l mo mp"># read every nth frame<br/>count=0<br/>frame_num = []<br/>while vcap.isOpened():<br/>    ret, frame = vcap.read()<br/>    if ret:<br/>        frame_count = "frame_" + str(count) + ".jpg"<br/>        cv2.imwrite(os.path.join('frames', frame_count), frame)<br/>        frame_num.append(frame_count)<br/>        count += 60<br/>        vcap.set(1, count)<br/>    else:<br/>        vcap.release()<br/>        break</span><span id="ef99" class="kz jk hi mi b fi mq mn l mo mp"># change color space from BGR to RGB<br/>all_imgs = [cv2.cvtColor(cv2.imread(os.path.join("frames",x)), cv2.COLOR_BGR2GRAY) for x in frame_num]</span><span id="d751" class="kz jk hi mi b fi mq mn l mo mp"># total number of frame saved<br/>len(all_imgs)</span><span id="3d7b" class="kz jk hi mi b fi mq mn l mo mp">Out[40]:35</span></pre><ul class=""><li id="691f" class="ls lt hi kd b ke ln kh lo kk lu ko lv ks lw kw lx ly lz ma bi translated">根据上面的代码，在“os.path.join”提供的路径中保存了35个图像。</li><li id="4a26" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">计数是我们从视频中保存图像的步骤。我们现在将显示图像列表中的第一幅图像。</li><li id="0b64" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">注意，彩色图像在这个分析中没有任何区别。所以我们将处理灰色的图像。</li></ul><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="6169" class="kz jk hi mi b fi mm mn l mo mp"># show first image from the list. <br/>plt.imshow(all_imgs[0],cmap='gray')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/34023320e65429037d9e4ade84860c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ogfd97qrKXpr6J_3LfjXfw.png"/></div></figure><ul class=""><li id="c622" class="ls lt hi kd b ke ln kh lo kk lu ko lv ks lw kw lx ly lz ma bi translated">我们的目的是查明是否有人从大门进入。</li><li id="95ff" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">如果有人进入，后续帧将显示不同于前一帧。</li><li id="0c8c" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">但仔细观看视频后，我们可以看到汽车在道路上移动，即帧随时间变化。还有，CCTV视频中显示的时间戳是不断变化的。</li><li id="9f6c" class="ls lt hi kd b ke mb kh mc kk md ko me ks mf kw lx ly lz ma bi translated">我们将遮蔽这两个区域，以便可以比较每一帧剩余区域来检测任何变化。</li></ul><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="214c" class="kz jk hi mi b fi mm mn l mo mp">## masking the rectangular area near gate and timestamp for all images</span><span id="fc01" class="kz jk hi mi b fi mq mn l mo mp">for i in range(len(all_imgs)):<br/>    all_imgs[i][0:350,700:1280] = 0<br/>    all_imgs[i][0:100,0:700] = 0</span><span id="3c24" class="kz jk hi mi b fi mq mn l mo mp">plt.imshow(all_imgs[0],cmap='gray')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/c6269b7d865a69c5f716c45f883c83e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*Ud-P8aeKgqGoVMuAP0VMyg.png"/></div></figure><p id="4937" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">现在，我们将遍历所有图像，找出两个连续图像之间的差异。为此，我将使用大小为(10，10)的内核/过滤器。如果我们使用更小的内核，它也会显示出细微事物的图像差异(比如风引起的变化)。此外，应用腐蚀(形态学操作)。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="defd" class="kz jk hi mi b fi mm mn l mo mp"># find the difference between consecutive image and save in a list. </span><span id="7d67" class="kz jk hi mi b fi mq mn l mo mp">diff_from_ref = []<br/>for i in range(1,len(all_imgs)):<br/>    diff = all_imgs[i-1] - all_imgs[i]<br/>    kernel = np.ones((10,10),np.uint8)<br/>    diff_dilated = cv2.erode(diff,kernel,200)<br/>    diff_from_ref.append(np.sum(diff_dilated != 0)/(diff.shape[0]*diff.shape[1]))</span></pre><p id="a74f" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">在字典中转换上面的列表(diff_from_ref)并按升序排序</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="e827" class="kz jk hi mi b fi mm mn l mo mp"># create dictionary<br/>res = pd.DataFrame({"frame":frame_num[1:],"diff":diff_from_ref}) res.sort_values(by="diff",ascending=False)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/2c5b0dca1adc1092b15b098441657c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*TwxPorU8M_wEIZbTCxIC3Q.png"/></div></figure><p id="cf64" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">第33帧和第34帧显示的差异最大。让我们看看第33帧图像。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="028f" class="kz jk hi mi b fi mm mn l mo mp">img_id = 33<br/>diff = cv2.subtract(all_imgs[img_id-1],  all_imgs[img_id])<br/>kernel = np.ones((5,5),np.uint8)<br/>diff_dilated = cv2.erode(diff,kernel,12)<br/>plt.imshow(diff_dilated,cmap="gray")</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/e0b8de57776eb03154d705465216dd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*7j9GUDW4-Ap95wqrAEQ2Zw.png"/></div></figure><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="8ea8" class="kz jk hi mi b fi mm mn l mo mp"># to confirm check the 33rd and 34th image<br/>plt.imshow(all_imgs[33],cmap="gray")<br/>plt.imshow(all_imgs[34],cmap="gray")</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/901c15128d2076bf51450694165d2c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*KIi7wqGRkUzqlUf4NTDxpA.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/9acb0204d663c6accb0746af2e1195a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*2dq5gu010clalXdfz2ZmBg.png"/></div></figure><p id="6aa3" class="pw-post-body-paragraph kb kc hi kd b ke ln ij kg kh lo im kj kk lp km kn ko lq kq kr ks lr ku kv kw hb bi translated">我们可以看到在第33帧检测到入侵。</p></div></div>    
</body>
</html>
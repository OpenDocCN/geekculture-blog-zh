<html>
<head>
<title>djwto: Django Authentication with JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">djwto: Django与JWT的认证</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/djwto-django-authentication-with-jwt-3ff6a6141fa6?source=collection_archive---------28-----------------------#2021-07-06">https://medium.com/geekculture/djwto-django-authentication-with-jwt-3ff6a6141fa6?source=collection_archive---------28-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7e1f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用JWTs介绍auth层的替代实现。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e829c53f2bf8a1b39b197e8e15a0fcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3b993ddwiAorApgloKYOw.png"/></div></div></figure><p id="9364" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我通常写数据科学项目。所以它回避了这个问题:“为什么这篇文章是关于在Django上添加一个基于JWT的认证层？”</p><p id="bb59" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">嗯，我可以说的是，在我们工作的每个项目中，为客户提供某种简单而有效的在线门户的需求变得非常明显，在那里他们可以与ML模型进行交互。</p><p id="d663" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这基本上就是我开发djwto的旅程的场景，DJ WTO是Django的另一个JWT认证实现。构建前端的一个步骤是建立一个合适的授权层，我们选择使用<em class="kf"> JWT </em> s来完成。</p><p id="138a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目前已经有很多很棒的软件包了，<em class="kf"> djwto </em>基本上增加了一些新的特性，同时以简单和轻量为目标。一些新的可能性包括:</p><ul class=""><li id="132d" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">djwto提供了将访问令牌分成两部分的选项(这是其名字的主要灵感)，其中一部分是解码后的有效载荷。</li><li id="a23f" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">使用无记名令牌或cookies。</li><li id="77c1" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">CSRF受到默认保护。</li><li id="2a7b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">提供<em class="kf">装饰器</em>来保护视图(完全认证和授权层)。</li><li id="7f9e" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">完全可定制。</li></ul><p id="59c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本帖中，让我们来看看对<em class="kf"> djwto </em>的简要介绍，以及它如何帮助开发者在他们的项目中添加auth层。我们将构建一个Django项目，并与前面提到的一些特性进行交互。</p><h1 id="2097" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">1.环境</h1><p id="9e9f" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">我们首先需要一个Django项目，所以让我们创建一个(接下来假设使用一个基于unix的系统)。将目录更改为空目录，并运行命令:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="f4e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">放心使用另一个版本的Python(可以是3.7也可以是3.9)；这是我们目前掌握的情况:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="f66b" class="lz kw hi lv b fi ma mb l mc md">.<br/>├── djwto_project<br/>│ ├── asgi.py<br/>│ ├── __init__.py<br/>│ ├── settings.py<br/>│ ├── urls.py<br/>│ └── wsgi.py<br/>└── manage.py</span></pre><p id="b889" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们修改<code class="du me mf mg lv b">urls.py</code>以包含<em class="kf"> djwto的</em>URL:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="4e58" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">也可以修改<code class="du me mf mg lv b">settings.py</code>来配置<em class="kf"> djwto </em>应该如何运行。这里有一个简单的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="299d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们将<code class="du me mf mg lv b">"djwto"</code>添加到<code class="du me mf mg lv b">INSTALLED_APPS</code>(这里添加<code class="du me mf mg lv b">"sslserver"</code>也只是为了测试https，实际上没有必要)。</p><p id="ec17" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个设定值在很大程度上应该是直观的。其中有几个值得进一步讨论:</p><ul class=""><li id="5b35" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated"><code class="du me mf mg lv b">DJWTO_SIGNING_KEY</code>应该包含用于编码令牌的密钥，默认情况下应该作为环境变量提供。如果使用非对称加密，那么也应该设置<code class="du me mf mg lv b">DJWTO_VERIFYING_KEY</code>。</li><li id="fdf4" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><code class="du me mf mg lv b">DJWTO_MODE</code>设置客户端如何处理<em class="kf">jwt</em>。<em class="kf"> djwto </em>使用两个令牌工作:<em class="kf">访问</em>和<em class="kf">刷新</em>。它们本质上是一样的东西，但前者是短暂的，应该通过使用后者来“刷新”，后者则是长期的。操作方式可以是下列方式之一:<br/> - <code class="du me mf mg lv b"><strong class="jl hj">JSON</strong></code>:将<em class="kf">jwt</em>作为常规<em class="kf">JSON</em>返回给客户端。<br/>-<code class="du me mf mg lv b"><strong class="jl hj">ONE-COOKIE</strong></code>:jwt<em class="kf"/>存储在cookies中。<br/> - <code class="du me mf mg lv b"><strong class="jl hj">TWO-COOKIES</strong></code>:与之前类似，但这次<em class="kf">访问</em>令牌被分成两部分。一个未编码，因此其有效载荷可由客户端访问。</li></ul><p id="0363" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在官方<a class="ae kg" href="https://djwto.readthedocs.io/en/latest/settings.html" rel="noopener ugc nofollow" target="_blank">文档</a>中可以找到每个设置的进一步说明。</p><p id="2e77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据库中还需要一个用户；请随意使用您最喜欢的方法创建一个。让我们首先运行迁移:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="4d17" class="lz kw hi lv b fi ma mb l mc md">export DJWTO_SIGNING_KEY=’test key’ &amp;&amp; python manage.py makemigrations<br/>python manage.py migrate</span></pre><p id="a844" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后让我们使用<code class="du me mf mg lv b">shell</code>:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="0325" class="lz kw hi lv b fi ma mb l mc md">python manage.py shell</span></pre><p id="f56e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">运行以下命令:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="2a7d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在数据库包含了用户<em class="kf"> alice </em>，我们将使用它进行身份验证。</p><p id="c474" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，让我们为我们的项目创建一个新的应用程序，在这里我们将与<em class="kf"> djwto进行交互。</em>只需在您的终端中运行:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="0686" class="lz kw hi lv b fi ma mb l mc md">python manage.py startapp testapp</span></pre><p id="523d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们来测试一下djwto。</p><h1 id="4727" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">2.运行djwto</h1><p id="85a9" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">首先，让我们使用<code class="du me mf mg lv b">requests</code>库，向用户<em class="kf"> alice </em>发送一个登录POST请求，看看情况如何。首先，我们需要运行服务器:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="e291" class="lz kw hi lv b fi ma mb l mc md">export DJWTO_SIGNING_KEY=’test key’ &amp;&amp; python manage.py runsslserver 0.0.0.0:8002</span></pre><p id="d8b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们导出了签名密钥的值，并使用<code class="du me mf mg lv b">sslserver</code>进行https加密管理，所有这些都在端口<code class="du me mf mg lv b">8002</code>上(试图选择一个有点不寻常的端口)。</p><h2 id="86ab" class="lz kw hi bd kx mh mi mj lb mk ml mm lf js mn mo lh jw mp mq lj ka mr ms ll mt bi translated">2.1登录</h2><p id="31bb" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">下面是发送一个<code class="du me mf mg lv b">login</code>请求的Python代码</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="5e94" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，如果运行<em class="kf"> djwto </em>的模式是JSON，那么结果应该是在响应中检索到<em class="kf">访问</em>和<em class="kf">刷新</em>令牌:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/8ab02292a746af755ab9a63d47ea1b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpD4DzmHgVdLaJryc-ZoyQ.png"/></div></div><figcaption class="mv mw et er es mx my bd b be z dx"><em class="mz">refresh and access tokens returned in JSON mode.</em></figcaption></figure><p id="fe38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们继续更改<em class="kf"> djwto </em>运行的设置，并将其模式设置为双COOKIES选项:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="58ee" class="lz kw hi lv b fi ma mb l mc md">#./djwto_project/settings.py</span><span id="432a" class="lz kw hi lv b fi na mb l mc md">DJWTO_MODE = ‘TWO-COOKIES’</span></pre><p id="49ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">相同的代码现在将返回不同的内容。<code class="du me mf mg lv b">sess</code>变量将包含带有<code class="du me mf mg lv b">csrftoken</code>和<em class="kf">jwt</em>的cookies:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="5a4e" class="lz kw hi lv b fi ma mb l mc md">sess<br/>&lt;RequestsCookieJar[</span><span id="1196" class="lz kw hi lv b fi na mb l mc md">    Cookie(name=’<strong class="lv hj">csrftoken</strong>’, value=’mzv…’),</span><span id="db7f" class="lz kw hi lv b fi na mb l mc md">    Cookie(name=’<strong class="lv hj">jwt_access_payload</strong>’, value=’eyJ…'),</span><span id="251b" class="lz kw hi lv b fi na mb l mc md">    Cookie(name=’<strong class="lv hj">jwt_access_token</strong>’, value=’eyJ’, rest={‘HttpOnly’: None}), </span><span id="053d" class="lz kw hi lv b fi na mb l mc md">    Cookie(name=’<strong class="lv hj">jwt_refresh</strong>’, value=’eyJ’, path=’/api/token/refresh’, rest={‘HttpOnly’: None})</span><span id="9932" class="lz kw hi lv b fi na mb l mc md">]&gt;</span></pre><p id="315c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf"> jwt_access_payload </em>包含令牌有效负载的<code class="du me mf mg lv b">base64</code>编码值。事实上，为了检索原始值，只需解码它:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/53542acd1bf4842b37c2cc75faeeed79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9Dtlq_unnA0MMYwiF6HrQ.png"/></div></div><figcaption class="mv mw et er es mx my bd b be z dx">Decoding the access JWT token.</figcaption></figure><p id="ed19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前端客户端可以直接使用这个值(仍然要注意不要在那里存储敏感信息)。</p><p id="f745" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们看看如何执行令牌验证来确认<em class="kf">jwt</em>仍然是好的。</p><h2 id="43dd" class="lz kw hi bd kx mh mi mj lb mk ml mm lf js mn mo lh jw mp mq lj ka mr ms ll mt bi translated">2.2验证</h2><p id="39db" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">假设令牌已经创建，有时需要检查它们在某个时候是否仍然有效。假设我们处于JSON模式:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8893" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，令牌被简单地添加到报头<code class="du me mf mg lv b">AUTHORIZATION</code>中，遵循承载模式。这应该会返回:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/7af0b1443f60afe23d820c72ad561646.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*6MO3ury6ROOh4x2MogJYHQ.png"/></div><figcaption class="mv mw et er es mx my bd b be z dx">Valid response</figcaption></figure><p id="04fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于一个COOKIE或两个COOKIE模式，下面是如何做到这一点:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="cf6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意<em class="kf"> csrf令牌</em>在报头<code class="du me mf mg lv b">X-CSRFToken</code>中发送，同时还有一个<code class="du me mf mg lv b">REFERER</code>指示请求来自哪里(由于Django的安全系统，这是必要的)。</p><p id="efe3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">验证<em class="kf">刷新</em>令牌有点不同:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d085" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所有终点的其余部分在官方<a class="ae kg" href="https://djwto.readthedocs.io/en/latest/endpoints.html" rel="noopener ugc nofollow" target="_blank">文档</a>中有完整记录。</p><h1 id="e7b9" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">3.保护视图</h1><p id="a035" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">djwto 通过要求jwt在输入请求中可用来提供对视图的直接保护。为了进行测试，让我们在我们的<em class="kf"> testapp </em>中创建一个视图，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="dd7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意<code class="du me mf mg lv b">@method_decorator(auth.jwt_login_required)</code>和<code class="du me mf mg lv b">auth.jwt_perm_required</code>。当用这些来装饰视图时，只有当请求包含一个认证的<em class="kf"> JWT </em>时，视图才会被处理。</p><p id="714f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<em class="kf"> testapp </em>中创建一个文件<code class="du me mf mg lv b">urls.py</code>，这样我们就可以路由到那些视图，就像这样:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="9f7e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更新项目URL文件以包含新添加的testapp:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="dd42" class="lz kw hi lv b fi ma mb l mc md"># ./djwto_project/urls.py<br/>from django.urls import path, include</span><span id="62ea" class="lz kw hi lv b fi na mb l mc md">urlpatterns = [<br/>    path('', include('djwto.urls')),<br/>    path('', include('testapp.urls'))<br/>]</span></pre><p id="3262" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们可以向服务器发送GET请求了:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="cbab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哪个返回:<code class="du me mf mg lv b">"worked!"</code>。如果我们从请求中删除jwt，会发生以下情况:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/dff0f59315338f9fbf4b12713cb3b8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*hkm8mAjER1L9FD18d0dvjQ.png"/></div></div><figcaption class="mv mw et er es mx my bd b be z dx">View is fully protected by the JWTs.</figcaption></figure><p id="a30b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">包含<code class="du me mf mg lv b">jwt_login_required</code>的每个视图现在都受到完全保护；这同样可以用于用户权限。</p><h1 id="2876" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">4.用户化</h1><p id="6932" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">djwto 旨在实现可定制化。让我们看一个例子。使用我们的<em class="kf"> testapp，</em>让我们更新文件<code class="du me mf mg lv b">apps.py</code>以更改创建令牌时处理用户的方式:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="4c95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，我们导入了<code class="du me mf mg lv b">djwto.tokens</code>并更改了处理用户的函数。现在，当用户登录时，一个新的字段<code class="du me mf mg lv b">email</code>将出现在令牌中；您可以更改其行为以更好地满足您的需求。以下是新令牌的结果示例:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="95a9" class="lz kw hi lv b fi ma mb l mc md">{<br/>    "aud": "aud",<br/>    "exp": 1624259339,<br/>    "iat": 1624229339,<br/>    "iss": "iss",<br/>    "jti": "900f4f1a-3e0f-4843-9997-9fd8d032684e",<br/>    "refresh_iat": 1624229339,<br/>    "sub": "sub",<br/>    "type": "access",<br/>    "user": {<br/>        "email": "alice@djwto.com",<br/>        "id": 1,<br/>        "perms": [],<br/>        "username": "alice"<br/>    }<br/>}</span></pre><h1 id="8b2b" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">5.结论</h1><p id="a5af" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">简而言之，这就是djwto。官方回购中充分记录了许多其他功能:</p><div class="ne nf ez fb ng nh"><a href="https://github.com/WillianFuks/djwto" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">威廉福克斯/djwto</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">姜戈的JWT认证。在GitHub上创建一个帐户，为WillianFuks/djwto的发展做出贡献。</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jh nh"/></div></div></a></div><p id="3cde" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在那里你会发现更多关于信号、端点、定制、管理双cookies设置等等。请随意查看！</p></div></div>    
</body>
</html>
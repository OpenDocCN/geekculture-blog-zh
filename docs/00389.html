<html>
<head>
<title>Lombok: Unhinge Yourself From Boilerplate Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让自己从样板代码中脱离出来</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/lombok-unhinge-yourself-from-boilerplate-code-8535ec5391f?source=collection_archive---------6-----------------------#2021-01-28">https://medium.com/geekculture/lombok-unhinge-yourself-from-boilerplate-code-8535ec5391f?source=collection_archive---------6-----------------------#2021-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1a5ab3261dd32b7252631b1983a4f87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_W2ndQQhzpmbMWW8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@beckerworks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Becker</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e488" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">概观</h1><p id="ac72" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Java是一种强类型的、面向对象的编程语言，通常翻译成严格的请求、响应和数据传输对象。它为开发人员提供了任何类中可供使用的数据的清晰画面，但添加了许多样板代码，如getters、setters，我们不要忘记构造函数。不仅编写和维护这些方法很痛苦，而且还会增加代码的混乱。Lombok项目允许我们在令人印象深刻的社区支持下编写整洁的代码。</p><h1 id="7720" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">突出</h1><p id="c83e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Lombok是一个代码生成器，在编译时运行。在深入研究软件包的特性之前，让我们看看如何将它们包含在我们的配置文件中:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a9b1" class="la iw hi kw b fi lb lc l ld le">/* Maven */</span><span id="7c97" class="la iw hi kw b fi lf lc l ld le">&lt;dependencies&gt;<br/>	&lt;dependency&gt;<br/>		&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>		&lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>		&lt;version&gt;${lombok.version}&lt;/version&gt;<br/>		&lt;scope&gt;provided&lt;/scope&gt;<br/>	&lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span><span id="c29b" class="la iw hi kw b fi lf lc l ld le">/* Include in build section of the pom file */</span><span id="f13a" class="la iw hi kw b fi lf lc l ld le">&lt;annotationProcessorPaths&gt;<br/>	&lt;path&gt;<br/>		&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>		&lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>		&lt;version&gt;1.18.16&lt;/version&gt;<br/>	&lt;/path&gt;<br/>&lt;/annotationProcessorPaths&gt;</span><span id="b0a9" class="la iw hi kw b fi lf lc l ld le">/* Gradle */</span><span id="1d1d" class="la iw hi kw b fi lf lc l ld le">dependencies {<br/>	compileOnly 'org.projectlombok:lombok:$version'<br/>	annotationProcessor 'org.projectlombok:lombok:$version'<br/>	<br/>	testCompileOnly 'org.projectlombok:lombok:$version'<br/>	testAnnotationProcessor 'org.projectlombok:lombok:$version'<br/>}</span></pre><p id="2ac5" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">如果你正在使用IntelliJ IDEA，建议安装Lombok插件以获得更好的开发者体验。</p><h2 id="0e06" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">简化封装</h2><ul class=""><li id="6d4f" class="ly lz hi jv b jw jx ka kb ke ma ki mb km mc kq md me mf mg bi translated">getter和setter:<br/>getter和setter是封装的一个重要方面，它们允许类决定哪些数据对其他对象可用。相反，为大型类编写Getters和Setters会增加混乱。Lombok提供了可以放在类或字段级别的<code class="du mh mi mj kw b">@Getter</code>和<code class="du mh mi mj kw b">@Setter</code>注释。如果您希望类的所有字段都有getter/setter，那么向整个类添加注释是明智的。让我们来看一个标准的<code class="du mh mi mj kw b">Student</code>级:</li></ul><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="515e" class="la iw hi kw b fi lb lc l ld le">public class Student {<br/>    <br/>    private String name;<br/>    private String identityNumber;<br/>    private Integer grade;<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public String getIdentityNumber() {<br/>        return identityNumber;<br/>    }<br/><br/>    public void setIdentityNumber(String identityNumber) {<br/>        this.identityNumber = identityNumber;<br/>    }<br/><br/>    public Integer getGrade() {<br/>        return grade;<br/>    }<br/><br/>    public void setGrade(Integer grade) {<br/>        this.grade = grade;<br/>    }<br/><br/>    public Student(String name, String identityNumber, Integer grade) {<br/>        this.name = name;<br/>        this.identityNumber = identityNumber;<br/>        this.grade = grade;<br/>    }<br/>}</span></pre><p id="42fc" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">现在让我们添加一些龙目岛的魔法:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f98e" class="la iw hi kw b fi lb lc l ld le">@Getter<br/>@Setter<br/>public class Student {<br/><br/>    private String name;<br/>    private String identityNumber;<br/>    private Integer grade;<br/><br/>    public Student(String name, String identityNumber, Integer grade) {<br/>        this.name = name;<br/>        this.identityNumber = identityNumber;<br/>        this.grade = grade;<br/>    }<br/>}</span></pre><ul class=""><li id="7640" class="ly lz hi jv b jw lg ka lh ke mk ki ml km mm kq md me mf mg bi translated"><strong class="jv hj">构造函数</strong> : <br/> Lombok提供了三种不同的注释来为你的类生成构造函数。<code class="du mh mi mj kw b">@AllArgsConstructor</code>为类中的所有字段添加一个构造函数。相应地，<code class="du mh mi mj kw b">@NoArgsConstructor</code>增加了一个空的构造函数。但是，如果您只想为类中的非final字段构造一个构造函数，那么<code class="du mh mi mj kw b">@RequiredArgsConstructor</code>恰恰可以做到这一点。</li><li id="8527" class="ly lz hi jv b jw mn ka mo ke mp ki mq km mr kq md me mf mg bi translated"><code class="du mh mi mj kw b"><strong class="jv hj">hashcode</strong></code> <strong class="jv hj">、</strong> <code class="du mh mi mj kw b"><strong class="jv hj">equals</strong></code> <strong class="jv hj">和</strong> <code class="du mh mi mj kw b"><strong class="jv hj">toString</strong></code> <strong class="jv hj">方法</strong> : <br/>重写<code class="du mh mi mj kw b">toString()</code>和<code class="du mh mi mj kw b">equals()</code>方法是一些最容易预测的样板代码片段。有趣的是，在整个代码库中标准化它们可能会令人望而生畏。Lombok已经提供了<code class="du mh mi mj kw b">@ToString</code>和<code class="du mh mi mj kw b">@EqualsAndHashCode</code>注释，每当我们编译时，它们都会自动生成方法。这两个注释都放在类级别，允许开发人员通过将属性<code class="du mh mi mj kw b">callSuper</code>设为true来包含超类中的字段。</li></ul><p id="86d3" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">因此您可以简化一个普通的旧的<code class="du mh mi mj kw b">Student</code>类型的Java对象，如下所示</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8616" class="la iw hi kw b fi lb lc l ld le">@Getter<br/>@Setter<br/>@AllArgsConstructor<br/>@EqualsAndHashCode<br/>@ToString<br/>public class Student {<br/><br/>    private String name;<br/>    private String identityNumber;<br/>    private Integer grade;<br/>}</span></pre><p id="05d8" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">但是，如果你觉得在每个类中添加<code class="du mh mi mj kw b">@AllArgsConstructor</code>、<code class="du mh mi mj kw b">@Getter</code>、<code class="du mh mi mj kw b">@Setter</code>和<code class="du mh mi mj kw b">@EqualsAndHashCode</code>很麻烦。可以用<code class="du mh mi mj kw b">@Data</code>来代替，一个简单但功能强大的别名。</p><h2 id="884a" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">不变性增强</h2><p id="fdac" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">让我们首先编写一个不可变的类。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e4e9" class="la iw hi kw b fi lb lc l ld le">public final class Student {<br/><br/>    private final String name;<br/>    private final String identityNumber;<br/>    private final Integer grade;<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public String getIdentityNumber() {<br/>        return identityNumber;<br/>    }<br/><br/>    public Integer getGrade() {<br/>        return grade;<br/>    }<br/><br/>    public Student(String name, String identityNumber, Integer grade) {<br/>        this.name = name;<br/>        this.identityNumber = identityNumber;<br/>        this.grade = grade;<br/>    }<br/>}</span></pre><p id="b165" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">我们可以使用<code class="du mh mi mj kw b">@Value</code>注释将类中的每个字段标记为final。它还向该类添加了一个<code class="du mh mi mj kw b">equals()</code>和<code class="du mh mi mj kw b">hashCode</code>方法。因此，它可以被认为是<code class="du mh mi mj kw b">@Data</code>的不可变变体。我们还可以通过在字段顶部使用<code class="du mh mi mj kw b">@NonFinal</code>使字段成为非最终字段。但是它不会是完全不可改变的。我们的学生类现在看起来像这样:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="834f" class="la iw hi kw b fi lb lc l ld le">@Value<br/>public class Student {<br/><br/>    private final String name;<br/>    private final String identityNumber;<br/>    private final Integer grade;<br/>}</span></pre><h2 id="b130" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">不要再建造建筑了</h2><p id="6f51" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">构建器模式是构建复杂对象的一种简洁方式。不幸的是，为每个复杂或大型的类编写构建器感觉很费力。Lombok为<code class="du mh mi mj kw b">@Builder</code>注释提供了可选的<code class="du mh mi mj kw b">toBuilder</code>属性。如果属性设置为true，那么将提供一个从构建的对象获取构建器的方法。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4c70" class="la iw hi kw b fi lb lc l ld le">/* without @Builder */</span><span id="a644" class="la iw hi kw b fi lf lc l ld le">public class Student {<br/><br/>    private final String name;<br/>    private final String identityNumber;<br/>    private final Integer grade;<br/>    <br/>    public static Builder builder(){<br/>        return new Builder();<br/>    }<br/><br/>    public static class Builder {<br/>        private String name;<br/>        private String identityNumber;<br/>        private Integer grade;<br/>        <br/>        public Builder name(String name){<br/>            this.name = name;<br/>            return this;<br/>        }<br/><br/>        public Builder identityNumber(String identityNumber){<br/>            this.identityNumber = identityNumber;<br/>            return this;<br/>        }<br/><br/>        public Builder grade(Integer grade){<br/>            this.grade = grade;<br/>            return this;<br/>        }<br/>        <br/>        public Student build(){<br/>            return new Student(name, identityNumber, grade);<br/>        }<br/>    }<br/>}</span><span id="2eed" class="la iw hi kw b fi lf lc l ld le">/* with @Builder */</span><span id="4719" class="la iw hi kw b fi lf lc l ld le">@Builder<br/>public class Student {<br/><br/>    private final String name;<br/>    private final String identityNumber;<br/>    private final Integer grade;<br/>}</span></pre><p id="620a" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">我们可以使用构建器类，如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3c9e" class="la iw hi kw b fi lb lc l ld le">Student student = Student.<em class="ms">builder</em>()<br/>        .name("unpackaged")<br/>        .identityNumber("1A045")<br/>        .grade(9)<br/>        .build();</span></pre><h2 id="d101" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">轻松编写同步代码</h2><p id="6ae1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">编写多线程应用程序时，大多数关键部分都用同步块标记。下面显示了一个示例代码片段:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9dd2" class="la iw hi kw b fi lb lc l ld le">public class Student {<br/><br/>    private String name;<br/>    private String identityNumber;<br/>    private Integer grade;<br/>    private final Object lock = new Object();<br/><br/>    public Integer updateGrade(Integer marks){<br/>        synchronized (lock) {<br/>            if (marks &gt; 40) {<br/>                grade++;<br/>            }<br/>        }<br/>        return grade;<br/>    }<br/>}</span></pre><p id="5254" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">管理多个这样的锁变量增加了混乱，并可能导致一些代码味道。我们可以将这样的块卸载到Lombok的<code class="du mh mi mj kw b">@Synchronized</code>注释中。它将一个<code class="du mh mi mj kw b">$LOCK</code>变量添加到类的静态和非静态范围(如果不存在的话),并将临界区包装在一个同步块中。它允许开发人员只关注业务逻辑。您还可以传递一个字符串作为锁变量的名称。上面的类将被转换如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0b14" class="la iw hi kw b fi lb lc l ld le">public class Student {<br/><br/>    private String name;<br/>    private String identityNumber;<br/>    private Integer grade;<br/>    private final Object lock = new Object();<br/><br/>    @Synchronized<br/>    public Integer updateGrade(Integer marks){<br/>        if (marks &gt; 40) {<br/>            grade++;<br/>        }<br/>        return grade;<br/>    }<br/><br/>    @Synchronized("lock")<br/>    public String getName(){<br/>        return name;<br/>    }<br/>}</span></pre><h2 id="040e" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">实验特性</h2><p id="0858" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">除了上面的注释，还有更多代码生成器可用。龙目岛遵循金丝雀方法。最初，实验包中有一个代码生成器。在观察了它的采用和错误修复之后，它被提升到主包。让我们简单地看看一些有趣的实验注释:</p><ul class=""><li id="d9e8" class="ly lz hi jv b jw lg ka lh ke mk ki ml km mm kq md me mf mg bi translated"><code class="du mh mi mj kw b">@FieldNameConstants</code>:创建一个内部类，其中包含注释所在类中所有字段的常量。有趣的是，它没有为方法或类名生成常量。如果他们能在将它标记为稳定可用之前将它添加到注释中，那就更好了。</li><li id="c7b6" class="ly lz hi jv b jw mn ka mo ke mp ki mq km mr kq md me mf mg bi translated"><code class="du mh mi mj kw b">@UtilityClass</code>:向带注释的类添加私有构造函数，并将类中的所有字段和方法标记为静态。</li><li id="20e0" class="ly lz hi jv b jw mn ka mo ke mp ki mq km mr kq md me mf mg bi translated"><code class="du mh mi mj kw b">@Slf4j</code>:用配置好的记录器向类中添加一个记录器对象。</li></ul><p id="4be0" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">虽然这些没有其他生成器强大，但它们仍然使代码可预测，并且不容易出现人为错误，例如创建一个实用程序类的对象或为一个类配置错误的记录器！</p><h2 id="5dea" class="la iw hi bd ix ll lm ln jb lo lp lq jf ke lr ls jj ki lt lu jn km lv lw jr lx bi translated">我再也不想用Lombok了！</h2><p id="c819" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果在任何时候想要从应用程序中移除Lombok，可以使用Delombok工具来生成样板代码，并从构建配置文件中移除应用程序。Delombok在Lombok jar文件中可用。开发人员可以运行下面的命令来解绑他们的应用程序:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1465" class="la iw hi kw b fi lb lc l ld le">java -jar lombok.jar delombok &lt;source-direcory&gt; -d &lt;destination-directory&gt;</span></pre><p id="e19c" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">IDEA还提供了一个选项来解包选定的文件。您也可以使用maven插件来实现同样的功能。</p><h1 id="d610" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">评估指标</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/1d3c7d3de180faca7e3ad395db193d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SC1GdYjgi-aSvct_PWpUpQ.png"/></div></div></figure><h1 id="e40f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="7fc4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们不能过分强调Lombok节省了多少时间，同时消除了Java开发人员日常生活中常见的混乱。与标准注释处理器不同，Lombok使用内部Java APIs并将代码注入到类中。因此，随着Java采用更快的发布周期，它引起了开发者对其稳定性的关注。然而，如果你考虑到所有的优势，以及你可以随时解包你的代码，我们可以毫无顾虑地接受它。它让Java代码看起来又很酷了。</p><p id="5299" class="pw-post-body-paragraph jt ju hi jv b jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">作为一个群体，他们非常活跃。任何人都可以加入他们的电子邮件线程，并开始一个可能的功能或增强线程。他们还对他们认为稳定的东西保持谨慎，因此，消除了任何疑虑。</p><h1 id="1dd1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">看看这个包裹和一些阅读材料</h1><ul class=""><li id="30ac" class="ly lz hi jv b jw jx ka kb ke ma ki mb km mc kq md me mf mg bi translated"><a class="ae iu" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">https://projectlombok.org/</a></li><li id="b5b1" class="ly lz hi jv b jw mn ka mo ke mp ki mq km mr kq md me mf mg bi translated">加入https://groups.google.com/forum/#!forum/project-lombok<a class="ae iu" href="https://groups.google.com/forum/#!forum/project-lombok" rel="noopener ugc nofollow" target="_blank">的龙目岛社区，参与并为这个令人惊叹的图书馆做出贡献。</a></li></ul><h1 id="e590" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">揭发</h1><p id="59a2" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">本文/评论中提到的内容和评估分数是主观的，是作者在无包装评论中基于日常使用和对流行开发者论坛的研究的个人意见。它们不代表任何公司的观点，也不受任何赞助/合作的影响。</p></div></div>    
</body>
</html>
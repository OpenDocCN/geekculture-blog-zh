<html>
<head>
<title>Neural Network from scratch on Python with mathematical proofs and code explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python上从头开始的神经网络，带有数学证明和代码解释</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/just-another-neural-network-from-scratch-on-python-simpler-cleaner-1083e3ce3b41?source=collection_archive---------25-----------------------#2021-06-07">https://medium.com/geekculture/just-another-neural-network-from-scratch-on-python-simpler-cleaner-1083e3ce3b41?source=collection_archive---------25-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="93fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你害怕看到这篇文章的长度或底部的方程，你可能想先看看一个更简单的只有一个神经元的神经网络。</p><p id="e34b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们先运行代码，然后分析每一部分</strong></p><p id="3794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们克隆这个Github <a class="ae jd" href="https://github.com/arf-themascoteers/c2f.git" rel="noopener ugc nofollow" target="_blank">项目</a>，或者简单地在您最喜欢的IDE中运行下面的代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="97b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要帮助来设置运行代码的环境，请参阅这篇文章来开始使用PyCharm。如果一切顺利，你会看到这样的图表。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/c252aff812c6c23c5e4d79c624a28f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01V7q5h9Wj-sqG1KBw1WPQ.png"/></div></div></figure><p id="b1c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题——华氏温度从摄氏温度上升</strong></p><p id="cb44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将训练机器从摄氏温度预测华氏温度。正如您从代码(或图表)中可以理解的，蓝线是实际的摄氏-华氏关系。红线是我们的宝贝机器在没有任何训练的情况下预测的关系。最后我们对机器进行训练，绿线是训练后的预测。</p><p id="e7dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">魔法在第69行，我们在那里训练机器。可以看到训练前后，都是用同一个函数进行预测(<strong class="ih hj"><em class="js">get _ predicted _ Fahrenheit _ values()</em></strong>)。那么神奇的火车()在做什么呢？让我们找出答案。</p><p id="c5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">网络结构</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jt"><img src="../Images/9998ce9fc1864ad4b2d3afa941a49106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRM9nNf5_gQXDrjNSuhHnA.png"/></div></div></figure><p id="88a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入</strong>:表示摄氏度的浮点数</p><p id="4d9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权重1 </strong> : 1 X 2矩阵，代表从输入到层1的2个权重</p><p id="30ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> biases1 </strong> : 1 X 2矩阵，代表从输入到层1的2个偏差</p><p id="3743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权重2</strong>:2×1矩阵，表示从层1到输出的2个权重</p><p id="eb7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">偏置2</strong>:1×1矩阵，表示从层1到输出的1个偏置</p><p id="d34e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong>:表示预测华氏温度的浮点数</p><p id="8a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们总共有7个参数(第一层2个权重，第一层2个偏差，第二层2个权重，第二层1个偏差)。</p><p id="e691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码的取证分析</strong></p><p id="6c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们一部分一部分地解释代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ju"><img src="../Images/e04294a6d50d2b03c16bcde0a3df9551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*bvmbH4eM3lcGiSYOoQoveg.png"/></div></div></figure><p id="e4ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第12行，我们生成了一个由-50到+50之间的100个数字组成的数组。</p><p id="7735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第13行中，我们将一维数组转换为100 X 1的矩阵，这将有助于向机器提供数据，您很快就会看到这一点。</p><blockquote class="jv jw jx"><p id="6b5f" class="if ig js ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">为了理解<strong class="ih hj"> <em class="hi"> reshape() </em> </strong>如何工作，如果<strong class="ih hj"> x </strong>是一个[10，20，30]的数组，x.reshape(3，1)将产生一个2D矩阵，每行只包含一列。换句话说，每一行将成为一个元素的数组—在这种情况下，第一行将是一个包含[10]、第二行[20]和第三行[30]的数组。</p></blockquote><p id="eef1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第14行，我们为每个摄氏温度值生成华氏温度。</p><p id="d97a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从第16–20行开始，我们用随机值初始化我们的网络参数。</p><p id="f9e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练()</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es kb"><img src="../Images/90e8c2b7656d8d66c26176e19b510dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcXbR3Kjjw7bym9lvIEKBQ.png"/></div></div></figure><p id="1111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里进行了2000次反复的训练。每次迭代由以下部分组成:</p><ol class=""><li id="04c5" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">向前(58号线)传递</li><li id="9558" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">向后(59号线)传递</li><li id="49f9" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">更新参数(第60行)</li></ol><blockquote class="jv jw jx"><p id="1a2c" class="if ig js ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">如果您是python的新手，可能会觉得有点奇怪——python函数可以返回多个值作为<strong class="ih hj">元组</strong></p></blockquote><p id="faa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，update_parameters是我们唯一感兴趣的东西。我们在这里做的其他事情是评估这个函数的参数，这些参数是我们的权重和偏差的<strong class="ih hj"> <em class="js">梯度</em> </strong>(我们将在下面解释梯度是什么)。这里每个梯度变量都是对应参数变量的同维矩阵。例如，由于<strong class="ih hj"> weights_1 </strong>是1×2矩阵，所以<strong class="ih hj"> grad_weights_1 </strong>也是1×2矩阵。</p><ol class=""><li id="69f2" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated"><strong class="ih hj"> grad_weights_1 </strong> : 1 X 2矩阵。从输入到图层1的2个权重的渐变</li><li id="ae55" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">grad _ bias _ 1:1 x2矩阵。从输入到层1的2个偏差的梯度</li><li id="4f1d" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated"><strong class="ih hj"> grad_weights_2 </strong> : 2 X 1矩阵。从层1到输出的2个权重的渐变</li><li id="d591" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated"><strong class="ih hj">grad _ bias _ 2</strong>:1 X 1矩阵。从层1到输出的1偏差梯度</li></ol><p id="69d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过向后调用来获取这些值，但这需要:</p><ol class=""><li id="9eff" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated"><strong class="ih hj">输出1 </strong>:层1的输出</li><li id="9074" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated"><strong class="ih hj">输出2 </strong>:层2的输出。最终预测的华氏温度值。</li></ol><p id="629b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了得到这些值，我们需要用摄氏温度值和相应的实际华氏温度值向前运行。</p><p id="0e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前进()</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es kq"><img src="../Images/b12acde31d4e5c636bc418a981f7efa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcrQ5IyqAWs_AXJCnGB8sg.png"/></div></div></figure><p id="1c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，这里的<strong class="ih hj"> <em class="js">摄氏度值</em> </strong>和<strong class="ih hj"> <em class="js">华氏度值</em> </strong>是100行的矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kr"><img src="../Images/d9cf644c28380dd66d84f75b4881e0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*j75kisLTCjikCm0fq5AvmA.png"/></div></figure><p id="d54e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行第24行后，对于<strong class="ih hj"><em class="js"/></strong>中的一个元素，比如说<strong class="ih hj"> 42.92929 </strong>，output1将包含2个数字:</p><p id="254d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">output 1[0]=<strong class="ih hj">42.92929</strong>* weight 1[0]+biases 1[0]</p><p id="027b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">output 1[1]=<strong class="ih hj">42.92929</strong>* weight 1[1]+biases 1[1]</p><p id="be40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以对于<strong class="ih hj"><em class="js">celsius _ values</em></strong>中的100个元素，output1基本上会是一个100 X 2的矩阵，我们可以用代码中所示的点积和矩阵加法来计算。</p><p id="664c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第25行也在做同样的操作，但是这里的输入是前一层的输出(output1)。</p><p id="7dd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第26行是使用均方误差(MSE)损失函数计算损失，这只是所有差异的平方除以样本数(本例中为100)的一个花哨名称。</p><blockquote class="jv jw jx"><p id="4d5a" class="if ig js ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">小损失意味着更好的预测。如果您在每次迭代中保持打印损失，您将看到它随着训练的进展而减少。</p></blockquote><p id="c6f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，在第27行，我们返回这些值。</p><p id="ec18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">向后</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ks"><img src="../Images/d619d11d98caced694797d0c232be321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*6HB91B6vgTtmKI9Qe295ag.png"/></div></figure><p id="629d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在事情会变得很混乱。如果你需要的话，喝杯咖啡，给我你的全部注意力。</p><p id="d694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，我们只对更新我们的权重和偏好感兴趣。为了更新这些值，我们必须知道它们的梯度，这就是我们在这里计算的——这是这个<strong class="ih hj"> <em class="js">向后</em> </strong>函数的唯一原因，也可能是写整篇文章的唯一原因。</p><p id="a23c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，梯度是以相反的顺序计算的(首先计算最后一层)，因此得名“反向传播”。原因是，为了计算一个层中的渐变，我们需要来自下一层的一些信息——以便我们可以在<strong class="ih hj"> <em class="js">链规则</em> </strong>公式中使用它们。</p><p id="efb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看什么是梯度和链式法则。</p><p id="d8a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="js">渐变</em> </strong></p><p id="b49c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，考虑我们只有一个值<strong class="ih hj"> <em class="js">摄氏度_数值</em> </strong>和<strong class="ih hj"> <em class="js">华氏度_数值</em> </strong>、<strong class="ih hj"> 42.92929 </strong>和<strong class="ih hj"> 109.27273 </strong>。</p><p id="3f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果你拿一张纸，把计算结果分解到第26行，你会发现:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kt"><img src="../Images/181c0b9eaa93e38a23d32c694d64d5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*-hysfUekGFdqta_sbasdtA.png"/></div></figure><p id="2e55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，损耗取决于7个参数。现在只考虑一个参数—第一层的第一个权重。在代码中是<strong class="ih hj"><em class="js">weights 1【0】【0】</em></strong>。想象一下，我们用一个随机值初始化它，比如说0.8，对上面的等式求值后得到123.45作为<strong class="ih hj"> <em class="js">损失</em> </strong>的值。根据这个损失值，您必须决定如何更新权重1[0][0]。你应该把它设为0.9，还是0.7？</p><p id="ae48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您必须以某种方式更新weights1[0][0]，以便在下一次迭代中获得更低的损失值(记住，最小化损失是最终目标)。因此，如果增加权重1[0][0]会增加损失，我们会减少损失。如果增加重量1[0][0]减少损失，我们将增加它。</p><p id="bf28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在的问题是，我们如何知道增加重量1[0][0]会增加还是减少损失。<strong class="ih hj">这就是</strong>中渐变的来源。广义上讲，梯度是用导数来定义的。还记得你高中的微积分吗，∂y/∂x(它是y相对于x的偏导数/梯度)指出了y将如何随着x的微小变化而变化</p><p id="e874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果∂y/∂x是正的，这意味着x的小增量将增加y</p><p id="5a02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果∂y/∂x是负的，这意味着x的一个小增量将减少y</p><p id="cf3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果∂y/∂x很大，x的小变化会引起y的大变化</p><p id="95bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果∂y/∂x很小，x的微小变化会引起y的微小变化</p><p id="68b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，从梯度中，我们得到两个信息。参数必须向哪个方向更新(增加或减少)以及更新多少(大或小)。</p><p id="83e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="js">链式法则</em> </strong></p><p id="57f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非正式地说，链式法则说:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/69b9063986e1ad1542b455ae9563dcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*iXhJz3qzXPh4r6UaZI0liQ.png"/></div></figure><p id="022c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者让我们更进一步，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kv"><img src="../Images/03adfda336eea1cffc365d91eb4684d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*Y53eeeCsjMzcJvFkYB48tA.png"/></div></figure><p id="e1d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看——为什么叫链式法则？</p><p id="0e8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑上面的<strong class="ih hj"> <em class="js">权重1[0][0] </em> </strong>的例子。我们需要计算<strong class="ih hj"><em class="js">grad _ weights _ 1[0][0]</em></strong>来更新该权重，其计算方法如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/0ef5c6190dfe6da924f83fc1bfa0e596.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*jo0EqxImKC9K5KYHTRwEFg.png"/></div></figure><p id="8653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用链式法则公式，我们可以推导出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/91f3358b700c6c71ca0941e3a4827195.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*Gp5WFtFEPY2KFcrSoR3xrg.png"/></div></figure><p id="a202" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们分解所有7个参数的所有梯度，并绘制一个依赖关系图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ky"><img src="../Images/8fd246d4dcc77a74a79b74780c14fe5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-IokT_bHvW4Osk8Mq6jWg.png"/></div></div></figure><p id="cb0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你不需要遵循这里的所有方框。</strong></p><p id="a860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只对蓝框感兴趣，它是参数的梯度。我们只需要计算其他盒子来评估这7个盒子。请注意几个有趣的方面:</p><ol class=""><li id="41c5" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">为了计算一个层中一个参数的梯度(例如<strong class="ih hj">∂loss/∂weights[0][0】</strong>，我们只需要两个信息:<br/> (a)该层的产量相对于该参数的导数(<strong class="ih hj">【∂output1/∂weights[0][0】</strong>)<br/>)(b)损耗相对于该层产量的导数(<strong class="ih hj"> ∂loss / ∂output1 </strong>)</li><li id="0792" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">为了计算一个层的输出梯度(<strong class="ih hj"> ∂loss / ∂output1 </strong>)，我们需要所有后续层的输出梯度(本例中为<strong class="ih hj"> ∂loss/∂output2 </strong>)。这意味着这里所有的梯度计算都依赖于最后一层输出的梯度。这就是为什么我们在backpass(第31行)中首先计算∂loss/∂output2。</li><li id="dbc8" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">参数的渐变不依赖于前一层的任何东西。例如<strong class="ih hj"> ∂ loss/∂权重2[0][0] </strong>不依赖于<strong class="ih hj"> ∂loss/∂output1.</strong></li><li id="3774" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">参数的渐变不依赖于任何图层上的任何其他参数(或任何其他参数的渐变)。例如，<strong class="ih hj"> ∂损失/∂权重[0][0] </strong>不依赖于<strong class="ih hj">权重2[0][0]，或者∂loss /∂weights2[0][0]).</strong></li><li id="2bd4" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">因此，从这些观察中，我们理解，在回传期间，在每一层，我们计算输出梯度(对于这个例子，<strong class="ih hj"> ∂loss / ∂output2 </strong>)有两个可能的原因:<br/> (a)计算这个层上参数的梯度，对于这个例子意味着:<br/> <strong class="ih hj"> ∂损耗/ ∂权重2[0][0]，<br/> ∂损耗/∂权重2[1][0]， </strong>和<strong class="ih hj"> <br/> ∂损失/ ∂偏置2[0][0] <br/> </strong> (b)将此梯度(<strong class="ih hj"> ∂loss /∂output2 </strong>)传递到前一层，以用于链规则来计算该层上参数的梯度(在此情况下为权重1[0][0]、权重1[0][1]、偏置1[0][0]和偏置1[0][1])。</li></ol><blockquote class="jv jw jx"><p id="55aa" class="if ig js ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">在高级ML框架中，例如在PyTorch中，您不必为backpass编写代码！在前进过程中，它创建计算图形，在后退过程中，它在图形中沿相反方向前进，并使用链规则计算梯度。</p></blockquote><p id="6474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ∂损失/ ∂产出2 </strong></p><p id="7e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在代码中通过<strong class="ih hj"> grad_output2 </strong>定义这个变量，正如你在第31行看到的，它是这样计算的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/fc71a93079608477adee0afccf04fa2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*AZPFbxi3NR4JhfF5VjMgow.png"/></div></figure><p id="2f38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们找出公式背后的原因。</p><p id="b3d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，我们将所有100个<strong class="ih hj">摄氏温度值</strong>一起输入到机器中。因此，grad_output2将是一个100 X 1的矩阵，每个元素包含对应于<strong class="ih hj"> celsius_values </strong>中元素的output2的梯度。为了简单起见，让我们考虑一下，在<strong class="ih hj">摄氏_值中只有2项。</strong></p><p id="278a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，分解第26行，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/2af45136cb0decb7bac79fe01b1ff89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*WDhrsHNzJOfo3--QhfBVXw.png"/></div></figure><p id="acfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里，</p><p id="36ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">output2_1 =第一摄氏度值的output2值</p><p id="57a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">output2_2 =第二摄氏度值的output2值</p><p id="91a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fahreinheit_values_1 =第一摄氏度值的实际fahreinheit值</p><p id="99d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fahreinheit_values_1 =第二摄氏度值的实际fahreinheit值</p><p id="5d5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，结果变量<strong class="ih hj"> <em class="js"> grad_output2 </em> </strong>将包含2个值output2 _ 1和output2_2的梯度，意思是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/0ec4d18f4bd746255fa33a535d34a978.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*qCxGL_UTgF45QkOuJikbjA.png"/></div></figure><p id="ae8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们只计算output_2_1的梯度，然后我们可以对其他的应用相同的规则。</p><p id="428e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微积分时间！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lc"><img src="../Images/20fd1649cf61abcb9ee9f7b9c6965100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9CixBWbMRZhzN0_M7-i_Q.png"/></div></div></figure><p id="eabd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与第31行相同</p><p id="1677" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二层权重的梯度</strong></p><p id="1caa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们计算第二层第一个重量的梯度</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ld"><img src="../Images/48b8b66ac58acced82f195514cc372f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAdBVEGCjcnHW9QybOuQRA.png"/></div></div></figure><p id="82a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与第32行相同。请注意，在点积之后，对于每个权重，100个输入值中的每一个的梯度值被相加，这是可以的，因为我们在更新参数之前将所有梯度乘以一个小因子(参见最后一节更新参数)。</p><p id="c4b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二层偏压梯度</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es le"><img src="../Images/a6383f343de5e9249a25b4f27e022239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-QrE2I1Zwpdzr4_cWwM0g.png"/></div></div></figure><p id="f51a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与第33行相同。像重量梯度一样，对100个输入中的每一个的这些值进行求和。同样，这很好，因为梯度在更新参数前乘以一个小系数(见最后一节<strong class="ih hj">更新参数)</strong>。</p><p id="8144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一层权重的梯度</strong></p><p id="86d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们计算第一层中第一个权重的梯度</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lf"><img src="../Images/aef757ef9ff6bcfb4b3e312a6177efa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsVU-q7senrQGqgHZqobCQ.png"/></div></div></figure><p id="c701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它看起来不像36号线吗？在代码<strong class="ih hj"> <em class="js">中，grad_output1 </em> </strong>是一个表示隐含层2个输出的梯度的矩阵，上式中的<strong class="ih hj"> <em class="js"> grad_output1_1 </em> </strong>是它的第一个元素——意味着隐含层中第一个神经元的梯度。我们来评价一下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lg"><img src="../Images/023a6ace69445e4bc122ef731708777b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GS3u-qXqaWSh2sTiLaDTA.png"/></div></div></figure><p id="0c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与第35行相同。在那一行中，在矩阵点积的帮助下，在一个操作中计算隐藏层中所有2个神经元的输出的所有梯度。</p><p id="b5fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一层偏压梯度</strong></p><p id="4a07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来计算第一层第一偏置的梯度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lf"><img src="../Images/84fcaa1c750865762dabf3cdf06a94ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ1_5o2OKpvCvyi8zaOqzg.png"/></div></div></figure><p id="e341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式中的grad_output_1_1是隐含层(第一层)中第一个神经元输出的梯度。因此，对于每个偏置，梯度等于相应神经元输出的梯度——写在代码的第37行。看上面——同样的事情也适用于输出层的偏差！</p><p id="aba1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新参数</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lh"><img src="../Images/0d13ab3670490056f621c867bef1dff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYrOZq3ygaK6eAdv6nszOg.png"/></div></div></figure><p id="769d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们正在更新参数。请注意，梯度在减去之前会乘以一个小因子(LEARNING_RATE ),以使训练稳定。LEARNING_RATE的大值将导致<strong class="ih hj"> <em class="js">过冲</em> </strong>问题，而极小的值将使训练变慢，这可能需要更多的迭代。我们应该通过反复试验找到它的最佳值。这里有很多在线资源，包括这个<a class="ae jd" href="https://noobest.medium.com/but-why-is-this-learning-rate-in-gradient-descent-279fd991a1ae" rel="noopener">和一个</a>来了解更多关于学习率的信息。</p><p id="83a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们调整的确切数量并不重要。例如，如果您稍微调整LEARNING_RATE，<strong class="ih hj"><em class="js"/></strong>变量(第45–48行)将会改变，但机器可能仍然工作。重要的是确保这些数量是通过用相同的因子(在这种情况下是LEARNING_RATE)缩小梯度而得到的。换句话说，“保持<strong class="ih hj"> <em class="js">下降</em> </strong>的渐变比例”比“它们<strong class="ih hj"> <em class="js">下降</em> </strong>多少”更重要。</p><p id="891d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意，这些梯度值实际上是为100个输入中的每一个评估的梯度的总和。但是因为这些是用相同的值缩放的，所以如上所述是好的。</p><blockquote class="jv jw jx"><p id="2f22" class="if ig js ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">为了更新参数，我们必须用global关键字声明它们(在第43行)。</p></blockquote><p id="7a06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何去何从</strong></p><p id="d06e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在看这篇文章之前对反向传播没有一个清晰的认识，看完之后如果你觉得你什么都懂了，那你肯定错了。要实现反向传播是不可能的，直到你自己运行代码，跟踪变量，你现在应该在做的事情。</p><p id="12fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何问题-请留下评论。我一定会解决这个问题。</p></div></div>    
</body>
</html>
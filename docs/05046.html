<html>
<head>
<title>Deploy to Google App Engine using GitHub Actions (CI/CD)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作(CI/CD)部署到Google App Engine</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/deploy-to-google-app-engine-using-github-actions-ci-cd-f25d4c965fbc?source=collection_archive---------2-----------------------#2021-07-08">https://medium.com/geekculture/deploy-to-google-app-engine-using-github-actions-ci-cd-f25d4c965fbc?source=collection_archive---------2-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="844e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">持续集成和持续部署(CI/CD)是MLOps(数据版本控制)的核心，我们将看看如何使用Google App Engine和GitHub Actions来实现这一点。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d6e41fb4e207ada43c37aa695cc242ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1w_6BuihTuUKpLcX7LLOg.png"/></div></div></figure><h2 id="42b8" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">介绍</h2><p id="8a98" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">作为个人项目的一部分，我使用Data Studio构建了一个仪表板，其中包含来自Big Query的数据，这些数据由应用引擎中托管的python代码填充。使用<code class="du la lb lc ld b">dvc</code>的数据版本控制将一些原始数据文件、配置和ML模型保存在云存储中。</p><p id="1df6" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">下面是我用<code class="du la lb lc ld b">dvc</code>详细了解数据版本控制的帖子——关于如何设置和使用谷歌云存储。有实际例子的详细指南。</p><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/geekculture/data-version-control-dvc-with-google-cloud-storage-and-python-for-ml-fe99dc7d338"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hj fi z dy lr ea eb ls ed ef hh bi translated">使用Google云存储和Python进行ML的数据版本控制(DVC)</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">数据版本控制是一个即将到来的领域，需要更快地实现机器学习迭代，而且仍然…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jh lm"/></div></div></a></div><p id="25ff" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">回到我的python代码——它从互联网的各种API中提取数据，使用云存储中存储的配置和模型处理和分析数据，然后将最终数据存储在大查询数据集和云存储文件中。并且代码基于AppEngine cron作业每天运行。</p><p id="89a2" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">这构成了我的应用程序/项目，它使用各种GCP组件无缝运行(顺便说一下，我在GCP上免费运行了近一个月，因为一切都是免费的——不是免费试用)。但整个设置中唯一缺少的部分是——当我将代码推送到GitHub时，它必须将新版本的代码推送到App Engine，这将完成DevOps的CI/CD阶段(在我们的示例中为MLOps)。</p><h2 id="b266" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">具有GitHub操作的CI/CD</h2><p id="dd99" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">我的git存储库中有两个分支——<code class="du la lb lc ld b">main</code>和<code class="du la lb lc ld b">develop</code>——我使用<code class="du la lb lc ld b">develop</code>来构建或调整模型，然后使用<code class="du la lb lc ld b">dvc</code>将最终的模型推送到云存储中。所以我也有以前版本的模型——如果我将来需要检索来比较结果的话。</p><p id="37e3" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">一旦我对模型结果感到满意，我将把<code class="du la lb lc ld b">develop</code>合并到<code class="du la lb lc ld b">main</code>分支(我们也可以做一个拉请求，但是我是这个项目的唯一开发者)。然后使用Google Cloud SDK从本地计算机单独将代码推送到GAE。</p><p id="7a7a" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">因此，我们的想法是在使用任何CI/CD工具向<code class="du la lb lc ld b">main</code>分支提交变更时，自动向GAE部署。为了简单起见，我选择了GitHub操作，但是也可以使用GitLab / Jenkins / …本文将解释使用GitHub操作的CI/CD。</p><p id="7014" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">下面是我的<code class="du la lb lc ld b">app.yaml</code>和<code class="du la lb lc ld b">cron.yaml</code>部署到谷歌应用引擎(GAE)的要点，我用来从本地计算机部署，我们将在GitHub操作中使用它。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3e5f" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">现在在<code class="du la lb lc ld b">.github/workflows/main.yml</code>中创建一个文件来配置GitHub动作，将我们的代码部署到GAE的push to <code class="du la lb lc ld b">main</code>分支。以上是配置的要点。这是一种不言自明的，但我花了一些时间来设置它，因为在互联网上没有清晰的文档，我不得不混合不同的部分，以获得大量失败的GitHub工作流的配置。</p><p id="6eda" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">这个动作有一个名称，然后是什么触发了这个动作——对主分支的推/拉请求。然后是需要在触发器上运行的作业—只有部署，我们也可以有更多的作业。然后它在最新的ubuntu上运行，步骤如下</p><ol class=""><li id="f878" class="md me hi kj b kk le kn lf ju mf jy mg kc mh kz mi mj mk ml bi translated">使用<code class="du la lb lc ld b">actions/checkout@v2</code>检查最新的代码库</li><li id="e134" class="md me hi kj b kk mm kn mn ju mo jy mp kc mq kz mi mj mk ml bi translated">使用<code class="du la lb lc ld b">google-github-actions/deploy-appengine@v0.2.0</code>将代码部署到应用引擎</li><li id="d2f7" class="md me hi kj b kk mm kn mn ju mo jy mp kc mq kz mi mj mk ml bi translated">通过运行<code class="du la lb lc ld b">curl</code>命令来测试应用程序是否已经成功部署</li></ol><p id="2480" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">在步骤2中，GitHub操作需要一些额外的参数来正确部署。</p><ol class=""><li id="d8ea" class="md me hi kj b kk le kn lf ju mf jy mg kc mh kz mi mj mk ml bi translated">交付件—部署时需要用到的东西。在大多数情况下，应该是<code class="du la lb lc ld b">app.yaml</code>，但是在我的例子中，我也在调度一个批处理作业，因为我使用了<code class="du la lb lc ld b">app.yaml cron.yaml</code></li><li id="104b" class="md me hi kj b kk mm kn mn ju mo jy mp kc mq kz mi mj mk ml bi translated">版本—(可选)这是要在App Engine中使用的版本。如果未使用，应用程序引擎将创建一个带有当前时间戳的版本。</li><li id="c9ae" class="md me hi kj b kk mm kn mn ju mo jy mp kc mq kz mi mj mk ml bi translated">project _ id——这是必需的，这样GitHub操作才能部署到正确的项目</li><li id="a755" class="md me hi kj b kk mm kn mn ju mo jy mp kc mq kz mi mj mk ml bi translated">凭据—我们从GCP下载的服务帐户API密钥文件中的json内容。</li></ol><p id="06bd" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">为了增加安全性，我们可以添加project_id和凭证作为GitHub机密，并在这里使用它们。要添加GitHub机密，请进入项目报告设置&gt;机密&gt;添加机密。复制服务帐户的JSON文件内容，并将其作为凭证粘贴。</p><p id="04a8" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">上面的配置类似于我们用来从本地计算机部署的<code class="du la lb lc ld b">gcloud</code>命令，除了凭证被存储并作为<code class="du la lb lc ld b">GOOGLE_APPLICATION_CREDENTIALS</code>添加到PATH中。</p><pre class="iy iz ja jb fd mr ld ms mt aw mu bi"><span id="5133" class="jj jk hi ld b fi mv mw l mx my">gcloud app deploy app.yaml cron.yaml --version=v1 --project=&lt;project-id&gt;</span></pre><p id="3f07" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lg kr ks jy lh ku kv kc li kx ky kz hb bi translated">下面是将codebase部署到GAE的GitHub操作的成功完成。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/f4e6f7810b5bfba59ff18e45d337205d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK6CYWwnmn7yW_dRAvnzMA.png"/></div></div></figure><h2 id="fe3a" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">结论</h2><p id="2afd" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">CI/CD管道是DevOps的重要组成部分(与MLOps一样),用于简化和自动化部署流程。我们已经使用GitHub Actions将我们的项目自动部署到Google App Engine，将代码推送到特定的分支。有了这个CI/CD管道，我们可以更加关注项目的核心功能——软件开发或者模型构建。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Tao of React — Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应之道——项目结构</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/tao-of-react-project-structure-8579708c751a?source=collection_archive---------0-----------------------#2020-11-15">https://medium.com/geekculture/tao-of-react-project-structure-8579708c751a?source=collection_archive---------0-----------------------#2020-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我记得当我第一次开始钻研它的时候，我被它如何完全改变了web应用程序开发的游戏惊呆了。</p><p id="1f95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配备一个<strong class="ih hj">小</strong> API，让一个<strong class="ih hj">快速</strong>掌握它。我很快开始参加黑客马拉松，这是我以前从未做过的事情，并且一直排在前三名，这是我的武器库中的新武器。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cf1c2dc9e51a9565b44bd295c93dc06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*BkJZTJlOVFY2f6QogoxZsQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Tao can loosely translate as “The Way”</figcaption></figure><p id="ee39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多不同的方式来构建react应用程序，我喜欢这种自由，但这也使它成为一把双刃剑，因为它是如此的不独立。</p><p id="fdf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我<strong class="ih hj">不是</strong>声称这里解释的结构优于其他方法，但它只是一种简单的<strong class="ih hj"> <em class="jp">方法</em> </strong> <em class="jp"> </em>，我发现在构建应用程序时，它是非常<strong class="ih hj">可扩展的</strong>，尤其是在处理同一个项目中的<strong class="ih hj">多个团队成员</strong>时。</p><blockquote class="jq jr js"><p id="58fe" class="if ig jp ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">这篇文章将解释一个你可以应用的方法，一个模板，如果你愿意，你可以塑造它来满足你的需要。因为没有针对每个项目的明确的“一刀切”的解决方案。</p></blockquote></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h1 id="ba38" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">现实与期望</h1><p id="0904" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">网上的大多数指南在谈到反应时，都会描述它的<strong class="ih hj">特性</strong>，以及如何<strong class="ih hj">利用</strong>它们。我没有在网上看到很多深入的指南，关于如何在创建一个你计划<strong class="ih hj">扩展</strong>的<strong class="ih hj">现实世界</strong>应用时应用它。</p><p id="3f72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数指南遵循一种方法，即完全基于"<strong class="ih hj">文件类型</strong>来组织文件。"当您的应用程序在您知道它之前开始增长时，您留下的是一个<strong class="ih hj">难以管理的应用程序</strong>，尤其是有<strong class="ih hj">多个</strong>团队成员和特性的应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/ef08b9548c7752c4873d13eeecdd75ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_77xGTBZdER2ibfW.jpg"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Application structures can quickly get out of hand</figcaption></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h1 id="529c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">让文件夹来说话</h1><p id="405e" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">我喜欢遵循一种"<strong class="ih hj">基于特征的"</strong>方法。</p><p id="e314" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们写代码时，我们是在写一个<strong class="ih hj">故事</strong>，就像我们用其他语言写一样。我坚信同样的方法可以应用于应用程序的构造方式。</p><p id="5a55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还做了一个<strong class="ih hj">样例</strong> Github repo，可以作为<strong class="ih hj">参考</strong><a class="ae ll" href="https://github.com/xXValhallaCoderXx/tao-react-app-structure" rel="noopener ugc nofollow" target="_blank">https://Github . com/xXValhallaCoderXx/Tao-react-app-structure</a></p><blockquote class="jq jr js"><p id="041a" class="if ig jp ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">看应用结构，应该能明白是什么样的应用。</strong></p></blockquote><p id="2eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个高级示例，让我们看看下面的结构</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="1524" class="lr ke hi ln b fi ls lt l lu lv">/src<br/>    index.js<br/>    root-routes.js (Top level routes)<br/>    /pages<br/>        /profile<br/>        /products<br/>            index.js (Nested Routes for Products)<br/>            /detail<br/>                index.js (Container for Detail)<br/>                Detail.js<br/>           /list<br/>               index.js (Container for List)<br/>               List.js<br/>               ComponentA.js<br/>    /shared<br/>        /styles<br/>        /utils<br/>        /components<br/>            /atoms<br/>            /molecules<br/>            /organisms<br/>        /templates</span></pre><blockquote class="jq jr js"><p id="b9a4" class="if ig jp ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">这大概是你的项目应该嵌套的部分，下面我们将对每个部分做一个简要的分析。</p></blockquote><h2 id="03c8" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak"> index.js </strong></h2><p id="4635" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">只是您的标准入口点，以连接React到DOM并导入您的应用程序所需的任何文件。</p><h2 id="1239" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak"> root-routes.js </strong></h2><p id="e55f" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">顶层路由是在你的应用程序中定义的，<br/>这个文件<strong class="ih hj">不需要</strong>所有底层嵌套路由的上下文。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="8ac1" class="lr ke hi ln b fi ls lt l lu lv">&lt;Route&gt;<br/>  &lt;Switch&gt;<br/>    &lt;Route path="/profile" component={Profile}/&gt;<br/>    &lt;Route path="/products" component={Products} /&gt;<br/>  &lt;/Switch&gt;<br/>&lt;/Route&gt;</span></pre><h2 id="02e8" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/页面/产品/索引. js </strong></h2><p id="575f" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在这些文件中，我们将为应用程序的每个页面或特性提供<strong class="ih hj">嵌套路由</strong>。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="0bf3" class="lr ke hi ln b fi ls lt l lu lv">&lt;Switch&gt;<br/>  &lt;Route eaxct path="/products" component={List}/&gt;<br/>  &lt;Route exact path="/products/:id" component={Detail} /&gt;<br/>&lt;/Switch&gt;</span></pre><h2 id="ba07" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/页面/产品/列表/索引. js </strong></h2><p id="e869" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在大型应用程序中，您很可能会使用某种形式的状态管理，如Context API、Redux、Mobx等。无论您选择使用哪种方法，都应该保持<strong class="ih hj">与应用程序的视图层</strong>分离。</p><p id="92fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将这些文件视为我们的<strong class="ih hj"> <em class="jp">【容器】</em> </strong>组件，它将<strong class="ih hj">将</strong>连接到我们正在使用的任何状态管理，<strong class="ih hj">准备</strong><strong class="ih hj">数据</strong>，以及所需的<strong class="ih hj">功能，并将其向下传递到<strong class="ih hj">表示层</strong>。</strong></p><p id="91c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将来，如果你曾经<strong class="ih hj">改变</strong>状态管理库，大部分的<strong class="ih hj">重构</strong>将会在<strong class="ih hj">应用程序的这一部分</strong>中。只要同样的道具传下来，你的表示层就不会受到影响。</p><h2 id="d200" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/页面/产品/列表/列表. js </strong></h2><p id="5258" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">作为一种命名惯例，我喜欢将每个“特性”的“<strong class="ih hj">顶层</strong> l”表示层命名为特性本身。允许轻松辨别<strong class="ih hj">容器</strong>和根<strong class="ih hj">呈现</strong>层之间的<strong class="ih hj">差异</strong>。</p><p id="c28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个文件可以使用一个模板组件，允许应用程序之间的一致性，特别是如果有许多相似的不同页面。</p><h2 id="f7e2" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/页面/产品/列表/组件A.js </strong></h2><p id="5021" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">您可能仍然希望将表示层分成小的组件，因此您仍然可以在应用程序的这一部分中添加特定于功能的组件。</p><p id="6e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong> <br/>在更大的特性中可能需要将这个ComponentA.js放入它自己的文件夹中，并作为一个容器连接到一个商店，如果它使你的应用程序更容易管理，没有什么可以阻止你这样做。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h1 id="075c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">共享文件夹</h1><p id="bda5" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">这个文件夹是我们保存文件的地方，这些文件可能会在应用程序的多个部分中使用，比如样式、实用程序甚至是我们的存储状态片段。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mj"><img src="../Images/3097a3040dc69b61b734c85dd846ec79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PCSNYT_BKqSgH_Ek.jpg"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Be nice — let others know where to find you</figcaption></figure><h2 id="7f91" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/共享/风格</strong></h2><p id="497a" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">这一部分应该是不言自明的，你所有的全局样式表都将是活的，SCSS混合等。</p><h2 id="d493" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/共享/实用工具</strong></h2><p id="f562" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">实用函数可以放在这个文件夹中，我们可以在这里进行解析、验证、包装库等等。</p><h2 id="8468" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/共享/组件</strong></h2><p id="2285" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">可重复使用的组件保存在这里。当涉及到构建组件时，我喜欢使用Brad Frosts的原子设计方法。如果这个教程得到了很好的反馈，我可能会写一篇续篇，讲述我如何将它融入到我的应用程序中。</p><h2 id="3dbf" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/共享/模板</strong></h2><p id="fb94" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">模板组件将位于该文件夹中，例如，如果每个页面都在顶部使用导航栏，您可以有一个“主”布局，或者如果您的编辑页面具有与您的应用程序一致的特定设计，“编辑”布局将位于此处。</p><p id="2f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我喜欢在构建模板组件时使用<strong class="ih hj">复合模式</strong>，我觉得它允许在使用组件时有更多的灵活性，比如改变某些东西呈现的顺序，但仍然保持UI所需的一致性。</p><h2 id="224b" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated"><strong class="ak">/共享/切片</strong></h2><p id="3c96" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">“<strong class="ih hj">切片</strong>是我们在整个应用程序中共享的应用程序状态的部分，所有的<strong class="ih hj">业务逻辑</strong>、访问<strong class="ih hj">的方式</strong>、<strong class="ih hj">状态</strong>都将存在于这个部分中。</p><p id="4727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将使用Redux作为我的状态管理的例子，但是您可以<strong class="ih hj">将</strong>与<strong class="ih hj">相同的原则</strong>应用于您喜欢的任何其他形式的状态管理。</p><p id="1d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下例所示，<br/>用户片将存储关于登录用户的所有数据，提供选择器通过应用程序访问该状态，并提供sagas处理API调用以获取或编辑与用户相关的数据。</p><p id="f96a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于toast切片，尤其是使用单例模式时，控制Toast通知的所有逻辑都将位于共享文件夹中。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="09b7" class="lr ke hi ln b fi ls lt l lu lv">/shared/slice<br/>    /user<br/>       /index.js - Barrel file to export relevant methods<br/>       /selectors.js - State selectors (permissions, roles, info)<br/>       /actions.js - Actions to trigger in the application<br/>       /reducer.js - Store reducer to deal with user state<br/>       /saga.js - Business logic related to user<br/>    /toast<br/>       /index.js<br/>       /selectors.js - Get toast notifcation state (open / closeed)<br/>       /actions.js - Actions to control the toast notification<br/>       /reducer.js</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/9e7b9ac42bfc59894a9cab8023faa3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*2a7g-M6G8wN9Nzjy.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Just like the Yin Yang — We keep our application layers separate, mixing a bit of each layer</figcaption></figure><p id="d80a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong></p><p id="6244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从一个API接收到数据时，我喜欢把它直接放入reducer，我使用选择器来解析数据。</p><p id="11af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是在应用程序的不同部分，相同的数据可能需要以不同的方式使用<strong class="ih hj"/>。所以我们应该保持从API接收的数据格式，然后<strong class="ih hj">使用适当命名的选择器</strong>解析数据，并用于在<strong class="ih hj">表示层</strong>显示数据。</p><blockquote class="jq jr js"><p id="0329" class="if ig jp ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">应用程序的UI层及其大部分业务逻辑应该与您选择使用的状态管理库无关。</p></blockquote><h2 id="c494" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated">GQL呢？</h2><p id="4187" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">随着GQL也变得越来越流行，方法仍然是一样的，您将在您的<strong class="ih hj">容器(index.js) </strong>文件中为每个<strong class="ih hj">特性</strong>获取数据。</p><p id="8414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些GQL模式可以存在于您各自的特性<strong class="ih hj">“切片”</strong>文件夹中，如果它们是特定于特性本身的，或者如果它是将在多个地方使用的东西，您可以将它们放在适当的<strong class="ih hj">“切片”</strong>文件夹中，这些文件夹存在于<strong class="ih hj">共享</strong>文件夹中。</p><p id="7f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，只要你保持数据向下传递到你的表示层<strong class="ih hj">相同</strong>，你就必须做<strong class="ih hj">最小的重构。</strong>例如，如果您正在<strong class="ih hj">将您的API调用从<strong class="ih hj"> Redux </strong>切换到由<strong class="ih hj"> GQL </strong>处理，并且可以随着时间的推移</strong>慢慢完成这个迁移<strong class="ih hj">。</strong></p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h2 id="3605" class="lr ke hi bd kf lw lx ly kj lz ma mb kn iq mc md kr iu me mf kv iy mg mh kz mi bi translated">这是所有的乡亲</h2><p id="b0d3" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">这是一个较高层次的小介绍，介绍了我如何构建React应用程序的规模。</p><p id="9951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个小的<strong class="ih hj">例子</strong>回购<a class="ae ll" href="https://github.com/xXValhallaCoderXx/tao-react-app-structure" rel="noopener ugc nofollow" target="_blank">这里</a>可能有助于一些教程更容易理解和跟随，它只是一个简单的<strong class="ih hj">例子来提供更多的上下文。</strong></p><p id="d56b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据反馈，我可能会继续分享我在使用React期间发现的其他有用的技巧和方法。</p><p id="d43f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢这个指南！</p><p id="929f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保重，祝编码愉快！</p></div></div>    
</body>
</html>
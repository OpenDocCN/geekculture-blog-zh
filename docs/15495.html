<html>
<head>
<title>Why we migrated from Memcached to Redis?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们从Memcached迁移到Redis？</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/why-we-migrated-from-memcached-to-redis-2ecdd21d68d0?source=collection_archive---------1-----------------------#2022-11-04">https://medium.com/geekculture/why-we-migrated-from-memcached-to-redis-2ecdd21d68d0?source=collection_archive---------1-----------------------#2022-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ca2b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="9192" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">很多时候缓存解决方案像Memcached，Redis，Guava等。用于提高数据检索性能。这是通过在缓存层存储一些数据来实现的，从而减少了访问底层较慢的数据存储层的需要。但是缓存还有另一种使用模式，称为“缓存作为数据存储”。在这种模式中，缓存本身被用作主数据存储。这样做通常是为了存储可能有过期时间戳的短暂数据。</p><p id="d292" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Memcached 和<a class="ae kg" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是两种最流行的缓存解决方案。这两者都是由AWS作为完全托管的缓存服务在<a class="ae kg" href="https://aws.amazon.com/elasticache/" rel="noopener ugc nofollow" target="_blank">亚马逊elastic cache</a>下提供的。在本文的其余部分，Memcached和Redis将分别意味着AWS ElastiCache提供Memcached和Redis。</p><p id="cfe4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我们的用例中，我们使用Memcached作为数据存储来存储临时数据。随着系统总负载的增加，我们的Memcached集群开始遇到一些性能问题。我们决定从Memcached迁移到Redis，因为Memcached的架构不支持一些可以帮助减轻这些性能问题的功能。</p><p id="03a9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在接下来的小节中，我们将更深入地探讨我们在使用Memcached时遇到的问题，以及我们如何使用Redis来克服这些问题。</p><h1 id="6e4c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Memcached架构</h1><p id="f8f2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Memcached 是一个内存中的键值存储服务，可以用作缓存或数据存储，并提供亚毫秒级的延迟。</p><p id="7e0c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Memcached支持数据分片，因此允许跨多个节点划分数据，并将负载分布在一个集群中。Memcached集群中的每个节点都是完全独立的，不与其他节点通信。集群不知道数据分区，数据分区的逻辑驻留在客户端。因此，添加或删除碎片会导致缓存未命中，直到客户端根据集群中新的碎片计数重新填充所有碎片。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/ff1bc2b165cf3e5ba5e5ea0b27c4cea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/0*WNiLRNozRogpq8Mg"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Memcached Cluster</figcaption></figure><p id="f0ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Memcached是多线程的，因此它可以利用多个处理核心。这意味着您可以通过提高Memcached集群的计算能力来处理更多的操作。这是一种处理负载增加的好技术，但是它通常受到货币预算的限制。</p><h1 id="f154" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Memcached的缺点</h1><p id="43a4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">虽然Memcached非常强大并且易于使用，但是有两个功能是Memcached不支持的。</p><p id="a257" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，Memcached不提供<strong class="jf hj">分片复制</strong>。一个Memcached集群每个分片只能有一个节点。在没有任何副本节点的情况下，节点故障意味着由该节点处理的整个碎片已经发生故障。</p><p id="86a3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第二个问题是Memcached不支持<strong class="jf hj">在线重分片</strong>。在分布式缓存系统中，键分布在多个碎片上。通过在线重新分片，可以无缝地在集群中添加或删除分片，而不会导致任何停机。集群将优雅地处理所有请求，同时根据新的碎片计数重新分配密钥。但是在没有在线重分片的情况下，分片数量的任何变化都会导致部分停机，直到所有的键被正确地重新分配。</p><h1 id="1e39" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么要迁移到Redis？</h1><p id="1883" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kg" href="https://aws.amazon.com/elasticache/redis/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是一个提供亚毫秒级延迟的内存数据存储。Redis还提供诸如事务、发布/订阅、Lua脚本等功能。Memcached不支持的。Memcached功能较少，设计简单，因此是我们开始时的选择。</p><p id="f346" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的Memcached设置在集群中有多个碎片。每个碎片仅由一个节点组成(无复制)。因此，每个分片的单个节点同时服务于读和写请求。</p><p id="bcdd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">随着业务的增长，读写操作的数量也在增长，导致MemcacheD集群的整体负载增加。随着负载的增加，Memcached集群中的节点偶尔会非常热。解决这种情况的唯一方法是向Memcached集群添加更多的碎片。但是正如我们之前讨论过的，Memcached不支持在线重分片。因此，添加一个新的碎片意味着在所有键被重新分配之前的缓存缺失。因此，我们被迫只能在非高峰流量时段进行这些分片添加，因为我们负担得起维护停机时间。</p><p id="a08e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">随着节点变热并需要向Memcached集群添加新碎片的频率增加，我们开始寻找替代解决方案。这就是Redis的由来。</p><h1 id="84b4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Redis架构</h1><p id="9efb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Redis的ElastiCache允许三种配置，(1) <em class="kt">单节点</em> , (2) <em class="kt">集群模式禁用</em>,( 3)<em class="kt">集群模式启用</em>。下图更详细地解释了这些配置。注意，在<em class="kt">启用集群模式的</em>设置中，Redis的ElastiCache提供了分片复制和在线重分片。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/d7394e02953b6bae6eb091547718fc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cOF5RkY_wNbkvwqu"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Various cluster modes for Redis</figcaption></figure><p id="90f9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于我们的用例，我们决定使用(3) <em class="kt">集群模式支持的</em>模式进行数据复制和分区。这允许我们将数据分布在多个分片上，从而减少了单个分片上的负载。有了数据复制，一个碎片的主节点中的任何故障都可以通过回退到该碎片的副本节点来处理。</p><h1 id="2398" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">redis Java客户端</h1><p id="677f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kg" href="https://github.com/redisson/redisson" rel="noopener ugc nofollow" target="_blank">Redis on</a>和<a class="ae kg" href="https://github.com/redis/jedis" rel="noopener ugc nofollow" target="_blank"> Jedis </a>是Redis最流行的两个Java客户端。</p><p id="2782" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Redisson是Redis上的一个内存数据网格。换句话说，Redisson提供了一个Java原生的对象接口，并将这些对象存储在Redis中。另一方面，Jedis提供了Redis固有的对象接口。</p><p id="a138" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们举一个在Redis中存储键值对的例子。Redisson为此用例提供了RMap对象。RMap对象的接口类似于Java的原生Map对象。在幕后，Redisson将管理RMap对象的键和值，并将它们存储在Redis中。另一方面，Jedis也支持map对象，但使用Redis的原生命令，如“<em class="kt"> SET </em>”、“<em class="kt"> GET </em>”等。因此，用户需要理解Redis命令行语言，以便有效地使用Jedis客户机。</p><h1 id="8864" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">雷迪森诉杰迪斯公司</h1><p id="4f93" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">雷迪森和杰迪斯各有利弊。在我们的用例中，我们希望确保我们的数据被分区和复制，并且客户端支持在线重分片。</p><p id="9c18" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Redisson Java对象与Redis集群兼容，但是它们的状态不会被划分到Redis集群中的多个主节点。Redisson PRO(付费)为其中一些对象提供了数据分区。由于我们不愿意在数据分片上妥协，因此我们没有继续使用Redisson(免费版)。</p><p id="4079" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的下一个选择是杰迪斯。Jedis支持数据分区，允许跨多个分片存储数据。Jedis还支持在<em class="kt">集群模式禁用</em>设置中的读取流量重定向(单个碎片，多个副本)。这允许写操作命中主节点，读操作命中复制副本节点。最后，Jedis支持在集群重划分期间优雅地处理请求。注意，为了充分利用这个特性，您必须在Jedis客户机包装器中编写一些额外的代码。</p><p id="41df" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我们的例子中，我们在<em class="kt">集群模式启用的</em>设置中使用Redis(多个碎片，多个副本)。遗憾的是，Jedis不支持在启用<em class="kt">集群模式的</em>设置中读取重定向到副本节点。但是我们接受这种折衷，因为我们仍然得到了数据分区和在线重分片的好处。因此，我们决定将Jedis客户机用于Redis集群。</p><h1 id="86d8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="6107" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据您的用例，您可以在Redis和Memcached之间做出选择。虽然这不是一个放之四海而皆准的问题，但是一个基本的经验法则是，如果您的用例很简单，就使用Memcached。此外，如果您正在使用Redis，那么您可以根据您对自己的用例所做的权衡，在Redisson和Jedis之间做出选择。</p><h1 id="172e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><ol class=""><li id="3967" class="kz la hi jf b jg jh jk jl jo lb js lc jw ld ka le lf lg lh bi translated"><a class="ae kg" href="https://www.linuxjournal.com/article/7451" rel="noopener ugc nofollow" target="_blank">Brad Fitzpatrick的Memcached分布式缓存</a></li><li id="951e" class="kz la hi jf b jg li jk lj jo lk js ll jw lm ka le lf lg lh bi translated"><a class="ae kg" href="https://aws.amazon.com/blogs/database/work-with-cluster-mode-on-amazon-elasticache-for-redis/" rel="noopener ugc nofollow" target="_blank">如何在亚马逊ElastiCache for Redis上使用集群模式</a></li><li id="19d7" class="kz la hi jf b jg li jk lj jo lk js ll jw lm ka le lf lg lh bi translated"><a class="ae kg" href="https://aws.amazon.com/elasticache/redis-vs-memcached/" rel="noopener ugc nofollow" target="_blank">比较Redis和Memcached </a></li><li id="29cf" class="kz la hi jf b jg li jk lj jo lk js ll jw lm ka le lf lg lh bi translated"><a class="ae kg" href="https://github.com/redisson/redisson/wiki/5.-data-partitioning-(sharding)" rel="noopener ugc nofollow" target="_blank"> Redisson数据分区(分片)</a></li></ol></div></div>    
</body>
</html>
<html>
<head>
<title>Fundamentals of Functional Programming in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程基础</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/functional-programming-in-java-31c9896fa48b?source=collection_archive---------3-----------------------#2021-04-20">https://medium.com/geekculture/functional-programming-in-java-31c9896fa48b?source=collection_archive---------3-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">Java 8 Lambdas基础！</em></p><p id="4215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客旨在解释函数式编程的基础，使用Java 8 lambdas。这个博客假设你没有函数式编程范例的先验知识，但是有面向对象编程的基础知识。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><blockquote class="jl jm jn"><p id="a4f9" class="if ig jd ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">什么是函数式编程。</em> </strong></p></blockquote><p id="979d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jr translated">函数式编程只不过是一种编程风格，它提倡纯函数。对于纯函数，我指的是一段代码，它接受一些输入，执行计算，并给出期望的输出。它没有任何“副作用”或任务，比如打印或操纵其作用域之外的变量。这些函数是<strong class="ih hj">一级</strong>函数，也就是说，它们可以简单地用作值，这些值可以作为变量/参数传递给其他函数。</p><p id="df84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java 8之前，Java不支持这种类型的编程。在Java 8之前，所有的代码块都属于一个类。因此，为了执行像打印问候信息这样简单的功能，我们必须编写一个单独的类来实现这个逻辑。我们不可能有一个孤立的简单函数来实现这个逻辑。随着lambda表达式的引入，这在Java 8中发生了改变。</p><blockquote class="jl jm jn"><p id="ac02" class="if ig jd ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated">当我们已经可以使用主流的面向对象编程做任何我们想做的事情时，为什么我们还需要函数式编程呢？T13】</p></blockquote><p id="888c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数式编程有助于编写清晰简洁的代码，易于维护(在某些情况下)。它允许更容易地使用API和库，并支持利用并行处理的方式。</p><p id="eb01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过比较Java 7和8中遵循的编程方法来尝试理解lambdas提供的优势。我们将看到一个动作如何在Java 7和Java 8中执行。</p><h2 id="2c2c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated"><strong class="ak"><em class="kv">Java 7路——简单OOP </em> </strong></h2><p id="3d3d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">为了在面向对象编程范例中实现一个行为，我们应该有一个如下所示的设置:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lb"><img src="../Images/84f2470d206943d7ab2bd09371cd2393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOGxoSyLPjMc28DIA_VVaw.png"/></div></div></figure><p id="a0dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行接口中声明的活动的类现在必须创建或检索对象(需要其行为的类的实例)，并将其作为参数传递给它的方法，以便执行活动。请参见下面的代码片段:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e4bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里做了什么？</p><ol class=""><li id="53ca" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc lu lv lw lx bi translated">创建了一个界面“MakeBeverage”。这是需要执行的活动。它给出了一个蓝图，活动的行为应该在名为“make”的方法中定义。</li><li id="40ed" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">创建了两个实现接口“MakeBeverage”的实体。这些实体对于活动有它们自己的行为，因此，它们的行为是在它们各自的“make”方法的实现中定义的。这个“make”方法中的代码就是它们的动作。</li><li id="5f77" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">创建了一个名为“BeverageMaker”的executor类，该类有一个方法，要求将活动作为参数。此方法根据作为参数传递的实现活动的实体的实例来执行操作。</li></ol><h2 id="9317" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated"><strong class="ak"><em class="kv">Java 8 way—Lambda表达式</em> </strong></h2><p id="5cdd" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">Java 8引入了lambda表达式，使我们能够编写简洁的代码。这是通过消除创建活动实现(接口)的需要来实现的。我们可以简单地将实体的“动作”存储在一个变量中，并将其作为参数传递给executor类，而不是创建具有不同行为的不同实体。请看下面的代码:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="67a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用executor类“BeverageMakerWithLambda ”,我们不需要实现接口“MakeBeverage”的实体。我们简单地声明了“Action”，即模拟每个实体类作为变量的行为的代码。变量的类型，即活动接口“MakeBeverage”。</p><blockquote class="jl jm jn"><p id="0c5e" class="if ig jd ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated"><strong class="ih hj">Java 7方法和Java 8方法的区别在于，我们没有实现一个完整的类来执行一个独立的动作，而是简单地实现了一个函数。</strong></p></blockquote></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="7a2b" class="md kb hi bd kc me mf mg kg mh mi mj kk mk ml mm kn mn mo mp kq mq mr ms kt mt bi translated"><strong class="ak"> <em class="kv">类型推断</em> </strong></h1><p id="c96b" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">Java 8能够自动推导出Lambda表达式的返回类型，以及传递给表达式的参数类型。这被称为类型推理。这是由java编译器执行的。</p><p id="045e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自动！！怎么会？</strong></p><p id="1bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java将用于创建lambda函数的接口命名为<strong class="ih hj">函数接口</strong>。</p><ul class=""><li id="d7e1" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc mu lv lw lx bi translated">它们内部只能声明一个方法。</li><li id="34bd" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc mu lv lw lx bi translated">当用作用于存储lambda表达式的变量的类型时，java编译器检查接口内抽象方法的返回类型和参数类型，并期望lambda表达式符合相同的条件。</li></ul><p id="0381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的示例中，MakeBeverage接口充当功能接口。</p><h2 id="c677" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">我们是否为每个想要实现的lambda创建了一个功能接口？</h2><p id="a63d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">没有必要创建一个新的函数接口来实现你的lambda逻辑。只有一个方法的现有Java接口可以用于此目的。让我们看一个Runnable接口的例子，它只有一个方法。</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码片段中，Runnable接口是使用匿名内部类方法和lambda方法实现的。可以清楚的看到，在lambdas的情况下，代码是多么的清晰简洁。</p><p id="4166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java提供了一个现成的函数接口包，可以根据代码的输入参数和返回类型需求来实现lambda函数。关于软件包的详细信息，请参考<a class="ae mv" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/function/package-summary . html</a>。</p><p id="8c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这标志着这个博客的结束。Java 8 lambda是一个巨大的主题，有很好的实现来减少Java代码的冗长。使用lambda实现Java流是一个非常有趣的话题，我将在以后的博客中讨论这个话题。</p><p id="e022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">练习是唯一的选择</em> </strong>👍</p><p id="bc61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">查看我的</em><a class="ae mv" href="https://github.com/rgog/TutorialsWorkspace/tree/master/FunctionalProgramming/src" rel="noopener ugc nofollow" target="_blank"><em class="jd">GitHub</em></a><em class="jd">获取本博客及其他项目的代码。</em></p></div></div>    
</body>
</html>
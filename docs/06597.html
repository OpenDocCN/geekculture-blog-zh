<html>
<head>
<title>Optimizing React Native offline mode using Apollo Cache Persist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apollo缓存持久化优化React本机离线模式</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/optimizing-react-native-offline-mode-using-apollo-cache-persist-a7723c7e8416?source=collection_archive---------23-----------------------#2021-08-24">https://medium.com/geekculture/optimizing-react-native-offline-mode-using-apollo-cache-persist-a7723c7e8416?source=collection_archive---------23-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4ca749d813962ee405385a20a9833f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzJP3m353jRh1WXDajX1Lw.jpeg"/></div></div></figure><p id="f20d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">离线模式对于市面上大多数手机app来说都是极其重要的。例如，拥有与旅游、天气、游戏或金融相关应用的不同公司发现，允许用户随时随地访问特定数据至关重要。在这篇博文中，我们将探讨如何使用React Native和Apollo创建无缝的离线体验。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/8affacd1446c3386efcaab158eea1f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1tOm8xfsKQHcirCLtiuJw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Example App linked at the bottom of blog post</figcaption></figure><h2 id="35de" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">背景</h2><p id="ff1f" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在过去，我们已经探索了不同的选择，包括可能是最流行的方法是使用SQLite。这是一个很好的解决方案，但是从额外的配置和需要直接从这个数据库手动读写的角度来看，它可能会变得非常乏味。</p><p id="8b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个取自<a class="ae kx" href="https://github.com/expo/examples/tree/master/with-sqlite" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Expo </strong> </a>的简单todo应用程序示例中，我们需要手动读写初始渲染:</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="a1bf" class="jx jy hi kz b fi ld le l lf lg">useEffect(() =&gt; {   <br/>   db.transaction((tx) =&gt; {<br/>      tx.executeSql("create table if not exists items (id integer       primary key not null, done int, value text);");    <br/>   }); <br/>}, []);</span></pre><p id="7100" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们需要初始化我们的表，如果我们还没有这样做。</p><p id="cee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这同样适用于任何其他需要写入数据库的函数。下面我们来看看添加一个todo。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="eaea" class="jx jy hi kz b fi ld le l lf lg">const add = (text) =&gt; {<br/>   if (text === null || text === "") {<br/>      return false;    <br/>   }     </span><span id="b2bb" class="jx jy hi kz b fi lh le l lf lg">   db.transaction((tx) =&gt; {        <br/>      tx.executeSql("insert into items (done, value) values (0, ?)", [text]);        <br/>      tx.executeSql("select * from items", [], (_, { rows }) =&gt;          console.log(JSON.stringify(rows)));      <br/>   }, null, forceUpdate);  <br/>};</span></pre><p id="476f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个函数中，我们直接调用数据库来插入新的todo项，然后读取它们。</p><p id="1fad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然所有这些都有效地工作，但是您可以很快看到对于较大的应用程序来说，这是如何变得难以维护的。</p><h2 id="8654" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">阿波罗客户端</h2><p id="e239" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">使用我们当前的架构，我们有超过40个联合GraphQL微服务。因此，我们在所有客户之间共享这些API，包括web和移动设备。我们使用Apollo客户端来消费这些API。“Apollo Client是一个全面的JavaScript状态管理库，使您能够使用GraphQL管理本地和远程数据。使用它来获取、缓存和修改应用程序数据，同时自动更新您的用户界面。”出于这篇博文的目的，我不会详细讨论Apollo为我们实现了什么，但是你可以在他们的<a class="ae kx" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">文档</strong> </a>中了解更多。</p><p id="0b08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apollo的主要优势之一是其开箱即用的缓存实现。它们将您的所有查询结果存储在一个本地的、规范化的内存缓存中。这对您的移动应用程序意味着，如果您导航到一个屏幕，获取数据，然后返回到该屏幕(所有这些都是在您的应用程序仍然打开的情况下)，您将无需再次从网络中重新获取所有数据。相反，Apollo非常聪明，可以从内存缓存中获取数据。</p><p id="07d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Apollo客户端正确缓存数据有很多不同的策略。您可以通过Apollo的<a class="ae kx" href="https://www.apollographql.com/docs/react/data/queries/#supported-fetch-policies" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> fetchPolicies </strong> </a>配置如何平衡从缓存中获取数据。确保您的数据被正确缓存也非常重要。Apollo通过使用typename和数据对象上的“id或id”字段生成缓存ID来实现这一点。因此，在您的每个数据模型上指定一个惟一的标识符是至关重要的，否则，您可以指定您计划如何在您的<a class="ae kx" href="https://www.apollographql.com/docs/react/caching/cache-configuration/#customizing-cache-ids" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">类型策略</strong> </a>中合并那些对象。</p><h2 id="6396" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">阿波罗缓存持久化</h2><p id="eb7f" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">所以现在我们应该让缓存正常工作了，但是我们注意到，一旦你关闭应用程序，你将被迫再次从网络获取，因为Apollo Client只是提供了一个内存缓存。回到更早的时候，这对于某些行业是行不通的。旅途中的旅行者需要能够离线访问他们的数据，这意味着一旦他们关闭他们的应用程序，他们将无法从网络上获取数据，他们也不会在内存中有可用的缓存。那我们该怎么办？</p><p id="b091" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用<a class="ae kx" href="https://github.com/apollographql/apollo-cache-persist" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">阿波罗缓存持久化</strong> </a>！Apollo Cache Persist是一个库，可以无缝地保存和恢复持久存储中的Apollo缓存。</p><p id="791e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置非常简单。首先，我们需要决定要添加哪些配置。例如，如果我们想改变maxSize，默认为1MB，我们可以在这里设置它。这里 可以参考<a class="ae kx" href="https://github.com/apollographql/apollo-cache-persist/blob/master/docs/advanced-usage.md#additional-options" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">的附加配置。对于我们的示例，我们将只关注提供我们的存储提供商，这将是一个AsyncStorage。</strong></a></p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="f0df" class="jx jy hi kz b fi ld le l lf lg">import { ApolloClient, InMemoryCache } from "@apollo/client";<br/>import AsyncStorage from "@react-native-async-storage/async-storage";<br/>import { AsyncStorageWrapper, CachePersistor } from "apollo3-cache-persist";<br/>import { useEffect } from "react";</span><span id="0db1" class="jx jy hi kz b fi lh le l lf lg">const cache = new InMemoryCache({<br/>   // your cache configuration<br/>});</span><span id="ea0b" class="jx jy hi kz b fi lh le l lf lg">const persistor = new CachePersistor({<br/>   cache,<br/>   storage: new AsyncStorageWrapper(AsyncStorage),<br/>});</span><span id="aee6" class="jx jy hi kz b fi lh le l lf lg">// then later when initializing your App</span><span id="9f33" class="jx jy hi kz b fi lh le l lf lg">useEffect(() =&gt; {<br/>   async function initializeCache() {<br/>      await persistor.restore();<br/>      const client = new ApolloClient({<br/>         // your Apollo Client initialization<br/>      });<br/>      client.onClearStore(async () =&gt; {<br/>         await persistor.purge();<br/>      });<br/>   }<br/>   initializeCache();<br/>}, []);</span></pre><p id="45d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们从apollo-cache-persist中设置初始化CachePersistor。我们通过传入缓存来引用它，我们确定我们的存储，并用来自<code class="du li lj lk kz b">@react-native-async-storage/async-storage</code>的AsyncStorage初始化我们的AsyncStorageWrapper。然后，在我们的应用程序初始化中，我们使用<code class="du li lj lk kz b">persistor.restore()</code>恢复我们的缓存。通过检查异步存储并查看是否有任何数据需要作为缓存的一部分进行恢复，这为我们完成了繁重的工作。一旦我们设置好这一部分，我们就可以关闭我们的应用程序，您会注意到您无需发出网络请求就可以获得数据(假设您之前已经至少获取过一次数据，并将其保存在您的缓存中)。您可以切换到飞行模式来正确测试这一点。</p><p id="a921" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们有了正确的身份验证，我们还有一个步骤。出于安全考虑，我们需要确保这些数据在注销时从存储器中清除，并防止使用同一设备登录的任何其他用户的数据出现任何错误。在您的应用程序初始化中，我们可以添加<code class="du li lj lk kz b">client.onClearStore(async () =&gt; { await persistor.purge() });</code>，它现在允许我们在清除Apollo客户端存储时清除我们的异步存储。所以现在，当我们签出我们的用户时，我们可以简单地清除商店。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="de43" class="jx jy hi kz b fi ld le l lf lg">&lt;Button<br/>   title="Sign out"<br/>   onPress={async () =&gt; {<br/>      await client.clearStore();<br/>   }}<br/>/&gt;</span></pre><p id="5114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！现在，我们的用户很高兴能够在旅途中访问他们的数据，让用户体验变得更好。</p><h2 id="2bc4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">回购示例</h2><p id="95d3" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">你可以在这里找到一个工作演示。它的制作是为了让你可以看到一个我们在这篇博文中概述的例子的工作应用。</p><p id="9b85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kx" href="https://github.com/nicobermudez/expo-offline-app-example" rel="noopener ugc nofollow" target="_blank">https://github.com/nicobermudez/expo-offline-app-example</a></p><h2 id="ca8e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">感谢阅读👋</h2><p id="aa83" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">如果你有任何问题，欢迎在下面评论或亲自联系我。</p></div></div>    
</body>
</html>
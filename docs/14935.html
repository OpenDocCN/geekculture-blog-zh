<html>
<head>
<title>Automate Azure Infrastructure Provisioning with Terraform — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform自动化Azure基础设施供应—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/automate-azure-infrastructure-provisioning-with-terraform-part-i-ef3be36c2c80?source=collection_archive---------11-----------------------#2022-10-03">https://medium.com/geekculture/automate-azure-infrastructure-provisioning-with-terraform-part-i-ef3be36c2c80?source=collection_archive---------11-----------------------#2022-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c54038b53237242a246c12a593530b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lySrnqFrMIiC4tp5.png"/></div><figcaption class="im in et er es io ip bd b be z dx">source — <a class="ae iq" href="https://blog.devgenius.io/how-to-create-a-terraform-custom-module-for-an-ec2-instance-ea30a1d4b1f8" rel="noopener ugc nofollow" target="_blank">https://blog.devgenius.io/how-to-create-a-terraform-custom-module-for-an-ec2-instance-ea30a1d4b1f8</a></figcaption></figure><h1 id="985a" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated"><strong class="ak">什么是Terraform </strong></h1><p id="f877" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">Terraform是一个基础设施供应工具。基本上，它用于以编程方式创建、管理和销毁项目的部署基础设施。它可以管理大多数云提供商的基础架构组件，如前门、线墙、密钥库、存储、虚拟机等。最重要的是，由于我们是通过代码库来配置基础架构的，因此我们可以复制和重用相同的代码库，通过对代码库进行微小的修改来为不同的环境或项目配置基础架构。这是使用这个强大工具的主要好处。另一方面，通过云控制台创建基础设施并相应地管理它们是一项非常繁琐的任务。当我们需要创建一个新环境时，如果我们手动创建，将会花费大量时间。但是通过terraform，我们可以高效地自动化这个过程。</p><p id="1e9f" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">Terraform是使用HashiCorp配置语言(HCL)编写的，它支持所有主要的云提供商。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ks"><img src="../Images/d5bf68384b62e14b79bd314ef9b98e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TCCZvtZ3AkaQusau"/></div></div><figcaption class="im in et er es io ip bd b be z dx">source — <a class="ae iq" href="https://registry.terraform.io/browse/providers" rel="noopener ugc nofollow" target="_blank">https://registry.terraform.io/browse/providers</a></figcaption></figure><h2 id="b118" class="lb is hi bd it lc ld le ix lf lg lh jb ka li lj jf ke lk ll jj ki lm ln jn lo bi translated">声明性与命令性特征</h2><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/38504cdab2e90357b14c2f89af03370d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*XNAEGHVDDoa-0kHV"/></div><figcaption class="im in et er es io ip bd b be z dx">source — <a class="ae iq" href="https://www.educative.io/blog/declarative-vs-imperative-programming" rel="noopener ugc nofollow" target="_blank">https://www.educative.io/blog/declarative-vs-imperative-programming</a></figcaption></figure><p id="280b" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">命令式编程意味着，我们有目的地提供达到目标所需的所有指令，或者提供完成目标所需的所有步骤。例如，在基础架构配置中:</p><ul class=""><li id="e5db" class="lq lr hi jr b js kn jw ko ka ls ke lt ki lu km lv lw lx ly bi translated">添加2台服务器</li><li id="04ed" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">创建DNS设置</li><li id="657c" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">添加必要的权限和路由规则等。</li></ul><p id="b821" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">但是在声明式编程中，我们只提供我们需要的目标或最终结果。例如，我们需要一个部署基础设施，包括2台服务器和必要的组件。</p><p id="1e01" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">Terraform是一种声明式编程语言，我们在其中声明最终需要的设置，然后terraform核心将识别当前状态以及完成最终状态所需的步骤。因此，在管理透视图中使用它更容易、更方便，因为我们不需要管理基础架构供应中的任何中间步骤。如果我们通过正确配置相关模块来提供最终状态，那么terraform将为目标基础设施规划所需的步骤。</p><h1 id="451e" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">地形文件结构</h1><p id="6cf1" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">当我们管理terraform代码库时，我们可以有几种不同用途的文件，并提高代码库的可读性和效率。</p><ul class=""><li id="086f" class="lq lr hi jr b js kn jw ko ka ls ke lt ki lu km lv lw lx ly bi translated">在文件<strong class="jr hj"> main.tf </strong>中可以找到带有所需资源块的模块的初始设置。</li><li id="49a8" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">模块的变量定义包含在文件<strong class="jr hj"> variables.tf </strong>中。</li><li id="e0ec" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">资源的输出定义在文件<strong class="jr hj"> outputs.tf </strong>中。</li><li id="b5ef" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">通过允许这些值只设置一次，然后在整个配置中用作参考，<strong class="jr hj"> locals.tf </strong>可以帮助简化配置。</li><li id="3d05" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km lv lw lx ly bi translated">Terraform变量定义文件的扩展名为. tfvars或. tfvars.json。<strong class="jr hj"> tf文件</strong>。而。<strong class="jr hj"> tfvars </strong>文件用于定义变量，它们有时被称为变量定义文件。</li></ul><h1 id="f138" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">Terraform tfstate文件</h1><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es me"><img src="../Images/e942105889e5695572b46013b8699396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O_U9uW_VXPC-I-W3"/></div></div><figcaption class="im in et er es io ip bd b be z dx">source — <a class="ae iq" href="https://digitalvarys.com/complete-terraform-tutorial-part-4-terraform-state/" rel="noopener ugc nofollow" target="_blank">https://digitalvarys.com/complete-terraform-tutorial-part-4-terraform-state/</a></figcaption></figure><p id="22e7" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">这个文件记录了我们在云提供商中创建的所有资源。主要是它拥有云提供者中真实世界实体的所有配置，通常它被称为terraform.tfstate文件。如果我们在一个团队环境中，它既可以本地管理，也可以远程管理。Terraform使用此本地状态来制定计划和修改您的基础架构。Terraform在每次操作之前都会进行刷新，以更新实际基础设施的状态。在项目的整个生命周期中保持这个文件是很重要的，如果它被破坏，我们在云提供商中创建的资源可能会被破坏或改变。要运行terraform并将其更改应用到云，必须有这个文件。否则，它将初始化一个新文件，并且不会与我们在云提供商端拥有的任何当前资源同步。</p><h1 id="9b21" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">不同阶段的地形命令</h1><ol class=""><li id="051f" class="lq lr hi jr b js jt jw jx ka mf ke mg ki mh km mi lw lx ly bi translated"><strong class="jr hj">terraform init</strong>—terra form init命令执行后端初始化、子模块安装和插件安装，以便设置与terra form一起使用的工作目录。</li><li id="05f6" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km mi lw lx ly bi translated"><strong class="jr hj"> terraform validate </strong> —在不访问任何外部数据或服务的情况下验证目录中的配置文件。该命令必须在terraform init之后执行。</li><li id="0b55" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km mi lw lx ly bi translated"><strong class="jr hj">地形计划— </strong>该<strong class="jr hj"> </strong>将提供一个执行计划，指明将要完成的步骤，而不实际执行这些步骤。</li><li id="8bdd" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km mi lw lx ly bi translated"><strong class="jr hj"> terraform应用</strong> —应用terraform基于配置文件构建或修改基础设施。默认情况下，首先创建一个计划，并且必须接受该计划才能实施。</li><li id="5313" class="lq lr hi jr b js lz jw ma ka mb ke mc ki md km mi lw lx ly bi translated"><strong class="jr hj">地形摧毁</strong> —摧毁地形管理的基础设施。</li></ol><p id="2870" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">让我们在下一篇博客中讨论<strong class="jr hj">使用Terraform和Azure DevOps部署基础设施</strong>部分。</p><p id="3548" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">谢谢，继续阅读☺️.</p></div></div>    
</body>
</html>
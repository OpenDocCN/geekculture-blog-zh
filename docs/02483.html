<html>
<head>
<title>Basic CRUD in Golang, Learned From Unicorn’s Engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从独角兽的工程师那里学到的Golang的基本CRUD</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/basic-crud-in-golang-learned-from-unicorns-engineer-586b89111592?source=collection_archive---------7-----------------------#2021-05-17">https://medium.com/geekculture/basic-crud-in-golang-learned-from-unicorns-engineer-586b89111592?source=collection_archive---------7-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6afc4438c9319cd0e35653c6bc75f28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YeVDo3ni0MVKNgZG.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">just a cute illustration</figcaption></figure><p id="b03a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我已经为许多项目和后端技术工作了近10年，在过去的3年里，我还尝试将Node JS作为我的后端堆栈之一。现在我想重点谈谈Golang 的使用，因为Golang有着良好的记录，许多初创公司都在使用它作为后端堆栈。</p><p id="4521" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了帮助我更深入地学习Golang，我决定购买Golang课程，幸运的是，我的导师是印度尼西亚一家独角兽公司的工程师。就我个人而言，当我第一次使用Golang创建一个简单的项目时，我觉得这个堆栈是如此的严格和复杂。但从记忆和速度上知道结果后，我对这种语言印象深刻。所以在这篇文章中，我将写一个教程来使用Golang制作CRUD API，这可能是一个很长的教程，因为我想一步一步地写。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="aa9d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">装置</h1><p id="e957" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated"><strong class="iw hj">首先</strong>，你需要做一个空文件夹(假设文件夹名是<strong class="iw hj"> go-basic-crud </strong>)然后去那个文件夹。<br/>接下来，在终端中，您需要使用该命令设置初始模式</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx">command to init mod Golang project</figcaption></figure><p id="fa0e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">之后，我们需要安装<a class="ae js" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Gin Gonic </strong> </a>使我们的Golang可以使用请求访问。只需在终端中键入以下命令</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx">command to install gin-gonic libary</figcaption></figure><p id="9d18" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">安装的最后一步是我们需要创建一个<strong class="iw hj"> main.go </strong>文件。在该文件中，调用gin-gonic并创建一个路由器</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/98420a37bf0307b292cbf06d2a26ee0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Bp2H3kt0KQVO_IV8MxLSg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure><p id="a09e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我们可以通过运行项目来测试我们的安装。使用<strong class="iw hj"> go run main.go </strong>运行，当您从浏览器访问<strong class="iw hj"> /ping </strong>时，会显示json响应。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="6cfc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">插入数据库</strong></h1><p id="38a2" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">在去编码之前，别忘了创建一个新的数据库(假设名字是<strong class="iw hj"> go-basic </strong>)。我们不打算创建表，因为我们将使用自动迁移来创建表。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/068071b6373448f0e2ed374b79d59d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q41xAGW4ipWy0y_NSkuDvw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">task’s table schema</figcaption></figure><p id="5b32" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们将制作一些文件和文件夹来维护我们的代码，如下所示</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/05fbaa3340b72081c329aea763a40973.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*2gA5po_MXopFNKSd6dfzmg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx">folder structure</figcaption></figure><p id="01de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们在任务文件夹中创建一个<strong class="iw hj">实体。这个文件特意定义了我们的表模式，所以这个文件将用于自动迁移和ORM。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/a36009ee4ac3cbba86334ae0397ff72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4mLpHSqrE7qv-b2JGJo8Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">entity.go</figcaption></figure><p id="5f12" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第二个文件我们需要在<strong class="iw hj"> input.go </strong>中定义输入为struct。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/88868db6573afd864cab15b2f9b018f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRsyeqt6LyieBd88XwKnfg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">input.go</figcaption></figure><p id="29d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要制作的第三个文件是repository.go，它用于操作我们的数据库记录。别忘了先安装<a class="ae js" href="https://gorm.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> GORM </strong> </a>。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/6bda95d1d64aff257f3eb554eab8b28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWRo90RvbryWnY9ZzxVIwA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">repository.go</figcaption></figure><p id="6be0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下一个文件是<strong class="iw hj"> service.go </strong>，这个文件的目的是调用存储库函数，服务文件内部的函数可能会被其他域调用。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/13ff8d2a2b1b66df3affff981d04ccc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omYiJXiilCGZ5IVUOxYOPg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="870a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一个文件是处理程序文件夹中的<strong class="iw hj"> task.go </strong>。这个文件的目的是让路由器调用函数和使用服务函数，它是一种控制器文件。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/55550cf3f43f9b4dc4429a2d778b0e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSz9T12QhdYx-9M0OSahjw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">task.go</figcaption></figure><p id="f3f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本节最后一步是定义我们的数据库连接，进行自动迁移，定义存储库、服务和处理程序，然后创建路由。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/1089566b42da5cb61f9c39bb4cb12c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1isQuVWyC7HcPtvwmJEauw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure><p id="87d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重新启动我们的服务器后，您可以尝试点击/task从任务表中获取所有记录。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="30c9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">从数据库获取所有数据</h1><p id="8a88" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">实际上，我们已经为存储数据做了很长的一步，现在我们将继续获取数据。</p><p id="eb9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们需要在<strong class="iw hj">存储库中创建一个新函数。我们给函数起个名字<strong class="iw hj"> SelectAll() </strong>。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/2a1af2f76cd494da566ea03f18a49a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8MfHv5UxC2OKp6Rxnk4bw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">repository.go</figcaption></figure><p id="46b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了调用存储库中的函数，我们将在<strong class="iw hj"> service.go </strong>文件中调用它。让我们创建一个名为<strong class="iw hj"> Index() </strong>的新函数。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/a48b648bed4c87d6d6ffd942f9f487b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UegdkM4hvOdPboRiljj3Iw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="6f8e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，调用<strong class="iw hj">任务中的服务函数。让我们创建名为<strong class="iw hj">索引为</strong>的新函数。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/950a765e228f4abf04608230c199bee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPx_gaGOpLC0zhFLqL6Gyg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">task.go</figcaption></figure><p id="cacf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一点是，我们只需要在<strong class="iw hj"> main.go </strong>中注册新的路线。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/132e924e1c44bfd806ee0e2a9776a173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKYYFRGtuln-EZ9vehmV6Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f3ae" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">按ID获取数据</h1><p id="19e9" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">对于创造这种流动，我们不会做太多的改变。那我们开始吧。</p><p id="5034" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们在<strong class="iw hj">输入中需要一个新的结构。只需调用<strong class="iw hj"> InputTaskDetail </strong> struct。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/4a6e813db3566f787b2f65ce5a6417d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vdmRJeu41wE-o2QG1R_ew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">input.go</figcaption></figure><p id="1c19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们当然需要在<strong class="iw hj">存储库中创建一个新函数。只需调用<strong class="iw hj"> SelectById </strong>。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/e79b24b49ad0ff68f83ba903629f560c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-8QaO0NQ7jjoKjCt4m7xQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">repository.go</figcaption></figure><p id="e03c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">调用<strong class="iw hj">服务中的新功能。创建名为<strong class="iw hj"> SelectById </strong>的新函数。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/e79b24b49ad0ff68f83ba903629f560c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-8QaO0NQ7jjoKjCt4m7xQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="5a15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在handler中调用新服务的函数，这样我们就可以创建一个新的路由。让我们把它命名为<strong class="iw hj">显示为</strong>。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/572495c8e69a5b002a2dfacb4e708671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WfVK8UAA9GdUya5Jp-z9Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">task.go</figcaption></figure><p id="5f5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一步是在<strong class="iw hj"> main.go </strong>中创建一条新路线，这样我们就可以通过ID获取记录。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/f41777c3f5cd9d6b78edc096db413241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9PhM35AcYtG4bzbrSFvtA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure><p id="e9a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重新启动您的服务器，并使用/task/:id(例如localhost:8080/api/task/1)进行访问以获取数据。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="aaaa" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">更新数据</h1><p id="f1c0" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">下一部分是更新数据，因为它与按ID选择数据相关。</p><p id="9e3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<strong class="iw hj">库中创建一个新函数，用名称<strong class="iw hj">转到</strong>，更新</strong>。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/6461c0450e363e7f5b30530187ca1e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zT_BYHBNa_W8RV8vQJzhw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">repository.go</figcaption></figure><p id="e80c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">移动到<strong class="iw hj"> service.go </strong>文件，创建一个名为<strong class="iw hj"> Update </strong>的新函数。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/e1e3b4d58fc332e32e2a93dff799a2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Bx-kY2Thc2BYmu_JUX1cw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="b12c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后在我们的处理程序中创建一个新函数来允许路由更新数据。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/14c0fbfee97ab27e0efd3a6665c841ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-39uY2SScHNd8xQ84xKgw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">task.go</figcaption></figure><p id="8bff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一次触摸，在<strong class="iw hj"> main.go </strong>中注册新路线。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/e216ecfefc3fca8f89e0914d77401275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsfIMLblZecKCB3odQd5dg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure><p id="d4eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了测试我们的新路线，不要忘记首先重启服务器。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="52d6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">按ID删除数据</h1><p id="d11a" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">实际上，这个步骤与更新数据没有什么不同，只是在存储库、服务、处理程序中创建一个新的函数，并注册新的路由。</p><p id="b266" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<strong class="iw hj"> repository.go </strong>中，创建一个名为<strong class="iw hj"> Destroy </strong>的新函数。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/6dffe6b9af60533e1174a8cfb23a7313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OK2dJkdXrOtsx7qiFRo5ag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">repository.go</figcaption></figure><p id="38ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样在<strong class="iw hj"> service.go </strong>中，创建一个名为<strong class="iw hj"> Destroy </strong>的新函数。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/5e1ea98a1452f861724afa6f82fa6aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uu-aOh7WJCzfPGXdMNLdfA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="b476" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在处理程序文件中，创建一个名为<strong class="iw hj"> Destroy </strong>的新函数。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/ad63cf60e1fcd28c17625bd335bd9ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctTiesMH3bEEMnXlZ3ygUQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">service.go</figcaption></figure><p id="bd1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一次触摸是像往常一样在<strong class="iw hj"> main.go </strong>中注册一条新路线。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/e687ba35acca6bc7f96b42431eb88e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUVw7omFMwCqFw4sS1iLtw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">main.go</figcaption></figure><p id="140a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重启你的服务器，点击我们刚刚创建的新API。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/c250c0ea0987b39a5352479f55ddd559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ck-mgOkywViHkZx2.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">ganbatte!!</figcaption></figure><h1 id="44f8" class="ka kb hi bd kc kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx bi translated"><strong class="ak">结论</strong></h1><p id="f3be" class="pw-post-body-paragraph iu iv hi iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">对于第一次用Golang创建CRUD API的我来说，感觉是如此的严格和复杂，我们需要创造条件来处理<strong class="iw hj"> <em class="mb"> err </em> </strong>。但是这个语言很好，我们可以同时做更多的逻辑和并发请求。我们也可以在任何操作系统中使用编译后的项目。</p><p id="312d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想克隆这个项目，我已经提供了我的<a class="ae js" href="https://github.com/taufanfadhilah/GO-basic-crud" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Github </strong> </a>。请随时给我发信息，也许你有问题或想合作，只需通过我的<a class="ae js" href="https://www.linkedin.com/in/taufanfadhilahiskandar/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> LinkedIn </strong> </a>。谢谢！</p></div></div>    
</body>
</html>
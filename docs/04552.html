<html>
<head>
<title>Creating an “Infinite Pin Bot” for Discord with TigerGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个与TigerGraph不和的“无限针机器人”</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/creating-an-infinite-pin-bot-for-discord-with-tigergraph-9870de089581?source=collection_archive---------23-----------------------#2021-06-29">https://medium.com/geekculture/creating-an-infinite-pin-bot-for-discord-with-tigergraph-9870de089581?source=collection_archive---------23-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2da7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将数据从Discord动态加载到TigerGraph用Python构建一个不和谐机器人，为我的科学碗不和谐提供无限的针</h2></div><h1 id="b0b6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">目标</h1><p id="c96a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我的朋友最近为我们的科学碗团队创建了一个不和谐服务器。老实说，这很神奇，每个科学碗类别都有添加问题和资源的地方。也许我最喜欢的部分是有一个“邮局”，在那里我们订阅了一些科学杂志和期刊，以获得最新的科学新闻。</p><p id="2540" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">由于我们一天会收到这么多文章，所以我们会“锁定”最有趣的文章。但是，不一致的是，引脚的限制是每通道50个。因此，我创建了一个机器人，其基本功能是将我们所有的图钉移动到一个不同的#有趣文章频道，下面是如何做到这一点。</p><h1 id="91c3" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">概观</h1><p id="5156" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在这个博客中，我们想要从一个频道获取固定的消息，并将其发送到另一个频道。为了确定哪个管脚去了哪里，我们将在<code class="du kq kr ks kt b">createGraph.py</code>中创建一个图表。机器人本身将在<code class="du kq kr ks kt b">bot.py</code>中，我们每次想运行机器人时都会运行它。</p><blockquote class="ku kv kw"><p id="cf48" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:<code class="du kq kr ks kt b">createGraph.py</code>只会运行一次。<code class="du kq kr ks kt b">bot.py</code>将被运行以激活机器人。</p></blockquote><p id="9fe6" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我们的文件夹结构将如下所示:</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="7657" class="lj iy hi kt b fi lk ll l lm ln">PinBot<br/>├──<!-- --> bot.py<br/>└──<!-- --> createGraph.py</span></pre><h1 id="2677" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第一步:创建你的机器人</h1><p id="915d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">首先，你需要在<a class="ae lo" href="https://discord.com/developers/applications" rel="noopener ugc nofollow" target="_blank">https://discord.com/developers/applications</a>上创建你的机器人。这里，从“新应用程序”开始</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/963f35d01af27bd92cd1eb798c6427cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fDvQAVfsUTn62fhMeXltA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Click the “New Application” Button</figcaption></figure><p id="b07a" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">接下来，命名你的机器人，并按下创建。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mb"><img src="../Images/002fb04707bac81dcce015983450c835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elPgoxnSgVoqqShs0fdI7w.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Name Your Bot and Press “Create”</figcaption></figure><p id="4daa" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在右边的菜单栏，点击“机器人”，然后按下蓝色的“添加机器人”按钮。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/c0ff71086946a488739beddc9790be05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZY7qNICKWzqxb3dEdqzCmg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Press “Bot” then “Add Bot.”</figcaption></figure><p id="139f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">确认后，你会看到如下页面。最重要的部分是“复制”按钮；这将复制您的令牌。我们将在Python文件中使用它来创建Discord bot功能。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/a9d5ec5733a786a08d7b1045af3d64ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bhj5EGldTN2Gd9Qt-S_fg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">This is your created bot! Copy your Token!</figcaption></figure><h1 id="ed26" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第二步:用Python创建机器人的基本结构</h1><p id="8c90" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们要创建一个不和谐机器人的基本结构。这个代码将属于<code class="du kq kr ks kt b">bot.py</code>。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="0de4" class="lj iy hi kt b fi lk ll l lm ln">import discord</span><span id="acde" class="lj iy hi kt b fi md ll l lm ln">client = discord.Client()</span><span id="48b7" class="lj iy hi kt b fi md ll l lm ln">@client.event<br/>async def on_ready():<br/>  print(f'{client.user} has entered Discord')</span><span id="6e01" class="lj iy hi kt b fi md ll l lm ln">client.run("PASTE_YOUR_TOKEN_HERE")</span></pre><p id="0c24" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">(<code class="du kq kr ks kt b">PASTE_YOUR_TOKEN_HERE</code>应该替换为您在上一步中复制的令牌。)</p><p id="8036" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们走一遍。首先，我们使用<code class="du kq kr ks kt b">import discord</code>导入discord.py。discord.py的所有文档都在<a class="ae lo" href="https://discordpy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">这里</a>，你可以在这里<a class="ae lo" href="https://pypi.org/project/discord.py/" rel="noopener ugc nofollow" target="_blank">找到它的pip包。</a></p><p id="8424" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">接下来，我们使用<code class="du kq kr ks kt b">client = discord.Client()</code>创建一个客户端对象。有了这个，我们将向机器人发送指令。最后，我们运行客户端，并将我们的令牌作为参数传递，指示我们正在控制哪个bot。</p><h1 id="25ab" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤三:在TigerGraph中创建一个解决方案</h1><p id="105f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">既然Discord方面已经准备好了，让我们设置我们的TigerGraph解决方案。前往https://tgcloud.io/<a class="ae lo" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">的</a>，使用您的TigerGraph账户登录。</p><blockquote class="ku kv kw"><p id="0e1f" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:创建TigerGraph云帐户是完全免费的，不需要您的信用卡号码。</p></blockquote><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es me"><img src="../Images/b5ebfe5caa330fb8d523d7e5f147c613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G06UvQfAq6aZokfQcFwpAg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Log in or register at <a class="ae lo" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">https://tgcloud.io/</a>.</figcaption></figure><p id="1eb4" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">登录后，单击“解决方案”选项卡，然后单击“新建解决方案”按钮。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div class="er es mf"><img src="../Images/7f1b79de59154a23b9181c7fc8d7d19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*o-UItPjdaL-Qw_jwXJ41jw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">On the sidebar, click “My Solutions.”</figcaption></figure><figure class="lb lc ld le fd lq er es paragraph-image"><div class="er es mg"><img src="../Images/c7a70f8de8a5f9ae239c576cf9c5cbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*h9D5ic3weWYXRvR1N9DEag.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Then click the blue “Create Solution” button.</figcaption></figure><p id="2e43" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在第一页上，选择“空白”初学者工具包。然后点击“下一步”</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mh"><img src="../Images/41d627b13dba1b60d1b626eaae5aa9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQ-0D02gXWVO815li6P-9Q.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Select the “Blank” starter kit and hit “Next.”</figcaption></figure><p id="f7c2" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在下一页，不要点击任何东西，按“下一步”</p><blockquote class="ku kv kw"><p id="ebf9" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:这个页面设置了一个免费的TigerGraph解决方案。如果你需要付费解决方案，你需要添加你的信用卡并修改设置。</p></blockquote><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/3c5f95fe161b2d993a9b34a962a2409b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaBtSxAgm73Yh6b75rGeag.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Leave this page as is and press “Next.”</figcaption></figure><p id="2cec" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在下一页上，编辑凭据。命名您的解决方案，添加标签，并添加描述。设置初始密码和子域名，并记下这些值。最后，按“下一步”</p><blockquote class="ku kv kw"><p id="5c3a" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:写下你的域名和密码！此外，所有子域必须是不同的。</p></blockquote><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/cb747b2d5a22d8a10dce7b885834e029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ow-44AQGgH9Y9gzo0cHNIw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Edit this page to the details for your solution then press “Next.”</figcaption></figure><p id="f577" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">最后，在第四部分，检查您的总结是否有错误，然后点击“提交”</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mh"><img src="../Images/3c744a01c726fea421ad15b3253d0ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raIWqOkdigDAdnCf0XaSkg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Review your summary and press “Submit.”</figcaption></figure><p id="0041" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">您的解决方案可能需要几分钟才能启动。当“解决方案”选项卡下的状态显示“就绪”并带有一个绿点时，您就知道它准备好了。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div class="er es mi"><img src="../Images/11009ce15f21263f6451a9918913d751.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*buew6n6xiT4vYCbYrvDc1g.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">When the status is “Ready” and has a green dot, then it’s ready!</figcaption></figure><p id="c453" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">干得好！是时候将TigerGraph集成到我们的项目中了。</p><h1 id="93d3" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第四步:创建你的图表</h1><p id="ff64" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">导航到<code class="du kq kr ks kt b">createGraph.py</code>文件。在这个文件中，我们将创建图表并安装查询。</p><h2 id="55bf" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">第四步。I:导入库并连接到解决方案</h2><p id="78f8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">首先，你需要导入<a class="ae lo" href="https://pytigergraph.github.io/pyTigerGraph/" rel="noopener ugc nofollow" target="_blank"> pyTigerGraph </a>。您可以使用以下命令从终端中的pip安装它:</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="a21d" class="lj iy hi kt b fi lk ll l lm ln">pip install pyTigerGraph</span></pre><p id="6b98" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">安装完成后，将其导入到<code class="du kq kr ks kt b">createGraph.py</code>文件中:</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="0411" class="lj iy hi kt b fi lk ll l lm ln">import pyTigerGraph as tg</span></pre><p id="928e" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">干得好！现在您需要创建一个到您的解决方案的连接。为此，请使用tg.TigerGraphConnection。文件应该是这样的，其中SUBDOMAIN是您的子域，PASSWORD是您的密码。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="fe53" class="lj iy hi kt b fi lk ll l lm ln">import pyTigerGraph as tg</span><span id="10ca" class="lj iy hi kt b fi md ll l lm ln">conn = tg.TigerGraphConnection(host="https://SUBDOMAIN.i.tgcloud.io", password="PASSWORD")</span></pre><blockquote class="ku kv kw"><p id="c9d2" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:为了正确执行，请确保您的解决方案在<a class="ae lo" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">https://tgcloud.io/</a>的“解决方案”选项卡上处于“就绪”状态。</p></blockquote><p id="2349" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">您现在已经连接到GraphStudio上的解决方案！现在让我们创建我们的图表！</p><h2 id="3afc" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">第四步。II:创建图表</h2><p id="9a3c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们将创建一个带有通道顶点和SEND_TO有向边的基本图形。我们将首先创建全局顶点和边，然后创建名为PinGraph的图。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="74d9" class="lj iy hi kt b fi lk ll l lm ln">print(conn.gsql('''</span><span id="ceb2" class="lj iy hi kt b fi md ll l lm ln">   CREATE VERTEX Channel(PRIMARY_ID channel_id STRING) WITH primary_id_as_attribute="true"<br/>   CREATE DIRECTED EDGE SEND_TO(FROM Channel, TO Channel)</span><span id="0519" class="lj iy hi kt b fi md ll l lm ln">   CREATE GRAPH PinGraph(Channel, SEND_TO)</span><span id="8ff3" class="lj iy hi kt b fi md ll l lm ln">'''))</span></pre><p id="9496" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">一旦执行完毕，您可以在GraphStudio中看到您的图形。要访问GraphStudio，请转到tgcloud.io中的“解决方案”选项卡。当您将鼠标悬停在“应用程序”上时，单击您的解决方案旁边和“操作”列下的四个框。您将看到一个下拉菜单，然后单击第一个选项GraphStudio。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div class="er es mw"><img src="../Images/ecf647d7243881ab1b2e683fcffa7ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*qhsQV_5UQf3U2OZliBpltg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Click “GraphStudio” under the Actions column</figcaption></figure><p id="fdde" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在“设计模式”中，您应该会看到刚刚创建的模式！</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/6257b6826316512de3e19a6d96eece7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7gwwP8fNCT6FVQITZYFhg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Schema for PinGraph in GraphStudio</figcaption></figure><p id="b381" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">最后，您需要更新您的图形凭证，以便我们可以安装查询。我们将把graphname改为PinGraph，并生成一个API令牌。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="a80f" class="lj iy hi kt b fi lk ll l lm ln">conn.graphname = "PinGraph"</span><span id="d132" class="lj iy hi kt b fi md ll l lm ln">conn.apiToken = conn.getToken(conn.createSecret())</span></pre><h2 id="9ffe" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">第四步。III:编写一个查询</h2><p id="8a9f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">厉害！最后一个设置步骤是编写一个查询。这里，我们将需要创建一个查询，该查询将能够获取连接到某个频道的所有频道。(这样，当我们锁定一个消息时，我们就知道将数据放在哪里。)</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="1ae5" class="lj iy hi kt b fi lk ll l lm ln">conn.gsql('''</span><span id="4199" class="lj iy hi kt b fi md ll l lm ln">   DROP QUERY getConnectedChannels</span><span id="52f7" class="lj iy hi kt b fi md ll l lm ln">   CREATE QUERY getConnectedChannels(STRING id) FOR GRAPH PinGraph {</span><span id="4d55" class="lj iy hi kt b fi md ll l lm ln">      Seed = {Channel.*};</span><span id="4006" class="lj iy hi kt b fi md ll l lm ln">      Res = SELECT c FROM Seed:s -(SEND_TO:e)-&gt; Channel:c<br/>            WHERE s.channel_id == id;<br/>      <br/>      PRINT Res;</span><span id="7fc9" class="lj iy hi kt b fi md ll l lm ln">   }</span><span id="b5d9" class="lj iy hi kt b fi md ll l lm ln">   INSTALL QUERY getConnectedChannels</span><span id="9196" class="lj iy hi kt b fi md ll l lm ln">''')</span></pre><p id="4d67" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这里，我们创建查询getConnectedChannels。我们来分解一下。</p><p id="f5a9" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我们首先删除已经存在的查询。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="308b" class="lj iy hi kt b fi lk ll l lm ln">DROP QUERY getConnectedChannels</span></pre><p id="e3ff" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">接下来，我们将为我们的查询创建标题。我们称它为getConnectedChannels，它将接受一个名为id的字符串。最后，这个查询将用于图形PinGraph。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="60a0" class="lj iy hi kt b fi lk ll l lm ln">CREATE QUERY getConnectedChannels(STRING id) FOR GRAPH PinGraph</span></pre><p id="87e5" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">查询本身从一个种子开始。这将抓取图形中的所有通道顶点。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="bae6" class="lj iy hi kt b fi lk ll l lm ln">Seed = {Channel.*};</span></pre><p id="0a65" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">然后我们有了SELECT语句。在FROM子句中，它表示从种子(通道顶点)开始，经过SEND_TO边，最后在通道顶点结束。</p><p id="98bd" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">SELECT语句说要抓取目标通道顶点。(它说选择c，并且在FROM子句中，目标通道顶点在Channel:c中被声明为c。)</p><p id="e295" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">最后，WHERE过滤我们的结果，以确保我们只获取连接到作为参数传递的通道id的通道顶点。</p><p id="39dd" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这存储在一个名为Res的变量中。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="61e0" class="lj iy hi kt b fi lk ll l lm ln">Res = SELECT c FROM Seed:s -(SEND_TO:e)-&gt; Channel:c<br/>      WHERE s.channel_id == id;</span></pre><p id="aece" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在查询的最后一行，输出Res。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="9f59" class="lj iy hi kt b fi lk ll l lm ln">PRINT Res;</span></pre><p id="5caf" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">最后，我们安装查询。这可能需要几分钟来运行。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="2acc" class="lj iy hi kt b fi lk ll l lm ln">INSTALL QUERY getConnectedChannels</span></pre><p id="d59b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">并且，运行第一个块，您已经创建了查询！恭喜你。您已经完成了图形和<code class="du kq kr ks kt b">createGraph.py</code>的创建。运行该文件一次，然后返回到<code class="du kq kr ks kt b">bot.py</code>以完成bot的创建。</p><blockquote class="ku kv kw"><p id="6471" class="jp jq kx jr b js kl ij ju jv km im jx ky kn ka kb kz ko ke kf la kp ki kj kk hb bi translated">注意:如果多次运行createGraph.py，可能会遇到错误。在这种情况下，您可以注释掉已经执行的代码，或者使用<code class="du kq kr ks kt b">conn.gsql('DROP ALL')</code>删除所有数据并重新运行。</p></blockquote><h1 id="f364" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第五步:将TigerGraph集成到你的机器人中，并创建你的机器人</h1><p id="e24c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在一切都设置好了，让我们开始编写机器人代码。</p><h2 id="5279" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">步骤V.I:添加您的TigerGraph连接</h2><p id="670e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">目前，<code class="du kq kr ks kt b">bot.py</code>应该已经有了第二步中的模板。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="36f8" class="lj iy hi kt b fi lk ll l lm ln">import discord</span><span id="46e9" class="lj iy hi kt b fi md ll l lm ln">client = discord.Client()</span><span id="6abf" class="lj iy hi kt b fi md ll l lm ln">@client.event<br/>async def on_ready():<br/>  print(f'{client.user} has entered Discord')</span><span id="8d2d" class="lj iy hi kt b fi md ll l lm ln">client.run("PASTE_YOUR_TOKEN_HERE")</span></pre><p id="b905" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们导入pyTigerGraph并创建连接。再次确保您的解决方案已经在GraphStudio中启动！</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="6166" class="lj iy hi kt b fi lk ll l lm ln">import discord<br/>import pyTigerGraph as tg</span><span id="f776" class="lj iy hi kt b fi md ll l lm ln">client = discord.Client()</span><span id="9f6d" class="lj iy hi kt b fi md ll l lm ln">conn = tg.TigerGraphConnection(host="https://SUBDOMAIN.i.tgcloud.io", password="PASSWORD", graphname="PinGraph")<br/>conn.apiToken = conn.getToken(conn.createSecret())</span><span id="140d" class="lj iy hi kt b fi md ll l lm ln">@client.event<br/>async def on_ready():<br/>   print(f'{client.user} has entered Discord')</span><span id="5d7a" class="lj iy hi kt b fi md ll l lm ln">client.run("PASTE_YOUR_TOKEN_HERE")</span></pre><p id="9ede" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在我们的TigerGraphConnection中，我们现在有了另一个参数graphname，它将是PinGraph。</p><h2 id="f479" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">步骤V.II:向图中添加顶点和边</h2><p id="8cc0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们将为on_message创建另一个@client.event函数。为了这句话！sendto #channel_name，我们将在撰写消息的频道和提到的频道之间创建一个链接。</p><p id="815b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">首先，我们将创建一个客户端消息，这个函数将在每次发送消息时做出反应。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="e6cb" class="lj iy hi kt b fi lk ll l lm ln">@client.event<br/>async def on_message(msg):<br/>   pass</span></pre><p id="c270" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在我们将添加一个if语句。如果发送的消息是！sendto，然后它会尝试抢占频道。它将向上插入两个顶点(当前通道和参考通道)，然后创建连接这两个顶点的边。如果有问题，它会简单地说有一个错误。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="4799" class="lj iy hi kt b fi lk ll l lm ln">@client.event</span><span id="1694" class="lj iy hi kt b fi md ll l lm ln">async def on_message(msg):</span><span id="c86c" class="lj iy hi kt b fi md ll l lm ln">   if msg.content[:7] == "!sendto":</span><span id="4fcb" class="lj iy hi kt b fi md ll l lm ln">      try:</span><span id="4781" class="lj iy hi kt b fi md ll l lm ln">         from_id = str(msg.channel.id)<br/>         to_id = str(msg.content[10:-1])<br/>         conn.upsertVertex("Channel", from_id, attributes={"channel_id": from_id})<br/>         conn.upsertVertex("Channel", to_id, attributes={"channel_id": to_id})<br/>         conn.upsertEdge("Channel", from_id, "SEND_TO", "Channel", to_id)<br/>         await msg.channel.send(f"Posting Pins from &lt;#{from_id}&gt; to &lt;#{to_id}&gt;")</span><span id="41cc" class="lj iy hi kt b fi md ll l lm ln">      except:</span><span id="2a83" class="lj iy hi kt b fi md ll l lm ln">         await msg.channel.send(f"Uh oh. There's been an error.")</span></pre><p id="f45d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们来测试一下！</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mx"><img src="../Images/428c6ce0dbc1d0ac24ddd0e4c5a6b2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcIinSRd2yYonW9UxV9MgA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Running the command in Discord</figcaption></figure><p id="3af1" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">完美！有用！</p><h2 id="d5c8" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">步骤V.III:从图中删除顶点和边</h2><p id="97db" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在让我们做同样的功能，但删除边缘切断连接。我们将使用命令！rmfrom和代码大致相似，但使用delEdge。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="4040" class="lj iy hi kt b fi lk ll l lm ln">@client.event</span><span id="0fef" class="lj iy hi kt b fi md ll l lm ln">async def on_message(msg):<br/>   if msg.content[:7] == "!sendto":<br/>      # Code from above; excluded for shortening purposes. Make sure to include in the final version!</span><span id="3c2a" class="lj iy hi kt b fi md ll l lm ln">   if msg.content[:7] == "!rmfrom":</span><span id="9139" class="lj iy hi kt b fi md ll l lm ln">      try:</span><span id="a102" class="lj iy hi kt b fi md ll l lm ln">         from_id = str(msg.channel.id)<br/>         to_id = str(msg.content[10:-1])<br/>         conn.delEdges("Channel", from_id, "SEND_TO", "Channel", to_id)<br/>         await msg.channel.send(f"Stopped Posting Pins from &lt;#{from_id}&gt; to &lt;#{to_id}&gt;")</span><span id="393f" class="lj iy hi kt b fi md ll l lm ln">      except:</span><span id="bf51" class="lj iy hi kt b fi md ll l lm ln">         await msg.channel.send(f"Uh oh. There's been an error.")</span></pre><p id="f6bc" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们来测试一下:</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es my"><img src="../Images/c17c844cf8341a1f753e4f022c328df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdpXw7hCVIJLa9XXcKKLig.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">!rmfrom command in Discord.</figcaption></figure><p id="0d07" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">不错！现在，我们可以添加和删除连接，让我们有机器人后引脚！</p><h2 id="85b1" class="lj iy hi bd iz mj mk ml jd mm mn mo jh jy mp mq jj kc mr ms jl kg mt mu jn mv bi translated">步骤五.四:张贴大头针</h2><p id="b5d4" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们将使用Discord.py中的另一个事件on_guild_channel_pins_update，它接受两个参数:channel和last_pin</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="20d7" class="lj iy hi kt b fi lk ll l lm ln">@client.event</span><span id="b963" class="lj iy hi kt b fi md ll l lm ln">async def on_guild_channel_pins_update(channel, last_pin):</span></pre><p id="9cd9" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">很好。这就是我们编写的查询发挥作用的地方。让我们运行查询来搜索任何连接到当前通道的通道，在当前通道中，某些内容被固定或取消固定。如果有结果，我们将从最近到最早获取所有的pin，并将其发布到另一个通道中，然后从当前通道中取消。总而言之，代码看起来像这样:</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="c6d7" class="lj iy hi kt b fi lk ll l lm ln">@client.event<br/>async def on_guild_channel_pins_update(channel, last_pin):</span><span id="cfbc" class="lj iy hi kt b fi md ll l lm ln">   connectingChannels = conn.runInstalledQuery("getConnectedChannels", params={"id": str(channel.id)})</span><span id="ab24" class="lj iy hi kt b fi md ll l lm ln">   if len(connectingChannels[0]["Res"]) &gt; 0:<br/>      channel_pins = await channel.pins()</span><span id="c61d" class="lj iy hi kt b fi md ll l lm ln">      for channels in connectingChannels[0]["Res"]:</span><span id="aebc" class="lj iy hi kt b fi md ll l lm ln">         if len(channel_pins) &gt; 0:<br/>            await client.get_channel(int(channels["attributes"]["channel_id"])).send(channel_pins[-1].content)<br/>            await channel_pins[-1].unpin()</span></pre><p id="821d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">太棒了。让我们检查它是否工作。</p><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mz"><img src="../Images/1d90ead83afe463db464853ca8957cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5GYkJOG7jk1RkeM3Ub8NQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Sending the Pin Request</figcaption></figure><figure class="lb lc ld le fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es na"><img src="../Images/70a26f9b858a602ea661f71a4969eebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZpfccCE1Mgjsrz7wdJ5FA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Message appears on the other channel!</figcaption></figure><p id="9e36" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">太棒了。你现在已经创建了你自己的无限针机器人！</p><h1 id="084b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第六步:祝贺+资源</h1><p id="460d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">恭喜你。您学习了如何使用Discord创建机器人，如何使用TigerGraph设置解决方案，以及如何创建无限pin机器人！</p><p id="7202" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">要加入TigerGraph Discord加入社区项目，了解更多信息，并提出任何问题，请单击此处:</p><div class="nb nc ez fb nd ne"><a href="https://discord.gg/gRHWBZNpxW" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">加入TigerGraph Discord服务器！</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">查看Discord上的TigerGraph社区-与568名其他成员一起玩，享受免费的语音和文本聊天。</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">不和谐. gg</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lv ne"/></div></div></a></div><p id="f2bc" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">要查看其他TigerGraph社区工具，请单击此处:</p><div class="nb nc ez fb nd ne"><a href="https://developers.tigergraph.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">TigerGraph开发者网站</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">所有TigerGraph开发者内容的一站式商店。探索学习、TigerGraph项目和我们生动的…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">developers.tigergraph.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns lv ne"/></div></div></a></div><p id="6ec0" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我希望你喜欢这个博客，学到一些东西，并继续探索更多的TigerGraph和Discord！</p></div></div>    
</body>
</html>
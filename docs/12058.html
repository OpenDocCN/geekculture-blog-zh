<html>
<head>
<title>Timer Precision in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中的定时器精度</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/flutter-case-study-timer-precision-a1154b431e8?source=collection_archive---------1-----------------------#2022-04-23">https://medium.com/geekculture/flutter-case-study-timer-precision-a1154b431e8?source=collection_archive---------1-----------------------#2022-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2fa0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">颤振案例研究</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/9e8b3a12f5bb4b8dd4fa9a3f346b17aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*C9ZItmvf4NLQ6wCuzXDqPQ.gif"/></div></figure><h1 id="99ec" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">介绍</h1><p id="a878" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我在stack overflow<a class="ae kt" href="https://stackoverflow.com" rel="noopener ugc nofollow" target="_blank">上看到一个关于Flutter(Dart ' s)<code class="du ku kv kw kx b"><a class="ae kt" href="https://api.dart.dev/stable/2.16.2/dart-async/Timer-class.html" rel="noopener ugc nofollow" target="_blank">Timer</a></code>职业的帖子。用户注意到了<code class="du ku kv kw kx b">Timer</code>的回调触发的变化，感觉它没有按预期工作。具体来说，用户表示，当将<code class="du ku kv kw kx b">Timer</code>的周期设置为20毫秒时，执行之间的时间间隔经常落在100-1000毫秒的不可接受的范围内。要了解这里发生了什么以及如何解决它，我们应该从看一看Dart的<code class="du ku kv kw kx b">Timer</code>类开始。</a></p><h1 id="8347" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">计时器</h1><p id="b94e" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">Dart中的<code class="du ku kv kw kx b">Timer</code>类是调度异步任务的强大工具，这些任务在后台处理一次或多次工作。然而，如果你使用过它，你可能会注意到实际的计时不是很精确(对于一个叫做<strong class="jz hj"> Timer </strong>的类来说不是很直观🤔).这在使用<code class="du ku kv kw kx b">Timer.periodic</code>时尤为明显。如果我们研究这个类的代码，我们会发现下面的注释:</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="0bf2" class="lc jg hi kx b fi ld le l lf lg">The exact timing depends on the underlying timer implementation. No more than `n` callbacks will be made in `duration * n` time, but the time between two consecutive callbacks can be shorter and longer than `duration`.</span></pre><p id="90cb" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">看来，<code class="du ku kv kw kx b">Timer</code>和Dart的<em class="lm">事件循环</em>的性质是造成回调持续时间变化的原因。当然，随着更多的事件被添加到循环中，我们可以看到它如何影响时间。如果我们需要定期(即每帧)更新一次<code class="du ku kv kw kx b">Widget</code>，那么<code class="du ku kv kw kx b">Timer</code>显然不是最好的方法。如果您不熟悉Dart的事件循环，请查看下面的视频。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="eb82" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">心脏</h1><p id="d315" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">幸运的是，在Flutter中有一个计时机制，我们可以指望它非常稳定。它依赖于以一致的60 fps绘制帧，并且由于它在每一帧被绘制之前触发，这是尽可能频繁和一致地更新我们的UI的完美方式！这种方法使用了Flutter的<code class="du ku kv kw kx b">scheduler</code>库中的<code class="du ku kv kw kx b"><a class="ae kt" href="https://api.flutter.dev/flutter/scheduler/Ticker-class.html" rel="noopener ugc nofollow" target="_blank">Ticker</a></code>类。我们去看看。</p><p id="1778" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">我们将创建一个简单的秒表部件。首先，让我们定义我们的<code class="du ku kv kw kx b">Stopwatch</code>小部件和<code class="du ku kv kw kx b">State</code>。我们将使用<code class="du ku kv kw kx b">SingleTickerProviderStateMixin</code>来提供对我们的<code class="du ku kv kw kx b">State</code>中的<code class="du ku kv kw kx b">Ticker</code>的访问。如果你在Flutter中做过动画，你可能已经遇到过了。我们还将提供变量来跟踪经过的时间。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="5c55" class="lc jg hi kx b fi ld le l lf lg">class Stopwatch extends StatefulWidget {<br/>  const Stopwatch({Key? key}) : super(key: key);</span><span id="89a7" class="lc jg hi kx b fi lp le l lf lg">  @override<br/>  State&lt;Stopwatch&gt; createState() =&gt; _StopwatchState();<br/>}</span><span id="0744" class="lc jg hi kx b fi lp le l lf lg">class _StopwatchState extends State&lt;Stopwatch&gt;<br/>    with SingleTickerProviderStateMixin {<br/>  var elapsed = Duration.zero;<br/>  var previousElapsed = Duration.zero;</span><span id="efd0" class="lc jg hi kx b fi lp le l lf lg">  @override<br/>  Widget build(BuildContext context) {<br/>    // TODO: implement UI<br/>  }<br/>}</span></pre><p id="ffbd" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">我们定义<code class="du ku kv kw kx b">previousElapsed</code>是为了帮助我们在暂停&amp;重启秒表时记录持续时间。接下来，我们将使用由<code class="du ku kv kw kx b">SingleTickerProviderStateMixin</code>提供的恰当命名的<code class="du ku kv kw kx b">createTicker</code>方法来创建我们的<code class="du ku kv kw kx b">Ticker</code>。我喜欢使用<code class="du ku kv kw kx b">late</code>关键字来实例化变量，但是您可能更喜欢先定义它，然后在<code class="du ku kv kw kx b">initState</code>中实例化它。无论哪种方式，请务必处理掉<code class="du ku kv kw kx b">Ticker</code>。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="9506" class="lc jg hi kx b fi ld le l lf lg">late final ticker = createTicker((elapsed) {<br/>  setState(() =&gt; this.elapsed = elapsed);<br/>});</span><span id="d083" class="lc jg hi kx b fi lp le l lf lg">@override<br/>void dispose() {<br/>  ticker.dispose();<br/>  super.dispose();<br/>}</span></pre><p id="3f70" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">如您所见，我们只是定义了一个回调函数，它更新我们的运行时间<code class="du ku kv kw kx b">Duration</code>并调用<code class="du ku kv kw kx b">setState</code>。现在，让我们定义我们的<code class="du ku kv kw kx b">start</code>、<code class="du ku kv kw kx b">stop</code>和<code class="du ku kv kw kx b">reset</code>方法。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="a254" class="lc jg hi kx b fi ld le l lf lg">void start() {<br/>  <!-- -->previousElapsed<!-- --> += elapsed;<br/>  ticker.start();<br/>}</span><span id="77b8" class="lc jg hi kx b fi lp le l lf lg">void stop() =&gt; setState(() =&gt; ticker.stop());</span><span id="53fc" class="lc jg hi kx b fi lp le l lf lg">void reset() {<br/>  stop();<br/>  setState(() =&gt; elapsed = <!-- -->previousElapsed<!-- --> = Duration.zero);<br/>}</span></pre><p id="6edf" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">这些方法非常简单，但是请注意我们在哪里更新<code class="du ku kv kw kx b">previousElapsed</code>确保我们在没有复位的情况下启动&amp;停止时不会丢失轨迹。还要注意，我们从<code class="du ku kv kw kx b">stop</code> &amp; <code class="du ku kv kw kx b">reset</code>调用<code class="du ku kv kw kx b">setState</code>来更新UI。启动<code class="du ku kv kw kx b">Ticker</code>时没有必要，因为我们的回调在每帧调用<code class="du ku kv kw kx b">setState</code>。</p><p id="4351" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">剩下唯一要做的就是实现我们的<code class="du ku kv kw kx b">build</code>方法，使用我们的<code class="du ku kv kw kx b">Duration</code>变量来显示经过的时间。</p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="9465" class="lc jg hi kx b fi ld le l lf lg">@override<br/>Widget build(BuildContext context) {<br/>  final totalElapsed = elapsed + previousElapsed;<br/>  return Column(<br/>    mainAxisAlignment: MainAxisAlignment.center,<br/>    children: &lt;Widget&gt;[<br/>      FormattedDuration(elapsed: totalElapsed),<br/>      Row(<br/>        mainAxisAlignment: MainAxisAlignment.center,<br/>        children: [<br/>          IconButton(<br/>            onPressed: reset,<br/>            icon: const Icon(Icons.restart_alt),<br/>          ),<br/>          IconButton(<br/>            onPressed: ticker.isTicking ? stop : start,<br/>            icon: Icon(ticker.isTicking ? Icons.stop : Icons.play_arrow),<br/>          ),<br/>        ],<br/>      ),<br/>    ],<br/>  );<br/>}</span></pre><p id="e63e" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">为了简洁起见，我省略了任何无关的格式和布局代码。需要注意的重要部分是我们通过添加<code class="du ku kv kw kx b">elapsed</code> &amp; <code class="du ku kv kw kx b">previousElapsed</code>和<code class="du ku kv kw kx b">ticker.isTicking</code>的使用来计算<code class="du ku kv kw kx b">totalElapsed</code> <code class="du ku kv kw kx b">Duration</code>。如果<code class="du ku kv kw kx b">Ticker</code>已经在下一个帧<em class="lm">上调度了对其回调的调用，则该属性为<code class="du ku kv kw kx b">true</code>，这意味着它正在运行。</em></p><pre class="iy iz ja jb fd ky kx kz la aw lb bi"><span id="424e" class="lc jg hi kx b fi ld le l lf lg"><strong class="kx hj">NOTE:</strong> Ticker also has an isActive property. isActive can be true even when the Ticker is muted (not actively scheduling calls to its callback). That is why we use isTicking here.</span></pre><h1 id="2a24" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">警告</h1><p id="6f10" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这种方法非常适合任何更新应用程序UI的预定任务，因为它保证每帧调用一次。您还可以使用它来安排任何其他每秒需要发生不超过60次(大约。每16.6毫秒)。例如，您可以以120 bpm播放节拍器声音(每秒两次/每30帧一次)。</p><p id="e49a" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">但是，如果你需要更频繁地重复任务，那么这是不合适的。这种方法也是特定于Flutter的，所以如果您单独使用Dart，它就不适用。如果这两种情况中的任何一种适用于你，我建议你去看看<a class="ae kt" href="https://gist.github.com/mitsuoka/2652622" rel="noopener ugc nofollow" target="_blank">这个</a>图书馆。它为精确计时创建了一个<code class="du ku kv kw kx b">Isolate</code>。我不是作者，也没有丰富的经验，所以你的收获可能会有所不同。作者声称精确度在几毫秒之内。不过应该注意的是，<code class="du ku kv kw kx b">Isolate</code>之间的通信是异步的，并且会受到不规则性的影响，所以在计划项目时要记住这一点。</p><h1 id="a221" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">结论</h1><p id="2737" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我希望你喜欢这篇文章，并在阅读过程中学到了一些有价值的东西。<code class="du ku kv kw kx b">Ticker</code>是Flutter的<code class="du ku kv kw kx b">scheduling</code>库的强大组成部分，可以帮助我们保证每一帧的时序。</p><p id="b9ca" class="pw-post-body-paragraph jx jy hi jz b ka lh ij kc kd li im kf kg lj ki kj kk lk km kn ko ll kq kr ks hb bi translated">一如既往的感谢阅读！鼓励评论，赞赏掌声。请跟随跟上我的颤振文章和更多。</p></div></div>    
</body>
</html>
<html>
<head>
<title>Elasticsearch and its internals working</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索及其内部工作</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/elasticsearch-internals-4c4c9ec077fa?source=collection_archive---------0-----------------------#2020-06-21">https://medium.com/geekculture/elasticsearch-internals-4c4c9ec077fa?source=collection_archive---------0-----------------------#2020-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c99525b6bd453a2214437d9423c63577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_LkCNig-0qvI0q-QihDKw.jpeg"/></div></div></figure><p id="bc29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Elasticsearch的关键是一个倒排索引，这使得它比现有的其他传统数据库系统更好。核心的倒排索引是Elasticsearch与其他NoSQL商店(如MongoDB、Cassandra等)的不同之处。Elasticsearch中的所有数据都作为倒排索引内部存储在<a class="ae jo" href="https://lucene.apache.org/core/" rel="noopener ugc nofollow" target="_blank"> Apache Lucene </a>中。尽管数据存储在Apache Lucene中，但正是Elasticsearch使数据得以分布，并提供了易于使用的API。</p><p id="e8cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基本术语:</strong></p><ol class=""><li id="4afe" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">字段:</strong>字段是弹性搜索中最小的数据单位。例如标题、作者、日期、摘要、团队、分数等。</li><li id="bbdc" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> Documents: </strong> Documents是存储在Elasticsearch索引中的JSON对象，被认为是基本的存储单元。在关系数据库的世界中，文档可以比作表中的一行。</li><li id="28cb" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> Mappings: </strong>在Elasticsearch的最新版本(即7.x)中已被弃用。这就像关系数据库世界中的一个模式。</li><li id="f265" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">索引:</strong>这些是弹性搜索中最大的数据单位。它们可以与关系数据库中的数据库进行类比。它们可以被假定为文档的逻辑分区。</li><li id="f6a7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">碎片:</strong>这些是Lucene索引。这是帮助伸缩弹性搜索的关键。在这里，我们可以将一个索引分成多个分区，每个分区可以驻留在一个节点上，以获得更好的可用性和可伸缩性。</li><li id="36aa" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">段:</strong>一个分片进一步分为多个段。每个段都是存储实际数据的倒排索引。一个段<strong class="is hj">是不可变的</strong>。在一段固定的时间之后，这些相同大小的段被编辑在一起以形成更大的段，从而进行有效的搜索。这整个过程对用户完全透明，由Elasticsearch自动处理。</li><li id="8dc3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">副本:</strong>副本，顾名思义，是弹性搜索的防故障机制，基本上是索引碎片的副本。这是一个有用的备份系统，以备不时之需，或者换句话说，当一个节点崩溃时。副本还服务于读取请求，因此添加副本有助于提高搜索性能。</li><li id="7a20" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">分析器:</strong>它们也与优化索引和高效搜索相关。它在索引文档时使用，将短语分解成它们的组成术语。<strong class="is hj"> <em class="kd">标准分析器</em> </strong>是Elasticsearch使用的默认分析器，它包含基于语法的标记器，可以删除常见的英语单词和文章。</li><li id="0fc2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">节点:</strong>elastic search的每个实例都成为一个节点。如果一个服务器有2个Elasticsearch实例，那么就会有2个Elasticsearch节点。它的关键任务是存储和索引数据。Elasticsearch中有不同种类的节点:</li></ol><p id="cdc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a) <strong class="is hj">数据节点</strong>——存储数据并执行数据相关操作，如搜索和聚合。</p><p id="5c16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b) <strong class="is hj">主节点</strong>——负责集群范围的管理和配置操作，例如添加和删除节点。</p><p id="999e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c) <strong class="is hj">客户端节点</strong>——向主节点转发集群请求，向数据节点转发数据相关请求。</p><p id="b3e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">d) <strong class="is hj">摄取节点</strong> -用于在步进前进行预处理。<strong class="is hj"> Logstash </strong>可以被实例化为一个摄取节点。每个节点由其名称(或id)唯一标识，并且默认情况下能够成为<strong class="is hj">主</strong>节点。</p><p id="446c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10.<strong class="is hj">集群:</strong>集群由一个或多个弹性搜索节点组成。每个集群都有一个唯一的标识符，每个节点(希望成为集群的一部分)都必须使用该标识符。</p><p id="20e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">11.<strong class="is hj"> Translog: </strong> Lucene提交的开销太大，无法对每一个单独的更改都执行，所以每个分片拷贝也将操作写入其事务日志，称为Translog。translog中的数据只能通过Lucene commit保存在磁盘上。在JVM失败或碎片崩溃的情况下，自上次translog提交以来写入的任何数据都将丢失。</p><p id="98c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a)<strong class="is hj">index . trans log . sync _ interval-</strong>无论写操作如何，多长时间将trans log<code class="du ke kf kg kh b">fsync</code>写入磁盘并提交一次。默认为<code class="du ke kf kg kh b">5s</code>。不允许小于<code class="du ke kf kg kh b">100ms</code>的值。</p><p id="c9ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)<strong class="is hj">index . translog . duration-</strong>是否在每次索引、删除、更新或批量请求后提交<code class="du ke kf kg kh b">fsync</code>和trans log。此设置接受以下参数:(I)请求(ii)异步</p><p id="6e3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c)<strong class="is hj">index . trans log _ flush _ threshold-</strong>默认为512mb。</p><p id="e891" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">12.<strong class="is hj"> Flush: </strong>这个过程将事务日志从内存提交到磁盘。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="8739" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated"><strong class="ak">让我们来谈谈节点、索引和分片之间的关系。</strong></h2><p id="e9b5" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">让我们用<strong class="is hj"> 3 </strong>个节点(或实例)创建一个Elasticsearch集群。假设索引是“MyIndex ”,带有<strong class="is hj"> 6 </strong>个碎片和<strong class="is hj"> 1 </strong>个副本。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/5360969573e8284f76f0b02c8032a335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*fYO77B5GIDiVZBcLOTTjqA.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">An Index is distributed into 3 nodes with 6 shards and 1 replica</figcaption></figure><p id="4077" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们向群集中再添加3个节点。现在，每个节点将只有一个主碎片和一个副本，这种重新平衡对用户完全透明，由Elasticsearch处理。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/7fc6badf6e0ab3188e72497f928806a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*DvAeboAjy_z9WnM0dDh_ZA.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">The Index is distributed into 6 nodes</figcaption></figure><p id="e507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们在集群中增加6个节点，每个节点将只有一个碎片，要么是主节点，要么是副本节点。</p><h2 id="5061" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated"><strong class="ak">分布式搜索</strong></h2><p id="4dc4" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">Elasticsearch执行并行搜索，因为它将数据分布在给定索引的多个分片中。客户机节点对索引的每个碎片发出并行请求，并编译结果返回给客户机。这种分布式搜索功能使得Elasticsearch的速度非常快，其数据存储中有数十亿条记录。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/09e9851e190196ae42f2ceaed8302c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*_hImaUDfWzq7BShN6uqnZw.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Parallel requests on multiple shards of an index</figcaption></figure><p id="f4d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【Elasticsearch如何处理失败？</p><p id="8eb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设一个Elasticsearch集群中有4个节点。使用2个碎片和1个副本创建了一个索引<strong class="is hj">‘我的索引’</strong>。每个节点将有一个主碎片或一个副本碎片，如下图所示:</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/a28626fae7321966ecd2a5b1ebc36047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*D8Xi-5RLnc-c6QCkxv53wg.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">MySecondIndex has 2 primary shards with 1 replica each</figcaption></figure><p id="19fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，假设Node1因为某个硬件故障而关闭。Elasticsearch将节点3上的副本碎片S1提升为主碎片，并在节点2或节点4上创建一个新的副本碎片。<strong class="is hj"> <em class="kd">如果主节点本身出现故障，主节点所在的节点会向主节点发送一条消息。索引操作将等待(默认情况下最多1分钟)主服务器将其中一个副本服务器提升为主服务器。</em> </strong> Elasticsearch在主节点的帮助下完成所有这些步骤。完成此过程后，群集将如下所示:</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/529023e84efd0219134f76c2dc8c5c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*q1qEG3E7i1ctbqmInSyPCw.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">The replica is promoted to primary shard on Node3 and S1 is re-replicated on Node2</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="3272" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated">写入路径</h2><p id="e435" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated"><strong class="is hj">在索引级别:</strong></p><ol class=""><li id="b857" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用路由逻辑(基于目标文档的哈希值)的复制组被识别，然后主碎片在结果复制组中被识别。</li><li id="ea40" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">写操作被转发到主碎片，主碎片做很多事情来索引文档E-2-E</li><li id="29fb" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">主碎片验证文档的内容和结构。</li><li id="bfe1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">在本地执行操作。</li><li id="b83f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">将操作转发到当前同步副本集中的每个副本。如果有多个副本，这是并行完成的。</li><li id="10cc" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">一旦所有复制副本成功执行操作并响应主副本，主副本就会向客户端确认请求成功完成。<strong class="is hj"> <em class="kd">注意:有一个配置是wait_for_active_shards，它可以有任意正值，最大值为副本+主shards(或全部)的总数。默认值为1。</em>T15】</strong></li></ol><p id="3036" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在分片级别:</strong></p><ol class=""><li id="563f" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">文档被添加到shard的translog中，如果在请求中传递了async，客户端将获得成功的确认。</li><li id="6415" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">5s后，translog被提交到磁盘，并在碎片中创建新的不可变段。</li><li id="8075" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">每个段都是一个倒排索引。它就像一个映射，将术语作为一个键，将术语出现的文档列表作为值。为文档编制索引涉及多个步骤。分析仪在这一过程中起着至关重要的作用。</li><li id="5e01" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">文档被分割成令牌。</li><li id="d6fe" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">所有的令牌都是小写的。('<strong class="is hj">守'</strong>变'<strong class="is hj">守'</strong>，'<strong class="is hj">泰姬陵</strong>'变'<strong class="is hj">泰姬陵</strong>'等)</li><li id="92b5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">所有停用词都被删除。(例如:删除关键字，如“<strong class="is hj"> a </strong>”、“<strong class="is hj"> the </strong>”、“<strong class="is hj"> to </strong>”等)</li><li id="bbda" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">然后，令牌规范化完成。(即英文词干和同义词process——'<strong class="is hj">降雨</strong>'变成'<strong class="is hj">下雨'</strong>，'<strong class="is hj">跳了</strong>'变成'<strong class="is hj">跳了</strong>'，'<strong class="is hj">书</strong>变成'<strong class="is hj">书</strong>'，<strong class="is hj">周末</strong>和<strong class="is hj">周日</strong>是一个意思)。</li><li id="987a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如果我们只是将文档id列表存储为每个团队的值，我们将无法精确地提供短语搜索(即图书库)。为此，Elasticsearch将术语location与文档Id一起存储在文档中。</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="1656" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated">读取路径</h2><ol class=""><li id="67bb" class="jp jq hi is b it lk ix ll jb mc jf md jj me jn ju jv jw jx bi translated">如果是文档搜索，则识别使用路由逻辑(基于目标文档的哈希值)的复制组。</li><li id="12d9" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">检查事务日志，如果它还没有提交到磁盘，就从那里返回。</li><li id="3551" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">任何碎片(主碎片或副本碎片)都可以为客户端的请求提供服务，这使得它成为最快的搜索数据存储。可以添加更多的副本碎片来提高服务效率。</li><li id="ce45" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">并行搜索索引的所有碎片，它们的结果存储在大小为<strong class="is hj"> N(默认为10)的优先级队列中。</strong>这是一种数据结构，用于保存所有分片结果中最匹配的文档。文档的优先级(或相关性)通过T.F .(术语频率)* I.D.F(逆文档频率)来计算。</li><li id="d91b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">一旦整个搜索完成，优先级队列中的文档就被返回给客户机。</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="7100" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated"><strong class="ak">在生产中使用Elasticsearch时需要记住的一些要点:</strong></h2><ol class=""><li id="21b8" class="jp jq hi is b it lk ix ll jb mc jf md jj me jn ju jv jw jx bi translated">它提供乐观并发控制。在更新任何文档时，可以在请求中传递一个版本。它不会在更新时锁定任何碎片或文档。</li><li id="7ff5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">所有文档都是不可变的，不能更改，更新删除现有文档(软删除，稍后在后台删除)。因此，我们必须始终确保我们最多使用机器中一半的可用容量。</li><li id="2c06" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">始终保持比可用实例(或节点)更多的碎片，以便索引可以通过添加更多的节点来增加负载。请记住，索引的#shards一旦创建就不能修改。建议每个节点的碎片数为<strong class="is hj"> 2:1。</strong></li><li id="8ce8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Elasticsearch在批量操作中表现更好。如果可能的话，试着批量索引或搜索你的文档。</li><li id="bd60" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如果需要精确的字段搜索，请使用过滤器而不是查询，因为过滤器比查询更有效。过滤结果也可以被缓存。</li><li id="da51" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">3主节点集群是首选。</li><li id="59de" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">禁用索引中的<strong class="is hj"> _all </strong>字段，使用copy_to选项复制需要复制到<strong class="is hj"> _all </strong>字段的字段。默认情况下，每个字段的数据都存储在<strong class="is hj"> _all </strong>字段。这个过程被称为黑名单方法。建议使用白名单方法来建立有效的索引。节省了很多空间。</li></ol><p id="e302" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>
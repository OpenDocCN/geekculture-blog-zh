# 快速初始化器

> 原文：<https://medium.com/geekculture/swift-initializers-99423426624b?source=collection_archive---------18----------------------->

![](img/9ad3ed6563aecd767cd27014b1d2e77d.png)

初始化器就像特殊的方法，可以被调用来创建一个特定类型的新实例。

**苹果文档:**

*初始化*是准备一个类、结构或枚举的实例以供使用的过程。这个过程包括为该实例上的每个存储属性设置一个初始值，并在新实例准备就绪之前执行任何其他所需的设置或初始化。

在创建类或结构的实例时，类和结构*必须*将它们所有存储的属性设置为适当的初始值。 ***存储的属性不能处于不确定状态*** 。

**简单的初始化器语法**

init() {

//在这里执行一些初始化

}

> 类别人员{
> 
> var 名称:字符串
> 
> var 年龄:Int
> 
> var 地址:字符串
> 
> }

编译器错误:类 person 没有初始值设定项。

***这里默认的初始化式来自***

Swift 为任何结构或类提供了一个*缺省初始化器*，为其所有属性提供缺省值，并且本身不提供至少一个初始化器。默认初始化器只是创建一个新的实例，它的所有属性都设置为默认值。

> 类别人员{
> 
> var name:String = "Atmaja "
> 
> var 年龄:Int？
> 
> var 地址:字符串？
> 
> }
> 
> var myPerson = Person()

**定制初始化**

根据我们的要求，我们可以有不止一个初始化器，有不同的参数名、类型等..

> 结构人类{
> 
> var 性别:字符串
> 
> var age:Int = 10
> 
> init(gender:String) { //初始值设定项 1
> 
> self.gender =性别
> 
> }
> 
> init(age:Int) { //初始值设定项 2
> 
> 年龄=年龄
> 
> self.gender = "Female "
> 
> }
> 
> init(age:Int，gender:Gender) { //初始值设定项 3
> 
> 年龄=年龄
> 
> self.gender =性别
> 
> }
> 
> }

**输出:**

让人类=人类(性别:“男性”)

让人类 2 =人类(年龄:20)

让人类 3 =人类(年龄:40，性别:“男性”)

**swift 编译器将根据参数标签决定调用哪个 init 方法。**

**指定初始化器和便利初始化器**

Swift 为类类型定义了两种初始化器，以帮助确保所有存储的属性都接收初始值。

*   **指定初始值**
*   **方便的初始化器**

指定的初始化器是一个类的主初始化器。指定的初始化器完全初始化由该类引入的所有属性，并调用适当的超类初始化器继续超类链的初始化过程。

每个类应该至少有一个指定的初始化器。

初始化(参数，如果有){

//在这里执行一些初始化

}

*便利的初始化器*是第二级的，支持类的初始化器。我们可以定义一个方便的初始化器，从与方便初始化器相同的类中调用一个指定的初始化器，其中一些指定的初始化器的参数设置为默认值。我们还可以定义一个方便的初始化器，为特定的用例或输入值类型创建该类的实例。

便利初始化(_ 参数，如果有的话 _ ) {

}

> 类别人员{
> 
> var 名称:字符串
> 
> var 年龄:Int
> 
> *v* ar 地址:字符串
> 
> init(名称:字符串，年龄:整数，地址:字符串){
> 
> self.name = name
> 
> 年龄=年龄
> 
> Self.address =地址
> 
> }
> 
> 便利初始化(){
> 
> self.init(名字:“Atmaja”，年龄:100，地址:“Bangalore”)//便利性 init 必须调用指定的 init 方法
> 
> }
> 
> }

让 personObj1 = HumanBeing() //调用便利初始化

让 personObj2 = HumanBeing(姓名:“阿特玛嘉”，年龄:20，地址:“地球上的某个地方”)//调用指定的 init

//在这里，当方便初始化被调用时，它创建一个默认的人，当指定初始化被调用时，它根据需要创建一个人。

**覆盖初始化器**

在 Swift 中，默认情况下子类不会继承初始化器。如果我们想为父类已经拥有的子类提供相同的初始化器，我们必须使用 override 关键字**。**

> 类点{
> 
> 设 x: Int
> 
> 让 y: Int
> 
> init(x: Int，y: Int) {
> 
> self.x = x
> 
> self.y = y
> 
> }
> 
> }
> 
> 类名点:点{
> 
> 让标签:字符串？
> 
> 覆盖 init(x: Int，y: Int) {
> 
> self.label =零
> 
> super.init(x: x，y: y)
> 
> }
> 
> }
> 
> 设 p1 =命名点(x: 1，y: 1)

**超级初始化:**

是的，指定的初始化器需要向上委托，所以它必须调用 super.init()。如果我们不写这一行，编译器会替我们写。

所以我们不必显式地编写 super.init(…)，但是子类必须这样做，即使只是在幕后。

但是记住，在第一阶段我们需要在子类中设置属性，然后必须调用 super.init()。在第二阶段，我们可能会改变所有继承的属性。

> **类**基类{
> 
> **var** 值:字符串
> 
> **初始化** () {
> 
> value = "你好"
> 
> 打印(价值+“艾伯特”)
> 
> }
> 
> }
> 
> **类**子类:基类{
> 
> **var** subVar : String
> 
> 让 subInt : Int
> 
> **覆盖**初始化**初始化** () {
> 
> subVar = "world "
> 
> subInt =2022
> 
> **超**。初始化()
> 
> value = "Namskar" //可选，更改超类的值
> 
> print(value+"Albert") //输出 Namskar Albert
> 
> }
> 
> }

## **失败的初始化器**

一个失败的初始化器创建一个它初始化的类型的可选值。Wewrite 在一个失败的初始化器中返回 nil，以指示初始化失败可能被触发的点。即；如果一个条件失败，我们可以返回零。我

> 结构点{
> 
> 设 x: Int
> 
> 让 y: Int
> 
> 初始化？(x: Int，y: Int) { //？标志着这可能会失败
> 
> 如果 x = = 0 & & y = = 0 {
> 
> 返回零
> 
> }
> 
> self.x = x
> 
> self.y = y
> 
> }
> 
> }
> 
> 设 p1 = Point(x: 0，y: 0) // nil
> 
> 设 p2 = Point(x: 1，y: 1) //有效点

**必需的初始值**

在一个类初始化器的定义前写一个`required`修饰符，表明这个类的每个子类都必须实现这个初始化器。

我们还必须在所需初始化器的每个子类实现之前编写`required`修饰符，以表明初始化器需求适用于链中的其他子类。当重写一个必需的指定初始化器时，我们不写`override`修饰符。

默认情况下，子类不继承它们的超类初始化器。但是，如果满足某些条件，超类初始值设定项会被自动继承。在实践中，这意味着我们不需要在许多常见的场景中编写初始化器重写，并且只要这样做是安全的，就可以用最少的努力来继承我们的超类初始化器。

假设我们为子类中引入的任何新属性提供了默认值，则以下两条规则适用:

如果我们的子类没有定义任何指定的初始化器，它会自动继承它的父类的所有指定的初始化器。

**规则 2** 如果我们的子类提供了其所有超类指定初始化器的实现——要么按照规则 1 继承它们，要么提供一个自定义实现作为其定义的一部分——那么它会自动继承所有超类便利初始化器。

> classA {
> 
> 必需的 init() {
> 
> var a = 10
> 
> 打印(一份)
> 
> }
> 
> }
> 
> classB: classA {
> 
> 必需的 init() {
> 
> var b = 30
> 
> 打印(b)
> 
> }
> 
> }
> 
> class classC: classA {
> 
> }
> 
> let objA = classA()
> 
> 设 objB = classB()
> 
> 让 objC = classC()

输出:

10

30

10

10

***快乐编码……***
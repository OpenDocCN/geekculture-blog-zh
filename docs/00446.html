<html>
<head>
<title>Understanding Merkle Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Merkle树</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/understanding-merkle-trees-f48732772199?source=collection_archive---------2-----------------------#2021-02-10">https://medium.com/geekculture/understanding-merkle-trees-f48732772199?source=collection_archive---------2-----------------------#2021-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ee9094e04a7c60a19fff800fee22b2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWmJupQPgE2Ob8oaQwgZIA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx"><a class="ae hv" href="https://unsplash.com/photos/Du41jIaI5Ww?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">Image Credits</a></figcaption></figure><div class=""/><div class=""><h2 id="3662" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">Git、比特币和DynamoDB的精髓</h2></div><p id="82d5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">哈希树</strong>或<strong class="jp hz"> Merkle树</strong>是这样一种树，其中每个<a class="ae hv" href="https://en.wikipedia.org/wiki/Leaf_node" rel="noopener ugc nofollow" target="_blank">叶节点</a>用数据块的<a class="ae hv" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">密码哈希</a>标记，每个非叶节点用其子节点标签的密码哈希标记。由于这一特性，Merkle树用于验证两方或多方拥有相同的数据，而无需交换整个数据集合。</p><p id="8f7c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以下是Merkle树的一些主要优点:</p><ul class=""><li id="865b" class="kj kk hy jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">它们提供了一种证明数据完整性和有效性的方法。即使很小的数据篡改也会导致完全不同的散列。</li><li id="901f" class="kj kk hy jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">他们的证明只需要通过网络传输极少量的信息。它们将数据验证与数据本身分开。</li></ul><p id="2978" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们来看看Merkle树的一些有趣的用例:</p><h1 id="cbdb" class="kx ky hy bd kz la lb lc ld le lf lg lh je li jf lj jh lk ji ll jk lm jl ln lo bi translated">饭桶</h1><p id="b255" class="pw-post-body-paragraph jn jo hy jp b jq lp iz js jt lq jc jv jw lr jy jz ka ls kc kd ke lt kg kh ki hb bi translated">在理解Git如何利用Merkle树之前，让我们先看看Git如何存储我们的源代码。</p><p id="3e92" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Git以类似于UNIX文件系统的方式存储内容，但是稍微简化了一些。所有内容都存储为树和blob对象，树对应于UNIX目录条目，blob或多或少对应于<em class="lu">索引节点</em>或文件内容。单个树对象包含一个或多个条目，每个条目都是一个blob或子树的SHA-1散列及其关联的模式、类型和文件名。例如，项目中最近的树可能如下所示:</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/43fdd60d14ce7de7615770c2f1365db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dr_sCtJlxjOxQUN15cUpBg.png"/></div></div></figure><p id="77d4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du ma mb mc md b">master^{tree}</code>语法指定了在<code class="du ma mb mc md b">master</code>分支上最后一次提交所指向的树对象。注意，<code class="du ma mb mc md b">lib</code>子目录不是一个blob，而是一个指向另一棵树的指针:</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es me"><img src="../Images/15786906bef989acac863ea4cc283450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pj06uyD4JDMlqfILt5F-vw.png"/></div></div></figure><p id="a2d6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从概念上讲，Git存储的数据如下所示:</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/ce0c80557814aae7a2692711809e23cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CHKeVkZWAYVsKeeq79log.png"/></div></div></figure><p id="4084" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">假设我们有8个文件(包括树、blobs和元数据)。Merkle树如下所示:</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/e0c6d4768faea7073e74d675207fd0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R10x3Sbe5R-xAT9GDkRIng.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">INITIAL COMMIT</figcaption></figure><p id="a4c2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，如果我们改变第一个文件的内容，相应的散列也会改变，并且这种改变会一直延续到树的根。</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/157eddf203063343908f15e90196c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiUMNIa5-RFPDXdINiXjNQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">FILE 1 CHANGED</figcaption></figure><p id="16b3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这有助于Git有效地维护一个存储库的两个版本，这就是它如何存储跨越数百万行代码的数千个本地提交的整个历史。</p><p id="b5cc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当您从远程获取或推送您的更改时，git将检查根的哈希是否相同。如果不同，它将检查左侧和右侧的子节点，并重复此操作，直到找到发生变化的叶节点，然后仅通过网络传输该<em class="lu">增量</em>。</p><blockquote class="mi mj mk"><p id="cfe4" class="jn jo lu jp b jq jr iz js jt ju jc jv ml jx jy jz mm kb kc kd mn kf kg kh ki hb bi translated"><strong class="jp hz">注意</strong>:元数据包括诸如指向父提交的指针以及作者信息和作为提交对象的提交消息的信息。</p></blockquote><h1 id="b81e" class="kx ky hy bd kz la lb lc ld le lf lg lh je li jf lj jh lk ji ll jk lm jl ln lo bi translated">比特币</h1><p id="787b" class="pw-post-body-paragraph jn jo hy jp b jq lp iz js jt lq jc jv jw lr jy jz ka ls kc kd ke lt kg kh ki hb bi translated">中本聪的独创性发明比特币依靠Merkle树保持规模增长。在比特币中，一个块由前一个块的散列(块的链接)、一个Nonce和Merkle树中散列的交易组成(如图所示)。这有助于两件事:</p><figure class="lw lx ly lz fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/86a3cd9492eb2822951827769324d39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*7QOhAngJazhsfP068-SIFw.jpeg"/></div></figure><ul class=""><li id="9017" class="kj kk hy jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">首先，通过从树上修剪事务分支来压缩周期性的旧块。没有事务的块标题大约是80字节。如果我们假设每10分钟生成一个块，每年80字节* 6 * 24 * 365 = 4.2MB。随着平均RAM大小逐年增加，存储应该不是问题，即使块头必须保存在内存中。</li><li id="d737" class="kj kk hy jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">第二，它使得在不运行完整网络节点的情况下验证支付成为可能(<strong class="jp hz">简化支付验证</strong>)。SPV节点不下载整个区块链，它们只下载<em class="lu">块头</em>，这使它们能够验证特定的事务是否包含在一个块中。</li></ul><h1 id="3f2c" class="kx ky hy bd kz la lb lc ld le lf lg lh je li jf lj jh lk ji ll jk lm jl ln lo bi translated">DynamoDB</h1><p id="0cce" class="pw-post-body-paragraph jn jo hy jp b jq lp iz js jt lq jc jv jw lr jy jz ka ls kc kd ke lt kg kh ki hb bi translated">除了对加密货币的大肆宣传，<em class="lu">像DynamoDB和Cassandra </em>这样的NoSQL数据库依靠Merkle树来更快地检测副本之间的不一致，并最小化传输的数据量。</p><p id="7e5c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Dynamo使用Merkle树进行反熵，如下所示:每个节点为其托管的每个键范围(虚拟节点覆盖的键集)维护一个单独的Merkle树。这允许节点比较一个键范围内的键是否是最新的。在这个方案中，两个节点交换对应于它们共同拥有的键范围的Merkle树的根。随后，使用本文<em class="lu"> Git </em>部分描述的树遍历方案，节点确定它们是否有任何差异，并执行适当的同步操作。这种方案的缺点是，当节点加入或离开系统时，许多关键字范围会改变，从而需要重新计算树。然而，这个问题通过本文的<a class="ae hv" href="https://www.allthingsdistributed.com/2007/10/amazons_dynamo.html" rel="noopener ugc nofollow" target="_blank">第6.2节中描述的细化分区方案得到了解决。</a></p><h1 id="acae" class="kx ky hy bd kz la lb lc ld le lf lg lh je li jf lj jh lk ji ll jk lm jl ln lo bi translated">结论</h1><p id="a1e8" class="pw-post-body-paragraph jn jo hy jp b jq lp iz js jt lq jc jv jw lr jy jz ka ls kc kd ke lt kg kh ki hb bi translated">如本文开头所述，Merkle树将数据验证与数据本身分开，这开启了一系列优化和用例。除了上面的用例，加密审计和完整性检查经常依赖于Merkle树。<em class="lu">证书透明性</em>是一种安全技术，依靠Merkle树来检查TLS/SSL证书的有效性。这些只是少数用例，我相信会有许多有趣的想法和实现，利用这种被称为Merkle trees的令人敬畏的数据结构。</p><h1 id="c0f8" class="kx ky hy bd kz la lb lc ld le lf lg lh je li jf lj jh lk ji ll jk lm jl ln lo bi translated">参考</h1><ul class=""><li id="6594" class="kj kk hy jp b jq lp jt lq jw mp ka mq ke mr ki ko kp kq kr bi translated"><a class="ae hv" href="https://hackernoon.com/merkle-trees-181cb4bc30b4" rel="noopener ugc nofollow" target="_blank"> Merkle Trees </a></li><li id="afca" class="kj kk hy jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae hv" href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" rel="noopener ugc nofollow" target="_blank"> Git内部——Git对象</a></li><li id="ad27" class="kj kk hy jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae hv" href="https://www.allthingsdistributed.com/2007/10/amazons_dynamo.html" rel="noopener ugc nofollow" target="_blank">所有东西都是分布式的——亚马逊的发电机</a></li><li id="c7a9" class="kj kk hy jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae hv" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank">比特币:一种点对点的电子现金系统</a></li></ul></div></div>    
</body>
</html>
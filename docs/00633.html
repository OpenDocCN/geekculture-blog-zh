<html>
<head>
<title>Write Custom Kotlin Gradle Build Plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写定制的Kotlin Gradle构建插件</h1>
<blockquote>原文：<a href="https://medium.com/geekculture/write-custom-kotlin-build-plugin-3c71cbf0ee87?source=collection_archive---------15-----------------------#2021-03-08">https://medium.com/geekculture/write-custom-kotlin-build-plugin-3c71cbf0ee87?source=collection_archive---------15-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5d0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将看看Gradle插件如何在内部工作。然后，我们将构建一个自定义插件，将我们的公共配置从<em class="jd"> build.gradle.kts </em>提取到我们自己的自定义插件中。</p><p id="5856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">首先要注意的是，Gradle本身就是一个Java应用程序。Gradle项目将在我们所有的build.gradle.kts文件上运行，并执行构建操作。Gradle构建的输出是我们自己的应用程序。</em></p><p id="3ca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个Java程序都需要类路径上的依赖库。格拉德建筑也不例外。它需要所有必要的库来完成构建过程。这些库必须与我们自己的应用程序所需的库区分开来。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/7c50aa13f7e3ddf26c2f56b52b730388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*PiZdYiB6Tga3ObUw4QHhJw.png"/></div></figure><p id="4b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当Gradle运行构建时，它需要所有的Project.java、Task.java、Plugin.java等<em class="jd">类，就像当我们运行我们的Spring应用程序时，我们需要类路径上的<em class="jd"> spring-core、spring-beans </em>等库。</em></p><p id="19d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何让Gradle知道它需要<em class="jd">KotlinDslPlugin.java</em>类来构建应用程序呢？答案是我们必须明确地告诉Gradle，您需要这个类来运行构建，就像我们明确地指定<em class="jd"> spring-context </em>应该在我们的类路径中一样。</p><h2 id="9215" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">构建脚本</strong></h2><p id="8ecb" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">以前，Gradle使用<em class="jd">构建脚本</em>告诉Gradle它需要依赖jar位于构建应用程序的类路径上。这个jar可以从由<em class="jd"> repositories </em>块指定的maven仓库中取出。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="b2d4" class="jm jn hi kn b fi kr ks l kt ku">buildscript {<br/>   repositories {<br/>     maven {<br/>       url = uri("https://repo.spring.io/plugins-snapshot")     }  <br/>   }   <br/>   dependencies {<br/>     classpath("io.spring.gradle:dependency-management-plugin:1.0.10.RELEASE")   <br/>   } <br/>}  <br/>apply(plugin = "io.spring.dependency-management")</span></pre><p id="2fdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在语法简化为<em class="jd">插件{} </em>块。我们只需要将<em class="jd">插件{} </em>添加到<em class="jd"> build.gradle.kts </em>中。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="6056" class="jm jn hi kn b fi kr ks l kt ku">plugins <strong class="kn hj">{<br/></strong>    id("io.spring.dependency-management") <em class="jd">version </em>"1.0.10.RELEASE"<br/><strong class="kn hj">}</strong></span></pre><p id="b029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，Gradle将把<em class="jd">依赖管理</em> jar放到构建应用程序的类路径上，并将插件应用到我们的项目中。我们将在后面讨论当插件被应用到一个项目中时意味着什么。</p><p id="ae64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何为自己的应用程序声明依赖关系？我们在<em class="jd">构建脚本之外使用 <em class="jd">依赖关系</em>块。</em></p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="e9d2" class="jm jn hi kn b fi kr ks l kt ku"><em class="jd">dependencies </em><strong class="kn hj">{ <br/>  </strong><em class="jd">implementation</em>("org.springframework.boot:spring-boot-starter-web")<br/>}</span></pre><p id="2f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Spring应用程序中，我们的项目通常包含多个与Spring相关的依赖项。依赖关系可以分为编译时依赖关系和运行时依赖关系等。它可以被认为是两类依赖关系。也可以更多。</p><p id="9811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gradle使用<em class="jd">配置</em>作为某类依赖关系的逻辑容器。每个<em class="jd">配置</em>都有一个名称。例如，我们可以有一个名为“编译”的配置。“编译”配置包含一堆jar作为编译时依赖项。下图显示了项目、配置和依赖关系之间的关系。可以从左到右查看每个类与其他类的关系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/a26b27e9d7b5628fc1618e7b65e1ed1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onjWesSr6i1XvSRsEgvU6A.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">Handling Dependencies</figcaption></figure><p id="1f3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图我们可以看到<em class="jd">configuration . get dependencies会返回一个DependencySet。因为对于编译时或运行时，我们可能有多个jar作为依赖项。</em></p><h2 id="9684" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">储存库</strong></h2><p id="3ee7" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">Repository告诉Gradle从我们的项目中提取依赖jar的远程URL</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es le"><img src="../Images/215a85ed22254cfa48a811595e6b7d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlLsuMm_WfSvTi4ksVVDhQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">API for adding repository</figcaption></figure><h2 id="6e9b" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">分机</strong></h2><p id="d303" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated"><em class="jd">扩展</em>的目的是使领域类(项目、任务等)能够使用用户定义类的任何其他对象。只需将<em class="jd"> ExtensionContainer </em>视为一个<em class="jd">映射&lt;字符串、对象&gt;、</em>，这个映射就成为域对象(项目或任务等)<em class="jd">的一个属性。</em>通过这种方式，我们能够向地图中添加任何随机的类。轻松点。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lf"><img src="../Images/0b10bdae02566d8a24df19b8b15f8747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quew8cFlU5hCBzpgGFk9gQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">API for add and get Extension</figcaption></figure><h2 id="b8ed" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">插件</strong></h2><p id="6c01" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">Plugin可以被认为是一个助手类，在这个类中，我们将前面提到的API应用于<em class="jd">项目。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lg"><img src="../Images/1802699e4f5e00eeef4f0982ebeaff20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUOfFgVUEMkNlcX81ijK9w.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">API for apply plugin on project</figcaption></figure><h2 id="51d5" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">实验</strong></h2><p id="2ad7" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">目标:在大多数Spring云应用程序中，我们必须将以下插件应用到我们所有的web应用程序中。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="d7f5" class="jm jn hi kn b fi kr ks l kt ku">plugins {<br/>  java<br/>  id("org.springframework.boot") version "2.4.3" <br/>  id "io.spring.dependency-management" version &lt;&lt;version&gt;&gt;<br/>}</span></pre><p id="b5f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望将上述逻辑提取到我们的自定义插件中。所以我们可以为每个项目应用我们自己的插件。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="74ef" class="jm jn hi kn b fi kr ks l kt ku">plugins {<br/>  <em class="jd">id(“com.qiusuo.common”)</em><br/>}</span></pre><p id="0e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在自定义插件中，我们以编程方式应用其他插件。这也是插件内部工作的方式。</p><h2 id="2b61" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated"><strong class="ak">开动火车</strong></h2><p id="b5ca" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">创建<strong class="ih hj"> gradledemo </strong>项目</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lh"><img src="../Images/f1242d747918efee5e4b78f9ec33a678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48YsQml7zDPnrsCtNoamGQ.png"/></div></div></figure><p id="842e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将项目加载到Intellij中，并创建一个虚拟helloworld控制器。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="dfda" class="jm jn hi kn b fi kr ks l kt ku">@RestController<br/>@RequestMapping(<strong class="kn hj">"/helloworld"</strong>)<br/><strong class="kn hj">class </strong>HelloWorldController {<br/>    @RequestMapping<br/>    <strong class="kn hj">fun </strong>posts(): Mono&lt;String&gt; {<br/>        <strong class="kn hj">return </strong>Mono.just(<strong class="kn hj">"hello world"</strong>);<br/>    }<br/>}</span></pre><p id="f1ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在<strong class="ih hj"> gradledemo </strong>项目下，创建一个文件夹<strong class="ih hj"> buildSrc </strong>，再创建一个<em class="jd"> build.gradle.kts </em>文件。我们将把以下内容添加到<em class="jd"> build.gradle.kts </em>中。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="9179" class="jm jn hi kn b fi kr ks l kt ku">plugins <strong class="kn hj">{<br/>    </strong><em class="jd">`kotlin-dsl`<br/></em><strong class="kn hj">}<br/><br/></strong><em class="jd">repositories </em><strong class="kn hj">{<br/>    </strong>mavenCentral()<br/>    jcenter()<br/>    maven <strong class="kn hj">{ </strong>setUrl(<strong class="kn hj">"https://plugins.gradle.org/m2/"</strong>) <strong class="kn hj">}<br/>}</strong></span></pre><p id="81c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Intellij会自动将其识别为新项目。我们将在包<em class="jd"> com.qiusuo. </em>下创建插件类，并将以下内容添加到build.gradle.kts中</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="10d6" class="jm jn hi kn b fi kr ks l kt ku"><em class="jd">dependencies </em><strong class="kn hj">{<br/>    </strong><em class="jd">implementation</em>(<strong class="kn hj">"org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.31"</strong>)<br/>    <em class="jd">implementation</em>(<strong class="kn hj">"io.spring.dependency-management:io.spring.dependency-management.gradle.plugin:1.0.10.RELEASE"</strong>)<br/>    <em class="jd">implementation</em>(group = <strong class="kn hj">"org.springframework.boot"</strong>, name = <strong class="kn hj">"spring-boot-gradle-plugin"</strong>, version = <strong class="kn hj">"2.4.3"</strong>)<br/><strong class="kn hj">}</strong></span></pre><p id="06fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里做的只是添加插件jar作为我们的<strong class="ih hj"> buildSrc </strong>项目的依赖项。这样，我们能够在源代码中使用不同的插件类。把它看作一个普通的java应用程序。</p><p id="4644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们在包<em class="jd"> com.qiusuo. </em>下创建一个<em class="jd"> QiuSuoPlugin.kt </em></p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="fd2e" class="jm jn hi kn b fi kr ks l kt ku"><strong class="kn hj">class </strong>QiuSuoPlugin : Plugin&lt;Project&gt; {<br/>    <strong class="kn hj">override fun </strong>apply(target: Project) {<br/>        target.<em class="jd">configurePlugins</em>()<br/>        target.<em class="jd">configureRepositories</em>()<br/>    }<br/>}<br/><br/><strong class="kn hj">fun </strong>Project.configurePlugins() {<br/>    <em class="jd">pluginManager</em>.apply(SpringBootPlugin::<strong class="kn hj">class</strong>.<em class="jd">java</em>)<br/>    <em class="jd">pluginManager</em>.apply(DependencyManagementPlugin::<strong class="kn hj">class</strong>.<em class="jd">java</em>)<br/>    <em class="jd">pluginManager</em>.apply(JavaPlugin::<strong class="kn hj">class</strong>.<em class="jd">java</em>)<br/>    <em class="jd">pluginManager</em>.apply(ApplicationPlugin::<strong class="kn hj">class</strong>.<em class="jd">java</em>)<br/>}<br/><br/><strong class="kn hj">fun </strong>Project.configureRepositories() {<br/>    <em class="jd">repositories</em>.mavenLocal()<br/>    <em class="jd">repositories</em>.mavenCentral()<br/>    <em class="jd">repositories</em>.jcenter()<br/>}</span></pre><p id="59dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个文件的内容是不言自明的。我们使用前面的界面来配置目标项目对象。我们将<em class="jd"> SpringBootPlugin、DependencyManagementPlugin、JavaPlugin和ApplicationPlugin </em>应用于目标项目。</p><p id="bac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只需要<em class="jd">gradledemo/build . gradle . kts</em>文件中的以下代码，就可以将我们的插件应用到<strong class="ih hj"> gradledemo </strong>项目中</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="b0ce" class="jm jn hi kn b fi kr ks l kt ku">plugins {<br/>  id(<strong class="kn hj">"com.qiusuo.common"</strong>)<br/>}</span></pre><p id="4ae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插件块的效果现在非常明显了。当这个块被应用到某个项目时，会调用<em class="jd"> apply(target: Project) </em>函数对项目执行一些自定义动作。</p><p id="1e7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你阅读其他插件的源代码，你会发现他们所做的也是使用Gradle提供的API来应用插件或添加扩展或向项目添加任务。比如<em class="jd"> kotlin-dsl </em>插件源代码是这样的。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="ae79" class="jm jn hi kn b fi kr ks l kt ku">class KotlinDslPlugin : Plugin&lt;Project&gt; {<br/>     override fun apply(project: Project): Unit = project.run <br/>    {        <br/>      apply&lt;JavaGradlePluginPlugin&gt;()      <br/>      apply&lt;KotlinDslBasePlugin&gt;()<br/>      apply&lt;PrecompiledScriptPlugins&gt;()   <br/>    }<br/>}</span></pre><p id="5007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在下面的github repo中找到这个演示的源代码</p><p id="ab2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae li" href="https://github.com/ryan-zheng-teki/kotlin-gradle-plugin-demo" rel="noopener ugc nofollow" target="_blank">https://github . com/Ryan-Zheng-teki/kot Lin-grad le-plugin-demo</a></p></div></div>    
</body>
</html>
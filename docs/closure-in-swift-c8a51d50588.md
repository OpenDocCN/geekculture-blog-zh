# Swift 中的关闭

> 原文：<https://medium.com/geekculture/closure-in-swift-c8a51d50588?source=collection_archive---------9----------------------->

![](img/328a2b46802a37c7b7046efa84106433.png)

闭包是自包含的功能块，可以在我们的代码中传递和使用。Swift 中的闭包类似于 C 和 Objective-C 中的块以及其他编程语言中的 lambdas。

## **T3【swift.org】T5**

闭包是非常强大的工具，但是如果我们不能使用它们，它们不会给我们带来什么好处。

*   闭包是一个函数和" *func* 关键字
*   闭包是我们可以赋给变量的代码块。
*   在 Swift 变量" *var* "和常量" *let* "存储信息，函数" *func* "执行任务和闭包有一个变量形式的功能代码，可以传递。

**闭包表达式语法**

**闭包表达式语法具有以下一般形式:**

{(参数)->返回输入

声明

}

*   闭包表达式语法中的*参数*可以是 in-out 参数，但不能有默认值。
*   如果我们命名可变参数，就可以使用可变参数。
*   元组也可以用作参数类型和返回类型。
*   闭包变量可以引用一个位置，即$0，$1，$2，$3 等等。

**接受参数并返回值的闭包**

> *var addTwoNumbers: (Int，Int) - > Int = {*
> 
> *返回$0 + $1*
> 
> *}*
> 
> *两个数字相加(2，3)*
> 
> *打印(" Sum is \(addTwoNumbers(2，3))"*

**输出:5**

**不接受参数并返回值的闭包**

> var 闭包:()->Int = {
> 
> 返回 5
> 
> }
> 
> var 值=闭包()
> 
> 打印(值)

**输出:5**

**没有参数或返回值的闭包**

> var myClosure = {
> 
> 印刷(“封闭概念”)
> 
> }
> 
> func print closure(printString:String){
> 
> myClosure()
> 
> }
> 
> print Closure(printString:"**闭包概念")**

****输出:关闭概念****

****尾随闭包****

**如果我们需要将闭包表达式作为函数的最终参数传递给函数，并且闭包表达式很长，那么将其编写为*结尾闭包*会很有用。我们在函数调用的括号后面写一个尾随闭包，即使尾随闭包仍然是函数的一个参数。当我们使用结尾闭包语法时，我们不会将第一个闭包的参数标签作为函数调用的一部分。一个函数调用可以包含多个尾随闭包；然而，下面的前几个例子使用了一个尾随闭包。**

> **func swiftTrailingClosure(closure:()-> Void){**
> 
> **//这里是函数体**
> 
> **}**
> 
> **func swiftTrailingClosure(闭包:{**
> 
> **// closure 的主体在这里**
> 
> **})**
> 
> **func swiftTrailingClosure() {**
> 
> **// closure 的主体在这里**
> 
> **}**

****非逃逸闭合:****

**非转义闭包告诉编译器，我们传入的**闭包将在**函数体内执行，而不会在其他地方执行。**

**@nonescaping 闭包的生命周期，**

*   **在函数调用期间，将闭包作为函数参数传递。**
*   **用函数做一些额外的工作。**
*   **该函数运行闭包。**
*   **该函数返回编译器。**

****举例:****

> **func getSumOf(array:[Int]，handler: ((Int)->Void)) {**
> 
> **var sum: Int = 0**
> 
> ****为数组中的**值{**
> 
> **总和+=值**
> 
> **}**
> 
> **处理程序(总和)**
> 
> **}**
> 
> **func getTheResult() {**
> 
> **self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in**
> 
> **print(sum) //结束执行**
> 
> **}**
> 
> **}**

**//它将打印所有给定数字的总和。**

**在上面的例子中，我们只是用闭包调用了在函数体末尾执行的函数。因此，我们并没有逃避闭包的执行。完成后，执行闭包将在内存中不存在。**

****逃脱关闭:****

**转义闭包是在传递给返回的函数后被调用的闭包。换句话说，它比传递给它的函数存在的时间更长。**

**当我们声明一个将闭包作为参数之一的函数时，我们可以在参数的类型前写@escaping 来表示闭包被允许转义。有几种方法可以摆脱封闭:**

*   ***存储:* 当我们需要在内存中保存闭包时，调用函数的一部分得到执行并返回编译器。(像等 API 一样。)**
*   ***异步执行:* 当我们在调度队列上异步执行闭包时，队列会将闭包保存在内存中供我们将来使用。在这种情况下，我们不知道何时执行闭包。**

**@escaping 闭包的生命周期:**

*   **在函数调用期间，将闭包作为函数参数传递。**
*   **在函数中做一些额外的工作。**
*   **函数要么异步执行闭包，要么存储闭包。**
*   **函数返回到编译器。**

****存储:****

> **var compliance handler:((Int)-> Void)？**
> 
> **func getSumOf(array:[Int]，handler:@ escaping((Int)-> Void)){**
> 
> **var sum: Int = 0**
> 
> ****为数组中的**值{**
> 
> **总和+=值**
> 
> **}**
> 
> **处理程序(总和)**
> 
> **self.complitionHandler =处理程序**
> 
> **}**
> 
> **func getTheResult() {**
> 
> **self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in**
> 
> **打印(总和)**
> 
> **//结束执行**
> 
> **}**
> 
> **}**

**//我们在这里存储闭包以备将来使用。**

**//它将打印所有传递的数字的总和。**

****异步执行:****

**func getSumOf(array:[Int]，handler:@ escaping((Int)-> Void)){**

**var sum: Int = 0**

****为数组中的**值{**

**总和+=值**

**}**

**Globals.delay(0.3，闭包:{**

**处理程序(总和)**

**})**

**}**

**func getTheResult() {**

**self.getSumOf(array: [16，756，442，6，23]){[弱自我](sum) in**

**打印(总和)**

**//结束执行**

**}**

**}**

**//这里我们调用延迟 0.3 秒的闭包**

**//它将打印所有传递的数字的总和。**

****为什么非转义闭包是默认选项****

**将非转义闭包作为默认选项有很多好处。最重要的好处是编译器的性能和代码优化，因为如果编译器知道闭包是不可转义的，它会负责闭包的内存分配。**

**另一个原因是，我们可以自己在非转义闭包中使用这个方法，因为闭包在函数返回之前执行。这样，自我肯定会在那里。我们不需要使用虚弱的自我，因为这是一个额外的特征。**

*****快乐编码……*****